- en: Chapter 10. Getting Your Setup Just Right
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章：精确调整你的配置
- en: '![Getting Your Setup Just Right](httpatomoreillycomsourcenostarchimages2127149.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![精确调整你的配置](httpatomoreillycomsourcenostarchimages2127149.png.jpg)'
- en: By now, you’ve spent significant time designing your network and implementing
    that design in your PF configuration. Getting your setup just right—that is, removing
    any remaining setup bugs and inefficiencies—can be quite challenging at times.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经花费了大量时间设计你的网络并在 PF 配置中实现这个设计。将配置调整到完美——也就是说，消除任何剩余的配置错误和低效——有时可能非常具有挑战性。
- en: This chapter describes options and methods that will help you get the setup
    you need. First, we’ll take a look at global options and settings that can have
    a profound influence on how your configuration behaves.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了将帮助你获得所需配置的选项和方法。首先，我们将查看一些全球性选项和设置，它们会对配置的行为产生深远的影响。
- en: Things You Can Tweak and What You Probably Should Leave Alone
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你可以调整的内容和你可能不应该轻易更改的内容
- en: Network configurations are inherently very tweakable. While browsing the `pf.conf`
    man page or other reference documentation, it’s easy to be overwhelmed by the
    number of options and settings that you could conceivably adjust in order to get
    that perfectly optimized setup.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 网络配置本质上是非常可调的。在浏览 `pf.conf` 手册页或其他参考文档时，你可能会被可以调整的选项和设置的数量所淹没，以便获得一个完美优化的配置。
- en: Keep in mind that for PF in general, *the defaults* are sane for most setups.
    Some settings and variables lend themselves to tuning; others should come with
    a big warning that they should be adjusted only in highly unusual circumstances,
    if at all.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对于 PF 来说，*默认设置*对于大多数配置来说是合理的。有些设置和变量适合调优；其他设置则应附带一个大警告，表示只有在非常特殊的情况下，才应该进行调整（如果有必要的话）。
- en: Here, we’ll look at some of the global settings that you should know about,
    although you won’t need to change them in most circumstances.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看看一些你应该了解的全局设置，尽管在大多数情况下你不需要更改它们。
- en: These options are written as `set` *`option setting`* and go *after* any macro
    definitions in your *pf.conf* file but *before* translation or filtering rules.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项以 `set` *`选项设置`* 形式写出，并且要*放在*任何宏定义之后，*但在*翻译或过滤规则之前。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you read the `pf.conf` man page, you’ll discover that a few other options
    are available. However, most of those aren’t relevant in a network-testing and
    performance-tuning context.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你阅读 `pf.conf` 手册页，你会发现还有一些其他选项。然而，大多数选项在网络测试和性能调优的上下文中并不相关。*'
- en: Block Policy
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阻止策略
- en: 'The `block-policy` option determines which feedback, if any, PF will give to
    hosts that try to create connections that are subsequently blocked. The option
    has two possible values:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`block-policy` 选项决定了 PF 是否会向尝试创建连接但被随后阻止的主机提供反馈。如果提供反馈，该选项有两个可能的值：'
- en: '`drop` drops blocked packets with no feedback.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drop` 在没有反馈的情况下丢弃被阻止的数据包。'
- en: '`return` returns with status codes, such as `Connection refused` or similar.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return` 用状态码返回，例如 `Connection refused` 或类似信息。'
- en: 'The correct strategy for block policies has been the subject of considerable
    discussion over the years. The default setting for `block-policy` is `drop`, which
    means that the packet is silently dropped without any feedback. Silently dropping
    packets, however, makes it likely that the sender will resend the unacknowledged
    packets rather than drop the connection. Thus, the sender may keep up the effort
    until the relevant timeout counter expires. If you don’t want this behavior to
    be the default in your setup, set the block policy to `return`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止策略的正确策略多年来一直是一个备受讨论的话题。`block-policy` 的默认设置是 `drop`，这意味着数据包会被静默丢弃，没有任何反馈。然而，静默丢弃数据包会让发送方可能重新发送那些未确认的数据包，而不是断开连接。因此，发送方可能会继续发送，直到相关的超时计数器到期。如果你不希望这种行为成为默认设置，可以将阻止策略设置为
    `return`：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This setting means that the sender’s networking stack will receive an unambiguous
    signal indicating that the connection was refused.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置意味着发送方的网络堆栈将收到一个明确的信号，表示连接被拒绝。
- en: Whichever `block-policy` option you use will specify the *global* default for
    your block policy. If necessary, however, you can still vary the blocking type
    for specific rules. For example, you could change the brute-force protection rule
    set from [Chapter 6](ch06.html "Chapter 6. Turning the Tables for Proactive Defense")
    to set `block-policy` to `return` but also use `block drop quick from <bruteforce>`
    to make the brute forcers waste time if they stick around once they’ve been added
    to the `<bruteforce>` table. You could also specify `drop` for traffic from nonroutable
    addresses coming in on your Internet-facing interface or other clearly nondesirable
    traffic, such as attempts to enlist your gear in amplifying a distributed denial-of-service
    (DDoS) attack.^([[49](#ftn.ch10fn01)])
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用哪种`block-policy`选项，它都会指定*全局*默认的阻塞策略。然而，如果需要，你仍然可以为特定规则修改阻塞类型。例如，你可以将暴力破解保护规则集从[第6章](ch06.html
    "第6章：主动防御的反击")更改为将`block-policy`设置为`return`，但也可以使用`block drop quick from <bruteforce>`来让暴力破解者浪费时间，如果他们在被添加到`<bruteforce>`表后还继续停留。你还可以为来自不可路由地址的流量指定`drop`，这些流量通过你的面向互联网的接口进入，或者其他明显不受欢迎的流量，例如尝试将你的设备用于放大分布式拒绝服务（DDoS）攻击。^([[49](#ftn.ch10fn01)])
- en: Skip Interfaces
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳过接口
- en: 'The `skip` option lets you exclude specific interfaces from all PF processing.
    The net effect is like a `pass-all` rule for the interface, but it actually disables
    all PF processing on the interface. For example, you can use this option to disable
    filtering on the loopback interface group, where filtering in most configurations
    adds little in terms of security or convenience:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`skip`选项让你将特定接口排除在所有PF处理之外。其效果类似于该接口上的`pass-all`规则，但实际上它禁用了该接口上的所有PF处理。例如，你可以使用此选项来禁用回环接口组的过滤，在大多数配置中，在该接口上进行过滤对于安全性或便利性几乎没有帮助：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In fact, filtering on the loopback interface is almost never useful, and it
    can lead to odd results with a number of common programs and services. The default
    is that `skip` is unset, which means that all configured interfaces can take part
    in PF processing. In addition to making your rule set slightly simpler, setting
    `skip` on interfaces where you don’t want to perform filtering results in a slight
    performance gain.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在回环接口上进行过滤几乎没有任何用处，而且可能会导致一些常见程序和服务出现奇怪的结果。默认情况下，`skip`未设置，这意味着所有配置的接口都可以参与PF处理。除了让规则集稍微简化之外，在不需要过滤的接口上设置`skip`会带来轻微的性能提升。
- en: State Policy
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态策略
- en: 'The `state-policy` option specifies how PF matches packets to the state table.
    It has two possible values:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`state-policy`选项指定PF如何将数据包与状态表匹配。它有两个可能的值：'
- en: With the default `floating` state policy, traffic can match state on all interfaces,
    not just the one where the state was created.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认的`floating`状态策略，流量可以在所有接口上匹配状态，而不仅仅是状态创建的那个接口。
- en: With an `if-bound` policy, traffic will match only on the interface where the
    state is created; traffic on other interfaces will not match the existing state.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`if-bound`策略时，流量将只在创建状态的接口上匹配；其他接口上的流量将无法匹配现有的状态。
- en: 'Like the `block-policy` option, this option specifies the global state-matching
    policy, but you can override the state-matching policy on a per-rule basis if
    needed. For example, in a rule set with the default `floating` policy, you could
    have a rule like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与`block-policy`选项类似，此选项指定全局的状态匹配策略，但如果需要，你可以在每条规则的基础上覆盖状态匹配策略。例如，在使用默认`floating`策略的规则集中，你可以有如下规则：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this rule, any return traffic trying to pass back in would need to pass
    on the same interface where the state was created in order to match the state-table
    entry.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此规则，任何尝试重新进入的返回流量必须通过创建状态的相同接口才能匹配状态表条目。
- en: The situations in which an `if-bound` policy is useful are rare enough that
    you should leave this setting at the default.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`if-bound`策略有用的情况非常少，因此你应该将此设置保留为默认值。'
- en: State Defaults
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态默认
- en: Introduced in OpenBSD 4.5, the `state-defaults` option enables you to set specific
    state options as the default options for all rules in the rule set—unless those
    state options are specifically overridden by other options in individual rules.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenBSD 4.5中引入的`state-defaults`选项使你可以将特定的状态选项设置为规则集中所有规则的默认选项——除非这些状态选项在单个规则中被其他选项显式覆盖。
- en: 'Here’s a common example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见的例子：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This option sets up all `pass` rules in the configuration to generate NetFlow
    data to be exported via a `pflow` device.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该选项设置配置中的所有`pass`规则，以生成通过`pflow`设备导出的NetFlow数据。
- en: 'In some contexts, it makes sense to apply state-tracking options, such as connection
    limits, as a global state default for the entire rule set. Here’s an example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，将状态跟踪选项（例如连接限制）作为全局状态默认值应用于整个规则集是有意义的。以下是一个示例：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This option sets the default maximum number of state entries per rule to 1,500,
    with a maximum of 100 simultaneous connections from any one host and with separate
    limits for each rule in the loaded rule set.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项将每条规则的默认最大状态条目数设置为 1,500，单个主机的最大并发连接数为 100，并且每个加载的规则集中的每条规则都有单独的限制。
- en: Any option that’s valid inside parentheses for `keep state` in an individual
    rule can also be included in a `set state-defaults` statement. Setting state defaults
    in this way is useful if there are state options that aren’t already system defaults
    that you want to apply to all rules in your configuration.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `keep state` 中的任何有效选项，它们也可以包含在 `set state-defaults` 语句中。如果有一些状态选项不是系统默认的，但您希望将其应用于配置中的所有规则，使用这种方式设置状态默认值是很有用的。
- en: Timeouts
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超时
- en: The `timeout` option sets the timeouts and related options for various interactions
    with the state-table entries. The majority of the available parameters are protocol-specific
    values stored in seconds and prefixed `tcp.`, `udp.`, `icmp.`, and `other.`. However,
    `adaptive.start` and `adaptive.end` denote the number of state-table entries.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeout` 选项设置了与状态表条目相关的超时和相关选项。大多数可用的参数是特定于协议的值，以秒为单位存储，并以 `tcp.`、`udp.`、`icmp.`
    和 `other.` 为前缀。然而，`adaptive.start` 和 `adaptive.end` 表示状态表条目的数量。'
- en: 'The following `timeout` options affect state-table memory use and, to some
    extent, lookup speed:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `timeout` 选项会影响状态表的内存使用和在一定程度上的查找速度：
- en: The `adaptive.start` and `adaptive.end` values set the limits for scaling down
    timeout values once the number of state entries reaches the `adaptive.start` value.
    When the number of states reaches `adaptive.end`, all timeouts are set to 0, essentially
    expiring all states immediately. The defaults are 6,000 and 12,000 (calculated
    as 60 percent and 120 percent of the state limit, respectively). These settings
    are intimately related to the memory-pool limit parameters you set via the `limit`
    option.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adaptive.start` 和 `adaptive.end` 值设置了当状态条目数量达到 `adaptive.start` 值后，超时值缩减的限制。当状态数量达到
    `adaptive.end` 时，所有超时都被设置为 0，实际上立即使所有状态过期。默认值为 6,000 和 12,000（分别计算为状态限制的 60% 和
    120%）。这些设置与通过 `limit` 选项设置的内存池限制参数密切相关。'
- en: The `interval` value denotes the number of seconds between purges of expired
    states and fragments. The default is 10 seconds.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interval` 值表示清除过期状态和片段之间的秒数。默认值为 10 秒。'
- en: The `frag` value denotes the number of seconds a fragment will be kept in an
    unassembled state before it’s discarded. The default is 30 seconds.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frag` 值表示在丢弃之前，片段将保持在未组装状态的秒数。默认值为 30 秒。'
- en: When set, `src.track` denotes the number of seconds source-tracking data will
    be kept after the last state has expired. The default is 0 seconds.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置后，`src.track` 表示源跟踪数据将在最后一个状态过期后保持的秒数。默认值为 0 秒。
- en: 'You can inspect the current settings for all `timeout` parameters with `pfctl
    -s timeouts`. For example, the following display shows a system running with default
    values:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过 `pfctl -s timeouts` 检查所有 `timeout` 参数的当前设置。例如，以下显示了一个使用默认值运行的系统：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These options can be used to tweak your setup for performance. However, changing
    the protocol-specific settings from the default values creates a significant risk
    that valid but idle connections might be dropped prematurely or blocked outright.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项可以用来调整您的设置以优化性能。然而，从默认值更改协议特定的设置会带来一定的风险，因为有效但空闲的连接可能会被过早丢弃或直接阻止。
- en: Limits
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制
- en: The `limit` option sets the size of the memory pools PF uses for state tables
    and address tables. These are hard limits, so you may need to increase or tune
    the values for various reasons. If your network is a busy one with larger numbers
    than the default values allow for, or if your setup requires large address tables
    or a large number of tables, then this section will be very relevant to you.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`limit` 选项设置 PF 用于状态表和地址表的内存池大小。这些是硬性限制，因此您可能需要根据各种原因增加或调整这些值。如果您的网络繁忙，且需要的数量超过了默认值的限制，或者如果您的设置需要较大的地址表或大量的表，那么本节将非常相关。'
- en: Keep in mind that the total amount of memory available through memory pools
    is taken from the *kernel memory space*, and the total available is a function
    of total available kernel memory. Kernel memory is to some extent dynamic, but
    the amount of memory allocated to the kernel can never equal or exceed all physical
    memory in the system. (If that happened, there would be no space for user-mode
    programs to run.)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，通过内存池可用的总内存量来自*内核内存空间*，而总可用量是总可用内核内存的函数。内核内存在一定程度上是动态的，但分配给内核的内存量永远不能等于或超过系统中的所有物理内存。
    （如果发生这种情况，将没有空间运行用户模式程序。）
- en: The amount of available pool memory depends on which hardware platform you use
    as well as on a number of hard-to-predict variables specific to the local system.
    On the i386 architecture, the maximum kernel memory is in the 768MB to 1GB range,
    depending on a number of factors, including the number and kind of hardware devices
    in the system. The amount actually available for allocation to memory pools comes
    out of this total, again depending on a number of system-specific variables.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 可用池内存量取决于您使用的硬件平台以及特定于本地系统的一些难以预测的变量。在i386架构上，最大内核内存在768MB至1GB范围内，这取决于多种因素，包括系统中的硬件设备数量和类型。实际可用于内存池分配的数量来自这个总数，同样取决于一些特定于系统的变量。
- en: 'To inspect the current `limit` settings, use `pfctl -sm`. Typical output looks
    like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查当前的`limit`设置，请使用`pfctl -sm`。典型的输出如下：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To change these values, edit *pf.conf* to include one or more lines with new
    `limit` values. For example, you could use the following lines to raise the hard
    limit for the number of states to 25,000 and for the number of table entries to
    300,000:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改这些值，请编辑*pf.conf*以包括一个或多个包含新`limit`值的行。例如，您可以使用以下行提高状态数的硬限制到25,000，并将表条目数的硬限制提高到300,000：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also set several `limit` parameters at the same time in a single line
    by enclosing them in brackets:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在单行中通过括号同时设置多个`limit`参数：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the end, other than possibly increasing these three parameters for larger
    installations, you almost certainly shouldn’t change the limits at all. If you
    do, however, it’s important to watch your system logs for any indication that
    your changed limits have undesirable side effects or don’t fit in available memory.
    Setting the `debug` level to a higher value is potentially quite useful for watching
    the effects of tuning `limit` parameters.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，除非为较大的安装可能增加这三个参数，否则你几乎肯定不应该改变任何限制。然而，如果确实这样做，监视系统日志以获取任何指示您更改的限制具有不良副作用或不适合可用内存的迹象是非常重要的。将`debug`级别设置为更高值对于观察调整`limit`参数的效果可能非常有用。
- en: Debug
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试
- en: The `debug` option determines what, if any, error information PF will generate
    at the *kern.debug* log level. The default value is `err`, which means that only
    serious errors will be logged. Since OpenBSD 4.7, the log levels here correspond
    to the ordinary `syslog` levels, which range from `emerg` (panics are logged),
    `alert` (correctable but very serious errors are logged), `crit` (critical conditions
    are logged), and `err` (errors are logged) to `warning` (warnings are logged),
    `notice` (unusual conditions are logged), `info` (informational messages are logged),
    and `debug` (full debugging information, likely only useful to developers, is
    logged).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`debug`选项决定了PF在*kern.debug*日志级别下生成的错误信息（如果有）。默认值为`err`，意味着只记录严重错误。自OpenBSD
    4.7以来，这里的日志级别对应于常规`syslog`级别，从`emerg`（记录紧急情况）、`alert`（可更正但非常严重的错误）、`crit`（记录关键条件）、`err`（记录错误）到`warning`（记录警告）、`notice`（记录异常情况）、`info`（记录信息消息）和`debug`（记录完整调试信息，可能只对开发人员有用）。'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In pre–OpenBSD 4.7 versions, PF used its own log-level system, with a default
    of `urgent` (equivalent to `err` in the new system). The other possible settings
    were `none` (no messages), `misc` (reporting slightly more than `urgent`), and
    `loud` (producing status messages for most operations). The `pfctl` parser still
    accepts the older-style debug levels for compatibility.*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*在OpenBSD 4.7之前的版本中，PF使用其自己的日志级别系统，默认为`urgent`（相当于新系统中的`err`）。其他可能的设置包括`none`（无消息）、`misc`（比`urgent`稍多报告）、`loud`（对大多数操作生成状态消息）。为了兼容性，`pfctl`解析器仍然接受旧式调试级别。*'
- en: 'After one of my gateways ran at the `debug` level for a while, this is what
    a typical chunk of the */var/log/messages* file looked like:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的一个网关以`debug`级别运行了一段时间后，*/var/log/messages*文件的一个典型块看起来是这样的：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At the `debug` level, PF repeatedly reports the IP address for the interface
    it’s currently handling. In between the selected address messages, PF warns twice
    for the same packet that the sequence number is at the very edge of the expected
    range. This level of detail seems a bit overwhelming at first glance, but in some
    circumstances, studying this kind of output is the best way to diagnose a problem
    and later to check to see whether your solution helped.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`debug`级别，PF会重复报告当前正在处理的接口的IP地址。在选择的地址信息之间，PF会对同一数据包发出两次警告，提示序列号处于期望范围的边缘。初看起来，这种详细级别似乎有点压倒性，但在某些情况下，研究这种输出是诊断问题的最佳方法，之后还可以检查是否你的解决方案起到了作用。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*This option can be set from the command line with `pfctl -x`, followed by
    the debug level you want. The command `pfctl -x debug` gives you maximum debugging
    information; `pfctl -x none` turns off debug messages entirely.*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*此选项可以通过命令行使用`pfctl -x`设置，后跟你想要的调试级别。命令`pfctl -x debug`将提供最大调试信息；`pfctl -x
    none`会完全关闭调试消息。*'
- en: Keep in mind that some `debug` settings can produce large amounts of log data
    and, in extreme cases, could impact performance all the way to self-denial-of-service
    level.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，一些`debug`设置可能会产生大量日志数据，在极端情况下，可能会影响性能，甚至达到自我拒绝服务的程度。
- en: Rule Set Optimization
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则集优化
- en: 'The `ruleset-optimization` option enables or sets the mode for the rule set
    optimizer. The default setting for `ruleset-optimization` in OpenBSD 4.1 and equivalents
    is `none`, which means that no rule set optimization is performed at load time.
    From OpenBSD 4.2 onward, the default is `basic`, which means that when the rule
    set loads, the optimizer performs the following actions:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`ruleset-optimization`选项启用或设置规则集优化器的模式。OpenBSD 4.1及等效版本中，`ruleset-optimization`的默认设置为`none`，这意味着在加载时不执行规则集优化。从OpenBSD
    4.2开始，默认设置为`basic`，这意味着在规则集加载时，优化器会执行以下操作：'
- en: Removes duplicate rules
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除重复的规则
- en: Removes rules that are subsets of other rules
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除作为其他规则子集的规则
- en: Merges rules into tables if appropriate (typical rule-to-table optimizations
    are rules that pass, redirect, or block based on identical criteria, except source
    and/or target addresses)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果适合，合并规则到表中（典型的规则到表优化是根据相同标准（源和/或目标地址除外）来进行传递、重定向或阻止的规则）
- en: Changes the order of rules to improve performance
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改规则顺序以提高性能
- en: For example, say you have the macro `tcp_services = { ssh, www, https }` combined
    with the rule `pass proto tcp from any to self port $tcp_services`. Elsewhere
    in your rule set, you have a different rule that says `pass proto tcp from any
    to self port ssh`. The second rule is clearly a subset of the first, and they
    can be merged into one. Another common combination is having a `pass` rule like
    `pass proto tcp from any to int_if:network port $tcp_services` with otherwise
    identical `pass` rules, where the target addresses are all in the `int_if:network`
    range.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有宏`tcp_services = { ssh, www, https }`，并结合规则`pass proto tcp from any to
    self port $tcp_services`。在规则集中其他地方，你还有一个不同的规则，表示`pass proto tcp from any to self
    port ssh`。第二个规则显然是第一个规则的子集，它们可以合并为一个。另一个常见的组合是有一个`pass`规则，如`pass proto tcp from
    any to int_if:network port $tcp_services`，其余的`pass`规则相同，目标地址都在`int_if:network`范围内。
- en: With `ruleset-optimization` set to `profile`, the optimizer analyzes the loaded
    rule set relative to network traffic in order to determine the optimal order of
    `quick` rules.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ruleset-optimization`设置为`profile`时，优化器会根据网络流量分析已加载的规则集，以确定`quick`规则的最佳顺序。
- en: 'You can also set the value of the optimization option from the command line
    with `pfctl`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过命令行使用`pfctl`设置优化选项的值：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This example enables the rule set optimization in `basic` mode.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例启用`basic`模式下的规则集优化。
- en: Because the optimization may remove or reorder rules, the meaning of some statistics—mainly
    the number of evaluations per rule—may change in ways that are hard to predict.
    In most cases, however, the effect is negligible.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于优化可能会移除或重新排序规则，因此某些统计数据的含义—主要是每条规则的评估次数—可能会以难以预测的方式发生变化。然而，在大多数情况下，效果是微不足道的。
- en: Optimization
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化
- en: The `optimization` option specifies profiles for state-timeout handling. The
    possible values are `normal`, `high-latency`, `satellite`, `aggressive`, and `conservative`.
    The recommendation is to keep the default `normal` setting unless you have very
    specific needs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`optimization`选项指定用于状态超时处理的配置文件。可选值包括`normal`、`high-latency`、`satellite`、`aggressive`和`conservative`。建议保持默认的`normal`设置，除非你有非常特定的需求。'
- en: The values `high-latency` and `satellite` are synonyms; with these values, states
    expire more slowly in order to compensate for potential high latency.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`high-latency` 和 `satellite` 是同义词；使用这些值时，状态会更慢地过期，以补偿潜在的高延迟。'
- en: The `aggressive` setting expires states early in order to save memory. This
    could, in principle, increase the risk of dropping idle-but-valid connections
    if your system is already close to its load and traffic limits, but anecdotal
    evidence indicates that the `aggressive` optimization setting rarely, if ever,
    interferes with valid traffic.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`aggressive` 设置会提前过期状态以节省内存。原则上，这可能会增加丢弃空闲但有效连接的风险，尤其是在系统已经接近负载和流量极限时，但根据经验，`aggressive`
    优化设置很少，甚至从未干扰有效流量。'
- en: The `conservative` setting goes to great lengths to preserve states and idle
    connections, at the cost of some additional memory use.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`conservative` 设置尽可能地保留状态和空闲连接，代价是会增加一些内存使用。'
- en: Fragment Reassembly
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 碎片重组
- en: The fragment reassembly options tied to `scrub` were significantly reworked
    in OpenBSD 4.6, which introduced the new `set reassemble` option to turn reassembly
    of fragmented packets on or off. If `reassemble` is set to `off`, fragmented packets
    are simply dropped unless they match a rule with the `fragment` option. The default
    is `set reassemble on`, which means that fragments are reassembled and that reassembled
    packets in which the do-not-fragment bit was set on individual fragments will
    have the bit cleared.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `scrub` 相关的碎片重组选项在 OpenBSD 4.6 中进行了显著的重构，引入了新的 `set reassemble` 选项，用于开启或关闭碎片包的重组。如果
    `reassemble` 设置为 `off`，则碎片包会被丢弃，除非它们匹配一个包含 `fragment` 选项的规则。默认设置是 `set reassemble
    on`，这意味着碎片包会被重组，且在重组后的包中，原本在单个碎片上设置的不分片位会被清除。
- en: Cleaning Up Your Traffic
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理你的流量
- en: 'The next two features we’ll discuss, `scrub` and `antispoof`, share a common
    theme: They provide automated protection against potentially dangerous clutter
    in your network traffic. Together, they’re commonly referred to as tools for “network
    hygiene” because they sanitize your networking considerably.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将讨论的两个特性，`scrub` 和 `antispoof`，有一个共同的主题：它们提供了自动保护，防止网络流量中潜在的危险杂乱物。总的来说，它们通常被称为“网络卫生”工具，因为它们大大净化了网络流量。
- en: 'Packet Normalization with scrub: OpenBSD 4.5 and Earlier'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包规范化与清理：OpenBSD 4.5 及更早版本
- en: In PF versions up to and including OpenBSD 4.5, the `scrub` keyword enables
    network traffic normalization. With `scrub`, fragmented packets are reassembled,
    and invalid fragments—such as overlapping fragments—are discarded, so the resulting
    packet is complete and unambiguous.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PF 版本（包括 OpenBSD 4.5 及之前版本）中，`scrub` 关键字启用网络流量规范化。使用 `scrub` 时，碎片化的包会被重新组装，非法的碎片——如重叠的碎片——会被丢弃，从而使得最终的包完整且明确无误。
- en: 'Enabling `scrub` provides a measure of protection against certain kinds of
    attacks based on incorrect handling of packet fragments.^([[50](#ftn.ch10fn02)])
    A number of supplementing options are available, but the simplest form is suitable
    for most configurations:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 `scrub` 提供了一定程度的保护，防止某些基于包碎片错误处理的攻击。^([[50](#ftn.ch10fn02)]) 有许多附加选项可以使用，但最简单的形式适用于大多数配置：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In order for certain services to work with `scrub`, specific options must be
    set. For example, some NFS implementations won’t work with `scrub` at all unless
    you use the `no-df` parameter to clear the do-not-fragment bit on any packets
    that have the bit set. Certain combinations of services, operating systems, and
    network configurations may require some of the more exotic `scrub` options.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使某些服务能与 `scrub` 一起工作，必须设置特定选项。例如，某些 NFS 实现根本无法与 `scrub` 一起使用，除非你使用 `no-df`
    参数清除任何设置了不分片位的包中的该位。某些服务、操作系统和网络配置的组合可能需要使用一些更为特殊的 `scrub` 选项。
- en: 'Packet Normalization with scrub: OpenBSD 4.6 Onward'
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包括清理的包规范化：OpenBSD 4.6 及之后版本
- en: In OpenBSD 4.6, `scrub` was demoted from stand-alone rule material to become
    an action you could attach to `pass` or `match` rules (the introduction of `match`
    rules being one of the main new PF features in OpenBSD 4.6). One other important
    development in the same rewrite of the `scrub` code was that the numerous packet-reassembly
    options were eliminated in favor of the new `reassemble` option, which simply
    turns reassembly on or off.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenBSD 4.6 中，`scrub` 从独立规则内容降级为一个可以附加到 `pass` 或 `match` 规则的动作（引入 `match`
    规则是 OpenBSD 4.6 中 PF 的主要新特性之一）。在同一版本中对 `scrub` 代码进行重写时，另一个重要的变化是，众多的包重组选项被删除，取而代之的是新的
    `reassemble` 选项，该选项简单地打开或关闭重组。
- en: 'With the new `scrub` syntax, you need to supply at least one option in parentheses.
    The following works quite well for several networks in my care:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This option clears the do-not-fragment bit and sets the maximum segment size
    to 1,440 bytes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Other variations are possible, and even though the list of `scrub` options shrank
    somewhat for the OpenBSD 4.6 version, you should be able to cater to specific
    needs by consulting the man pages and doing some experimentation. For most setups,
    a global match rule like the one quoted earlier is appropriate, but keep in mind
    that you can vary `scrub` options on a per-rule basis if needed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself needing to debug a `scrub`-related problem, study the `pf.conf`
    man page and consult the gurus on the relevant mailing lists.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Protecting Against Spoofing with antispoof
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some very useful and common packet-handling actions could be written as PF rules,
    but not without becoming long, complicated, and error-prone rule set boilerplate.
    Thus, `antispoof` was implemented for a common special case of filtering and blocking.
    This mechanism protects against activity from spoofed or forged IP addresses,
    mainly by blocking packets that appear on interfaces traveling in directions that
    aren’t logically possible.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: With `antispoof`, you can specify that you want to weed out spoofed traffic
    coming in from the rest of the world as well as any spoofed packets that might
    originate in your own network. [Figure 10-1](ch10.html#antispoof_drops_packets_that_come_in_fro
    "Figure 10-1. antispoof drops packets that come in from the wrong network.") illustrates
    the concept.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![antispoof drops packets that come in from the wrong network.](httpatomoreillycomsourcenostarchimages2127169.png.jpg)Figure 10-1. antispoof
    drops packets that come in from the wrong network.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'To establish the kind of protection depicted in the diagram, specify `antispoof`
    for both interfaces in the illustrated network with these two lines:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These lines expand to complex rules. The first one blocks incoming traffic when
    the source address appears to be part of the network directly connected to the
    antispoofed interface but arrives on a different interface. The second rule performs
    the same functions for the internal interface, blocking any traffic with apparently
    local network addresses that arrive on interfaces other than `$int_if`. Keep in
    mind, however, that `antispoof` isn’t designed to detect address spoofing for
    remote networks that aren’t directly connected to the machine running PF.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Testing Your Setup
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it’s time to dust off the precise specification that describes how your
    setup *should* work.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The physical layout of our sample network is centered on a *gateway* connected
    to the Internet via `$ext_if`. Attached to the gateway via `$int_if` is a *local
    network* with workstations and possibly one or more servers for local use. Finally,
    we have a *DMZ* connected to `$dmz_if`, populated with servers offering services
    to the local network and the Internet. [Figure 10-2](ch10.html#network_with_servers_in_a_dmz
    "Figure 10-2. Network with servers in a DMZ") shows the logical layout of the
    network.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例网络的物理布局以一个*网关*为中心，该网关通过 `$ext_if` 连接到互联网。通过 `$int_if` 连接到网关的是一个*本地网络*，该网络包含工作站，可能还包括一个或多个供本地使用的服务器。最后，我们有一个*DMZ*，它通过
    `$dmz_if` 连接，里面的服务器提供服务给本地网络和互联网。[图 10-2](ch10.html#network_with_servers_in_a_dmz
    "图 10-2. 带有 DMZ 服务器的网络") 显示了该网络的逻辑布局。
- en: '![Network with servers in a DMZ](httpatomoreillycomsourcenostarchimages2127171.png.jpg)Figure 10-2. Network
    with servers in a DMZ'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![带有 DMZ 服务器的网络](httpatomoreillycomsourcenostarchimages2127171.png.jpg)图 10-2.
    带有 DMZ 服务器的网络'
- en: 'The corresponding rule set specification looks something like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的规则集规范大致如下：
- en: Machines outside our network should have access to the services offered by our
    servers in the DMZ and should not have access to the local network.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们网络外的机器应该能够访问我们在 DMZ 中的服务器提供的服务，但不应访问本地网络。
- en: The machines in our local network, attached to `$int_if`, should have access
    to the services offered by the servers in the DMZ and access to a defined list
    of services outside our network.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们本地网络中的机器，连接到 `$int_if`，应能够访问 DMZ 中的服务器提供的服务，并访问我们网络外定义的服务列表。
- en: The machines in the DMZ should have access to some network services in the outside
    world.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DMZ 中的机器应能访问外部世界的一些网络服务。
- en: The task at hand is to make sure the rule set we have in place actually implements
    the specification. We need to test the setup. A useful test would be to try the
    sequence in [Table 10-1](ch10.html#sample_rule_set_test_case_sequence "Table 10-1. Sample
    Rule Set Test Case Sequence").
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的任务是确保我们现有的规则集确实实现了规范。我们需要测试该设置。一个有用的测试是尝试[表 10-1](ch10.html#sample_rule_set_test_case_sequence
    "表 10-1. 示例规则集测试用例序列")中的测试序列。
- en: Your configuration may call for other tests or could differ in some particulars,
    but your real-life test scenario should specify how packets and connections should
    be logged. The main point is that you should decide what the expected and desired
    result for each of your test cases should be before you start testing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你的配置可能需要进行其他测试，或者在某些细节上有所不同，但你实际的测试场景应该明确说明如何记录数据包和连接。关键是，在开始测试之前，你应该决定每个测试用例的预期和期望结果是什么。
- en: In general, you should test using the applications you expect the typical user
    to have, such as Web browsers or mail clients on various operating systems. The
    connections should simply succeed or fail, according to specifications. If one
    or more of your basic tests gives an unexpected result, move on to debugging your
    rule set.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你应使用典型用户可能使用的应用程序进行测试，比如不同操作系统上的网页浏览器或邮件客户端。连接应该按照规范简单地成功或失败。如果一个或多个基本测试结果不符合预期，可以开始调试你的规则集。
- en: Table 10-1. Sample Rule Set Test Case Sequence
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-1. 示例规则集测试用例序列
- en: '| Test Action | Expected Result |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 测试操作 | 预期结果 |'
- en: '| --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Try a connection from the local network to each allowed port on the servers
    in the DMZ. | The connection should pass. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 尝试从本地网络到 DMZ 中每个服务器的允许端口进行连接。 | 连接应通过。 |'
- en: '| Try a connection from the local network to each allowed port on servers outside
    your network. | The connection should pass. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 尝试从本地网络到网络外服务器的每个允许端口进行连接。 | 连接应通过。 |'
- en: '| Try a connection on any port from the DMZ to the local network. | The connection
    should be blocked. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 尝试从 DMZ 到本地网络的任何端口进行连接。 | 连接应被阻止。 |'
- en: '| Try a connection from the DMZ to each allowed port on servers outside your
    network. | The connection should pass. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 尝试从 DMZ 到你网络外服务器的每个允许端口进行连接。 | 连接应通过。 |'
- en: '| Try a connection from outside your network to `$webserver` in the DMZ on
    each port in `$webports`. | The connection should pass. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 尝试从网络外部到 DMZ 中的 `$webserver` 在 `$webports` 中的每个端口进行连接。 | 连接应通过。 |'
- en: '| The connection should pass.Try a connection from outside your network to
    `$webserver` in the DMZ on port 25 (SMTP). | The connection should be blocked.
    |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 连接应通过。尝试从网络外部到 DMZ 中的 `$webserver` 在端口 25（SMTP）上的连接。 | 连接应被阻止。 |'
- en: '| Try a connection from outside your network to `$emailserver` in the DMZ on
    port 80 (HTTP). | The connection should be blocked. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 尝试从网络外部连接到DMZ中端口80（HTTP）的`$emailserver`。 | 连接应该被阻止。 |'
- en: '| Try a connection from outside your network to `$emailserver` in the DMZ on
    port 25 (SMTP). | The connection should pass. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 尝试从网络外部连接到DMZ中端口25（SMTP）的`$emailserver`。 | 连接应该被允许。 |'
- en: '| Try a connection from outside your network to one or more machines in the
    local network. | The connection should be blocked. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 尝试从网络外部连接到本地网络中的一台或多台机器。 | 连接应该被阻止。 |'
- en: Debugging Your Rule Set
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试你的规则集
- en: When your configuration doesn’t behave as expected, there may be an error in
    the rule set logic, so you need to find the error and correct it. Tracking down
    logic errors in your rule set can be time-consuming and could involve manually
    evaluating your rule set—both as it’s stored in the *pf.conf* file and as the
    loaded version after macro expansions and any optimizations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的配置没有按预期行为时，可能是规则集逻辑存在错误，因此你需要找到错误并纠正它。追踪规则集中的逻辑错误可能会非常耗时，可能需要手动评估规则集——包括它在`pf.conf`文件中的存储版本，以及宏扩展和任何优化后的加载版本。
- en: Users often initially blame PF for issues that turn out to be basic network
    problems. Network interfaces set to wrong duplex settings, bad netmasks, and faulty
    network hardware are common culprits.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通常最初将问题归咎于PF，但实际上问题往往是基本的网络问题。网络接口设置错误的双工模式、错误的子网掩码和故障的网络硬件是常见的罪魁祸首。
- en: 'Before diving into the rule set itself, you can easily determine whether the
    PF configuration is causing the problem. To do so, disable PF with `pfctl -d`
    to see whether the problem disappears. If the problem persists when PF is disabled,
    you should turn to debugging other parts of your network configuration instead.
    If the problem disappears upon disabling PF and you’re about to start adjusting
    your PF configuration, make sure that PF is enabled and that your rule set is
    loaded with this command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入规则集本身之前，你可以轻松地判断PF配置是否引发了问题。为此，可以通过`pfctl -d`禁用PF，看看问题是否消失。如果禁用PF后问题仍然存在，你应该转而调试网络配置的其他部分。如果禁用PF后问题消失，并且你准备开始调整PF配置，请确保PF已启用，并且通过以下命令加载了你的规则集：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`Status: Enabled` tells us that PF is enabled, so we try viewing the loaded
    rules with a different `pfctl` command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Status: Enabled`告诉我们PF已启用，因此我们尝试使用不同的`pfctl`命令查看已加载的规则：'
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, `pfctl -sr` is equivalent to `pfctl -s rules`. The output is likely to
    be a bit longer than that shown here, but this is a good example of what you should
    expect to see when a rule set is loaded.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`pfctl -sr`等同于`pfctl -s rules`。输出可能会比这里显示的稍长，但这可以作为加载规则集时你应该预期看到的输出的一个好例子。
- en: 'For debugging purposes, consider adding the `-vv` flag to the `pfctl` command
    line to see rule numbers and some additional debug information, like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试的目的，可以考虑在`pfctl`命令行中添加`-vv`标志，以查看规则编号和一些额外的调试信息，像这样：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now you should perform a structured walk-through of the loaded rule set. Find
    the rules that match the packets you’re investigating. What’s the last matching
    rule? If more than one rule matches, is one of the matching rules a `quick` rule?
    (As you probably recall from earlier chapters, when a packet matches a `quick`
    rule, evaluation stops, and whatever the `quick` rule specifies is what happens
    to the packet.) If so, you’ll need to trace the evaluation until you hit the end
    of the rule set or the packet matches a `quick` rule, which then ends the process.
    If your rule set walk-through ends somewhere other than the rule you were expecting
    to match your packet, you’ve found your logic error. Be sure to watch out for
    `match` rules. If you can’t determine why a specific packet matched a particular
    `block` or `pass` rule, the reason could be that a `match` rule applied an action
    that made the packet or connection match filtering criteria other than the expected
    ones.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该对加载的规则集进行结构化的逐步检查。找到与正在调查的数据包匹配的规则。最后匹配的规则是什么？如果有多个规则匹配，其中有一个是`quick`规则吗？（如你在前面的章节中可能记得，当数据包匹配一个`quick`规则时，评估会停止，`quick`规则指定的内容就是数据包的处理方式。）如果是这样，你需要追踪评估过程，直到到达规则集的末尾，或者数据包匹配到一个`quick`规则，之后过程结束。如果你的规则集逐步检查的结果与预期匹配的数据包规则不同，你就找到了逻辑错误。务必小心`match`规则。如果你无法确定为何特定数据包匹配了某个`block`或`pass`规则，原因可能是某个`match`规则应用了一个操作，使得数据包或连接匹配了与预期不同的过滤标准。
- en: 'Rule set logic errors tend to fall into three types:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 规则集逻辑错误通常分为三种类型：
- en: Your rule doesn’t match because it’s never evaluated. A `quick` rule earlier
    in the rule set matched, and the evaluation stopped.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的规则没有匹配，因为它从未被评估。规则集中的一个`quick`规则先匹配了，评估就停止了。
- en: Your rule is evaluated but doesn’t match the packet after all, due to the rule’s
    criteria.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的规则被评估，但由于规则的标准，最终没有匹配到数据包。
- en: Your rule is evaluated and the rule matches, but the packet also matches another
    rule later in the rule set. The last matching rule is the one that determines
    what happens to your connection.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的规则被评估并且匹配，但数据包也匹配了规则集中的另一个规则。最后匹配的规则决定了连接的处理方式。
- en: '[Chapter 9](ch09.html "Chapter 9. Logging, Monitoring, and Statistics") introduced
    `tcpdump` as a valuable tool for reading and interpreting PF logs. The program
    is also very well suited for viewing the traffic that passes on a specific interface.
    What you learned about PF’s logs and how to use `tcpdump`’s filtering features
    will come in handy when you want to track down exactly which packets reach which
    interface.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html "第9章。日志、监控和统计")介绍了`tcpdump`，它是一个读取和解读PF日志的有价值工具。该程序也非常适合查看特定接口上通过的流量。你关于PF日志的学习，以及如何使用`tcpdump`的过滤功能，将在你想要追踪到底是哪些数据包到达了哪个接口时派上用场。'
- en: 'Here’s an example of using `tcpdump` to watch for TCP traffic (but not SSH
    or SMTP traffic) on the `xl0` interface and to print the result in very verbose
    mode (`vvv`):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`tcpdump`监控TCP流量（但不包括SSH或SMTP流量）在`xl0`接口上的示例，并以非常详细的模式（`vvv`）打印结果。
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The connection shown here is a successful connection to a website.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的连接是成功连接到一个网站。
- en: There are more interesting things to look for, though, such as connections that
    fail when they shouldn’t according to your specifications or connections that
    succeed when your specification says they clearly shouldn’t.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然有更多有趣的事情需要探索，比如连接在不应该失败的情况下失败，或者连接在你的规范明确表示不应该成功的情况下却成功。
- en: 'The test in these cases involves tracking the packets’ path through your configuration.
    Once more, it’s useful to check whether PF is enabled or whether disabling PF
    makes a difference. Building on the result from that initial test, you then perform
    the same kind of analysis of the rule set as described previously:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些情况中的测试涉及追踪数据包在你配置中的路径。再次强调，检查PF是否启用，或者禁用PF是否会产生不同的结果是非常有用的。在初步测试的结果基础上，你将执行与之前描述的相同类型的规则集分析：
- en: Once you have a reasonable theory of how the packets should traverse your rule
    set and your network interfaces, use `tcpdump` to see the traffic on each of the
    interfaces in turn.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你对数据包如何穿越规则集和网络接口有了合理的理论，就使用`tcpdump`逐一查看每个接口上的流量。
- en: Use `tcpdump`’s filtering features to extract only the information you need—that
    is, to see only the packets that should match your specific case, such as `port
    smtp and dst 192.0.2.19`.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tcpdump`的过滤功能来提取你需要的信息——也就是说，只查看应该匹配你特定情况的数据包，比如`port smtp and dst 192.0.2.19`。
- en: Find the place where your assumptions no longer match the reality of your network
    traffic.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到你的假设与网络流量现实不匹配的地方。
- en: Turn on logging for the rules that may be involved and turn `tcpdump` loose
    on the relevant `pflog` interface to see which rule the packets actually match.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为可能涉及的规则开启日志记录，并将`tcpdump`应用于相关的`pflog`接口，查看数据包实际上匹配了哪个规则。
- en: The main outline for the test procedure is fairly fixed. If you’ve narrowed
    down the cause to your PF configuration, again, it’s a case of finding out which
    rules match and which rule ends up determining whether the packet passes or is
    blocked.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 测试过程的主要框架是相对固定的。如果你已经将原因缩小到你的PF配置，那么，接下来就是找出哪些规则匹配，哪个规则最终决定数据包是通过还是被阻塞。
- en: Know Your Network and Stay in Control
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解你的网络并保持控制
- en: The recurring theme in this book has been how PF and related tools make it relatively
    easy for you, as the network administrator, to take control of your network and
    to make it behave the way you want it to behave—in other words, how PF allows
    you to build the network you need.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的反复主题是，PF和相关工具如何使你作为网络管理员相对容易地控制你的网络，并让它按你希望的方式运作——换句话说，PF如何帮助你构建所需的网络。
- en: Running a network can be fun, and I hope you’ve enjoyed this tour of what I
    consider to be the best tool available for network security. In presenting PF,
    I made a conscious decision early on to introduce you to the methods and ways
    of thinking via interesting and useful configurations, rather than offering a
    full catalog of available features or, for that matter, making this book the complete
    reference. The complete PF reference already exists in the man pages, which are
    updated every six months with the new OpenBSD releases. You can also find further
    information in the resources I’ve listed in [Appendix A](apa.html "Appendix A. Resources").
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 运行网络是件有趣的事，希望你已经享受了我认为是网络安全最佳工具的介绍。在介绍PF时，我一开始就做出了一个有意识的决定：通过有趣且有用的配置向你介绍方法和思维方式，而不是提供一个完整的功能目录，或者把这本书做成完整的参考手册。完整的PF参考资料已经存在于手册页中，这些手册每六个月会随着新的OpenBSD版本发布而更新。你还可以在我在[附录A](apa.html
    "附录A. 资源")中列出的资源中找到更多信息。
- en: Now that you have a broad, basic knowledge of what PF can do, you can start
    building the network according to your own ideas of what you need. You’ve reached
    the point where you can find your way around the man pages and locate the exact
    information you need. This is when the fun part starts!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经具备了关于PF可以做什么的广泛基础知识，你可以开始根据自己的需求来构建网络。你已经到了可以在手册页中找到所需准确信息的阶段。这时，真正有趣的部分开始了！
- en: '* * *'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^([[49](#ch10fn01)]) If you’ve yet to be hit by this particular kind of nastiness,
    you will be. Here’s a writeup about a DDOS situation where the hamfistedness was
    about equally distributed between both sides—the attacker and the attacked: *[http://bsdly.blogspot.com/2012/12/ddos-bots-are-people-or-manned-by-some.html](http://bsdly.blogspot.com/2012/12/ddos-bots-are-people-or-manned-by-some.html)*.
    Your attackers will likely be smarter and better equipped than these.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[49](#ch10fn01)]) 如果你还没有遇到过这种恶劣情况，迟早会遇到。这是关于一个DDoS攻击案例的描述，攻击者和受害者的笨拙程度几乎相等——*［http://bsdly.blogspot.com/2012/12/ddos-bots-are-people-or-manned-by-some.html](http://bsdly.blogspot.com/2012/12/ddos-bots-are-people-or-manned-by-some.html)*。你的攻击者很可能比这些更聪明、更装备精良。
- en: ^([[50](#ch10fn02)]) Some notable attack techniques, including several historical
    denial-of-service setups, have exploited bugs in fragment handling that could
    lead to out-of-memory conditions or other resource exhaustion. One such exploit,
    which was aimed at Cisco’s PIX firewall series, is described in the advisory at
    *[http://www.cisco.com/en/US/products/products_security_advisory09186a008011e78d.shtml](http://www.cisco.com/en/US/products/products_security_advisory09186a008011e78d.shtml).*
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[50](#ch10fn02)]) 一些著名的攻击技术，包括几种历史上的拒绝服务攻击（DoS）设置，利用了片段处理中的漏洞，这可能导致内存溢出或其他资源耗尽。一种针对思科PIX防火墙系列的漏洞就是在*［http://www.cisco.com/en/US/products/products_security_advisory09186a008011e78d.shtml](http://www.cisco.com/en/US/products/products_security_advisory09186a008011e78d.shtml)*中描述的。
