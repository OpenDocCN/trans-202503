<html><head></head><body>
<h2 class="h2" id="ch04"><a id="page_31"/><strong>4</strong></h2>
<p class="h2a"><strong>PSEUDO-CLASSES AND PSEUDO-ELEMENTS</strong></p>
<div class="image"><img alt="Image" src="graphics/common-01.jpg"/></div>
<p class="noindentt">The very first CSS specification, CSS1, introduced the concepts of <em>pseudo-classes</em> and <em>pseudo-elements</em>. These are selectors that act on information about elements that extends (or sits outside of) the document tree. A pseudo-class differentiates among an element’s different states or types; these include—but are not limited to—those that provide information about link states: <code>:hover</code>, <code>:visited</code>, <code>:active</code>, and so on. A pseudo-element provides access to an element’s subpart, which includes those pseudo-elements that select portions of text nodes; for instance, <code>:first-line</code> and <code>:first-letter</code>.</p>
<p class="indent">The selectors just mentioned have been around since the first CSS specification, but a handful more were added in CSS2.1—although pseudo-element support has not been well implemented until relatively recently. CSS3 builds on these foundations with an expanded range of pseudo-classes, as well as a (slightly) tweaked syntax to differentiate pseudo-elements.</p>
<p class="indent"><a id="page_32"/>The advantage of having more methods for traversing documents should be clear: Fewer styling hooks are required. You are most likely familiar with markup like this:</p>
<pre class="programs">&lt;ul&gt;<br/>   &lt;li class="<span class="ent">➊</span>first <span class="ent">➋</span>odd"&gt;<span class="ent">➌</span>&lt;span&gt;L&lt;/span&gt;orem ipsum&lt;/li&gt;<br/>   &lt;li&gt;Lorem ipsum&lt;/li&gt;<br/>   &lt;li class="odd"&gt;Lorem ipsum&lt;/li&gt;<br/>   &lt;li class="<span class="ent">➍</span>last"&gt;Lorem ipsum&lt;/li&gt; &lt;/ul&gt;</pre>
<p class="indent">The markup contains class names to describe each element’s position in the document tree: <code>first</code> (<span class="ent">➊</span>) and <code>last</code> (<span class="ent">➍</span>) show that the <code>li</code> elements are the first and last children of the <code>ul</code> element, and <code>odd</code> (<span class="ent">➋</span>) is used for the oddnumbered <code>li</code> elements. An extra <code>span</code> (<span class="ent">➌</span>) is included around the first letter of the initial <code>li</code> element.</p>
<p class="indent">You mark up code like this when you want to add styles to alternating elements, set different values on the first and last elements, or add special formatting to the first letter of a text node. This markup detracts from the clarity and semantic meaning of your code, but in many cases you need it to provide the hooks to hang your styles on.</p>
<p class="indent">CSS3’s new methods allow you to achieve the same visual results without muddying the markup with unnecessary classes and nonsemantic elements, making for cleaner and more maintainable code:</p>
<pre class="programs">&lt;ul&gt;<br/>    &lt;li&gt;Lorem ipsum&lt;/li&gt;<br/>    &lt;li&gt;Lorem ipsum&lt;/li&gt;<br/>    &lt;li&gt;Lorem ipsum&lt;/li&gt;<br/>    &lt;li&gt;Lorem ipsum&lt;/li&gt; &lt;/ul&gt;</pre>
<p class="indent">The other major advantage of the new selectors is that if new elements are added to the markup, class names don’t have to be updated to accommodate them while still keeping order. This change takes CSS a big step closer to achieving its stated goal: the separation of content and presentation.</p>
<h3 class="h3" id="ch04leve1sec34"><strong>Structural Pseudo-classes</strong></h3>
<p class="noindent">As I stated in the introduction to this chapter, a pseudo-class provides a way to select an element based on information that is not specified in the document tree. Various subtypes are available, the most common of which is the <em>structural pseudo-class</em>. These subtypes are used to select elements that are not accessible using simple selectors.</p>
<p class="indent"><a id="page_33"/>Take, for example, the following markup:</p>
<pre class="programs">&lt;div&gt;<br/>    &lt;p&gt;Lorem ipsum.&lt;/p&gt;<br/>    &lt;p&gt;Dolor sit amet.&lt;/p&gt;<br/>&lt;/div&gt;</pre>
<p class="indent">The first of the two <code>p</code> elements is the first child of the <code>div</code> element. That’s obvious from the document tree, but the document tree doesn’t provide any information that would allow you to apply a rule only to that element. CSS2 introduced the <code>:first-child</code> pseudo-class for exactly that reason:</p>
<pre class="programs">E:first-child {…}</pre>
<p class="indent">This pseudo-class allows you to make a selection based on information that exists but isn’t provided as an attribute of the element—the exact purpose of a pseudo-class. Since <code>:first-child</code> was introduced in CSS2, it has been the only pseudo-class of its type. But CSS3 extends the range greatly with the introduction of 11 new structural pseudo-classes.</p>
<h4 class="h4" id="ch04leve1sec35"><strong><em>The :nth-* Pseudo-classes</em></strong></h4>
<p class="noindent">Four of the new pseudo-classes are based on a count value used to find an element’s position in the document tree; for this count, you use the syntax <code>:nth-*</code>. Note that I’ve used the asterisk here in place of a number of different values, each of which I’ll introduce throughout the rest of this chapter.</p>
<p class="indent">The basic syntax of the <code>:nth-*</code> pseudo-classes is quite straightforward. By default, <code>n</code> represents a number that begins at 0 and increments by 1 (1, 2, 3, etc.). Another integer can be passed into it as a multiplier. For example, <code>2n</code> is every multiple of 2 (2, 4, 6, etc.), <code>3n</code> is every multiple of 3 (3, 6, 9, etc.), and so on:</p>
<pre class="programs"><span class="codeitalic">E</span>:nth-*(n) {…}<br/><span class="codeitalic">E</span>:nth-*(2n) {…}<br/><span class="codeitalic">E</span>:nth-*(3n) {…}</pre>
<p class="indent">The first example uses the default value <code>n</code>, so all elements of type <code><em>E</em></code> would be selected; in practice, this is the same as using a simple element selector. The next example selects every other <code><em>E</em></code> element, and the final example selects every third element of type <code><em>E</em></code>.</p>
<p class="indent">You may also use the mathematical operators for plus (+) and minus (−). So <code>2n+1</code> selects every multiple of two plus one (1, 3, 5, etc.), and <code>3n-1</code> selects every multiple of three minus one (2, 5, 8, etc.):</p>
<pre class="programs"><span class="codeitalic">E</span>:nth-*(n+1) {…}<br/><span class="codeitalic">E</span>:nth-*(2n+1) {…}<br/><span class="codeitalic">E</span>:nth-*(3n-1) {…}</pre>
<p class="indent"><a id="page_34"/>The first example selects every element of type <code><em>E</em></code> except for the first instance; the count for this would be 2, 3, 4, 5, and so on. The next example selects every odd-numbered <code><em>E</em></code> element (1, 3, 5, and so on). The final example, as just mentioned, selects elements in the sequence 2, 5, 8, and so on.</p>
<p class="indent">Two special keyword values, <code>even</code> and <code>odd</code>, are also available; you can use these to replace <code>2n</code> and <code>2n+1</code>, respectively:</p>
<pre class="programs"><span class="codeitalic">E</span>:nth-*(even) {…}<br/><span class="codeitalic">E</span>:nth-*(odd) {…}</pre>
<p class="indent">Finally, it’s also acceptable to use <code>0n</code> (that’s zero) as a value. It has no use of itself but is very useful when combined with a mathematical operator, as it allows you to pinpoint a single element without any recurrence. In fact, for brevity, you can supply only the value after the mathematical operator. For example, to select only the third element in a selector list, both of these values are valid:</p>
<pre class="programs"><span class="codeitalic">E</span>:nth-*(0n+3) {…}<br/><span class="codeitalic">E</span>:nth-*(3) {…}</pre>
<p class="indent">With the basic syntax out of the way, let’s move on to the pseudo-classes themselves.</p>
<h5 class="h5" id="ch04leve1sec36"><strong>:nth-child() and :nth-of-type()</strong></h5>
<p class="noindent">Most of the new structural pseudo-classes allow you to select elements based on either their position in the document tree in relation to their parent element (<code>-child</code>) or their classification (<code>-of-type</code>). Often these definitions overlap, but there are crucial differences between them.</p>
<p class="indent">The simplest examples of these pseudo-classes are <code>:nth-child()</code> and <code>:nth-of-type()</code>. The first, <code>:nth-child()</code>, selects an element based on its position in a count of the total number of children in its parent element; <code>:nth-of-type()</code> bases its count not on the total children, but only on those of the specified element type.</p>
<pre class="programs1"><span class="ent">➊</span> <span class="codeitalic">E</span>:nth-child(n) {…}<br/><span class="ent">➋</span> <span class="codeitalic">E</span>:nth-of-type(n) {…}<br/><span class="ent">➌</span> <span class="codeitalic">E</span>:nth-child(2n) {…}<br/><span class="ent">➍</span> <span class="codeitalic">E</span>:nth-of-type(2n) {…}</pre>
<p class="indent">In this example, rules <span class="ent">➊</span> and <span class="ent">➋</span> are equivalent because the count value (<code>n</code>) is left at the default; both of these simply select all child elements of type <code><em>E</em></code>. The difference reveals itself in the later examples: in <span class="ent">➌</span>, <code>:nth-child(2n)</code> selects all elements of type <code><em>E</em></code> from a count that includes all its siblings but only where those elements are even-numbered. In <span class="ent">➍</span>, by comparison, <code>:nth-of-type(2n)</code> selects all even-numbered elements of type <code><em>E</em></code> from a count that includes only those elements.</p>
<p class="indent"><a id="page_35"/>These rules are much easier to demonstrate than they are to explain. I’ll demonstrate the difference between them with the following example (text has been truncated for clarity):</p>
<pre class="programs">&lt;div&gt;<br/>    &lt;h2&gt;The Picture of Dorian Gray&lt;/h2&gt;<br/>    &lt;p&gt;The artist is the creator…&lt;/p&gt;<br/>    &lt;p&gt;To reveal art and conceal the artist…&lt;/p&gt;<br/>    &lt;p&gt;The critic is he who can translate…&lt;/p&gt;<br/>&lt;/div&gt;</pre>
<p class="indent">And in my style sheet I’ll use these two rules:</p>
<pre class="programs1"><span class="ent">➊</span> p:nth-child(2n) { font-weight: bolder ; }<br/><span class="ent">➋</span> p:nth-of-type(2n) { font-weight: bolder; }</pre>
<p class="indent">You can see the differing result of the two rules in <a href="ch04.html#ch04fig1">Figure 4-1</a>. In the example markup, the <code>div</code> element has a total of four child elements: one <code>h2</code> and three <code>p</code>. The <code>:nth-child(2n)</code> selector in rule <span class="ent">➊</span> makes bold every second child (the first and third paragraphs), as seen in the box on the left. Compare that to the box on the right, which has rule <span class="ent">➋</span> applied; the <code>:nth-of-type(2n)</code> selector ignores the <code>h2</code> and applies a bold weight to every second instance of the three elements of type <code>p</code>—that is, only the second paragraph.</p>
<div class="image"><img alt="Image" src="graphics/f04-01.jpg"/></div>
<p class="figuret"><a id="ch04fig1"/><em>Figure 4-1: Comparing the result of using the</em> <code><em>:nth-child()</em></code> <em>selector (left) with</em> <code><em>:nth-of-type()</em></code> <em>(right)</em></p>
<p class="indent">As I mentioned before, and as you can no doubt deduce from the previous examples, <code>:nth-child()</code> and <code>:nth-of-type()</code> have a fair bit of overlap, and you can often use them interchangeably, as I do in the following example.</p>
<p class="indent">The table on the left of <a href="ch04.html#ch04fig2">Figure 4-2</a> shows the five-day weather forecast for London (so temperatures are given in degrees Celsius—0°C equals 32°F). These figures were taken in January—it’s not <em>always</em> this cold here! All of the information I want to convey is in the table, but without any definition of rows, I find the table difficult to read.</p>
<p class="indent">Now compare this table to the one on the right in the same <a href="ch04.html#ch04fig2">Figure 4-2</a>. Here, I used the technique known as <em>zebra striping</em> to aid the eye along the row, making the data much more readable to me.</p>
<div class="image"><a id="page_36"/><img alt="Image" src="graphics/f04-02.jpg"/></div>
<p class="figuret"><a id="ch04fig2"/><em>Figure 4-2: Weather forecast table (left) and better formatted for readability (right). Weather data from</em> <a href="http://bbc.co.uk/weather/">http://bbc.co.uk/weather/</a></p>
<p class="indent">I achieved this technique with a single CSS3 declaration:</p>
<pre class="programs">tbody tr:nth-of-type(even) { background-color: #DDD; }</pre>
<p class="indent">In this example, I could have used <code>:nth-child()</code> instead, as in the markup all of the child elements of <code>tbody</code> are of the same type: <code>tr</code>. Where every child is of the same type, <code>:nth-child()</code> and <code>:nth-of-type()</code> are interchangeable.</p>
<h5 class="h5" id="ch04leve1sec37"><strong>:nth-last-child() and :nth-last-of-type()</strong></h5>
<p class="noindent">The <code>:nth-last-child()</code> and <code>:nth-last-of-type()</code> pseudo-classes accept the same arguments as <code>:nth-child()</code> and <code>:nth-of-type()</code>, except they are counted from the last element, working in reverse. For example, say I want to use some visual shorthand to show in my weather table that the forecasts for days four and five are less certain than for the preceding days. You can see how this would look in <a href="ch04.html#ch04fig3">Figure 4-3</a>.</p>
<div class="image"><img alt="Image" src="graphics/f04-03.jpg"/></div>
<p class="figuret"><a id="ch04fig3"/><em>Figure 4-3: Extra formatting using</em> <code><em>:nth-last-child()</em></code></p>
<p class="indent">Here I italicized the characters in the last two rows by using the <code>:nth-last-child()</code> pseudo-class (although, once again, <code>:nth-last-of-type()</code> would serve just as well in this example), passing an argument of <code>-n+2</code>:</p>
<pre class="programs">tbody tr:nth-last-child(-n+2) { font-style: italic; }</pre>
<p class="indent">I used the negative value (<code>-n</code>) to increment the count negatively, which has the effect of acting in reverse. Because <code>:nth-last-child()</code> and <code>:nth-last-of-type()</code> count backward through the tree, using a negative value here makes the count go forward! The count starts at the last <code>tr</code> element in the table and counts up in reverse order, so the last and penultimate lines are the first two counted and are, therefore, italicized. This may seem counterintuitive, but it’ll become second nature as you traverse the document tree.</p>
<h5 class="h5" id="ch04leve1sec38"><a id="page_37"/><em><strong>:first-of-type, :last-child, and :last-of-type</strong></em></h5>
<p class="noindent">If you take a look at the tables in <a href="ch04.html#ch04fig2">Figure 4-2</a>, you’ll notice that the text in the Weather column is left-aligned, whereas the other columns are center-aligned. I did this using the <code>:first-of-type</code> pseudo-class, which is similar to the <code>:first-child</code> selector introduced in CSS2, but with the same difference in type and child that you’ve seen so far in this chapter.</p>
<p class="indent">As you’re no doubt aware, the <code>:first-child</code> pseudo-class is a selector used to apply rules to an element that is the first child of its parent. As with <code>:nth-of-type()</code>, however, <code>:first-of-type</code> is more specific, applying only to the element that is the first child of the named type of its parent. A pair of counterpart pseudo-classes is also available, <code>:last-child</code> and <code>:last-of-type</code>, which—as you might have guessed—select the last child element or the last child element of that type, respectively, of the parent.</p>
<p class="indent">In the weather table examples in the previous section, the markup for each row in the table body is structured like this:</p>
<pre class="programs">&lt;tr&gt;<br/>    &lt;th&gt;Sun&lt;/th&gt;<br/>    &lt;td&gt;Sunny&lt;/td&gt;<br/>    &lt;td&gt;8&lt;/td&gt;<br/>    &lt;td&gt;4&lt;/td&gt;<br/>    &lt;td&gt;8&lt;/td&gt;<br/>&lt;/tr&gt;</pre>
<p class="indent">I want to left-align the content of the second column, so I can’t use <code>:first-child</code> here as the first child is a <code>th</code>. Instead, I use the <code>:first-of-type</code> selector:</p>
<pre class="programs">tbody td:first-of-type { text-align: left; }</pre>
<p class="indent">I’ll show two more examples to demonstrate the difference clearly. I’ll apply both of the examples to the same chunk of markup (I’ve truncated the text for clarity):</p>
<pre class="programs">&lt;div&gt;<br/>    &lt;h2&gt;Wuthering Heights&lt;/h2&gt;<br/>    &lt;p&gt;I have just returned…&lt;/p&gt;<br/>    &lt;p&gt;This is certainly…&lt;/p&gt;<br/>    &lt;p&gt;In all England…&lt;/p&gt;<br/>    &lt;h3&gt;By Emily Bronte&lt;/h3&gt;<br/>&lt;/div&gt;</pre>
<p class="indent">In the first example, I use <code>:first-child</code> and <code>:last-child</code>, as shown here:</p>
<pre class="programs">:first-child { text-decoration: underline; }<br/>:last-child { font-style: italic; }</pre>
<p class="indent">The result is shown in <a href="ch04.html#ch04fig4">Figure 4-4</a>. The <code>h2</code> element is the first child of the <code>div</code>, so it has an underline applied to it. The last child of the <code>div</code> is the <code>h3</code> element, so that is italicized. All quite straightforward.</p>
<div class="image"><a id="page_38"/><img alt="Image" src="graphics/f04-04.jpg"/></div>
<p class="figuret"><a id="ch04fig4"/><em>Figure 4-4: Applying the</em> <code><em>:first-child</em></code> <em>and</em> <code><em>:last-child</em></code> <em>selectors</em></p>
<p class="indent">Now let’s see the difference when we use the <code>:first-of-type</code> and <code>:last-of-type</code> selectors:</p>
<pre class="programs">:first-of-type { text-decoration: underline; }<br/>:last-of-type { font-style: italic; }</pre>
<p class="indent">Take a look at the result in <a href="ch04.html#ch04fig5">Figure 4-5</a>. You’ll notice that three elements—<code>h2</code>, <code>h3</code>, and the first <code>p</code>—are underlined. This is because they are the first instance of that element type. Likewise, the <code>h2</code>, <code>h3</code>, and last <code>p</code> are all italicized. Again, this is because they are all the last element of that type; the <code>h2</code> and <code>h3</code> are both the first and last of their type, and so both rules are applied to them.</p>
<div class="image"><img alt="Image" src="graphics/f04-05.jpg"/></div>
<p class="figuret"><a id="ch04fig5"/><em>Figure 4-5: Applying the</em> <code><em>:first-of-type</em></code> <em>and</em> <code><em>:last-of-type</em></code> <em>selectors</em></p>
<p class="indent">As with all of the <code>*-type</code> and <code>*-child</code> pseudo-classes, the distinction is subtle, and sometimes the last child element is also the last of its type, so the selectors are interchangeable. But as I’ve just shown, at times, they have different applications.</p>
<h5 class="h5" id="ch04leve1sec39"><a id="page_39"/><em><strong>:only-child and :only-of-type</strong></em></h5>
<p class="noindent">These two pseudo-classes are used to select elements in the document tree that have a parent but either no sibling elements (<code>:only-child</code>) or no siblings of the same type (<code>:only-of-type</code>). As with many of the previous pseudo-classes, these two overlap substantially in function, but this next example illustrates the difference between them. Take the following style rules:</p>
<pre class="programs">p:only-of-type { font-style: italic; }<br/>p:only-child { text-decoration: underline; }</pre>
<p class="indent">and then apply them to this markup:</p>
<pre class="programs">&lt;h2&gt;On Intelligence&lt;/h2&gt;<br/>&lt;p&gt;Arthur C. Clarke once said:&lt;/p&gt;<br/>&lt;blockquote&gt;<br/>    &lt;p&gt;It has yet to be proven that intelligence has any survival value.&lt;/p&gt;<br/>&lt;/blockquote&gt;</pre>
<p class="indent">You can see the result in <a href="ch04.html#ch04fig6">Figure 4-6</a>.</p>
<div class="image"><img alt="Image" src="graphics/f04-06.jpg"/></div>
<p class="figuret"><a id="ch04fig6"/><em>Figure 4-6: Comparing</em> <code><em>:only-child</em></code> <em>and</em> <code><em>:only-of-type</em></code></p>
<p class="indent">Both <code>p</code> elements are the only elements of their type in their level of the document tree, so the <code>:only-of-type</code> rule selects both and italicizes them. The <code>p</code> element inside the blockquote, however, is also the only child in its level, so it’s also subject to the <code>:only-child</code> rule that applies the underline.</p>
<p class="indent">Using <code>:only-of-type</code> allows you to pick an element from among others, whereas <code>:only-child</code> requires the element to sit alone.</p>
<h3 class="h3" id="ch04leve1sec40"><strong>Other Pseudo-classes</strong></h3>
<p class="noindent">In addition to the structural pseudo-classes discussed so far in this chapter, CSS3 introduces a number of pseudo-classes that allow you to select elements based on other criteria. These include link destinations, user interface elements, and even an inverse selector that permits selection based on what an element <em>isn’t</em>!</p>
<h4 class="h4a" id="ch04leve1sec41"><a id="page_40"/><em><strong>:target</strong></em></h4>
<p class="noindent">On the Web, sites don’t just link between pages but also provide internal links to specific elements. A URI can contain a reference to a unique ID or a named anchor. For example, if you had this markup in a page:</p>
<pre class="programs">&lt;h4 id="my_id"&gt;Lorem ipsum&lt;/h4&gt;</pre>
<p class="indent">you could refer to it with this link:</p>
<pre class="programs">&lt;a href="page.html#my_id"&gt;Lorem&lt;/a&gt;</pre>
<p class="indent">The <code>:target</code> pseudo-class allows you to apply styles to the element when the referring URI has been followed. In this example, if you want to apply styles to the <code>h4</code> element when the URI is followed, you use:</p>
<pre class="programs">#my_id:target {…}</pre>
<p class="indent">A popular practice is to highlight the subject of an internal link visually to provide a clear cue to the user. Consider, for example, the standard pattern for blog comments, which are somewhat like this simplified markup:</p>
<pre class="programs">&lt;div class="comment" id="comment-01"&gt;<br/>    &lt;p&gt;Thanks for this scintillating example!&lt;/p&gt;<br/>    &lt;p class="author"&gt;N.E. Boddy, April 13&lt;/p&gt;<br/>&lt;/div&gt;</pre>
<p class="indent">And another fairly common pattern is to include links to individual comments:</p>
<pre class="programs">&lt;p&gt;&lt;a href="#comment-02"&gt;Latest comment&lt;/a&gt;&lt;/p&gt;</pre>
<p class="indent">Using the <code>:target</code> pseudo-class, you can easily highlight the comment that the user wants to read:</p>
<pre class="programs">.comment:target { background-color: #DDD; }</pre>
<p class="indent"><a href="ch04.html#ch04fig7">Figure 4-7</a> shows a list of comments in two states: on the left, as they appear before the referring link has been clicked, and on the right, as they appear after the link has been clicked—with the element that the link refers to showing a different background color thanks to the <code>:target</code> selector.</p>
<div class="image"><a id="page_41"/><img alt="Image" src="graphics/f04-07.jpg"/></div>
<p class="figuret"><a id="ch04fig7"/><em>Figure 4-7: Highlighting applied with the</em> <code><em>:target</em></code> <em>pseudo-class</em></p>
<h4 class="h4" id="ch04leve1sec42"><strong><em>:empty</em></strong></h4>
<p class="noindent">The <code>:empty</code> pseudo-class selects an element that has no children, including text nodes. Consider this markup:</p>
<pre class="programs">&lt;tr&gt;<br/>&lt;td&gt;&lt;/td&gt;<br/>&lt;td&gt;Lorem ipsum&lt;/td&gt;<br/>&lt;td&gt;&lt;span&gt;&lt;/span&gt;&lt;/td&gt;<br/>&lt;/tr&gt;</pre>
<p class="indent">If you apply this CSS rule:</p>
<pre class="programs">td:empty { background-color: red; }</pre>
<p class="noindent">the rule is only applied to the first <code>td</code> element, as the other two contain a text node and a child element, respectively.</p>
<h4 class="h4" id="ch04leve1sec43"><strong><em>:root</em></strong></h4>
<p class="noindent">The <code>:root</code> pseudo-class selects the first element in a document tree, which is only really handy if you’re adding a style sheet to XML documents—in HTML, the root will always be the <code>html</code> element. One small advantage of using <code>:root</code> in HTML is that you can use it to give a higher specificity to the <code>html</code> element, which could be useful if you need to override the simple type selector:</p>
<pre class="programs">html {…} /* <span class="codeitalic">Specificity</span>: 1; */<br/>html:root {…} /* <span class="codeitalic">Specificity</span>: 2; */</pre>
<p class="indent"><a id="page_42"/>Let’s say you’re creating a base style sheet and want to set a property on the <code>html</code> element, which shouldn’t be altered. In this case, you would use something like this:</p>
<pre class="programs">html:root { background-color: black; }</pre>
<p class="indent">The higher specificity gives precedence to this rule over any other rules applied to the <code>html</code> element, meaning the following is ignored:</p>
<pre class="programs">html { background-color: white; }</pre>
<p class="indent">But it’s unlikely that you’ll need to use this in most situations.</p>
<h4 class="h4" id="ch04leve1sec44"><strong><em>:not()</em></strong></h4>
<p class="noindent">The negation pseudo-class <code>:not()</code> selects all elements <em>except</em> those that are given as the value of an argument:</p>
<pre class="programs"><span class="codeitalic">E</span> :not(<span class="codeitalic">F</span>) {…}</pre>
<p class="indent">This rule selects all children of element <code><em>E</em></code> except for those of type <code><em>F</em></code>. For example, to color all the immediate child elements of a <code>div</code>, except for <code>p</code> elements, you use this:</p>
<pre class="programs">div &gt; :not(p) { color: red; }</pre>
<p class="indent">To see how useful <code>:not()</code> is, consider a situation where you have the following markup:</p>
<pre class="programs">&lt;div&gt;<br/>    &lt;p&gt;Lorem ipsum dolor sit amet…&lt;/p&gt;<br/>    &lt;p&gt;Nunc consectetur tempor justo…&lt;/p&gt;<br/>    &lt;p&gt;Nunc porttitor malesuada cursus…&lt;/p&gt;<br/>&lt;/div&gt;</pre>
<p class="indent">Now imagine you want to italicize all of the child <code>p</code> elements except for the first one.</p>
<p class="indent">To do this with CSS2, you applied a style to all the <code>p</code> elements and then applied a further style to reset the first element back to its previous state:</p>
<pre class="programs">p { font-style: italic; }<br/>p:first-child { font-style: normal; }</pre>
<p class="indent">With <code>:not()</code>, you can reduce that to a single rule:</p>
<pre class="programs">p:not(:first-child) { font-style: italic; }</pre>
<p class="indent">The argument passed into <code>:not()</code> must be a simple selector—therefore combinators (such as <code>+</code> and <code>&gt;</code>) and pseudo-elements (which I discuss in “<a href="ch04.html#ch04leve1sec47">Pseudo-elements</a>” on <a href="ch04.html#page_45">page 45</a>) are not valid values.</p>
<h5 class="h5" id="ch04leve1sec45"><a id="page_43"/><em><strong>UI Element States</strong></em></h5>
<p class="noindent">Elements relating to forms and user input can have various states; they can be disabled or checked, for example, by setting attribute values:</p>
<pre class="programs">&lt;textarea disabled="disabled"&gt;&lt;/textarea&gt;<br/>&lt;input checked="checked" type="checkbox"&gt;</pre>
<p class="indent">CSS3 has three UI state pseudo-class selectors, which allow you to apply rules to elements based on their current state:</p>
<pre class="programs">:checked {…}<br/>:disabled {…}<br/>:enabled {…}</pre>
<p class="note"><strong><small>NOTE</small></strong><br/><em>HTML has no</em> <code><em>enabled</em></code> <em>attribute; elements that are not disabled are, by definition, enabled.</em></p>
<p class="indent">To see the effect of these pseudo-class selectors, consider the following style rules:</p>
<pre class="programs">input[type='text']:disabled { border: 1px dotted gray; }<br/>input[type='text']:enabled { border: 1px solid black; }</pre>
<p class="indent">I’ll apply these rules to a form that has two text <code>input</code> elements, one of which has a <code>disabled</code> attribute (the form isn’t well-structured as I don’t have labels for the inputs, but I’ve left them out for clarity):</p>
<pre class="programs">&lt;form action=""&gt;<br/>&lt;fieldset&gt;<br/>&lt;legend&gt;UI element state pseudo-classes&lt;/legend&gt;<br/>&lt;input type="text" value="Lorem ipsum" disabled&gt;<br/>&lt;input type="text" value="Lorem ipsum"&gt;<br/>&lt;/fieldset&gt;<br/>&lt;/form&gt;</pre>
<p class="indent">You can see the results in <a href="ch04.html#ch04fig8">Figure 4-8</a>.</p>
<div class="image"><img alt="Image" src="graphics/f04-08.jpg"/></div>
<p class="figuret"><a id="ch04fig8"/><em>Figure 4-8: Disabled and enabled element states</em></p>
<p class="indent">As you can see, the disabled form element has grayed-out text (which is done automatically by the browser) and a gray dotted border (which I set in the style sheet). I set a solid black border around the enabled element.</p>
<p class="indent"><a id="page_44"/>I’m not giving a demonstration of the <code>checked</code> state here, as most browsers have different interpretations of which style rules can be applied to <code>checkbox</code> inputs. For a comprehensive overview of cross-browser styling of form elements, I highly recommend “Styling Form Controls with CSS” from the blog 456 Berea Street (<em><a href="http://www.456bereastreet.com/lab/styling-form-controls-revisited/">http://www.456bereastreet.com/lab/styling-form-controls-revisited/</a></em>).</p>
<p class="indent">There is a fourth UI element state, <code>indeterminate</code>, which is used in a limited set of circumstances; for example, a radio button input in a group where no input has been checked would be classed as indeterminate, as would a <code>progress</code> element with no value supplied. Although implemented in some browsers, however, it hasn’t yet been fully defined, and its status is indeterminate (ha!).</p>
<h4 class="h4" id="ch04leve1sec46"><strong><em>Constraint Validation Pseudo-classes</em></strong></h4>
<p class="noindent">HTML5 introduced a new API for client-side validation of forms, known as the <em>constraint validation API</em>, which can be used to determine if certain requirements are met before the form contents are sent to the server. The constraint validation API brings along with it an associated range of new pseudo-classes.</p>
<p class="note"><strong><small>NOTE</small></strong><br/><em>Mozilla Developer Network (MDN) has an excellent introduction to the Constraint Validation API at</em> <a href="https://developer.mozilla.org/docs/Web/Guide/HTML/HTML5/Constraint_validation/">https://developer.mozilla.org/docs/Web/Guide/HTML/HTML5/Constraint_validation/</a>.</p>
<p class="indent">Under constraint validation, a form field can be made mandatory through use of the new <code>required</code> attribute:</p>
<pre class="programs">&lt;input type="text" <span class="codestrong">required</span>&gt;</pre>
<p class="indent">You can style elements depending on whether they’re required or optional by using their namesake pseudo-classes:</p>
<pre class="programs">:required {…}<br/>:optional {…}</pre>
<p class="indent">Each form field can be in one of two states of validation: either valid or invalid. If no specific constraints are applied, either by the browser or the author, a form field is valid by default. As before, each state has a namesake pseudo-class:</p>
<pre class="programs">:valid {…}<br/>:invalid {…}</pre>
<p class="note"><strong><small>WARNING</small></strong><br/><em>In a form with which the user has yet to interact, fields with constraints that aren’t met—such as being required—will have rules set with the</em> <code><em>:invalid</em></code> <em>pseudo-class applied already.</em></p>
<p class="indent"><a id="page_45"/>Finally, some HTML5 elements can have a permitted range of values, set by using the <code>min</code> and <code>max</code> attributes. You can style these elements depending on whether the current value is in or out of range by using, once again, a pair of namesake pseudo-classes:</p>
<pre class="programs">:in-range {…}<br/>:out-of-range {…}</pre>
<h3 class="h3" id="ch04leve1sec47"><strong>Pseudo-elements</strong></h3>
<p class="noindent">Like pseudo-classes, pseudo-elements provide information that is not specified in the document tree. But where pseudo-classes use “phantom” conditions such as an element’s position in the tree or its state, pseudo-elements go further and allow you to apply styles to elements that don’t exist in the tree at all.</p>
<p class="indent">In CSS2, the four pseudo-elements are <code>:first-line</code> and <code>:first-letter</code>, which select subelements in text nodes, and <code>:after</code> and <code>:before</code>, which allow you to apply styles at the beginning and end of existing elements. CSS3 doesn’t introduce any new pseudo-elements, but it refines the definitions slightly and introduces a new syntax to differentiate them from pseudoclasses. In CSS3, pseudo-elements are prefixed with a double colon (<code>::</code>), like so:</p>
<pre class="programs">::first-line {…}<br/>::first-letter {…}<br/>::after {…}<br/>::before {…}</pre>
<p class="note"><strong><small>NOTE</small></strong><br/><em>The single colon syntax is still accepted for reasons of backward compatibility, although it is deprecated and you shouldn’t use it going forward.</em></p>
<h4 class="h4" id="ch04leve1sec48"><strong><em>The ::selection Pseudo-element</em></strong></h4>
<p class="noindent">Early versions of the CSS3 Selectors module included the definition of a <code>::selection</code> pseudo-element. Although formally removed from the module, it has been well implemented across desktop browsers (less so in mobile browsers). <code>::selection</code> is used to apply rules to an element that the user has selected in the browser (for example, a portion of a text node):</p>
<pre class="programs">::selection {…}</pre>
<p class="indent">Only a limited number of properties can be applied with <code>::selection</code>: <code>color</code>, <code>background-color</code>, and the <code>background</code> shorthand (although not <code>background-image</code>). Using <code>::selection</code>, you can do something like this:</p>
<pre class="programs">p::selection {<br/>    background-color: black;<br/>    color: white;<br/>}</pre>
<p class="indent"><a id="page_46"/><a href="ch04.html#ch04fig9">Figure 4-9</a> shows a comparison of the system-native <code>::selection</code> colors (top) and the colors I’ve applied with the <code>::selection</code> pseudo-element (bottom).</p>
<div class="image"><img alt="Image" src="graphics/f04-09.jpg"/></div>
<p class="figuret"><a id="ch04fig9"/><em>Figure 4-9: Custom colors applied with the</em> <code><em>::selection</em></code> <em>pseudo-element</em></p>
<p class="indent">The <code>::selection</code> pseudo-element is implemented in Chrome, Safari, and IE9+ without a prefix, and in Firefox with the <code>-moz-</code> prefix—so despite it no longer being part of the CSS3 specification, you can use it with confidence.</p>
<h3 class="h3" id="ch04leve1sec49"><strong>Summary</strong></h3>
<p class="noindent">The new range of pseudo-classes (and any pseudo-elements that may be defined in the future) makes document traversal far more flexible and powerful with CSS3 than it ever was with its predecessors, and allows for much leaner and more maintainable markup.</p>
<p class="indent">The increased number of pseudo-classes based on the state of UI and form validation also gives users a much broader range of feedback, without relying on JavaScript. This is exceptionally useful for HTML5, with its increased focus on web applications.</p>
<h3 class="h3" id="ch04leve1sec50"><strong>DOM and Attribute Selectors: Browser Support</strong></h3>
<table border="0" cellpadding="0" cellspacing="0" class="all" width="100%">
<tr>
<td class="table2" valign="top"><p class="table"/></td>
<td class="table2" valign="top"><p class="table"><strong>Chrome</strong></p></td>
<td class="table2" valign="top"><p class="table"><strong>Firefox</strong></p></td>
<td class="table2" valign="top"><p class="table"><strong>Safari</strong></p></td>
<td class="table2" valign="top"><p class="table"><strong>IE</strong></p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">Structural pseudo-classes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
</tr>
<tr>
<td class="table4" valign="top"><p class="table"><code>:target</code></p></td>
<td class="table4" valign="top"><p class="table">Yes</p></td>
<td class="table4" valign="top"><p class="table">Yes</p></td>
<td class="table4" valign="top"><p class="table">Yes</p></td>
<td class="table4" valign="top"><p class="table">Yes</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>:empty</code></p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
</tr>
<tr>
<td class="table4" valign="top"><p class="table"><code>:root</code></p></td>
<td class="table4" valign="top"><p class="table">Yes</p></td>
<td class="table4" valign="top"><p class="table">Yes</p></td>
<td class="table4" valign="top"><p class="table">Yes</p></td>
<td class="table4" valign="top"><p class="table">Yes</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>:not()</code></p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
</tr>
<tr>
<td class="table4" valign="top"><p class="table">Pseudo-elements (<code>::</code> syntax)</p></td>
<td class="table4" valign="top"><p class="table">Yes</p></td>
<td class="table4" valign="top"><p class="table">Yes</p></td>
<td class="table4" valign="top"><p class="table">Yes</p></td>
<td class="table4" valign="top"><p class="table">Yes</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">UI element states</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
</tr>
<tr>
<td class="table4" valign="top"><p class="table">Constraint validation</p></td>
<td class="table4" valign="top"><p class="table">Yes</p></td>
<td class="table4" valign="top"><p class="table">Yes</p></td>
<td class="table4" valign="top"><p class="table">Yes</p></td>
<td class="table4" valign="top"><p class="table">IE10<sup><a id="footnote_20a"/><a href="ch04.html#footnote20a">*</a></sup></p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table"><code>::selection</code></p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
<td class="table" valign="top"><p class="table">Yes</p></td>
</tr>
</table>
<p class="footnote"><a id="footnote20a"/><a href="ch04.html#footnote_20a">*</a> Does not support :in-range, :out-of-range</p>
</body></html>