<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_185"/><strong><span class="big">10</span><br/>REQUIREMENTS DOCUMENTATION</strong></h2>
<div class="image1"><img src="Images/com.jpg" alt="Image" width="204" height="204"/></div>
<p class="noindents">Requirements state what the software must do in order to satisfy the customer’s needs, specifically:</p>
<ul>
<li class="noindent">What functions the system must carry out (a <em>functional requirement</em>)</li>
<li class="noindent">How well the system must perform them (a <em>nonfunctional requirement</em>)</li>
<li class="noindent">The resource or design parameters in which the software must operate (<em>constraints</em>, which are also nonfunctional requirements)</li>
</ul>
<p class="noindent">If a piece of software does not fulfill a particular requirement, you cannot consider the software complete or correct. A set of software requirements, therefore, is the fundamental starting point for software development.</p>
<h3 class="h3" id="lev-10.1"><strong>10.1 Requirement Origins and Traceability</strong></h3>
<p class="noindent">Every software requirement must have an origin. This could be a higher-level requirements document (for example, a requirement in a Software Requirements Specification [SRS] might originate from a System Requirements Specification [SyRS], or a requirement in the SyRS might originate from a <span epub:type="pagebreak" id="page_186"/>customer-supplied functional requirements document), a specific use case document, a customer “statement of work to be done,” a customer’s verbal communication, or a brainstorming meeting. You should be able to trace any requirement to its origin; if you can’t, it probably isn’t necessary and should be removed.</p>
<p class="indent"><em>Reverse traceability</em> is the ability to trace a requirement back to its origin. As discussed in <a href="ch09.xhtml">Chapter 9</a>, the Reverse Traceability Matrix (RTM) is a document or database that lists all requirements and their origins. With an RTM, you can easily identify the origin of a requirement to determine its importance (see “<a href="ch09.xhtml#lev-9.2.3">The Requirements/Reverse Traceability Matrix</a>” on <a href="ch09.xhtml#page_178">page 178</a> for an in-depth description of the RTM).</p>
<h4 class="h4" id="lev-10.1.1"><strong><em>10.1.1 A Suggested Requirements Format</em></strong></h4>
<p class="noindent">A written requirement should take one of the following forms:</p>
<ul>
<li class="noindent">[<strong><em>Trigger</em></strong>] <strong>Actor</strong> shall <strong>Action Object</strong> [<strong><em>Condition</em></strong>]</li>
<li class="noindent">[<strong><em>Trigger</em></strong>] <strong>Actor</strong> must <strong>Action Object</strong> [<strong><em>Condition</em></strong>]</li>
</ul>
<p class="noindent">where the items inside the square brackets are optional. The word <em>shall</em> indicates a functional requirement; the word <em>must</em> indicates a nonfunctional requirement. Each item is described as follows, based on this sample requirement:</p>
<p class="blockquote">When the pool temperature is in the range 40 degrees F to 65 degrees F the pool monitor shall turn off the “good” indication unless the atmospheric temperature is above 90 degrees F.</p>
<p class="uln-indent"><strong>Trigger</strong> A trigger is a phrase indicating when the requirement applies. The absence of a trigger implies that the requirement always applies. In the example, the trigger is “When the pool temperature is in the range 40 degrees F to 65 degrees F.”</p>
<p class="uln-indent"><strong>Actor</strong> The actor is the person or thing that is performing the action—in this case, “the pool monitor.”</p>
<p class="uln-indent"><strong>Action</strong> The action is the activity that the requirement causes (“turn off”).</p>
<p class="uln-indent"><strong>Object</strong> The object is the thing being acted upon (“the ‘good’ indication”).</p>
<p class="uln-indent"><strong>Condition</strong> The condition is typically a negative contingency that stops the action (if a positive condition causes the action, it’s a trigger). In the example, the condition is “unless the atmospheric temperature is above 90 degrees F.”</p>
<p class="indenta">Some authors allow the words <em>should</em> or <em>may</em> in place of <em>shall</em> or <em>must</em>; however, these terms suggest that the requirement is optional. This book subscribes to the view that all requirements are necessary and therefore should not include the words <em>should</em> or <em>may</em>.</p>
<h4 class="h4" id="lev-10.1.2"><span epub:type="pagebreak" id="page_187"/><strong><em>10.1.2 Characteristics of Good Requirements</em></strong></h4>
<p class="noindent">This section discusses the attributes that characterize good requirements.</p>
<h5 class="h5" id="lev-10.1.2.1"><strong>10.1.2.1 Correct</strong></h5>
<p class="noindent">That requirements must be correct should go without saying, but research shows that about 40 percent of a project’s cost is due to errors in requirements. Therefore, taking time to review requirements and correct any mistakes is one of the most cost-efficient ways to ensure quality software.</p>
<h5 class="h5" id="lev-10.1.2.2"><strong>10.1.2.2 Consistent</strong></h5>
<p class="noindent">Requirements must be consistent with one another; that is, one requirement cannot contradict another. For example, if a pool temperature monitor states that an alarm must be triggered if the temperature falls below 70 degrees and another says that the same alarm must be triggered when the temperature falls below 65 degrees, the two requirements are inconsistent.</p>
<p class="indent">Note that consistency refers to requirements within the same document. If a requirement is not consistent with a requirement in a higher-level document, then that requirement is <em>incorrect</em>—never mind inconsistent.</p>
<h5 class="h5" id="lev-10.1.2.3"><strong>10.1.2.3 Feasible</strong></h5>
<p class="noindent">If you can’t feasibly implement a software requirement, then you don’t have a requirement. After all, requirements state what must be done in order to provide a satisfactory software solution; if the requirement is not viable, then it’s likewise impossible to provide the software solution.</p>
<h5 class="h5" id="lev-10.1.2.4"><strong>10.1.2.4 Necessary</strong></h5>
<p class="noindent">By definition, if a software requirement is not necessary, it is not a requirement. Requirements are costly to implement—they require documentation, code, test procedures, and maintenance—so you do not want to include a requirement unless it is necessary. Unnecessary requirements are often the result of “gold plating,” or adding features simply because somebody thought they would be cool, without regard to the costs involved in implementing them.</p>
<p class="indent">A requirement is necessary if it:</p>
<ul>
<li class="noindent">makes the product market competitive;</li>
<li class="noindent">addresses a need expressed by a customer, end user, or other stakeholder;</li>
<li class="noindent">differentiates the product or usage model; or</li>
<li class="noindent">is dictated by a business strategy, roadmap, or a sustainability need.</li>
</ul>
<h5 class="h5" id="lev-10.1.2.5"><strong>10.1.2.5 Prioritized</strong></h5>
<p class="noindent">Software requirements specify everything you must do to produce the desired application. However, given various constraints (time, budget, <span epub:type="pagebreak" id="page_188"/>and so on), you may not be able to implement every requirement in the first release of the software. Furthermore, as time passes (and dollars are spent), some requirements may be abandoned because things change. Therefore, a good requirement will have an associated priority. This can help drive the schedule, as teams implement the most critical features first and relegate the less important ones to the end of the project development cycle. Typically, three or four levels of priority should be sufficient: critical/mandatory, important, desirable, and optional are good examples.</p>
<h5 class="h5" id="lev-10.1.2.6"><strong>10.1.2.6 Complete</strong></h5>
<p class="noindent">A good requirement will be complete; that is, it will not contain any <em>TBD</em> (to be determined) items.</p>
<h5 class="h5" id="lev-10.1.2.7"><strong>10.1.2.7 Unambiguous</strong></h5>
<p class="noindent">Requirements must not be open to interpretation (note that TBD is a special case of this). Unambiguous means that a requirement has exactly one interpretation.</p>
<p class="indent">Because most requirements are written in a natural language (such as English) and natural languages are ambiguous, you must take special care when writing requirements to avoid ambiguity.</p>
<p class="indent">Example of an ambiguous requirement:</p>
<p class="blockquote">When the pool temperature is too cold the software shall signal an alarm.</p>
<p class="indent">An unambiguous example:</p>
<p class="blockquote">When the pool temperature is below 65 degrees (F) the software shall signal an alarm.</p>
<p class="indenta">Ambiguity results whenever the following natural language features appear in a requirement:</p>
<p class="uln-indent"><strong>Vagueness</strong> Results when you use <em>weak words</em>—those without a precise meaning—in a requirement. This section will discuss weak words shortly.</p>
<p class="uln-indent1"><strong>Subjectivity</strong> Refers to the fact that different people will assign a different meaning for a term (a weak word) based on their own personal experiences or opinion.</p>
<p class="uln-indent1"><strong>Incompleteness</strong> Results from using TBD items, partial specifications, or unbounded lists in a requirement. Unbounded lists will be discussed in this section a little later.</p>
<p class="uln-indent1"><strong>Optionality</strong> Occurs when you use phrases that make a requirement optional rather than required (for example, <em>is caused by</em>, <em>use of</em>, <em>should</em>, <em>may</em>, <em>if possible</em>, <em>when appropriate</em>, <em>as desired</em>).</p>
<p class="uln-indent1"><strong>Underspecification</strong> Occurs when a requirement does not fully specify the requirement, often as a result of using weak words (such as <em>support</em>, <em>analyzed</em>, <em>respond</em>, and <em>based on</em>).</p>
<p class="indenta"><span epub:type="pagebreak" id="page_189"/>Consider this requirement:</p>
<p class="blockquote">The pool monitor shall support Fahrenheit and Celsius scales.</p>
<p class="indenta1">What exactly does <em>support</em> mean in this context? One developer could interpret it to mean that the end user can select the input and output to be in degrees F or C (fixed), while another developer could interpret it to mean that both scales are used for output and that input allows either scale to be used. A better requirement might be:</p>
<p class="blockquote">The pool monitor setup shall allow the user to select either the Fahrenheit or Celsius temperature scale.</p>
<p class="uln-indent1"><strong>Underreference</strong> Refers to when a requirement provides an incomplete or missing reference to another document (such as a requirement’s origin).</p>
<p class="uln-indent1"><strong>Overgeneralization</strong> Occurs when a requirement contains universal qualifiers such as <em>any</em>, <em>all</em>, <em>always</em>, and <em>every</em>, or, in the negative sense, <em>none</em>, <em>never</em>, and <em>only</em>.</p>
<p class="uln-indent1"><strong>Nonintelligibility</strong> Results from poor writing (grammar), undefined terms, convoluted logic (for example, double negation), and incompleteness.</p>
<p class="uln-indent1"><strong>Passive voice</strong> Refers to when the requirement does not assign an actor to an action. For example, a bad requirement using the passive voice might be:</p>
<p class="blockquote">An alarm shall be raised if the temperature drops below 65 degrees F.</p>
<p class="indenta1">Who is responsible for raising the alarm? Different people could interpret this differently. A better requirement might be:</p>
<p class="blockquote">The pool monitor software shall raise an alarm if the temperature drops below 65 degrees F.</p>
<p class="indent">Using weak words in requirements often results in ambiguity. Examples of weak words include: <em>support</em>, <em>generally</em>, <em>kind of</em>, <em>mostly</em>, <em>pretty</em>, <em>slightly</em>, <em>somewhat</em>, <em>sort of</em>, <em>various</em>, <em>virtually</em>, <em>quickly</em>, <em>easy</em>, <em>timely</em>, <em>before</em>, <em>after</em>, <em>user-friendly</em>, <em>effective</em>, <em>multiple</em>, <em>as possible</em>, <em>appropriate</em>, <em>normal</em>, <em>capability</em>, <em>reliable</em>, <em>state-of-the-art</em>, <em>effortless</em>, and <em>multi.</em></p>
<p class="indent">For example, a requirement such as “The pool monitor shall provide multiple sensors” is ambiguous because <em>multiple</em> is a weak word. What does it mean? Two? Three? A dozen?</p>
<p class="indent">Another way to create an ambiguous requirement is by using an unbounded list—a list missing a starting point, an ending point, or both. Typical examples include phrasing like <em>at least</em>; <em>including, but not limited to</em>; <em>or later</em>; <em>or more</em>; <em>such as</em>; <em>and so on</em>; and <em>etc.</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_190"/>For example: “The pool monitor shall support three or more sensors.” Does it have to support four sensors? Ten sensors? An infinite number of sensors? This requirement doesn’t make it clear what the maximum number of supported sensors is. A better requirement might be:</p>
<p class="blockquote">The pool monitor must support between three and six sensors.</p>
<p class="indent">Unbounded lists are impossible to design and test against (so they fail both the feasible and verifiable attributes).</p>
<h5 class="h5" id="lev-10.1.2.8"><strong>10.1.2.8 Implementation-Independent</strong></h5>
<p class="noindent">Requirements must be based solely on the inputs and outputs of a system. They should not delve into the implementation details of the application (that’s the purpose of the Software Design Description [SDD] document). Requirements must view the system as a black box into which inputs are fed and from which outputs are produced.</p>
<p class="indent">For example, a requirement might state that an input to the system is a list of numbers that produce a sorted list as output. The requirement should not state something like “A quicksort algorithm shall be used.” There may be good reasons why the software designer would want to use a different algorithm; the requirements should not force the software designer’s or programmer’s hand.</p>
<h5 class="h5" id="lev-10.1.2.9"><strong>10.1.2.9 Verifiable</strong></h5>
<p class="noindent">“If it isn’t testable, it isn’t a requirement” is the mantra by which a requirements author should live. If you can’t create a test for it, you also can’t verify that the requirement has been fulfilled in the final product. Indeed, the requirement might very well be impossible to implement if you can’t come up with a way to test it.</p>
<p class="indent">If you can’t create a physical test that can be run on the final software product, there’s a good chance that your requirement is not based solely on system inputs and outputs. For example, if you have a requirement that states “The system shall use the quicksort algorithm to sort the data,” how do you test for this? If you have to resort to “This requirement is tested by reviewing the code,” then you may not have a good requirement. That’s not to say that requirements can’t be verified by inspection or analysis, but an actual test is always the best way to verify a requirement, especially if you can automate that test.</p>
<h5 class="h5" id="lev-10.1.2.10"><strong>10.1.2.10 Atomic</strong></h5>
<p class="noindent">A good requirement statement must not contain multiple requirements—that is, it must not be a compound requirement. Requirements should also be as independent as possible; their implementation should not rely on other requirements.</p>
<p class="indent">Some authors claim that the words <em>and</em> and <em>or</em> must never appear in a requirement. Strictly speaking, this isn’t true. You simply want to avoid <span epub:type="pagebreak" id="page_191"/>using the <em>fanboys</em> conjunctions (<em>for</em>, <em>and</em>, <em>nor</em>, <em>but</em>, <em>or</em>, <em>yet</em>, <em>so</em>) to combine separate requirements into a single statement. For example, the following is not a compound requirement:</p>
<p class="blockquote">The pool monitor shall set the “good” indication when the temperature is between 70 degrees F <em>and</em> 85 degrees F.</p>
<p class="indent">This is a single requirement, not two. The presence of the word <em>and</em> does not produce two requirements. If you really want to be a stickler and eliminate the word <em>and</em>, you could rewrite the requirement thusly:</p>
<p class="blockquote">The pool monitor shall set the “good” indication when the temperature is in the range from 70 degrees F to 85 degrees F.</p>
<p class="indent">However, there’s really nothing wrong with the first version. Here’s an example of a compound requirement:</p>
<p class="blockquote">The pool monitor shall clear the “good” indication when the temperature is below 70 degrees F <em>or</em> above 85 degrees F.</p>
<p class="indent">This should be rewritten as two separate requirements:<sup><a href="ch19_footnote.xhtml#ch10fn1" id="ch10fn1a">1</a></sup></p>
<p class="blockquote">The pool monitor shall clear the “good” indication when the temperature is below 70 degrees F.</p>
<p class="blockquote">The pool monitor shall clear the “good” indication when the temperature is above 85 degrees F.</p>
<p class="indent">Note that compound requirements will create problems later when you’re constructing traceability matrices, as this chapter will discuss in “Updating the Traceability Matrix with Requirement Information” on <a href="ch10.xhtml#page_222">page 222</a>. Compound requirements also create testing problems. The test for a requirement must produce a single answer: pass or fail. You cannot have part of a requirement pass and another part fail. That’s a sure sign of a compound requirement.</p>
<h5 class="h5" id="lev-10.1.2.11"><strong>10.1.2.11 Unique</strong></h5>
<p class="noindent">A requirements specification must not contain any duplicate requirements. Duplication makes the document much more difficult to maintain, particularly if you ever modify requirements and forget to modify the duplicates.</p>
<h5 class="h5" id="lev-10.1.2.12"><strong>10.1.2.12 Modifiable</strong></h5>
<p class="noindent">It would be unreasonable to expect the requirements of a project to remain constant over its lifetime. Expectations change, technology changes, the market changes, and the competition changes. During product development, you’ll likely want to revise some requirements to adapt to evolving <span epub:type="pagebreak" id="page_192"/>conditions. In particular, you don’t want to choose requirements that enforce certain system constraints that other requirements will be based on. For example, consider the following requirement:</p>
<p class="blockquote">The pool monitor shall use an Arduino Mega 2560 single-board computer as the control module.</p>
<p class="indent">Based on this requirement, other requirements might be “The pool monitor shall use the A8 pin for the pool level indication” and “The pool monitor shall use the D0 pin as the low temperature output.” The problem with such requirements, which are based on the use of the Mega 2560 board, is that if a new board comes along (say, a Teensy 4.0 module), then changing the first requirement necessitates also changing all the other requirements that depend on it. A better set of requirements might be:</p>
<p class="blockquote">The pool monitor shall use a single-board computer that supports 8 analog inputs, 4 digital outputs, and 12 digital inputs.</p>
<p class="blockquote">The pool monitor shall use one of the digital output pins as the low temperature alarm.</p>
<p class="blockquote">The pool monitor shall use one of the analog input pins as the pool level input.</p>
<h5 class="h5" id="lev-10.1.2.13"><strong>10.1.2.13 Traceable</strong></h5>
<p class="noindent">All requirements must be forward- and reverse-traceable. <em>Reverse traceability</em> means that the requirement can be traced to its origin. To be traceable to some other object, the requirement must have a <em>tag</em> (a unique identifier, as introduced in <a href="ch04.xhtml">Chapter 4</a>).</p>
<p class="indent">Each requirement must include the origin as part of the requirement text or tag; otherwise, you must provide a separate RTM document (or database) that provides that information. In general, you should explicitly list a requirement’s origin within the requirement itself.</p>
<p class="indent"><em>Forward traceability</em> provides a link to all documents based on (or spawned by) the requirements document. Most of the time, forward traceability is handled via an RTM document; it would be too much work to maintain this information in each requirements document (there would be too much duplicate information, which, as previously noted, makes document maintenance difficult).</p>
<h5 class="h5" id="lev-10.1.2.14"><strong>10.1.2.14 Positively Stated</strong></h5>
<p class="noindent">A requirement should state what must be true, not what must <em>not</em> happen. Most negatively stated requirements are impossible to verify. For example, the following is a bad requirement:</p>
<p class="blockquote">The pool monitor shall not operate at atmospheric temperatures below freezing.</p>
<p class="indent"><span epub:type="pagebreak" id="page_193"/>This requirement suggests that the pool monitor must stop operation once the temperature drops below freezing. Does this mean that the system will sense the temperature and shut down below freezing? Or does it simply mean that the system cannot be expected to produce reasonable values below freezing? Better requirements might be:</p>
<p class="blockquote">The pool monitor shall automatically shut off if the temperature falls below freezing.</p>
<p class="indent">Hopefully, there is a requirement that discusses what should happen when the temperature rises back above freezing. If the pool monitor has been shut off, can it sense this change?</p>
<h3 class="h3" id="lev-10.2"><strong>10.2 Design Goals</strong></h3>
<p class="noindent">Although requirements can’t be optional, it’s sometimes beneficial to be able to list optional items in a requirements document. Such items are known as design goals.</p>
<p class="indent">Design goals violate many of the attributes of good requirements. Obviously, they are not necessary, but they can also be incomplete, be slightly ambiguous, specify implementation, or not be testable. For example, a design goal might be to use the C standard library’s built-in <span class="literal">sort()</span> function (an implementation detail) in order to reduce development time. Another design goal might be something like:</p>
<p class="blockquote">The pool monitor should support as many sensors as possible.</p>
<p class="indent">As you can see, this is both optional and open-ended. A design goal is a suggestion that a developer can use to guide development choices. It should not involve extra design work or testing that leads to further development expenses. It should simply help a developer make certain developmental choices when designing the system.</p>
<p class="indent">Like requirements, design goals can have tags, though there’s little need to trace design goals through the documentation system. However, because they might be elevated to requirement status at some point, it’s nice to have a tag associated with them so they can serve as an origin for a requirement in a spawned document.</p>
<h3 class="h3" id="lev-10.3"><strong>10.3 The System Requirements Specification Document</strong></h3>
<p class="noindent">The System Requirements Specification document collects all the requirements associated with a complete system. This may include business requirements, legislative/political requirements, hardware requirements, and software requirements. The SyRS is usually a very high-level document, though internal to an organization. Its purpose is to provide a <em>single-source</em> origin for all requirements appearing in an organization’s subservient documents (such as the SRS).</p>
<p class="indent"><span epub:type="pagebreak" id="page_194"/>The SyRS takes the same form as the SRS (described in the next section), so I won’t further elaborate on its contents other than to point out that the SyRS spawns the SRS (and Hardware Requirements Specifications, or HRS, if appropriate). The SyRS is optional and typically absent in small software-only projects.</p>
<p class="indent">SyRS requirements typically state “The <em>system</em> shall” or “The <em>system</em> must.” This is in contrast to requirements in the SRS that typically state “The <em>software</em> shall” or “The <em>software</em> must.”</p>
<h3 class="h3" id="lev-10.4"><strong>10.4 The Software Requirements Specification Document</strong></h3>
<p class="noindent">The Software Requirements Specification is a document that contains all the requirements and design goals for a given software project. There are (literally) hundreds, if not thousands, of examples of SRS documents scattered across the internet. Many sites seem to have their own ideas about what constitutes an SRS. Rather than introduce yet another new template into the cacophony, this book will elect to use the template defined by the IEEE: the IEEE 830-1998 Recommended Practice for Software Requirements Specifications.</p>
<p class="indent">In this book, using the IEEE 830-1998 recommended practice is a safe decision, but note that the standard is by no means perfect. It was created by a committee and, as a result, it contains a lot of bloat (extraneous information). The problem with committee-designed standards is that the only way to get them approved is by letting everyone inject their own pet ideas into the document, even if those ideas conflict with others in the document. Nevertheless, the IEEE 830-1998 recommendation is a good starting point. You need not feel compelled to implement everything in it, but you should use it as a guideline when creating your SRS.</p>
<p class="indent">A typical SRS uses an outline similar to the following:</p>
<p class="numbert"><strong>Table of Contents</strong></p>
<p class="number1">1 Introduction</p>
<p class="number2">1.1 Purpose</p>
<p class="number2">1.2 Scope</p>
<p class="number2">1.3 Definitions, Acronyms, and Abbreviations</p>
<p class="number2">1.4 References</p>
<p class="number2">1.5 Overview</p>
<p class="number1">2 Overall Description</p>
<p class="number2">2.1 Product Perspective</p>
<p class="number3">2.1.1 System Interfaces</p>
<p class="number3">2.1.2 User Interfaces</p>
<p class="number3">2.1.3 Hardware Interfaces</p>
<p class="number3">2.1.4 Software Interfaces</p>
<p class="number3"><span epub:type="pagebreak" id="page_195"/>2.1.5 Communication Interfaces</p>
<p class="number3">2.1.6 Memory Constraints</p>
<p class="number3">2.1.7 Operations</p>
<p class="number2">2.2 Site Adaptation Requirements</p>
<p class="number2">2.3 Product Functions</p>
<p class="number2">2.4 User Characteristics</p>
<p class="number2">2.5 Constraints</p>
<p class="number2">2.6 Assumptions and Dependencies</p>
<p class="number2">2.7 Apportioning of Requirements</p>
<p class="number1">3 Specific Requirements</p>
<p class="number2">3.1 External Interfaces</p>
<p class="number2">3.2 Functional Requirements</p>
<p class="number2">3.3 Performance Requirements</p>
<p class="number2">3.4 Logical Database Requirements</p>
<p class="number2">3.5 Design Constraints</p>
<p class="number2">3.6 Standards Compliance</p>
<p class="number2">3.7 Software System Attributes</p>
<p class="number3">3.7.1 Reliability</p>
<p class="number3">3.7.2 Availability</p>
<p class="number3">3.7.3 Security</p>
<p class="number3">3.7.4 Maintainability</p>
<p class="number3">3.7.5 Portability</p>
<p class="number2">3.8 Design Goals</p>
<p class="number1">4 Appendixes</p>
<p class="number1">5 Index</p>
<p class="indenta">Section 3 is the most important—this is where you will place all of your requirements as well as your design goals.</p>
<h4 class="h4" id="lev-10.4.1"><strong><em>10.4.1 Introduction</em></strong></h4>
<p class="noindent">The Introduction contains an overview of the entire SRS. The following subsections describe the suggested contents of the Introduction.</p>
<h5 class="h5" id="lev-10.4.1.1"><strong>10.4.1.1 Purpose</strong></h5>
<p class="noindent">In the Purpose section, you should state the purpose of the SRS and who the intended audience is. For an SRS, the intended audience is probably the customers who will need to validate the SRS and the developers/designers who will create the SDD, software test cases, and software test procedures, and will write the code.</p>
<h5 class="h5" id="lev-10.4.1.2"><span epub:type="pagebreak" id="page_196"/><strong>10.4.1.2 Scope</strong></h5>
<p class="noindent">The Scope section describes the software product by name (for example, Plantation Productions Pool Monitor), explains what the product will do, and, if necessary, states what it will <em>not</em> do. (Don’t worry that this doesn’t adhere to the “positively stated” rule, since this is a scope declaration, not a requirement statement.) The Scope section also outlines the objectives of the project, the benefits and goals of the product, and the application software being written for the product.</p>
<h5 class="h5" id="lev-10.4.1.3"><strong>10.4.1.3 Definitions, Acronyms, and Abbreviations</strong></h5>
<p class="noindent">The Definitions section provides a glossary of all terms, acronyms, and abbreviations the SRS uses.</p>
<h5 class="h5" id="lev-10.4.1.4"><strong>10.4.1.4 References</strong></h5>
<p class="noindent">The References section provides a link to all external documents that the SRS references. If your SRS relies on an external RTM document, you should reference that document here. If the documents are internal to the organization, you should provide their internal document numbers/references. If the SRS references a document that is external to the organization, the SRS should list the document’s title, author, publisher, and date as well as information on how to obtain the document.</p>
<h5 class="h5" id="lev-10.4.1.5"><strong>10.4.1.5 Overview</strong></h5>
<p class="noindent">The Overview section describes the format of the rest of the SRS and the information it contains (this section is particularly important if you’ve omitted items from the IEEE recommendation).</p>
<h4 class="h4" id="lev-10.4.2"><strong><em>10.4.2 Overall Description</em></strong></h4>
<p class="noindent">The Overall Description section specifies the requirements of the following aspects:</p>
<h5 class="h5" id="lev-10.4.2.1"><strong>10.4.2.1 Product Perspective</strong></h5>
<p class="noindentt">The Product Perspective section contextualizes the product with respect to other (possibly competing) products. If this product is part of a larger system, the product perspective should point this out (and describe how the requirements in this document relate to the larger system). This section might also describe various constraints on the product, such as:</p>
<h6 class="h6" id="lev-10.4.2.1.1"><strong>10.4.2.1.1 System Interfaces</strong></h6>
<p class="noindentt">This section describes how the software will interface with the rest of the system. This would typically include any APIs, such as how the software interfaces with a Wi-Fi adapter in order to view pool readings remotely.</p>
<h6 class="h6" id="lev-10.4.2.1.2"><span epub:type="pagebreak" id="page_197"/><strong>10.4.2.1.2 User Interfaces</strong></h6>
<p class="noindentt">This section lists all user interface (UI) elements needed to meet the requirements. For example, in the pool monitor scenario, this section could describe how the user interacts with the device via an LCD display and various push buttons on the device.</p>
<h6 class="h6" id="lev-10.4.2.1.3"><strong>10.4.2.1.3 Hardware Interfaces</strong></h6>
<p class="noindentt">This section could describe how the software interacts with the underlying hardware. For example, the pool monitor SRS could state that the software will be running on an Arduino Mega 2560, using the A8 through A15 analog inputs to connect to the sensors and the D0 through D7 digital lines as inputs connected to buttons.</p>
<h6 class="h6" id="lev-10.4.2.1.4"><strong>10.4.2.1.4 Software Interfaces</strong></h6>
<p class="noindentt">This section describes any additional/external software needed to implement the system. This might include operating systems, third-party libraries, database management systems, or other application systems. For example, the pool monitor SRS might describe the use of vendor-supplied libraries needed to read data from various sensors. For each software item, you should include the following information in this section:</p>
<ul class="bullet1zz1">
<li class="noindent">Name</li>
<li class="noindent">Specification number (a vendor-supplied value, if any)</li>
<li class="noindent">Version number</li>
<li class="noindent">Source</li>
<li class="noindent">Purpose</li>
<li class="noindent">Reference to pertinent documentation</li>
</ul>
<h6 class="h6" id="lev-10.4.2.1.5"><strong>10.4.2.1.5 Communication Interfaces</strong></h6>
<p class="noindentt">This section lists any communication interfaces, such as Ethernet, Wi-Fi, Bluetooth, and RS-232 serial that the product will use. For example, the pool monitor SRS might describe the Wi-Fi interface in this section.</p>
<h6 class="h6" id="lev-10.4.2.1.6"><strong>10.4.2.1.6 Memory Constraints</strong></h6>
<p class="noindentt">This section describes all the constraints on memory and data storage. For the pool monitor running on an Arduino Mega 2560, SRS might state that there is a limitation in program storage of 1K EEPROM and 8K RAM plus 64K to 128K Flash.</p>
<h6 class="h6" id="lev-10.4.2.1.7"><strong>10.4.2.1.7 Operations</strong></h6>
<p class="noindentt">This section (often folded into the UI section) describes various operations on the product. It might detail the various modes of operation—such as normal, reduced power, maintenance, or installation modes—and describe interactive sessions, unattended sessions, and communication features.</p>
<h5 class="h5" id="lev-10.4.2.2"><span epub:type="pagebreak" id="page_198"/><strong>10.4.2.2 Site Adaptation Requirements</strong></h5>
<p class="noindent">This section describes any site-specific adaptations. For example, the pool monitor SRS might describe optional sensors for pools with spas in this section.</p>
<h5 class="h5" id="lev-10.4.2.3"><strong>10.4.2.3 Product Functions</strong></h5>
<p class="noindent">The Product Functions section describes the software’s (major) functionality. For example, the pool monitor SRS might use this section to describe how the software monitors pool levels, pool temperatures, atmospheric temperature, water conductivity (for saltwater pools), water flow though the filtration system, and filtration time since the last filter cleaning.</p>
<h5 class="h5" id="lev-10.4.2.4"><strong>10.4.2.4 User Characteristics</strong></h5>
<p class="noindent">The User Characteristics section describes the people that will use the product. For example, the pool monitor SRS might define a factory test technician (responsible for testing and repairing the unit), a field installation technician, an advanced end user, and an average end user. There may be different requirements for the software that apply only to certain types of users.</p>
<h5 class="h5" id="lev-10.4.2.5"><strong>10.4.2.5 Constraints</strong></h5>
<p class="noindent">The Constraints section describes any limitations that may affect the developer’s choices when designing and implementing the software, such as:</p>
<ul>
<li class="noindent">Regulatory policies</li>
<li class="noindent">Hardware limitations (for example, signal timing requirements)</li>
<li class="noindent">Interfaces to other applications</li>
<li class="noindent">Parallel operation</li>
<li class="noindent">Audit functions</li>
<li class="noindent">Control functions</li>
<li class="noindent">High-level language requirements</li>
<li class="noindent">Signal handshake protocols (for example, XON-XOFF)</li>
<li class="noindent">Reliability requirements</li>
<li class="noindent">Criticality of the application</li>
<li class="noindent">Safety and security considerations</li>
</ul>
<h5 class="h5" id="lev-10.4.2.6"><strong>10.4.2.6 Assumptions and Dependencies</strong></h5>
<p class="noindent">The items listed in the Assumptions and Dependencies section apply only to the requirements; they do not present constraints on the design. If an assumption were to change, it would require changing requirements rather than the design (though changing requirements will likely affect the design as well). For example, in the pool monitor SRS an assumption might be that the Arduino Mega 2560 will provide sufficient computing <span epub:type="pagebreak" id="page_199"/>power, ports, and memory to complete the task. If this assumption is incorrect, it may affect some requirements with respect to port usage, available memory, and the like.</p>
<h5 class="h5" id="lev-10.4.2.7"><strong>10.4.2.7 Apportioning of Requirements</strong></h5>
<p class="noindent">The Apportioning of Requirements section divides the requirements and features into two or more groups: those to be implemented in the current release, and those planned for future versions of the software.</p>
<h4 class="h4" id="lev-10.4.3"><strong><em>10.4.3 Specific Requirements</em></strong></h4>
<p class="noindent">The Specific Requirements section should list all the requirements and supporting documentation. This documentation should be written such that a system designer can construct a design for the software from the requirements documented.</p>
<p class="indent">All requirements should possess the characteristics discussed earlier in this chapter. They should also have a tag and a cross-reference (trace) to their origin. Because the requirements documentation will be read far more times than it is written, you should take special care to make this document as readable as possible.</p>
<h5 class="h5" id="lev-10.4.3.1"><strong>10.4.3.1 External Interfaces</strong></h5>
<p class="noindent">The External Interfaces section should describe all the inputs and outputs of the software system in great detail but without replicating the information in the interface subsections of the Product Perspective section. Each listing should contain the following information (as appropriate for the system):</p>
<ul>
<li class="noindent">Tag</li>
<li class="noindent">Description</li>
<li class="noindent">Input source or output destination</li>
<li class="noindent">Valid range of values plus necessary accuracy/precision/tolerance</li>
<li class="noindent">Measurement units</li>
<li class="noindent">Timing and tolerances</li>
<li class="noindent">Relationship to other input/output items</li>
<li class="noindent">Screen/window formats (but list only screen requirements that are actual requirements—don’t design the user interface here)</li>
<li class="noindent">Data formats</li>
<li class="noindent">Command formats, protocols, and any necessary sentinel messages</li>
</ul>
<p class="indent">Many SRS authors will pull this section out of the Specific Requirements section and place it in the Product Perspective section in order to avoid redundancy, though the IEEE 830-1998 standard suggests that this section be part of the Specific Requirements section. However, the IEEE document is only a <em>recommended</em> practice, so the choice is really yours. What matters most is that the information appears in the SRS.</p>
<h5 class="h5" id="lev-10.4.3.2"><span epub:type="pagebreak" id="page_200"/><strong>10.4.3.2 Functional Requirements</strong></h5>
<p class="noindent">The Functional Requirements section contains those items that most people immediately recognize as requirements. This section lists the fundamental activities that take place on inputs and describes how the system uses the inputs to produce outputs. By convention, functional requirements always contain the auxiliary verb <em>shall</em>. For example, “The software <em>shall</em> raise an alarm when the pool low input is active.”</p>
<p class="indent">Typical functional requirements include the following:</p>
<ul>
<li class="noindent">Input validity checks and responses to invalid inputs</li>
<li class="noindent">Operation sequences</li>
<li class="noindent">Abnormal condition responses, including: overflow, underflow, arithmetic exceptions, communication failures, resource overruns, error handling and recovery, and protocol errors</li>
<li class="noindent">Persistence of data across executions of the software</li>
<li class="noindent">Effect of parameters</li>
<li class="noindent">Input/output relationships, including: legal and illegal input patterns, relationship of inputs to output, and how outputs are computed from inputs (but be careful not to incorporate software design into the requirements)</li>
</ul>
<h5 class="h5" id="lev-10.4.3.3"><strong>10.4.3.3 Performance Requirements</strong></h5>
<p class="noindent">The Performance Requirements section lists nonfunctional requirements that specify either static or dynamic performance targets that the software must hit. Like most nonfunctional requirements, performance requirements usually contain the auxiliary verb <em>must</em>—for example, “The software <em>must</em> be able to control an internal display and a remote display.”</p>
<p class="indent">Static performance requirements are those that are defined for the system as a whole and do not depend on the software’s capabilities. A good example for the pool monitor is “The pool monitor must be able to read sensor input data from between 5 and 10 analog sensors.” This is a static requirement because the number of sensors is static for a given installation (it isn’t going to change because the software is written more efficiently, for example).</p>
<p class="indent">Dynamic performance requirements are those that the software must meet during execution. A good example might be “The software must read each sensor between 10 and 20 times per second.”</p>
<h5 class="h5" id="lev-10.4.3.4"><strong>10.4.3.4 Logical Database Requirements</strong></h5>
<p class="noindent">The Logical Database Requirements section describes nonfunctional requirements that specify the record and field formats for databases that the application must access. Typically, these requirements deal with externally accessed databases. Databases internal to the application (that is, not visible to the outside world) are generally outside the domain of the software requirements, although the SDD might cover these.</p>
<h5 class="h5" id="lev-10.4.3.5"><span epub:type="pagebreak" id="page_201"/><strong>10.4.3.5 Design Constraints</strong></h5>
<p class="noindent">Standards compliance is an example of a <em>design constraint</em>. Any limitation that prevents the software designer from using an arbitrary implementation should be listed in the Design Constraints section. One example might be limiting readings from a 16-bit A/D converter to 13 bits because the A/D chip/circuit is noisy and the low-order 3 bits may not be reliable.</p>
<h5 class="h5" id="lev-10.4.3.6"><strong>10.4.3.6 Standards Compliance</strong></h5>
<p class="noindent">The Standards Compliance section should describe, and provide links to, all standards to which the software must adhere. Standards numbers and document descriptions should allow the reader to research the standards as necessary.</p>
<h5 class="h5" id="lev-10.4.3.7"><strong>10.4.3.7 Software System Attributes</strong></h5>
<p class="noindent">The Software System Attributes section lists characteristics for the software system, including:</p>
<h6 class="h6" id="lev-10.4.3.7.1"><strong>10.4.3.7.1 Reliability</strong></h6>
<p class="noindentt">The Requirements section will specify the expected uptime requirements for the software system. Reliability is a nonfunctional requirement that describes, usually as a percentage, the amount of time that the system will operate without a failure. A typical example is “an expected reliability of 99.99 percent,” meaning that the software will fail no more than 0.01 percent of the time. As with many nonfunctional requirements, it can be difficult to provide tests to ensure that reliability targets are met.</p>
<h6 class="h6" id="lev-10.4.3.7.2"><strong>10.4.3.7.2 Availability</strong></h6>
<p class="noindentt">The availability attribute specifies the amount of <em>downtime</em> that is acceptable in the final application (actually, it specifies the <em>inverse</em> of downtime). Availability specifies the ability of the user to access the software system at any time. When the system is <em>down</em>, it is not available to the user. This nonfunctional requirement might differentiate between scheduled downtime and unscheduled downtime (for example, a hardware failure that forces a restart of the system).</p>
<h6 class="h6" id="lev-10.4.3.7.3"><strong>10.4.3.7.3 Security</strong></h6>
<p class="noindentt">The security attribute is a nonfunctional requirement that specifies the expected system security, which could include items such as encryption expectations and network socket types.</p>
<h6 class="h6" id="lev-10.4.3.7.4"><strong>10.4.3.7.4 Maintainability</strong></h6>
<p class="noindentt">Maintainability is another nonfunctional requirement that can be hard to specify and test. In most specifications, there is a nebulous statement like “the software shall be easy to maintain.” This is unhelpful. Instead, this attribute should state, “It must take an experienced maintenance programmer no more than a week to come up to speed on this system and make changes to it.”</p>
<div class="sidebar"><span epub:type="pagebreak" id="page_202"/>
<p class="sidebart">REQUIREMENT ORGANIZATION</p>
<p class="sidebarp">Any sufficiently complex system will have a large number of requirements, so the SRS can become unwieldy if it is not organized properly. There are many different application types, and an equally large number of ways to organize their requirements. No particular organization is correct; you’ll have to choose one of the following options based on the audience for your SRS.</p>
<p class="sidebarp1"><strong>Organizing by system mode</strong></p>
<p class="sidebarp2">Some systems operate in various modes—for example, an embedded system might have a low-power mode and a regular mode. In that case, you could organize the system requirements into those two groups.</p>
<p class="sidebarp1"><strong>Organizing by user class</strong></p>
<p class="sidebarp2">Some systems support different classes of users (for example, beginners, power users, and system administrators). In a complex system, you might have normal users, power users, maintenance workers, and programmers accessing the system.</p>
<p class="sidebarp1"><strong>Organizing by object class</strong></p>
<p class="sidebarp2">Objects are entities in the software system that correspond to real-world objects. You could organize your requirements based on the types or classes of these objects.</p>
<p class="sidebarp1"><strong>Organizing by feature</strong></p>
<p class="sidebarp2">One of the more common ways to organize SRS requirements is by the features they implement. This is a particularly useful method of organization when the application provides a user interface for all the features in the system.</p>
<p class="sidebarp1"><strong>Organizing by input stimulus</strong></p>
<p class="sidebarp2">If processing different inputs is a primary activity of the application, then you might consider organizing your SRS by the type of inputs the application processes.</p>
<p class="sidebarp1"><strong>Organizing by output response</strong></p>
<p class="sidebarp2">Similarly, if producing a wide range of outputs is a primary activity of the application, then it might make sense to organize the requirements by output response.</p>
<p class="sidebarp1"><strong>Organizing by functional hierarchy</strong></p>
<p class="sidebarp2">Another common SRS organization approach is by functionality. This is often the fallback position SRS authors use when no other organization seems appropriate. Grouping the requirements by common inputs, command outputs, common database operations, and data flow through the program are all reasonable ways to organize the SRS.</p>
</div>
<h6 class="h6" id="lev-10.4.3.7.5"><span epub:type="pagebreak" id="page_203"/><strong>10.4.3.7.5 Portability</strong></h6>
<p class="noindentt">Portability describes what is involved in moving the software to a different environment. This section should include a discussion of portability across CPUs, operating systems, and programming language dialects.</p>
<h5 class="h5" id="lev-10.4.3.8"><strong>10.4.3.8 Design Goals</strong></h5>
<p class="noindent">Often it is tempting to put so-called optional requirements into an SRS. However, as noted earlier in this chapter, requirements by definition cannot be optional. Nevertheless, there will be times when you might wish to say, “If possible, add this feature.” You can state such requests as design goals and leave it up to the designer or software engineer to decide if the feature is worth having. Place design goals in a separate section and clearly state “<em>As a design goal</em>, the software should . . . ” in your SRS.</p>
<h4 class="h4" id="lev-10.4.4"><strong><em>10.4.4 Supporting Information</em></strong></h4>
<p class="noindent">Any good software requirements specification will contain supporting information such as a table of contents, appendixes, glossaries, and an index. There should also be a table of requirement tags (sorted numerically or lexicographically) that lists each tag, a short description of the requirement, and the page number where it appears in the document (this could also be placed in the RTM rather than in the SRS).</p>
<h4 class="h4" id="lev-10.4.5"><strong><em>10.4.5 A Sample Software Requirements Specification</em></strong></h4>
<p class="noindent">This section provides a sample SRS for a swimming pool monitor similar to the examples given thus far in this chapter. For space reasons, this swimming pool monitor SRS is greatly simplified; the purpose is not to provide a complete specification, but rather to provide an illustrative outline.</p>
<p class="numbert"><strong>Table of Contents</strong></p>
<p class="number1"><strong>1 Introduction</strong></p>
<p class="number2"><strong>1.1 Purpose</strong></p>
<p class="numberp">The pool monitor device will track pool water levels and automatically refill the pool when levels are low.</p>
<p class="number2"><strong>1.2 Scope</strong></p>
<p class="numberp">The pool monitor software will be produced from this specification.</p>
<p class="numberp">The objectives of the hardware and software development are to provide functions, status information, monitor and control hardware, communications, and self-test functions per the requirements that have been allocated to the pool monitor system.</p>
<p class="number2"><span epub:type="pagebreak" id="page_204"/><strong>1.3 Definitions, Acronyms, and Abbreviations</strong></p>
<table class="topbot-d">
<colgroup>
<col style="width:30%"/>
<col style="width:70%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Term</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Definition</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">Accuracy</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">The degree of agreement with the true value of the measured input, expressed as percent of reading for digital readouts (ANSI N42.18-1980).</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba">Anomaly</p></td>
<td style="vertical-align: top;"><p class="taba">Anything observed in the documentation or operation of software that deviates from expectations. (Derived from IEEE Std 610.12-1990.)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">Catastrophic event</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">An event without warning from which recovery is impossible. Catastrophic events include hardware or software failures resulting in computation and processing errors. The processor will halt or reset, based on a configuration item, after a catastrophic event.</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba">Handled conditions</p></td>
<td style="vertical-align: top;"><p class="taba">Conditions that the system is designed to handle and continue processing. These conditions include anomalies, faults, and failures.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">SBC</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Single-board computer</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba">Software Requirements Specification (SRS)</p></td>
<td style="vertical-align: top;"><p class="taba">Documentation of the essential requirements (functions, performance, design constraints, and attributes) of the software and its external interfaces (IEEE Std 610.12-1990).</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">SPM</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Swimming pool monitor</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba">System Requirements Specification (SyRS)</p></td>
<td style="vertical-align: top;"><p class="taba">A structured collection of information that embodies the requirements of the system (IEEE Std 1233-1998). A specification that documents the requirements to establish a design basis and the conceptual design for a system or subsystem.</p></td>
</tr>
</tbody>
</table>
<p class="number2"><strong>1.4 References</strong></p>
<p class="numberp">[None]</p>
<p class="number2"><strong>1.5 Overview</strong></p>
<p class="numberp">Section 2 provides an overall description of the swimming pool monitor (hardware and software).</p>
<p class="numberp">Section 3 lists the specific requirements for the swimming pool monitor system.</p>
<p class="numberp">Sections 4 and 5 provide any necessary appendixes and an index.</p>
<p class="numberp">In section 3, requirements tags take the following form:</p>
<table class="none">
<colgroup>
<col style="width:50%"/>
<col style="width:50%"/>
</colgroup>
<tbody>
<tr>
<td style="vertical-align: top;"><p class="taba1">&lt;whitespace&gt;</p></td>
<td style="vertical-align: top;"><p class="indent">[POOL_SRS_<em>xxx</em>]</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba1">&lt;whitespace&gt;</p></td>
<td style="vertical-align: top;"><p class="indent">[POOL_SRS_<em>xxx.yy</em>]</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba1">&lt;whitespace&gt;</p></td>
<td style="vertical-align: top;"><p class="indent">[POOL_SRS_<em>xxx.yy.zz</em>]</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba1">&lt;and so on&gt;.</p></td>
<td style="vertical-align: top;"><p class="indent"> </p></td>
</tr>
</tbody>
</table>
<p class="numberp">where <em>xxx</em> is a three- or four-digit SRS requirement number.</p>
<p class="numberp">Should the need arise to insert a new SRS requirement tag between two other values (for example, add a requirement between <span epub:type="pagebreak" id="page_205"/>POOL_SRS_040 and POOL_SRS_041), then a decimal fractional number shall be appended to the SRS tag number (for example, POOL_SRS_040.5). Any number of decimal point suffixes can be added, if needed (for example, POOL_SRS_40.05.02).</p>
<p class="number1"><strong>2 Overall Description</strong></p>
<p class="numberp1">The purpose behind the swimming pool monitor (SPM) is to provide an automatic system for maintaining water level in the pool. This task is sufficiently simple to allow the creation of an SRS that is short enough to fit within this chapter.</p>
<p class="number2"><strong>2.1 Product Perspective</strong></p>
<p class="numberp">In the real world, an SPM would probably provide many additional features; adding those features here would only increase the size of the SRS without providing much additional educational benefit. This specification is intentionally simplified in order to fit within the editorial requirements of this book.</p>
<p class="number3"><strong>2.1.1 System Interfaces</strong></p>
<p class="numberp2">The SPM design assumes the use of an Arduino-compatible SBC. Accordingly, the software will interface to the hardware using Arduino-compatible libraries.</p>
<p class="number3"><strong>2.1.2 User Interfaces</strong></p>
<p class="numberp2">The user interface shall consist of a small four-line display (minimum 20 characters/line), six push buttons (up, down, left, right, cancel/back, and select/enter), and a rotary encoder (rotating knob).</p>
<p class="number3"><strong>2.1.3 Hardware Interfaces</strong></p>
<p class="numberp2">This document doesn’t specify a particular SBC to use. However, the SBC must provide at least the following:</p>
<ul class="bullet1z">
<li class="noindent">16 digital inputs</li>
<li class="noindent">1 analog input</li>
<li class="noindent">2 digital outputs</li>
<li class="noindent">A small amount of nonvolatile, writable memory (for example, EEPROM) to store configuration values.</li>
<li class="noindent">A real-time clock (RTC; this can be an external module)</li>
<li class="noindent">A watchdog timer to monitor the system’s software operation</li>
</ul>
<p class="numberp2">The SPM provides pool sensors to determine when the pool level is high or low. It also provides a solenoid interface to a water valve, allowing the SPM to turn on or off a water source for the pool.</p>
<p class="number3"><span epub:type="pagebreak" id="page_206"/><strong>2.1.4 Software Interfaces</strong></p>
<p class="numberp2">The SPM software is self-contained and provides no external interfaces, nor does it require any external software interfaces.</p>
<p class="number3"><strong>2.1.5 Communication Interfaces</strong></p>
<p class="numberp2">The SPM is self-contained and does not communicate with the outside world.</p>
<p class="number3"><strong>2.1.6 Memory Constraints</strong></p>
<p class="numberp2">As the SPM is running on an Arduino-compatible SBC, there will be (severe) memory constraints, depending on the exact model chosen (for example, an Arduino Mega 2560 SBC provides only 8KB of static RAM on board).</p>
<p class="number3"><strong>2.1.7 Operations</strong></p>
<p class="numberp2">The SPM operates in an <em>always-on</em> mode, monitoring the pool 24/7/365. Therefore, the module itself should not consume excessive electrical power. It will, however, be connected to line voltage via a power supply, so extreme low-power operation is unnecessary. It will constantly monitor the pool’s water level and automatically turn on a water source if the pool level is low. To avoid flooding if there is a sensor failure, the SPM will limit the amount of water introduced to the pool on a daily basis (time limit is user-selectable).</p>
<p class="number2"><strong>2.2 Site Adaptation Requirements</strong></p>
<p class="numberp">For this particular variant of the SPM, there is little in the way of site adaptation requirements. There are no optional sensors or operations and the only interfaces outside the SPM itself is a source of power for the system and a water source (interfaced via the solenoid valve).</p>
<p class="number2"><strong>2.3 Product Functions</strong></p>
<p class="numberp">The product shall use seven water-level sensors to determine the pool level: three digital sensors that provide a <em>low-pool</em> indication, three digital sensors that provide a <em>high-pool</em> indication, and an analog sensor that provides a pool level depth indication (perhaps only a couple inches or centimeters in range). The three low-pool digital sensors are active when the water level is at the level of the sensor. The system will begin filling the pool when there is a low-pool indication. To avoid flooding when a sensor fails, the three sensors operate in a <em>two out of three</em> configuration, meaning at least two sensors must indicate a low-pool condition before the SPM will attempt to fill the pool. The three high-pool sensors work in a likewise fashion when the SPM should stop filling the pool (water level is high). The analog sensor provides a small range of depth; <span epub:type="pagebreak" id="page_207"/>the SPM will use the analog sensor as a backup to verify that the pool level is low prior to filling the pool. The SPM will also use the analog sensor to determine that the pool is actually filling while the SPM has turned on the water source.</p>
<p class="number2"><strong>2.4 User Characteristics</strong></p>
<p class="numberp">There are two types of SPM users: technicians and end users. A technician is responsible for installing and adjusting the SPM. An end user is the pool’s owner who uses the SPM on a day-to-day basis.</p>
<p class="number2"><strong>2.5 Constraints</strong></p>
<p class="numberp">The SPM should be carefully designed to prevent inadvertent flooding and excessive water use. In particular, the software must be robust enough to determine that the pool is not being properly filled and to cease attempting to fill the pool if the sensors do not indicate proper operation. Should any sensor fail, the software should be smart enough to avoid blindly keeping the water turned on (which could lead to flood damage). For example, if the SPM is attached to an aboveground pool and that pool has a leak, it might not ever be possible to fill the pool. The software should handle such situations.</p>
<p class="numberp">The system should be fail-safe insofar as a power failure should automatically shut off the water valve. A watchdog timer of some sort should also check that the software is operating properly and turn off the water valve if a timeout occurs (for example, should the software hang up).</p>
<p class="numberp">To avoid flooding because of a malfunctioning relay, the SPM should use two relays in series to open the water valve. Both relays must be actuated by the software in order to turn on the solenoid valve.</p>
<p class="number2"><strong>2.6 Assumptions and Dependencies</strong></p>
<p class="numberp">The requirements in this document assume that the SBC contains sufficient resources (computing power) to handle the task and that the device can reasonably operate in a 24/7/365 real-time environment.</p>
<p class="number2"><strong>2.7 Apportioning of Requirements</strong></p>
<p class="numberp">These requirements define a very simple swimming pool monitor for the purposes of demonstrating a complete SRS. As this is a minimal requirement set for a very small SPM, the assumption is that a product built around these requirements would implement all of them. A real product would probably include many additional features beyond those listed here, with a corresponding increase in the number of requirements appearing in this document.</p>
<p class="number1"><span epub:type="pagebreak" id="page_208"/><strong>3 Specific Requirements</strong></p>
<p class="number2"><strong>3.1 External Interfaces</strong></p>
<p class="numberpa"><strong>[POOL_SRS_001]</strong></p>
<p class="numberp2a">The SPM shall provide a digital input for the navigation <em>up</em> button.</p>
<p class="numberpa"><strong>[POOL_SRS_002]</strong></p>
<p class="numberp2a">The SPM shall provide a digital input for the navigation <em>down</em> button.</p>
<p class="numberpa"><strong>[POOL_SRS_003]</strong></p>
<p class="numberp2a">The SPM shall provide a digital input for the navigation <em>left</em> button.</p>
<p class="numberpa"><strong>[POOL_SRS_004]</strong></p>
<p class="numberp2a">The SPM shall provide a digital input for the navigation <em>right</em> button.</p>
<p class="numberpa"><strong>[POOL_SRS_005]</strong></p>
<p class="numberp2a">The SPM shall provide a digital input for the <em>cancel/back</em> button.</p>
<p class="numberpa"><strong>[POOL_SRS_006]</strong></p>
<p class="numberp2a">The SPM shall provide a digital input for the <em>select/enter</em> button.</p>
<p class="numberpa"><strong>[POOL_SRS_007]</strong></p>
<p class="numberp2a">The SPM shall provide four digital inputs for the rotary encoder (quadrature) input.</p>
<p class="numberpa"><strong>[POOL_SRS_008.01]</strong></p>
<p class="numberp2a">The SPM shall provide a digital input for the primary <em>water level low</em> sensor.</p>
<p class="numberpa"><strong>[POOL_SRS_008.02]</strong></p>
<p class="numberp2a">The SPM shall provide a digital input for the secondary <em>water level low</em> sensor.</p>
<p class="numberpa"><strong>[POOL_SRS_008.03]</strong></p>
<p class="numberp2a">The SPM shall provide a digital input for the tertiary <em>water level low</em> sensor.</p>
<p class="numberpa"><strong>[POOL_SRS_009.01]</strong></p>
<p class="numberp2a">The SPM shall provide a digital input for the primary <em>water level high</em> sensor.</p>
<p class="numberpa"><strong>[POOL_SRS_009.02]</strong></p>
<p class="numberp2a">The SPM shall provide a digital input for the secondary <em>water level high</em> sensor.</p>
<p class="numberpa"><strong>[POOL_SRS_009.03]</strong></p>
<p class="numberp2a">The SPM shall provide a digital input for the tertiary <em>water level high</em> sensor.</p>
<p class="numberpa"><span epub:type="pagebreak" id="page_209"/><strong>[POOL_SRS_011]</strong></p>
<p class="numberp2a">The SPM shall provide an analog input (minimum 8-bit resolution) for the water level sensor.</p>
<p class="numberpa"><strong>[POOL_SRS_012]</strong></p>
<p class="numberp2a">The SPM shall provide two digital outputs to control the water source solenoid valve.</p>
<p class="number2"><strong>3.2 Functional Requirements</strong></p>
<p class="numberpa"><strong>[POOL_SRS_013]</strong></p>
<p class="numberp2a">The SPM shall allow the user to set the RTC date and time via the user interface.</p>
<p class="numberpa"><strong>[POOL_SRS_014]</strong></p>
<p class="numberp2a">The SPM shall have a maximum fill time, specifying the maximum amount of time (hours:mins) that the water valve can be actuated during a 24-hour period.</p>
<p class="numberpa"><strong>[POOL_SRS_015]</strong></p>
<p class="numberp2a">The user shall be able to set the maximum fill time from the SPM user interface (using the navigation and enter buttons).</p>
<p class="numberpa"><strong>[POOL_SRS_015.01]</strong></p>
<p class="numberp2a">Once the user has selected the maximum fill time from the user interface, the user shall be able to select the hours or minutes fields using the navigation buttons.</p>
<p class="numberpa"><strong>[POOL_SRS_015.02]</strong></p>
<p class="numberp2a">The user shall be able to independently set the maximum fill-time hours value using the rotary encoder after selecting the hours field.</p>
<p class="numberpa"><strong>[POOL_SRS_015.03]</strong></p>
<p class="numberp2a">The user shall be able to independently set the maximum fill-time minutes value using the rotary encoder after selecting the minutes field.</p>
<p class="numberpa"><strong>[POOL_SRS_015.04]</strong></p>
<p class="numberp2a">The software shall not allow a maximum fill time of greater than 12 hours.</p>
<p class="numberpa"><strong>[POOL_SRS_016]</strong></p>
<p class="numberp2a">The SPM shall check the pool level once every 24 hours, at a specific time, to determine if it needs to add water to the pool.</p>
<p class="numberpa"><strong>[POOL_SRS_017]</strong></p>
<p class="numberp2a">The user shall be able to set the time the SPM checks the pool level (and, therefore, when the SPM fills the pool) from the SPM user interface.</p>
<p class="numberpa"><span epub:type="pagebreak" id="page_210"/><strong>[POOL_SRS_017.01]</strong></p>
<p class="numberp2a">Once the user has selected the pool-level check time from the user interface, the user shall be able to select the hours or minutes fields using the navigation buttons.</p>
<p class="numberpa"><strong>[POOL_SRS_017.02]</strong></p>
<p class="numberp2a">The user shall be able to independently set the pool-level check-time hours value using the rotary encoder after selecting the hours field.</p>
<p class="numberpa"><strong>[POOL_SRS_017.03]</strong></p>
<p class="numberp2a">The user shall be able to independently set the pool-level check-time minutes value using the rotary encoder after selecting the minutes field.</p>
<p class="numberpa"><strong>[POOL_SRS_017.04]</strong></p>
<p class="numberp2a">The default (factory reset) pool check time shall be 1:00 <span class="small">AM</span>.</p>
<p class="numberpa"><strong>[POOL_SRS_018]</strong></p>
<p class="numberp2a">At the pool check time each day, the system shall read the three <em>pool level low</em> sensors and begin a pool fill operation if at least two of the three sensors indicate a pool low condition.</p>
<p class="numberpa"><strong>[POOL_SRS_018.01]</strong></p>
<p class="numberp2a">During a pool fill operation the software shall accumulate a running <em>fill time</em>.</p>
<p class="numberpa"><strong>[POOL_SRS_018.02]</strong></p>
<p class="numberp2a">During a pool fill operation if the running fill time exceeds the maximum fill time, the software shall cease the pool fill operation.</p>
<p class="numberpa"><strong>[POOL_SRS_018.03]</strong></p>
<p class="numberp2a">During a pool fill operation the software shall read the <em>pool level high</em> sensors and cease the pool fill operation if at least two of the three sensors indicate a high pool level.</p>
<p class="numberpa"><strong>[POOL_SRS_018.04]</strong></p>
<p class="numberp2a">During a pool fill operation the software shall read the analog pool-level sensor and shut off the water flow if the level isn’t increasing after each half-hour of operation.</p>
<p class="numberpa"><strong>[POOL_SRS_019]</strong></p>
<p class="numberp2a">The software shall allow the user to select a <em>manual pool</em> fill mode that turns on the water source to the pool.</p>
<p class="numberpa"><strong>[POOL_SRS_019.01]</strong></p>
<p class="numberp2a">The software shall allow the user to select an <em>auto pool</em> fill mode that turns off the manual pool fill mode.</p>
<p class="numberpa"><strong>[POOL_SRS_019.02]</strong></p>
<p class="numberp2a">In the manual pool fill mode, the software shall ignore the maximum fill time.</p>
<p class="numberpa"><span epub:type="pagebreak" id="page_211"/><strong>[POOL_SRS_019.03]</strong></p>
<p class="numberp2a">In the manual pool fill mode, the software shall ignore the <em>pool level high</em> and <em>pool level low</em> sensors (filling stops when the user turns off the manual fill mode).</p>
<p class="numberpa"><strong>[POOL_SRS_020]</strong></p>
<p class="numberp2a">The software shall update the system watchdog timer at least twice as frequently as the watchdog timeout period.</p>
<p class="numberpa"><strong>[POOL_SRS_020.01]</strong></p>
<p class="numberp2a">The watchdog timeout period shall be no less than 5 seconds and no greater than 60 seconds.</p>
<p class="number2"><strong>3.3 Performance Requirements</strong></p>
<p class="numberpa"><strong>[POOL_SRS_001.00.01]</strong></p>
<p class="numberp2a">The SPM shall debounce all button inputs.</p>
<p class="numberpa"><strong>[POOL_SRS_007.00.01]</strong></p>
<p class="numberp2a">The SPM shall be capable of reading the rotary encoder inputs without losing any changes on the inputs.</p>
<p class="numberpa"><strong>[POOL_SRS_015.00.01]</strong></p>
<p class="numberp2a">The SPM shall maintain an accuracy of at least one minute for the maximum pool fill time.</p>
<p class="numberpa"><strong>[POOL_SRS_017.00.01]</strong></p>
<p class="numberp2a">The SPM shall maintain an accuracy of at least one minute for the pool level check time.</p>
<p class="number2"><strong>3.4 Logical Database Requirements</strong></p>
<p class="numberpa"><strong>[POOL_SRS_014.00.01]</strong></p>
<p class="numberp2a">The SPM shall store the maximum fill time in nonvolatile memory.</p>
<p class="numberpa"><strong>[POOL_SRS_016.00.01]</strong></p>
<p class="numberp2a">The SPM shall store the pool check time in nonvolatile memory.</p>
<p class="number2"><strong>3.5 Design Constraints</strong></p>
<p class="numberp">[None]</p>
<p class="number2"><strong>3.6 Standards Compliance</strong></p>
<p class="numberp">[None]</p>
<p class="number2"><strong>3.7 Software System Attributes</strong></p>
<p class="number3"><strong>3.7.1 Reliability</strong></p>
<p class="numberp2">The software will run 24/7/365. Therefore, robustness is a critical factor in system design. In particular, the system should be fail-safe insofar as a software or other failure should result in the closure of the water valve.</p>
<p class="number3"><span epub:type="pagebreak" id="page_212"/><strong>3.7.2 Availability</strong></p>
<p class="numberp2">The software should be running continuously (24/7/365). The software must not be subject to counter overflows or other problems associated with long-term execution. The end user should expect at least 99.99 percent uptime.</p>
<p class="number3"><strong>3.7.3 Security</strong></p>
<p class="numberp2">There are no security requirements for the system (closed, disconnected, air-gapped system).</p>
<p class="number3"><strong>3.7.4 Maintainability</strong></p>
<p class="numberp2">There are no maintainability requirements other than those customarily expected of a professional software engineering project.</p>
<p class="numberp2">That said, this is a bare-bones requirements document. Should someone actually build this system, one would expect future enhancements. Thus, the system should be designed and implemented with such expectations in mind.</p>
<p class="number3"><strong>3.7.5 Portability</strong></p>
<p class="numberp2">The software is expected to run on an Arduino-class device. No portability requirements exist other than the possibility of selecting different Arduino-compatible modules (for example, Arduino Mega 2560 versus Teensy 4.0) during implementation.</p>
<p class="number2"><strong>3.8 Design Goals</strong></p>
<p class="numberp">None for this project.</p>
<p class="number1"><strong>4 Appendixes</strong></p>
<p class="numberp1">[None]</p>
<p class="number1"><strong>5 Index</strong></p>
<p class="numberp1">Given the (small) size of this SRS, no index appears here in order to reduce page count for this book.</p>
<h3 class="h3" id="lev-10.5"><strong>10.5 Creating Requirements</strong></h3>
<p class="noindent">Up to this point this chapter has defined requirements as well as requirements documentation. But you might be asking, “How does someone come up with the requirements in the first place?” This section will provide some insight into that question.</p>
<p class="indent">The modern approach to requirements creation involves use cases, which were introduced in <a href="ch04.xhtml">Chapter 4</a>. The system architect studies how an end user would use a system (the user story) and creates a set of scenarios (use cases) from that study. Each use case becomes the basis for a set of <span epub:type="pagebreak" id="page_213"/>one or more requirements. This section departs from the swimming pool monitor scenario to consider an example from a real-world system, the Plantation Productions <em>digital data acquisition and control (DAQ) system</em>.<sup><a href="ch19_footnote.xhtml#ch10fn2" id="ch10fn2a">2</a></sup></p>
<p class="indent">The DAQ system consists of multiple interconnecting circuit boards, including analog I/O boards, digital I/O boards, digital output boards (relay boards), and an SBC, the Netburner MOD54415, that runs the system firmware. These components allow a system designer to read various analog and digital inputs, compute results and make decisions based on those inputs, and then control external devices by sending digital and analog output values to those devices. For example, the DAQ system was originally designed to control a TRIGA<sup><a href="ch19_footnote.xhtml#ch10fn3" id="ch10fn3a">3</a></sup> research reactor.</p>
<p class="indent">The firmware requirements for the DAQ system are too large to duplicate here, so this chapter will limit the discussion to certain I/O initialization that must take place when the system first powers up. The Netburner MOD54415 includes a set of eight DIP switches, which the DAQ system uses to initialize various system components. These DIP switches do the following:</p>
<ol class="numberz">
<li class="noindent">Enable/disable RS-232 port command processing.</li>
<li class="noindent">Enable/disable USB port command processing.</li>
<li class="noindent">Enable/disable Ethernet port command processing.</li>
<li class="noindent">Specify one Ethernet connection or five simultaneous Ethernet connections.</li>
<li class="noindent">Specify one of four different Ethernet addresses using two DIP switches; see <a href="ch10.xhtml#ch10tab1">Table 10-1</a>.</li>
<li class="noindent">Enable/disable test mode.</li>
<li class="noindent">Enable/disable debug output.</li>
</ol>
<p class="tabcap" id="ch10tab1"><strong>Table 10-1:</strong> Ethernet Address Selection</p>
<table class="topbot-d">
<colgroup>
<col style="width:30%"/>
<col style="width:35%"/>
<col style="width:35%"/>
</colgroup>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>DIP switch A</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>DIP switch A + 1</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Ethernet address</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">0</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">0</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">192.168.2.70</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba">1</p></td>
<td style="vertical-align: top;"><p class="taba">0</p></td>
<td style="vertical-align: top;"><p class="taba">192.168.2.71</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">0</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">1</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">192.168.2.72</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba">1</p></td>
<td style="vertical-align: top;"><p class="taba">1</p></td>
<td style="vertical-align: top;"><p class="taba">192.168.2.73</p></td>
</tr>
</tbody>
</table>
<p class="indent">One final thing to note about the DAQ software initialization: debug output uses the Netburner COM1: port. The Netburner shares this serial port hardware with the USB port. There is a conflict if the user enables both the debug output and the USB command ports. Therefore, to enable the debug port, two conditions must be met: debug output must be enabled and USB port command processing must be disabled.</p>
<p class="indent"><span epub:type="pagebreak" id="page_214"/>To enable commands from the RS-232 or USB ports, the software must read the switches. If the particular switch indicates that the command stream is active, then the software must create a new task<sup><a href="ch19_footnote.xhtml#ch10fn4" id="ch10fn4a">4</a></sup> to handle input from that port. The newly created task is responsible for reading characters from the given port and sending entire lines of text to the system’s command processor upon receiving a newline character. If the corresponding DIP switches are in the disabled position, the software won’t create the RS-232 or USB tasks, and the system will ignore these ports.</p>
<p class="indent">Enabling Ethernet commands is slightly more complicated. There are four DIP switches associated with the Ethernet port. The Ethernet initialization operation must consider the settings for all four DIP switches.</p>
<p class="indent">One DIP switch controls the number of concurrent clients the DAQ software supports. In one position, the DAQ software supports only a single Ethernet client; in the other position, the software supports up to five Ethernet clients. In some environments, you might need to allow multiple host computers to access the data acquisition and control hardware; for example, while debugging you may want to have a test computer monitoring the operations. In some secure applications (after deployment), you may want to limit access to the DAQ system to a single computer.</p>
<p class="indent">The third and fourth Ethernet DIP switches allow an operator to select one of four separate IP/Ethernet addresses. This allows control of up to four separate Netburner modules in the same system. As noted in <a href="ch10.xhtml#ch10tab1">Table 10-1</a>, the four selectable Ethernet addresses are 192.168.2.70 through 192.168.2.73 (the requirements could be changed to support different IP addresses, of course, but these were convenient addresses for the initial DAQ system that was built).</p>
<h3 class="h3" id="lev-10.6"><strong>10.6 Use Cases</strong></h3>
<p class="noindentb">Given the preceding user story, the next step is to build a set of use cases that describe these operations. Remember, use cases are more than a few UML diagrams—they also include a descriptive narrative (see “<a href="ch04.xhtml#lev-4.2.6">Use Case Narratives</a>” on <a href="ch04.xhtml#page_80">page 80</a>).</p>
<p class="uln-indent1"><strong>Actors</strong> There is a single actor in the following use cases, the <em>System User</em>.</p>
<p class="uln-indent1"><strong>Triggers</strong> In all of the following use cases, the trigger that activates each use case is system boot. The system reads the DIP switch settings at boot time and initializes based on those settings (see <a href="ch10.xhtml#ch10fig1">Figure 10-1</a>).</p>
<p class="uln-indent1"><strong>Scenarios/Flow of Events</strong> These are the activities that occur for a given use case.</p>
<p class="uln-indent1"><strong>Associated Requirements</strong> The Associated Requirements provide cross-references to the DAQ System SRS. The requirements appear in <span epub:type="pagebreak" id="page_215"/>the following sections (see “(Selected) DAQ Software Requirements (from SRS)” on <a href="ch10.xhtml#page_219">page 219</a>). You must create the requirements <em>before</em> filling in this section; otherwise, you’d simply be guessing at the requirements you’ll need.</p>
<div class="image"><a id="ch10fig1"/><img src="Images/fig10-1.jpg" alt="image" width="693" height="783"/></div>
<p class="figcap"><em>Figure 10-1: Read DIP switches use case</em></p>
<h4 class="h4" id="lev-10.6.1"><strong><em>10.6.1 Enable/Disable Debug Mode</em></strong></h4>
<p class="uln-indent1"><strong>Goal</strong> Enabling and disabling debug output on DAQ system.</p>
<p class="uln-indent1"><strong>Precondition</strong> System has booted.</p>
<p class="uln-indent1"><strong>End condition</strong> Debug mode is active or inactive, as appropriate.</p>
<h5 class="h5" id="lev-10.6.1.1"><span epub:type="pagebreak" id="page_216"/><strong>10.6.1.1 Scenarios/Flow of Events</strong></h5>
<p class="noindent">Enable/Disable Debug Mode</p>
<ol class="numberz">
<li class="noindent">During system initialization, read DIP switches.</li>
<li class="noindent">Save the value of DIP switch 8 (<span class="literal">on</span> = debug mode on, <span class="literal">off</span> = debug mode off).</li>
<li class="noindent">Debug mode is enabled if DIP switch 8 is <span class="literal">on</span> and DIP switch 2 (USB mode) is <span class="literal">off</span>.</li>
<li class="noindent">Start the <span class="literal">maintPrintf</span> task.</li>
</ol>
<h5 class="h5" id="lev-10.6.1.2"><strong>10.6.1.2 Associated Requirements</strong></h5>
<p class="uln-indent1">DAQ_SRS_721_001: PPDAQ Debug Mode Enabled</p>
<p class="uln-indent1">DAQ_SRS_721_002: PPDAQ Debug Mode Disabled</p>
<h4 class="h4" id="lev-10.6.2"><strong><em>10.6.2 Enable/Disable Ethernet</em></strong></h4>
<p class="uln-indent1"><strong>Goal</strong> Enabling and disabling Ethernet command processing on DAQ system.</p>
<p class="uln-indent1"><strong>Precondition</strong> System has booted.</p>
<p class="uln-indent1"><strong>End condition</strong> Ethernet communication is active or inactive, as appropriate. If active, Ethernet input processing tasks are running.</p>
<h5 class="h5" id="lev-10.6.2.1"><strong>10.6.2.1 Scenarios/Flow of Events</strong></h5>
<p class="noindentb">Enable/Disable Ethernet</p>
<p class="number1">1. During system initialization, read DIP switches.</p>
<p class="number1">2. Use the value of DIP switch 3 to determine if Ethernet is enabled (switch is <span class="literal">on</span>) or disabled (switch is <span class="literal">off</span>).</p>
<p class="number1">3. Save the value of DIP switch 4 to determine if the system supports one connection (switch is <span class="literal">off</span>) or five concurrent connections (switch is <span class="literal">on</span>).</p>
<p class="number1">4. Use the values of DIP switches 5 and 6 to determine the IP address.</p>
<p class="number1">5. If Ethernet is enabled (DIP switch 3 is <span class="literal">on</span>), then:</p>
<p class="number2">5.1 Set the Ethernet address based on the value of DIP switches 5 and 6 as:</p>
<p class="number3">5.1.1 192.168.2.70</p>
<p class="number3">5.1.2 192.168.2.71</p>
<p class="number3">5.1.3 192.168.2.72</p>
<p class="number3">5.1.4 192.168.2.73</p>
<p class="number2">5.2 Start the <span class="literal">ethernetListenTask</span> task with priority <span class="literal">ETHL_PRIO</span>.</p>
<p class="number1">6. Else (if Ethernet is not enabled):</p>
<p class="number2">6.1 Do not start the <span class="literal">ethernetListenTask</span>.</p>
<p class="noindentb"><span epub:type="pagebreak" id="page_217"/><span class="literal">ethernetListenTask</span></p>
<p class="number1">1. Initialize an array of five descriptors with zero elements (empty descriptor slots).</p>
<p class="number1">2. Wait for an external connection request on Ethernet socket 0x5050.</p>
<p class="number1">3. If a connection request is made:</p>
<p class="number2">3.1 Search for an empty slot (array element containing zero) in the descriptor array.</p>
<p class="number2">3.2 If there are no slots available:</p>
<p class="number3">3.2.1 Refuse connection.</p>
<p class="number3">3.2.2 Go to step 2.</p>
<p class="number2">3.3 Else if a slot is available:</p>
<p class="number3">3.3.1 Accept connection and store its file descriptor in the available slot.</p>
<p class="number3">3.3.2 Create a new Ethernet command task associated with the new connection; the priority of the new task shall be <span class="literal">ETH1_PRIO</span> through <span class="literal">ETH5_PRIO</span>, selected by the index into the descriptor slot array; note that <span class="literal">SER_PRIO</span> &lt; <span class="literal">ETHL_PRIO</span> &lt; <span class="literal">ETH1_PRIO</span> to <span class="literal">ETH5_PRIO</span> &lt; <span class="literal">USB_PRIO</span> (where smaller numbers mean the task has a higher priority in the task queue).</p>
<p class="number3">3.3.3 Go to step 2.</p>
<p class="number1">4. Else if the listen connection is broken, terminate listen task.</p>
<h5 class="h5" id="lev-10.6.2.2"><strong>10.6.2.2 Associated Requirements</strong></h5>
<p class="uln-indent1">DAQ_SRS_708_000: PPDAQ Ethernet IP Address</p>
<p class="uln-indent1">DAQ_SRS_709_000: PPDAQ Ethernet IP Address 192.168.2.70</p>
<p class="uln-indent1">DAQ_SRS_710_000: PPDAQ Ethernet IP Address 192.168.2.71</p>
<p class="uln-indent1">DAQ_SRS_711_000: PPDAQ Ethernet IP Address 192.168.2.72</p>
<p class="uln-indent1">DAQ_SRS_712_000: PPDAQ Ethernet IP Address 192.168.2.73</p>
<p class="uln-indent1">DAQ_SRS_716_000: PPDAQ Ethernet Enabled</p>
<p class="uln-indent1">DAQ_SRS_716.5_000: PDAQ Ethernet Disabled</p>
<p class="uln-indent1">DAQ_SRS_716_001: PPDAQ Ethernet Task</p>
<p class="uln-indent1">DAQ_SRS_716_002: PPDAQ Ethernet Task Priority</p>
<p class="uln-indent1">DAQ_SRS_717_000: PPDAQ Ethernet Port</p>
<p class="uln-indent1">DAQ_SRS_718_000: PPDAQ Ethernet Multiple Clients Enabled</p>
<p class="uln-indent1">DAQ_SRS_718_001: PPDAQ Ethernet Multiple Clients Disabled</p>
<p class="uln-indent1">DAQ_SRS_728_000: PPDAQ Command Source #3</p>
<p class="uln-indent1">DAQ_SRS_737_000: PPDAQ Maximum Ethernet Connections #1</p>
<p class="uln-indent1">DAQ_SRS_738_000: PPDAQ Maximum Ethernet Connections #2</p>
<p class="uln-indent1">DAQ_SRS_738_001: PPDAQ Ethernet Command Processing Tasks</p>
<p class="uln-indent1">DAQ_SRS_738_002: PPDAQ Ethernet Command Task Priorities</p>
<h4 class="h4" id="lev-10.6.3"><span epub:type="pagebreak" id="page_218"/><strong><em>10.6.3 Enable/Disable RS-232</em></strong></h4>
<p class="noindent">(Similar to the previous use cases; deleted for brevity.)</p>
<h4 class="h4" id="lev-10.6.4"><strong><em>10.6.4 Enable/Disable Test Mode</em></strong></h4>
<p class="noindent">(Similar to the previous use cases; deleted for brevity.)</p>
<h4 class="h4" id="lev-10.6.5"><strong><em>10.6.5 Enable/Disable USB</em></strong></h4>
<p class="noindent">(Similar to the previous use cases; deleted for brevity.)</p>
<h4 class="h4" id="lev-10.6.6"><strong><em>10.6.6 Read DIP Switches</em></strong></h4>
<p class="noindent">(Similar to the previous use cases; deleted for brevity.)</p>
<h3 class="h3" id="lev-10.7"><strong>10.7 Creating DAQ Software Requirements from the Use Cases</strong></h3>
<p class="noindent">Converting an informal use case to a formal requirement consists of extracting the information from a use case, filling in missing details, and structuring the result in the form of a requirement.</p>
<p class="indent">Consider the use case for “Enable/Disable Debug Mode.” You might be tempted into thinking this use case generates a single requirement:</p>
<p class="blockquote">The PPDAQ software shall operate in a special debug mode if the Netburner DIP switch 8 is set to the ON position and USB (DIP switch 2) is not enabled; it shall operate in a non-debug mode if switch 8 is in the OFF position or DIP switch 2 is enabled.</p>
<p class="noindent">The problem is that this is actually two separate requirements—not because of the “and” and “or” components (you’ll see why in a moment), but because of the semicolon separating the two clauses. The two separate requirements are:</p>
<p class="blockquote">The PPDAQ software shall operate in a special debug mode if the Netburner DIP switch 8 is set to the ON position and USB (DIP switch 2) is not enabled.</p>
<p class="noindent">and</p>
<p class="blockquote">The PPDAQ software shall operate in a non-debug mode if switch 8 is in the OFF position or DIP switch 2 is enabled.</p>
<p class="indent">Note that the “and USB” and “or DIP switch 2” phrases do not imply that these requirements must be split into two separate requirements each. The clause “if the Netburner DIP switch 8 is set to the ON position and USB (DIP switch 2) is not enabled” is actually a logical phrase that is part of the <em>trigger</em> for this requirement. Technically, the requirement should probably be reworded.</p>
<p class="blockquote"><span epub:type="pagebreak" id="page_219"/>If the Netburner DIP switch 8 is set to the ON position and USB (DIP switch 2) is not enabled, then the PPDAQ software shall operate in a special debug mode.</p>
<p class="indent">This moves the trigger clause to the beginning of the requirement, as suggested in section “<a href="ch10.xhtml#lev-10.1.1">A Suggested Requirements Format</a>” on <a href="ch10.xhtml#page_186">page 186</a>. Note, however, that this is simply a suggested format; it’s not unreasonable to place the trigger condition after the actor (PPDAQ software), action (operate), and object (debug mode).</p>
<p class="indent">The next section provides a listing of various requirements from the DAQ software system. It gives an example of how the DAQ requirements were generated from the use cases. You should be able to fill in the details for the remaining requirements on your own.</p>
<h3 class="h3" id="lev-10.8"><strong>10.8 (Selected) DAQ Software Requirements (from SRS)</strong></h3>
<p class="noindent">The actual DAQ SRS (not the <span class="literal">POOL_SRS</span> presented in “A Sample Software Requirements Specification” on <a href="ch10.xhtml#page_203">page 203</a>) contains hundreds of requirements; to keep the size of this chapter reasonable, I’ve selected the following requirements as they are representative of those needed to support the DIP switch use cases shown earlier. Note that the tags for these SRS requirements take the form [DAQ_SRS_<em>xxx_yyy</em>] because the actual DAQ system requirements have an SyRS as well as an SRS.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The DAQ SRS document puts all requirements in section 3, as is the case for all SRSes. That is why the following section numbers revert to 3 rather than continuing the paragraph numbering of this chapter.</em></p>
</div>
<p class="listhead"><strong>3.1.1.1 PPDAQ Standard Software Platform</strong></p>
<p class="listhead"><strong>3.1.1.15 PPDAQ Ethernet IP Address</strong></p>
<p class="listhead1"><strong>[DAQ_SRS_708_000]</strong></p>
<p class="listbody">The PPDAQ software shall set the Ethernet IP address to a value in the range 192.168.2.70–192.168.2.73 based on DIP switch 5–6 settings on the Netburner.</p>
<p class="listhead"><strong>3.1.1.16 PPDAQ Ethernet IP Address 192.168.2.70</strong></p>
<p class="listhead1"><strong>[DAQ_SRS_709_000]</strong></p>
<p class="listbody">The PPDAQ software shall set the Ethernet IP address to 192.168.2.70 if the Netburner DIP switches 5–6 are set to (OFF, OFF).</p>
<p class="listhead"><strong>3.1.1.17 PPDAQ Ethernet IP Address 192.168.2.71</strong></p>
<p class="listhead1"><strong>[DAQ_SRS_710_000]</strong></p>
<p class="listbody">The PPDAQ software shall set the Ethernet IP address to 192.168.2.71 if the Netburner DIP switches 5–6 are set to (ON, OFF).</p>
<p class="listhead"><span epub:type="pagebreak" id="page_220"/><strong>3.1.1.18 PPDAQ Ethernet IP Address 192.168.2.72</strong></p>
<p class="listhead1"><strong>[DAQ_SRS_711_000]</strong></p>
<p class="listbody">The PPDAQ software shall set the Ethernet IP address to 192.168.2.72 if the Netburner DIP switches 5–6 are set to (OFF, ON).</p>
<p class="listhead"><strong>3.1.1.19 PPDAQ Ethernet IP Address 192.168.2.73</strong></p>
<p class="listhead1"><strong>[DAQ_SRS_712_000]</strong></p>
<p class="listbody">The PPDAQ software shall set the Ethernet IP address to 192.168.2.73 if the Netburner DIP switches 5–6 are set to (ON, ON).</p>
<p class="listhead"><strong>3.1.1.20 PPDAQ Ethernet Enabled</strong></p>
<p class="listhead1"><strong>[DAQ_SRS_716_000]</strong></p>
<p class="listbody">The PPDAQ software shall enable Ethernet operation if the Netburner DIP switch 3 is in the ON position.</p>
<p class="listhead"><strong>3.1.1.21 PPDAQ Ethernet Disabled</strong></p>
<p class="listhead1"><strong>[DAQ_SRS_716.5_000]</strong></p>
<p class="listbody">The PPDAQ software shall disable Ethernet operation if the Netburner DIP switch 3 is in the OFF position.</p>
<p class="listhead"><strong>3.1.1.22 PPDAQ Ethernet Task</strong></p>
<p class="listhead1"><strong>[DAQ_SRS_716_001]</strong></p>
<p class="listbody">The Ethernet listening task shall be started if Ethernet communications are enabled.</p>
<p class="listhead"><strong>3.1.1.23 PPDAQ Ethernet Task Priority</strong></p>
<p class="listhead1"><strong>[DAQ_SRS_716_002]</strong></p>
<p class="listbody">The Ethernet listening task shall have a priority lower than the USB task but higher than the serial task.</p>
<p class="listhead"><strong>3.1.1.24 PPDAQ Ethernet Port</strong></p>
<p class="listhead1"><strong>[DAQ_SRS_717_000]</strong></p>
<p class="listbody">The PPDAQ software shall communicate via Ethernet using socket port 0x5050 (decimal 20560, ASCII <em>PP</em>, for <em>Plantation Productions</em>).</p>
<p class="listhead"><strong>3.1.1.25 PPDAQ Ethernet Multiple Clients Enabled</strong></p>
<p class="listhead1"><strong>[DAQ_SRS_718_000]</strong></p>
<p class="listbody">The PPDAQ software shall allow up to five Ethernet clients if the Netburner DIP switch 4 is set to the ON position.</p>
<p class="listhead"><span epub:type="pagebreak" id="page_221"/><strong>3.1.1.26 PPDAQ Ethernet Multiple Clients Disabled</strong></p>
<p class="listhead1"><strong>[DAQ_SRS_718_001]</strong></p>
<p class="listbody">The PPDAQ software shall allow only a single Ethernet client if the Netburner DIP switch 4 is set to the OFF position.</p>
<p class="listhead"><strong>3.1.1.29 PPDAQ Unit Test Mode I/O</strong></p>
<p class="listhead1"><strong>[DAQ_SRS_721_000]</strong></p>
<p class="listbody">The PPDAQ software shall utilize the UART0 serial port on the Netburner MOD54415 MOD-70 evaluation board for unit test communication unless USB commands are enabled (USB commands share the same serial port [UART0] as the test mode output).</p>
<p class="listhead"><strong>3.1.1.30 PPDAQ Debug Mode Enabled</strong></p>
<p class="listhead1"><strong>[DAQ_SRS_721_001]</strong></p>
<p class="listbody">The PPDAQ software shall operate in a special <em>debug</em> mode if the Netburner DIP switch 8 is set to the ON position and USB (DIP switch 2) is not enabled.</p>
<p class="listhead"><strong>3.1.1.31 PPDAQ Debug Mode Disabled</strong></p>
<p class="listhead1"><strong>[DAQ_SRS_721_002]</strong></p>
<p class="listbody">The PPDAQ software shall operate in the normal (nondebug) mode if the Netburner DIP switch 8 is set to the OFF position.</p>
<p class="listhead"><strong>3.1.1.38 PPDAQ Command Source #3</strong></p>
<p class="listhead1"><strong>[DAQ_SRS_728_000]</strong></p>
<p class="listbody">The PPDAQ software shall accept commands from the Ethernet port on the Netburner MOD54415 MOD-70 evaluation board if Ethernet communications are enabled.</p>
<p class="listhead"><strong>3.1.1.40 PPDAQ Maximum Ethernet Connections #1</strong></p>
<p class="listhead1"><strong>[DAQ_SRS_737_000]</strong></p>
<p class="listbody">The PPDAQ software shall only recognize a single connection on the Ethernet port if the Netburner DIP switch 4 is in the OFF position.</p>
<p class="listhead"><strong>3.1.1.41 PPDAQ Maximum Ethernet Connections #2</strong></p>
<p class="listhead1"><strong>[DAQ_SRS_738_000]</strong></p>
<p class="listbody">The PPDAQ software shall only recognize up to five connections on the Ethernet port if the Netburner DIP switch 4 is in the ON position.</p>
<p class="listhead"><strong>3.1.1.42 PPDAQ Ethernet Command Processing Tasks</strong></p>
<p class="listhead1"><strong>[DAQ_SRS_738_001]</strong></p>
<p class="listbody">The PPDAQ software shall start a new process to handle command processing for each connection.</p>
<p class="listhead"><span epub:type="pagebreak" id="page_222"/><strong>3.1.1.43 PPDAQ Ethernet Command Task Priorities</strong></p>
<p class="listhead1"><strong>[DAQ_SRS_738_002]</strong></p>
<p class="listbody">The PPDAQ command processing tasks shall each have a different priority that is higher than the priority of the Ethernet listening task and less than the priority of the USB command task.</p>
<h3 class="h3" id="lev-10.9"><strong>10.9 Updating the Traceability Matrix with Requirement Information</strong></h3>
<p class="noindent">The SyRS and SRS requirements typically add four to six columns to the RTM: Description, SyRS tag (if you have an SyRS), Allocations, SRS tag, and Test/verification type. The Description column provides a brief description of the requirement, such as <em>PPDAQ Standard Software Platform</em> from requirement DAQ_SRS_700_000 in the previous section. (Note that this does <em>not</em> refer to the POOL_SRS tag presented in “A Sample Software Requirements Specification” on <a href="ch10.xhtml#page_203">page 203</a>.)</p>
<p class="indent">The SyRS and SRS tag columns contain the actual SyRS (if present) and SRS tag identifiers. Generally, you would sort the rows in the RTM by SyRS (primary key) and then SRS (secondary key) unless there are no SyRS tags, in which case you’d simply sort the rows by the SRS tag.</p>
<p class="indent">The Allocations column specifies whether the requirement is hardware (<em>H</em>), software (<em>S</em>), other (<em>O</em>), or a combination of these. Typically, only SyRS requirements have hardware-only allocations; after all, SRS requirements are <em>software</em> requirements. It is possible, however, for an SRS requirement to have an <em>HS</em> allocation if it covers both software and hardware aspects of the system. The <em>other</em> designation is a catch-all to cover requirements that don’t clearly fit into a hardware or software category (this could describe a manual process, for example).</p>
<p class="indent">Note that if you don’t have an SyRS, or all of your requirement allocations are software allocations, you can eliminate the Allocations column; this can help reduce the size and complexity of the RTM.</p>
<p class="indent">The Verification type column in the RTM specifies how you will verify (test) this requirement in the system. Possible entries are: <em>by test</em> (<em>T</em>); <em>by review</em> (<em>R</em>); <em>by inspection</em> (<em>I</em>; the “by review” variant for hardware designs); <em>by design</em> (<em>D</em>; usually applies to hardware, not software); <em>by analysis</em> (<em>A</em>); <em>other</em> (<em>O</em>); and <em>no test, or no test possible</em> (<em>N</em>).</p>
<p class="indent">Clearly, requirements that have a <em>T</em> verification method will have some associated test to run to verify the requirement. This generally means that you will have a corresponding test case for this requirement and a test procedure to execute it.</p>
<p class="indent">It may be difficult, impractical, or dangerous to test certain requirements.<sup><a href="ch19_footnote.xhtml#ch10fn5" id="ch10fn5a">5</a></sup> In these situations it may be much easier to carefully review the <span epub:type="pagebreak" id="page_223"/>code to verify that it will behave properly. For such requirements, the verification method would be <em>R</em>, by review.</p>
<p class="indent">The <em>by analysis</em> (<em>A</em>) verification method means that somewhere you are offering a formal (mathematical) proof that the software meets the formal requirement. This is a much more stringent process than <em>by review</em> and a subject that is well beyond the scope of this book. Nevertheless, this type of verification may be necessary for certain requirements whose failure could lead to catastrophic events (such as death). Consider the very first requirement from “(Selected) DAQ Software Requirements (from SRS)” on <a href="ch10.xhtml#page_219">page 219</a>:</p>
<p class="listhead1"><strong>[DAQ_SRS_700_000]</strong></p>
<p class="listbody">The PPDAQ software shall run on a Netburner MOD54415 MOD-70 evaluation board connected to a DAQ_IF interface board.</p>
<p class="indenta">It would be somewhat difficult to come up with an actual test that proves this requirement is being met (other than installing the software on a Netburner MOD54415 and verifying that it actually runs). On the other hand, it’s nearly trivial to look at the source code (and the build files) and verify that this code was written for the Netburner MOD54415. A <em>test by review</em> is easily the most appropriate way to handle this particular requirement.</p>
<p class="indent">The <em>other</em> verification method is a catch-all category that implies you’re going to provide the documentation to justify either the lack of a testing method or the verification approach you plan to use.</p>
<p class="indent">The <em>no test</em> or <em>no test possible</em> verification requires you to justify why a test is not needed. If you are specifying <em>N</em> to represent <em>no test possible</em>, you should carefully consider whether the requirement is valid (is an actual requirement). Remember, if it can’t be tested, it isn’t a requirement.</p>
<p class="indentb">These are the four column entries that [DAQ_SRS_700_000] would add to the RTM.</p>
<table class="topbot-d">
<colgroup>
<col style="width:30%"/>
<col style="width:35%"/>
<col style="width:15%"/>
<col style="width:20%"/>
</colgroup>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>SRS tag</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Allocation</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Verification</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">PPDAQ Standard<br/>Software Platform</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">DAQ_SRS_700_000</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">HS</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">R</p></td>
</tr>
</tbody>
</table>
<p class="indent">Given the requirements in “(Selected) DAQ Software Requirements (from SRS)” on <a href="ch10.xhtml#page_219">page 219</a>, we can divide the requirements into two groups: those whose verification type should be <em>by test</em> and those whose verification type should be <em>by review</em> (because an actual test for them might be difficult to perform or awkward to create).</p>
<h4 class="h4" id="lev-10.9.1"><strong><em>10.9.1 Requirements to Be Verified by Review</em></strong></h4>
<p class="noindent"><a href="ch10.xhtml#ch10tab2">Table 10-2</a> shows a list of the requirements from “(Selected) DAQ Software Requirements (from SRS)” on <a href="ch10.xhtml#page_219">page 219</a> that should be verified by review and should provide a justification for the choice that has been made.<sup><a href="ch19_footnote.xhtml#ch10fn6" id="ch10fn6a">6</a></sup></p>
<p class="tabcap" id="ch10tab2"><span epub:type="pagebreak" id="page_224"/><strong>Table 10-2:</strong> DAQ Software Requirement Justifications</p>
<table class="topbot-d">
<colgroup>
<col style="width:30%"/>
<col style="width:70%"/>
</colgroup>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Requirement</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Justification</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">DAQ_SRS_700_000</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Although you could argue that running the software on a Netburner verifies that it runs on a Netburner, reviewing the make/build files is an easier and more practical way to verify this requirement.</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba">DAQ_SRS_700_000.01</p></td>
<td style="vertical-align: top;"><p class="taba">Although you could argue that running the software on a μC/OS verifies that it runs under μC/OS, reviewing the make/build files is an easier and more practical way to verify this requirement.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">DAQ_SRS_702_001</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Writing a test to show that a separate process is running would be difficult without actually changing the code (i.e., to print some output to show this). However, reviewing the code to see that it is starting a new task to handle RS-232 communication isn’t that difficult.</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba">DAQ_SRS_702_002</p></td>
<td style="vertical-align: top;"><p class="taba">Writing a test to show that the RS-232 process is running at a particular priority level would require modifying the code; reviewing the code is easier.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">DAQ_SRS_703_001</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Making this one by review is arguable. You could argue that if the system is accepting RS-232 commands, the task is running. However, this does not prove that a separate task is running or not running (the main task could be processing the commands). Hence, this should probably be a by review verification.</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba">DAQ_SRS_705_001</p></td>
<td style="vertical-align: top;"><p class="taba">The same argument applies as for DAQ_SRS_702_001 (just applied to the USB input task).</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">DAQ_SRS_705_002</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Same justification as for DAQ_SRS_702_002.</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba">DAQ_SRS_706_001</p></td>
<td style="vertical-align: top;"><p class="taba">Same argument as for DAQ_SRS_705_001 (just the complement of that requirement).</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">DAQ_SRS_716_001</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Same argument as for DAQ_SRS_702_001 (just applied to the Ethernet listen task).</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba">DAQ_SRS_716_002</p></td>
<td style="vertical-align: top;"><p class="taba">Same argument as for DAQ_SRS_702_002 (just applied to the Ethernet listen task priority).</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">DAQ_SRS_719_000</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Currently, unit test mode is undefined on the DAQ system so there is no way to test that the system has entered this mode. Reviewing the code verifies that the internal variable is properly set up (the only effect the DIP switch will have).</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba">DAQ_SRS_720_000</p></td>
<td style="vertical-align: top;"><p class="taba">See DAQ_SRS_719_000.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">DAQ_SRS_723_000</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Another arguable case. The fact that the system is reading the DIP switches (to handle other tests) should be enough to show that the software is reading the Netburner switches. However, this requirement is sufficiently unimportant that the choice of review/test doesn’t really matter.</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba">DAQ_SRS_723_000.01</p></td>
<td style="vertical-align: top;"><p class="taba">See DAQ_SRS_723_000.</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">DAQ_SRS_723_000.02</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">See DAQ_SRS_723_000.</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba">DAQ_SRS_725_000</p></td>
<td style="vertical-align: top;"><p class="taba">Checking to see that the DAQ responds to a command is no big deal (easily testable); however, this requirement states that the DAQ does not initiate communication on its own (that is, it’s negatively stated, which, in general, is bad in a requirement). Reviewing code is the only proper way to handle negative requirements (which is why you want to avoid them).</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">DAQ_SRS_738_001</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Similar justification to DAQ_SRS_702_001.</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba">DAQ_SRS_738_002</p></td>
<td style="vertical-align: top;"><p class="taba">Similar justification to DAQ_SRS_702_002.</p></td>
</tr>
</tbody>
</table>
<h4 class="h4" id="lev-10.9.2"><span epub:type="pagebreak" id="page_225"/><strong><em>10.9.2 Requirements to Be Verified by Testing</em></strong></h4>
<p class="noindent">All requirements in “(Selected) DAQ Software Requirements (from SRS)” on <a href="ch10.xhtml#page_219">page 219</a> that are not also listed in “Requirements to Be Verified by Review” on <a href="ch10.xhtml#page_223">page 223</a> will be verified using test cases and test procedures.</p>
<h3 class="h3" id="lev-10.10"><strong>10.10 For More Information</strong></h3>
<p class="ref">IEEE. “IEEE Standard 830-1998: IEEE Recommended Practice for Software Requirements Specifications.” October 20, 1998. <em><a href="https://doi.org/10.1109/IEEESTD.1998.88286">https://doi.org/10.1109/IEEESTD.1998.88286</a></em>.</p>
<p class="ref">Leffingwell, Dean, and Don Widrig. <em>Managing Software Requirements</em>. Boston: Addison-Wesley Professional, 2003.</p>
<p class="ref">Wiegers, Karl E. <em>Software Requirements</em>. Redmond, WA: Microsoft Press, 2009.</p>
<p class="ref">———. “Writing Quality Requirements.” <em>Software Development</em> 7, no. 5 (May 1999): 44–48.<span epub:type="pagebreak" id="page_226"/></p>
</div>



  </body></html>