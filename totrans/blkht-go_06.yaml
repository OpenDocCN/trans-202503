- en: '6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '6'
- en: INTERACTING WITH SMB AND NTLM
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SMB 和 NTLM 的交互
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: In the previous chapters, you examined various common protocols used for network
    communication, including raw TCP, HTTP, and DNS. Each of these protocols has interesting
    use cases for attackers. Although an extensive number of other network protocols
    exist, we’ll conclude our discussion of network protocols by examining *Server
    Message Block* *(SMB)*, a protocol that arguably proves to be the most useful
    during Windows post-exploitation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，你研究了用于网络通信的各种常见协议，包括原始 TCP、HTTP 和 DNS。每个协议对于攻击者都有有趣的用例。尽管存在大量其他网络协议，我们将通过研究
    *服务器消息块* *(SMB)* 协议来结束网络协议的讨论，SMB 协议无疑是 Windows 后期利用中最有用的协议。
- en: SMB is perhaps the most complicated protocol you’ll see in this book. It has
    a variety of uses, but SMB is commonly used for sharing resources such as files,
    printers, and serial ports across a network. For the offensive-minded reader,
    SMB allows interprocess communications between distributed network nodes via named
    pipes. In other words, you can execute arbitrary commands on remote hosts. This
    is essentially how PsExec, a Windows tool that executes remote commands locally,
    works.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: SMB 可能是你在本书中看到的最复杂的协议。它有多种用途，但 SMB 常用于在网络中共享资源，如文件、打印机和串口。对于攻击者来说，SMB 允许通过命名管道在分布式网络节点之间进行进程间通信。换句话说，你可以在远程主机上执行任意命令。这本质上就是
    PsExec 工具的工作原理，PsExec 是一个在本地执行远程命令的 Windows 工具。
- en: SMB has several other interesting use cases, particularly due to the way it
    handles *NT LAN Manager (NTLM) authentication*, a challenge-response security
    protocol used heavily on Windows networks. These uses include remote password
    guessing, hash-based authentication (or *pass-the-hash*), SMB relay, and NBNS/LLMNR
    spoofing. Covering each of these attacks would take an entire book.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: SMB 还有其他几个有趣的用例，尤其是由于它处理 *NT LAN Manager (NTLM) 身份验证* 的方式，NTLM 是一种在 Windows
    网络中广泛使用的挑战-响应安全协议。这些用例包括远程密码猜测、基于哈希的身份验证（或 *pass-the-hash*）、SMB 中继和 NBNS/LLMNR
    欺骗。要覆盖这些攻击，每一项都可以写成一本书。
- en: We’ll begin this chapter with a detailed explanation of how to implement SMB
    in Go. Next, you’ll leverage the SMB package to perform remote password guessing,
    use the pass-the-hash technique to successfully authenticate yourself by using
    only a password’s hash, and crack the NTLMv2 hash of a password.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从详细解释如何在 Go 中实现 SMB 开始。接下来，你将利用 SMB 包执行远程密码猜测，使用 pass-the-hash 技术仅凭密码的哈希值成功进行身份验证，并破解密码的
    NTLMv2 哈希。
- en: The SMB Package
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SMB 包
- en: At the time of this writing, no official SMB package exists in Go, but we created
    a package where you can find the book-friendly version at [*https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/*](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/).
    Although we won’t show you every detail of this package in this chapter, you’ll
    still learn the basics of interpreting the SMB specification in order to create
    the binary communications necessary to “speak SMB,” unlike in previous chapters,
    where you simply reused fully compliant packages. You’ll also learn how to use
    a technique called *reflection* to inspect interface data types at runtime and
    define arbitrary Go structure field tags to marshal and unmarshal complicated,
    arbitrary data, while maintaining scalability for future message structures and
    data types.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在写作本文时，Go 中尚未有官方的 SMB 包，但我们创建了一个包，你可以在 [*https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/*](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/)
    中找到本书友好的版本。虽然我们在本章不会展示该包的每个细节，但你仍将学习如何解释 SMB 规范的基础知识，以便创建必要的二进制通信来“讲 SMB”，这与前几章你仅仅重用了完全兼容的包不同。你还将学习如何使用一种叫做
    *反射* 的技术，在运行时检查接口数据类型，并定义任意的 Go 结构体字段标签，以便编组和解组复杂的、任意的数据，同时为未来的消息结构和数据类型保持可扩展性。
- en: While the SMB library we’ve built allows only basic client-side communications,
    the codebase is fairly extensive. You’ll see relevant examples from the SMB package
    so that you can fully understand how communications and tasks, such as SMB authentication,
    work.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们构建的 SMB 库仅允许基本的客户端通信，但代码库相当庞大。你将看到来自 SMB 包的相关示例，以便你能完全理解如何进行通信和任务，例如 SMB
    身份验证。
- en: Understanding SMB
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 SMB
- en: SMB is an application-layer protocol, like HTTP, that allows network nodes to
    communicate with one another. Unlike HTTP 1.1, which communicates using ASCII-readable
    text, SMB is a binary protocol that uses a combination of fixed- and variable-length,
    positional, and little-endian fields. SMB has several versions, also known as
    *dialects*—that is, versions 2.0, 2.1, 3.0, 3.0.2, and 3.1.1\. Each dialect performs
    better than its predecessors. Because the handling and requirements vary from
    one dialect to the next, a client and server must agree on which dialect to use
    ahead of time. They do this during an initial message exchange.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: SMB是一个应用层协议，类似于HTTP，它允许网络节点相互通信。与使用ASCII可读文本的HTTP 1.1不同，SMB是一个二进制协议，使用固定和可变长度、位置以及小端字段的组合。SMB有多个版本，也称为*方言*——即版本2.0、2.1、3.0、3.0.2和3.1.1。每个方言的性能都优于其前代版本。由于不同方言的处理和要求有所不同，因此客户端和服务器必须事先就使用哪种方言达成一致。它们通过初始的消息交换完成这一过程。
- en: Generally, Windows systems support multiple dialects and choose the most current
    dialect that both the client and server support. Microsoft has provided [Table
    6-1](ch06.xhtml#ch6tab1), which shows which Windows versions select which dialect
    during the negotiation process. (Windows 10 and WS 2016—not shown in the graphic—negotiate
    SMB version 3.1.1.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Windows系统支持多个方言，并选择客户端和服务器都支持的最新方言。微软提供了[表6-1](ch06.xhtml#ch6tab1)，展示了在协商过程中，哪些Windows版本选择了哪些方言。（Windows
    10和WS 2016——图中未显示——协商使用SMB版本3.1.1。）
- en: '**Table 6-1:** SMB Dialects Negotiated By Windows Versions'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-1：** Windows版本协商的SMB方言'
- en: '| **Operating system** | **Windows 8.1 WS 2012 R2** | **Windows 8 WS 2012**
    | **Windows 7 WS 2008 R2** | **Windows Vista WS 2008** | **Previous versions**
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **操作系统** | **Windows 8.1 WS 2012 R2** | **Windows 8 WS 2012** | **Windows
    7 WS 2008 R2** | **Windows Vista WS 2008** | **旧版本** |'
- en: '| Windows 8.1 WS 2012 R2 | **SMB 3.02** | **SMB 3.0** | SMB 2.1 | SMB 2.0 |
    SMB 1.0 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| Windows 8.1 WS 2012 R2 | **SMB 3.02** | **SMB 3.0** | SMB 2.1 | SMB 2.0 |
    SMB 1.0 |'
- en: '| Windows 8 WS 2012 | **SMB 3.0** | **SMB 3.0** | SMB 2.1 | SMB 2.0 | SMB 1.0
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Windows 8 WS 2012 | **SMB 3.0** | **SMB 3.0** | SMB 2.1 | SMB 2.0 | SMB 1.0
    |'
- en: '| Windows 7 WS 2008 R2 | SMB 2.1 | SMB 2.1 | SMB 2.1 | SMB 2.0 | SMB 1.0 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| Windows 7 WS 2008 R2 | SMB 2.1 | SMB 2.1 | SMB 2.1 | SMB 2.0 | SMB 1.0 |'
- en: '| Windows Vista WS 2008 | SMB 2.0 | SMB 2.0 | SMB 2.0 | SMB 2.0 | SMB 1.0 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| Windows Vista WS 2008 | SMB 2.0 | SMB 2.0 | SMB 2.0 | SMB 2.0 | SMB 1.0 |'
- en: '| Previous versions | SMB 1.0 | SMB 1.0 | SMB 1.0 | SMB 1.0 | SMB 1.0 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 旧版本 | SMB 1.0 | SMB 1.0 | SMB 1.0 | SMB 1.0 | SMB 1.0 |'
- en: For this chapter, you’ll use the SMB 2.1 dialect, because most modern Windows
    versions support it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用SMB 2.1方言，因为大多数现代Windows版本都支持它。
- en: Understanding SMB Security Tokens
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解SMB安全令牌
- en: SMB messages contain *security tokens* used to authenticate users and machines
    across a network. Much like the process of selecting the SMB dialect, selecting
    the authentication mechanism takes place through a series of Session Setup messages,
    which allow clients and servers to agree on a mutually supported authentication
    type. Active Directory domains commonly use *NTLM Security Support Provider* *(NTLMSSP)*,
    a binary, positional protocol that uses NTLM password hashes in combination with
    challenge-response tokens in order to authenticate users across a network. *Challenge-response
    tokens* are like the cryptographic answer to a question; only an entity that knows
    the correct password can answer the question correctly. Although this chapter
    focuses solely on NTLMSSP, Kerberos is another common authentication mechanism.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: SMB消息包含用于在网络中对用户和计算机进行身份验证的*安全令牌*。与选择SMB方言的过程类似，选择身份验证机制是通过一系列的会话设置消息进行的，这些消息允许客户端和服务器就共同支持的身份验证类型达成一致。活动目录域通常使用*NTLM安全支持提供程序*（*NTLMSSP*），这是一种二进制位置协议，它将NTLM密码哈希与挑战-响应令牌结合使用，以便在网络中验证用户。*挑战-响应令牌*类似于一个加密问题的答案；只有知道正确密码的实体才能正确回答这个问题。尽管本章仅专注于NTLMSSP，Kerberos也是一种常见的身份验证机制。
- en: Separating the authentication mechanism from the SMB specification itself allows
    SMB to use different authentication methods in different environments, depending
    on domain and enterprise security requirements as well as client-server support.
    However, separating the authentication and the SMB specification makes it more
    difficult to create an implementation in Go, because the authentication tokens
    are *Abstract Syntax Notation One (ASN.1)* encoded. For this chapter, you don’t
    need to know too much about ASN.1—just know that it’s a binary encoding format
    that differs from the positional binary encoding you’ll use for general SMB. This
    mixed encoding adds complexity.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将身份验证机制与 SMB 规范本身分离，使得 SMB 可以根据域和企业的安全要求以及客户端和服务器的支持，在不同的环境中使用不同的身份验证方法。然而，身份验证与
    SMB 规范的分离使得在 Go 中实现变得更加困难，因为身份验证令牌是*抽象语法表示法（ASN.1）* 编码的。对于本章内容，你无需了解 ASN.1 的太多细节——只需知道它是一种二进制编码格式，与用于一般
    SMB 的位置二进制编码不同。这种混合编码增加了复杂性。
- en: Understanding NTLMSSP is crucial to creating an SMB implementation that is smart
    enough to marshal and unmarshal message fields selectively, while accounting for
    the potential that adjacent fields—within a single message—may be encoded or decoded
    differently. Go has standard packages that you can use for binary and ASN.1 encoding,
    but Go’s ASN.1 package wasn’t built for general-purpose use; so you must take
    into account a few nuances.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 NTLMSSP 对于创建一个足够智能的 SMB 实现至关重要，这样它就可以在选择性地序列化和反序列化消息字段时，同时考虑到相邻字段（在同一个消息中）可能会被以不同的方式编码或解码。Go
    提供了标准包用于二进制和 ASN.1 编码，但 Go 的 ASN.1 包并不是为通用用途而设计的，因此你必须考虑一些细微差别。
- en: Setting Up an SMB Session
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置 SMB 会话
- en: 'The client and server perform the following process to successfully set up
    an SMB 2.1 session and choose the NTLMSSP dialect:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器执行以下过程以成功建立 SMB 2.1 会话并选择 NTLMSSP 方言：
- en: The client sends a Negotiate Protocol request to the server. The message includes
    a list of dialects that the client supports.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向服务器发送一个协商协议请求。该消息包括客户端支持的方言列表。
- en: The server responds with a Negotiate Protocol response message, which indicates
    the dialect the server selected. Future messages will use that dialect. Included
    in the response is a list of authentication mechanisms the server supports.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器回复一个协商协议响应消息，指示服务器选择的方言。未来的消息将使用该方言。响应中包括服务器支持的身份验证机制列表。
- en: The client selects a supported authentication type, such as NTLMSSP, and uses
    the information to create and send a Session Setup request message to the server.
    The message contains an encapsulated security structure indicating that it’s an
    NTLMSSP Negotiate request.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端选择一种支持的身份验证类型，例如 NTLMSSP，并使用该信息创建并发送一个会话设置请求消息到服务器。该消息包含一个封装的安全结构，表明这是一个
    NTLMSSP 协商请求。
- en: The server replies with a Session Setup response message. This message indicates
    that more processing is required and includes a server challenge token.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器回复一个会话设置响应消息。该消息表明需要更多处理，并包含一个服务器挑战令牌。
- en: The client calculates the user’s NTLM hash—which uses the domain, user, and
    password as inputs—and then uses it in combination with the server challenge,
    random client challenge, and other data to generate the challenge response. It
    includes this in a new Session Setup request message that the client sends to
    the server. Unlike the message sent in step 3, the encapsulated security structure
    indicates that it’s an NTLMSSP Authenticate request. This way, the server can
    differentiate between the two Session Setup SMB requests.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端计算用户的 NTLM 哈希——该哈希使用域、用户和密码作为输入——然后将其与服务器挑战、随机客户端挑战以及其他数据结合，生成挑战响应。它将此信息包含在一个新的会话设置请求消息中，并发送给服务器。与第
    3 步发送的消息不同，封装的安全结构表明这是一个 NTLMSSP 身份验证请求。通过这种方式，服务器可以区分这两个会话设置 SMB 请求。
- en: The server interacts with an authoritative resource, such as a domain controller
    for authentication using domain credentials, to compare the challenge-response
    information the client supplied with the value the authoritative resource calculated.
    If they match, the client is authenticated. The server sends a Session Setup response
    message back to the client, indicating that login was successful. This message
    contains a unique session identifier that the client can use to track session
    state.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器与一个权威资源（如域控制器）进行交互，使用域凭证进行身份验证，将客户端提供的挑战-响应信息与权威资源计算的值进行比较。如果匹配，则客户端通过认证。服务器向客户端发送会话设置响应消息，指示登录成功。该消息包含一个唯一的会话标识符，客户端可以用它来跟踪会话状态。
- en: The client sends additional messages to access file shares, named pipes, printers,
    and so on; each message includes the session identifier as a reference through
    which the server can validate the authentication status of the client.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端发送额外的消息以访问文件共享、命名管道、打印机等；每条消息都包括会话标识符，作为服务器验证客户端认证状态的参考。
- en: You might now begin to see how complicated SMB is and understand why there is
    neither a standard nor a third-party Go package that implements the SMB specification.
    Rather than take a comprehensive approach and discuss every nuance of the libraries
    we created, let’s focus on a few of the structures, messages, or unique aspects
    that can help you implement your own versions of well-defined networking protocols.
    Instead of extensive code listings, this chapter discusses only the good stuff,
    sparing you from information overload.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能已经开始看到 SMB 的复杂性，并理解为什么没有标准或第三方的 Go 包实现 SMB 规范。我们不会采取全面的方法讨论我们创建的每一个库的细节，而是专注于一些结构、消息或独特的方面，这些内容可以帮助你实现自己版本的明确网络协议。本章将讨论一些关键内容，避免信息过载，而不是列出大量代码。
- en: You can use the following relevant specifications as a reference, but don’t
    feel obligated to read each one. A Google search will let you find the latest
    revisions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将以下相关规范作为参考，但不必强迫自己阅读每一份。通过 Google 搜索，你可以找到最新的修订版。
- en: '**MS-SMB2** The SMB2 specification to which we attempted to conform. This is
    the main specification of concern and encapsulates a Generic Security Service
    Application Programming Interface (GSS-API) structure for performing authentication.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**MS-SMB2** 是我们尝试遵循的 SMB2 规范。这是主要的关注规范，封装了用于执行认证的通用安全服务应用程序接口（GSS-API）结构。'
- en: '**MS-SPNG and RFC 4178** The GSS-API specification within which the MS-NLMP
    data is encapsulated. The structure is ASN.1 encoded.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**MS-SPNG 和 RFC 4178** 是 GSS-API 规范，其中 MS-NLMP 数据被封装。该结构是 ASN.1 编码的。'
- en: '**MS-NLMP** The specification used for understanding NTLMSSP authentication
    token structure and challenge-response format. It includes formulas and specifics
    for calculating things like the NTLM hash and authentication response token. Unlike
    the outer GSS-API container, NTLMSSP data isn’t ASN.1 encoded.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**MS-NLMP** 是用于理解 NTLMSSP 认证令牌结构和挑战-响应格式的规范。它包括计算 NTLM 哈希和认证响应令牌等内容的公式和细节。与外部的
    GSS-API 容器不同，NTLMSSP 数据并非 ASN.1 编码。'
- en: '**ASN.1** The specification for encoding data by using ASN.1 format.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**ASN.1** 是一种使用 ASN.1 格式编码数据的规范。'
- en: Before we discuss the interesting snippets of code from the package, you should
    understand some of the challenges you need to overcome in order to get working
    SMB communications.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论包中的有趣代码片段之前，你需要了解一些挑战，这些挑战需要克服才能实现有效的 SMB 通信。
- en: Using Mixed Encoding of Struct Fields
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用结构字段的混合编码
- en: As we alluded to earlier, the SMB specification requires positional, binary,
    little-endian, fixed- and variable-length encoding for the majority of the message
    data. But some fields need to be ASN.1 encoded, which uses explicitly tagged identifiers
    for field index, type, and length. In this case, many of the ASN.1 subfields to
    be encoded are optional and not restricted to a specific position or order within
    the message field. This may help clarify the challenge.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，SMB 规范要求大多数消息数据采用位置性、二进制、小端、固定和可变长度编码。但有些字段需要 ASN.1 编码，ASN.1 编码使用显式标记的标识符来表示字段索引、类型和长度。在这种情况下，许多
    ASN.1 子字段是可选的，并且不限制在消息字段中的特定位置或顺序。这可能有助于澄清挑战。
- en: In [Listing 6-1](ch06.xhtml#ch6list1), you can see a hypothetical `Message`
    struct that presents these challenges.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Listing 6-1](ch06.xhtml#ch6list1) 中，你可以看到一个假设的 `Message` 结构体，它呈现了这些挑战。
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 6-1: A hypothetical example of a struct requiring variable field encodings*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-1：一个假设的结构体示例，要求对字段使用不同的编码方式*'
- en: The crux of the problem here is that you can’t encode all the types inside the
    `Message` struct by using the same encoding scheme because `B`, a `Foo` type,
    is expected to be ASN.1 encoded, whereas other fields aren’t.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的关键在于，你不能使用相同的编码方案来编码`Message`结构体中的所有类型，因为`B`，一个`Foo`类型，预计采用ASN.1编码，而其他字段则不需要。
- en: Writing a Custom Marshaling and Unmarshaling Interface
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编写自定义序列化和反序列化接口
- en: 'Recall from previous chapters that encoding schemes such as JSON or XML recursively
    encode the struct and all fields by using the same encoding format. It was clean
    and simple. You don’t have the same luxury here, because Go’s `binary` package
    behaves the same way—it encodes all structs and struct fields recursively without
    a care in the world, but this won’t work for you because the message requires
    mixed encoding:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾前面的章节，编码方案如JSON或XML会递归地使用相同的编码格式对结构体和所有字段进行编码。这种方式简洁且直观。但在这里你没有这种奢侈的条件，因为Go的`binary`包也以相同的方式工作——它递归地对所有结构体和结构体字段进行编码，但这对你来说行不通，因为消息需要混合编码：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The solution is to create an interface that allows arbitrary types to define
    custom marshaling and unmarshaling logic ([Listing 6-2](ch06.xhtml#ch6list2)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是创建一个接口，允许任意类型定义自定义的序列化和反序列化逻辑（[列表 6-2](ch06.xhtml#ch6list2)）。
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 6-2: An interface definition requiring custom marshaling and unmarshaling
    methods*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-2：需要自定义序列化和反序列化方法的接口定义*'
- en: 'The interface ❶, `BinaryMarshallable`, defines two methods that must be implemented:
    `MarshalBinary()` ❷ and `UnmarshalBinary()` ❸. Don’t worry too much about the
    `Metadata` type passed into the functions, as it’s not relevant to understand
    the main functionality.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接口❶，`BinaryMarshallable`，定义了两个必须实现的方法：`MarshalBinary()` ❷和`UnmarshalBinary()`
    ❸。不要太担心传入函数的`Metadata`类型，因为理解主要功能时它并不重要。
- en: Wrapping the Interface
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 封装接口
- en: Any type that implements the `BinaryMarshallable` interface can control its
    own encoding. Unfortunately, it’s not as simple as just defining a few functions
    on the `Foo` data type. After all, Go’s `binary.Write()` and `binary.Read()` methods,
    which you use for encoding and decoding binary data, don’t know anything about
    your arbitrarily defined interface. You need to create a `marshal()` and `unmarshal()`
    wrapper function, within which you inspect the data to determine whether the type
    implements the `BinaryMarshallable` interface, as in [Listing 6-3](ch06.xhtml#ch6list3).
    (All the code listings at the root location of / exist under the provided github
    repo *[https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*.)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现了`BinaryMarshallable`接口的类型都可以控制自己的编码。不幸的是，这并不像在`Foo`数据类型上定义几个函数那么简单。毕竟，Go的`binary.Write()`和`binary.Read()`方法用于编码和解码二进制数据时，并不了解你自定义的接口。你需要创建一个`marshal()`和`unmarshal()`包装函数，在其中检查数据，以确定类型是否实现了`BinaryMarshallable`接口，如[列表
    6-3](ch06.xhtml#ch6list3)所示。 （所有位于根目录的代码清单都存在于提供的GitHub仓库* [https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*）。
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 6-3: Using type assertions to perform custom data marshaling and unmarshaling
    (*[/ch-6/smb/smb/encoder/encoder.go](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go)*)*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-3：使用类型断言执行自定义数据序列化和反序列化（*[/ch-6/smb/smb/encoder/encoder.go](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go)）*'
- en: '[Listing 6-3](ch06.xhtml#ch6list3) details only a subsection of the `marshal()`
    and `unmarshal()` functions taken from [*https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go*](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go).
    Both functions contain a similar section of code that attempts to assert the supplied
    interface, `v`, to a `BinaryMarshallable` variable named `bm` ❶❸. This succeeds
    only if whatever type `v` is actually implements the necessary functions required
    by your `BinaryMarshallable` interface. If it succeeds, your `marshal()` function
    ❷ makes a call to `bm.MarshalBinary()`, and your `unmarshal``()` function ❹ makes
    a call to `bm.UnmarshalBinary()`. At this point, your program flow will branch
    off into the type’s encoding and decoding logic, allowing a type to maintain complete
    control over the way it’s handled.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-3](ch06.xhtml#ch6list3)详细介绍了从[*https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go*](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go)中提取的`marshal()`和`unmarshal()`函数的一个子集。两个函数都包含类似的代码段，试图将提供的接口`v`断言为名为`bm`的`BinaryMarshallable`变量
    ❶❸。只有当`v`的实际类型实现了`BinaryMarshallable`接口所需的必要函数时，这种断言才会成功。如果成功，`marshal()`函数 ❷
    会调用`bm.MarshalBinary()`，而`unmarshal()`函数 ❹ 会调用`bm.UnmarshalBinary()`。此时，程序流程将分支到该类型的编码和解码逻辑，从而允许该类型完全控制其处理方式。'
- en: Forcing ASN.1 Encoding
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制进行ASN.1编码
- en: Let’s look at how to force your `Foo` type to be ASN.1 encoded, while leaving
    other fields in your `Message` struct as-is. To do this, you need to define the
    `MarshalBinary()` and `UnmarshalBinary()` functions on the type, as in [Listing
    6-4](ch06.xhtml#ch6list4).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何强制将你的`Foo`类型进行ASN.1编码，同时保持`Message`结构中的其他字段不变。为此，你需要在该类型上定义`MarshalBinary()`和`UnmarshalBinary()`函数，如[示例
    6-4](ch06.xhtml#ch6list4)所示。
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 6-4: Implementing the `BinaryMarshallable` interface for ASN.1 encoding*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 6-4：为ASN.1编码实现`BinaryMarshallable`接口*'
- en: The methods don’t do much besides make calls to Go’s `asn1.Marshal()` ❶ and
    `asn1.Unmarshal()` ❷ functions. You can find variations of these functions within
    the `gss` package code at [*https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/gss/gss.go*](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/gss/gss.go).
    The only real difference between them is that the `gss` package code has additional
    tweaks to make Go’s `asn1` encoding function play nicely with the data format
    defined within the SMB spec.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法几乎不做什么，除了调用Go的`asn1.Marshal()` ❶和`asn1.Unmarshal()` ❷函数。你可以在[`gss`](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/gss/gss.go)包的代码中找到这些函数的变种。它们的唯一真实区别在于，`gss`包的代码对Go的`asn1`编码函数做了额外的调整，使其与SMB规范中定义的数据格式兼容。
- en: The `ntlmssp` package at [*https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/ntlmssp/ntlmssp.go*](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/ntlmssp/ntlmssp.go)
    contains an alternative implementation of the `MarshalBinary()` and `UnmarshalBinary()`
    functions. Although it doesn’t demonstrate ASN.1 encoding, the `ntlmssp` code
    shows how to handle encoding of an arbitrary data type by using necessary metadata.
    The metadata—the lengths and offsets of variable-length `byte` slices—is pertinent
    to the encoding process. This metadata leads us to the next challenge you need
    to address.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`ntlmssp`包位于[*https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/ntlmssp/ntlmssp.go*](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/ntlmssp/ntlmssp.go)中，包含了`MarshalBinary()`和`UnmarshalBinary()`函数的另一种实现。尽管它没有展示ASN.1编码，`ntlmssp`代码展示了如何通过使用必要的元数据来处理任意数据类型的编码。元数据——可变长度`byte`切片的长度和偏移量——与编码过程密切相关。这些元数据引导我们进入下一个你需要解决的挑战。'
- en: Understanding Metadata and Referential Fields
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解元数据和引用字段
- en: 'If you dig into the SMB specification a little, you’ll find that some messages
    contain fields that reference other fields of the same message. For example, the
    fields—taken from the Negotiate response message—refer to the offset and length
    of a variable-length byte slice that contains the actual value:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你深入研究SMB规范，你会发现一些消息包含引用同一消息中其他字段的字段。例如，来自协商响应消息的字段，引用了包含实际值的可变长度字节切片的偏移量和长度：
- en: '**SecurityBufferOffset (2 bytes):** The offset, in bytes, from the beginning
    of the SMB2 header to the security buffer.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**SecurityBufferOffset (2 字节)：** 从SMB2头部开始到安全缓冲区的偏移量（以字节为单位）。'
- en: '**SecurityBufferLength (2 bytes):** The length, in bytes, of the security buffer.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**SecurityBufferLength (2 字节)：** 安全缓冲区的长度（以字节为单位）。'
- en: 'These fields essentially act as metadata. Later in the message spec, you find
    the variable-length field within which your data actually resides:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段本质上充当了元数据。在消息规范后续部分，你将找到实际存储数据的可变长度字段：
- en: '**Buffer (variable):** The variable-length buffer that contains the security
    buffer for the response, as specified by SecurityBufferOffset and SecurityBufferLength.
    The buffer SHOULD contain a token as produced by the GSS protocol as specified
    in section 3.3.5.4\. If SecurityBufferLength is 0, this field is empty and client-initiated
    authentication, with an authentication protocol of the client’s choice, will be
    used instead of server-initiated SPNEGO authentication, as described in [MS-AUTHSOD]
    section 2.1.2.2.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**Buffer（变量）：** 包含响应的安全缓冲区的可变长度缓冲区，具体由SecurityBufferOffset和SecurityBufferLength指定。该缓冲区应该包含由GSS协议生成的令牌，具体见第3.3.5.4节。如果SecurityBufferLength为0，则此字段为空，客户端发起的身份验证（使用客户端选择的身份验证协议）将取代服务器发起的SPNEGO身份验证，具体描述见[MS-AUTHSOD]第2.1.2.2节。'
- en: 'Generally speaking, this is how the SMB spec consistently handles variable-length
    data: fixed-position length and offset fields depicting the size and location
    of the data itself. This is not specific to response messages or the Negotiate
    message, and often you’ll find multiple fields within a single message using this
    pattern. Really, anytime you have a variable-length field, you’ll find this pattern.
    The metadata explicitly instructs the message receiver on how to locate and extract
    the data.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，SMB规范是通过固定位置的长度和偏移量字段来一致地处理可变长度数据的，这些字段表示数据本身的大小和位置。这不仅仅适用于响应消息或协商消息，通常你会在单个消息中发现多个字段使用这种模式。实际上，只要你有一个可变长度字段，你就会发现这种模式。元数据明确地指示消息接收方如何定位和提取数据。
- en: This is useful, but it complicates your encoding strategy because you now need
    to maintain a relationship between different fields within a struct. You can’t,
    for example, just marshal an entire message because some of the metadata fields—for
    example, length and offset—won’t be known until the data itself is marshaled or,
    in the case of the offset, all fields preceding the data are marshaled.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有用，但它使得编码策略变得复杂，因为你现在需要维护结构体内不同字段之间的关系。例如，你不能仅仅对整个消息进行序列化，因为某些元数据字段（例如，长度和偏移量）直到数据本身被序列化后才会知道，或者在偏移量的情况下，所有位于数据之前的字段都必须被序列化。
- en: Understanding the SMB Implementation
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解SMB实现
- en: The remainder of this subsection addresses some of the ugly details regarding
    the SMB implementation we devised. You don’t need to understand this information
    to use the package.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本小节的其余部分涉及我们设计的SMB实现中的一些复杂细节。你无需理解这些信息就能使用这个包。
- en: We played around with a variety of approaches to handle referential data, eventually
    settling on a solution that utilizes a combination of structure field tags and
    reflection. Recall that *reflection* is a technique through which a program can
    inspect itself, particularly examining things like its own data types. *Field
    tags* are somewhat related to reflection in that they define arbitrary metadata
    about a struct field. You may recall them from previous XML, MSGPACK, or JSON
    encoding examples. For example, [Listing 6-5](ch06.xhtml#ch6list5) uses struct
    tags to define JSON field names.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试了多种处理引用数据的方法，最终选择了一种结合了结构体字段标签和反射的方案。回想一下，*反射*是一种程序能够自我检查的技术，特别是检查类似于程序自身数据类型的内容。*字段标签*在某种程度上与反射相关，因为它们定义了有关结构体字段的任意元数据。你可能在之前的XML、MSGPACK或JSON编码示例中见过它们。例如，[示例
    6-5](ch06.xhtml#ch6list5)使用结构体标签来定义JSON字段名称。
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 6-5: A struct defining JSON field tags*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 6-5：定义JSON字段标签的结构体*'
- en: Go’s `reflect` package contains the functions we used to inspect data types
    and extract field tags. At that point, it was a matter of parsing the tags and
    doing something meaningful with their values. In [Listing 6-6](ch06.xhtml#ch6list6),
    you can see a struct defined in the SMB package.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Go的`reflect`包包含了我们用来检查数据类型并提取字段标签的函数。那时，问题就在于解析标签并对其值执行有意义的操作。在[示例 6-6](ch06.xhtml#ch6list6)中，你可以看到在SMB包中定义的结构体。
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 6-6: Using SMB field tags for defining field metadata (*[/ch-6/smb/smb/smb.go](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/smb.go)*)*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 6-6：使用SMB字段标签定义字段元数据 (*[/ch-6/smb/smb/smb.go](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/smb.go)*)*'
- en: 'This type uses three field tags, identified by the SMB key: `fixed` ❶, `offset`
    ❷, and `len` ❸. Keep in mind that we chose all these names arbitrarily. You aren’t
    obligated to use a specific name. The intent of each tag is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 该类型使用了三个字段标签，通过SMB键进行标识：`fixed` ❶，`offset` ❷，和`len` ❸。请记住，我们选择这些名称都是随意的。您不必使用特定的名称。每个标签的意图如下：
- en: '`fixed` identifies a `[]byte` as a fixed-length field of the provided size.
    In this case, `ServerGuid` is 16 bytes in length.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fixed`标识`[]byte`为一个固定长度的字段，大小为提供的尺寸。在这种情况下，`ServerGuid`的长度为16字节。'
- en: '`offset` defines the number of bytes from the beginning of the struct to the
    first position of a variable-length data buffer. The tag defines the name of the
    field—in this case, `SecurityBlob`—to which the offset relates. A field by this
    referenced name is expected to exist in the same struct.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset`定义了从结构体开始到可变长度数据缓冲区的第一个位置之间的字节数。该标签定义了字段的名称——在此情况下是`SecurityBlob`——该偏移量与之相关。通过该引用名称的字段预计存在于相同的结构体中。'
- en: '`len` defines the length of a variable-length data buffer. The tag defines
    the name of the field—in this case, `SecurityBlob`, to which the length relates.
    A field by this referenced name should exist in the same struct.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`len`定义了一个可变长度数据缓冲区的长度。该标签定义了字段的名称——在此情况下是`SecurityBlob`，该长度与之相关。通过这个引用名称的字段应该存在于相同的结构体中。'
- en: As you might have noticed, our tags allow us not only to create relationships—through
    arbitrary metadata—between different fields, but also to differentiate between
    fixed-length byte slices and variable-length data. Unfortunately, adding these
    struct tags doesn’t magically fix the problem. The code needs to have the logic
    to look for these tags and take specific actions on them during marshaling and
    unmarshaling.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所注意到的，我们的标签不仅允许我们通过任意元数据在不同字段之间创建关系，还能区分固定长度字节切片和可变长度数据。不幸的是，添加这些结构体标签并不会神奇地解决问题。代码需要有逻辑来查找这些标签，并在序列化和反序列化时对其执行特定操作。
- en: Parsing and Storing Tags
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解析和存储标签
- en: In [Listing 6-7](ch06.xhtml#ch6list7), the convenience function, called `parseTags()`,
    performs the tag-parsing logic and stores the data in a helper struct of type
    `TagMap`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单6-7](ch06.xhtml#ch6list7)中，名为`parseTags()`的便利函数执行标签解析逻辑，并将数据存储在一个类型为`TagMap`的辅助结构体中。
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 6-7: Parsing structure tags (*[/ch-6/smb/smb/encoder/encoder.go](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go)*)*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-7：解析结构体标签（*[/ch-6/smb/smb/encoder/encoder.go](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go)）*'
- en: The function accepts a parameter named `sf` of type `reflect.StructField` ❶,
    which is a type defined within Go’s `reflect` package. The code calls `sf.Tag.Get("smb")`
    on the `StructField` variable to retrieve any `smb` tags defined on the field
    ❷. Again, this is an arbitrary name we chose for our program. We just need to
    make sure that the code to parse the tags is using the same key as the one we
    used in our struct’s type definition.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个名为`sf`的参数，其类型为`reflect.StructField` ❶，这是Go语言`reflect`包内定义的一个类型。代码在`StructField`变量上调用`sf.Tag.Get("smb")`来检索在字段上定义的任何`smb`标签
    ❷。同样，这是我们为程序选择的一个任意名称。我们只需要确保用于解析标签的代码使用与我们在结构体类型定义中使用的相同的键。
- en: We then split the `smb` tags on a comma ❸, in case we need to have multiple
    `smb` tags defined on a single struct field in the future, and loop through each
    tag ❹. We split each tag on a colon ❺—recall that we used the format name`:`value
    for our tags, such as `fixed:16` and `len:SecurityBlob`. With the individual tag
    data separated into its basic key and value pairing, we use a `switch` statement
    on the key to perform key-specific validation logic, such as converting values
    to integers for `fixed` tag values ❻.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将`smb`标签按逗号 ❸ 分割，以防将来需要在单个结构体字段上定义多个`smb`标签，并遍历每个标签 ❹。我们按冒号 ❺ 分割每个标签——回想一下，我们使用的是`name:value`格式的标签，如`fixed:16`和`len:SecurityBlob`。将单个标签数据分离为基本的键值对后，我们使用`switch`语句对键进行特定的验证逻辑，例如将`fixed`标签的值转换为整数
    ❻。
- en: Lastly, the function sets the data in our custom map named `ret` ❼.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，函数将数据存储在我们自定义的名为`ret`的映射中 ❼。
- en: Invoking the parseTags() Function and Creating a reflect.StructField Object
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 调用`parseTags()`函数并创建`reflect.StructField`对象
- en: Now, how do we invoke the function, and how do we create an object of type `reflect.StructField`?
    To answer these questions, look at the `unmarshal()` function in [Listing 6-8](ch06.xhtml#ch6list8),
    which is within the same source file that has our `parseTags()` convenience function.
    The `unmarshal()` function is extensive, so we’ll just piece together the most
    relevant portions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 6-8: Using reflection to dynamically unmarshal unknown types (*[/ch-6/smb/smb/encoder/encoder.go](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go)*)*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The `unmarshal()` function uses Go’s `reflect` package to retrieve the type
    ❶ and value ❷ of the destination interface to which our data buffer will be unmarshaled.
    This is necessary because in order to convert an arbitrary byte slice into a struct,
    we need to know how many fields are in the struct and how many bytes to read for
    each field. For example, a field defined as `uint16` consumes 2 bytes, whereas
    a `uint64` consumes 8 bytes. By using reflection, we can interrogate the destination
    interface to see what data type it is and how to handle the reading of data. Because
    the logic for each type will differ, we perform a `switch` on the type by calling
    `typev.Kind()` ❸, which returns a `reflect.Kind` instance indicating the kind
    of data type we’re working with. You’ll see that we have a separate case for each
    of the allowed data types.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Handling Structs
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s look at the `case` block, in [Listing 6-9](ch06.xhtml#ch6list9), that
    handles a struct type, since that is a likely initial entry point.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 6-9: Unmarshaling a struct type (*[/ch-6/smb/smb/encoder/encoder.go](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go)*)*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The `case` block begins by defining a new `Metadata` object ❶, a type used to
    track relevant metadata, including the current buffer offset, field tags, and
    other information. Using our type variable, we call the `NumField()` method to
    retrieve the number of fields within the struct ❷. It returns an integer value
    that acts as the constraint for a loop.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Within the loop, we can extract the current field through a call to the type’s
    `Field(index int)` method. The method returns a `reflect.StructField` type. You’ll
    see we use this method a few times throughout this code snippet. Think of it as
    retrieving an element from a slice by index value. Our first usage ❸ retrieves
    the field to extract the field’s name. For example, `SecurityBufferOffset` and
    `SecurityBlob` are field names within the `NegotiateRes` struct defined in [Listing
    6-6](ch06.xhtml#ch6list6). The field name is assigned to the `CurrField` property
    of our `Metadata` object. The second call to the `Field(index int)` method is
    inputted to the `parseTags()` function ❹ from [Listing 6-7](ch06.xhtml#ch6list7).
    We know this function parses our struct field tags. The tags are included in our
    `Metadata` object for later tracking and usage.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use a `switch` statement to act specifically on the field type ❺. There
    are only two cases. The first handles instances where the field itself is a struct
    ❻, in which case, we make a recursive call to the `unmarshal()` function, passing
    to it a pointer to the field as an interface. The second case handles all other
    kinds (primitives, slices, and so on), recursively calling the `unmarshal()` function
    and passing it the field itself as an interface ❼. Both calls do some funny business
    to advance the buffer to start at our current offset. Our recursive call eventually
    returns an `interface{}`, which is a type that contains our unmarshaled data.
    We use reflection to set our current field’s value to the value of this interface
    data ❽. Lastly, we advance our current offset in the buffer ❾.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Yikes! Can you see how this can be a challenge to develop? We have a separate
    case for every kind of input. Luckily, the `case` block that handles a struct
    is the most complicated.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Handling uint16
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you are really paying attention, you’re probably asking: where do you actually
    read data from the buffer? The answer is nowhere in [Listing 6-9](ch06.xhtml#ch6list9).
    Recall that we are making recursive calls to the `unmarshal()` function, and each
    time, we pass the inner fields to the function. Eventually we’ll reach primitive
    data types. After all, at some point, the innermost nested structs are composed
    of basic data types. When we encounter a basic data type, our code will match
    against a different case in the outermost `switch` statement. For example, when
    we encounter a `uint16` data type, this code executes the `case` block in [Listing
    6-10](ch06.xhtml#ch6list10).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 6-10: Unmarshaling `uint16` data (*[/ch-6/smb/smb/encoder/encoder.go/](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go)*)*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: In this `case` block, we make a call to `binary.Read()` in order to read data
    from our buffer into a variable, `ret` ❶. This function is smart enough to know
    how many bytes to read, based off the type of the destination. In this case, `ret`
    is a `uint16`, so 2 bytes are read.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check whether the `len` field tag is present ❷. If it is, we retrieve
    the value—that is, a field name—tied to that key ❸. Recall that this value will
    be a field name to which the current field is expected to refer. Because the length-identifying
    fields precede the actual data in the SMB messages, we don’t know where the buffer
    data actually resides, and so we can’t take any action yet.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: We’ve just acquired length metadata, and there’s no better place to store it
    than in our `Metadata` object. We store it within a `map[string]uint64` that maintains
    a relationship of reference field names to their lengths ❹. Phrased another way,
    we now know how long a variable-length byte slice needs to be. We advance the
    current offset by the size of the data we just read ❺, and return the value read
    from the buffer.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Similar logic and metadata tracking happen in the process of handling the `offset`
    tag information, but we omitted that code for brevity.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理`offset`标签信息的过程中，类似的逻辑和元数据跟踪也会发生，但我们为了简洁省略了那部分代码。
- en: Handling Slices
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 处理切片
- en: In [Listing 6-11](ch06.xhtml#ch6list11), you can see the `case` block that unmarshals
    slices, which we need to account for both fixed- and variable-length data while
    using tags and metadata in the process.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 6-11](ch06.xhtml#ch6list11)中，你可以看到`case`块，它反序列化切片，我们需要在处理过程中考虑到固定长度和可变长度数据，同时使用标签和元数据。
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 6-11: Unmarshaling fixed- and variable-length byte slices (*[/ch-6/smb/smb/encoder/encoder.go/](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go/)*)*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-11：反序列化固定长度和可变长度字节切片（*[/ch-6/smb/smb/encoder/encoder.go/](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go/)*)*'
- en: First, we use reflection to determine the slice’s element type ❶. For example,
    handling of `[]uint8` is different from `[]uint32`, as the number of bytes per
    element differs. In this case, we’re handling only `[]uint8` slices. Next, we
    define a couple of local variables, `length` and `offset`, to use for tracking
    the length of the data to read and the offset within the buffer from which to
    begin reading ❷. If the slice is defined with the `fixed` tag, we retrieve the
    value and assign it to `length` ❸. Recall that the tag value for the `fixed` key
    is an integer that defines the length of the slice. We’ll use this length to advance
    the current buffer offset for future reads ❹. For fixed-length fields, the `offset`
    is left as its default value—zero—since it will always appear at the current offset.
    Variable-length slices are slightly more complex because we retrieve both the
    length ❺ and offset ❻ information from our `Metadata` structure. A field uses
    its own name as the key for the lookup of the data. Recall how we populated this
    information previously. With our `length` and `offset` variables properly set,
    we then create a slice of the desired length ❼ and use it in a call to `binary.Read()`
    ❽. Again, this function is smart enough to read bytes up until our destination
    slice has been filled.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用反射来确定切片的元素类型❶。例如，`[]uint8`的处理方式与`[]uint32`不同，因为每个元素的字节数不同。在这个例子中，我们只处理`[]uint8`切片。接下来，我们定义了两个本地变量`length`和`offset`，用于跟踪要读取的数据的长度以及从缓冲区开始读取的位置❷。如果切片是用`fixed`标签定义的，我们就会获取该值并将其赋给`length`❸。回想一下，`fixed`键的标签值是一个整数，定义了切片的长度。我们将使用这个长度来推进当前缓冲区的偏移量，以便将来读取❹。对于固定长度字段，`offset`保持其默认值——零——因为它将始终出现在当前偏移位置。可变长度切片稍微复杂一些，因为我们需要从`Metadata`结构中检索长度❺和偏移量❻信息。一个字段使用它自己的名称作为数据查找的键。回忆一下我们之前是如何填充这些信息的。通过正确设置`length`和`offset`变量，我们接着创建一个所需长度的切片❼，并在调用`binary.Read()`时使用它❽。再次提醒，这个函数足够智能，能够读取字节，直到我们的目标切片被填充。
- en: This has been an exhaustingly detailed journey into the dark recesses of custom
    tags, reflection, and encoding with a hint of SMB. Let’s move beyond this ugliness
    and do something useful with the SMB library. Thankfully, the following use cases
    should be significantly less complicated.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一次非常详细的旅程，深入探索了自定义标签、反射和编码的黑暗角落，并且略带 SMB 的味道。让我们走出这些丑陋的地方，使用 SMB 库做些有用的事情。幸运的是，接下来的使用案例应该要简单得多。
- en: Guessing Passwords with SMB
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 SMB 猜测密码
- en: 'The first SMB case we’ll examine is a fairly common one for attackers and pen
    testers: online password guessing over SMB. You’ll try to authenticate to a domain
    by providing commonly used usernames and passwords. Before diving in, you’ll need
    to grab the SMB package with the following `get` command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的第一个 SMB 案例是攻击者和渗透测试人员非常常见的一种情况：通过 SMB 进行在线密码猜测。你会尝试通过提供常用的用户名和密码来对一个域进行身份验证。在开始之前，你需要使用以下`get`命令获取
    SMB 包：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once the package is installed, let’s get to coding. The code you’ll create (shown
    in [Listing 6-12](ch06.xhtml#ch6list12)) accepts a file of newline-separated usernames,
    a password, a domain, and target host information as command line arguments. To
    avoid locking accounts out of certain domains, you’ll attempt a single password
    across a list of users rather than attempt a list of passwords across one or more
    users.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦包安装完成，我们就可以开始编写代码了。你将编写的代码（见[列表 6-12](ch06.xhtml#ch6list12)）接受一个包含换行分隔的用户名的文件、一个密码、一个域和目标主机信息作为命令行参数。为了避免将帐户锁定出某些域，你会尝试在一系列用户上使用一个密码，而不是在一个或多个用户上尝试一系列密码。
- en: '**WARNING**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Online password guessing can lock accounts out of a domain, effectively resulting
    in a denial-of-service attack. Take caution when testing your code and run this
    against only systems on which you’re authorized to test.*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 6-12: Leveraging the SMB package for online password guessing (*[/ch-6/password-guessing/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-6/password-guessing/main.go)*)*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'The SMB package operates on sessions. To establish a session, you first initialize
    an `smb.Options` instance that will contain all your session options, including
    target host, user, password, port, and domain ❶. Next, you loop through each of
    your target users ❷, setting the `options.User` value appropriately ❸, and issue
    a call to `smb.NewSession()` ❹. This function does a lot of heavy lifting for
    you behind the scenes: it negotiates both the SMB dialect and authentication mechanism,
    and then authenticates to the remote target. The function will return an error
    if authentication fails, and a boolean `IsAuthenticated` field on the `session`
    struct is populated based off the outcome. It will then check the value to see
    whether the authentication succeeded, and if it did, display a success message
    ❺.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: That is all it takes to create an online password-guessing utility.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Reusing Passwords with the Pass-the-Hash Technique
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *pass-the-hash* technique allows an attacker to perform SMB authentication
    by using a password’s NTLM hash, even if the attacker doesn’t have the cleartext
    password. This section walks you through the concept and shows you an implementation
    of it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass-the-hash is a shortcut to a typical *Active Directory domain compromise*,
    a type of attack in which attackers gain an initial foothold, elevate their privileges,
    and move laterally throughout the network until they have the access levels they
    need to achieve their end goal. Active Directory domain compromises generally
    follow the roadmap presented in this list, assuming they take place through an
    exploit rather than something like password guessing:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The attacker exploits the vulnerability and gains a foothold on the network.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The attacker elevates privileges on the compromised system.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The attacker extracts hashed or cleartext credentials from LSASS.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The attacker attempts to recover the local administrator password via offline
    cracking.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The attacker attempts to authenticate to other machines by using the administrator
    credentials, looking for reuse of the password.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The attacker rinses and repeats until the domain administrator or other target
    has been compromised.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With NTLMSSP authentication, however, even if you fail to recover the cleartext
    password during step 3 or 4, you can proceed to use the password’s NTLM hash for
    SMB authentication during step 5—in other words, passing the hash.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass-the-hash works because it separates the hash calculation from the challenge-response
    token calculation. To see why this is, let’s look at the following two functions,
    defined by the NTLMSSP specification, pertaining to the cryptographic and security
    mechanisms used for authentication:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Pass-the-hash 技术之所以有效，是因为它将哈希计算与挑战-响应令牌计算分离开来。为了理解这一点，我们来看一下以下两个函数，它们由 NTLMSSP
    规范定义，涉及用于认证的加密和安全机制：
- en: '**NTOWFv2** A cryptographic function that creates an MD5 HMAC by using the
    username, domain, and password values. It generates the NTLM hash value.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**NTOWFv2** 是一个加密函数，它通过使用用户名、域和密码值来创建一个 MD5 HMAC，从而生成 NTLM 哈希值。'
- en: '**ComputeResponse** A function that uses the NTLM hash in combination with
    the message’s client and server challenges, timestamp, and target server name
    to produce a GSS-API security token that can be sent for authentication.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**ComputeResponse** 是一个函数，它将 NTLM 哈希与消息的客户端和服务器挑战、时间戳以及目标服务器名称结合使用，生成可以发送进行认证的
    GSS-API 安全令牌。'
- en: You can see the implementations of these functions in [Listing 6-13](ch06.xhtml#ch6list13).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [Listing 6-13](ch06.xhtml#ch6list13) 中看到这些函数的实现。
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 6-13: Working with NTLM hashes (*[/ch-6/smb/ntlmssp/crypto.go](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/ntlmssp/crypto.go)*)*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-13: 处理 NTLM 哈希 (*[/ch-6/smb/ntlmssp/crypto.go](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/ntlmssp/crypto.go)*)*'
- en: 'The NTLM hash is supplied as input to the `ComputeResponseNTLMv2` function
    ❶, meaning the hash has been created independently of the logic used for security
    token creation. This implies that hashes stored anywhere—even in LSASS—are considered
    precalculated, because you don’t need to supply the domain, user, or password
    as input. The authentication process is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: NTLM 哈希作为输入传递给 `ComputeResponseNTLMv2` 函数 ❶，这意味着哈希是在与安全令牌创建逻辑无关的情况下独立生成的。这意味着无论哈希存储在哪里——即使是在
    LSASS 中——都被视为预计算的，因为你不需要提供域、用户名或密码作为输入。认证过程如下：
- en: Calculate the user’s hash by using the domain, user, and password values.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用域、用户名和密码值来计算用户的哈希值。
- en: Use the hash as input to calculate authentication tokens for NTLMSSP over SMB.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用哈希作为输入来计算用于 NTLMSSP 认证的 SMB 认证令牌。
- en: Since you already have a hash in hand, you’ve already completed step 1\. To
    pass the hash, you initiate your SMB authentication sequence, as you defined it
    way back in the opening sections of this chapter. However, you never calculate
    the hash. Instead, you use the supplied value as the hash itself.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经有了哈希值，你已经完成了步骤 1。为了传递哈希，你启动了 SMB 认证序列，就像你在本章开头部分定义的那样。然而，你并没有计算哈希。相反，你直接使用提供的值作为哈希值。
- en: '[Listing 6-14](ch06.xhtml#ch6list14) shows a pass-the-hash utility that uses
    a password hash to attempt to authenticate as a specific user to a list of machines.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 6-14](ch06.xhtml#ch6list14) 展示了一个使用密码哈希来尝试作为特定用户认证到一组机器的 pass-the-hash
    工具。'
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 6-14: Passing the hash for authentication testing (*[/ch-6/password-reuse/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-6/password-reuse/main.go)*)*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 6-14: 使用哈希进行认证测试 (*[/ch-6/password-reuse/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-6/password-reuse/main.go)*)*'
- en: This code should look similar to the password-guessing example. The only significant
    differences are that you’re setting the `Hash` field of `smb.Options` (not the
    `Password` field) ❶ and you’re iterating over a list of target hosts (rather than
    target users) ❷. The logic within the `smb.NewSession()` function will use the
    hash value if populated within the `options` struct.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该与密码猜测的例子相似。唯一显著的区别是，你设置了 `smb.Options` 的 `Hash` 字段（而不是 `Password` 字段）
    ❶，并且你遍历的是一组目标主机（而不是目标用户） ❷。`smb.NewSession()` 函数内的逻辑会使用填充在 `options` 结构体中的哈希值。
- en: Recovering NTLM Passwords
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恢复 NTLM 密码
- en: In some instances, having only the password hash will be inadequate for your
    overall attack chain. For example, many services (such as Remote Desktop, Outlook
    Web Access, and others) don’t allow hash-based authentication, because it either
    isn’t supported or isn’t a default configuration. If your attack chain requires
    access to one of these services, you’ll need a cleartext password. In the following
    sections, you’ll walk through how hashes are calculated and how to create a basic
    password cracker.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，仅拥有密码哈希不足以支持你的整体攻击链。例如，许多服务（如远程桌面、Outlook Web Access 等）不允许基于哈希的认证，因为要么不支持，要么不是默认配置。如果你的攻击链需要访问这些服务，你将需要明文密码。在接下来的部分中，你将了解哈希是如何计算的，以及如何创建一个基础的密码破解工具。
- en: Calculating the Hash
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计算哈希
- en: In [Listing 6-15](ch06.xhtml#ch6list15), you perform the magic of calculating
    the hash.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 6-15: Calculating hashes (*[/ch-6/smb/ntlmssp/ntlmssp.go](https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/ntlmssp/ntlmssp.go/)*)*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The logic to call the appropriate function is defined elsewhere, but you’ll
    see that the two functions are similar. The real difference is that password-based
    authentication in the `NewAuthenticatePass()` function computes the hash before
    generating the authentication message, whereas the `NewAuthenticateHash()` function
    skips that step and uses the supplied hash directly as input to generate the message.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Recovering the NTLM Hash
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Listing 6-16](ch06.xhtml#ch6list16), you can see a utility that recovers
    a password by cracking a supplied NTLM hash.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 6-16: NTLM hash cracking (*[/ch-6/password-recovery/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-6/password-recovery/main.go)*)*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The utility reads the hash as a command line argument, decoding it to a `[]byte`
    ❶. Then you loop over a supplied password list ❷, calculating the hash of each
    entry by calling the `ntlmssp.Ntowfv2()` function we discussed previously ❸. Finally,
    you compare the calculated hash with that of our supplied value ❹. If they match,
    you have a hit and break out of the loop.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve made it through a detailed examination of SMB, touching on protocol specifics,
    reflection, structure field tags, and mixed encoding! You also learned how pass-the-hash
    works, as well as a few useful utility programs that leverage the SMB package.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: To continue your learning, we encourage you to explore additional SMB communications,
    particularly in relation to remote code execution, such as PsExec. Using a network
    sniffer, such as Wireshark, capture the packets and evaluate how this functionality
    works.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we move on from network protocol specifics to focus on
    attacking and pillaging databases.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
