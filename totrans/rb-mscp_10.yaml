- en: 'Chapter 10. JRuby: Ruby on the JVM'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章. JRuby：JVM 上的 Ruby
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*JRuby is Ruby implemented on the Java platform.*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*JRuby 是在 Java 平台上实现的 Ruby。*'
- en: In [Chapter 1](ch01.html "Chapter 1. Tokenization and Parsing") through [Chapter 9](ch09.html
    "Chapter 9. Metaprogramming") we learned how the standard version of Ruby works
    internally. Because Ruby is written in C, its standard implementation is often
    known as *CRuby*. It’s also often referred to as *Matz’s Ruby Interpreter (MRI)*,
    after Yukihiro Matsumoto, who created the language in the early 1990s.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.html "第 1 章. 词法分析与解析") 到 [第 9 章](ch09.html "第 9 章. 元编程") 中，我们学习了
    Ruby 的标准版本是如何在内部工作的。由于 Ruby 是用 C 语言编写的，它的标准实现通常被称为 *CRuby*。它也常被称为 *Matz 的 Ruby
    解释器（MRI）*，这是因为 Yukihiro Matsumoto 在 1990 年代初期创建了这个语言。
- en: In this chapter we’ll see an alternative implementation of Ruby called *JRuby*.
    JRuby is Ruby implemented in Java instead of C. The use of Java allows Ruby applications
    to run like any other Java program, using the Java Virtual Machine (JVM). It also
    allows your Ruby code to interoperate with thousands of libraries written in Java
    and other languages that run on the JVM. Thanks to the JVM’s sophisticated garbage
    collection (GC) algorithms, just-in-time (JIT) compiler, and many other technical
    innovations, using the JVM means that your Ruby code often runs faster and more
    reliably.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到一种名为 *JRuby* 的 Ruby 替代实现。JRuby 是用 Java 实现的 Ruby，而不是用 C 语言。使用 Java
    使得 Ruby 应用程序能够像任何其他 Java 程序一样运行，利用 Java 虚拟机（JVM）。它还使得你的 Ruby 代码能够与成千上万的用 Java
    和其他在 JVM 上运行的语言编写的库进行互操作。得益于 JVM 的先进垃圾回收（GC）算法、即时编译器（JIT）和许多其他技术创新，使用 JVM 意味着你的
    Ruby 代码通常运行得更快，更可靠。
- en: In the first half of this chapter, we’ll contrast standard Ruby—that is, MRI—with
    JRuby. You’ll learn what happens when you run a Ruby program using JRuby and how
    JRuby parses and compiles your Ruby code. In the latter half of the chapter, we’ll
    see how JRuby and MRI save your string data using the `String` class.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前半部分，我们将对比标准 Ruby——即 MRI——与 JRuby。你将了解当使用 JRuby 运行 Ruby 程序时会发生什么，以及 JRuby
    是如何解析和编译你的 Ruby 代码的。在后半部分，我们将看到 JRuby 和 MRI 是如何使用 `String` 类保存你的字符串数据的。
- en: Roadmap
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 路线图
- en: '[Running Programs with MRI and JRuby](ch10.html#running_programs_with_mri_and_jruby
    "Running Programs with MRI and JRuby")'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 MRI 和 JRuby 运行程序](ch10.html#running_programs_with_mri_and_jruby "使用 MRI
    和 JRuby 运行程序")'
- en: '[How JRuby Parses and Compiles Your Code](ch10.html#how_jruby_parses_and_compiles_your_code
    "How JRuby Parses and Compiles Your Code")'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何 JRuby 解析和编译你的代码](ch10.html#how_jruby_parses_and_compiles_your_code "如何
    JRuby 解析和编译你的代码")'
- en: '[How JRuby Executes Your Code](ch10.html#how_jruby_executes_your_code "How
    JRuby Executes Your Code")'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何 JRuby 执行你的代码](ch10.html#how_jruby_executes_your_code "如何 JRuby 执行你的代码")'
- en: '[Implementing Ruby Classes with Java Classes](ch10.html#implementing_ruby_classes_with_java_clas
    "Implementing Ruby Classes with Java Classes")'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 Java 类实现 Ruby 类](ch10.html#implementing_ruby_classes_with_java_clas "使用
    Java 类实现 Ruby 类")'
- en: '**[Experiment 10-1: Monitoring JRuby’s Just-in-Time Compiler](ch10.html#experiment_10-1_monitoring_jrubyapostrop
    "Experiment 10-1: Monitoring JRuby’s Just-in-Time Compiler")**'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验 10-1：监控 JRuby 的即时编译器](ch10.html#experiment_10-1_monitoring_jrubyapostrop
    "实验 10-1：监控 JRuby 的即时编译器")**'
- en: '[Experiment Code](ch10.html#experiment_code "Experiment Code")'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实验代码](ch10.html#experiment_code "实验代码")'
- en: '[Using the -J-XX:+PrintCompilation Option](ch10.html#using_the_-j-xxplusprintcompilation_opti
    "Using the -J-XX:+PrintCompilation Option")'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 -J-XX:+PrintCompilation 选项](ch10.html#using_the_-j-xxplusprintcompilation_opti
    "使用 -J-XX:+PrintCompilation 选项")'
- en: '[Does JIT Speed Up Your JRuby Program?](ch10.html#does_jit_speed_up_your_jruby_programques
    "Does JIT Speed Up Your JRuby Program?")'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JIT 是否加速你的 JRuby 程序？](ch10.html#does_jit_speed_up_your_jruby_programques "JIT
    是否加速你的 JRuby 程序？")'
- en: '[Strings in JRuby and MRI](ch10.html#strings_in_jruby_and_mri "Strings in JRuby
    and MRI")'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JRuby 和 MRI 中的字符串](ch10.html#strings_in_jruby_and_mri "JRuby 和 MRI 中的字符串")'
- en: '[How JRuby and MRI Save String Data](ch10.html#how_jruby_and_mri_save_string_data
    "How JRuby and MRI Save String Data")'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[JRuby 和 MRI 如何保存字符串数据](ch10.html#how_jruby_and_mri_save_string_data "JRuby
    和 MRI 如何保存字符串数据")'
- en: '[Copy-on-Write](ch10.html#copy-on-write "Copy-on-Write")'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[写时复制](ch10.html#copy-on-write "写时复制")'
- en: '**[Experiment 10-2: Measuring Copy-on-Write Performance](ch10.html#experiment_10-2_measuring_copy-on-write
    "Experiment 10-2: Measuring Copy-on-Write Performance")**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验 10-2：测量写时复制性能](ch10.html#experiment_10-2_measuring_copy-on-write "实验
    10-2：测量写时复制性能")**'
- en: '[Creating a Unique, Nonshared String](ch10.html#creating_a_uniquecomma_nonshared_string
    "Creating a Unique, Nonshared String")'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建唯一的、非共享的字符串](ch10.html#creating_a_uniquecomma_nonshared_string "创建唯一的、非共享的字符串")'
- en: '[Experiment Code](ch10.html#experiment_code "Experiment Code")'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[实验代码](ch10.html#experiment_code "实验代码")'
- en: '[Visualizing Copy-on-Write](ch10.html#visualizing_copy-on-write "Visualizing
    Copy-on-Write")'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[可视化写时复制](ch10.html#visualizing_copy-on-write "可视化写时复制")'
- en: '[Modifying a Shared String Is Slower](ch10.html#modifying_a_shared_string_is_slower
    "Modifying a Shared String Is Slower")'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[修改共享字符串较慢](ch10.html#modifying_a_shared_string_is_slower "修改共享字符串较慢")'
- en: '[Summary](ch10.html#summary-id00041 "Summary")'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](ch10.html#summary-id00041 "总结")'
- en: Running Programs with MRI and JRuby
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MRI 和 JRuby 运行程序
- en: The normal way to run a Ruby program using standard Ruby is to enter `ruby`
    followed by the name of your Ruby script, as shown in [Figure 10-1](ch10.html#running_a_script_at_the_command_line_usi
    "Figure 10-1. Running a script at the command line using standard Ruby").
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准 Ruby 运行 Ruby 程序的常见方法是输入`ruby`，然后跟上 Ruby 脚本的名称，如[图 10-1](ch10.html#running_a_script_at_the_command_line_usi
    "图 10-1. 使用标准 Ruby 在命令行运行脚本")所示。
- en: '![Running a script at the command line using standard Ruby](httpatomoreillycomsourcenostarchimages1854279.png.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![使用标准 Ruby 在命令行运行脚本](httpatomoreillycomsourcenostarchimages1854279.png.jpg)'
- en: Figure 10-1. Running a script at the command line using standard Ruby
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-1. 使用标准 Ruby 在命令行运行脚本
- en: As you can see in the rectangle at the left, entering `ruby` at a terminal prompt
    launches a binary executable, the product of compiling Ruby’s C source code during
    the Ruby build process. On the right, you see that the command line parameter
    to the `ruby` command is a text file containing your Ruby code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如左侧矩形框所示，在终端提示符下输入`ruby`会启动一个二进制可执行文件，这是 Ruby 构建过程中将 Ruby 的 C 源代码编译后的产物。右侧则显示了`ruby`命令的命令行参数，即包含
    Ruby 代码的文本文件。
- en: To run your Ruby script using JRuby, you normally enter `jruby` at your terminal
    prompt. (Depending on how you installed JRuby, the standard `ruby` command might
    be remapped to launch JRuby.) [Figure 10-2](ch10.html#jruby_command_actually_maps_to_a_she
    "Figure 10-2. The jruby command actually maps to a shell script.") shows how this
    command works at a high level.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 JRuby 运行 Ruby 脚本，通常在终端提示符下输入`jruby`。 （根据你安装 JRuby 的方式，标准的`ruby`命令可能已重新映射为启动
    JRuby。）[图 10-2](ch10.html#jruby_command_actually_maps_to_a_she "图 10-2. `jruby`
    命令实际上映射到一个 shell 脚本")展示了这个命令的高层工作原理。
- en: '![The jruby command actually maps to a shell script.](httpatomoreillycomsourcenostarchimages1854281.png.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![`jruby` 命令实际上映射到一个 shell 脚本](httpatomoreillycomsourcenostarchimages1854281.png.jpg)'
- en: Figure 10-2. The `jruby` command actually maps to a shell script.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-2. `jruby` 命令实际上映射到一个 shell 脚本。
- en: Unlike the `ruby` command, the `jruby` command doesn’t map to a binary executable.
    It refers to a shell script that executes the `java` command. [Figure 10-3](ch10.html#simplified_version_of_the_command_jrub
    "Figure 10-3. A simplified version of the command JRuby uses to launch the JVM")
    shows a simplified view of the command JRuby uses to launch Java.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ruby`命令不同，`jruby`命令并不映射到二进制可执行文件，而是指向一个执行`java`命令的 shell 脚本。[图 10-3](ch10.html#simplified_version_of_the_command_jrub
    "图 10-3. JRuby 启动 JVM 的命令简化版") 展示了 JRuby 启动 Java 的命令简化版。
- en: '![A simplified version of the command JRuby uses to launch the JVM](httpatomoreillycomsourcenostarchimages1854283.png.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![JRuby 启动 JVM 的命令简化版](httpatomoreillycomsourcenostarchimages1854283.png.jpg)'
- en: Figure 10-3. A simplified version of the command JRuby uses to launch the JVM
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-3. JRuby 启动 JVM 的命令简化版
- en: Notice in [Figure 10-3](ch10.html#simplified_version_of_the_command_jrub "Figure 10-3. A
    simplified version of the command JRuby uses to launch the JVM") that JRuby executes
    your Ruby script using a binary executable known as the *Java Virtual Machine
    (JVM)*. Like the standard Ruby executable, the JVM is written in C and compiled
    into a binary executable. The JVM runs Java applications, while MRI runs Ruby
    applications.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 10-3](ch10.html#simplified_version_of_the_command_jrub "图 10-3. JRuby 启动
    JVM 的命令简化版")中注意到，JRuby 使用被称为*Java 虚拟机 (JVM)* 的二进制可执行文件来执行 Ruby 脚本。与标准 Ruby 可执行文件一样，JVM
    是用 C 编写并编译成二进制可执行文件。JVM 运行 Java 应用程序，而 MRI 运行 Ruby 应用程序。
- en: 'Notice, too, that in the center of [Figure 10-3](ch10.html#simplified_version_of_the_command_jrub
    "Figure 10-3. A simplified version of the command JRuby uses to launch the JVM")
    one of the parameters to the `java` program, *-Xbootclasspath*, specifies an additional
    library, or collection, of compiled Java code to make available to the new program:
    *jruby.jar*. The JRuby Java application is contained inside *jruby.jar*. Finally,
    on the right, you see the text file containing your Ruby code again.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在[Figure 10-3](ch10.html#simplified_version_of_the_command_jrub "Figure 10-3. A
    simplified version of the command JRuby uses to launch the JVM")的中间，`java`程序的一个参数，*-Xbootclasspath*，指定了一个额外的Java编译代码库或集合，用于新程序：*jruby.jar*。JRuby
    Java应用程序包含在*jruby.jar*中。最后，在右侧，你再次看到包含你的Ruby代码的文本文件。
- en: 'In sum, here’s what happens when standard Ruby and JRuby launch your Ruby programs:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，当标准Ruby和JRuby启动你的Ruby程序时，会发生以下情况：
- en: When you run a Ruby script using MRI, you launch a binary executable, originally
    written in C, that directly compiles and executes your Ruby script. This is the
    standard version of Ruby.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你使用MRI运行Ruby脚本时，你启动了一个二进制可执行文件，最初用C语言编写，直接编译和执行你的Ruby脚本。这是Ruby的标准版本。
- en: When you run a Ruby script using JRuby, you launch a binary executable, the
    JVM, which executes the JRuby Java application. This Java application, in turn,
    parses, compiles, and executes your Ruby script while running inside the JVM.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你使用JRuby运行Ruby脚本时，你启动了一个二进制可执行文件，即JVM，它执行JRuby Java应用程序。这个Java应用程序依次解析、编译和执行你的Ruby脚本，同时在JVM内部运行。
- en: How JRuby Parses and Compiles Your Code
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JRuby如何解析和编译你的代码
- en: Once you launch JRuby, it needs to parse and compile your code. To do this,
    it uses a parser generator, just as MRI does. [Figure 10-4](ch10.html#jruby_uses_a_parser_generator_called_jay
    "Figure 10-4. JRuby uses a parser generator called Jay.") shows a high-level overview
    of the JRuby parsing and compiling process.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你启动了JRuby，它需要解析和编译你的代码。为此，它使用一个解析器生成器，就像MRI一样。[Figure 10-4](ch10.html#jruby_uses_a_parser_generator_called_jay
    "Figure 10-4. JRuby uses a parser generator called Jay.")展示了JRuby解析和编译过程的高级概述。
- en: '![JRuby uses a parser generator called Jay.](httpatomoreillycomsourcenostarchimages1854285.png.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![JRuby使用名为Jay的解析器生成器。](httpatomoreillycomsourcenostarchimages1854285.png.jpg)'
- en: Figure 10-4. JRuby uses a parser generator called Jay.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 10-4. JRuby使用名为Jay的解析器生成器。
- en: Just as MRI uses Bison, JRuby uses a parser generator called *Jay* during the
    JRuby build process to create the code that will parse your Ruby code. Jay is
    very similar to Bison, except that it’s written in Java instead of C. At run time,
    JRuby tokenizes and parses your Ruby code using the generated parser. As with
    MRI, this process produces an abstract syntax tree (AST).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如MRI使用Bison一样，JRuby在构建过程中使用名为*Jay*的解析器生成器来创建解析你的Ruby代码的代码。Jay与Bison非常相似，只是它是用Java而不是C编写的。在运行时，JRuby使用生成的解析器对你的Ruby代码进行标记化和解析。与MRI一样，这个过程产生一个抽象语法树（AST）。
- en: Once JRuby parses your code and produces an AST, it compiles your code. However,
    instead of producing YARV instructions as MRI does, JRuby produces a series of
    instructions, known as *Java bytecode* instructions, that the JVM can execute.
    [Figure 10-5](ch10.html#different_forms_your_ruby_code_takes "Figure 10-5. The
    different forms your Ruby code takes inside MRI (left) and JRuby (right)") shows
    a high-level comparison of how MRI and JRuby process your Ruby code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦JRuby解析了你的代码并生成了AST，它会对你的代码进行编译。但是，与MRI生成YARV指令不同，JRuby生成一系列指令，即*Java字节码*指令，供JVM执行。[Figure 10-5](ch10.html#different_forms_your_ruby_code_takes
    "Figure 10-5. The different forms your Ruby code takes inside MRI (left) and JRuby
    (right)")展示了MRI和JRuby处理Ruby代码的高级比较。
- en: The left side of the figure shows how your Ruby code changes when you execute
    it with MRI. MRI converts your code into tokens, then into AST nodes, and finally
    into YARV instructions. The *Interpret* arrow indicates that the MRI executable
    reads the YARV instructions and interprets, or executes, them. (You don’t write
    the C or machine language code; that work is done for you.)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图的左侧显示了使用MRI执行时你的Ruby代码的变化。MRI将你的代码转换为标记，然后转换为AST节点，最后转换为YARV指令。*Interpret*箭头表示MRI可执行文件读取YARV指令并解释或执行它们。（你不需要编写C或机器语言代码；这项工作已经为你完成。）
- en: '![The different forms your Ruby code takes inside MRI (left) and JRuby (right)](httpatomoreillycomsourcenostarchimages1854287.png.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![MRI（左）和JRuby（右）中你的Ruby代码的不同形式](httpatomoreillycomsourcenostarchimages1854287.png.jpg)'
- en: Figure 10-5. The different forms your Ruby code takes inside MRI (left) and
    JRuby (right)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 10-5. MRI（左）和JRuby（右）中你的Ruby代码的不同形式
- en: 'The high-level overview at the right side of the figure shows how JRuby handles
    your Ruby code internally. The boxes in the one large rectangle show the different
    forms your code takes as JRuby executes it. You can see that, like MRI, JRuby
    first converts your code into tokens and later into AST nodes. But then MRI and
    JRuby diverge: JRuby compiles the AST nodes into Java bytecode instructions, which
    the JVM can execute. In addition, the JVM can convert the Java bytecode into machine
    language using a JIT compiler, which speeds up your program even more because
    executing machine language is faster than executing Java bytecode. (We’ll look
    at the JIT compiler in more detail in [Experiment 10-1: Monitoring JRuby’s Just-in-Time
    Compiler](ch10.html#experiment_10-1_monitoring_jrubyapostrop "Experiment 10-1:
    Monitoring JRuby’s Just-in-Time Compiler").)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图右侧的高层次概述展示了 JRuby 如何在内部处理您的 Ruby 代码。大矩形中的各个框显示了 JRuby 执行代码时，您的代码所经历的不同形式。您可以看到，像
    MRI 一样，JRuby 首先将您的代码转换为词法单元，随后转换为 AST 节点。但随后 MRI 和 JRuby 分道扬镳：JRuby 将 AST 节点编译为
    Java 字节码指令，JVM 可以执行这些指令。此外，JVM 还可以使用 JIT 编译器将 Java 字节码转换为机器语言，这样可以进一步加速程序，因为执行机器语言比执行
    Java 字节码要快。（我们将在[实验 10-1：监控 JRuby 的即时编译器](ch10.html#experiment_10-1_monitoring_jrubyapostrop
    "实验 10-1：监控 JRuby 的即时编译器")中更详细地了解 JIT 编译器。）
- en: How JRuby Executes Your Code
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JRuby 如何执行您的代码
- en: We’ve seen that JRuby tokenizes and parses your code almost the same way that
    MRI does. And just as MRI Ruby 1.9 and 2.0 compile your code into YARV instructions,
    JRuby compiles it into Java bytecode instructions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 JRuby 以几乎与 MRI 相同的方式对代码进行词法分析和解析。就像 MRI Ruby 1.9 和 2.0 将您的代码编译为 YARV
    指令一样，JRuby 将其编译为 Java 字节码指令。
- en: 'But that’s where the similarity ends: MRI and JRuby use two very different
    virtual machines to execute your code. Standard Ruby uses YARV, but JRuby uses
    the JVM to execute your program.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但相似性到此为止：MRI 和 JRuby 使用两种完全不同的虚拟机来执行您的代码。标准 Ruby 使用 YARV，而 JRuby 使用 JVM 来执行您的程序。
- en: 'The whole point of building a Ruby interpreter with Java is to be able to execute
    Ruby programs using the JVM. The ability to use the JVM is important for two reasons:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Java 构建 Ruby 解释器的核心目的，就是能够通过 JVM 执行 Ruby 程序。使用 JVM 的能力非常重要，原因有二：
- en: '****Environmental****. The JVM allows you to use Ruby on servers, in applications,
    and in IT organizations where previously you could not run Ruby at all.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****环境性****。JVM 使您能够在服务器、应用程序以及之前无法运行 Ruby 的 IT 组织中使用 Ruby。'
- en: '****Technical****. The JVM is the product of almost 20 years of intense research
    and development. It contains sophisticated solutions for many difficult computer
    science problems, like garbage collection and multithreading. Ruby can often run
    faster and more reliably on the JVM.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****技术性****。JVM 是经过近 20 年的强烈研究和开发的产物，包含了许多难题的复杂解决方案，比如垃圾回收和多线程。Ruby 在 JVM 上通常能更快、更可靠地运行。'
- en: To get a better sense of how this works, let’s see how JRuby executes the simple
    Ruby script *simple.rb* in [Example 10-1](ch10.html#one-line_ruby_program_left_parenthesis
    "Example 10-1. A one-line Ruby program (simple.rb)").
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一过程，让我们看看 JRuby 如何执行简单的 Ruby 脚本 *simple.rb*，如[示例 10-1](ch10.html#one-line_ruby_program_left_parenthesis
    "示例 10-1. 一行 Ruby 程序 (simple.rb)")所示。
- en: Example 10-1. A one-line Ruby program *(simple.rb)*
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-1。 一行 Ruby 程序 *(simple.rb)*
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, JRuby tokenizes and parses this Ruby code into an AST node structure.
    Next, it iterates through the AST nodes and converts your Ruby into Java bytecode.
    Use the `--bytecode` option, as shown in [Example 10-2](ch10.html#jrubyapostrophes_--bytecode_option_displ
    "Example 10-2. JRuby’s --bytecode option displays the Java bytecode your Ruby
    code is compiled into."), to see this bytecode for yourself.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，JRuby 对这段 Ruby 代码进行词法分析并解析为 AST 节点结构。接下来，它遍历这些 AST 节点并将 Ruby 转换为 Java 字节码。如[示例
    10-2](ch10.html#jrubyapostrophes_--bytecode_option_displ "示例 10-2. JRuby 的 `--bytecode`
    选项显示您的 Ruby 代码被编译成的 Java 字节码。")所示，使用 `--bytecode` 选项可以查看这些字节码。
- en: Example 10-2. JRuby’s `--bytecode` option displays the Java bytecode your Ruby
    code is compiled into.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-2。 JRuby 的 `--bytecode` 选项显示您的 Ruby 代码被编译成的 Java 字节码。
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As the output of this command is complex, I won’t dig into it here, but [Figure 10-6](ch10.html#jruby_converts_your_ruby_code_into_java
    "Figure 10-6. JRuby converts your Ruby code into Java classes.") summarizes how
    JRuby compiles and executes this script.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该命令的输出较为复杂，我在这里不做深入探讨，但[图 10-6](ch10.html#jruby_converts_your_ruby_code_into_java
    "图 10-6. JRuby 将您的 Ruby 代码转换为 Java 类。")总结了 JRuby 如何编译并执行该脚本。
- en: At the left of this figure, you see the code `puts 2+2`. The large downward
    pointing arrow indicates that JRuby converts this code into a series of Java bytecode
    instructions that implement a Java class called `simple` (after the script’s filename).
    The `class simple extends AbstractScript` notation is Java code; here, it declares
    a new Java class called `simple`, which uses `AbstractScript` as a superclass.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图的左侧，你可以看到代码 `puts 2+2`。指向下方的大箭头表示 JRuby 将这段代码转换为一系列 Java 字节码指令，这些指令实现了一个名为
    `simple` 的 Java 类（与脚本的文件名相同）。`class simple extends AbstractScript` 的表示法是 Java
    代码；它在这里声明了一个新的 Java 类 `simple`，该类以 `AbstractScript` 作为父类。
- en: The `simple` class is a Java version of our Ruby code that adds 2 + 2 and prints
    the sum. The `simple` Java class does the same thing using Java. Inside `simple`,
    JRuby creates a Java method called `__file__` that executes the `2+2` code as
    indicated with the inner `__file__` rectangle at the bottom of the figure. The
    method rectangle `<init>` is the constructor for the `simple` class.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`simple` 类是我们 Ruby 代码的 Java 版本，它执行 2 + 2 并打印总和。`simple` Java 类用 Java 完成了相同的操作。在
    `simple` 内部，JRuby 创建了一个名为 `__file__` 的 Java 方法，执行 `2+2` 的代码，正如图中底部的内部 `__file__`
    矩形所示。方法矩形 `<init>` 是 `simple` 类的构造函数。'
- en: '![JRuby converts your Ruby code into Java classes.](httpatomoreillycomsourcenostarchimages1854289.png.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![JRuby 将你的 Ruby 代码转换为 Java 类。](httpatomoreillycomsourcenostarchimages1854289.png.jpg)'
- en: Figure 10-6. JRuby converts your Ruby code into Java classes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-6. JRuby 将你的 Ruby 代码转换为 Java 类。
- en: At the right of [Figure 10-6](ch10.html#jruby_converts_your_ruby_code_into_java
    "Figure 10-6. JRuby converts your Ruby code into Java classes."), you see a small
    part of JRuby’s library of Ruby classes. These are Ruby’s built-in classes, such
    as `Fixnum`, `String`, and `Array`. MRI implements these classes using C. When
    your code calls a method from one of these classes, the method dispatch process
    uses the CFUNC method type. However, JRuby implements all of the built-in Ruby
    classes using Java code. On the right side of [Figure 10-6](ch10.html#jruby_converts_your_ruby_code_into_java
    "Figure 10-6. JRuby converts your Ruby code into Java classes."), you see two
    built-in Ruby methods that our code calls.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 10-6](ch10.html#jruby_converts_your_ruby_code_into_java "图 10-6. JRuby 将你的
    Ruby 代码转换为 Java 类")的右侧，你可以看到 JRuby 的 Ruby 类库的一个小部分。这些是 Ruby 的内建类，比如 `Fixnum`、`String`
    和 `Array`。MRI 使用 C 实现这些类。当你的代码调用这些类中的某个方法时，方法调度过程会使用 CFUNC 方法类型。然而，JRuby 使用 Java
    代码实现所有内建的 Ruby 类。在[图 10-6](ch10.html#jruby_converts_your_ruby_code_into_java "图
    10-6. JRuby 将你的 Ruby 代码转换为 Java 类")的右侧，你可以看到我们的代码调用的两个内建 Ruby 方法。
- en: First, your code adds 2 + 2, using the `+` method of the Ruby `Fixnum` class.
    JRuby implements the Ruby `Fixnum` class using a Java class called `RubyFixnum`.
    In this example, your code calls the `op_plus` Java method in this `RubyFixnum`
    class.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，你的代码执行 2 + 2，使用 Ruby `Fixnum` 类的 `+` 方法。JRuby 使用名为 `RubyFixnum` 的 Java 类实现
    Ruby `Fixnum` 类。在这个例子中，你的代码调用了 `RubyFixnum` 类中的 `op_plus` Java 方法。
- en: To print the sum, the code calls the `puts` method of the built-in Ruby `IO`
    class (actually via the `Kernel` module). JRuby implements this in a similar way,
    using a Java class called `RubyIO`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了打印总和，代码调用了内建 Ruby `IO` 类的`puts`方法（实际上是通过`Kernel`模块）。JRuby 以类似的方式实现这一点，使用一个名为
    `RubyIO` 的 Java 类。
- en: Implementing Ruby Classes with Java Classes
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Java 类实现 Ruby 类
- en: As you know, standard Ruby is implemented internally using C, which doesn’t
    support the notion of object-oriented programming. C code can’t use objects, classes,
    methods, or inheritance the way that Ruby code does.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知道的，标准 Ruby 是使用 C 内部实现的，C 不支持面向对象编程的概念。C 代码无法像 Ruby 代码那样使用对象、类、方法或继承。
- en: However, JRuby is implemented in Java, an object-oriented programming language.
    While not as flexible and powerful as Ruby itself, Java does support writing classes,
    creating objects as instances of those classes, and relating one class to another
    through inheritance, which means that JRuby’s implementation of Ruby is also object
    oriented.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JRuby 是用 Java 实现的，Java 是一种面向对象的编程语言。虽然 Java 不如 Ruby 本身那样灵活和强大，但它确实支持编写类、创建类的实例对象，并通过继承将一个类与另一个类关联起来，这意味着
    JRuby 对 Ruby 的实现也是面向对象的。
- en: JRuby implements Ruby objects with Java objects. To get a better idea of what
    this means, see [Figure 10-7](ch10.html#mri_implements_objects_and_classes_using
    "Figure 10-7. MRI implements objects and classes using C structures."), which
    compares Ruby code with MRI C structures.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: JRuby使用Java对象实现Ruby对象。为了更好地理解这意味着什么，请参见[图10-7](ch10.html#mri_implements_objects_and_classes_using
    "图10-7。MRI使用C结构实现对象和类。")，它将Ruby代码与MRI C结构进行了比较。
- en: '![MRI implements objects and classes using C structures.](httpatomoreillycomsourcenostarchimages1854291.png.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![MRI使用C结构实现对象和类。](httpatomoreillycomsourcenostarchimages1854291.png.jpg)'
- en: Figure 10-7. MRI implements objects and classes using C structures.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-7。MRI使用C结构实现对象和类。
- en: Internally Ruby creates an `RClass` C structure for each class and an `RObject`
    structure for each object. Ruby tracks the class for each object using the `klass`
    pointer in the `RObject` structure. [Figure 10-7](ch10.html#mri_implements_objects_and_classes_using
    "Figure 10-7. MRI implements objects and classes using C structures.") shows one
    `RClass` for the `Mathematician` class and one `RObject` for `pythagoras`, an
    instance of `Mathematician`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby在内部为每个类创建一个`RClass` C结构，为每个对象创建一个`RObject`结构。Ruby通过`RObject`结构中的`klass`指针追踪每个对象的类。[图10-7](ch10.html#mri_implements_objects_and_classes_using
    "图10-7。MRI使用C结构实现对象和类。")展示了一个`RClass`表示`Mathematician`类，一个`RObject`表示`pythagoras`，即`Mathematician`的一个实例。
- en: '[Figure 10-8](ch10.html#internallycomma_jruby_represents_objects "Figure 10-8. Internally,
    JRuby represents objects using the RubyObject Java class and classes using the
    RubyClass Java class.") shows that the situation is very similar in JRuby, at
    least at first glance.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-8](ch10.html#internallycomma_jruby_represents_objects "图10-8。内部，JRuby使用RubyObject
    Java类表示对象，使用RubyClass Java类表示类。")显示JRuby中的情况非常相似，至少在第一眼看上去是这样。'
- en: '![Internally, JRuby represents objects using the RubyObject Java class and
    classes using the RubyClass Java class.](httpatomoreillycomsourcenostarchimages1854293.png.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![在内部，JRuby使用RubyObject Java类表示对象，使用RubyClass Java类表示类。](httpatomoreillycomsourcenostarchimages1854293.png.jpg)'
- en: Figure 10-8. Internally, JRuby represents objects using the `RubyObject` Java
    class and classes using the `RubyClass` Java class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-8。 在内部，JRuby使用`RubyObject` Java类表示对象，使用`RubyClass` Java类表示类。
- en: On the left side of the figure, we see the same Ruby code. On the right are
    two Java objects, one an instance of the `RubyObject` Java class and the other
    an instance of the `RubyClass` Java class. JRuby’s implementation of Ruby objects
    and classes closely resembles MRI’s, but JRuby uses Java objects instead of using
    C structures. JRuby uses the names `RubyObject` and `RubyClass` because these
    Java objects represent your Ruby object and class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在图的左侧，我们看到相同的Ruby代码。右侧是两个Java对象，一个是`RubyObject` Java类的实例，另一个是`RubyClass` Java类的实例。JRuby对Ruby对象和类的实现与MRI非常相似，但JRuby使用Java对象而不是C结构。JRuby使用`RubyObject`和`RubyClass`这两个名称，因为这些Java对象代表了你的Ruby对象和类。
- en: But when we look a bit closer, things aren’t so straightforward. Because `RubyObject`
    is a Java class, JRuby can use inheritance to simplify its internal implementation.
    In fact, the superclass of `RubyObject` is `RubyBasicObject`. This reflects how
    the Ruby classes are related, as we can see by calling the `ancestors` method
    on `Object`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当我们更仔细地观察时，事情并不像看起来那么简单。由于`RubyObject`是一个Java类，JRuby可以利用继承来简化其内部实现。事实上，`RubyObject`的父类是`RubyBasicObject`。这反映了Ruby类之间的关系，正如我们通过调用`ancestors`方法查看`Object`时所看到的那样。
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Calling `ancestors` returns an array containing all the classes and modules
    in the superclass chain for the receiver. Here, we see that `Object`’s superclass
    is the `Kernel` module and its superclass is `BasicObject`. JRuby uses the same
    pattern for its internal Java class hierarchy, as shown in [Figure 10-9](ch10.html#rubybasicobject_is_the_superclass_of_the
    "Figure 10-9. RubyBasicObject is the superclass of the RubyObject Java class.").
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`ancestors`返回一个包含接收者所有父类链中类和模块的数组。这里，我们可以看到`Object`的父类是`Kernel`模块，而它的父类是`BasicObject`。JRuby对其内部Java类层次结构使用相同的模式，如[图10-9](ch10.html#rubybasicobject_is_the_superclass_of_the
    "图10-9。RubyBasicObject是RubyObject Java类的父类。")所示。
- en: '![RubyBasicObject is the superclass of the RubyObject Java class.](httpatomoreillycomsourcenostarchimages1854295.png.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![RubyBasicObject是RubyObject Java类的父类。](httpatomoreillycomsourcenostarchimages1854295.png.jpg)'
- en: Figure 10-9. `RubyBasicObject` is the superclass of the `RubyObject` Java class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-9。`RubyBasicObject`是`RubyObject` Java类的父类。
- en: The `Kernel` module aside, we can see that JRuby’s internal Java class hierarchy
    reflects the Ruby class hierarchy that it implements. This similarity is made
    possible by Java’s object-oriented design.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Kernel` 模块，我们可以看到 JRuby 的内部 Java 类层次结构反映了它实现的 Ruby 类层次结构。这种相似性得益于 Java 的面向对象设计。
- en: Now for a second example. Let’s use `ancestors` again to show the superclasses
    for the `Class` Ruby class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看第二个示例。让我们再次使用 `ancestors` 来展示 `Class` Ruby 类的超类。
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we see that the superclass of `Class` is `Module`, its superclass is `Object`,
    and so on. And as we would expect, JRuby’s Java code uses the same design internally
    (see [Figure 10-10](ch10.html#jrubyapostrophes_internal_java_class_hie "Figure 10-10. JRuby’s
    internal Java class hierarchy for RubyClass")).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到 `Class` 的超类是 `Module`，它的超类是 `Object`，依此类推。正如我们所预期的那样，JRuby 的 Java 代码在内部使用了相同的设计（参见
    [图 10-10](ch10.html#jrubyapostrophes_internal_java_class_hie "图 10-10. JRuby 的
    RubyClass 内部 Java 类层次结构")）。
- en: '![JRuby’s internal Java class hierarchy for RubyClass](httpatomoreillycomsourcenostarchimages1854297.png.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![JRuby 的 RubyClass 内部 Java 类层次结构](httpatomoreillycomsourcenostarchimages1854297.png.jpg)'
- en: Figure 10-10. JRuby’s internal Java class hierarchy for `RubyClass`
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-10. JRuby 的 `RubyClass` 内部 Java 类层次结构
- en: 'Experiment 10-1: Monitoring JRuby’s Just-in-Time Compiler'
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 10-1：监控 JRuby 的即时编译器
- en: I mentioned earlier that JRuby can speed up your Ruby code by using a JIT compiler.
    JRuby always translates your Ruby program into Java bytecode instructions, which
    the JVM can compile into machine language that your computer’s microprocessor
    can execute directly. In this experiment we’ll see when this happens and measure
    how much it speeds up your code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，JRuby 可以通过使用 JIT 编译器加速你的 Ruby 代码。JRuby 总是将你的 Ruby 程序转换为 Java 字节码指令，JVM
    可以将其编译为机器语言，直接由计算机的微处理器执行。在这个实验中，我们将看到何时发生这种情况，并测量它加速了多少代码。
- en: Experiment Code
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验代码
- en: '[Example 10-3](ch10.html#sample_program_for_testing_jrubyapostr "Example 10-3. A
    sample program for testing JRuby’s JIT behavior (jit.rb)") shows a Ruby program
    that prints out 10 random numbers between 1 and 100.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-3](ch10.html#sample_program_for_testing_jrubyapostr "示例 10-3. 测试 JRuby
    JIT 行为的示例程序 (jit.rb)") 展示了一个 Ruby 程序，它打印出 1 到 100 之间的 10 个随机数。'
- en: Example 10-3. A sample program for testing JRuby’s JIT behavior *(jit.rb)*
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-3. 测试 JRuby JIT 行为的示例程序 *(jit.rb)*
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) we create an
    array with 100 elements: 1 through 100\. Then, at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    we iterate over the following block 10 times. Inside this block, we use the `sample`
    method at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg) to pick a
    random value from the array and print it. When we run this code, we get the output
    shown in [Example 10-4](ch10.html#output_from_listing_10-3 "Example 10-4. The
    output from Example 10-3").'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 我们创建了一个包含 100 个元素的数组：从
    1 到 100。然后，在 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) 我们对以下代码块迭代
    10 次。在这个块内部，我们在 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg) 使用
    `sample` 方法随机选择数组中的一个值并打印。当我们运行这段代码时，得到的输出如 [示例 10-4](ch10.html#output_from_listing_10-3
    "示例 10-4. 来自示例 10-3 的输出") 所示。
- en: Example 10-4. The output from [Example 10-3](ch10.html#sample_program_for_testing_jrubyapostr
    "Example 10-3. A sample program for testing JRuby’s JIT behavior (jit.rb)")
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-4. 来自 [示例 10-3](ch10.html#sample_program_for_testing_jrubyapostr "示例 10-3.
    测试 JRuby JIT 行为的示例程序 (jit.rb)") 的输出
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now let’s remove the `puts` statement and increase the number of iterations.
    (Removing the output will make the experiment more manageable.) [Example 10-5](ch10.html#we_remove_puts_and_increase_the_number_o
    "Example 10-5. We remove puts and increase the number of iterations to 1,000.")
    shows the updated program.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们移除 `puts` 语句并增加迭代次数。（移除输出将使实验更易管理。）[示例 10-5](ch10.html#we_remove_puts_and_increase_the_number_o
    "示例 10-5. 我们移除 puts 并将迭代次数增加到 1,000.") 展示了更新后的程序。
- en: Example 10-5. We remove `puts` and increase the number of iterations to 1,000.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 10-5. 我们移除了 `puts` 并将迭代次数增加到 1,000。
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using the -J-XX:+PrintCompilation Option
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 -J-XX:+PrintCompilation 选项
- en: Of course, if we run the program now, we won’t see any output because we’ve
    removed `puts`. Let’s run the program again—this time using a debug flag (shown
    in [Example 10-6](ch10.html#output_generated_by_the_-j-xxpluspri "Example 10-6. The
    output generated by the -J-XX:+PrintCompilation option")) to display information
    about what the JVM’s JIT compiler is doing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们现在运行程序，我们不会看到任何输出，因为我们已经去除了`puts`。让我们再次运行程序——这次使用一个调试标志（如[示例10-6](ch10.html#output_generated_by_the_-j-xxpluspri
    "示例10-6. `-J-XX:+PrintCompilation`选项生成的输出")所示）来显示JVM的JIT编译器正在做什么。
- en: Example 10-6. The output generated by the `-J-XX:+PrintCompilation` option
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 示例10-6. `-J-XX:+PrintCompilation`选项生成的输出
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we use the `-J` option for JRuby and pass the `XX:+PrintCompilation` option
    to the underlying JVM application. `PrintCompilation` causes the JVM to display
    the information you see in [Example 10-6](ch10.html#output_generated_by_the_-j-xxpluspri
    "Example 10-6. The output generated by the -J-XX:+PrintCompilation option"). The
    line `java.lang.String::hashCode` means that the JVM compiled the `hashCode` method
    of the `String` Java class into machine language. The other values show technical
    information about the JIT process (`101` is a time stamp, `1` is a compilation
    ID, and `64 bytes` is the size of the bytecode snippet that was compiled).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为JRuby使用了`-J`选项，并将`XX:+PrintCompilation`选项传递给底层JVM应用程序。`PrintCompilation`使JVM显示你在[示例10-6](ch10.html#output_generated_by_the_-j-xxpluspri
    "示例10-6. `-J-XX:+PrintCompilation`选项生成的输出")中看到的信息。`java.lang.String::hashCode`这一行意味着JVM将`String`
    Java类的`hashCode`方法编译成了机器语言。其他值显示了关于JIT过程的技术信息（`101`是时间戳，`1`是编译ID，`64 bytes`是已编译字节码片段的大小）。
- en: The goal of this experiment is to validate the hypothesis that [Example 10-5](ch10.html#we_remove_puts_and_increase_the_number_o
    "Example 10-5. We remove puts and increase the number of iterations to 1,000.")
    should run faster once the JVM’s JIT compiler converts it into machine language.
    Notice that [Example 10-5](ch10.html#we_remove_puts_and_increase_the_number_o
    "Example 10-5. We remove puts and increase the number of iterations to 1,000.")
    has just one line of Ruby code inside the loop at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    that calls `array.sample`. Therefore, we should expect our Ruby program to finish
    noticeably faster once the JIT compiles JRuby’s implementation of `Array#sample`
    into machine language because `Array#sample` is called so many times.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实验的目标是验证假设，即[示例10-5](ch10.html#we_remove_puts_and_increase_the_number_o "示例10-5.
    我们去除了puts并将迭代次数增加到1,000.")应该会在JVM的JIT编译器将其转换为机器语言后运行得更快。注意，[示例10-5](ch10.html#we_remove_puts_and_increase_the_number_o
    "示例10-5. 我们去除了puts并将迭代次数增加到1,000.")在循环中只有一行Ruby代码，在![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)处调用了`array.sample`。因此，一旦JIT将JRuby实现的`Array#sample`编译成机器语言，我们应该会看到我们的Ruby程序明显更快地完成，因为`Array#sample`被调用了很多次。
- en: Because the output in [Example 10-6](ch10.html#output_generated_by_the_-j-xxpluspri
    "Example 10-6. The output generated by the -J-XX:+PrintCompilation option") is
    quite long and complex, we’ll use `grep` to search the output for occurrences
    of `org.jruby.RubyArray`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于[示例10-6](ch10.html#output_generated_by_the_-j-xxpluspri "示例10-6. `-J-XX:+PrintCompilation`选项生成的输出")中的输出非常长且复杂，我们将使用`grep`来搜索输出中`org.jruby.RubyArray`的出现情况。
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The result is no output. None of the lines in the `PrintCompilation` output
    match the name `org.jruby.RubyArray`, which means the JIT compiler is not converting
    the `Array#sample` method into machine language. It doesn’t do this conversion
    because the JVM only runs the JIT compiler to compile Java bytecode instructions
    that your program executes numerous times—areas of bytecode instructions known
    as *hot spots*. The JVM spends extra time compiling hot spots because they are
    called so many times. To prove this, we can increase the number of iterations
    to 100,000 and repeat our test, as shown in [Example 10-7](ch10.html#increasing_the_number_of_iterations_shou
    "Example 10-7. Increasing the number of iterations should trigger the JIT compiler
    to convert Array#sample to machine language.").
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 结果没有输出。在`PrintCompilation`输出中没有任何一行与名称`org.jruby.RubyArray`匹配，这意味着JIT编译器没有将`Array#sample`方法转换为机器语言。它之所以没有进行转换，是因为JVM仅在程序执行多次的Java字节码指令上运行JIT编译器——这些字节码指令被称为*热点*。JVM会花更多时间编译热点，因为它们被调用的次数非常多。为了验证这一点，我们可以将迭代次数增加到100,000并重复测试，正如在[示例10-7](ch10.html#increasing_the_number_of_iterations_shou
    "示例10-7. 增加迭代次数应该触发JIT编译器将Array#sample转换为机器语言。")中所示。
- en: Example 10-7. Increasing the number of iterations should trigger the JIT compiler
    to convert `Array#sample` to machine language.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When we repeat the same `jruby` command again with `grep`, we see the output
    shown in [Example 10-8](ch10.html#output_after_running_listing_10-7_wi "Example 10-8. The
    output after running Example 10-7 with -J-XX:+PrintCompilation piped to grep").
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-8. The output after running [Example 10-7](ch10.html#increasing_the_number_of_iterations_shou
    "Example 10-7. Increasing the number of iterations should trigger the JIT compiler
    to convert Array#sample to machine language.") with `-J-XX:+PrintCompilation`
    piped to `grep`
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Because we used `grep org.jruby.RubyArray` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg),
    we see only Java class names that match the text `org.jruby.RubyArray`. At ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    we can see that the JIT compiler compiled the `Array#sample` method because we
    see the text `org.jruby.RubyArray::sample`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Does JIT Speed Up Your JRuby Program?
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now to see if the JIT sped things up. Based on a command-line parameter—`ARGV[0]`—which
    I save in `iterations` at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg),
    [Example 10-9](ch10.html#sample_code_for_benchmarking_jit_perform "Example 10-9. Sample
    code for benchmarking JIT performance") measures the amount of time it takes to
    call `Array#sample` a given number of times.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-9. Sample code for benchmarking JIT performance
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By running this listing as shown below, we can measure how long it takes to
    execute the loop 100 times, for example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Figure 10-11](ch10.html#jruby_vsdot_mri_performancedot_time_is_s "Figure 10-11. JRuby
    vs. MRI performance. Time is shown in seconds vs. number of iterations (using
    JRuby 1.7.5 and Java 1.6; MRI Ruby 2.0).") shows the results for 100 to 100 million
    iterations using both JRuby and MRI.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![JRuby vs. MRI performance. Time is shown in seconds vs. number of iterations
    (using JRuby 1.7.5 and Java 1.6; MRI Ruby 2.0).](httpatomoreillycomsourcenostarchimages1854299.png.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Figure 10-11. JRuby vs. MRI performance. Time is shown in seconds vs. number
    of iterations (using JRuby 1.7.5 and Java 1.6; MRI Ruby 2.0).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The graph for MRI is more or less a straight line moving up to the right. This
    means it always takes Ruby 2.0 about the same amount of time to execute the `Array#sample`
    method. The results for JRuby, however, are not so simple. At left you can see
    that for fewer than 100,000 iterations, JRuby takes longer to execute [Example 10-9](ch10.html#sample_code_for_benchmarking_jit_perform
    "Example 10-9. Sample code for benchmarking JIT performance"). (The chart uses
    a logarithmic scale, so the absolute time differences on the left side are small.)
    However, once we reach about 1 million iterations, JRuby speeds up dramatically
    and starts to take less time to execute `Array#sample`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately for many, many iterations, JRuby is faster than MRI. But what’s important
    here is not simply that JRuby might be faster but that its performance characteristics
    vary. The longer your code runs, the longer the JVM has to optimize it, and the
    faster things will be.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Strings in JRuby and MRI
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve learned how JRuby executes bytecode instructions, passing control between
    your code and a library of Ruby objects implemented with Java. Now we’ll take
    a closer look at this library, specifically at how JRuby implements the `String`
    class. How do JRuby and MRI implement strings? Where do they save the string data
    you use in your Ruby code, and how do their implementations compare? Let’s begin
    to answer these questions by looking at how MRI implements strings.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: How JRuby and MRI Save String Data
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This code saves a famous quote from Pythagoras in a local variable. But where
    does this string go?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Recall from [Chapter 5](ch05.html "Chapter 5. Objects and Classes") that MRI
    uses different C structures to implement built-in classes, such as `RRegExp`,
    `RArray`, and `RHash`, as well as `RString`, which saves your strings. [Figure 10-12](ch10.html#part_of_the_rstring_c_structure
    "Figure 10-12. Part of the RString C structure") shows how MRI represents the
    `Geometry...` string internally.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![Part of the RString C structure](httpatomoreillycomsourcenostarchimages1854301.png.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: Figure 10-12. Part of the `RString` C structure
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that MRI saves the actual string data in a separate buffer, or section
    of memory, shown on the right. The `RString` structure itself contains a pointer
    to this buffer, `ptr`. Also notice that `RString` contains two other integer values:
    `len`, or the length of the string (48 in this example), and `capa`, or the capacity
    of the data buffer (also 48). The size of the data buffer can be longer than the
    string, in which case `capa` would be larger than `len`. (This would be the case
    if you executed code that reduced the length of the string.)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s consider JRuby. [Figure 10-13](ch10.html#jruby_uses_two_java_objects_and_a_data_b
    "Figure 10-13. JRuby uses two Java objects and a data buffer for each string.")
    shows how JRuby represents this string internally. JRuby uses the Java class `RubyString`
    to represent strings in your Ruby code, following the naming pattern we saw above
    with `RubyObject` and `RubyClass`. `RubyString` uses another class to track the
    actual string data: `ByteList`. This lower-level code tracks a separate data buffer
    (called `bytes`) similar to the way that the `RString` structure does so in MRI.
    `ByteList` also stores the length of the string in the `realSize` instance variable.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![JRuby uses two Java objects and a data buffer for each string.](httpatomoreillycomsourcenostarchimages1854303.png.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: Figure 10-13. JRuby uses two Java objects and a data buffer for each string.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Copy-on-Write
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Internally, both JRuby and MRI use an optimization called *copy-on-write* for
    strings and other data. This trick allows two identical string values to share
    the same data buffer, which saves both memory and time because Ruby avoids making
    separate copies of the same string data unnecessarily.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose we use the `dup` method to copy a string.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Does JRuby have to copy the `Geometry is...` text from one string object to
    another? No. [Figure 10-14](ch10.html#two_jruby_string_objects_can_share_the_s
    "Figure 10-14. Two JRuby string objects can share the same data buffer.") shows
    how JRuby shares the string data across two different string objects.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![Two JRuby string objects can share the same data buffer.](httpatomoreillycomsourcenostarchimages1854305.png.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: Figure 10-14. Two JRuby string objects can share the same data buffer.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: When we call `dup`, JRuby creates new `RubyString` and `ByteList` Java objects,
    but it doesn’t copy the actual string data. Instead, it sets the second `ByteList`
    object to point to the same data buffer used by the original string. Now we have
    two sets of Java objects but only one underlying string value, as shown on the
    right of the figure. Because strings can contain thousands of bytes or more, this
    optimization can often save a tremendous amount of memory.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: MRI uses the same trick, although in a slightly more complex way. [Figure 10-15](ch10.html#mri_shares_strings_by_creating_a_third_r
    "Figure 10-15. MRI shares strings by creating a third RString structure.") shows
    how standard Ruby shares strings.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![MRI shares strings by creating a third RString structure.](httpatomoreillycomsourcenostarchimages1854307.png.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: Figure 10-15. MRI shares strings by creating a third `RString` structure.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Like JRuby, MRI shares the underlying string data. However, when you copy a
    string in standard MRI Ruby, it creates a third `RString` structure and then sets
    both the original `RString` and new `RString` to refer to it using the `shared`
    pointer.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'In either case, we have a problem. What if we change one of the string variables?
    For example, suppose we convert one of the strings to uppercase as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: At ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) in both JRuby
    and MRI, we have two shared strings, but at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    I change the second string using the `upcase!` method. Now the two strings differ,
    which means that Ruby clearly can’t continue to share the underlying string buffer
    or `upcase!` would change both strings. We can see the strings are now different
    by displaying the string values.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At some point, Ruby must have separated these two strings, creating a new data
    buffer. This is what the phrase *copy-on-write* means: Both MRI and JRuby create
    a new copy of the string data buffer when you write to one of the strings.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Experiment 10-2: Measuring Copy-on-Write Performance'
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this experiment we’ll collect evidence that this extra copy operation really
    occurs when we write to a shared string. First, we’ll create a simple, nonshared
    string and write to it. Then we’ll create two shared strings and write to one
    of them. If copy-on-write really occurs, then writing to a shared string should
    take a bit longer because Ruby has to create a new copy of the string before writing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Unique, Nonshared String
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s begin by creating our example string again, `str`. Initially Ruby can’t
    possibly share `str` with anything else because there is only one string. We’ll
    use `str` for our baseline performance measurement.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: But as it turns out, Ruby shares `str` immediately! To see why, we’ll examine
    the YARV instructions that MRI uses to execute this code, as shown in [Example 10-10](ch10.html#mri_ruby_uses_a_dup_yarv_instruction_int
    "Example 10-10. MRI Ruby uses a dup YARV instruction internally when you use a
    literal string constant.").
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-10. MRI Ruby uses a `dup` YARV instruction internally when you use
    a literal string constant.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Reading the YARV instructions above carefully, we see at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    that Ruby puts the string onto the stack using `putstring`. This YARV instruction
    internally copies the string argument to the stack, creating a shared copy already.
    At ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg) Ruby uses `dup`
    to create yet another shared copy of the string to use as an argument for `setlocal`.
    Finally, at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg) `setlocal_OP__WC__0
    2` saves this string into the `str` variable, shown as `[2]` in the local table
    ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-16](ch10.html#executing_putstring_and_dup_creates_shar "Figure 10-16. Executing
    putstring and dup creates shared strings in MRI.") summarizes this process.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![Executing putstring and dup creates shared strings in MRI.](httpatomoreillycomsourcenostarchimages1854309.png.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: Figure 10-16. Executing `putstring` and `dup` creates shared strings in MRI.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: On the left are the YARV instructions `putstring`, `dup`, and `setlocal`. On
    the right are the `RString` structures that these instructions create, as well
    as the underlying shared string data. As I just mentioned, `putstring` in fact
    copies the string constant from a third `RString` left off the diagram, meaning
    the string is actually shared a third time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Ruby initially shares strings created from constant values, we need
    to create our string differently by concatenating two strings together as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The result of this concatenation will be a new, unique string. Ruby will not
    share its string data with any other string objects.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Experiment Code
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s take some measurements. [Example 10-11](ch10.html#measuring_a_delay_for_copy-on-write
    "Example 10-11. Measuring a delay for copy-on-write") shows the code for this
    experiment.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-11. Measuring a delay for copy-on-write
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Before we run this test, let’s walk through this code. At ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    we create a unique, unshared string by concatenating two strings. This is `str`.
    Then at ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) we create a
    second unshared string, `str2`. But at ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    we use `dup` to create a copy of this string, `str3`, and now `str2` and `str3`
    share the same value.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing Copy-on-Write
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg) in [Example 10-11](ch10.html#measuring_a_delay_for_copy-on-write
    "Example 10-11. Measuring a delay for copy-on-write") we change the fourth character
    in `str3` using the code `str3[3] = 'x'`. But here Ruby can’t change the character
    in `str3` without changing `str2` as well, as shown in [Figure 10-17](ch10.html#ruby_canapostrophet_change_str3_without
    "Figure 10-17. Ruby can’t change str3 without also changing str2.").
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby can’t change str3 without also changing str2.](httpatomoreillycomsourcenostarchimages1854311.png.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: Figure 10-17. Ruby can’t change `str3` without also changing `str2`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Ruby has to make a separate copy of `str3` first, as shown in [Figure 10-18](ch10.html#ruby_copies_the_string_into_a_new_buffer
    "Figure 10-18. Ruby copies the string into a new buffer for str3 before writing
    to it.").
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby copies the string into a new buffer for str3 before writing to it.](httpatomoreillycomsourcenostarchimages1854313.png.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: Figure 10-18. Ruby copies the string into a new buffer for `str3` before writing
    to it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Now Ruby can write into the new buffer for `str3` without affecting `str2`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Modifying a Shared String Is Slower
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we execute [Example 10-11](ch10.html#measuring_a_delay_for_copy-on-write
    "Example 10-11. Measuring a delay for copy-on-write"), the `benchmark` library
    measures how long it takes to run the inner block 1 million times. This block
    creates `str`, `str2`, and `str3` and then modifies `str3`. On my laptop, `benchmark`
    yields a measurement of about 1.87 seconds.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s change `str3[3] = 'x'` at ![](httpatomoreillycomsourcenostarchimages1853937.png.jpg)
    to modify `str` instead.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now we’re modifying the unshared, unique string instead of the shared string.
    Running the test again yields a result of about 1.69 seconds, or about 9.5 percent
    less than the time `benchmark` reported for the shared string. As expected, it
    takes slightly less time to modify a unique string than it does to modify a shared
    one.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The graph in [Figure 10-19](ch10.html#both_mri_and_jruby_show_a_delay_for_copy
    "Figure 10-19. Both MRI and JRuby show a delay for copy-on-write (seconds).")
    shows my cumulative results averaged over 10 different observations for both MRI
    and JRuby. On the left side of the graph are my average measurements for MRI.
    The bar on the far left represents the time required to modify the shared string,
    `str3`, and the right MRI bar shows how long it took to modify the unique string,
    `str`. The two bars on the right side exhibit the same pattern for JRuby, but
    the difference in the height of the bars is much less. Apparently, the JVM can
    make a new copy of the string faster than MRI.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'But there’s more: Notice that overall JRuby ran the experiment code in 60 percent
    less time. That is, it was 2.5 times faster than MRI! Just as in [Experiment 10-1:
    Monitoring JRuby’s Just-in-Time Compiler](ch10.html#experiment_10-1_monitoring_jrubyapostrop
    "Experiment 10-1: Monitoring JRuby’s Just-in-Time Compiler"), we must be seeing
    the JVM optimizations, such as JIT compilation, speed up JRuby when compared to
    MRI.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![Both MRI and JRuby show a delay for copy-on-write (seconds).](httpatomoreillycomsourcenostarchimages1854315.png.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: Figure 10-19. Both MRI and JRuby show a delay for copy-on-write (seconds).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we took a look at JRuby, a version of Ruby written in Java.
    We saw how the `jruby` command launches the JVM, passing *jruby.jar* as a parameter.
    We explored how JRuby parses and compiles our code, and learned in [Experiment
    10-1: Monitoring JRuby’s Just-in-Time Compiler](ch10.html#experiment_10-1_monitoring_jrubyapostrop
    "Experiment 10-1: Monitoring JRuby’s Just-in-Time Compiler") how the JVM can compile
    hot spots, or frequently executed snippets of Java bytecode, into machine language.
    Our results from [Experiment 10-1: Monitoring JRuby’s Just-in-Time Compiler](ch10.html#experiment_10-1_monitoring_jrubyapostrop
    "Experiment 10-1: Monitoring JRuby’s Just-in-Time Compiler") showed that compiling
    hot spots dramatically improves performance, allowing JRuby to run even faster
    than MRI in some cases.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second half of this chapter, we learned how MRI and JRuby represent
    our string data internally. We discovered that both versions of Ruby use copy-on-write
    optimization, sharing string data between different string objects when possible.
    Finally, in [Experiment 10-2: Measuring Copy-on-Write Performance](ch10.html#experiment_10-2_measuring_copy-on-write
    "Experiment 10-2: Measuring Copy-on-Write Performance") we proved that copy-on-write
    actually occurred in both JRuby and MRI.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'JRuby is a very powerful and clever implementation of Ruby: By running your
    Ruby code using the Java platform, you can benefit from the many years of research,
    development, tuning, and testing that have been invested in the JVM. The JVM is
    one of the most popular, mature, and powerful software platforms in use today.
    It’s being used not only by Java and JRuby but also by many other software languages,
    such as Clojure, Scala, and Jython, to name a few. By using this shared platform,
    JRuby can take advantage of the speed, robustness, and diversity of the Java platform—and
    it can do this for free!'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: JRuby is a groundbreaking piece of technology with which every Ruby developer
    should be familiar.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
