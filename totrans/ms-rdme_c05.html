<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
	<head>
		<title>Chapter 5: Managing Dependencies</title>
		<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:7db14923-61d0-434f-baa0-3e20bf74259e" name="Adept.expected.resource"/>
	</head>
	<body epub:type="bodymatter chapter">
		<section>
			<header>
				<h1 class="chapter"><span class="ChapterNumber"><span epub:type="pagebreak" id="Page_75" title="75"/>5</span><br/><span class="ChapterTitle">Managing Dependencies</span></h1>
			</header>
			<p class="BodyFirst"><span class="DropCap">I</span>n March 2016, thousands of JavaScript projects began failing to compile when a single package, <code>left-pad</code>, disappeared. The <code>left-pad</code> was a library with a single method that simply left-padded a string to a specific character width. Several foundational JavaScript libraries depended on <code>left-pad</code>. In turn, many projects depended on these libraries. Thanks to the viral nature of transitive dependencies, thousands and thousands of open source and commercial codebases had a critical dependency on this fairly trivial library. When the package was removed from NPM (JavaScript’s Node Package Manager), a lot of programmers had a rough day.</p>
			<p>
				Adding a dependency on existing code seems like a simple decision. Don’t repeat yourself (DRY) is a commonly taught principle. Why should we all write our own <code>left-pad</code>? Database drivers, application frameworks, machine learning packages—there are many examples of libraries you should not write from scratch. But dependencies bring risk: incompatible changes, circular dependencies, version conflicts, and lack of control. You must consider these risks and how to mitigate them.</p>
			<p>In this chapter, we cover the basics of dependency management and talk about every engineer’s nightmare: dependency hell.</p>
			<h2 id="h1-501836c05-0001"><span epub:type="pagebreak" id="Page_76" title="76"/>Dependency Management Basics</h2>
			<p class="BodyFirst">Before we can talk about problems and best practices, we must introduce you to common dependency and versioning concepts.</p>
			<p>
				A <em>dependency</em> is code that your code relies on. The time at which a dependency is needed—during compilation, testing, or runtime—is called its <em>scope</em>.</p>
			<p>
				Dependencies are declared in package management or build files: Java’s Gradle or Maven configs, Python’s <em>setup.py</em> or <em>requirements.txt</em>, and JavaScript’s NPM <em>package.json</em>. Here is a snippet of a Java project’s <em>build.gradle</em> file:</p>
			<pre><code>dependencies { compile 'org.apache.httpcomponents:httpclient:4.3.6' compile 'org.slf4j:slf4j-api:1.7.2'
}</code></pre>
			<p>
				The project depends on version 4.3.6 of an HTTP client library and version 1.7.2 of an SLF4J application programming interface (API) library. Each dependency is declared with a <code>compile</code> scope, meaning the dependencies are needed to compile the code. Each package has a version defined: 4.3.6 for <code>httpclient</code> and 1.7.2 for <code>slf4j</code>. Versioned packages are used to control when dependencies change and to resolve conflicts when different versions of the same package appear (more on this later).</p>
			<p>A good versioning scheme has versions that are</p>
			<ol class="none">
				<li><span class="RunInHead">Unique</span>  Versions should never be reused. Artifacts get distributed, cached, and pulled by automated workflows. Never republish changed code under an existing version.</li>
				<li><span class="RunInHead">Comparable</span>  Versions should help humans and tools reason about version precedence. <em>Precedence</em> is used to resolve conflicts when a build depends on multiple versions of the same artifact.</li>
				<li><span epub:type="pagebreak" id="Page_77" title="77"/><span class="RunInHead">Informative</span>  Versions differentiate between prereleased and released code, associate build numbers to artifacts, and set stability and compatibility expectations.</li>
			</ol>
			<p>Git hashes or “marketing-related” versions like Android OS’s dessert series (Android Cupcake, Android Froyo) or Ubuntu’s alliterative animals (Trusty Tahr, Disco Dingo) satisfy the uniqueness property, but they are not comparable or informative. Similarly, a monotonically increasing version number (1, 2, 3) is both unique and comparable, but not terribly informative.</p>
			<h3 id="h2-501836c05-0001">Semantic Versioning</h3>
			<p class="BodyFirst">The packages in the previous example use a versioning scheme called <em>semantic versioning</em> <em>(SemVer)</em>, one of the most commonly used versioning schemes. The official SemVer specification is available at <a class="LinkURL" href="https://semver.org/">https://semver.org/</a>. The spec defines three numbers: the major, minor, and patch version (sometimes called the <em>micro version</em>). Version numbers are combined into a single MAJOR.MINOR.PATCH version number. The <code>httpclient</code> version 4.3.6 has a major, minor, and patch of 4, 3, and 6, respectively.</p>
			<p>Semantic versions are unique, comparable, and informative. Each version number is used once and can be compared by going left to right (2.13.7 is before 2.14.1). They provide information about compatibility between different versions and can optionally encode release candidate or build number information.</p>
			<p>Major version 0, considered “prerelease,” is intended for fast iteration; no compatibility guarantees are made. Developers can change APIs in ways that break older code, like adding a new required parameter or deleting a public method. Starting with major version 1, a project is expected to guarantee the following:</p>
			<ul>
				<li>Patch versions are incremented for backward-compatible bug fixes.</li>
				<li>Minor versions are incremented for backward-compatible features.</li>
				<li>Major versions are incremented for backward-incompatible changes.</li>
			</ul>
			<p><span epub:type="pagebreak" id="Page_78" title="78"/>SemVer also defines prerelease versions by appending a <code>-</code> character after the patch version. Dot-separated alphanumeric sequences are used for prerelease identifiers (2.13.7-alpha.2). Prereleases can make breaking changes without bumping the major version. Many projects use <em>release candidate (RC)</em> builds. Early adopters can find bugs in RCs before the official release. RC prerelease versions have incremental identifiers, such as 3.0.0-rc.1. The final RC is then promoted to the release version by re-releasing it without an RC suffix. All prereleased versions are superseded by the final release (3.0.0 in our example). See Chapter 8 for more on release management mechanics.</p>
			<p>Build numbers are appended after both the version and prerelease metadata: 2.13.7-alpha.2+1942. Including a build number helps developers and tools find the build logs for any version that was compiled.</p>
			<p>
				SemVer’s scheme also allows for <em>wildcard</em> version ranges (2.13.*). Since SemVer promises compatibility across minor and patch versions, builds should continue to work even as updated versions with bug fixes and new features are automatically pulled in.</p>
			<h3 id="h2-501836c05-0002">Transitive Dependencies</h3>
			<p class="BodyFirst">Package management or build files show a project’s direct dependencies, but direct dependencies are only a subset of what build or packaging systems actually use. Dependencies usually depend on other libraries, which become <em>transitive dependencies</em>. A dependency report shows the fully resolved <em>dependency tree</em> (or <em>dependency graph</em>). Most build and packaging systems can produce dependency reports. Continuing the previous example, here’s the <code>gradle dependencies</code> output:</p>
			<pre><code>compile - Compile classpath for source set 'main'.
+--- org.apache.httpcomponents:httpclient:4.3.6
|    +--- org.apache.httpcomponents:httpcore:4.3.3
|    +--- commons-logging:commons-logging:1.1.3
|    \--- commons-codec:commons-codec:1.6
\--- org.slf4j:slf4j-api:1.7.2</code></pre>
			<p><span epub:type="pagebreak" id="Page_79" title="79"/>The dependency tree shows the dependencies that the build system is actually using when it compiles the project. The report is several layers deep. Dependencies of dependencies of dependencies get pulled in, and so on. The <code>httpclient</code> library pulls in three transitive dependencies: <code>httpcore</code>, <code>commons-logging</code>, and <code>commons-codec</code>. The project does not depend directly on these libraries, but through <code>httpclient</code>, it does.</p>
			<p>Understanding transitive dependencies is a critical part of dependency management. Adding a single dependency seems like a small change, but if that library depends on 100 others, your code now depends on 101 libraries. Any change in any dependency can affect your program. Make sure you know how to get information like the dependency tree in our examples so you can debug dependency conflicts.</p>
			<h2 id="h1-501836c05-0002">Dependency Hell</h2>
			<p class="BodyFirst">Ask any software engineer about dependency hell, and you’ll get a tale of woe. Conflicting versions of the same library, or an incompatible library upgrade, can break builds and cause runtime failures. The most common dependency hell culprits are circular dependencies, diamond dependencies, and version conflicts.</p>
			<p>The previous dependency report was simple. A more realistic report will show version conflicts, and give you a glimpse of dependency hell:</p>
			<pre><code>compile - Compile classpath for source set 'main'.
+--- com.google.code.findbugs:annotations:3.0.1
|    +--- net.jcip:jcip-annotations:1.0
|    \--- com.google.code.findbugs:jsr305:3.0.1
+--- org.apache.zookeeper:zookeeper:3.4.10
|    +--- org.slf4j:slf4j-api:1.6.1 -&gt; 1.7.21
|    +--- org.slf4j:slf4j-log4j12:1.6.1
|    +--- log4j:log4j:1.2.16
|    +--- jline:jline:0.9.94
|    \--- io.netty:netty:3.10.5.Final
\--- com.mycompany.util:util:1.4.2 \--- org.slf4j:slf4j-api:1.7.21</code></pre>
			<p><span epub:type="pagebreak" id="Page_80" title="80"/>This tree shows three direct dependencies: <code>annotations</code>, <code>zookeeper</code>, and <code>util</code>. The libraries all depend on other libraries; these are their transitive dependencies. Two versions of <code>slf4j-api</code> appear in the report. The <code>util</code> depends on <code>slf4j-api</code> version 1.7.21, but <code>zookeeper</code> depends on <code>slf4j-api</code> version 1.6.1.</p>
			<p>
				The dependencies form a <em>diamond dependency</em>, illustrated in <a href="#figure5-1" id="figureanchor5-1">Figure 5-1</a>.</p>
			<figure>
				<img alt="f05001" src="image_fi/501836c05/f05001.png"/>
				<figcaption>
					<p><a id="figure5-1">Figure 5-1</a>: A diamond dependency</p>
				</figcaption>
			</figure>
			<p>A project can’t use two library versions simultaneously, so the build system must pick one. In a Gradle dependency report, version choices are shown with annotations like so:</p>
			<pre><code>|    +--- org.slf4j:slf4j-api:1.6.1 -&gt; 1.7.21</code></pre>
			<p>
				The <code>1.6.1 -&gt; 1.7.21</code> means that <code>slf4j-api</code> was upgraded to 1.7.21 across the whole project to resolve the version conflict. Zookeeper might not work correctly with a different version of <code>slf4j-api</code>, especially since a related dependency, <code>slf4j-log4j12</code>, did not get upgraded. The upgrade <em>should</em> work, since Zookeeper dependency’s major version number remains unchanged (SemVer guarantees backward compatibility within the same major version). In reality, compatibility is aspirational. Projects often set version numbers without compatibility checks, and even automation can’t fully guarantee compatibility. <span epub:type="pagebreak" id="Page_81" title="81"/>Incompatible changes slip into minor or patch releases, wreaking havoc on your codebase.</p>
			<p>
				Even nastier are <em>circular dependencies</em> (or <em>cyclic dependencies</em>), where a library transitively depends on itself (A depends on B, which depends on C, which depends on A, shown in <a href="#figure5-2" id="figureanchor5-2">Figure 5-2</a>).</p>
			<figure>
				<img alt="f05002" src="image_fi/501836c05/f05002.png"/>
				<figcaption>
					<p><a id="figure5-2">Figure 5-2</a>: A circular dependency</p>
				</figcaption>
			</figure>
			<p>Circular dependencies create a chicken and egg problem: upgrading one library breaks the other. Utility or helper projects commonly appear in circular dependencies. For example, a natural language processing (NLP) library depends on a utility library for a string parsing function; unwittingly, another developer adds the NLP library as a utility dependency for a word-stemming utility method.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="box trade">
					<h2>The Curious Case of Google Collections</h2>
					<p class="BoxBodyFirst">Java libraries are packaged into JAR files. During runtime, Java will search all JARs on its classpath to locate classes. This works great until you have multiple JARs that contain different versions of the same class.</p>
					<p>
						LinkedIn had a tool called Azkaban, a workflow engine that let developers upload packages of code and schedule them to run on Hadoop. Azkaban was written in Java and didn’t isolate its classpath, meaning all the uploaded code would run with Azkaban’s dependencies in addition to their own. One day, jobs began to <span epub:type="pagebreak" id="Page_82" title="82"/>crash with <code>NoSuchMethodErrors</code>. Confusingly, Chris’s team could clearly see that the supposedly missing methods existed in the uploaded packages. There was a pattern to the errors: all the missing methods came from the popular Google <code>Guava</code> library.</p>
					<p><code>Guava</code> provides a number of useful features, including making Java’s notoriously clunky collection libraries easier to use. The team suspected that there were conflicts between Azkaban’s libraries and the packages that were uploaded. It wasn’t that simple, though: Azkaban didn’t use <code>Guava</code> at all. They eventually realized that <code>Guava</code> had evolved from another library, <code>google-collections</code>, which Azkaban was using. Azkaban pulled in <code>google-collections</code> for two classes, <code>ImmutableMap</code> and <code>ImmutableList</code>. Java was finding referenced classes in <code>google-collections</code> ahead of <code>Guava</code> and trying to call methods that didn’t exist in the earlier version of the library.</p>
					<p>
						The team eventually isolated the classpaths, and Azkaban stopped adding its JARs to the runtime. This mostly fixed the issue, but some jobs continued to fail. They then discovered that packages that were still having problems contained both <code>google-collections</code> and <code>Guava</code>. The build system couldn’t tell that <code>google-collections</code> was an older version of <code>Guava</code>, so it included both libraries, causing the same problem as the Azkaban dependency. A lot of careful refactoring had to happen, diverting many engineers from their normal work. Is all of this worth it for some collection helper methods?</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<h2 id="h1-501836c05-0003">Avoiding Dependency Hell</h2>
			<p class="BodyFirst">You will absolutely stumble into dependency hell. Dependencies are unavoidable, but every new dependency comes with a cost. Ask yourself if a dependency’s value outweighs its cost.</p>
			<ul>
				<li>Do you really need the functionality?</li>
				<li>How well maintained is the dependency?</li>
				<li><span epub:type="pagebreak" id="Page_83" title="83"/>How easy would it be for you to fix the dependency if something went wrong?</li>
				<li>How mature is the dependency?</li>
				<li>How frequently does the dependency introduce backward-incompatible changes?</li>
				<li>How well do you, your team, and your organization understand the dependency?</li>
				<li>How easy is it to write the code yourself?</li>
				<li>How is the code licensed?</li>
				<li>What is the ratio of code you use versus code you don’t use in the dependency?</li>
			</ul>
			<p>When you do decide to add dependencies, use the following best practices.</p>
			<h3 id="h2-501836c05-0003">Isolate Dependencies</h3>
			<p class="BodyFirst">You don’t have to leave dependency management to build and package systems. Dependent code can also be copied, vendored, or shaded. Copying code into your project trades dependency management automation for more isolation (stability). You’ll be able to pick and choose exactly what code you use, but you’ll have to manage the code copying.</p>
			<p>Many developers are raised on the DRY philosophy, which discourages code duplication. Be pragmatic; don’t be afraid to copy code if it helps you avoid a big or unstable dependency (and the software license allows it).</p>
			<p>
				Copying code works best on small, stable code fragments. Manually copying entire libraries has drawbacks: version history can be lost, and you must recopy code every time you update it. <em>Vendor</em> code using vendor tools to manage history and updates when embedding entire libraries in your codebase. Vendor folders contain complete library copies. Tools like <span epub:type="pagebreak" id="Page_84" title="84"/>git-subtree and <code>git-vendor</code> help manage vendor folders in your codebase. Some packaging systems, like Go, even have built-in support for vendor folders.</p>
			<p>
				Dependency <em>shading</em> can also isolate dependencies. Shading automatically relocates a dependency into a different namespace to avoid conflicts: <code>some.package.space</code> becomes <code>shaded.some.package.space</code>. This is a friendly way to keep libraries from forcing their dependencies on applications. Shading comes from the Java ecosystem, but the concept applies broadly. Other languages like Rust use similar techniques.</p>
			<p>
				Shading is an advanced technique and should be used sparingly. Never expose a shaded dependency’s objects in public APIs; doing so means developers will have to create objects in the shaded package space (<code>shaded.some.package.space.Class</code>). Shading is meant to hide a dependency’s existence; creating an object that’s been shaded is tricky, and sometimes impossible, for library users. Also, beware that shaded dependencies can confuse developers since package names differ in the build artifact. We recommend only shading dependencies when you are creating a library with widely used dependencies that are likely to create conflicts.</p>
			<h3 id="h2-501836c05-0004">Deliberately Add Dependencies</h3>
			<p class="BodyFirst">Explicitly declare as dependencies all libraries you use. Don’t use methods and classes from transitive dependencies, even if it seems to work. Libraries are free to change their dependencies even in patch-level version bumps. Your code will stop working if a transitive dependency that you depend on gets dropped during an upgrade.</p>
			<p>
				A project that depends only on the <code>httpclient</code> library (from the earlier example) should not explicitly use classes in <code>httpcore</code>, <code>commons-logging</code>, and <code>commons-codec</code> (<code>httpclient</code>’s dependencies); if it does, it should declare a direct dependency on the libraries.</p>
			<p>
				Don’t rely solely on the IDE for dependency management. Declare your dependencies explicitly in build files. IDEs often store dependencies <span epub:type="pagebreak" id="Page_85" title="85"/>in their own project configurations, which build machinery doesn’t look at. Inconsistency between your IDE and build files will make code work in the IDE but not when actually building your code, or vice versa.</p>
			<h3 id="h2-501836c05-0005">Pin Versions</h3>
			<p class="BodyFirst">Explicitly set every dependency’s version number, a practice called <em>version pinning</em>. Unpinned versions will be decided by the build or package management system for you. Leaving your fate to the build system is a bad idea. Your code will destabilize when dependency versions change during consecutive builds.</p>
			<p>The following code snippet declares a list of Go library dependencies with pinned versions:</p>
			<pre><code>require ( github.com/bgentry/speakeasy v0.1.0 github.com/cockroachdb/datadriven v0.0.0-20190809214429-80d97fb3cbaa github.com/coreos/go-semver v0.2.0 github.com/coreos/go-systemd v0.0.0-20180511133405-39ca1b05acc7 github.com/coreos/pkg v0.0.0-20160727233714-3ac0863d7acf ...
)</code></pre>
			<p>For contrast, this snippet of Apache Airflow’s dependencies uses three different version management strategies:</p>
			<pre><code>flask_oauth = [ 'Flask-OAuthlib&gt;=0.9.1', 'oauthlib!=2.0.3,!=2.0.4,!=2.0.5,&lt;3.0.0,&gt;=1.1.2', 'requests-oauthlib==1.1.0'
]</code></pre>
			<p>
				The <code>requests-oauthlib</code> library is explicitly pinned to 1.1.0. The <code>Flask-OAuthlib</code> dependency is set to any version greater than or equal to 0.9.1. And the <code>oauthlib</code> library is extremely specific: 1.1.2 or newer, but not above 3.0.0, but also not 2.0.3, 2.0.4, or 2.0.5. Versions 2.0.3 to 2.0.5 are excluded due to known bugs or incompatibilities.</p>
			<p><span epub:type="pagebreak" id="Page_86" title="86"/>Bounding the version range is a compromise between an unbounded range and a fully pinned version. The dependency resolution system is free to resolve conflicts and update dependencies, but exposure to breaking changes is limited. But any unpinned versions will pull in more than the latest bug fixes; they’ll pull in the latest bugs, behavior, or even incompatible changes.</p>
			<p>
				Even if you pin your direct dependencies, transitive dependencies might still have wildcards. Transitive dependency versions can be pinned by generating a complete manifest of all resolved dependencies and their versions. Dependency manifests go by many names: you freeze requirements in Python, generate <em>Gemfile.lock</em>s in Ruby, and create <em>Cargo.lock</em>s in Rust. Build systems use manifests to produce identical results on every execution. Manifests are regenerated explicitly by developers when they want to change a version. Committing manifests alongside the rest of your code allows you to explicitly track changes to any of the dependencies, giving you the opportunity to prevent potential problems.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="box trade">
					<h2>Why Airflow’s flask_oauth Is So Messy</h2>
					<p class="BoxBodyFirst">The elaborate dependency in the previous code block is trying to fix a dependency problem inherited by Airflow from the <code>Flask-</code><code>OAuthlib</code> library. <code>Flask-</code><code>OAuthlib</code> had its own unbounded dependencies on <code>oauthlib</code> and <code>requests-</code><code>oauthlib</code>, which started causing problems. The <code>Flask-</code><code>OAuthlib</code> developers introduced bounded ranges to their <code>oauthlib</code> and <code>requests-</code><code>oauthlib</code> dependencies to address this, but it took them a while to release the fix. In the meantime, Airflow broke and couldn’t wait for the <code>Flask-</code><code>OAuthlib</code> release. Airflow copy-pasted the <code>Flask-</code><code>OAuthlib</code> dependency block as a temporary fix. The change was accompanied by the comment “we can unpin these once a new release of <code>Flask-</code><code>OAuthlib</code> is released that includes these changes.” Eighteen months later, this change has still not been reverted. This is the sort of skulduggery one has to resort to when fixing dependency issues.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<h3 id="h2-501836c05-0006"><span epub:type="pagebreak" id="Page_87" title="87"/>Scope Dependencies Narrowly</h3>
			<p class="BodyFirst">Dependency scope, discussed earlier, defines when in the build lifecycle a dependency is used. Scoping has a hierarchy: compile-time dependencies are used during runtime, but runtime dependencies are not used to compile code, only to run it. Test dependencies are only pulled in for test execution and are not necessary for normal use of the published code.</p>
			<p>Use the narrowest possible scope for each dependency. Declaring all dependencies with compile-time scoping will work but is bad practice. Narrow scoping will help avoid conflicts and reduce runtime binary sizes.</p>
			<h3 id="h2-501836c05-0007">Protect Yourself from Circular Dependencies</h3>
			<p class="BodyFirst">Never introduce circular dependencies. Circular dependencies lead to strange build system behavior and deployment ordering problems. Builds will appear to work and then fail suddenly, and applications will have elusive and sporadic bugs.</p>
			<p>Protect yourself using build tools. Many build systems have built-in circular dependency detectors that will alert you when a cycle is detected. If your build system doesn’t protect against circular dependencies, there are usually plug-ins that can help.</p>
			<h2 id="h1-501836c05-0004">Do’s and Don’ts</h2>
			<table border="1" class="trade" id="tabular-501836c05-0001">
				<thead>
					<tr>
						<td><b>Do’s</b></td>
						<td><b>Don’ts</b></td>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td><b>DO</b> use semantic versioning.<br/></td>
						<td><b>DON’T</b> use Git hashes as version numbers.<br/></td>
					</tr>
					<tr>
						<td><b>DO</b> pin dependency version ranges.<br/></td>
						<td><b>DON’T</b> add dependencies unless the value exceeds the cost.<br/></td>
					</tr>
					<tr>
						<td><b>DO</b> use dependency report tools for transitive dependencies.<br/></td>
						<td><b>DON’T</b> use transitive dependencies directly.<br/></td>
					</tr>
					<tr>
						<td><b>DO</b> be skeptical when adding new dependencies.<br/></td>
						<td><b>DON’T</b> introduce circular dependencies.<br/></td>
					</tr>
					<tr>
						<td><b>DO</b> scope your dependencies.<br/></td>
						<td/>
					</tr>
				</tbody>
			</table>
			<h2 id="h1-501836c05-0005"><span epub:type="pagebreak" id="Page_88" title="88"/>Level Up</h2>
			<p class="BodyFirst">The problem of dependency conflicts and incompatible changes is pervasive; the general term for it is <em>dependency hell</em> (and many ecosystems have their own versions—DLL hell, JAR hell, “Any time I have to touch pip”). Though dependency management is complex, there are not many books on the subject; ecosystem-specific discussions and explanations are plentiful online. For a historical perspective, take a look at the Wikipedia article on dependency hell and the references therein.</p>
			<p>
				See <a class="LinkURL" href="https://semver.org/">https://semver.org/</a> for a compact and readable spec on semantic versioning. Python has a similar scheme, defined at <a class="LinkURL" href="https://www.python.org/dev/peps/pep-0440/">https://www.python.org/dev/peps/pep-0440/</a>. Both of these versioning schemes are in heavy use and worth learning. There are many others, and it’s not uncommon to encounter artifacts using different versioning schemes within the same project. Following the Pareto principle, we don’t recommend you dig into version semantics too deep when you are starting out unless it’s an explicit part of your job or you need more information to solve a concrete problem. The contents of this chapter should be sufficient for most day-to-day activities.</p>
			<p>Many of the versioning concepts in this chapter apply to both libraries and service APIs. We talk more about API versioning in Chapter 11.</p>
		</section>
	</body>
</html>