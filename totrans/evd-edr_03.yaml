- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp> <samp class="SANS_Dogma_OT_Bold_B_11">PROCESS-
    AND THREAD-CREATION NOTIFICATIONS</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
- en: Most modern EDR solutions rely heavily on functionality supplied through their
    *kernel-mode driver*, which is the sensor component running in a privileged layer
    of the operating system, beneath the user mode. These drivers give developers
    the ability to leverage features that are only available inside the kernel, supplying
    EDRs with many of their preventive features and telemetry.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: While vendors can implement a vast number of security-relevant features in their
    drivers, the most common one is *notification callback routines*. These are internal
    routines that take actions when a designated system event occurs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next three chapters, we’ll discuss how modern EDRs leverage notification
    callback routines to gain valuable insight into system events from the kernel.
    We’ll also cover the evasion techniques relevant to each type of notification
    and its related callback routines. This chapter focuses on two types of callback
    routines used very often in EDRs: those related to process creation and thread
    creation.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Notification Callback Routines Work</samp>
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most powerful features of drivers in the context of EDRs is the ability
    to be notified when a system event occurs. These system events might include creating
    or terminating new processes and threads, requesting to duplicate processes and
    threads, loading images, taking actions in the registry, or requesting a shutdown
    of the system. For example, a developer may want to know whether a process attempts
    to open a new handle to *lsass.exe*, because this is a core component of most
    credential-dumping techniques.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: To do this, the driver registers callback routines, which essentially just say,
    “Let me know if this type of event occurs on the system so I can do something.”
    As a result of these notifications, the driver can take action. Sometimes it might
    simply collect telemetry from the event notification. Alternatively, it might
    opt to do something like provide only partial access to the sensitive process,
    such as by returning a handle with a limited-access mask (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_QUERY_LIMITED_INFORMATION</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_ALL_ACCESS</samp>).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Callback routines may be either *pre-operation*, occurring before the event
    completes, or *post-operation*, occurring after the operation. Pre-operation callbacks
    are more common in EDRs, as they give the driver the ability to interfere with
    the event or prevent it from completing, as well as other side benefits that we’ll
    discuss in this chapter. Post-operation callbacks are useful too, as they can
    provide information about the result of the system event, but they have some drawbacks.
    The largest of these is the fact that they’re often executed in an arbitrary thread
    context, making it difficult for an EDR to collect information about the process
    or thread that started the operation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Process Notifications</samp>
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Callback routines can notify drivers whenever a process is created or terminated
    on the system. These notifications happen as an integral part of the process creation
    or termination. You can see this in [Listing 3-1](#list3-1), which shows the call
    stack for creation of a child process of *cmd.exe*, *notepad.exe*, that led to
    the notification of registered callback routines.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: To obtain this call stack, use WinDbg to set a breakpoint (<samp class="SANS_TheSansMonoCd_W5Regular_11">bp</samp>)
    on <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PspCallProcessNotifyRoutines()</samp>,
    the internal kernel function that notifies drivers with registered callbacks of
    process-creation events. When the breakpoint is hit, the <samp class="SANS_TheSansMonoCd_W5Regular_11">k</samp>
    command returns the call stack for the process under which the break occurred.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 3-1: A process-creation call stack'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a user wants to run an executable, *cmd.exe* calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">cmd!ExecPgm()</samp>
    function. In this call stack, we can see this function calling the stub used to
    create a new process (at output line 07). This stub ends up making the syscall
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateUserProcess()</samp>,
    where control is transitioned to the kernel (at 04).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Now notice that, inside the kernel, another function is executed (at 00). This
    function is responsible for letting every registered callback know that a process
    is being created.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Registering a Process
    Callback Routine</samp>
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To register process callback routines, EDRs use one of the following two functions:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsSetCreateProcessNotifyRoutineEx()</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsSetCreateProcessNotifyRoutineEx2()</samp>.
    The latter can provide notifications about non-Win32 subsystem processes. These
    functions take a pointer to a callback function that will perform some action
    whenever a new process is created or terminated. [Listing 3-2](#list3-2) demonstrates
    how a callback function is registered.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 3-2: Registering a process-creation callback routine'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: This code registers the callback routine ❶ and passes three arguments to the
    registration function. The first, <samp class="SANS_TheSansMonoCd_W5Regular_11">PsCreateProcessNotifySubsystems</samp>,
    indicates the type of process notification that is being registered. At the time
    of this writing, “subsystems” is the only type that Microsoft documents. This
    value tells the system that the callback routine should be invoked for processes
    created across all subsystems, including Win32 and Windows Subsystem for Linux
    (WSL).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码注册回调例程❶并将三个参数传递给注册函数。第一个参数<samp class="SANS_TheSansMonoCd_W5Regular_11">PsCreateProcessNotifySubsystems</samp>指示正在注册的进程通知类型。在本文写作时，“子系统”是微软文档中唯一提到的类型。这个值告诉系统，回调例程应在所有子系统中创建的进程时被调用，包括Win32和Windows子系统Linux（WSL）。
- en: The next argument defines the entry point of the callback routine to be executed
    when the process is created. In our example, the code points to the internal <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ProcessNotifyCallbackRoutine()</samp>
    function. When process creation occurs, this callback function will receive information
    about the event, which we’ll discuss momentarily.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个参数定义了回调例程的入口点，该例程将在进程创建时执行。在我们的示例中，代码指向内部的<samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessNotifyCallbackRoutine()</samp>函数。当进程创建发生时，回调函数将接收有关该事件的信息，我们稍后将讨论这一点。
- en: The third argument is a Boolean value indicating whether the callback routine
    should be removed. Because we’re registering the routine in this example, the
    value is <samp class="SANS_TheSansMonoCd_W5Regular_11">FALSE</samp>. When we unload
    the driver, we’d set this to <samp class="SANS_TheSansMonoCd_W5Regular_11">TRUE</samp>
    to remove the callback from the system. After registering the callback routine,
    we define the callback function itself ❷.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是一个布尔值，表示是否应该移除回调例程。由于我们在这个示例中注册了回调例程，因此该值为<samp class="SANS_TheSansMonoCd_W5Regular_11">FALSE</samp>。当我们卸载驱动程序时，我们将其设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TRUE</samp>，以从系统中移除回调。注册回调例程后，我们定义回调函数本身❷。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Viewing the Callback
    Routines Registered on a System</samp>
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">查看系统上注册的回调例程</samp>
- en: You can use WinDbg to see a list of the process callback routines on your system.
    When a new callback routine is registered, a pointer to the routine is added to
    an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">EX_FAST_REF</samp> structures,
    which are 16-byte aligned pointers stored in an array at <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PspCreateProcessNotifyRoutine</samp>,
    as shown in [Listing 3-3](#list3-3).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用WinDbg查看系统上进程回调例程的列表。当注册一个新的回调例程时，一个指向该例程的指针会被添加到一个<samp class="SANS_TheSansMonoCd_W5Regular_11">EX_FAST_REF</samp>结构体数组中，这些结构体是16字节对齐的指针，存储在位于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nt!PspCreateProcessNotifyRoutine</samp>的位置，如[清单
    3-3](#list3-3)所示。
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 3-3: An array of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EX_FAST_REF</samp>
    structures containing the addresses of process- creation callback routines'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-3：一个包含进程创建回调例程地址的<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EX_FAST_REF</samp>结构体数组
- en: '[Listing 3-4](#list3-4) shows a way of iterating over this array of <samp class="SANS_TheSansMonoCd_W5Regular_11">EX_FAST_REF</samp>
    structures to enumerate drivers that implement process-notification callbacks.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-4](#list3-4)展示了遍历这个<samp class="SANS_TheSansMonoCd_W5Regular_11">EX_FAST_REF</samp>结构体数组的方法，以枚举实现进程通知回调的驱动程序。'
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 3-4: Enumerating registered process-creation callbacks'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-4：枚举已注册的进程创建回调
- en: 'Here, we can see some of the routines registered on a default system. Note
    that some of these callbacks do not perform security functions. For instance,
    the one beginning with <samp class="SANS_TheSansMonoCd_W5Regular_11">tcpip</samp>
    is used in the TCP/IP driver. However, we do see that Microsoft Defender has a
    callback registered: <samp class="SANS_TheSansMonoCd_W5Regular_11">WdFilter</samp>+<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x45e00</samp>. (Microsoft doesn’t publish
    full symbols for the *WdFilter.sys* driver.) Using this technique, we could locate
    an EDR’s callback routine without needing to reverse engineer Microsoft’s driver.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Collecting Information
    from Process Creation</samp>
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once an EDR registers its callback routine, how does it access information?
    Well, when a new process is created, a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_CREATE_NOTIFY_INFO</samp>
    structure is passed to the callback. You can see the structure defined in [Listing
    3-5](#list3-5).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 3-5: The definition of the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PS_CREATE_NOTIFY_INFO</samp>
    structure'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'This structure contains a significant amount of valuable data relating to process-creation
    events on the system. This data includes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ParentProcessId</samp>   The parent
    process of the newly created process. This isn’t necessarily the one that created
    the new process.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CreatingThreadId</samp>   Handles
    to the unique thread and process responsible for creating the new process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FileObject</samp>   A pointer to
    the process’s executable file object (the image on disk).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ImageFileName</samp>   A pointer
    to a string containing the path to the newly created process’s executable file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">CommandLine</samp>   The command
    line arguments passed to the creating process.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">FileOpenNameAvailable</samp>   A
    value that specifies whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp>
    member matches the filename used to open the new process’s executable file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: One way that EDRs commonly interact with the telemetry returned from this notification
    is through Sysmon’s Event ID 1, the event for process creation, shown in [Figure
    3-1](#fig3-1).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-1.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: Sysmon Event ID
    1 showing process creation</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: In this event, we can see some of the information from the <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_CREATE
    _NOTIFY_INFO</samp> structure passed to Sysmon’s callback routine. For example,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Image</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLine</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentProcessId</samp> properties
    in the event translate to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLine</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentProcessId</samp>
    members of the structure, respectively.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why there are so many more properties in this event than
    there are in the structure received by the callback. The driver collects these
    supplemental pieces of information by investigating the context of the thread
    under which the event was generated and expanding on members of the structure.
    For instance, if we know the ID of the process’s parent, we can easily find the
    parent’s image path to populate the <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentImage</samp>
    property.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging the data collected from this event and the associated structure,
    EDRs can also create internal mappings of process attributes and relationships
    in order to detect suspicious activity, such as Microsoft Word spawning a *powershell.exe*
    child. This data could also provide the agent with useful context for determining
    whether other activity is malicious. For example, the agent could feed process
    command line arguments into a machine learning model to figure out whether the
    command’s invocation is unusual in the environment.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Thread Notifications</samp>
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thread-creation notifications are somewhat less valuable than process-creation
    events. They work relatively similarly, occurring during the creation process,
    but they receive less information. This is true despite the fact that thread creation
    happens substantially more often; after all, nearly every process supports multithreading,
    meaning that there will be more than one thread-creation notification for every
    process creation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Although thread-creation callbacks pass far less data to the callback, they
    do provide the EDR with another datapoint against which detections can be built.
    Let’s explore them a little further.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Registering a Thread
    Callback Routine</samp>
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a thread is created or terminated, the callback routine receives three
    pieces of data: the ID of the process to which the thread belongs, the unique
    thread ID, and a Boolean value indicating whether the thread is being created.
    [Listing 3-6](#list3-6) shows how a driver would register a callback routine for
    thread-creation events.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 3-6: Registration of a thread-creation notification routine'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: As with process creation, an EDR can receive notifications about thread creation
    or termination via its driver by registering a thread-notification callback routine
    with either <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsSetCreateThreadNotifyRoutine()</samp>
    or the extended <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsSetCreateThreadNotifyRoutineEx()</samp>,
    which adds the ability to define the notification type.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: This example driver first registers the callback routine ❶, passing in a pointer
    to the internal callback function, which receives the same three pieces of data
    passed to process callback routines. If the Boolean indicating whether the thread
    is being created or terminated is <samp class="SANS_TheSansMonoCd_W5Regular_11">TRUE</samp>,
    the driver performs some action defined by the developer ❷. Otherwise, the callback
    would simply ignore the thread events, as thread-termination events (which occur
    when a thread completes its execution and returns) are generally less valuable
    for security monitoring.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Detecting Remote
    Thread Creation</samp>
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Despite providing less information than process-creation callbacks, thread-creation
    notifications offer the EDR data about something other callbacks can’t detect:
    remote thread creation. *Remote thread creation* occurs when one process creates
    a thread inside another process. This technique is core to a ton of attacker tradecraft,
    which often relies on changing the execution context (as in going from user 1
    to user 2). [Listing 3-7](#list3-7) shows how an EDR could detect this behavior
    with its thread-creation callback routine.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 3-7: Detecting remote thread creation'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the notification executes in the context of the process creating the
    thread, developers can simply check whether the current process ID matches the
    one passed to the callback routine ❶. If not, the thread is being created remotely
    and should be investigated. That’s it: a huge capability, provided through one
    or two lines of code. It doesn’t get much better than that. You can see this feature
    implemented in real life through Sysmon’s Event ID 8, shown in [Figure 3-2](#fig3-2).
    Notice that the <samp class="SANS_TheSansMonoCd_W5Regular_11">SourceProcessId</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetProcessId</samp> values
    differ.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-2.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: Sysmon Event ID
    8 detecting remote thread creation</samp>'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Of course, remote thread creation happens under a number of legitimate circumstances.
    One example is child process creation. When a process is created, the first thread
    executes in the context of the parent process. To account for this, many EDRs
    simply disregard the first thread associated with a process.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Certain internal operating system components also perform legitimate remote
    thread creation. An example of this is Windows Error Reporting (*werfault.exe*).
    When an error has occurred on the system, the operating system spawns *werfault.exe*
    as a child of *svchost.exe* (specifically, the *WerSvc* service) and then injects
    into the faulting process.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the fact that a thread was created remotely doesn’t automatically make
    it malicious. To determine this, the EDR has to collect supplemental information,
    as shown in Sysmon Event ID 8.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evading Process- and Thread-Creation
    Callbacks</samp>
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Process and thread notifications have the most associated detections of all
    callback types. This is partly due to the fact that the information they provide
    is critical to most process-oriented detection strategies and is used by almost
    every commercial EDR product. They’re also generally the easiest to understand.
    This isn’t to say that they’re also easy to evade. However, there is no shortage
    of procedures we can follow to increase our chances of slipping through the cracks
    somewhere.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Command Line Tampering</samp>
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of the most commonly monitored attributes of process-creation events are
    the command line arguments with which the process was invoked. Certain detection
    strategies are even built entirely around specific command line arguments associated
    with a known offensive tool or piece of malware.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: EDRs can find arguments in the <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLine</samp>
    member of the structure passed to a process-creation callback routine. When a
    process is created, its command line arguments are stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp>
    field of its process environment block (PEB). This field contains a pointer to
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">RTL_USER_PROCESS_PARAMETERS</samp>
    structure that contains, among other things, a <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp>
    with the parameters passed to the process at invocation. [Listing 3-8](#list3-8)
    shows how we could manually retrieve a process’s command line arguments with WinDbg.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 3-8: Retrieving parameters from the PEB with WinDbg'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we extract the parameters from the current process’s PEB by
    directly accessing the buffer member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp>,
    which makes up the <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLine</samp>
    member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp>
    field.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: However, because the PEB resides in the process’s user-mode memory space and
    not in the kernel, a process can change attributes of its own PEB. Adam Chester’s
    “How to Argue like Cobalt Strike” blog post details how to modify the command
    line arguments for a process. Before we cover this technique, you should understand
    what it looks like when a normal program creates a child process. [Listing 3-9](#list3-9)
    contains a simple example of this behavior.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 3-9: Typical child-process creation'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: This basic implementation spawns a child process of *cmd.exe* with the arguments
    “These are my sensitive arguments.” When the process is executed, any standard
    process-monitoring tool should see this child process and its unmodified arguments
    by reading them from the PEB. For example, in [Figure 3-3](#fig3-3), we use a
    tool called Process Hacker to extract command line parameters.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-3.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: Command line arguments
    retrieved from the PEB</samp>'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: As expected, *cmd.exe* was spawned with our string of five arguments passed
    to it. Let’s keep this example in mind; it will serve as our benign baseline as
    we start trying to hide our malware.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Chester’s blog post describes the following process for modifying the command
    line arguments used to invoke a process. First, you create the child process in
    a suspended state using your malicious arguments. Next, you use <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQueryInformationProcess()</samp>
    to get the address of the child process’s PEB, and you copy it by calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">kernel32!ReadProcessMemory()</samp>. You
    retrieve its <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp>
    field and overwrite the <samp class="SANS_TheSansMonoCd_W5Regular_11">UNICODE_STRING</samp>
    represented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">CommandLine</samp>
    member pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp>
    with spoofed arguments. Lastly, you resume the child process.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Let’s overwrite the original arguments from [Listing 3-9](#list3-9) with the
    argument string “Spoofed arguments passed instead.” [Listing 3-10](#list3-10)
    shows this behavior in action, with the updates in bold.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 3-10: Overwriting command line arguments'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: When we create our process, we pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">CREATE_SUSPENDED</samp>
    flag to the function to start it in a suspended state. Next, we need to get the
    address of the process’s parameters in the PEB. We’ve omitted this code from [Listing
    3-10](#list3-10) for brevity, but the way to do this is to use <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQueryInformationProcess()</samp>,
    passing in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessBasicInformation</samp>
    information class. This should return a <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_BASIC_INFORMATION</samp>
    structure that contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">PebBaseAddress</samp>
    member.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: We can then read our child process’s PEB into a buffer that we allocate locally.
    Using this buffer, we extract the parameters and pass in the address of the PEB.
    Then we use <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp>
    to copy it into another local buffer. In our code, this final buffer is called
    <samp class="SANS_TheSansMonoCd_W5Regular_11">pParameters</samp> and is cast as
    a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">RTL_USER_PROCESS_PARAMETERS</samp>
    structure. We overwrite the existing parameters with a new string via a call to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!WriteProcessMemory()</samp>.
    Assuming that this all completed without error, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!ResumeThread()</samp>
    to allow our suspended child process to finish initialization and begin executing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Process Hacker now shows the spoofed argument values, as you can see in [Figure
    3-4](#fig3-4).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-4.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-4: Command line arguments
    overwritten with spoofed values</samp>'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: While this technique remains one of the more effective ways to evade detection
    based on suspicious command line arguments, it has a handful of limitations. One
    such limitation is that a process can’t change its own command line arguments.
    This means that if we don’t have control of the parent process, as in the case
    of an initial access payload, the process must execute with the original arguments.
    Additionally, the value used to overwrite the suspicious arguments in the PEB
    must be longer than the original value. If it is shorter, the overwrite will be
    incomplete, and portions of the suspicious arguments will remain. [Figure 3-5](#fig3-5)
    shows this limitation in action.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-5.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-5: Command line arguments
    partially overwritten</samp>'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have shortened our arguments to the value “Spoofed arguments.” As
    you can see, it replaced only part of the original arguments. The inverse is also
    true: if the length of the spoofed value is greater than that of the original
    arguments, the spoofed arguments will be truncated.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parent Process ID
    Spoofing</samp>
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nearly every EDR has some way of correlating parent–child processes on the system.
    This allows the agent to identify suspicious process relationships, such as Microsoft
    Word spawning *rundll32.exe*, which could indicate an attacker’s initial access
    or their successful exploitation of a service.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Thus, in order to hide malicious behavior on the host, attackers often wish
    to spoof their current process’s parent. If we can trick an EDR into believing
    that our malicious process creation is actually normal, we’re substantially less
    likely to be detected. The most common way to accomplish this is by modifying
    the child’s process and thread attribute list, a technique popularized by Didier
    Stevens in 2009\. This evasion relies on the fact that, on Windows, children inherit
    certain attributes from parent processes, such as the current working directory
    and environment variables. No dependencies exist between parent and child processes;
    therefore, we can specify a parent process somewhat arbitrarily, as this section
    will cover.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: To better understand this strategy, let’s dig into process creation on Windows.
    The primary API used for this purpose is the aptly named <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateProcess()</samp>
    API. This function is defined in [Listing 3-11](#list3-11).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 3-11: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">kernel32!CreateProcess()</samp>
    API definition'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The ninth parameter passed to this function is a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">STARTUPINFO</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">STARTUPINFOEX</samp> structure.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">STARTUPINFOEX</samp> structure,
    which is defined in [Listing 3-12](#list3-12), extends the basic startup information
    structure by adding a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">PROC_THREAD_ATTRIBUTE_LIST</samp>
    structure.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 3-12: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">STARTUPINFOEX</samp>
    structure definition'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: When creating our process, we can make a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!InitializeProcThreadAttributeList()</samp>
    to initialize the attribute list and then make a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!UpdateProcThreadAttribute()</samp>
    to modify it. This allows us to set custom attributes of the process to be created.
    When spoofing the parent process, we’re interested in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PROC_THREAD_ATTRIBUTE_PARENT_PROCESS</samp>
    attribute, which indicates that a handle to the desired parent process is being
    passed. To get this handle, we must obtain a handle to the target process, by
    either opening a new one or leveraging an existing one.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-13](#list3-13) shows an example of process spoofing to tie all these
    pieces together. We’ll modify the attributes of the Notepad utility so that VMware
    Tools appears to be its parent process.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 3-13: An example of spoofing a parent process'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: We first hardcode the process ID ❶ of *vmtoolsd.exe*, our desired parent. In
    the real world, we might instead use logic to find the ID of the parent we’d like
    to spoof, but I’ve opted not to include this code in the example for the sake
    of brevity. Next, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SpoofParent()</samp>
    function makes a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!OpenProcess()</samp>
    ❷. This function is responsible for opening a new handle to an existing process
    with the access rights requested by the developer. In most offensive tools, you
    may be used to seeing this function used with arguments like <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_VM_READ</samp>,
    to read the process’s memory, or <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_ALL_ACCESS</samp>,
    which gives us full control over the process. In this example, however, we request
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_CREATE_PROCESS</samp>. We’ll
    need this access right in order to use the target process as a parent with our
    externed startup information structure. When the function completes, we’ll have
    a handle to *vmtoolsd.exe* with the appropriate rights.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we need to do is create and populate the <samp class="SANS_TheSansMonoCd_W5Regular_11">PROC_THREAD
    _ATTRIBUTE_LIST</samp> structure. To do this, we use a pretty common Windows programming
    trick to get the size of a structure and allocate the correct amount of memory
    to it. We call the function to initialize the attribute list ❸, passing in a null
    pointer instead of the address of the real attribute list. However, we still pass
    in a pointer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">DWORD</samp>,
    which will hold the size required after completion. We then use the size stored
    in this variable to allocate memory on the heap with <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!HeapAlloc()</samp>
    ❹. Now we can call the attribute list initialization function again, passing in
    a pointer to the heap allocation we just created.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’re ready to start spoofing. We do this by first calling the
    function for modifying the attribute list and passing in the attribute list itself,
    the flag indicating a handle to the parent process, and the handle we opened to
    *vmtoolsd.exe* ❺. This sets *vmtoolsd.exe* as the parent process of whatever we
    create using this attribute list. The last thing we need to do with our attribute
    list is pass it as input to the process-creation function, specifying the child
    process to create and the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXTENDED_STARTUPINFO_PRESENT</samp>
    flag. When this function is executed, *notepad.exe* will appear to be a child
    of *vmtoolsd.exe* in Process Hacker rather than a child of its true parent, *ppid-spoof.exe*
    ([Figure 3-6](#fig3-6)).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-6.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-6: A spoofed parent
    process in Process Hacker</samp>'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately for adversaries, this evasion technique is relatively simple
    to detect in a few ways. The first is by using the driver. Remember that the structure
    passed to the driver on a process-creation event contains two separate fields
    related to parent processes: <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentProcessId</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CreatingThreadId</samp>. While
    these two fields will point to the same process in most normal circumstances,
    when the parent process ID (PPID) of a new process is spoofed, the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreatingThreadId.UniqueProcess</samp>
    field will contain the PID of the process that made the call to the process-creation
    function. [Listing 3-14](#list3-14) shows the output from a mock EDR driver captured
    by DbgView, a tool used to capture debug print messages.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 3-14: Capturing parent and creator process information from a driver'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: You can see here that the spoofed *vmtoolsd.exe* shows up as the parent process,
    but the creator (the true process that launched *notepad.exe*) is identified as
    *ppid-spoof.exe*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Another approach to detecting PPID spoofing uses ETW (a topic we’ll explore
    further in [Chapter 8](chapter8.xhtml)). F-Secure has extensively documented this
    technique in its “Detecting Parent PID Spoofing” blog post. This detection strategy
    relies on the fact that the process ID specified in the ETW event header is the
    creator of the process, rather than the parent process specified in the event
    data. Thus, in our example, defenders could use an ETW trace to capture process-creation
    events on the host whenever *notepad.exe* is spawned. [Figure 3-7](#fig3-7) shows
    the resulting event data.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-7.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-7: A spoofed parent
    process in ETW event data</samp>'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Highlighted in [Figure 3-7](#fig3-7) is the process ID of *vmtoolsd.exe*, the
    spoofed parent. If you compare this to the event header, shown in [Figure 3-8](#fig3-8),
    you can see the discrepancy.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-8.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-8: A creator process
    ID captured in an ETW event header</samp>'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Note the difference in the two process IDs. While the event data had the ID
    of *vmtoolsd.exe*, the header contains the ID of *ppid-spoof.exe*, the true creator.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'The information from this ETW provider isn’t quite as detailed as the information
    provided to us by the mock EDR driver in [Listing 3-14](#list3-14). For example,
    we’re missing the image name for both the parent and creator processes. This is
    because the ETW provider doesn’t derive that information for us, like the driver
    does. In the real world, we’d likely need to add a step to retrieve that information,
    by either querying the process or pulling it from another data source. Regardless,
    we can still use this technique as a way to detect PPID spoofing, as we have the
    core piece of information needed for the strategy: mismatched parent and creator
    process IDs.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Process-Image Modification</samp>
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In many cases, malware wishes to evade *image-based* detection, or detections
    built on the name of the file being used to create the process. While there are
    many ways to accomplish this, one tactic, which we’ll call *process-image modification*,
    has gained substantial traction since 2017, although prolific threat groups have
    used it since at least 2014\. In addition to hiding the execution of the malware
    or tooling, this tactic could allow attackers to bypass application whitelisting,
    evade per-application host firewall rules, or pass security checks against the
    calling image before a server allows a sensitive operation to occur.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'This section covers four process-image modification techniques, namely hollowing,
    doppelgänging, herpaderping, and ghosting, all of which achieve their goal in
    roughly the same way: by remapping the host process’s original image with its
    own. These techniques also all rely on the same design decision made by Microsoft
    while implementing the logic for notifying registered callbacks of a process being
    created.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'The design decision is this: process creation on Windows involves a complex
    set of steps, many of which occur before the kernel notifies any drivers. As a
    result, attackers have an opportunity to modify the process’s attributes in some
    way during those early steps. Here is the entire process-creation workflow, with
    the notification step shown in bold:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 1. Validate parameters passed to the process-creation API.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 2. Open a handle to the target image.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 3. Create a section object from the target image.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 4. Create and initialize a process object.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 5. Allocate the PEB.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Create and initialize the thread object.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '**7. Send the process-creation notification to the registered callbacks.**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 8. Perform Windows subsystem-specific operations to finish initialization.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 9. Start execution of the primary thread.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 10. Finalize process initialization.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 11. Start execution at the image entry point.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 12. Return to the caller of the process-creation API.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The techniques outlined in this section take advantage of step 3, in which the
    kernel creates a section object from the process image. The memory manager caches
    this image section once it is created, meaning that the section can deviate from
    the corresponding target image. Thus, when the driver receives its notification
    from the kernel process manager, the <samp class="SANS_TheSansMonoCd_W5Regular_11">FileObject</samp>
    member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_CREATE_NOTIFY_INFO</samp>
    structure it processes may not point to the file truly being executed. Beyond
    exploiting this fact, each of the following techniques has slight variations.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Hollowing</samp>
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Hollowing* is one of the oldest ways of leveraging section modification, dating
    back to at least 2011\. [Figure 3-9](#fig3-9) shows the execution flow of this
    technique.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-9.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-9: The execution flow
    of process hollowing</samp>'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Using this technique, the attacker creates a process in a suspended state, then
    unmaps its image after locating its base address in the PEB. Once the unmapping
    is complete, the attacker maps a new image, such as the adversary’s shellcode
    runner, to the process and aligns its section. If this succeeds, the process resumes
    execution.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Doppelgänging</samp>
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In their 2017 Black Hat Europe presentation “Lost in Transaction: Process Doppelgänging,”
    Tal Liberman and Eugene Kogan introduced a new variation on process-image modification.
    Their technique, *process doppelgänging*, relies on two Windows features: Transactional
    NTFS (TxF) and the legacy process-creation API, <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateProcessEx()</samp>.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: TxF is a now-deprecated method for performing filesystem actions as a single
    atomic operation. It allows code to easily roll back file changes, such as during
    an update or in the event of an error, and has its own group of supporting APIs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The legacy process-creation API performed process creation prior to the release
    of Windows 10, which introduced the more robust <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateUserProcess()</samp>.
    While it’s deprecated for normal process creation, you’ll still find it used on
    Windows 10, in versions up to 20H2, to create minimal processes. It has the notable
    benefit of taking a section handle rather than a file for the process image but
    comes with some significant challenges. These difficulties stem from the fact
    that many of the process-creation steps, such as writing process parameters to
    the new process’s address space and creating the main thread object, aren’t handled
    behind the scenes. In order to use the legacy process-creation function, the developer
    must re-create those missing steps in their own code to ensure that the process
    can start.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-10](#fig3-10) shows the complex flow of process doppelgänging.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-10.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-10: The execution
    flow of process doppelgänging</samp>'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In their proof of concept, Liberman and Kogan first create a transaction object
    and open the target file with <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateFileTransacted()</samp>.
    They then overwrite this transacted file with their malicious code, create an
    image section that points to the malicious code, and roll back the transaction
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!RollbackTransaction()</samp>.
    At this point, the executable has been restored to its original state, but the
    image section is cached with the malicious code. From here, the authors call <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateProcessEx()</samp>, passing
    in the section handle as a parameter, and create the main thread pointing to the
    entry point of their malicious code. After these objects are created, they resume
    the main thread, allowing the doppelgänged process to execute.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Herpaderping</samp>
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Process herpaderping*, invented by Johnny Shaw in 2020, leverages many of
    the same tricks as process doppelgänging, namely its use of the legacy process-creation
    API to create a process from a section object. While herpaderping can evade a
    driver’s image-based detections, its primary aim is to evade detection of the
    contents of the dropped executable. [Figure 3-11](#fig3-11) shows how this technique
    works.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-11.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-11: The execution
    flow of process herpaderping</samp>'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: To perform herpaderping, an attacker first writes the malicious code to be executed
    to disk and creates the section object, leaving the handle to the dropped executable
    open. They then call the legacy process-creation API, with the section handle
    as a parameter, to create the process object. Before initializing the process,
    they obscure the original executable dropped to disk using the open file handle
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!WriteFile()</samp>
    or a similar API. Finally, they create the main thread object and perform the
    remaining process spin-up tasks.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the driver’s callback receives a notification, and it can scan
    the file’s contents using the <samp class="SANS_TheSansMonoCd_W5Regular_11">FileObject</samp>
    member of the structure passed to the driver on process creation. However, because
    the file’s contents have been modified, the scanning function will retrieve bogus
    data. Additionally, closing the file handle will send an <samp class="SANS_TheSansMonoCd_W5Regular_11">IRP_MJ_CLEANUP</samp>
    I/O control code to any filesystem minifilters that have been registered. If the
    minifilter wishes to scan the contents of the file, it will meet the same fate
    as the driver, potentially resulting in a false-negative scan result.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Ghosting</samp>
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the newest variations on process-image modification is *process ghosting*,
    released in June 2021 by Gabriel Landau. Process ghosting relies on the fact that
    Windows only prevents the deletion of files *after* they’re mapped into an image
    section and doesn’t check whether an associated section actually exists during
    the deletion process. If a user attempts to open the mapped executable to modify
    or delete it, Windows will return an error. If the developer marks the file for
    deletion and then creates the image section from the executable, the file will
    be deleted when the file handle is closed, but the section object will persist.
    This technique’s execution flow is shown in [Figure 3-12](#fig3-12).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure3-12.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-12: The process-ghosting
    workflow</samp>'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: To implement this technique in practice, malware might create an empty file
    on disk and then immediately put it into a delete-pending state using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtSetInformationFile()</samp> API.
    While the file is in this state, the malware can write its payload to it. Note
    that external requests to open the file will fail, with *ERROR_DELETE_PENDING*,
    at this point. Next, the malware creates the image section from the file and then
    closes the file handle, deleting the file but preserving the image section. From
    here, the malware follows the steps to create a new process from a section object
    described in previous examples. When the driver receives a notification about
    the process creation and attempts to access the <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_OBJECT</samp>
    backing the process (the structure used by Windows to represent a file object),
    it will receive a *STATUS_FILE_DELETED* error, preventing the file from being
    inspected.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Detection</samp>
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While process-image modification has a seemingly endless number of variations,
    we can detect all of these using the same basic methods due to the technique’s
    reliance on two things: the creation of an image section that differs from the
    reported executable, whether it is modified or missing, and the use of the legacy
    process-creation API to create a new, non-minimal process from the image section.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, most of the detections for this tactic are reactive, occurring
    only as part of an investigation, or they leverage proprietary tooling. Still,
    by focusing on the basics of the technique, we can imagine multiple potential
    ways to detect it. To demonstrate these methods, Aleksandra Doniec (@hasherezade)
    created a public proof of concept for process ghosting that we can analyze in
    a controlled environment. You can find this file, *proc_ghost64.exe*, at [*https://<wbr>github<wbr>.com<wbr>/hasherezade<wbr>/process<wbr>_ghosting<wbr>/releases*](https://github.com/hasherezade/process_ghosting/releases).
    Verify that its SHA-256 hash matches the following: <samp class="SANS_TheSansMonoCd_W5Regular_11">8a74a522e9a91b777080d3cb95d8bbeea84cb71fda487bc3d4489188e3fd6855</samp>.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: First, in kernel mode, the driver could search for information related to the
    process’s image either in the PEB or in the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp>
    structure, the structure that represents a process object in the kernel. Because
    the user can control the PEB, the process structure is a better source. It contains
    process-image information in a number of locations, described in [Table 3-1](#tab3-1).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 3-1:</samp> <samp class="SANS_Futura_Std_Book_11">Process-Image
    Information Contained in the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp>
    <samp class="SANS_Futura_Std_Book_11">Structure</samp>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Location</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Process-image
    information</samp> |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp> | <samp
    class="SANS_Futura_Std_Book_11">Contains only the filename</samp> |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFilePointer.FileName</samp>
    | <samp class="SANS_Futura_Std_Book_11">Contains the rooted Win32 filepath</samp>
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAuditProcessCreationInfo.ImageFileName</samp>
    | <samp class="SANS_Futura_Std_Book_11">Contains the full NT path but may not
    always be populated</samp> |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">ImagePathHash</samp> | <samp
    class="SANS_Futura_Std_Book_11">Contains the hashed NT, or canonicalized, path
    via</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PfCalculateProcessHash()</samp>
    |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: Drivers may query these paths by using APIs such as <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!SeLocateProcessImageName()</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!ZwQueryInformationProcess()</samp>
    to retrieve the true image path, at which point they still need a way to determine
    whether the process has been tampered with. Despite being unreliable, the PEB
    provides a point of comparison. Let’s walk through this comparison using WinDbg.
    First, we attempt to pull the image’s filepath from one of the process structure’s
    fields ([Listing 3-15](#list3-15)).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 3-15: Pulling the filepath from <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SeAuditProcessCreationInfo</samp>'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, WinDbg returns an empty string as the image name. This is atypical;
    for example, [Listing 3-16](#list3-16) returns what you’d expect to see in the
    case of an unmodified *notepad.exe*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 3-16: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">UNICODE_STRING</samp>
    field populated with the NT path of the image'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Let’s also check another member of the process structure, <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp>.
    While this field won’t return the full image path, it still provides valuable
    information, as you can see in [Listing 3-17](#list3-17).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 3-17: Reading the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ImageFileName</samp>
    member of the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EPROCESS</samp>
    structure'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'The returned filename should have already attracted attention, as *.tmp* files
    aren’t very common executables. To determine whether image tampering might have
    taken place, we’ll query the PEB. A few locations in the PEB will return the image
    path: <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters.ImagePathName</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Ldr.InMemoryOrderModuleList</samp>*.*
    Let’s use WinDbg to demonstrate this ([Listing 3-18](#list3-18)).'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 3-18: Extracting the process image’s path from <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ImagePathName</samp>'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the WinDbg output, the PEB reports the process image’s path as *C:\Windows\System32\notepad.exe*.
    We can verify this by querying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Ldr.InMemoryOrderModuleList</samp>
    field, shown in [Listing 3-19](#list3-19).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 3-19: Extracting the process image’s path from <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">InMemoryOrderModuleList</samp>'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: You can see here that *notepad.exe* is the first image in the module list ❶.
    In my testing, this should always be the case. If an EDR found a mismatch like
    this between the image name reported in the process structures and in the PEB,
    it could reasonably say that some type of process-image tampering had occurred.
    It couldn’t, however, determine which technique the attacker had used. To make
    that call, it would have to collect additional information.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The EDR might first try to investigate the file directly, such as by scanning
    its contents through the pointer stored in the process structure’s <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFilePointer</samp>
    field. If malware created the process by passing an image section object through
    the legacy process-creation API, as in the proof of concept, this member will
    be empty ([Listing 3-20](#list3-20)).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 3-20: The empty <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ImageFilePointer</samp>
    field'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The use of the legacy API to create a process from a section is a major indicator
    that something weird is going on. At this point, the EDR can reasonably say that
    this is what happened. To support this assumption, the EDR could also check whether
    the process is minimal or *pico* (derived from a minimal process), as shown in
    [Listing 3-21](#list3-21).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 3-21: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Minimal</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PicoCreated</samp>
    members set to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">false</samp>'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Another place to look for anomalies is the virtual address descriptor (VAD)
    tree used for tracking a process’s contiguous virtual memory allocations. The
    VAD tree can provide very useful information about loaded modules and the permissions
    of memory allocations. The root of this tree is stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">VadRoot</samp>
    member of the process structure, which we can’t directly retrieve through a Microsoft-supplied
    API, but you can find a reference implementation in Blackbone, a popular driver
    used for manipulating memory.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: To detect process-image modifications, you’ll probably want to look at the mapped
    allocation types, which include *READONLY* file mappings, such as the COM+ catalog
    files (for example, *C:\Windows\Registration\Rxxxxxxx1.clb*), and *EXECUTE_WRITECOPY*
    executable files. In the VAD tree, you’ll commonly see the Win32-rooted path for
    the process image (in other words, the executable file that backs the process
    as the first mapped executable). [Listing 3-22](#list3-22) shows the truncated
    output of WinDbg’s <samp class="SANS_TheSansMonoCd_W5Regular_11">!vad</samp> command.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 3-22: The output of the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">!vad</samp>
    command in WinDbg for a normal process'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The output of this tool shows mapped allocations for an unmodified *notepad.exe*
    process. Now let’s see how they look in a ghosted process ([Listing 3-23](#list3-23)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 3-23: The output of the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">!vad</samp>
    command for a ghosted process'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: This mapped allocation shows the path to the *.tmp* file instead of the path
    to *notepad.exe*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the path to the image of interest, we can investigate it further.
    One way to do this is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQueryInformationFile()</samp>
    API with the <samp class="SANS_TheSansMonoCd_W5Regular_11">FileStandardInformation</samp>
    class, which will return a <samp class="SANS_TheSansMonoCd_W5Regular_11">FILE_STANDARD_INFORMATION</samp>
    structure. This structure contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeletePending</samp>
    field, which is a Boolean indicating whether the file has been marked for deletion.
    Under normal circumstances, you could also pull this information from the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DeletePending</samp> member of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FILE_OBJECT</samp> structure. Inside the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp> structure for the
    relevant process, this is pointed to by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFilePointer</samp>
    member. In the case of the ghosted process, this pointer will be null, so the
    EDR can’t use it. [Listing 3-24](#list3-24) shows what a normal process’s image
    file pointer and deletion status should look like.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 3-24: Normal <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ImageFilePointer</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">DeletePending</samp>
    members'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: This listing is from a *notepad.exe* process executed under normal conditions.
    In a ghosted process, the image file pointer would be an invalid value, and thus,
    the deletion status flag would also be invalid.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'After observing the difference between a normal instance of *notepad.exe* and
    one that has been ghosted, we’ve identified a few indicators:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: There will be a mismatch between the paths in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImagePathName</samp>
    inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessParameters</samp>
    member of the process’s PEB and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp>
    in its <samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp> structure.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process structure’s image file pointer will be null and its <samp class="SANS_TheSansMonoCd_W5Regular_11">Minimal</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">PicoCreated</samp> fields will
    be <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The filename may be atypical (this isn’t a requirement, however, and the user
    can control this value).
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the EDR driver receives the new process-creation structure from its process-creation
    callback, it will have access to the key information needed to build a detection.
    Namely, in the case of process ghosting, it can use <samp class="SANS_TheSansMonoCd_W5Regular_11">ImageFileName</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FileObject</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">IsSubsystemProcess</samp>
    to identify potentially ghosted processes. [Listing 3-25](#list3-25) shows what
    this driver logic could look like.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 3-25: Detecting ghosted processes with the driver'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: We first check whether the file pointer is null even though the process being
    created isn’t a subsystem process ❶, meaning it was likely created with the legacy
    process-creation API. Next, we use two mock helper functions ❷ to return the process
    image path from the PEB and convert it to the NT path. We then repeat this process
    using the image filename from the process structure for the newly created process
    ❸. After that, we compare the image paths in the PEB and process structure. If
    they’re not equal, we’ve likely found a suspicious process, and it’s time for
    the EDR to take some action.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_B_11">A Process Injection Case Study: fork&run</samp>'
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over time, shifts in attacker tradecraft have affected the importance, to EDR
    vendors, of detecting suspicious process-creation events. After gaining access
    to a target system, attackers may leverage any number of command-and-control agents
    to perform their post-exploitation activities. Each malware agent’s developers
    must decide how to handle communications with the agent so that they can execute
    commands on the infected system. While there are numerous approaches to tackling
    this problem, the most common architecture is referred to as *fork&run*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Fork&run works by spawning a sacrificial process into which the primary agent
    process injects its post-exploitation tasking, allowing the task to execute independently
    of the agent. This comes with the advantage of stability; if a post-exploitation
    task running inside the primary agent process has an unhandled exception or fault,
    it could cause the agent to exit. As a result, the attacker could lose access
    to the environment.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The architecture also streamlines the agent’s design. By providing a host process
    and a means of injecting its post-exploitation capabilities, the developer makes
    it easier to integrate new features into the agent. Additionally, by keeping post-exploitation
    tasking contained in another process, the agent doesn’t need to worry too much
    about cleanup and can instead terminate the sacrificial process altogether.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging fork&run in an agent is so simple that many operators might not even
    realize they’re using it. One of the most popular agents that makes heavy use
    of fork&run is Cobalt Strike’s Beacon. Using Beacon, the attacker can specify
    a sacrificial process, either through their Malleable profile or through Beacon’s
    integrated commands, into which they can inject their post-exploitation capabilities.
    Once the target is set, Beacon will spawn this sacrificial process and inject
    its code whenever a post-exploitation job that requires fork&run is queued. The
    sacrificial process is responsible for running the job and returning output before
    exiting.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: However, this architecture poses a large risk to operational security. Attackers
    now have to evade so many detections that leveraging the built-in features of
    an agent like Beacon often isn’t viable. Instead, many teams now use their agent
    only as a method for injecting their post-exploitation tooling code and maintaining
    access to the environment. An example of this trend is the rise of offensive tooling
    written in C# and primarily leveraged through Beacon’s *execute-assembly*, a way
    to execute .NET assemblies in memory that makes use of fork&run under the hood.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Because of this shift in tradecraft, EDRs highly scrutinize process creation
    from numerous angles, ranging from the relative frequency of the parent–child
    relationship in the environment to whether the process’s image is a .NET assembly.
    Yet, as EDR vendors became better at detecting the “create a process and inject
    into it” pattern, attackers have begun to consider spawning a new process to be
    highly risky and have looked for ways to avoid doing it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: One of the biggest challenges for EDR vendors came in version 4.1 of Cobalt
    Strike, which introduced Beacon Object Files (BOFs). BOFs are small programs written
    in C that are meant to be run in the agent process, avoiding fork&run entirely.
    Capability developers could continue to use their existing development process
    but leverage this new architecture to achieve the same results in a safer manner.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: If attackers remove the artifacts from fork&run, EDR vendors must rely on other
    pieces of telemetry for their detections. Fortunately for vendors, BOFs only remove
    the process-creation and injection telemetry related to the sacrificial process
    creation. They don’t do anything to hide the post-exploitation tooling’s artifacts,
    such as network traffic, filesystem interactions, or API calls. This means that,
    while BOFs do make detection more difficult, they are not a silver bullet.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Monitoring the creation of new processes and threads is an immensely important
    capability for any EDR. It facilitates the mapping of parent–child relationships,
    the investigation of suspect processes prior to their execution, and the identification
    of remote thread creation. Although Windows provides other ways to obtain this
    information, process- and thread-creation callback routines inside the EDR’s driver
    are by far the most common. In addition to having a great deal of visibility into
    activity on the system, these callbacks are challenging to evade, relying on gaps
    in coverage and blind spots rather than fundamental flaws in the underlying technology.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
