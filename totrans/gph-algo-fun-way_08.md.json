["```\nclass PGState:\n    def __init__(self, guards_left: int = 3, prisoners_left: int = 3,\n                 boat_side: str = \"L\"):\n        self.guards_left = guards_left\n        self.prisoners_left = prisoners_left\n        self.boat_side = boat_side\n\n    def __str__(self) -> str:\n        return (f\"{self.guards_left},{self.prisoners_left},{self.boat_side}\") \n```", "```\ndef pg_result_of_move(state: PGState, num_guards: int,\n                      num_prisoners: int) -> Union[PGState, None]: \n  ❶ if num_guards < 0 or num_prisoners < 0:\n        return None\n    if num_guards + num_prisoners == 0:\n        return None\n    if num_guards + num_prisoners > 2:\n        return None\n\n  ❷ G_L: int = state.guards_left\n    G_R: int = (3 - state.guards_left)\n    P_L: int = state.prisoners_left\n    P_R: int = (3 - state.prisoners_left)\n    if state.boat_side == \"L\":\n        G_L -= num_guards\n        G_R += num_guards\n        P_L -= num_prisoners\n        P_R += num_prisoners\n        new_side: str = \"R\"\n    else:\n        G_L += num_guards\n        G_R -= num_guards\n        P_L += num_prisoners\n        P_R -= num_prisoners\n        new_side = \"L\"\n\n  ❸ if G_L < 0 or P_L < 0 or G_R < 0 or P_R < 0:\n        return None\n\n  ❹ if G_L > 0 and G_L < P_L:\n        return None\n    if G_R > 0 and G_R < P_R:\n        return None\n    return PGState(G_L, P_L, new_side) \n```", "```\ndef pg_neighbors(state: PGState) -> list: \n    neighbors: list = []\n  ❶ for move in [(1, 0), (2, 0), (0, 1), (0, 2), (1, 1)]:\n      ❷ n: Union[PGState, None] = pg_result_of_move(state, move[0], move[1])\n        if n is not None:\n            neighbors.append(n)\n    return neighbors \n```", "```\ndef create_prisoners_and_guards() -> Graph: \n    indices: dict = {}\n    next_node: queue.Queue = queue.Queue()\n    g: Graph = Graph(0, undirected=True)\n\n  ❶ initial_state: PGState = PGState(3, 3, \"L\")\n    initial: Node = g.insert_node(label=initial_state)\n    next_node.put(initial.index)\n    indices[str(initial_state)] = initial.index\n\n    while not next_node.empty():\n      ❷ current_ind: int = next_node.get()\n        current_node: Node = g.nodes[current_ind]\n        current_state = current_node.label\n\n      ❸ neighbors: list = pg_neighbors(current_state)\n        for state in neighbors:\n            state_str: str = str(state)\n          ❹ if not state_str in indices:\n                new_node: Node = g.insert_node(label=state)\n                indices[state_str] = new_node.index\n                next_node.put(new_node.index)\n          ❺ new_ind: int = indices[str(state)]\n            g.insert_edge(current_ind, new_ind, 1.0)\n\n    return g \n```", "```\ndef pg_state_to_index_map(g: Graph) -> dict: \n    state_to_index: dict = {}\n    for node in g.nodes:\n        state: str = str(node.label)\n        state_to_index[state] = node.index\n    return state_to_index \n```", "```\ndef solve_pg_bfs(): \n  ❶ g: Graph = create_prisoners_and_guards()\n\n  ❷ state_to_index: dict = pg_state_to_index_map(g)\n    start_index: int = state_to_index[\"3,3,L\"]\n    end_index: int = state_to_index[\"0,0,R\"]\n\n  ❸ last: int = breadth_first_search(g, start_index)\n\n  ❹ current: int = end_index\n    path_reversed: list = []\n    while current != -1:\n        path_reversed.append(current)\n        current = last[current]\n\n  ❺ if path_reversed[-1] != start_index:\n        print(\"No solution\")\n        return\n\n  ❻ for i, n in enumerate(reversed(path_reversed)):\n        print(f\"Step {i}: {g.nodes[n].label}\") \n```"]