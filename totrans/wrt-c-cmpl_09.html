<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch8">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_142" aria-label="142"/>&#13;
<figure class="co-img"><img id="fig-pg142" class="img60" src="../images/pg142.jpg" alt="" width="687" height="1664"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-16.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_143" aria-label="143"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch8">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">LOOPS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro">In this chapter, you’ll add all things loop-related. That includes <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> loops, plus <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements to skip over parts of a loop. These are the last statements you’ll implement in this book. Once you finish this chapter, if you’ve implemented all the extra credit features, your compiler will be able to handle <i>every</i> kind of C statement.</p>&#13;
<p class="TX">But you have work to do first! You’ll update the lexer and parser to support all five new statements. Then, you’ll add a new semantic analysis pass, which we’ll call <i>loop labeling</i>. This new pass, which is bolded in the diagram at the start of the chapter, will annotate the AST to associate every <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement with the loop that contains it. Finally, you’ll translate every new statement into a sequence of TACKY instructions. You can implement all the new statements using the TACKY instructions you’ve already defined, so you won’t change any stages after TACKY generation.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_144" aria-label="144"/>The new statements in this chapter introduce a few edge cases and errors we’ll need to handle. We’ll briefly discuss each of these statements before we start on the lexer.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-63"/><samp class="SANS_Futura_Std_Bold_B_11">Loops and How to Escape Them</samp></h3>&#13;
<p class="TNI">Let’s first look at the three kinds of loop statements, then consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements. <a href="chapter8.xhtml#list8-1">Listing 8-1</a> shows an example of a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop.</p>&#13;
<a id="list8-1"/>&#13;
<pre><code>while ( <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> a &gt; 0)&#13;
    a = a / 2;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-1: A</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">while</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp></p>&#13;
<p class="TX">First, we evaluate the statement’s <i>controlling expression</i> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If it’s 0 (that is, false), the loop ends and we move on to the next statement. If it’s nonzero, we execute the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop body, then go back to the controlling expression, rinse, and repeat.</p>&#13;
<p class="TX">A <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> loop, like the one in <a href="chapter8.xhtml#list8-2">Listing 8-2</a>, is almost exactly the same.</p>&#13;
<a id="list8-2"/>&#13;
<pre><code>do&#13;
    a = a + 1;&#13;
while (a &lt; 100);</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-2: A</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">do</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp></p>&#13;
<p class="TX">The only difference is that we execute the loop body first, <i>then</i> check the controlling expression. That means the loop body will be executed at least once. Like an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement body, a loop body is a single statement, which can be a compound statement that contains declarations. Any variables you declare in the loop body will not be in scope in the controlling expression. For example, <a href="chapter8.xhtml#list8-3">Listing 8-3</a> is invalid.</p>&#13;
<a id="list8-3"/>&#13;
<pre><code>do {&#13;
    int a = a + 1;&#13;
} while (a &lt; 100);</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-3: A</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">do</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop where the controlling expression uses an out-of-scope variable</samp></p>&#13;
<p class="TX">Things start to get more complicated with <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops. These come in two different flavors. In the first, shown in <a href="chapter8.xhtml#list8-4">Listing 8-4</a>, the loop header consists of three expressions.</p>&#13;
<a id="list8-4"/>&#13;
<pre><code>int a;&#13;
for ( <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> a = 0; <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> a &lt; 5; <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> a = a + 1)&#13;
    b = b * 2;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-4: A</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop where the initial clause is an expression</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_145" aria-label="145"/>The initial expression <span class="CodeAnnotation" aria-label="annotation1">❶</span> is evaluated once before the first loop iteration. Then, on each iteration, we:</p>&#13;
<ol class="NL">&#13;
<li class="NL">Evaluate the controlling expression <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If it’s false, the loop terminates. Otherwise, we …</li>&#13;
<li class="NL">Execute the statement body.</li>&#13;
<li class="NL">Evaluate the final expression <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</li>&#13;
</ol>&#13;
<p class="TX">You can omit any or all of the expressions in the loop header. If you omit the initial expression or the final expression, nothing happens when that clause would normally be evaluated. If you omit the controlling expression, the loop behaves as though its controlling expression is always true (that is, nonzero). That means it will never terminate, unless it contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement that transfers control out of the loop body.</p>&#13;
<p class="TX"><a href="chapter8.xhtml#list8-5">Listing 8-5</a> shows the second kind of <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, in which the initial clause is a declaration rather than an expression.</p>&#13;
<a id="list8-5"/>&#13;
<pre><code>for (int a = 0; a &lt; 5; a = a + 1)&#13;
    b = b * 2;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-5: A</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop with a declaration in the initial clause</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop header introduces a new scope, so you can write code like <a href="chapter8.xhtml#list8-6">Listing 8-6</a>.</p>&#13;
<a id="list8-6"/>&#13;
<pre><code>int a = 5;&#13;
for (int a = 0; a &lt; 5; a = a + 1)&#13;
    b = b + a;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-6: Declaring two variables with the same name before a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop and in the loop header</samp></p>&#13;
<p class="TX">In this listing, the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> declared in the header hides the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> declared on the previous line. And since a compound statement always introduces a new scope, including when it appears as a loop body, <a href="chapter8.xhtml#list8-7">Listing 8-7</a> is also valid.</p>&#13;
<a id="list8-7"/>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> int a = 5;&#13;
for ( <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> int a = 0; a &lt; 5; a = a + 1) {&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> int a = 1;&#13;
    b = b + a;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-7: Declaring three variables with the same name before a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop, in the loop header, and in the loop body</samp></p>&#13;
<p class="TX">In <a href="chapter8.xhtml#list8-7">Listing 8-7</a>, there are three distinct variables named <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>: one declared before the start of the loop <span class="CodeAnnotation" aria-label="annotation1">❶</span>, one declared in the loop header <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and one declared in the loop body <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Although the expressions in a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop header are optional, the loop body is required. (It’s required for <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loops too.) A loop body can, however, be a null statement, like in <a href="chapter8.xhtml#list8-8">Listing 8-8</a>.</p>&#13;
<a id="list8-8"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_146" aria-label="146"/>while ((a = a + 1) &lt; 10)&#13;
    ;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-8: Using a null statement as a loop body</samp></p>&#13;
<p class="TX">The lone <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> here is a null statement. Even though this statement doesn’t do anything, we need to include it so the parser can figure out where the loop ends. As we saw when we implemented them in <span class="Xref-1"><a href="chapter5.xhtml">Chapter 5</a></span>, null statements aren’t a loop-specific construct; you can use them anywhere you can use any other kind of statement. In practice, though, they mostly appear in loop bodies because they’re rarely useful anywhere else.</p>&#13;
<p class="TX">Now let’s talk about <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements. Both can appear only inside loops. (Actually, that’s not entirely true; a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement can also appear inside a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement, which you can implement as an extra credit feature in this chapter.) A <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement, like the one in <a href="chapter8.xhtml#list8-9">Listing 8-9</a>, jumps to the point just after the end of the loop.</p>&#13;
<a id="list8-9"/>&#13;
<pre><code>while (1) {&#13;
    a = a - 1;&#13;
    if (a &lt; 0)&#13;
        break;&#13;
}&#13;
return a;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-9: A</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp></p>&#13;
<p class="TX">When we hit this <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement, we’ll jump to the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement after the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop.</p>&#13;
<p class="TX">A <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement terminates only the innermost loop. For example, consider the code snippet in <a href="chapter8.xhtml#list8-10">Listing 8-10</a>.</p>&#13;
<a id="list8-10"/>&#13;
<pre><code>while (b &gt; 0) {&#13;
    do {&#13;
        a = a - 1;&#13;
        if (a &lt; 0)&#13;
            break;&#13;
    } while (1);&#13;
    b = b * a;&#13;
}&#13;
return b;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-10: Using a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement to break out of the inner of two nested loops</samp></p>&#13;
<p class="TX">When we reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement in this listing, we’ll break out of the inner loop, but not the outer loop, so we’ll jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b * a;</samp>. Throughout this chapter, I’ll call the innermost loop that contains a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement its <i>enclosing loop</i>. (Calling this the “smallest enclosing loop” would be more in line with the terminology in the C standard, but that’s a bit of a mouthful.)</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_147" aria-label="147"/>A <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement jumps to the point just after the last statement in the body of the enclosing loop. Consider the example in <a href="chapter8.xhtml#list8-11">Listing 8-11</a>.</p>&#13;
<a id="list8-11"/>&#13;
<pre><code>while (a &gt; 0) {&#13;
    a = a * b;&#13;
    if (b &gt; 0)&#13;
        continue;&#13;
    b = b + 1;&#13;
    return b;&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span>}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-11: A</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp></p>&#13;
<p class="TX">When we reach the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement, we skip over all the statements that follow it and jump to the end of the loop body <span class="CodeAnnotation" aria-label="annotation1">❶</span>. From there, the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop executes as usual, which means it jumps back to the controlling expression. A <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement in a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, like the one in <a href="chapter8.xhtml#list8-12">Listing 8-12</a>, works the same way.</p>&#13;
<a id="list8-12"/>&#13;
<pre><code>for (int i = 0; i &lt; 5; <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> i = i + 1) {&#13;
    a = a * i;&#13;
    if (b &gt; 0)&#13;
        continue;&#13;
    b = b + 1;&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span>}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-12: A</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement inside a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp></p>&#13;
<p class="TX">In this listing, we still jump from the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement to the end of the loop body <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Then, we jump to the final expression <span class="CodeAnnotation" aria-label="annotation1">❶</span>, as usual.</p>&#13;
<p class="TX">If a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement appears outside of a loop, like in <a href="chapter8.xhtml#list8-13">Listing 8-13</a>, compilation should fail.</p>&#13;
<a id="list8-13"/>&#13;
<pre><code>int main(void) {&#13;
    break;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-13: An invalid</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp></p>&#13;
<p class="TX">It’s perfectly fine, however, for one of these statements to appear nested deep inside a loop, like the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement in <a href="chapter8.xhtml#list8-14">Listing 8-14</a>.</p>&#13;
<a id="list8-14"/>&#13;
<pre><code>while (1) {&#13;
    if (a &gt; 4) {&#13;
        b = b * 2;&#13;
        return a + b;&#13;
    } else {&#13;
        int c = a ? b : 5;&#13;
        {&#13;
            int d = c;&#13;
            break;&#13;
        }&#13;
    }&#13;
    return 0;&#13;
}&#13;
return 1;</code></pre>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_148" aria-label="148"/>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-14: A</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement appearing a few layers deep inside a loop</samp></p>&#13;
<p class="TX">This <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement jumps to <samp class="SANS_TheSansMonoCd_W5Regular_11">return 1;</samp> because that’s the point right after the end of the loop.</p>&#13;
<p class="TX">It’s legal to have multiple <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements in one loop, like in <a href="chapter8.xhtml#list8-15">Listing 8-15</a>.</p>&#13;
<a id="list8-15"/>&#13;
<pre><code>for (int i = 0; i &lt; 10; i = i + 1) {&#13;
    if (i % 2 == 0)&#13;
        continue;&#13;
    if (x &gt; y)&#13;
        continue;&#13;
    break;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-15: Multiple</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements inside a loop</samp></p>&#13;
<p class="TX">Now that we’ve covered the key things you need to know about the statements we’ll add in this chapter, we can get started on implementing them. The first step, as usual, is updating the lexer.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-64"/><samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp></h3>&#13;
<p class="TNI">You’ll add five keywords in this chapter:</p>&#13;
<p class="RunInParaF"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">do</samp></p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">while</samp></p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">for</samp></p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">break</samp></p>&#13;
<p class="RunInParaL"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">continue</samp></p>&#13;
<p class="TX">You won’t need any other new tokens.</p>&#13;
<aside class="box" aria-label="box-106"><p class="BoxTitle" id="box-106"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE LEXER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out your lexer, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 8 --stage lex</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Lexing should succeed for every test case in this chapter.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_149" aria-label="149"/>&#13;
<h3 class="H1" id="sec3"><span id="h1-65"/><samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp></h3>&#13;
<p class="TNI">Next, we’ll update the AST. We’ll add five new statements:</p>&#13;
<pre><code>statement = Return(exp)&#13;
          | Expression(exp)&#13;
          | If(exp condition, statement then, statement? else)&#13;
<b>          </b>| Compound(block)&#13;
<b>          | Break</b>&#13;
<b>          | Continue</b>&#13;
<b>          | While(exp condition, statement body)</b>&#13;
<b>          | DoWhile(statement body, exp condition)</b>&#13;
<b>          | For(for_init init, exp? condition, exp? post, statement body)</b>&#13;
          | Null</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements are as simple as it gets. The <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> statements are also relatively simple; both have a body and a controlling expression. The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> statement is the most complex: it includes an initial clause, an optional controlling expression, an optional final expression, and a body. The initial clause can be a declaration, an expression, or nothing, so we need a new AST node to describe it:</p>&#13;
<pre><code>for_init = InitDecl(declaration) | InitExp(exp?)</code></pre>&#13;
<p class="TX">Putting it all together gives us the latest AST definition, shown in <a href="chapter8.xhtml#list8-16">Listing 8-16</a>.</p>&#13;
<a id="list8-16"/>&#13;
<pre><code>program = Program(function_definition)&#13;
function_definition = Function(identifier name, block body)&#13;
block_item = S(statement) | D(declaration)&#13;
block = Block(block_item*)&#13;
declaration = Declaration(identifier name, exp? init)&#13;
<b>for_init = InitDecl(declaration) | InitExp(exp?)</b>&#13;
statement = Return(exp)&#13;
          | Expression(exp)&#13;
          | If(exp condition, statement then, statement? else)&#13;
<b>          </b>| Compound(block)&#13;
<b>          | Break</b>&#13;
<b>          | Continue</b>&#13;
<b>          | While(exp condition, statement body)</b>&#13;
<b>          | DoWhile(statement body, exp condition)</b>&#13;
<b>          | For(for_init init, exp? condition, exp? post, statement body)</b>&#13;
          | Null&#13;
exp = Constant(int)&#13;
<b>    </b>| Var(identifier)&#13;
    | Unary(unary_operator, exp)&#13;
    | Binary(binary_operator, exp, exp)&#13;
<b>    </b>| Assignment(exp, exp)&#13;
<b>    </b>| Conditional(exp condition, exp, exp)&#13;
unary_operator = Complement | Negate | Not&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_150" aria-label="150"/>binary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or&#13;
                | Equal | NotEqual | LessThan<b> </b>|<b> </b>LessOrEqual&#13;
                | GreaterThan | GreaterOrEqual</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-16: The abstract syntax tree with loops and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp></p>&#13;
<p class="TX">Updating the AST in this chapter involves one complication. The loop labeling pass will annotate every <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp>, and loop statement in the program with a label (we’ll use these labels to associate each <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement with its enclosing loop). That means you’ll need some way to attach these labels to the new statements in the AST. There are a few different options. One is to include a <samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp> argument for each new constructor, like this:</p>&#13;
<pre><code>statement = <var>--snip--</var>&#13;
          | Break(<b>identifier label</b>)&#13;
          | Continue(<b>identifier label</b>)&#13;
          | While(exp condition, statement body, <b>identifier label</b>)&#13;
          | DoWhile(statement body, exp condition, <b>identifier label</b>)&#13;
          | For(for_init init, exp? condition, exp? post, statement body, <b>identifier label</b>)</code></pre>&#13;
<p class="TX">If you go with this option, you may need to use dummy labels during parsing, then replace them with real labels in the loop labeling pass. Another option is to define two AST data structures: one without annotations to use before loop labeling and one with annotations to use afterward. The right approach depends on what language you’re writing your compiler in (and on your personal taste).</p>&#13;
<p class="TX">After updating the AST, we’ll make the corresponding changes to the grammar, as shown in <a href="chapter8.xhtml#list8-17">Listing 8-17</a>.</p>&#13;
<a id="list8-17"/>&#13;
<pre><code>&lt;program&gt; ::= &lt;function&gt;&#13;
&lt;function&gt; ::= "int" &lt;identifier&gt; "(" "void" ")" &lt;block&gt;&#13;
&lt;block&gt; ::= "{" {&lt;block-item&gt;} "}"&#13;
&lt;block-item&gt; ::= &lt;statement&gt; | &lt;declaration&gt;&#13;
&lt;declaration&gt; ::= "int" &lt;identifier&gt; ["=" &lt;exp&gt;] ";"&#13;
<b>&lt;for-init&gt; ::= &lt;declaration&gt; | [&lt;exp&gt;] ";"</b>&#13;
&lt;statement&gt; ::= "return" &lt;exp&gt; ";"&#13;
              | &lt;exp&gt; ";"&#13;
<b>              </b>| "if" "(" &lt;exp&gt; ")" &lt;statement&gt; ["else" &lt;statement&gt;]&#13;
              | &lt;block&gt;&#13;
              <b>| "break" ";"</b>&#13;
<b>              | "continue" ";"</b>&#13;
<b>              | "while" "(" &lt;exp&gt; ")" &lt;statement&gt;</b>&#13;
<b>              | "do" &lt;statement&gt; "while" "(" &lt;exp&gt; ")" ";"</b>&#13;
<b>              | "for" "(" &lt;for-init&gt; [&lt;exp&gt;] ";" [&lt;exp&gt;] ")" &lt;statement&gt;</b>&#13;
              | ";"&#13;
&lt;exp&gt; ::= &lt;factor&gt; | &lt;exp&gt; &lt;binop&gt; &lt;exp&gt; | &lt;exp&gt; "?" &lt;exp&gt; ":" &lt;exp&gt;&#13;
&lt;factor&gt; ::= &lt;int&gt; | &lt;identifier&gt; | &lt;unop&gt; &lt;factor&gt; | "(" &lt;exp&gt; ")"&#13;
&lt;unop&gt; ::= "-" | "~" | "!"&#13;
&lt;binop&gt; ::= "-" | "+" | "*" | "/" | "%" | "&amp;&amp;" | "||"&#13;
          | "==" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" | "="&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_151" aria-label="151"/>&lt;identifier&gt; ::= ? An identifier token ?&#13;
&lt;int&gt; ::= ? A constant token ?</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-17: The grammar with loops and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements</samp></p>&#13;
<p class="TX">I recommend writing a helper function to parse optional expressions. You can use this helper function to parse the two optional expressions in a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop header, plus expression statements and null statements. The helper function should let you specify which token marks the end of the optional expression; most of the optional expressions in the grammar are followed by a semicolon, but the third clause in a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop header is followed by a closing parenthesis.</p>&#13;
<aside class="box" aria-label="box-107"><p class="BoxTitle" id="box-107"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE PARSER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test your parser, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 8 --stage parse</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Your parser should successfully parse every test program in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_8/valid</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_8/invalid_semantics</samp><samp class="SANS_Futura_Std_Book_11">, and it should raise an error for every test program in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_8/invalid_parse</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h3 class="H1" id="sec4"><span id="h1-66"/><samp class="SANS_Futura_Std_Bold_B_11">Semantic Analysis</samp></h3>&#13;
<p class="TNI">The semantic analysis stage of your compiler currently performs one task: it resolves variable names. In this chapter, it will take on a completely new task: loop labeling. The loop labeling pass associates each <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement with its enclosing loop. More concretely, this pass assigns every loop statement a unique ID and annotates each <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement with the ID of its enclosing loop. If it finds a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement outside of a loop, it will throw an error. During TACKY generation, we’ll use these annotations to convert each <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement into a jump to the correct spot relative to its enclosing loop.</p>&#13;
<p class="TX">We’ll resolve variable names and label loops in two separate passes, traversing the whole program each time. Let’s start by extending the variable resolution pass to handle this chapter’s new statements; then we’ll implement the loop labeling pass.</p>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-47"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extending Variable Resolution</samp></h4>&#13;
<p class="TNI">You’ll need to extend <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp> to traverse the five new statements you added in this chapter. You’ll treat <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> loops just like <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements, processing every substatement and subexpression recursively. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_152" aria-label="152"/>Resolving <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements is even simpler; since they don’t have any substatements or subexpressions, you don’t have to do anything.</p>&#13;
<p class="TX">Resolving a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is a tiny bit more complicated because the loop header introduces a new variable scope. <a href="chapter8.xhtml#list8-18">Listing 8-18</a> demonstrates how to handle <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops in <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp>.</p>&#13;
<a id="list8-18"/>&#13;
<pre><code>resolve_statement(statement, variable_map):&#13;
    match statement with&#13;
<var>    </var>| <var>--snip--</var>&#13;
    | For(init, condition, post, body) -&gt;&#13;
        new_variable_map = copy_variable_map(variable_map)&#13;
        init = resolve_for_init(init, new_variable_map)&#13;
        condition = resolve_optional_exp(condition, new_variable_map)&#13;
        post = resolve_optional_exp(post, new_variable_map)&#13;
        body = resolve_statement(body, new_variable_map)&#13;
        return For(init, condition, post, body)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-18: Resolving a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp></p>&#13;
<p class="TX">We start by making a new copy of the variable map, just like we do at the beginning of a compound statement. Copying the map ensures that a variable declared in the loop header won’t be visible outside of the loop and that it won’t trigger a compiler error if it hides a variable from the outer scope.</p>&#13;
<p class="TX">Next, we process the initial clause with <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_for_init</samp>, which we’ll look at in a moment. We then traverse the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop’s controlling expression, final expression, and body, all using the new variable map. I won’t provide pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_optional_exp</samp>, which handles the optional controlling expression and final expression; it just calls <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> if the expression is present and does nothing if it’s absent.</p>&#13;
<p class="TX"><a href="chapter8.xhtml#list8-19">Listing 8-19</a> shows the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_for_init</samp>.</p>&#13;
<a id="list8-19"/>&#13;
<pre><code>resolve_for_init(init, variable_map):&#13;
    match init with&#13;
    | InitExp(e) -&gt; return InitExp(resolve_optional_exp(e, variable_map))&#13;
    | InitDecl(d) -&gt; return InitDecl(resolve_declaration(d, variable_map))</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-19: Resolving the initial clause of a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp></p>&#13;
<p class="TX">We resolve an expression or declaration in the initial clause exactly the same way we would resolve it if it appeared elsewhere in the program. If the clause is a declaration, calling <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_declaration</samp> will add the newly declared variable to the variable map so it’s visible throughout the rest of the loop.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-48"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Loop Labeling</samp></h4>&#13;
<p class="TNI">After resolving variables, we’ll traverse the program again, labeling each loop, <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement with an ID. Whenever we encounter a loop statement, we’ll generate a unique ID for it. Then, when we traverse the loop body, we’ll attach that same ID to any <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements <span role="doc-pagebreak" epub:type="pagebreak" id="pg_153" aria-label="153"/>we encounter. Let’s look at a few examples. In the next three listings, the markers <span class="CodeAnnotation" aria-label="annotation1">❶</span> and <span class="CodeAnnotation" aria-label="annotation2">❷</span> represent IDs attached to the AST. Although the loop labeling pass annotates the AST rather than source files, these listings are presented as source code for the sake of readability.</p>&#13;
<p class="TX"><a href="chapter8.xhtml#list8-20">Listing 8-20</a> illustrates how we’ll annotate a code fragment that contains two loops in succession.</p>&#13;
<a id="list8-20"/>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> while (1) {&#13;
    a = a - 1;&#13;
    if (a &lt; 0)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> break;&#13;
}&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> for (int b = 0; b &lt; 100; b = b + 1) {&#13;
    if (b % 2 == 0)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> continue;&#13;
    a = a * b;&#13;
}&#13;
return a;</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-20: Annotating</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements and their enclosing loops</samp></p>&#13;
<p class="TX">Each of the two loops in this listing gets its own ID. We annotate the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop with ID <span class="CodeAnnotation" aria-label="annotation1">❶</span> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop with ID <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Each <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement is annotated with the ID of its enclosing loop, so we annotate the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement with ID <span class="CodeAnnotation" aria-label="annotation1">❶</span> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement with ID <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">If several <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements are in the same enclosing loop, they’re all annotated with the same ID, as <a href="chapter8.xhtml#list8-21">Listing 8-21</a> demonstrates.</p>&#13;
<a id="list8-21"/>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> for (int i = 0; i &lt; 10; i = i + 1) {&#13;
    if (i % 2 == 0)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> continue;&#13;
    if (x &gt; y)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> continue;&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> break;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-21: Annotating multiple</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">break</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statements in the same loop</samp></p>&#13;
<p class="TX">Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop labeled <span class="CodeAnnotation" aria-label="annotation1">❶</span> is the enclosing loop of the two <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements and the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement, we annotate all three of those statements with ID <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">If a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement appears inside nested loops, we annotate it with the ID of its enclosing loop, which is the innermost loop. <a href="chapter8.xhtml#list8-22">Listing 8-22</a> illustrates how to annotate nested loops.</p>&#13;
<a id="list8-22"/>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> while (a &gt; 0) {&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> for (int i = 0; i &lt; 10; i = i + 1) {&#13;
        if (i % 2 == 0)&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> continue;&#13;
        a = a / 2;&#13;
    }&#13;
    if (a == b)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> break;&#13;
}</code></pre>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_154" aria-label="154"/>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-22: Annotating nested loops</samp></p>&#13;
<p class="TX">The outer <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop and inner <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop are labeled <span class="CodeAnnotation" aria-label="annotation1">❶</span> and <span class="CodeAnnotation" aria-label="annotation2">❷</span>, respectively. Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement appears in the inner loop, we annotate it with ID <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement is in the outer loop, so we annotate it with ID <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-49"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing Loop Labeling</samp></h4>&#13;
<p class="TNI">To implement this compiler pass, we pass the current loop ID along as an argument when we traverse the AST, much like we pass the variable map as an argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_statement</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>, and so on during the variable resolution pass. When we’re outside of a loop, the current ID is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>, or whatever your implementation language uses to indicate an absent value. When we hit a loop statement, we generate a new ID and annotate the statement with it. We then pass it along as the current ID when we traverse the loop body. When we hit a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement, we annotate it with the ID that was passed to us. The pseudocode in <a href="chapter8.xhtml#list8-23">Listing 8-23</a> illustrates how to annotate statements with loop IDs.</p>&#13;
<a id="list8-23"/>&#13;
<pre><code>label_statement(statement, current_label):&#13;
    match statement with&#13;
    | Break -&gt;&#13;
        if current_label is null:&#13;
            fail("break statement outside of loop")&#13;
        return <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> annotate(Break, current_label)&#13;
    | Continue -&gt;&#13;
        if current_label is null:&#13;
            fail("continue statement outside of loop")&#13;
        return <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> annotate(Continue, current_label)&#13;
    | While(condition, body) -&gt;&#13;
        new_label = <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> make_label()&#13;
        labeled_body = label_statement(body, new_label)&#13;
        labeled_statement = While(condition, labeled_body)&#13;
        return <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> annotate(labeled_statement, new_label)&#13;
    | <var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-23: The loop annotation algorithm</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">make_label</samp> helper function <span class="CodeAnnotation" aria-label="annotation3">❸</span> generates unique loop IDs; you can use the same helper function here that you use to generate unique labels in TACKY. The <samp class="SANS_TheSansMonoCd_W5Regular_11">annotate</samp> helper function takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp> AST node and a label and returns a copy of that AST node annotated with that label. Here, we use it to annotate the <samp class="SANS_TheSansMonoCd_W5Regular_11">Break</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Continue</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">While</samp> <span class="CodeAnnotation" aria-label="annotation4">❹</span> statements. I haven’t provided the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">annotate</samp> because it will depend on how exactly you represent loop annotations in your AST. I’ve also omitted the pseudocode to handle <samp class="SANS_TheSansMonoCd_W5Regular_11">DoWhile</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">For</samp>, and all the statements we added in earlier chapters. You can process <samp class="SANS_TheSansMonoCd_W5Regular_11">DoWhile</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">For</samp> essentially the same way as <samp class="SANS_TheSansMonoCd_W5Regular_11">While</samp>. To <span role="doc-pagebreak" epub:type="pagebreak" id="pg_155" aria-label="155"/>process any other kind of statement, call <samp class="SANS_TheSansMonoCd_W5Regular_11">label_statement</samp> recursively for every substatement, passing along the same value of <samp class="SANS_TheSansMonoCd_W5Regular_11">current_label</samp>.</p>&#13;
<p class="TX">Once you’ve updated the loop labeling pass, you’re ready to test out the whole semantic analysis stage.</p>&#13;
<aside class="box" aria-label="box-108"><p class="BoxTitle" id="box-108"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE SEMANTIC ANALYSIS STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Your semantic analysis stage should successfully process every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_8/valid</samp> <samp class="SANS_Futura_Std_Book_11">and fail on every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_8/invalid _semantics</samp><samp class="SANS_Futura_Std_Book_11">. The invalid test cases include some programs that we should reject during variable resolution and others that we should reject during loop labeling, because they use</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> <samp class="SANS_Futura_Std_Book_11">statements outside of loops. To test the semantic analysis stage, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 8 --stage validate</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">You might also want to write your own tests to verify that loops and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> <samp class="SANS_Futura_Std_Book_11">statements are labeled correctly.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h1-67"/><samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp></h3>&#13;
<p class="TNI">Next, we’ll convert each new statement to TACKY. We won’t change the TACKY IR in this chapter, because we can implement these statements with our existing TACKY instructions.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-50"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">break and continue Statements</samp></h4>&#13;
<p class="TNI">A <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement unconditionally jumps to some other point in the program, so we implement it with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> instruction. The same is true for <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements. The only question is where to jump to. The loop annotations we added in the last section help us answer that question.</p>&#13;
<p class="TX">Whenever we convert a loop statement to TACKY, we’ll emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> right after the instructions for the loop body. Any <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement in that loop can be implemented as a jump to that label, which I’ll call the <i>continue label</i>. We’ll emit another <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> as the final instruction for the whole loop; I’ll call this the <i>break label</i>.</p>&#13;
<p class="TX">We’ll derive these labels from the IDs we added during the loop annotation pass. For example, if a loop is labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">loop0</samp>, its break and continue labels might be <samp class="SANS_TheSansMonoCd_W5Regular_11">break_loop0</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue_loop0</samp>. Using this example naming scheme, we’d convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">Break</samp> AST node annotated with ID <samp class="SANS_TheSansMonoCd_W5Regular_11">loop0</samp> to the following TACKY instruction:</p>&#13;
<pre><code>Jump("break_loop0")</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_156" aria-label="156"/>We’d convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">Continue</samp> node with the same annotation to:</p>&#13;
<pre><code>Jump("continue_loop0")</code></pre>&#13;
<p class="TX">You don’t need to use this particular naming scheme (although your naming scheme must guarantee that these labels won’t conflict with any other labels in the TACKY program). The important point is that you can derive the same label when you convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement to TACKY as when you convert its enclosing loop to TACKY, because that statement and its enclosing loop are annotated with the same ID.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-51"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">do Loops</samp></h4>&#13;
<p class="TNI">We can execute the statement <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;body&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">while (</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;condition&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">);</samp> in three steps. First, we execute the loop body. Then, we evaluate the condition and compare the result to zero. Finally, if the result was not zero, we jump back to the beginning of the loop. <a href="chapter8.xhtml#list8-24">Listing 8-24</a> demonstrates how to implement these steps in TACKY.</p>&#13;
<a id="list8-24"/>&#13;
<pre><code>Label(start)&#13;
<var>&lt;instructions for body&gt;</var>&#13;
<var>&lt;instructions for condition&gt;</var>&#13;
v = <var>&lt;result of condition&gt;</var>&#13;
JumpIfNotZero(v, start)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-24: The TACKY instructions for a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">do</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp></p>&#13;
<p class="TX">We also need break and continue labels. The continue label goes between the body and the condition, and the break label goes at the very end, after <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfNotZero</samp>. Adding both of these labels gives us the complete TACKY for a <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> loop, as shown in <a href="chapter8.xhtml#list8-25">Listing 8-25</a>.</p>&#13;
<a id="list8-25"/>&#13;
<pre><code>Label(start)&#13;
<var>&lt;instructions for body&gt;</var>&#13;
<b>Label(continue_label)</b>&#13;
<var>&lt;instructions for condition&gt;</var>&#13;
v = <var>&lt;result of condition&gt;</var>&#13;
JumpIfNotZero(v, start)&#13;
<b>Label(break_label)</b></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-25: The TACKY instructions for a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">do</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop, with break and continue labels</samp></p>&#13;
<p class="TX">Now any <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements in the loop body will jump to the continue label, and any <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statements will jump to the break label. These labels are necessary only if a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement shows up somewhere in the loop body—otherwise, they won’t be used—but to keep things simple, we’ll always emit them. That way, we don’t need to figure out whether a loop contains <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_157" aria-label="157"/>&#13;
<h4 class="H2" id="sec11"><span id="h2-52"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">while Loops</samp></h4>&#13;
<p class="TNI">We’ll handle <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loops similarly to <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> loops, but in this case we’ll execute the condition before the loop body, then use <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> to exit the loop if the condition is false. We can convert the statement <samp class="SANS_TheSansMonoCd_W5Regular_11">while (</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;condition&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;body&gt;</samp> to the TACKY in <a href="chapter8.xhtml#list8-26">Listing 8-26</a>.</p>&#13;
<a id="list8-26"/>&#13;
<pre><code>Label(start)&#13;
<var>&lt;instructions for condition&gt;</var>&#13;
v = <var>&lt;result of condition&gt;</var>&#13;
JumpIfZero(v, end)&#13;
<var>&lt;instructions for body&gt;</var>&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> Jump(start)&#13;
Label(end)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-26: The TACKY instructions for a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">while</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp></p>&#13;
<p class="TX">Now let’s figure out where to put the break and continue labels. This time, we don’t need extra <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> instructions; we can reuse the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> instructions that are already present in <a href="chapter8.xhtml#list8-26">Listing 8-26</a>. We’ll put the break label in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> instruction at the end of this listing. It will be the target for both the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> instruction and any <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statements in the loop body.</p>&#13;
<p class="TX">Likewise, we’ll put the continue label in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Label</samp> instruction at the start of this listing. This has the same effect as putting the continue label just after the end of the loop body <span class="CodeAnnotation" aria-label="annotation1">❶</span>, because the instruction after the loop body is an unconditional jump that immediately takes us back to the start of the loop. Having <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements jump directly to the start of the loop lets them bypass that <samp class="SANS_TheSansMonoCd_W5Regular_11">Jump</samp> instruction, which makes them a little bit more efficient.</p>&#13;
<p class="TX"><a href="chapter8.xhtml#list8-27">Listing 8-27</a> shows where to use the break and continue labels when we convert <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loops to TACKY.</p>&#13;
<a id="list8-27"/>&#13;
<pre><code>Label(<b>continue_label</b>)&#13;
<var>&lt;instructions for condition&gt;</var>&#13;
v = <var>&lt;result of condition&gt;</var>&#13;
JumpIfZero(v, <b>break_label</b>)&#13;
<var>&lt;instructions for body&gt;</var>&#13;
Jump(<b>continue_label</b>)&#13;
Label(<b>break_label</b>)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-27: The TACKY instructions for a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">while</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop, with break and continue labels</samp></p>&#13;
<p class="TX">This TACKY is identical to <a href="chapter8.xhtml#list8-26">Listing 8-26</a>, except that it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">continue_</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">break_label</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-53"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">for Loops</samp></h4>&#13;
<p class="TNI">Our final task is to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops to TACKY. We’ll convert the statement <samp class="SANS_TheSansMonoCd_W5Regular_11">for (</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;init&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;condition&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;post&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;body&gt;</samp> into the TACKY in <a href="chapter8.xhtml#list8-28">Listing 8-28</a>, which includes the break and continue labels.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_158" aria-label="158"/>&#13;
<a id="list8-28"/>&#13;
<pre><code><var>&lt;instructions for init&gt;</var>&#13;
Label(start)&#13;
<var>&lt;instructions for condition&gt;</var>&#13;
v = <var>&lt;result of condition&gt;</var>&#13;
JumpIfZero(v, break_label)&#13;
<var>&lt;instructions for body&gt;</var>&#13;
Label(continue_label)&#13;
<var>&lt;instructions for post&gt;</var>&#13;
Jump(start)&#13;
Label(break_label)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 8-28: The TACKY instructions for a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp></p>&#13;
<p class="TX">First, we execute <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;init&gt;</samp>. Then, we execute the controlling expression, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;condition&gt;</samp>, and check whether the result is zero. If it is, we jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">Label(break _label)</samp> at the very end, without executing the loop body or the final expression. Otherwise, we execute the loop body followed by the final expression, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;post&gt;</samp>, then jump back to <samp class="SANS_TheSansMonoCd_W5Regular_11">Label(start)</samp> and start another loop iteration. We won’t execute <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;init&gt;</samp> again, since <samp class="SANS_TheSansMonoCd_W5Regular_11">Label(start)</samp> comes after <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;init&gt;</samp>. Note that the continue label appears at the end of the loop body, just before <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;post&gt;</samp>, and the break label appears at the very end of the loop, where it does double duty as the target of the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> instruction and any <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statements.</p>&#13;
<p class="TX">Next, let’s break down how to handle each of the three clauses in the loop header. The first clause can be an expression, a declaration, or nothing. If it’s a declaration or expression, we’ll handle it the same way as a declaration or expression outside of a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop. If it’s absent, we won’t emit any instructions.</p>&#13;
<p class="TX">The second clause is the controlling expression. If this expression is present, we’ll convert it to TACKY exactly like the controlling expressions in <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">do</samp> loops. If it’s absent, the C standard says that this expression is “replaced by a nonzero constant” (section 6.8.5.3, paragraph 2). We could just use a nonzero constant in the conditional jump:</p>&#13;
<pre><code>JumpIfZero(Const(1), break_label)</code></pre>&#13;
<p class="TX">But this instruction doesn’t do anything; <samp class="SANS_TheSansMonoCd_W5Regular_11">Const(1)</samp> will never equal zero, so we’ll never jump. Instead, we’ll leave out the <samp class="SANS_TheSansMonoCd_W5Regular_11">JumpIfZero</samp> instruction entirely, since that’s a more efficient way to produce the same behavior.</p>&#13;
<p class="TX">Finally, we need to handle the third clause, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;post&gt;</samp>. If it’s present, we’ll convert it to TACKY; if it’s absent, we won’t emit any instructions.</p>&#13;
<aside class="box" aria-label="box-109"><p class="BoxTitle" id="box-109"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE WHOLE COMPILER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Now you’re ready to test out your whole compiler. To compile and execute this chapter’s test cases, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 8</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_159" aria-label="159"/>&#13;
<h3 class="H1" id="sec13"><span id="h1-68"/><samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: switch Statements</samp></h3>&#13;
<p class="TNI">You have the option of implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> statements in this chapter. To support these statements, you’ll need to make significant changes to the semantic analysis stage. First, you’ll need to change the loop annotation pass, because <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statements can break out of <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statements as well as loops. You can’t, however, use a <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement inside a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement, so this pass will need to treat <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements differently from <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statements.</p>&#13;
<p class="TX">You’ll need additional analysis, probably in a separate compiler pass, to collect the cases that appear inside each <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement. To generate the TACKY for a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement, you’ll need a list of all the cases in that statement. However, that information isn’t immediately available in the AST. The cases in a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement may be nested several layers deep, or the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement body may not include any cases at all. You’ll need to attach that information to the AST in a more usable form.</p>&#13;
<p class="TX">Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--switch</samp> flag to enable the tests for <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statements:</p>&#13;
<pre><code>$ <b>./test_compiler </b><var><b>/path/to/your_compiler</b></var><b> --chapter 8 --switch</b></code></pre>&#13;
<p class="TX">Or enable every extra credit test with the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp> flag, as usual.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h3 class="H1" id="sec14"><span id="h1-69"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">In this chapter, you implemented your last set of control-flow statements. You added support for three different loop statements, plus <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements. You implemented a new semantic analysis pass to associate <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements with their enclosing loops, and you saw how to convert each of these complex structures into a list of TACKY instructions.</p>&#13;
<p class="TX">Although we’re done with control-flow <i>statements</i>, you’ll add support for one more control-flow <i>expression</i> in the next chapter: function calls. You’ll learn about the calling conventions that dictate how function calls work in assembly and write a simple type checker. Best of all, you’ll end the chapter by compiling “Hello, World!”</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>