- en: '**10'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RECONSTRUCTING USER DESKTOPS AND LOGIN ACTIVITY**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is often necessary to reconstruct user login activity to know when a person
    has logged in to a system, how they logged in, what they were doing, and when
    they finally logged out. This chapter explains various aspects of shell and desktop
    user logins, and describes various artifacts that are interesting from a digital
    forensics perspective.
  prefs: []
  type: TYPE_NORMAL
- en: We are primarily focused on *human* interaction with the computer. Other system
    “users” are running daemons or starting programs, but they are part of normal
    system operation and are covered in other sections of the book. The human use
    of peripheral devices, such as printers, external drives, and so on, is also covered
    separately in [Chapter 11](ch11.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux Login and Session Analysis**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On early Unix systems, users logged in via a physical terminal or a terminal
    emulated by a PC, both of which connected over an RS232 serial line. Remote connections
    were possible using analog modems over dial-up or leased lines from the local
    phone company. As TCP/IP became popular, users logged in over the network using
    telnet or rlogin. Users entered their login name and password, and if correct,
    the system ran scripts to set up their environments and provide a command line
    prompt. When the user finished, they logged out, and the terminal was reset to
    prepare for the next login.
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, people log in using the local console or securely over a network. The
    most common ways to log in to Linux systems are:'
  prefs: []
  type: TYPE_NORMAL
- en: Graphical logins through a local *display manager* (usually workstations and
    laptops)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell logins on a local virtual console (usually physical server access)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell logins remotely over a network using secure shell (SSH) (usually remote
    server access)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell logins over local serial lines (often used by embedded systems or Linux-based
    IoT devices)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 10-1](ch10.xhtml#ch010fig01) shows a simplified overview of these user
    login methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch10fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-1: System initialization and user login process*'
  prefs: []
  type: TYPE_NORMAL
- en: The first three of the above listed login methods are primarily intended for
    human interaction. The last login method is mostly used as an interface for configuration,
    firmware updates, or diagnostic programs, and it may use internal pins directly
    on the circuit board. Serial line logins can be useful in the forensic analysis
    of embedded and IoT devices where storage cannot be removed and imaged like a
    regular computer.
  prefs: []
  type: TYPE_NORMAL
- en: Remote desktop connections like VNC are not listed here because they are usually
    connecting to an already logged-in desktop or remotely accessing the display manager.
    In such cases, the remote desktop can be analyzed like a local graphical login.
    Remote desktop access is explained at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections describe how login sessions work and identify interesting
    digital forensic artifacts that may be available.
  prefs: []
  type: TYPE_NORMAL
- en: '***Seats and Sessions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To analyze human user activity on a Linux system, we must understand the concepts
    of seats, users, and sessions.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *seat* is typically composed of one or more screens, a keyboard and mouse
    (unless the screen is a touchscreen), audio devices, video cameras, and other
    human interactive peripherals attached to a local workplace. The default seat
    name is `seat0`, and it’s recognized on system boot. We can view it in the systemd
    journal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A Linux system can be configured to have additional seats when a PC has multiple
    keyboards and screens for more than one person (though this is somewhat rare).
  prefs: []
  type: TYPE_NORMAL
- en: We can view a seat’s device components on a live system with loginctl seat-status
    seat0; however, this information is not available in a postmortem forensic investigation
    and must be inferred or reconstructed from the logs. See the sd-login(3) man page
    for more information on seats.
  prefs: []
  type: TYPE_NORMAL
- en: The term *user* can refer to either a person or a process. A human user is a
    person with a user account on the computer, which corresponds to a traditional
    Unix username and numeric user ID (UID). System processes (which are not people)
    also run under specified usernames and UIDs. When performing a forensic analysis
    of a system, it is important to differentiate between human and system user activity.
    A human user will log in from a seat or remotely with SSH or some other remote
    access method. Non-human (system process) users are typically daemons started
    from systemd or by some other system user.
  prefs: []
  type: TYPE_NORMAL
- en: A *session* is the duration of a user login and can take place on a physical
    seat or over a network connection such as SSH. After a successful login, a user
    is given a session ID, and the session is cleanly terminated at logout. Sessions
    are logged and managed by systemd-logind. Systemd, together with the display manager,
    can also facilitate *fast user switching*. This means that multiple users can
    be logged in to the same seat at the same time and can securely switch control
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The word “session" has many meanings in computing. There are system login
    sessions, desktop sessions, application login sessions, browser sessions, TCP
    sessions, SSL/TLS sessions, and others. When performing forensic analysis work
    and writing forensic reports, make sure the use of the word session is clearly
    understood.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Early Unix systems were expensive, and accounting logs were developed to facilitate
    billing of users or departments. Administrators needed to know when a user logged
    in, when they logged off, and possibly other usage information. On modern Linux
    systems, this is largely managed by systemd, but some traditional files still
    record the state and history of user login sessions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***/var/log/wtmp*** | History of successful logins and logouts |'
  prefs: []
  type: TYPE_TB
- en: '| ***/var/log/btmp*** | History of failed login attempts |'
  prefs: []
  type: TYPE_TB
- en: '| ***/var/log/lastlog*** | Most recent user logins |'
  prefs: []
  type: TYPE_TB
- en: '| ***/var/run/utmp*** | Current users logged in (only on running systems) |'
  prefs: []
  type: TYPE_TB
- en: When performing a postmortem forensic analysis of a modern Linux system, anything
    stored temporarily on pseudo-filesystems will not be available (pseudo-filesystems
    are stored in memory). The */var/run/utmp* will not be available for analysis
    unless it is recovered from a memory image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `utmpdump`^([1](footnotes.xhtml#ch10foot_01)) tool can be used to view
    the raw contents of *wtmp* and *btmp* (and *utmp* on a live system). Here are
    some example entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The output fields (from left to right and following wrapped lines) are listed
    here with a description:^([2](footnotes.xhtml#ch10foot_02))
  prefs: []
  type: TYPE_NORMAL
- en: '***type*** Type of record (see list of types below)'
  prefs: []
  type: TYPE_NORMAL
- en: '***pid*** PID of login process (agetty, sshd, or 0 for reboots and shutdowns)'
  prefs: []
  type: TYPE_NORMAL
- en: '***id*** Terminal name suffix (last four characters of the tty; blank or tildes
    if none)'
  prefs: []
  type: TYPE_NORMAL
- en: '***user*** Username (failed or successful) or action (shutdown, reboot, and
    so on)'
  prefs: []
  type: TYPE_NORMAL
- en: '***line*** Device name of the tty (tilde if none)'
  prefs: []
  type: TYPE_NORMAL
- en: '***host*** A hostname or IP address string (or kernel info for some types)'
  prefs: []
  type: TYPE_NORMAL
- en: '***addr*** An IP address (IPv4 or IPv6, if available)'
  prefs: []
  type: TYPE_NORMAL
- en: '***time*** Timestamp of record'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the record type and the program writing to *wtmp* or *btmp*, the
    contents of the fields may be used for different information. For example, with
    types 1 or 2, the *user* field is used to log a shutdown or reboot, and the *host*
    field logs the kernel version. Also notice how *id* and *line* are similar, as
    are *host* and *address*. Any program can write to *wtmp* or *btmp* and can choose
    the fields it wants to use. Although this seems redundant, it increases the amount
    of log information saved from a variety of different programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following record type numbers are stored in *wtmp* and *btmp* (and */var/run/utmp*):'
  prefs: []
  type: TYPE_NORMAL
- en: '**0**   Invalid data'
  prefs: []
  type: TYPE_NORMAL
- en: '**1**   Change in run level or equivalent systemd target'
  prefs: []
  type: TYPE_NORMAL
- en: '**2**   Time of boot'
  prefs: []
  type: TYPE_NORMAL
- en: '**3**   Timestamp before a clock change'
  prefs: []
  type: TYPE_NORMAL
- en: '**4**   Timestamp after a clock change'
  prefs: []
  type: TYPE_NORMAL
- en: '**5**   Process spawned by init'
  prefs: []
  type: TYPE_NORMAL
- en: '**6**   Login prompt provided'
  prefs: []
  type: TYPE_NORMAL
- en: '**7**   Successful user login'
  prefs: []
  type: TYPE_NORMAL
- en: '**8**   Process terminated (logout)'
  prefs: []
  type: TYPE_NORMAL
- en: For more information, see the utmp(5) man page.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*During a forensic examination, look for possible passwords in the* btmp *file.
    If a user accidentally typed their password at the user login prompt, it will
    be logged here.*'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to `utmpdump` are `utmpr`^([3](footnotes.xhtml#ch10foot_03)) (on
    GitHub at *[https://github.com/m9/lastlog/](https://github.com/m9/lastlog/)*)
    and a one-line Perl script to dump *wtmp* files (*[https://www.hcidata.info/wtmp.htm](https://www.hcidata.info/wtmp.htm)*.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the */var/log/lastlog* file contains the most recent login information
    for each user on a system. This is a sparse binary file that can be read on a
    running system with the `lastlog` command. Running `lastlog` on a separate Linux
    examination host will produce incorrect results because it reads the local password
    file, so an offline forensic tool must be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following three-line Perl script (*lastlog.pl*) parses offline *lastlog*
    files from suspect Linux systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Running it on an offline examination machine produces output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The output starts with the numeric UID followed by a timestamp. The last two
    columns are the line (or terminal) used and the hostname or IP address (if it
    exists). This same information is in the *wtmp* log and should match.
  prefs: []
  type: TYPE_NORMAL
- en: The `lslogins` tool dumps information about *wtmp*, *btmp*, and *lastlog* in
    a single table (with the `--output-all` flag). It’s also possible to specify which
    offline copies of the files to use on an analysis machine. However, running this
    command will still read the */etc/passwd* and */etc/shadow* on your local analysis
    machine, creating incorrect output.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Be careful when running tools on your analysis machine that are intended for
    live systems. In many cases, the resulting data will not be about the suspect
    drive, but from your own analysis machine.*'
  prefs: []
  type: TYPE_NORMAL
- en: Some machines will have a */var/log/tallylog* file. This file maintains the
    state for `pam_tally`, a PAM module that counts attempted logins on a live system,
    possibly blocking on too many failed attempts. See the pam_tally2(8) man page
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '***Shell Login***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Users can log in to a Linux system with a shell on a local console^([4](footnotes.xhtml#ch10foot_04))
    or remotely with SSH. After successful authentication and authorization, a program
    called a shell is started and the user can interact with the system. This shell
    program interprets and executes commands typed by the user, or read from a text
    file run as a shell script.
  prefs: []
  type: TYPE_NORMAL
- en: The most common shell program on Linux systems is Bash; however, zsh and fish
    also have active user communities. The default shell is defined in the last field
    of the user’s */etc/passwd* entry. This section focuses on Bash, but the forensic
    examination principles should apply to any shell (refer to the specific shell’s
    man pages for help).
  prefs: []
  type: TYPE_NORMAL
- en: A shell can be *interactive* (for users) or *non-interactive* (for scripts).
    When invoked as a *login* shell (usually the first shell upon login), several
    additional startup scripts are run. [Figure 10-1](ch10.xhtml#ch010fig01) earlier
    in the chapter shows the typical process for getting a login shell.
  prefs: []
  type: TYPE_NORMAL
- en: The local Linux console is a text mode interface via the PC monitor and keyboard.
    Over this physical interface, multiple “virtual consoles” are available, which
    can be switched using a hotkey (ALT-FN or CTRL-ALT-FN) or the `chvt` program.
  prefs: []
  type: TYPE_NORMAL
- en: Systemd-logind starts the agetty^([5](footnotes.xhtml#ch10foot_05)) program
    when a virtual console becomes active. The agetty daemon sets up the terminal
    and displays a login prompt. After a username is entered, it’s passed to the login
    program that asks for a password. If the username and password are correct and
    the user is authorized, a shell is started under the user’s UID and group ID (GID).
  prefs: []
  type: TYPE_NORMAL
- en: Logging in to a shell over a network has been possible with telnet and rlogin
    since network protocols were introduced. Today, remote logins are typically done
    with more secure alternatives like SSH.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the SSH daemon (sshd) listens on TCP port 22\. When incoming network
    connections are received, a cryptographic channel is established, the user is
    authenticated, and a shell is started. More details about analyzing SSH are provided
    later in the chapter, but [Figure 10-1](ch10.xhtml#ch010fig01) given earlier provides
    an overview of a network login.
  prefs: []
  type: TYPE_NORMAL
- en: Linux systems use PAM libraries for multiple login activities. PAM modules check
    passwords, authenticate users, determine authorization, and perform other pre-login
    checks. One important function on modern Linux systems is the starting of a systemd
    user instance (if it hasn’t started already). On successful login, PAM registers
    the session with systemd-logind, which starts the systemd user instance. The systemd
    user instance has a `default` `.target` that starts various unit files (user daemons,
    such as D-Bus) for the user before they are finally given a shell command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shell login activity can be observed in the journal. This example shows an
    SSH login, followed by a logout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice how in the first three lines the SSH daemon takes the connection and
    engages `pam`, which then involves systemd. SSH logins may also be found in syslog
    files like */var/log/auth.log*, or in other traditional Unix locations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Shell Startup Files**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'After a successful login, the shell starts and several scripts are run to set
    up the environment. Some system scripts are configured by the system administrator
    and run by every user, but users can also create and modify additional scripts
    in their home directories. Shell startup scripts (using Bash as an example) typically
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/etc/profile*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/profile.d/**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*~/.bash_profile*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/bash.bashrc*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*~/.bashrc*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The profile scripts are run only in a login shell (normally the first shell
    when the user logs in). The other scripts (**rc*) are run on every invocation
    of the shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'On exit or logout, additional scripts are run, which typically include:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/etc/bash.bash_logout*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*~/.bash_logout*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These files should be examined for changes deviating from the defaults. In particular,
    user customization in the home directory may be interesting. In the case of a
    system-wide compromise, malicious modifications also may be made to the */etc/*
    files.
  prefs: []
  type: TYPE_NORMAL
- en: The environment variables, especially those that were explicitly set, can be
    interesting, and may reveal programs used or custom configuration. The `PATH`
    variable may point to an additional directory where the user’s own scripts and
    binaries are located. The `VISUAL` and `EDITOR` variables indicate the default
    editor used and, depending on the editor, may point to additional cache and history
    information about the files edited.
  prefs: []
  type: TYPE_NORMAL
- en: 'Systemd and PAM provide additional locations to set environment variables at
    login:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/etc/security/pam_env.conf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/environment*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/environment.d/*.conf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/usr/lib/environment.d/*.conf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*~/.config/environment.d/*.conf*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find more information in the environment.d(5) and pam_env.conf(5) man
    pages. Variables stored in */run/* or modified in the memory of a running system
    will not be available in a postmortem forensic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**Shell History**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Most shells can save a history of commands typed so the user can search and
    recall commands, instead of retyping them. This command history is especially
    interesting from an investigative point of view because they were explicitly typed
    by a human user. In the case of a compromised login, however, the command history
    could also be from a malicious script.
  prefs: []
  type: TYPE_NORMAL
- en: Shell history is configured using environment variables (starting with `HIST*`)
    that specify the file used, the number of commands to save, timestamp format,
    and other history features offered by the particular shell. The default Bash history
    file is *~/.bash_history*. This file contains a simple list of commands typed.
    Organizations wanting more forensic readiness may set the `HISTTIMEFORMAT` variable
    in Bash to include timestamps in the history. A shell history file may exist for
    every user, including root.
  prefs: []
  type: TYPE_NORMAL
- en: 'An examination of the shell history gives insight into the activity and character
    of the human user. Items, activity, and behavior you can observe or look for in
    the shell history include:'
  prefs: []
  type: TYPE_NORMAL
- en: Skill level (simple commands or mistakes indicating a beginner)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revealed filenames from files created, edited, or deleted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commands modifying system configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually setting up tunnels, relays, or VPNs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting local or remote filesystems or encrypted containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing local daemons or functionality on remote hosts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passwords typed (accidentally or as parameters on a command line)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revealing other IP addresses or hostnames from running `ping`, `nslookup`, `ssh`,
    or other network tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information from text accidentally copy/pasted into a terminal window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any sequence of commands revealing intent or train of thought
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typed commands are stored in memory and written to the history file when the
    shell exits. A history file may contain lines from multiple shell instances that
    exited at different times, so the commands saved may not be in chronological order.
  prefs: []
  type: TYPE_NORMAL
- en: If the history file has been explicitly disabled, deleted, zeroed, or symlinked
    to */dev/null*, it indicates an awareness of security or higher skill level of
    a suspected user or an attacker. For an excellent SANS talk on Bash history forensics,
    see *[https://youtu.be/wv1xqOV2RyE/](https://youtu.be/wv1xqOV2RyE/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***X11 and Wayland***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The X11 window system was the de facto standard graphical interface for Unix
    and the natural choice for the Linux community. The most popular implementation
    of X11 on Linux today is [X.Org](http://X.Org), and many new extensions and enhancements
    have been added since forking from the XFree86 project.
  prefs: []
  type: TYPE_NORMAL
- en: '[X.Org](http://X.Org) connects applications to input devices (keyboard, mouse,
    touchscreen, and so on) and to output devices like graphics cards and monitors.
    In addition to [X.Org](http://X.Org), a separate window manager is needed to manage
    the windows (placement, decorations, resizing, movement, and so on). On top of
    the window manager, a desktop environment typically provides an additional “look
    and feel” or even a completely separate graphical shell. Each of these components
    and subcomponents may store information useful in a digital forensic context.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the [X.Org](http://X.Org) configuration is done automatically; however,
    manual tweaks and customization are typically found in */etc/X11/xorg.conf* or
    files in the */etc/X11/xorg.conf.d/* directory. A log of [X.Org](http://X.Org)
    activity is created by default and written to */var/log/Xorg.0.log* (in some cases,
    it may be located in the user’s *.local/share/xorg/Xorg.0.log*). The contents
    of the file describe the graphics hardware, monitors, input devices, default screen
    resolution, and more. Some examples are shown here, taken from such a log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Other instances of the log may exist, such as a */var/log/Xorg.1.log* file.
    Unlike rotated logfiles, this is not an older version, but represents the display
    that was logged (0, 1, and so on). Older versions of the log may also exist and
    have an *.old* filename extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Xorg* logfiles contain “markers” used to describe the log entries:'
  prefs: []
  type: TYPE_NORMAL
- en: (–)     Probed
  prefs: []
  type: TYPE_NORMAL
- en: (**)     From config file
  prefs: []
  type: TYPE_NORMAL
- en: (==)     Default setting
  prefs: []
  type: TYPE_NORMAL
- en: (++)     From command line
  prefs: []
  type: TYPE_NORMAL
- en: (!!)     Notice
  prefs: []
  type: TYPE_NORMAL
- en: (II)     Informational
  prefs: []
  type: TYPE_NORMAL
- en: (WW)     Warning
  prefs: []
  type: TYPE_NORMAL
- en: (EE)     Error
  prefs: []
  type: TYPE_NORMAL
- en: (NI)     Not implemented
  prefs: []
  type: TYPE_NORMAL
- en: (??)     Unknown
  prefs: []
  type: TYPE_NORMAL
- en: If a user was working with X11 and later switched to Wayland, this log may still
    exist and would provide information from an earlier point in time. You can find
    more information about [X.Org](http://X.Org) in the Xorg(1) man page.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-2](ch10.xhtml#ch010fig02) shows X11’s basic architecture. The evolution
    of desktop computing obsoleted many of X11’s original design decisions, and a
    more modern windowing system was needed. Wayland was designed to be the replacement,
    and most Linux distributions are moving toward Wayland-based desktops.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch10fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-2: X11 Architecture*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Window managers are used in X11 environments to manage windows. Functionally,
    the window manager is just another X11 client. Most distros and graphical environments
    have a default window manager. Some popular X11 window mangers include:'
  prefs: []
  type: TYPE_NORMAL
- en: Mutter (GNOME default)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KWin (KDE default)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Xfwm4 (Xfce default)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Openbox (LXDE default)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fluxbox, FVWM, and tiling window managers like i3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each window manager will have its own configuration and logging artifacts. See
    the associated documentation for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Wayland uses a different model than X11 and combines window management together
    with compositing and other functionality. [Figure 10-3](ch10.xhtml#ch010fig03)
    shows Wayland’s architecture. The differences between X11 and Wayland can be seen
    by comparing the two architectures. As a side note, Wayland is not exclusive to
    Linux and is used in other operating systems like BSD.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch10fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-3: Wayland Architecture*'
  prefs: []
  type: TYPE_NORMAL
- en: More information about the architectural differences between X11 and Wayland
    is available at *[https://wayland.freedesktop.org/architecture.html](https://wayland.freedesktop.org/architecture.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: Wayland compositors are becoming more popular. Mutter and KWin both support
    Wayland (in addition to X11), and power users are using specialty compositors
    like Sway (an i3 clone for Wayland) or Hikari (originally developed for FreeBSD).
    Each compositor has configuration and logging capability that can be examined,
    but the forensic analysis of individual compositors is outside the scope of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: '***Desktop Login***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Typical Linux desktop and laptop systems have a graphical login screen. This
    screen is sometimes called the *greeter* and is provided by a daemon called the
    *display manager*. The display manager sets up the graphics on the local machine
    and provides pre-login options (for example, language, screen brightness, accessibility,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The display manager is independent of the graphical environment used, and it
    may allow users to choose which graphical environment they want to use after login.
    The most popular display managers today are GDM (the GNOME default) and SDDM (the
    KDE Plasma default).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can determine which desktop manager is used by examining the systemd *display-manager.service*
    unit file, which is a symbolic link to the actual display manager. In the following
    example, the default target is symlinked to the graphical target and specifies
    (`Wants=`) the display manager service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The display manager service is symlinked to the GDM service, which starts (`ExecStart=`)
    the GDM daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the configuration, the GDM display manager may save logs in */var/log/gdm/*
    or leave traces in the systemd journal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SDDM display manager may save logs in */var/log/sddm.log* and also log
    activity in the systemd journal (search for `sddm`). After a successful login,
    the SDDM display manager stores session logs in the user’s home directory that
    can be examined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Other logs for either Wayland or X11 sessions may be present that are related
    to the desktop environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon successful login via the display manager, multiple processes are started.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: User instance of systemd (`systemd --user`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Desktop session manager (`gnome-session`, `plasma_session`, `xfce4-session`,
    and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Window manager (if running X11)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Systemd user units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XDG session autostart items (**.desktop* files)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D-Bus session instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agents (polkit, gpg, ssh, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The desktop or graphical shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting daemons for the desktop environment (settings, Pulseaudio or PipeWire,
    Bluetooth, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each component will be running under the user’s UID. Configuration, logs, cache,
    and other related data is typically found in the user’s XDG directories. (Refer
    back to [Figure 10-1](ch10.xhtml#ch010fig01) for an overview of the graphical
    login process.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The systemd *user* instance (not to be confused with the systemd *system* instance)
    is responsible for activating the units needed to bring up and supervise the login
    session. The systemd user instance is started when PAM registers the session with
    systemd-logind. The user unit files are found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/usr/lib/systemd/user/**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/systemd/user/**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*~/.config/systemd/user/**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each directory overrides the previous. The first two directories are the vendor
    and system administrator defaults. The last directory contains the custom configuration
    in the user’s home directory. In a forensic examination, these directories can
    be checked for deviations from the expected defaults, or any custom additions
    added by the system administrator, user, or malicious actor. The system-wide configuration
    of the systemd user instance is found in the */etc/systemd/user.conf* and */etc/systemd/logind.conf*
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the systemd user instance, the desktop session manager will
    bring up the user’s login environment with its own startup files. The XDG desktop
    definition files (**.desktop*) provide the information needed to bring up a user’s
    desktop environment. The XDG standards also define common locations for storing
    desktop configuration files. These files are found in the autostart directories,
    and files specific to the desktop environment are read and applications are launched
    accordingly. The system default and user-defined directory locations (user-created
    files have priority) are located here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/etc/xdg/autostart/**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*~/.config/autostart/**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Window managers and desktop shells may also have their own *autostart* directories
    containing desktop files that start relevant components. The XDG Desktop Entry
    Specification can be found at *[https://specifications.freedesktop.org/desktop-entry-spec/](https://specifications.freedesktop.org/desktop-entry-spec/)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Definition files have a **.desktop* extension and describe how the desktop
    component should be brought up. The following example shows several entries illustrating
    the contents of a definition file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, an application (GNOME Keyring, discussed later in this chapter) is described.
    Files have multilingual content for names and comments, and the context in which
    the definition file is valid is specified. The program and flags to execute are
    also defined.
  prefs: []
  type: TYPE_NORMAL
- en: Systemd and XDG both provide similar functionality in setting up desktop environments.
    Because of the widespread use of XDG and a commitment to compatibility by the
    major distros, both of them can be examined. Many desktop environments are transitioning
    XDG desktop startup activity to systemd, which is a complex process requiring
    backward compatibility with the XDG **.desktop* files. If a **.desktop* file contains
    the line `X-GNOME-Hidden UnderSystemd=true`, it means that the GNOME session manager
    should ignore the file, as it is being started by systemd.^([6](footnotes.xhtml#ch10foot_06))
  prefs: []
  type: TYPE_NORMAL
- en: 'Some session managers can save and restore session state about the desktop.
    These files can be examined to determine which windows may have been open in a
    previously saved state. The location of the saved session information is different
    for each desktop environment, and common locations include:'
  prefs: []
  type: TYPE_NORMAL
- en: '*~/.cache/sessions/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*~/.config/session/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*~/.config/gnome-session/saved-session/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*~/.config/ksmserverrc*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sessions may be saved automatically on exit or explicitly requested by the user.
    Depending on the desktop environment and its configuration, the session manager
    may save a simple list of open programs and also include the window sizes and
    locations on-screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fast User Switching**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Multiple users can be logged in to separate graphical environments at the same
    time by starting their sessions in different virtual consoles. Switching between
    users can be done with a hotkey (CTRL-ALT-FN), the `chvt` command, or a *switch
    user* option in the current graphical environment. User switching may indicate
    multiple people using the same machine or one person using multiple identities
    on the same machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also known as *fast user switching*, a menu option is typically provided in
    the graphical environment (if there are multiple users) that locks the screen
    and jumps to the display manager where another user can be authenticated. Depending
    on the display manager, this transition might be found in the journal. The following
    example log shows a new GDM session (a login screen) started due to a user switch,
    and terminated less than a minute later after the second user successfully authenticated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Observing when a display manager is started without a user logging out indicates
    a possible user switch. This information provides a starting point to examine
    surrounding logs and filesystem timestamps that identify which users were active
    before and after the switch. A user switch can also be initiated from a locked
    screen by another person.
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication and Authorization**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a user wants to access a Linux system, a number of checks are made before
    granting that access. The system looks for an indicator that the person really
    is who they claim to be and that they are indeed authorized to access the resources
    they want. Today, this is typically done with PAM. PAM can provide authentication
    and authorization controls between the user and the system, both at login and
    throughout the user login session.
  prefs: []
  type: TYPE_NORMAL
- en: 'PAM configuration is in the *pam.conf* file and the */etc/pam.d/* directory.
    PAM also logs the successes and failures of attempted authentication and authorization.
    Here are several examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines ➊ show logs from an SSH login and logout over a network.
    The next two lines ➋ show logs from a login and logout on a local virtual console
    (text login prompt). The last two lines ➌ show a login and logout using GDM (a
    typical graphical login screen).
  prefs: []
  type: TYPE_NORMAL
- en: '***User, Group, and Password Files***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Linux adopted the concepts and implementation of usernames and groups from Unix.
    Traditionally, these usernames and groups were listed in several files in the
    */etc/* directory.^([7](footnotes.xhtml#ch10foot_07)) The password file */etc/passwd*
    (which doesn’t contain passwords anymore) lists the defined users on the system
    with some additional information. The shadow file */etc/shadow* contains hashed
    passwords for each (enabled) user. The group file */etc/group* lists the groups
    and their members. Each user has a default group assigned (typically named after
    themselves) and can be added to other groups for access to files and resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format of the *passwd*, *shadow,* and *group* files are described in the
    passwd(5),^([8](footnotes.xhtml#ch10foot_08)) shadow(5), and group(5) man pages.
    These files are plaintext, have one line per user/group, and have multiple fields
    per line. The following shows some excerpts from a *passwd* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The fields (separated by colons) of the *passwd* file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Login name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password field (`x` indicates a password is stored in */etc/shadow*; `!` indicates
    password access is locked; a blank field means no password is required and applications
    may choose to allow access)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numerical user ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numerical group ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comment field (often the user’s full name)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User’s home directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User’s shell program (the `nologin` program simply rejects login attempts)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The */etc/passwd* file has historically been a prime target of theft on early
    Unix systems. Anyone stealing this file had a list of users and encrypted/ hashed
    passwords that could be potentially cracked. This weakness led to the development
    of the shadow password file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The */etc/shadow* file is not readable by regular users because it contains
    the (encrypted) password and other potentially sensitive information. Some examples
    from a shadow file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The fields (separated by colons) of the *shadow* file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Login name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypted password (if not a valid password string, password access is blocked)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date of last password change (days since January 1, 1970)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Days until a user is allowed to change their password (if empty, the user can
    change password any time)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Days until a user is required to change their password (if empty, the user never
    has to change password)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password warning period (number of days before password expires)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password grace period (number of days user can change password after expiration)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Account expiration date (days since January 1, 1970)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unused field reserved for future use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The date of last password change may be interesting when constructing a forensic
    timeline of user activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The encrypted password field has three dollar sign ($)–separated fields. These
    fields are the encryption algorithm used, the encryption salt (to make cracking
    more difficult), and the encrypted password string. The encryption algorithms
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **1** | MD5 |'
  prefs: []
  type: TYPE_TB
- en: '| **2a** | Blowfish |'
  prefs: []
  type: TYPE_TB
- en: '| **5** | SHA-256 |'
  prefs: []
  type: TYPE_TB
- en: '| **6** | SHA-512 |'
  prefs: []
  type: TYPE_TB
- en: See the crypt(3) man page for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The */etc/group* file stores information about Unix groups, including a list
    of group members. Some excerpts from a typical *group* file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The fields (separated by colons) of the group file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Group name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password (if used, the password information is stored in a gshadow file)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numerical group ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comma-separated list of members
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A default group for each user is defined in the */etc/passwd* file. The */etc/
    group* file can provide additional group configuration. For example, notice how
    the *sudo* group lists users allowed to use the `sudo` program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users and groups are simply human-readable names mapped to numbers: the user
    ID (UID) and group ID (GID). The *passwd* and *group* files define the name-to-number
    assignment.^([9](footnotes.xhtml#ch10foot_09)) There is no requirement to have
    an assigned user or group name for a particular UID or GID number. To illustrate,
    observe the following sequence of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a file is created using the `touch` command. The user and group
    is then changed using `chown` to numeric values that are not defined in the password
    or group files. You can see in the directory listing that the unknown user is
    `5555` and the unknown group is `6666`. From a forensics perspective, files with
    unassigned users and groups are interesting because they may indicate a previously
    deleted user/group or an attempt to hide malicious activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we find files without assigned UIDs or GIDs? On a live system, the
    `find` command has the options `-nouser` and `-nogroup`, which can be used to
    scan a system for files that don’t have an existing user or group assigned. On
    a postmortem drive image, forensic software may have the ability to identify such
    files (using EnCase EnScript, for example). Identified files and directories can
    be analyzed in more detail to answer certain questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How and why were the files created?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happened to the original user and group?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are the file timestamps interesting or relevant?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does this UID or GID appear in any logs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On a live system, are there any running processes with the same UID and GID?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several ways users and groups can be created and deleted. A system
    administrator can manually edit the *passwd*, *shadow*, and *group* files to add
    or remove assigned UIDs or GIDs. Command line tools like `useradd` or `groupadd`
    can be used. Distros may also provide graphical configuration tools that can add
    users and groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a user or group is created or modified, some tools make backup copies
    of the password, group, shadow files, and others. The backup copies have the same
    name with a hyphen (-) appended, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*/etc/passwd-*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/shadow-*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/gshadow-*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/group-*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/subuid-*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These backup copies are normally identical to the original files. If a file
    is different, it was possibly modified manually or using alternative tools not
    supporting this backup convention. Examining the differences may reveal users
    that have been deleted, added, or modified previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *passwd* file contains both human users and system users. When analyzing
    human user activity, it is important to know the difference. The numeric ID fields
    in the *passwd* and *group* can help make this distinction in a forensic investigation.
    The following list describes a few standard users, groups, and allocated numeric
    ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '**0** root (LSB required)'
  prefs: []
  type: TYPE_NORMAL
- en: '**1** daemon (LSB required)'
  prefs: []
  type: TYPE_NORMAL
- en: '**2** bin (LSB required)'
  prefs: []
  type: TYPE_NORMAL
- en: '**0–100** Allocated by the system'
  prefs: []
  type: TYPE_NORMAL
- en: '**101–999** Allocated by applications'
  prefs: []
  type: TYPE_NORMAL
- en: '**1000–6000** Regular (human) user accounts'
  prefs: []
  type: TYPE_NORMAL
- en: '**65534** nobody'
  prefs: []
  type: TYPE_NORMAL
- en: Deviations from these standard UID and GID ranges are interesting from the perspective
    of a forensic investigator because they indicate possible manual modification
    or non-standard creation of users and groups.
  prefs: []
  type: TYPE_NORMAL
- en: Most Linux distros create new users starting with UID 1000 and also create default
    groups with the same GID number. However, the UID and GID of a user doesn’t have
    to be the same number. If a user’s UID is different from the GID, it suggests
    that an additional group was manually created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The creation of a new user or group might be found in the shell history of
    the root user (`useradd fred`, for example) or in the shell history of a regular
    user (`sudo useradd fred`). If the user was created in a GUI tool, it may appear
    in the journal as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, GNOME’s `gnome-control-center` (the Settings program) asked
    the `accounts-daemon` (part of AccountsService; *[https://www.freedesktop.org/wiki/Software/AccountsService/](https://www.freedesktop.org/wiki/Software/AccountsService/)*)
    to create a user (`fred`). This D-Bus service accesses and configures local user
    accounts using system tools like `useradd` or `groupadd`. AccountService was originally
    developed for GNOME but can be used by any distro.
  prefs: []
  type: TYPE_NORMAL
- en: 'The deletion of a user simply means that the defined user and ID record in
    the shadow, password, and group files has been deleted. The following is an example
    found in the journal (deleting `fred` from the previous example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Deleting a user or group does not automatically delete the files owned by those
    users. Unless explicitly deleted, the files will still exist and appear with the
    former numeric IDs of the deleted users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some forensic programs or password recovery tools are able to attempt recovery
    of encrypted passwords stored in shadow files. Here is an example of John the
    Ripper recovering a password from the */etc/shadow* entry extracted for the user
    *sam*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `john` cracking tool discovers the password is *canada* from a wordlist
    or dictionary-based attack. John the Ripper leaves traces of password cracking
    activity, including previously recovered passwords, in the *~/.john/* directory
    of the user who ran it.
  prefs: []
  type: TYPE_NORMAL
- en: '***Elevated Privileges***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A typical user account on a Linux system is expected to have enough privileges
    to do “normal work,” but not enough to cause damage to the system, disrupt other
    users, or access files that are meant to be private. Only one user, root (UID
    0), has privileges to do everything. Several mechanisms allow regular users to
    elevate privileges to perform certain authorized tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The traditional Unix `su` (substitute user) command allows a command to be
    executed with the privileges of another user or group (root is the default if
    nothing is specified). Failed and successful use of the `su` command appears in
    the system log as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: By default, all users are permitted to use the `su` command. See the su(1) man
    page for more information.
  prefs: []
  type: TYPE_NORMAL
- en: The `sudo` command provides more granularity than `su` and can be configured
    to allow some users to execute specific commands only. The `sudo` configuration
    is found in the */etc/sudoers* file or in files in the */etc/sudoers.d/* directory.
    A *sudo* group may also contain a list of authorized users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Failed and successful uses of the `sudo` command by authorized users is logged
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Attempts to use `sudo` by unauthorized users (those users who are not considered
    “administrators”) will also appear in the system log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: A search for `sudo` activity can reveal information about compromised systems
    or abuse by regular users, including the privileged commands attempted.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a user runs `sudo` for the first time, they may be presented with a warning
    message or “lecture” about the risks and responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If sudo is configured to display the message once only (the default), a zero-length
    file named after the user is created in the */var/db/sudo/lectured/* directory.
    The creation timestamp on this file indicates the first time a user ran the `sudo`
    command. See the sudo(8) and sudoers(5) man pages for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method of privilege escalation uses a `setuid` flag on an executable
    file indicating the program should execute with the UID of the file’s owner. Use
    of this flag is not logged (although the `setuid` program itself may generate
    logs). The `ls -l` of a `setuid` program has an “s” in the permission information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In a forensic investigation, a search can be made to find all *setuid* files.
    In particular, *setuid* files that are not part of any official distro software
    package can be interesting; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a suspicious *setuid* file was found in */tmp/* and should
    be examined further.
  prefs: []
  type: TYPE_NORMAL
- en: All *setuid* files pose a risk to the system, and can be exploited if they contain
    vulnerabilities. If non-privileged users can exploit a `setuid` program, they
    may gain unauthorized access or execute arbitrary code as another user (like root
    for example). Files can also have the `setgid` flag set, causing programs to run
    as the file’s group.
  prefs: []
  type: TYPE_NORMAL
- en: 'An API provided by the polkit (also called PolicyKit) framework can also escalate
    privileges over D-Bus. The polkit daemon (`polkitd`) listens for requests and
    takes appropriate action. The authorization actions are configured using *.rules*
    and *.policy* files located in the */etc/polkit-1/* or */usr/share/ polkit-1/*
    directories. When making authorization decisions, `polkitd` checks these rules
    and policies and logs activity to the journal, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a user tries to reboot a system, polkit asks for authentication,
    and the user fails to provide it.
  prefs: []
  type: TYPE_NORMAL
- en: The `pkexec` command line tool is part of the polkit software package and functions
    similarly to `sudo`. For more information about polkit use over D-Bus, see the
    polkit(8) and polkitd(8) man pages.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux kernel also provides *capabilities* that can extend and reduce privileges
    of a user at a more granular level. Systemd has options to define capabilities
    in unit files. See the capabilities(7) and systemd.unit(5) man pages for more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: '***GNOME Keyring***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The GNOME desktop environment has a credential storage mechanism called the
    GNOME Keyring. Users can create multiple keyrings, and each keyring can store
    multiple passwords. Frontend tools interact with a backend daemon that creates
    and manages the files containing the passwords.
  prefs: []
  type: TYPE_NORMAL
- en: The default location of the keyring files is *~/.local/share/keyrings/* (previously
    *~/.gnome2/keyrings/*). Filenames are the same as the keyring names, with spaces
    replaced with underscores. If multiple keyrings exist and a default is specified,
    a file called *default* will contain the name of the default keyring. [Figure
    10-4](ch10.xhtml#ch010fig04) shows an overview of GNOME Keyring.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch10fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-4: GNOME Keyring data flow*'
  prefs: []
  type: TYPE_NORMAL
- en: In some installations, the `pam_gnome_keyring` PAM module may use a keyring
    for logins. In that case, the login password is the same as the password of the
    default `gnome-keyring`. If a keyring is not given a password on creation, the
    keyring file will be stored in unencrypted form, with passwords and other information
    visible in a readable plaintext file format.
  prefs: []
  type: TYPE_NORMAL
- en: The **.keyring* files can be copied to another system for analysis. The decrypted
    keyring files contain interesting data from a forensics perspective, including
    the creation timestamp of the keyring, the creation and modification timestamps
    for each password entry, and the description and password for each password entry.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t have the password, brute-force attempts can be made to crack it
    using a recovery tool that supports the GNOME Keyring format. If you do have the
    password to unlock a keyring, there are several ways to extract information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to view all the information is simply to set a blank password
    for the keyring, meaning that the resulting keyring file contents will be saved
    unencrypted. Another way to extract information is using `dump-keyring0` `-format`,
    which is included in the GNOME Keyring source code,^([10](footnotes.xhtml#ch10foot_010))
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Using this method, you can see information about the keyring and the individual
    entries. The password entries contain the password, creation time, and last modified
    time.
  prefs: []
  type: TYPE_NORMAL
- en: '*Seahorse* is the primary graphical tool in the GNOME desktop environment for
    managing passwords and keys. Seahorse can create and manage password keyrings
    (via the gnome-keyring-daemon) and can also create and manage other keys such
    as SSH and GNU Privacy Guard (GPG). Support for PKCS11 certificates is under development
    and uses the file *user.keystore*. [Figure 10-5](ch10.xhtml#ch010fig05) shows
    a screenshot of Seahorse.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch10fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-5: Seahorse Passwords and Keys manager tool*'
  prefs: []
  type: TYPE_NORMAL
- en: '***KDE Wallet Manager***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The KDE desktop environment has a credential storage mechanism called KWallet,
    in which users can store multiple passwords and web form data. The wallet is protected
    with a separate password. KDE-integrated apps are able to use KWallet to store
    passwords and other sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: Wallets managed using the KWallet Manager operate through the `kwalletd` daemon,
    which is started on demand by the wallet manager. Wallets can be encrypted using
    the Blowfish algorithm or with the user’s GPG keys. [Figure 10-6](ch10.xhtml#ch010fig06)
    on the following page shows an overview of the KDE Wallet system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default location for wallet files is *~/.local/share/kwalletd/*, and files
    have the same name as the wallet. There are two files per wallet: one with a **.kwl*
    extension containing the encrypted data and one with a **.salt* extension containing
    salt data to strengthen against password-cracking attempts. The **.kwl* files
    have a header that determines the version and type of wallet file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first 12 bytes of the wallet file are always the same and signify that
    it is a KDE wallet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The 13th and 14th bytes are the major and minor version numbers and the 15th
    and 16th bytes specify the encryption and hash algorithms, respectively (see *[https://github.com/KDE/kwallet/blob/master/src/runtime/kwalletd/backend/backendpersisthandler.cpp](https://github.com/KDE/kwallet/blob/master/src/runtime/kwalletd/backend/backendpersisthandler.cpp)*
    for more information). If the 15th byte of a **.kwl* file is 0x02, it’s GPG; if
    the 15th byte is 0x00 or 0x03, it’s a version of Blowfish.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch10fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-6: KWallet data flow*'
  prefs: []
  type: TYPE_NORMAL
- en: Some Linux distributions create a default wallet called *kdewallet*, and users
    can create and manage additional wallets using frontend tools like `kwallet-query`
    or `kwalletmanager5`, shown in [Figure 10-7](ch10.xhtml#ch010fig07).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch10fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-7: KWallet Manager Tool*'
  prefs: []
  type: TYPE_NORMAL
- en: You can copy these files to another Linux machine to analyze them using the
    same wallet manager utilities.
  prefs: []
  type: TYPE_NORMAL
- en: If a password-recovery tool supports the Blowfish format of KWallet files, attempts
    to brute-force the password can be made.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the login password and KWallet password might be the same—for
    example, when `pam_kwallet` is used. If GPG is used, the KWallet password is the
    same as the user’s GPG key password. Also check the logs for `kwalletd5` or `kwalletmanager5`,
    as sometimes error messages may appear during the use of the wallet manager, providing
    a timestamp linked to evidence of use.
  prefs: []
  type: TYPE_NORMAL
- en: '***Biometric Fingerprint Authentication***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recent versions of Linux desktops offer biometric fingerprint authentication
    if the machine has compatible hardware. The fprint project (*[https://fprint.freedesktop.org/](https://fprint.freedesktop.org/)*)
    provides Linux support for various fingerprint-reading devices, which can be used
    for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user must enroll fingerprints before they can be used. The enrollment process
    saves fingerprint information to files (a single file for each finger). The files
    are located in the */var/lib/fprint/* directory, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This directory path is constructed from the username (`sam`), and the manufacturer
    (`synaptics`) and USB device number or serial number (`45823e114e26`) of the fingerprint-reading
    device. The filenames of enrolled fingers are saved as numbers. The associated
    numbers for each finger are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1    Left thumb
  prefs: []
  type: TYPE_NORMAL
- en: 2    Left index finger
  prefs: []
  type: TYPE_NORMAL
- en: 3    Left middle finger
  prefs: []
  type: TYPE_NORMAL
- en: 4    Left ring finger
  prefs: []
  type: TYPE_NORMAL
- en: 5    Left little finger
  prefs: []
  type: TYPE_NORMAL
- en: 6    Right thumb
  prefs: []
  type: TYPE_NORMAL
- en: 7    Right index finger
  prefs: []
  type: TYPE_NORMAL
- en: 8    Right middle finger
  prefs: []
  type: TYPE_NORMAL
- en: 9    Right ring finger
  prefs: []
  type: TYPE_NORMAL
- en: 10    Right little finger
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the fingerprint objects is documented at the project team’s
    website, including useful information for a forensic examination.
  prefs: []
  type: TYPE_NORMAL
- en: The fingerprint files contain information about the fingerprint reader, the
    username, the date of enrollment, and possibly the data from the scanned finger.
    Depending on the fingerprint reader hardware, these files may differ. Some readers
    will store the fingerprint data in the device itself and only save metadata in
    the files.
  prefs: []
  type: TYPE_NORMAL
- en: 'A PAM module (*pam_fprintd*) and PAM configuration file (*gdm-fingerprint*
    for example) facilitates fingerprint scanning for authentication. This PAM module
    also logs successful fingerprint authentication, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, biometric authentication was used to log in to a machine from GDM.
  prefs: []
  type: TYPE_NORMAL
- en: Biometric authentication is especially interesting from a forensics perspective.
    It identifies physical attributes of a person rather than knowledge of a password
    that can be stolen or shared. However, biometric authentication can also be forced
    (coercion, blackmail, physical force, or other threats) or “stolen” while someone
    is sleeping or unconscious. Other methods of using copies of fingerprints on certain
    materials have been shown to work with some fingerprint readers.^([11](footnotes.xhtml#ch10foot_011))
  prefs: []
  type: TYPE_NORMAL
- en: '***GnuPG***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In 1991, Philip Zimmermann created Pretty Good Privacy (PGP) to provide the
    public with a simple tool for strong encryption to protect files and messages.
    It was initially free and open source but later became a commercial product. Concerns
    over patents and commercialization led to the creation of the OpenPGP standard,
    originally described in RFC 2440 (currently RFC 4880 and RFC 5581). In 1999, an
    independent implementation of Open- PGP was developed under the name GNU Privacy
    Guard (GnuPG or GPG), a software project that is actively developed to this day.
  prefs: []
  type: TYPE_NORMAL
- en: GPG is a popular form of encryption and used by email programs, office programs,
    software package integrity verification tools, password managers,^([12](footnotes.xhtml#ch10foot_012))
    and other programs in need of interoperable cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: Most Linux distributions include GPG software by default for the purpose of
    verifying the signatures of software packages. Frontend tools like Seahorse and
    KGpg make GPG key generation and management easy for Linux users. Decrypting GPG-encrypted
    files is a challenge that forensic investigators regularly face, together with
    other encryption challenges.
  prefs: []
  type: TYPE_NORMAL
- en: The `gpg` program is compiled with default options, but will look for a system-wide
    configuration file (*/etc/gnupg/gpgconf.conf* ) and the default location of the
    user configuration file (*~/.gnupg/gpg.conf* ). [Figure 10-8](ch10.xhtml#ch010fig08)
    provides an overview of GPG.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch10fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-8: GnuPG data flow*'
  prefs: []
  type: TYPE_NORMAL
- en: The key files consist of public and private key pairs belonging to the user
    and any other keys that have been added to the public keyring. On newer systems,
    the user’s public keys are located in *~/.gnupg/pubring.kbx* (previous versions
    stored them in *~/.gnupg/pubring.gpg*).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the private keys, it can be interesting to examine which public
    keys have been added to a keyring. This file can be read without the secret key
    and may contain information of forensic interest. For example, any public keys
    added by the user will be visible together with the date created, name, email
    address, and other information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `gpg` binary does not have an option to specify which file to use, but
    the `GNUPGHOME` environment variable can be set to point to a copy of the *.gnupg*
    directory if you have moved the files to a separate analysis machine, as demonstrated
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Other GPG commands for listing or extracting keys and information can also be
    used in this way. See the gpg(1) man page for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Some forensic programs or password-recovery tools are able to attempt recovery
    of GPG private keys. John the Ripper also supports brute-forcing GPG encrypted
    files.
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux Desktop Artifacts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with the forensic examination of Windows or Macintosh computers, the Linux
    desktop can be of significant interest to forensic investigators. Analyzing digital
    traces from various graphical components allows you to reconstruct past activity
    and user behavior. This section focuses on finding useful forensic artifacts on
    a graphical Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: '***Desktop Settings and Configuration***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most desktops today use a database for storing configuration data. This database
    can be used by any application, and configuration settings can be shared between
    different programs.
  prefs: []
  type: TYPE_NORMAL
- en: '**GNOME configuration**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Desktop environments based on GNOME 3 and GNOME 40^([13](footnotes.xhtml#ch10foot_013))
    store settings and configuration data using the GSettings API, which in turn uses
    the dconf configuration system. The `dconf-service` program is activated over
    D-Bus whenever an application or desktop component wants to modify configuration
    settings (for performance, reading settings is done directly from the files, without
    D-Bus). Dconf is conceptually similar to the Windows Registry, where data is stored
    in a hierarchical tree with keys and values.
  prefs: []
  type: TYPE_NORMAL
- en: The desktop configuration utilities like GNOME Control Center (see [Figure 10-9](ch10.xhtml#ch010fig09)
    on the following page) or GNOME Tweaks read and write settings to the dconf system
    (the `dconf-editor` tool can be used to see all settings). Any applications built
    with the glib library are also able to use the dconf system to store configuration
    information.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch10fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-9: GNOME Control Center*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the typical tools (GNOME Control Center, Gnome Tweaks, `gsettings`,
    `dconf-editor`) for viewing dconf configuration also operate using D-Bus on a
    live system, they are not suitable for use in a postmortem examination. Therefore,
    we must examine the files where configuration data is stored on the filesystem.
    All the dconf settings that deviate from the defaults (that is, the user or application
    made changes) are stored in a single file: *~/.config/dconf/user*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This file uses a binary database format known as GNOME Variant (gvdb). The
    database can be extracted using an offline reader found here: *[https://github.com/chbarts/gvdb/](https://github.com/chbarts/gvdb/)*.
    The `reader` tool dumps the contents of any gvdb file, including GNOME configuration
    databases; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we see a variety of desktop configuration information that
    might be found in the dconf database file. The hierarchical tree structure of
    the configuration can be seen in paths (*/org/gnome/. . .*) and the contents on
    the line below. From this example, the configuration that is interesting from
    a forensics perspective includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Favorite apps listed on the GNOME dash (the dock revealed by clicking Activities)
    ➊
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A webcam used by the cheese program (cheese is a webcam photo app: *[https://wiki.gnome.org/Apps/Cheese](https://wiki.gnome.org/Apps/Cheese)*)
    ➋'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The file location of the desktop background picture (likely taken with the webcam)
    ➌
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most recent Bluetooth devices, including MAC address, device description,
    and timestamp ➍
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user-configured default search engine (DuckDuckGo) in the Epiphany web browser
    ➎
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-defined proxy settings, including the protocol (SOCKS), TCP port number,
    and proxy host ➏
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any application can save settings via the GSettings API, and they will be stored
    in the dconf database files. In addition to the gvdb *user* file, system-wide
    equivalent dconf databases may be found in */etc/dconf/db/**. User-defined configuration
    data has priority over system configuration or other configuration databases (profiles).
  prefs: []
  type: TYPE_NORMAL
- en: The configuration information saved depends on an application’s developer. As
    shown in the previous example, configuration information can include any persistent
    information desired, including history of files opened, bookmarks, timestamps
    of various events, remote servers and account names, previously attached devices,
    previous calendar notifications, and much more information that could be useful
    in a forensic investigation. See the dconf(7) man page for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '**KDE Configuration**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The KDE desktop manages user configuration changes with KConfig Modules (KCMs).^([14](footnotes.xhtml#ch10foot_014))
    These configuration changes are stored as plaintext files in the user’s *.config/*
    directory, with the filename usually ending in *rc*. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the user’s KDE/Plasma configuration changes that deviate from
    the system defaults are written into files. These files can be from any applications
    that integrate with KDE/Plasma.
  prefs: []
  type: TYPE_NORMAL
- en: 'The files have a basic *ini*-style format that is easy to understand, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here the user has configured a personal cookie policy that includes explicitly
    rejecting cookies from certain sites.
  prefs: []
  type: TYPE_NORMAL
- en: '**Other Desktop Configurations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Desktop environments and applications based on GNOME 2 store settings and configuration
    data using the GConf system. GConf is now deprecated, but some applications may
    still use it. The configuration data is stored using readable text files in XML
    format. The user-defined gconf files are located in *~/.config/gconf/** and system-wide
    files are in */etc/gconf/**.
  prefs: []
  type: TYPE_NORMAL
- en: Other desktop environments, window managers, and graphical components may save
    configuration data in files or databases in the user XDG standard directories
    (*~/.config/*, *~/.local/share/*) or as hidden files in the home directory (*~/.**).
    Close examination of the user home directories may reveal additional configuration
    specific to a desktop environment or component not respecting the XDG base directory
    standard.
  prefs: []
  type: TYPE_NORMAL
- en: '***Desktop Clipboard Data***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Early X11 systems had very simple copy/paste mechanisms where selected text
    could be pasted using the middle mouse button into whatever window had focus (the
    selected text was not saved). The Inter-Client Communication Conventions Manual
    (ICCCM) standards called this the “PRIMARY” selection and added an additional
    “CLIPBOARD” for text that was saved in memory and could be pasted at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Modern desktop environments introduced clipboard management systems for multiple
    items that were stored persistently across logins. These clipboard managers are
    implemented as user daemons, plug-ins, or tray applets that coordinate the copying
    of text and choosing what to paste.
  prefs: []
  type: TYPE_NORMAL
- en: Most desktop environments have a default clipboard manager, but users may choose
    to install other stand-alone clipboard manager programs. This section describes
    the analysis and extraction of clipboard data from the most common clipboard managers.
  prefs: []
  type: TYPE_NORMAL
- en: The KDE desktop provides the Klipper clipboard manager. By default, the last
    seven copied items are remembered and saved to the file *~/.local/ share/klipper/history2.lst*.
    The file has a short header, and clipboard entries are separated by the word `string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file can be viewed with a hex editor or text editor capable of 16-bit character
    widths. The following `sed` command can provide a quick-and-dirty list of saved
    clipboard entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The header ends with a version number, and the lines following are the history
    of items copied into the clipboard. You can also use the `strings` command (maybe
    with `-el`), but the list will appear unformatted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Distributions with the GNOME desktop environment may have different clipboard
    managers. These are available as plug-ins or separate programs, and some distros
    don’t install a clipboard manager by default. The following example shows the
    Clipboard Indicator extension for GNOME. The default history size is 15 items,
    which are stored in the *~/.cache/clipboard -indicator@tudmotu.com/registry.txt*
    file, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple JSON file and can be read with any text editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clipman is a plug-in for the Xfce panel and is embedded in the panel bar across
    the top or bottom of the desktop. By default, 10 items are stored in the *~/.cache/xfce4/clipman/textsrc*
    file. The items are stored in a readable format, and each item is separated by
    a semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Everything in `texts=` is on a single line. Copied text with multiple lines
    is separated with a newline character `\n`.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is Lubuntu, which uses Qlipper by default and stores clipboard
    data in *~/.config/Qlipper/qlipper.ini*.
  prefs: []
  type: TYPE_NORMAL
- en: Many clipboard managers are available for Linux. Each distro makes its own decision
    on what to use, and you need to determine which clipboard system is in use and
    where the data might be stored.
  prefs: []
  type: TYPE_NORMAL
- en: '***Desktop Trash Cans***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The computer desktop metaphor also introduced the concept of trash cans that
    allow a user to easily recover files that were discarded. [freedesktop.org](http://freedesktop.org)
    defines a standard for implementing trash cans on Linux desktop systems.^([15](footnotes.xhtml#ch10foot_015))
    The standard refers to moving files to the trash as *trashing* and unlinking from
    the filesystem as *erasing*. Adherence to this standard lies not so much with
    the distros or even the desktops, but primarily with the file managers.
  prefs: []
  type: TYPE_NORMAL
- en: The desktop or file manager can display a trash icon where people can see trashed
    files, recover them, or delete them from the filesystem (that is, empty the trash).
    Depending on the type of storage media and filesystem, files deleted from the
    trash might still be recoverable using forensic tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default file managers for GNOME, KDE, Xfce, and LXDE are Nautilus, Dolphin,
    Thunar, and PCManFM, respectively. These file managers (and others) follow the
    trash specification. When files and directories are moved to the trash, they are
    moved to another location on the filesystem, and the information needed to recover
    them is saved. The typical location of the trash is *~/.local/share/Trash/* in
    the user’s home directory, which contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '***files/*** The directory where trashed files and directories are moved. Unless
    entire directories are trashed, the *files/* directory is flat with no additional
    structure.'
  prefs: []
  type: TYPE_NORMAL
- en: '***info/*** A directory containing **.trashinfo* files for every deleted file
    or directory. These files contain the original location of the trashed item and
    a timestamp of when it was moved to the trash.'
  prefs: []
  type: TYPE_NORMAL
- en: '***directorysizes*** When a directory is trashed, some file managers update
    the *directorysizes* file with the name and size of the directory trashed together
    with a timestamp (Unix epoch) of when it was moved.'
  prefs: []
  type: TYPE_NORMAL
- en: '***expunged/*** GNOME gvfs may create an expunged directory for deleting files
    from the trash. This is not part of the standard and doesn’t always appear.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a typical trash folder structure containing a trashed
    file (*helloworld.c*) and trashed directory (*Secret_Docs/*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The **.trashinfo* and *directorysizes* file contents are readable plaintext.
    The *directorysizes* file contains one line for every deleted directory (in addition
    to the **.trashinfo* file).
  prefs: []
  type: TYPE_NORMAL
- en: 'No additional meta information is kept about the contents of trashed directories—only
    the size. The *.trashinfo* and *directorysizes* are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Trash folders (other than a user’s home Trash) can exist on removable storage
    (like USB sticks), mounted network shares, and other locations using a *.Trash/*
    or *.Trash-UID/* directory (where UID is the numeric ID of the user) at the top
    of the mounted directory. The Trash specification does not require systems to
    support this, but many file managers do.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing trash folders on any operating system is standard in forensic investigations.
    When a deletion attempt is made, deletion timestamps exist, and an original location
    is revealed where more relevant files might be found.
  prefs: []
  type: TYPE_NORMAL
- en: '***Desktop Bookmarks and Recent Files***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Identifying bookmarks (sometimes called “favorites") and recently used items
    on the desktop is a typical part of a forensic examination. On Linux desktops,
    bookmarks and recently used files, or “recents,” are managed with the same mechanism.
    Recent documents can also be thought of as dynamically created bookmarks.
  prefs: []
  type: TYPE_NORMAL
- en: The *xbel* file format refers to the XML Bookmark Exchange Language (see *[http://pyxml.sourceforge.net/topics/xbel/](http://pyxml.sourceforge.net/topics/xbel/)*
    and *[https://www.freedesktop.org/wiki/Specifications/desktop-bookmark-spec/](https://www.freedesktop.org/wiki/Specifications/desktop-bookmark-spec/)*).
    These are not limited to office documents and pictures; they may also contain
    other files that were opened by applications or file managers (zip files, for
    example).
  prefs: []
  type: TYPE_NORMAL
- en: Bookmarks and information about recent files can be found in several standard
    locations on a Linux system with an *.xbel* extention. Examples include *.local/share/recently-used.xbel*
    and *.local/user-places.xbel* found in the user’s home directory. These files
    may also have backup copies (**.bak*) containing previously bookmarked items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows a single entry (there can be multiple entries) in a recently
    used file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, the file *Conference.pdf* was saved to a temporary location by the Thunderbird
    mail client. Information about the file type and timestamps are also saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example shows an entry in the *user-places.xbel* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, the folder */home/sam/KEEPOUT* is bookmarked (“add to places”) in KDE’s
    Dolphin file manager. The timestamp refers to the date added or when the properties
    of the bookmark were changed (name, icon, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some recent file data is stored in **.desktop* files in the *.local/share/Recent
    Documents/* directory; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, the *PFI_cover-front-FINAL.png* image file (the cover art from my last
    book) was recently opened by the Ristretto application. These desktop files contain
    no timestamps and the filesystem timestamp may indicate the creation date.
  prefs: []
  type: TYPE_NORMAL
- en: The aforementioned bookmarking methods were designed to be shared across applications,
    but individual applications may have their own implementation of storing bookmarks
    and recent documents. In a forensic examination, the list of installed programs
    may be analyzed for application-specific artifacts. Often these are stored in
    the user’s *.cache/* directory.
  prefs: []
  type: TYPE_NORMAL
- en: '***Desktop Thumbnail Images***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When Linux desktops started to grow in popularity, graphical applications were
    developing their own way of managing thumbnail images (smaller versions of the
    original) for quick previews. Today this is standardized by [freedesktop.org](http://freedesktop.org)
    and used by most modern applications that need thumbnail functionality. This means
    that thumbnails created by one application can be reused by another application
    because they are all stored in the same place and in the same format. The specification
    for Linux desktop thumbnails can be found at *[https://www.freedesktop.org/wiki/Specifications/thumbnails/](https://www.freedesktop.org/wiki/Specifications/thumbnails/)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thumbnails are typically stored in *~/.cache/thumbnails/* in several directories.
    Three possible subdirectories store thumbnail images: *large/*, *normal/*, and
    *fail/*. These contain different sizes (usually 256×256 or 128×128) of thumbnail
    images and also failed attempts to create a thumbnail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard dictates that all thumbnail files must be saved in PNG format
    and contain metadata about the original file. The possible metadata stored in
    the thumbnail images includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Thumb::URI    URI of the original file (required)
  prefs: []
  type: TYPE_NORMAL
- en: Thumb::MTime    Modification time of the original file (required)
  prefs: []
  type: TYPE_NORMAL
- en: Thumb::Size    Size of the original file
  prefs: []
  type: TYPE_NORMAL
- en: Thumb::Mimetype    The file MIME type
  prefs: []
  type: TYPE_NORMAL
- en: Description    Descriptive text about thumbnail contents
  prefs: []
  type: TYPE_NORMAL
- en: Software    Information about software that created the thumbnail
  prefs: []
  type: TYPE_NORMAL
- en: Thumb::Image::Width    Width (pixels) of the original image
  prefs: []
  type: TYPE_NORMAL
- en: Thumb::Image::Height    Height (pixels) of the original image
  prefs: []
  type: TYPE_NORMAL
- en: Thumb::Document::Pages    Number of pages in the original document
  prefs: []
  type: TYPE_NORMAL
- en: Thumb::Movie::Length    Length (seconds) of the original video
  prefs: []
  type: TYPE_NORMAL
- en: date:create    The creation timestamp of the thumbnail file
  prefs: []
  type: TYPE_NORMAL
- en: date:modify    The modification date of the thumbnail file (updated if the original
    changes)
  prefs: []
  type: TYPE_NORMAL
- en: The thumbnail filename is created using the MD5 hash of the URI of the original
    file location (without a trailing newline). For example, if the original file
    URI is *file:///home/username/cats.jpg*, the thumbnail filename will be *14993c875146cb2df70672a60447ea31.png*.
  prefs: []
  type: TYPE_NORMAL
- en: Failed thumbnails are sorted by the program that failed and contain a blank
    PNG file with as much metadata about the original file as possible. The timestamp
    of the PNG saved in the fail directory is the time it failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows thumbnails found in a user’s *~/.cache/* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Using any PNG analysis tool reveals more information inside these files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the ImageMagick `identify` tool is used to extract metadata
    from one of the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The first two timestamps refer to the creation and last modification times of
    the thumbnail PNG (it will be updated if the original image changes). The `Thumb::MTime:`
    property is the last modified timestamp (in Unix epoch format) of the original
    file.^([16](footnotes.xhtml#ch10foot_016)) The `Software:` property is the program
    that created the thumbnail. In this case, it was from KDE while using the Dolphin
    file manager. The `Thumb::Mimetype:`, `Thumb::Size:`, and `Thumb::URI:` properties
    reveal the image type, size, and location of the original file. The thumbnail
    is a smaller version of the original, as shown in [Figure 10-10](ch10.xhtml#ch010fig010).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch10fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-10: Recovered thumbnail example*'
  prefs: []
  type: TYPE_NORMAL
- en: The removal of thumbnail files is best effort. Some file managers may delete
    the thumbnail when the original file is deleted. Some “cleaner” tools exist that
    purge cached files. Users could also manually delete the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Some older applications might use the *~/.thumbnails* directory to store thumbnail
    image files.
  prefs: []
  type: TYPE_NORMAL
- en: '***Well-Integrated Desktop Applications***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the early days of X11 window managers, standard widget libraries were used
    to create a unified appearance across windows (same button styles, scrollbar styles,
    and so on). Desktop environments have taken this unified “look and feel” further
    to include tightly integrated applications. These apps don’t just look similar,
    they also behave in a similar manner, are able to communicate with one another
    (usually via D-Bus), and can share configuration. These apps are sometimes called
    *well-integrated* applications and are developed as part of a desktop environment
    project. Here are several examples of project teams along with links to lists
    of their apps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'GNOME: *[https://wiki.gnome.org/Apps/](https://wiki.gnome.org/Apps/)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'KDE: *[https://apps.kde.org/](https://apps.kde.org/)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Xfce: *[https://gitlab.xfce.org/apps/](https://gitlab.xfce.org/apps/)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LXDE: *[https://wiki.lxde.org/](https://wiki.lxde.org/)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical integrated apps tend to be text editors, image and document viewers,
    file managers, music and video players, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Other integrated “accessory” applications may include applications for screenshot,
    configuration tools, hotkey managers, themes, and so on. The larger desktop environments
    may even include their own email client (GNOME’s Evolution or KDE’s Kmail, for
    example) or web browser. Large cross-platform applications like Firefox, Thunderbird,
    LibreOffice, and so on may be integrated in a more generic way (using D-Bus to
    communicate).
  prefs: []
  type: TYPE_NORMAL
- en: Well-integrated apps are interesting from a forensics perspective because they
    tend to log, share, configure, and store data in the same place and in the same
    way, making forensic analysis easier.
  prefs: []
  type: TYPE_NORMAL
- en: The use of widget libraries and well-integrated apps is not mandatory. It is
    possible to install GNOME, KDE, Xfce, and LXDE apps together on a single system,
    and even use older non-integrated X11 applications with various widget libraries
    (like Athena or Motif, for example).
  prefs: []
  type: TYPE_NORMAL
- en: '**File Managers**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: File manager applications are of special interest to forensic examiners. File
    managers are to the local system what web browsers are to the internet. Analysis
    of file managers provides insight into how files on the local machine were managed.
  prefs: []
  type: TYPE_NORMAL
- en: Dozens of file managers are available for Linux, both graphical and text console
    based. Each desktop environment favors a particular file manager, and distributions
    may choose one file manager as their default.
  prefs: []
  type: TYPE_NORMAL
- en: File managers are often a strong personal preference among Linux enthusiasts,
    and a user’s favorite may be installed, overriding the distro default.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, these file managers are not bound to a particular desktop, and they
    can be used in any environment (if the required libraries are installed).
  prefs: []
  type: TYPE_NORMAL
- en: The default file managers for the different desktop environments (KDE Dolphin,
    GNOME Nautilus, XFCE Thunar, and LXDE PCManFM) may be called by other well-integrated
    apps and leave artifacts of past activity, which can be useful in an investigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a forensics perspective, the analysis of file managers and other integrated
    applications may include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Recently opened documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trash cans/recycle bins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image thumbnails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search indexes and queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bookmarked files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tags and file manager metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: History of mounted devices and network shares
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration and plug-ins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These artifacts may be created and shared across well-integrated applications,
    and they can help reconstruct past activity. Every application may store different
    information and in different locations. During a forensic analysis, look for cache
    and data files for each application used.
  prefs: []
  type: TYPE_NORMAL
- en: '***Other Desktop Forensic Artifacts***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A variety of other desktop artifacts can be found on most Linux systems. These
    are described here.
  prefs: []
  type: TYPE_NORMAL
- en: '**Screenshots**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Screenshot functionality on Linux desktops can be implemented as extensions,
    as tools bundled with a particular environment, or as stand-alone applications.
    Screenshot tools typically save screenshots to the clipboard or to the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'When saved to the filesystem, screenshots are often saved to the user’s *~/Pictures/*
    directory with a default naming convention that includes a timestamp of when the
    screenshot was made, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Wayland’s security architecture prevents X11-based screenshot programs from
    working as expected, but alternative tools work with various Wayland compositors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Desktop Search**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Desktop search engines are an interesting place to look for forensic artifacts.
    Here, we are not looking for the keywords searched (they are not typically saved),
    but rather the search indexes containing filenames and other data. Local search
    engines are included with most distros and can index filenames or file content.
  prefs: []
  type: TYPE_NORMAL
- en: '**GNOME Desktop Search**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: GNOME’s local search engine is called Tracker, and it uses daemons called Miners
    that index the filesystem and extract metadata for the Tracker database. Tracker
    uses the SPARQL database, which is based on SQLite. The database files can be
    found in either the *.cache/tracker/* or *.cache/tracker3/* directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Newer versions of Tracker separate the database into files for each search
    miner (Pictures, Documents, Filesystem, and so on). The database files (**.db*)
    can be dumped with the `sqlite` command and viewed as text or imported into SQLite
    forensic tools for analysis. For example, here the `sqlite` command is used to
    dump a tracker database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a file on the filesystem is represented by two lines (linked
    by the record number `100086`). There is a path and filename (`file:///home/sam/`
    `Downloads/Fintech_Forensics_Nikkel.pdf`), file size (`275303`), a file creation
    timestamp (`1593928895`), and a file added to database timestamp (`1602069522)`.
  prefs: []
  type: TYPE_NORMAL
- en: These databases may contain additional information not otherwise found on a
    forensic image, possibly information about files that had already been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: '**KDE Desktop Search**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'KDE has two local search engines: one for the local filesystem called Baloo
    and another for contacts, calendar, and email built into Akonadi, KDE’s personal
    information management (PIM) framework.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Baloo database is a single file located in the user’s home directory (*~/.local/share/baloo/index*),
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The size of the index can grow large over time as Baloo appears to ingest significant
    amounts of content data. As of this writing, no tools are available for offline
    forensic analysis of Baloo index files on a separate analysis machine. Analysis
    can be done with `strings`, hex editors, and forensic carving tools. There are
    several Baloo tools for searching and extracting data from a running system.
  prefs: []
  type: TYPE_NORMAL
- en: KDE’s other indexing activity is done with Akonadi. This framework stores and
    indexes email, contacts, calendar entries, notes, and other information in the
    KDE Kontact PIM suite. The data itself is stored in MySQL databases, and the search
    index uses Xapian database files (**.glass*). Everything is located in the user’s
    home directory (*~/.local/share/akonadi/*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This example shows the parts of the Akonadi directory structure. The */search
    _db/* directory contains Xapian databases for each data category. The other directories
    have MySQL databases for the data itself. The contents of the databases can be
    extracted using standard MySQL and Xapian tools.
  prefs: []
  type: TYPE_NORMAL
- en: '**Other Search Indexes**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Xfce desktop environment uses the Catfish search tool. Catfish does not
    index files and searches files on demand.
  prefs: []
  type: TYPE_NORMAL
- en: 'A system-wide search package called *mlocate* indexes filenames. Some distros
    may have it installed by default (Ubuntu, for example). A tool to update the database
    is run periodically from cron or with systemd timers. Only file and directory
    names are indexed, not content. The configuration file is */etc/updatedb.conf*,
    and the database is */var/lib/mlocate/mlocate.db*. The mlocate.db(5) man page
    describes the database format. This database contains last modified/changed timestamps
    for each directory, and it also lists which files belong to that directory (but
    the individual files have no timestamps). A tool for dumping this database can
    be found here: *[https://github.com/halpomeranz/dfis/blob/master/mlocate-time/](https://github.com/halpomeranz/dfis/blob/master/mlocate-time/)*.'
  prefs: []
  type: TYPE_NORMAL
- en: The search databases described in this section may contain evidence of files
    that have been deleted, previous timestamps of files, or even document and file
    content that may be useful in a forensic investigation.
  prefs: []
  type: TYPE_NORMAL
- en: '**User Network Access**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This section describes access to/from Linux systems over a network. Remote
    access can be viewed from two perspectives: users initiating connections from
    a Linux system to a remote system, and Linux systems accepting connections from
    users on remote systems. Remote access is typically in the form of a remote shell
    or remote desktop.'
  prefs: []
  type: TYPE_NORMAL
- en: Network shares and cloud access are considered from the end user or client perspective.
    Local forensic analysis of client-side activity is covered, although analysis
    of network server applications is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '***Secure Shell Access***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Remote access to Unix machines began with analog telephone modems used to connect
    a physical terminal to a serial port (tty) on a remote system. Once machines became
    connected to the internet, protocols like telnet and rlogin were created, and
    they used TCP/IP to access pseudo-terminals (pty or pts) on remote systems. These
    early protocols had poor security, and SSH was developed as a secure replacement
    that used cryptographic authentication and protection. Today, OpenSSH (*[https://www.openssh.com/](https://www.openssh.com/)*)
    is the de facto standard for secure remote access.
  prefs: []
  type: TYPE_NORMAL
- en: Machines with an SSH server (default TCP port 22) directly exposed to the internet
    will experience constant scanning, probing, and brute-force attempts to gain access,
    which will be visible in the logs. In a forensic examination, random opportunistic
    “noise” from the internet must be distinguished from a targeted attack under investigation.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-11](ch10.xhtml#ch010fig011) provides a basic overview diagram of
    OpenSSH clients.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch10fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-11: SSH client overview*'
  prefs: []
  type: TYPE_NORMAL
- en: The `ssh` client accesses a shell or sends commands to a remote machine, the
    `scp` client is used to copy files (based on BSD’s `rcp`), and the `sftp` client
    also copies files interactively, similar to `ftp`. These three client programs
    use the same configuration files and keys, which are stored in the user’s *~/.ssh/*
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: An SSH client can authenticate to a remote machine using passwords, key files,
    or other security key providers (smartcards, for example). By default, key files
    (if used) are manually created using the `ssh-keygen` tool and stored in files
    beginning with *id_**. The files are named after the algorithm used, and the public
    key file ends with the extension **.pub*.
  prefs: []
  type: TYPE_NORMAL
- en: The private key file can be encrypted with a passphrase or stored in the clear
    (often used for automated remote system administration tasks). The easiest way
    to check whether a key file is encrypted is to attempt to change the password
    (using `ssh-keygen -p`). If you are prompted with `Enter old` `passphrase:`, it’s
    encrypted. If you are prompted with `Enter new passphrase` `(empty for no passphrase):`,
    then it is stored in the clear. Brute-forcing an encrypted SSH key file can also
    be attempted.
  prefs: []
  type: TYPE_NORMAL
- en: In an investigation, it is useful to search the entire system for SSH key files
    that might not be encrypted. Sometimes system users are created to make backups
    or run automated system management tools (Ansible or Nagios, for example). The
    header and footer of an SSH private key is the same whether encrypted or not,
    and the following examples can be used to create search strings in a forensic
    tool:^([17](footnotes.xhtml#ch10foot_017))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The public key file ends with a comment field that can be interesting. It may
    contain a username, email address, hostname, or other descriptive information
    associated with the key. This public key can be made available for authentication
    using an *authorized_keys* keys file. Here’s an example public key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the public key string contains the user’s email address in the comment
    area. SSH clients don’t log anything locally by default, so it can be difficult
    to reconstruct past SSH activity. The *.ssh/known_hosts* file is interesting from
    a forensics perspective, as it contains a list of hosts that were accessed in
    the past. New hosts are automatically added to this list when an SSH connection
    is made. The *.ssh/known_hosts* file contains a hostname and/or IP address, the
    cryptographic algorithm used, and the public key of the remote machine. This list
    can be used to identify other machines, hostnames, domain names, and IP addresses
    possibly linked to an investigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The public key information is also interesting as it can be correlated with
    externally gathered intelligence data like SSH public key scans (Shodan, for example),
    and could potentially identify other hosts using the same key (reused or replicated
    virtual machines). The following is an example line from a *.ssh/known_hosts*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Another place to look for traces of past secure shell client activity is in
    the user’s shell history. These history files can be searched for `ssh`, `scp`,
    or `sftp` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Even though SSH clients don’t log activity by default, there may still be log
    entries indicating previous use. For example, when a client script or program
    has failed (or succeeded), evidence of SSH connection attempts might be found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SSH client configuration can be found several places: */etc/ssh/ssh _config*,
    */etc/ssh/ssh_config.d/**, and *~/.ssh/config*, although some of these are optional.
    Here, added custom configuration might point to other infrastructure (Host, Match,
    and ProxyJump commands, for example). Also, the use of relaying and forwarding
    of ports might be revealed (RemoteForward, ProxyCommand, and Tunnel, for example).
    SSH provides highly flexible port forwarding and proxying functionality, which
    can be used to bypass firewall rules and existing perimeter security systems.
    Evidence of remote hosts, remote usernames, port forwarding, and proxying may
    be found in the configuration files or from commands in the shell history.'
  prefs: []
  type: TYPE_NORMAL
- en: In a forensic examination, check other (non-OpenSSH) programs interacting with
    SSH (password managers or agents, for example) or alternative implementations
    of SSH (PuTTY, for example). An SSH agent will provide key authentication, and
    that is included by default in OpenSSH, but alternate agents can be used. Some
    examples of alternate agents or password managers were described previously (GNOME
    Keyring, GPG, or KDEWallet). Search for the existence of the `SSH_AUTH_SOCK` variable
    setting that indicates the use of an alternate agent for SSH.
  prefs: []
  type: TYPE_NORMAL
- en: The file copying programs `scp` and `sftp` are often used as backends for larger
    applications (office suites, file managers, and so on) that need to exchange files
    with remote servers. An additional software package called sshfs exists to create
    a FUSE-mounted filesystem of a remote sftp login.
  prefs: []
  type: TYPE_NORMAL
- en: See the ssh(1), scp(1), sftp(1), ssh-keygen(1), and ssh_config(5) man pages
    for more detailed information about secure shell clients.
  prefs: []
  type: TYPE_NORMAL
- en: '***Remote Desktop Access***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For server environments, the ability to copy files and get a remote shell is
    often enough for users (especially administrators), and SSH adequately fills this
    need. But for desktop environments, a remote graphical desktop is possible and
    usually desired.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional Unix and Linux machines didn’t need remote desktop software, because
    remotely accessing desktops was built into the X11 protocol. This capability requires
    both the local and remote machines to run X11, which is not always the case (Windows
    or Mac clients accessing remote Linux desktops, for example). This led to the
    use of remote desktops.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual network computing (VNC) is the most popular remote desktop client for
    Linux. VNC servers typically listen on TCP port 5900 when a Linux desktop has
    a VNC server installed and running.
  prefs: []
  type: TYPE_NORMAL
- en: Wayland was developed with more security in mind and prevents client windows
    from accessing each other. Because of this, most X11-based remote access software
    doesn’t work on Wayland desktops (nor do X11 screenshot or hotkey managers). As
    a result, Wayland desktops must build remote desktop functionality into the compositor
    or use other methods to gain access to the desktop.
  prefs: []
  type: TYPE_NORMAL
- en: 'One issue with VNC servers is the poor logging. In some cases, there may be
    no logs indicating a remote desktop connection. In other cases, the connection
    may be logged, but without an IP address. The following is an example from an
    Ubuntu machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here a VNC connection was made to the `vino-server` daemon and then terminated.
    A hostname from a reverse DNS lookup is logged, but not an IP address.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If a person or organization runs their own DNS for the source IP range (**.in-addr
    .arpa *zone), they can fake or spoof any DNS reverse lookup they want, causing
    logs to be false. Never fully trust hostnames from reverse DNS lookups.*'
  prefs: []
  type: TYPE_NORMAL
- en: There are other client protocols for remote desktop access. Remote desktop protocol
    (RDP) is popular in Windows environments and has some Linux support. The Spice
    protocol was developed primarily for Linux desktops and includes features such
    as TLS encryption, USB port redirection, audio, and smartcard support. Many video-conferencing
    applications (Jitsi, Zoom, Microsoft Teams, and Skype, for example) offer screen
    sharing for support and presentation purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Many enterprise environments are implementing virtual desktop environments (VDEs)
    as an alternative to hardware desktop or laptop systems. A VDE is a full desktop
    environment running in a cloud. Similar to a virtual server, it’s a virtual desktop
    PC accessible with a remote desktop access method.
  prefs: []
  type: TYPE_NORMAL
- en: '***Network Shares and Cloud Services***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Network-mounted filesystems (also called network shares) can be managed in the
    kernel, or in userspace with FUSE. If mounted for system-wide use, these network
    filesystems may be configured in the */etc/fstab* file together with local hard
    drives. Network filesystems can also be mounted manually from the command line,
    and evidence might be found in the shell history. Evidence of mounting may also
    be found in the logs.
  prefs: []
  type: TYPE_NORMAL
- en: Network file system (NFS) is the traditional Unix protocol, developed by Sun
    Microsystems, for mounting remote filesystems on local machines. NFS shares are
    mounted like normal drives, but with a hostname prepended to the first field of
    the fstab entry (`hostname.example.com:/home`, for example).
  prefs: []
  type: TYPE_NORMAL
- en: Compared to other network filesystems, NFS is more complex, requiring multiple
    protocols and RPC services (mountd), processes to manage locking, authentication,
    exports, and more. NFS is typically used in enterprise environments, and rarely
    found in consumer home environments. See the nfs(5) man page for more information.
    The supporting protocols are defined in nearly a dozen different RFCs.
  prefs: []
  type: TYPE_NORMAL
- en: Common internet file system (CIFS) and/or sever message block (SMB) were originally
    developed by IBM and then later by Microsoft to mount remote network filesystems
    on local machines. Linux implements the client in the kernel, and mounting can
    be an entry in */etc/fstab* (similar to NFS). The most common server-side implementation
    is Samba, which serves network shares to other SMB clients. See the mount.smb(3)
    man page for details.
  prefs: []
  type: TYPE_NORMAL
- en: Webdav is a web-based specification for mounting shares over the HTTP protocol.
    The filesystem implementation under Linux is called davfs. Webdav is popular for
    mounting cloud services like NextCloud. Variations of the Webdav protocol include
    caldav and carddav for accessing remote calendars and contact databases. See the
    mount.davfs(8) man page for more information about mounting webdav shares.
  prefs: []
  type: TYPE_NORMAL
- en: FUSE allows mounting filesystems without requiring a kernel implementation.
    FUSE filesystems also allow non-privileged users to mount filesystems (USB sticks,
    for example). FUSE can create filesystem abstractions for accessing arbitrary
    datasets in a filesystem-based manner (like remote FTP servers, local archive
    files, or unusual hardware devices containing data).
  prefs: []
  type: TYPE_NORMAL
- en: Various cloud accounts on desktop machines can be configured with GUI tools
    provided by the desktop environment. GNOME provides GOA, or GNOME Online Accounts,
    for configuring cloud accounts. [Figure 10-12](ch10.xhtml#ch010fig012) shows the
    GOA configuration panel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch10fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-12: GNOME Online Accounts panel*'
  prefs: []
  type: TYPE_NORMAL
- en: The user has the ability to add and configure a variety of commercial and open
    cloud services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configured accounts can be found in the user’s home directory in the *~/.config/goa-1.0/accounts.conf*
    file. The following shows two examples of configured cloud accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, Microsoft Exchange ➋ and Imap ➍ accounts are configured. Account identifiers
    at ➊ and ➌ in the file each contain a numeric timestamp indicating when the account
    entry was created. The passwords are stored in the GNOME Keyring.
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of possible GOA account sections can be found here: *[https://gitlab.gnome.org/GNOME/gnome-online-accounts/raw/master/doc/goa-sections.txt](https://gitlab.gnome.org/GNOME/gnome-online-accounts/raw/master/doc/goa-sections.txt)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'KDE stores cloud account information in the user’s *~/.config/libaccounts -glib/*
    directory. This is in an SQLite 3 database and can be accessed (dumped) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This reveals that a NextCloud account is configured for user `sam`. The password
    is stored in the KDE Wallet and requested by the libaccounts client.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, a Linux system may have “fat client” software installed for accessing
    cloud resources. This can be free and open source software like the NextCloud
    client, or proprietary client software like Microsoft Teams.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to reconstruct access to cloud services can support investigations
    and lead to the possible recovery of additional evidence stored on remote servers.
  prefs: []
  type: TYPE_NORMAL
- en: '***Summary***'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter will likely feel the most familiar for readers coming from a Windows
    or Mac forensics background. Nearly all of the user and desktop artifacts covered
    here are similar in concept. You now should know how to find and analyze the locations
    of user credentials and passwords and how fingerprint scans are stored. You also
    have explored windowing and desktop systems and the artifacts they provide. You
    should have a solid foundation for reconstructing user activity on the desktop,
    as well as remote access and cloud connectivity.
  prefs: []
  type: TYPE_NORMAL
