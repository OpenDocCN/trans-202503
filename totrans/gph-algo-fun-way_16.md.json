["```\ndef is_valid_probability_graph(g: Graph) -> bool: \n    for node in g.nodes:\n      ❶ edge_list: list = node.get_edge_list()\n        if len(edge_list) == 0:\n            return False\n\n        total: float = 0.0\n        for edge in edge_list:\n          ❷ if edge.weight < 0.0 or edge.weight > 1.0:\n                return False\n            total += edge.weight\n      ❸ if abs(total - 1.0) > 1e-10:\n            return False\n\n    return True \n```", "```\ndef simulate_random_step(self, Vt: list) -> list: \n    if len(Vt) != self.num_nodes:\n        raise ValueError(\"Incorrect length of probability dist\")\n\n    Vnext: list = [0.0] * self.num_nodes\n    for i in range(self.num_nodes):\n        for j in range(self.num_nodes):\n            Vnext[j] += Vt[i] * self.connections[i][j]\n    return Vnext \n```", "```\ndef choose_next_node(current: Node) -> int: \n  ❶ prob: float = random.random()\n    cumulative: float = 0.0\n    edge_list: list = current.get_edge_list()\n\n    for edge in edge_list:\n        cumulative += edge.weight\n      ❷ if cumulative >= prob:\n            return edge.to_node\n  ❸ return edge_list[-1].to_node \n```", "```\ndef random_walk(g: Graph, start: int, steps: int) -> list: \n  ❶ if not is_valid_probability_graph(g):\n        raise ValueError(\"Graph weights are not probabilities.\")\n\n    walk: list = [-1] * steps\n    current: int = start\n    walk[0] = current\n    for i in range(1, steps):\n      ❷ current = choose_next_node(g.nodes[current])\n        walk[i] = current\n\n    return walk \n```", "```\ndef estimate_graph_from_random_walks(walks: list) -> Graph: \n    num_nodes: int = 0\n  ❶ for path in walks:\n        for node in path:\n            if node >= num_nodes:\n                num_nodes = node + 1\n\n    counts: list = [0.0] * num_nodes\n    move_counts: list = [[0.0] * num_nodes for _ in range(num_nodes)]\n  ❷ for path in walks:\n        for i in range(0, len(path) - 1):\n            counts[path[i]] += 1.0\n            move_counts[path[i]][path[i + 1]] += 1.0\n\n    g: Graph = Graph(num_nodes)\n  ❸ for i in range(num_nodes):\n        if counts[i] > 0.0:\n            for j in range(num_nodes):\n              ❹ if move_counts[i][j] > 0.0:\n                    g.insert_edge(i, j, move_counts[i][j] / counts[i])\n    return g \n```", "```\npath1 = [0, 1, 0, 0, 1, 0, 0]\npath2 = [0, 1, 0, 1, 0, 0, 0] \n```", "```\ng = estimate_graph_from_random_walks([path1, path2]) \n```", "```\ndef choose_start(S: list) -> int: \n  ❶ prob: float = random.random()\n    cumulative: float = 0.0\n\n  ❷ for i in range(len(S)):\n        cumulative += S[i] if cumulative >= prob:\n            return i\n    return len(S) - 1 \n```", "```\ndef estimate_start_from_random_walks(walks: list) -> list: \n    num_nodes: int = 0\n  ❶ for path in walks:\n        for node in path:\n            if node >= num_nodes:\n                num_nodes = node + 1\n    counts: list = [0.0] * num_nodes\n\n  ❷ for path in walks:\n        counts[path[0]] += 1.0\n\n    for i in range(num_nodes):\n        counts[i] = counts[i] / len(walks)\n    return counts \n```"]