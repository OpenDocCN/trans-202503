- en: Chapter 3. Into the Real World
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三章. 进入真实世界
- en: '![Into the Real World](httpatomoreillycomsourcenostarchimages2127149.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![进入真实世界](httpatomoreillycomsourcenostarchimages2127149.png.jpg)'
- en: 'The previous chapter demonstrated the configuration for basic packet filtering
    on a single machine. In this chapter, we’ll build on that basic setup but move
    into more conventional territory: the packet-filtering *gateway*. Although most
    of the items in this chapter are potentially useful in a single-machine setup,
    our main focus is to set up a gateway that forwards a selection of network traffic
    and handles common network services for a basic local network.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章演示了单台机器上基本数据包过滤的配置。在这一章中，我们将在此基础设置上进行扩展，但将进入更常规的领域：数据包过滤“网关”。尽管这一章中的大部分内容在单机设置中可能也很有用，但我们的主要关注点是设置一个网关，转发特定的网络流量并处理基本本地网络的常见网络服务。
- en: A Simple Gateway
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的网关
- en: 'We’ll start with building what you probably associate with the term *firewall*:
    a machine that acts as a gateway for at least one other machine. In addition to
    forwarding packets between its various networks, this machine’s mission will be
    to improve the signal-to-noise ratio in the network traffic it handles. That’s
    where our PF configuration comes in.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从构建你可能与“防火墙”一词关联的东西开始：一台作为至少一台其他机器网关的机器。除了在它的多个网络之间转发数据包外，这台机器的使命是提高它所处理的网络流量的信噪比。这就是我们的PF配置发挥作用的地方。
- en: But before diving into the practical configuration details, we need to dip into
    some theory and flesh out some concepts. Bear with me; this will end up saving
    you some headaches I’ve seen on mailing lists, newsgroups, and Web forums all
    too often.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但在深入实际的配置细节之前，我们需要深入一些理论，完善一些概念。请耐心等一下；这将帮助你避免我在邮件列表、新闻组和网络论坛上经常看到的一些头痛问题。
- en: 'Keep It Simple: Avoid the Pitfalls of in, out, and on'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持简单：避免陷入“in”、“out”和“on”的误区
- en: In the single-machine setup, life is relatively simple. Traffic you create should
    either pass out to the rest of the world or be blocked by your filtering rules,
    and you get to decide what you want to let in from elsewhere.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在单机设置中，生活相对简单。你创建的流量应该要么传递到外部世界，要么被你的过滤规则阻止，而你可以决定想要让哪些流量从其他地方进入。
- en: When you set up a gateway, your perspective changes. You go from the “It’s me
    versus the network out there” mindset to “I’m the one who decides what to pass
    to or from all the networks I’m connected to.” The machine has several, or at
    least two, network interfaces, each connected to a separate network, and its primary
    function (or at least the one we’re interested in here) is to forward network
    traffic between networks. Conceptually, the network would look something like
    [Figure 3-1](ch03.html#network_with_a_single_gateway "Figure 3-1. Network with
    a single gateway").
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设置一个网关时，你的视角会发生变化。你从“是我与外部网络对抗”的心态转变为“我是决定所有我连接的网络之间传输什么内容的人”。这台机器有多个，或者至少有两个，网络接口，每个接口连接到一个独立的网络，它的主要功能（或者至少是我们在这里关注的功能）是转发网络流量在各个网络之间。概念上，网络看起来应该像[图3-1](ch03.html#network_with_a_single_gateway
    "图3-1. 具有单一网关的网络")那样。
- en: '![Network with a single gateway](httpatomoreillycomsourcenostarchimages2127151.png.jpg)Figure 3-1. Network
    with a single gateway'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![具有单一网关的网络](httpatomoreillycomsourcenostarchimages2127151.png.jpg)图3-1. 具有单一网关的网络'
- en: It’s very reasonable to think that if you want traffic to pass from the network
    connected to `re1` to hosts on the network connected to `re0`, you’ll need a rule
    like the following:^([[13](#ftn.ch03fn01)])
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望将流量从连接到`re1`的网络传递到连接到`re0`的主机，认为你需要像下面这样的规则是非常合理的：^([[13](#ftn.ch03fn01)])
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, one of the most common and most complained-about mistakes in firewall
    configuration is not realizing that the `to` keyword doesn’t in itself guarantee
    passage to the end point. The `to` keyword here means only that a packet or connection
    must have a destination address that matches those criteria in order to match
    the rule. The rule we just wrote lets the traffic pass `in` to just the gateway
    itself and `on` the specific interface named in the rule. To allow the packets
    in a bit further and to move on to the next network, we need a matching rule that
    says something like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在防火墙配置中，最常见且最令人抱怨的错误之一是没有意识到`to`关键字本身并不能保证数据包能到达终点。这里的`to`关键字仅仅意味着数据包或连接必须具有与这些标准匹配的目的地址，才能匹配该规则。我们刚才写的规则允许流量“进入”到网关本身，并且“在”规则中指定的特定接口上。为了让数据包进一步进入并传递到下一个网络，我们需要一个匹配的规则，类似这样：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: But please stop and take a moment to read those rules one more time. This last
    rule allows only packets with a destination in the network directly connected
    to `re0` to pass, and nothing else. If that’s exactly what you want, fine. In
    other contexts, such rules are, while perfectly valid, more specific than the
    situation calls for. It’s very easy to let yourself dive deeply into specific
    details and lose the higher-level view of the configuration’s purpose—and maybe
    earn yourself a few extra rounds of debugging in the process.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请停下来再看一遍这些规则。最后这一条规则只允许目的地在直接连接到 `re0` 的网络中的数据包通过，其他的都不行。如果这正是你想要的，那就好了。在其他情况下，这样的规则虽然完全有效，但比实际需要的要更具体。很容易让自己陷入具体细节而忽视配置目的的更高层次视角——并可能在此过程中让自己陷入更多的调试循环。
- en: 'If there are good reasons for writing very specific rules, like the preceding
    ones, you probably already know that you need them and why. By the time you have
    finished this book (if not a bit earlier), you should be able to articulate the
    circumstances when more specific rules are needed. However, for the basic gateway
    configurations in this chapter, it’s likely that you’ll want to write rules that
    are not interface-specific. In fact, in some cases, it isn’t useful to specify
    the direction either; you’d simply use a rule like the following to let your local
    network access the Internet:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有充分的理由编写非常具体的规则，比如前面的规则，你可能已经知道需要这些规则以及为什么需要它们。当你读完本书（如果不是更早一些的话）时，你应该能够清楚地表达出在何种情况下需要更具体的规则。然而，对于本章中的基本网关配置，你可能会希望编写不特定于接口的规则。事实上，在某些情况下，指定方向并没有什么实际意义；你只需使用如下规则来让本地网络访问互联网：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For simple setups, interface-bound `in` and `out` rules are likely to add more
    clutter to your rule sets than they’re worth. For a busy network admin, a readable
    rule set is a safer one. (And we’ll look at some additional safety measures, like
    `antispoof`, in [Chapter 10](ch10.html "Chapter 10. Getting Your Setup Just Right").)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的设置，绑定到接口的 `in` 和 `out` 规则可能会为你的规则集增加比其价值更多的杂乱。对于繁忙的网络管理员来说，一个易于阅读的规则集是更安全的。（我们将在[第10章](ch10.html
    "第10章：让你的设置恰到好处")中讨论一些额外的安全措施，如 `antispoof`。）
- en: For the remainder of this book, with some exceptions, we’ll keep the rules as
    simple as possible for readability.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的其余部分，在一些例外情况下，我们将尽可能简化规则，以便于阅读。
- en: Network Address Translation vs. IPv6
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络地址转换与 IPv6
- en: Once we start handling traffic between separate networks, it’s useful to look
    at how network addresses work and why you’re likely to come across several different
    addressing schemes. The subject of network addresses has been a rich source of
    both confusion and buzzwords over the years. The underlying facts are sometimes
    hard to establish, unless you go to the source and wade through a series of RFCs.
    Over the next few paragraphs, I’ll make an effort to clear up some of the confusion.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始处理不同网络之间的流量，了解网络地址是如何工作的以及为什么你可能会遇到几种不同的地址方案就变得非常有用。多年来，网络地址一直是混乱和流行词汇的来源。除非你查阅相关文档并深入研究一系列
    RFC，否则很难确定其中的事实。在接下来的几段中，我将努力澄清一些混乱。
- en: For example, a widely held belief is that if you have an internal network that
    uses a totally different address range from the one assigned to the interface
    attached to the Internet, you’re safe, and no one from the outside can get at
    your network resources. This belief is closely related to the idea that the IP
    address of your firewall in the local network must be either `192.168.0.1` or
    `10.0.0.1`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个广泛流传的观点是，如果你拥有一个使用与连接互联网接口分配的地址范围完全不同的内部网络，那么你就安全了，外界无法访问你的网络资源。这个观点与这样一个想法密切相关：防火墙在本地网络中的
    IP 地址必须是 `192.168.0.1` 或 `10.0.0.1`。
- en: There’s an element of truth in both notions, and those addresses are common
    defaults. But the real story is that it’s possible to sniff one’s way past network
    address translation, although PF offers some tricks that make that task harder.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种观点都有一定的真实性，而且这些地址是常见的默认值。但真正的情况是，尽管 PF 提供了一些技巧使这一任务更难，但仍然有可能绕过网络地址转换。
- en: 'The real reason we use a specific set of internal address ranges and a different
    set of addresses for unique external address ranges isn’t primarily to address
    security concerns. Rather, it’s the easiest way to work around a design problem
    in the Internet protocols: a limited range of possible addresses.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一套特定的内部地址范围和一套不同的外部地址范围，并不是为了主要解决安全问题。而是因为这是绕过互联网协议设计问题的最简单方式：有限的地址范围。
- en: In the 1980s, when the Internet protocols were formulated, most computers on
    the Internet (or ARPANET, as it was known at the time) were large machines with
    anything from several dozen to several thousand users each. At the time, a 32-bit
    address space with more than four billion addresses seemed quite sufficient, but
    several factors have conspired to prove that assumption wrong. One factor is that
    the address-allocation process led to a situation where the largest chunks of
    the available address space were already allocated before some of the world’s
    more populous nations even connected to the Internet. The other, and perhaps more
    significant, factor was that by the early 1990s, the Internet was no longer a
    research project, but rather a commercially available resource with consumers
    and companies of all sizes consuming IP address space at an alarming rate.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在1980年代，当互联网协议被制定时，互联网上的大多数计算机（当时被称为ARPANET）都是大型计算机，每台有几十到几千个用户。当时，32位地址空间提供的超过40亿个地址似乎相当充足，但几个因素证明了这一假设是错误的。一个因素是地址分配过程导致在一些世界人口较多的国家甚至还没有连接互联网之前，已经分配了大量的地址空间。另一个，更重要的因素是，到1990年代初，互联网不再是一个研究项目，而是一个商业化的资源，消费者和各种规模的公司以惊人的速度消耗IP地址空间。
- en: The long-term solution was to redefine the Internet to use a larger address
    space. In 1998, the specification for IPv6, with 128 bits of address space for
    a total of 2^(128) addresses, was published as RFC 2460\. But while we were waiting
    for IPv6 to become generally available, we needed a stopgap solution. That solution
    came as a series of RFCs that specified how a gateway could forward traffic with
    IP addresses translated so that a large local network would look like just one
    computer to the rest of the Internet. Certain previously unallocated IP address
    ranges were set aside for these private networks. These were free for anyone to
    use, on the condition that traffic in those ranges wouldn’t be allowed out on
    the Internet untranslated. Thus, *network address translation (NAT)* was born
    in the mid-1990s and quickly became the default way to handle addressing in local
    networks.^([[14](#ftn.ch03fn02)])
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 长期解决方案是重新定义互联网，使用更大的地址空间。1998年，IPv6的规范发布了，提供了128位的地址空间，总共有2^(128)个地址，作为RFC 2460发布。但在我们等待IPv6广泛可用的同时，我们需要一个临时解决方案。这个解决方案通过一系列RFCs提出，指定了网关如何转发经过地址转换的流量，使得大型本地网络在互联网上看起来像一个计算机。某些以前未分配的IP地址范围被划定为这些私有网络。这些地址范围对任何人都是免费的，前提是这些范围内的流量不得未经转换直接进入互联网。因此，*网络地址转换（NAT）*在1990年代中期诞生，并迅速成为本地网络中处理地址的默认方式。^([[14](#ftn.ch03fn02)])
- en: PF supports IPv6 as well as the various IPv4 address translation tricks. (In
    fact, the BSDs were among the earliest IPv6 adopters, thanks to the efforts of
    the KAME project.^([[15](#ftn.ch03fn03)])) All systems that have PF also support
    both the IPv4 and the IPv6 address families. If your IPv4 network needs a NAT
    configuration, you can integrate the translation as needed in your PF rule set.
    In other words, if you’re using a system that supports PF, you can be reasonably
    sure that your IPv6 needs have been taken care of, at least on the operating-system
    level. However, some operating systems with a PF port use older versions of the
    code, and it’s important to be aware that the general rule that newer PF code
    is better applies equally to the IPv6 context.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: PF支持IPv6以及各种IPv4地址转换技巧。（实际上，BSD是最早采用IPv6的系统之一，得益于KAME项目的努力。^([[15](#ftn.ch03fn03)]))
    所有支持PF的系统也都支持IPv4和IPv6地址族。如果你的IPv4网络需要NAT配置，你可以在PF规则集中根据需要集成地址转换。换句话说，如果你使用的是支持PF的系统，你可以合理地确信，至少在操作系统层面，你的IPv6需求已经得到满足。然而，一些带有PF端口的操作系统使用的是较旧版本的代码，值得注意的是，“更新的PF代码更好”这一通用规则同样适用于IPv6环境。
- en: The examples in this book use mainly IPv4 addresses and NAT where appropriate,
    but most of the material is equally relevant to networks that have implemented
    IPv6.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例主要使用IPv4地址和必要时的NAT，但大部分内容同样适用于已实现IPv6的网络。
- en: 'Final Preparations: Defining Your Local Network'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最终准备：定义本地网络
- en: In [Chapter 2](ch02.html "Chapter 2. PF Configuration Basics"), we set up a
    configuration for a single, standalone machine. We’re about to extend that configuration
    to a gateway version, and it’s useful to define a few more macros to help readability
    and to conceptually separate the local networks where you have a certain measure
    of control from everything else. So how do you define your “local” network in
    PF terms?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章 PF配置基础")中，我们为一台单独的独立机器设置了配置。接下来，我们将把这个配置扩展到网关版本，并且定义一些宏来帮助提高可读性，并在概念上将你有一定控制权的本地网络与其他网络分开。那么，如何在PF术语中定义你的“本地”网络呢？
- en: Earlier in this chapter, you saw the *`interface`*`:network` notation. This
    is a nice piece of shorthand, but you can make your rule set even more readable
    and easier to maintain by taking the macro a bit further. For example, you could
    define a `$localnet` macro as the network directly attached to your internal interface
    (`re1:network` in our examples). Or you could change the definition of `$localnet`
    to an IP address/netmask notation to denote a network, such as `192.168.100.0/24`
    for a subnet of private IPv4 addresses or `2001:db8:dead:beef::/64` for an IPv6
    range.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，你已经看到了*`interface`*`:network`的表示法。这是一种很好的简写方式，但你可以通过稍微扩展宏的使用，使规则集更加易读且便于维护。例如，你可以将`$localnet`宏定义为直接连接到你内部接口的网络（在我们的示例中是`re1:network`）。或者，你也可以将`$localnet`的定义更改为IP地址/子网掩码表示法，来表示一个网络，比如`192.168.100.0/24`表示一个私有IPv4地址子网，或者`2001:db8:dead:beef::/64`表示一个IPv6范围。
- en: 'If your network environment requires it, you could define your `$localnet`
    as a list of networks. For example, a sensible `$localnet` definition combined
    with `pass` rules that use the macro, such as the following, could end up saving
    you a few headaches:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的网络环境要求，你可以将`$localnet`定义为一个网络列表。例如，结合使用宏的`pass`规则，像下面这样的合理`$localnet`定义，可能会帮你省去不少麻烦：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We’ll stick to the convention of using macros such as `$localnet` for readability
    from here on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们将坚持使用像`$localnet`这样的宏，来提高可读性。
- en: Setting Up a Gateway
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置网关
- en: We’ll take the single-machine configuration we built from the ground up in the
    previous chapter as our starting point for building our packet-filtering gateway.
    We assume that the machine has acquired another network card (or that you have
    set up a network connection from your local network to one or more other networks
    via Ethernet, PPP, or other means).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以上一章中从头开始构建的单机配置为基础，来构建我们的数据包过滤网关。我们假设机器已经安装了另一块网络卡（或者你已经通过以太网、PPP或其他方式，从本地网络连接到一个或多个其他网络）。
- en: In our context, it isn’t too interesting to look at the details of how the interfaces
    are configured. We just need to know that the interfaces are up and running.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的语境中，接口如何配置并不特别重要。我们只需要知道接口已经启用并正常工作。
- en: For the following discussion and examples, only the interface names will differ
    between a PPP setup and an Ethernet one, and we’ll do our best to get rid of the
    actual interface names as quickly as possible.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的讨论和示例中，PPP和以太网设置之间的唯一不同是接口名称，我们会尽量快速地去除接口名称，以便让示例更简洁。
- en: 'First, because packet forwarding is off by default in all BSDs, we need to
    turn it on in order to let the machine forward the network traffic it receives
    on one interface to other networks via one or more separate interfaces. Initially,
    we’ll do this on the command line with a `sysctl` command for traditional IPv4:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，因为BSD系统默认禁用了数据包转发，我们需要启用它，以便让计算机将接收到的网络流量从一个接口转发到其他网络通过一个或多个单独的接口。最初，我们将在命令行使用`sysctl`命令来启用传统的IPv4转发：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we need to forward IPv6 traffic, we use this `sysctl` command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要转发IPv6流量，我们使用这个`sysctl`命令：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is fine for now. However, in order for this to work once you reboot the
    computer at some time in the future, you need to enter these settings into the
    relevant configuration files.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这样设置是可以的。然而，为了在将来重新启动计算机时仍然有效，你需要将这些设置输入到相关的配置文件中。
- en: 'In OpenBSD and NetBSD, you do this by editing */etc/sysctl.conf* and adding
    IP-forwarding lines to the end of the file so the last lines look like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In FreeBSD, make the change by putting these lines in your */etc/rc.conf*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The net effect is identical; the FreeBSD *rc* script sets the two values via
    `sysctl` commands. However, a larger part of the FreeBSD configuration is centralized
    into the *rc.conf* file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to check whether all of the interfaces you intend to use are up
    and running. Use **`ifconfig -a`** or **`ifconfig` *interface_name*** to find
    out.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of `ifconfig -a` on one of my systems looks like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Your setup is most likely somewhat different. Here, the physical interfaces
    on the gateway are `xl0` and `fxp0`. The logical interfaces `lo0` (the loopback
    interface), `enc0` (the encapsulation interface for IPSEC use), and `pflog0` (the
    PF logging device) are probably on your system, too.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: If you’re on a dial-up connection, you probably use some variant of PPP for
    the Internet connection, and your external interface is the `tun0` pseudo-device.
    If your connection is via some sort of broadband connection, you may have an Ethernet
    interface to play with. However, if you’re in the significant subset of ADSL users
    who use PPP over Ethernet (PPPoE), the correct external interface will be one
    of the pseudo-devices `tun0` or `pppoe0` (depending on whether you use userland
    `pppoe(8)` or kernel mode `pppoe(4)`), not the physical Ethernet interface.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your specific setup, you may need to do some other device-specific
    configuration for your interfaces. After you have that set up, you can move on
    to the TCP/IP level and deal with the packet-filtering configuration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'If you still intend to allow any traffic initiated by machines on the inside,
    your */etc/pf.conf* for your initial gateway setup could look roughly like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note the use of macros to assign logical names to the network interfaces. Here,
    Realtek Ethernet cards are used, but this is the last time we’ll find this of
    any interest whatsoever in our context.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: In truly simple setups like this one, we may not gain very much by using macros
    like these, but once the rule sets grow a little larger, you’ll learn to appreciate
    the readability they add.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: One possible refinement to this rule set would be to remove the macro `ext_if`
    and replace the `$ext_if` references with the string `egress`, which is the name
    of the interface group that contains the interface that has the default route.
    Interface groups are not macros, so you would write the name `egress` without
    a leading `$` character.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Also note the `match` rule with `nat-to`. This is where you handle NAT from
    the nonroutable address inside your local network to the sole official address
    assigned to you. If your network uses official, routable IPv4 addresses, you simply
    leave this line out of your configuration. The `match` rules, which were introduced
    in OpenBSD 4.6, can be used to apply actions when a connection matches the criteria
    without deciding whether a connection should be blocked or passed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意`nat-to`的`match`规则。这是处理从你本地网络中不可路由地址到分配给你的唯一官方地址的NAT的地方。如果你的网络使用官方的、可路由的IPv4地址，你可以直接省略这行配置。`match`规则是OpenBSD
    4.6中引入的，它们可以在连接匹配某些标准时应用动作，而不决定连接是应该被阻止还是通过。
- en: The parentheses surrounding the last part of the `match` rule `($ext_if)` are
    there to compensate for the possibility that the IP address of the external interface
    may be dynamically assigned. This detail will ensure that your network traffic
    runs without serious interruptions, even if the interface’s IP address changes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`match`规则最后部分`($ext_if)`周围的括号是为了补偿外部接口的IP地址可能是动态分配的情况。这个细节将确保即使接口的IP地址发生变化，你的网络流量也能顺利运行，不会出现严重的中断。'
- en: 'It’s time to sum up the rule set we’ve built so far: (1) We block all traffic
    originating outside our own network. (2) We make sure all IPv4 traffic initiated
    by hosts in our local network will pass into the outside world only with the source
    address rewritten to the routable address assigned to the gateway’s external interface.
    (3) Finally, we let all traffic from our local network (IPv4 and IPv6 both) and
    from the gateway itself pass. The keyword `self` in the final `pass` rule is a
    macro-ish reserved word in PF syntax that denotes all addresses assigned to all
    interfaces on the local host.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候总结我们迄今为止构建的规则集了：(1) 我们阻止来自我们自己网络外部的所有流量。 (2) 我们确保所有从我们本地网络中的主机发起的IPv4流量，在进入外部世界时，其源地址会被重写为网关外部接口分配的可路由地址。
    (3) 最后，我们允许来自我们本地网络（IPv4和IPv6均包括）和网关本身的所有流量通过。最后`pass`规则中的`self`关键字是PF语法中的一个类似宏的保留字，表示本地主机上所有接口分配的所有地址。
- en: 'If your operating system runs a pre-OpenBSD 4.7 PF version, your first gateway
    rule set would look something like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的操作系统运行的是OpenBSD 4.7之前的PF版本，你的第一个网关规则集可能看起来像这样：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `nat` rule here handles the translation much as does the `match` rule with
    `nat-to` in the previous example.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`nat`规则处理的转换方式与前一个示例中的`nat-to`的`match`规则类似。
- en: 'On the other hand, this rule set probably allows more traffic than you actually
    want to pass out of your network. In one of the networks where I’ve done a bit
    of work, the main part of the rule set is based on a macro called `client_out`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这个规则集可能允许比你实际希望通过的流量更多。在我曾经工作过的一些网络中，规则集的主要部分基于一个名为`client_out`的宏：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It has this `pass` rule:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它有这个`pass`规则：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This may be a somewhat peculiar selection of ports, but it’s exactly what my
    colleagues there needed at the time. Some of the numbered ports were needed for
    systems that were set up for specific purposes at other sites. Your needs probably
    differ at least in some details, but this should cover some of the more useful
    services.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个有些奇特的端口选择，但它正是我那里的同事们当时所需要的。有些编号端口是为其他站点上为特定目的设置的系统所需要的。你的需求在某些细节上可能有所不同，但这应该涵盖了一些更常用的服务。
- en: 'Here’s another `pass` rule that is useful to those who want the ability to
    administer machines from elsewhere:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一个`pass`规则，对那些希望能够从其他地方管理机器的人很有用：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Or use this form, if you prefer:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢，也可以使用这种格式：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When you leave out the `from` part entirely, the default is `from any`, which
    is quite permissive. It lets you log in from anywhere, which is great if you travel
    a lot and need SSH access from unknown locations around the world. If you’re not
    all that mobile—say you haven’t quite developed the taste for conferences in far-flung
    locations, or you feel your colleagues can fend for themselves while you’re on
    vacation—you may want to tighten up with a `from` part that includes only the
    places where you and other administrators are likely to log in from for legitimate
    reasons.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完全省略`from`部分时，默认值是`from any`，这相当宽松。它允许你从任何地方登录，这对你经常旅行并需要从全球未知地点进行SSH访问时非常有用。如果你不怎么流动——比如你还没完全习惯参加远方的会议，或者你觉得同事们可以在你度假时自己应对——你可能想通过包含仅限你和其他管理员从合法地点登录的`from`部分来加强安全性。
- en: 'Our very basic rule set is still not complete. Next, we need to make the name
    service work for our clients. We start with another macro at the start of our
    rule set:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的非常基础的规则集仍然不完整。接下来，我们需要让名称服务为我们的客户端工作。我们从规则集开始时的另一个宏开始：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is supplemented with a rule that passes the traffic we want through our
    firewall:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过一个规则来补充，该规则允许我们想要的流量通过防火墙：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note the `quick` keyword in this rule. We’ve started writing rule sets that
    consist of several rules, and it’s time to revisit the relationships and interactions
    between them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意此规则中的`quick`关键字。我们已经开始编写由多个规则组成的规则集，现在是时候重新审视它们之间的关系和互动了。
- en: As noted in the previous chapter, the rules are evaluated from top to bottom
    in the sequence they’re written in the configuration file. For each packet or
    connection evaluated by PF, *the last matching rule* in the rule set is the one
    that’s applied.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，规则是按照它们在配置文件中书写的顺序从上到下进行评估的。对于PF评估的每个数据包或连接，*最后匹配的规则*就是被应用的规则。
- en: The `quick` keyword offers an escape from the ordinary sequence. When a packet
    matches a `quick` rule, the packet is treated according to the present rule. The
    rule processing stops without considering any further rules that might have matched
    the packet. As your rule sets grow longer and more complicated, you’ll find this
    quite handy. For example, it’s useful when you need a few isolated exceptions
    to your general rules.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`quick`关键字提供了逃离普通顺序的方式。当一个数据包匹配到`quick`规则时，数据包会按照当前规则进行处理。规则处理停止，不再考虑可能匹配该数据包的其他规则。随着你的规则集变得越来越长和复杂，你会发现这非常方便。例如，当你需要一些与一般规则隔离的例外时，这会非常有用。'
- en: This `quick` rule also takes care of NTP, which is used for time synchronization.
    Common to both the name service and time synchronization protocols is that they
    may, under certain circumstances, communicate alternately over TCP and UDP.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`quick`规则还处理了NTP，它用于时间同步。名称服务和时间同步协议的共同点是，在某些情况下，它们可能会交替通过TCP和UDP进行通信。
- en: Testing Your Rule Set
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试你的规则集
- en: You may not have gotten around to writing that formal test suite for your rule
    sets just yet, but there’s every reason to test that your configuration works
    as expected.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还没来得及为你的规则集编写正式的测试套件，但完全有理由测试你的配置是否按预期工作。
- en: 'The same basic tests in the standalone example from the previous chapter still
    apply. But now you need to test from the other hosts in your network as well as
    from your packet-filtering gateway. For each of the services you specified in
    your `pass` rules, test that machines in your local network get meaningful results.
    From any machine in your local network, enter a command like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章中的独立示例中的基本测试仍然适用。但现在，你需要从你网络中的其他主机以及你的数据包过滤网关进行测试。对于你在`pass`规则中指定的每项服务，测试你本地网络中的机器是否获得了有意义的结果。从你本地网络中的任何机器，输入类似这样的命令：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It should return exactly the same results as when you tested the stand-alone
    rule set in the previous chapter, and traffic for the services you have specified
    should pass^([[16](#ftn.ch03fn04)]).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该返回与前一章中测试独立规则集时完全相同的结果，并且你指定的服务流量应该通过^([[16](#ftn.ch03fn04)])。
- en: You may not think it’s necessary, but it doesn’t hurt to check that the rule
    set works as expected from outside your gateway as well. If you’ve done exactly
    what this chapter says so far, it shouldn’t be possible to contact machines in
    your local network from the outside.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能觉得没必要，但检查一下规则集是否在你的网关外部按预期工作并没有坏处。如果你迄今为止做了本章所说的，那么从外部应该无法联系到你本地网络中的机器。
- en: Why Only IP Addresses—Not Hostnames or Domain Names?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么只有IP地址——而不是主机名或域名？
- en: Looking at the examples up to this point, you’ve probably noticed that the rule
    sets all have macros that expand into IP addresses or address ranges but never
    into hostnames or domain names. You’re probably wondering why. After all, you’ve
    seen that PF lets you use service names in your rule set, so why not include hostnames
    or domain names?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 看到到目前为止的示例，你可能已经注意到规则集中的宏总是展开为IP地址或地址范围，而从不展开为主机名或域名。你可能在想，为什么呢？毕竟，你已经看到PF允许在规则集中使用服务名称，那么为什么不包括主机名或域名呢？
- en: The answer is that if you used domain names and hostnames in your rule set,
    the rule set would be valid only after the name service was running and accessible.
    In the default configuration, PF is loaded before any network services are running.
    This means that if you want to use domain names and hostnames in your PF configuration,
    you’ll need to change the system’s startup sequence (by editing */etc/rc.local*,
    perhaps) to load the name service–dependent rule set only after the name service
    is available. If you have only a limited number of hostnames or domain names you
    want to reference in your PF configuration, it’s likely at least as useful to
    add those as IP addresses to name-mapping entries in your */etc/hosts* file and
    leave the *rc* scripts alone.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，如果你在规则集中使用了域名和主机名，那么规则集只有在名称服务运行并且可访问时才有效。在默认配置下，PF 会在任何网络服务运行之前加载。这意味着，如果你希望在
    PF 配置中使用域名和主机名，你需要改变系统的启动顺序（可能需要编辑 */etc/rc.local*），以便在名称服务可用后再加载依赖名称服务的规则集。如果你只需要引用少量的主机名或域名，将它们作为
    IP 地址添加到 */etc/hosts* 文件的名称映射条目中，并且不更改 *rc* 脚本，可能会更有用。
- en: That Sad Old FTP Thing
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那个悲伤的旧 FTP 协议
- en: 'The short list of real-life TCP ports we looked at a few moments back contained,
    among other things, *FTP*, the classic *file transfer protocol*. FTP is a relic
    of the early Internet, when experiments were the norm and security was not really
    on the horizon in any modern sense. FTP actually predates TCP/IP,^([[17](#ftn.ch03fn05)])
    and it’s possible to track the protocol’s development through more than 50 RFCs.
    After more than 30 years, FTP is both a sad old thing and a problem child—emphatically
    so for anyone trying to combine FTP and firewalls. FTP is an old and weird protocol
    with a lot to dislike. Here are the most common points against it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才简要查看的实际 TCP 端口清单中，包含了*FTP*——经典的*文件传输协议*。FTP 是早期互联网的遗物，那时实验是常态，安全性并不是现代意义上的一个关注点。事实上，FTP
    比 TCP/IP 还要早，^([[17](#ftn.ch03fn05)])，我们可以通过超过 50 个 RFC 来追踪这个协议的发展。经过 30 多年，FTP
    既是一个悲伤的老东西，也是一个问题孩子——特别是对于那些试图将 FTP 和防火墙结合使用的人来说。FTP 是一个古老且奇怪的协议，存在很多值得反感的地方。以下是反对它的最常见几点：
- en: Passwords are transferred in the clear.^([[18](#ftn.ch03fn06)])
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码以明文传输。^([[18](#ftn.ch03fn06)])
- en: The protocol demands the use of at least two TCP connections (control and data)
    on separate ports.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该协议要求至少使用两个 TCP 连接（控制和数据），并且需要使用不同的端口。
- en: When a session is established, data is communicated via ports usually selected
    at random.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当会话建立时，数据通常通过随机选择的端口进行传输。
- en: All of these points make for challenges security-wise, even before considering
    any potential weaknesses in client or server software that may lead to security
    issues. As any network graybeard will tell you, these things tend to crop up when
    you need them the least.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都会带来安全上的挑战，即便在考虑到客户端或服务器软件中的潜在弱点可能导致安全问题之前。正如任何网络老兵所说的，这些问题通常会在你最不需要的时候出现。
- en: Under any circumstances, other more modern and more secure options for file
    transfer exist, such as SFTP and SCP, which feature both authentication and data
    transfer via encrypted connections. Competent IT professionals should have a preference
    for some form of file transfer other than FTP.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，存在其他更现代、更安全的文件传输选项，例如 SFTP 和 SCP，这些协议都通过加密连接进行身份验证和数据传输。称职的 IT 专业人员应该偏好使用除
    FTP 之外的某种文件传输方式。
- en: 'Regardless of our professionalism and preferences, we sometimes must deal with
    things we would prefer not to use at all. In the case of FTP through firewalls,
    we can combat problems by redirecting the traffic to a small program that’s written
    specifically for this purpose. The upside for us is that handling FTP offers us
    a chance to look at two fairly advanced PF features: *redirection* and *anchors.*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不论我们多么专业，也有时候不得不处理一些我们根本不想使用的东西。在通过防火墙使用 FTP 时，我们可以通过将流量重定向到一个专门为此目的编写的小程序来解决问题。对我们来说，处理
    FTP 给了我们一个机会，去了解两个相对先进的 PF 特性：*重定向*和*锚点*。
- en: The easiest way to handle FTP in a default-to-block scenario such as ours is
    to have PF redirect the traffic for that service to an external application that
    acts as a *proxy* for the service. The proxy maintains its own named sub–rule
    set (an *anchor* in PF terminology), where it inserts or deletes rules as needed
    for the FTP traffic. The combination of redirection and the anchor provides a
    clean, well-defined interface between the packet-filtering subsystem and the proxy.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'If We Must: ftp-proxy with Divert or Redirect'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Enabling FTP transfers through your gateway is amazingly simple, thanks to the
    FTP-proxy program included in the OpenBSD base system. The program is called—you
    guessed it—`ftp-proxy`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable `ftp-proxy`, you need to add this line to your */etc/rc.conf.local*
    file on OpenBSD:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On FreeBSD, */etc/rc.conf* needs to contain at least the first of these two
    lines:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you need to specify any command-line options to `ftp-proxy`, you put them
    in the `ftpproxy_flags` variable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: You can start the proxy manually by running */usr/sbin/ftp-proxy* if you like
    (or even better, use the */etc/rc.d/ftp-proxy* script with the `start` option
    on OpenBSD), and you may want to do this in order to check that the changes to
    the PF configuration you’re about to make have the intended effect.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'For a basic configuration, you need to add only three elements to your */etc/pf.conf*:
    the anchor and two `pass` rules. The anchor declaration looks like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In pre-OpenBSD 4.7 versions, two anchor declarations were needed:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The proxy will insert the rules it generates for the FTP sessions here. Then,
    you also need a `pass` rule to let FTP traffic into the proxy:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note the `divert-to` part. This redirects the traffic to the local port, where
    the proxy listens via the highly efficient, local-connections-only divert(4) interface.
    In OpenBSD versions 4.9 and older, the traffic diversion happened via an `rdr-to`.
    If you’re upgrading an existing pre-OpenBSD 5.0 configuration, you’ll need to
    update your `rdr-to` rules for the FTP proxy to use `divert-to` instead.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'If your operating system uses a pre-OpenBSD 4.7 PF version, you need this version
    of the redirection rule:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, make sure your rule set contains a `pass` rule to let the packets
    pass from the proxy to the rest of the world, where `$proxy` expands to the address
    to which the proxy daemon is bound:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Reload your PF configuration:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Before you know it, your users will thank you for making FTP work.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Variations on the ftp-proxy Setup
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding example covers a basic setup where the clients in your local network
    need to contact FTP servers elsewhere. This configuration should work well with
    most combinations of FTP clients and servers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: You can change the proxy’s behavior in various ways by adding options to the
    `ftpproxy_flags=` line. You may bump into clients or servers with specific quirks
    that you need to compensate for in your configuration, or you may want to integrate
    the proxy in your setup in specific ways, such as assigning FTP traffic to a specific
    queue. For these and other finer points of `ftp-proxy` configuration, your best
    bet is to start by studying the man page.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in ways to run an FTP server protected by PF and `ftp-proxy`,
    you could look into running a separate `ftp-proxy` in reverse mode (using the
    `-R` option) on a separate port with its own redirecting `pass` rule. It’s even
    possible to set up the proxy to run in IPv6 mode, but if you’re ahead of the pack
    in running the modern protocol, you’re less likely to bother with FTP as your
    main file transfer protocol.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*If your PF version predates the ones described here, you’re running on an
    outdated, unsupported operating system. I strongly urge you to schedule an operating
    system upgrade as soon as possible. If an upgrade is for some reason not an option,
    please look up the first edition of this book and study the documentation for
    your operating system for information on how to use some earlier FTP proxies.*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Making Your Network Troubleshooting-Friendly
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Making your network troubleshooting-friendly is a potentially large subject.
    Generally, the debugging- or troubleshooting-friendliness of your TCP/IP network
    depends on how you treat the Internet protocol that was designed specifically
    with debugging in mind: ICMP.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: ICMP is the protocol for sending and receiving *control messages* between hosts
    and gateways, mainly to provide feedback to a sender about any unusual or difficult
    conditions en route to the target host.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lot of ICMP traffic, which usually happens in the background while
    you are surfing the Web, reading mail, or transferring files. Routers (remember,
    you’re building one) use ICMP to negotiate packet sizes and other transmission
    parameters in a process often referred to as *path MTU discovery*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: You may have heard admins refer to ICMP as either “evil” or, if their understanding
    runs a little deeper, “a necessary evil.” The reason for this attitude is purely
    historical. A few years back, it was discovered that the networking stacks of
    several operating systems contained code that could make the machine crash if
    it were sent a sufficiently large ICMP request.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: One of the companies that was hit hard by this was Microsoft, and you can find
    a lot of material on the *ping of death* bug by using your favorite search engine.
    However, this all happened in the second half of the 1990s, and all modern operating
    systems have thoroughly sanitized their network code since then (at least, that’s
    what we’re led to believe).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: One of the early work-arounds was to simply block either ICMP echo (ping) requests
    or even all ICMP traffic. That measure almost certainly led to poor performance
    and hard-to-debug network problems. In some places, however, these rule sets have
    been around for almost two decades, and the people who put them there are still
    scared. There’s most likely little to no reason to worry about destructive ICMP
    traffic anymore, but here we’ll look at how to manage just what ICMP traffic passes
    to or from your network.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: In modern IPv6 networks, the updated `icmp6` protocol plays a more crucial role
    than ever in parameter passing and even host configuration, and network admins
    are playing a high-stakes game while learning the finer points of blocking or
    passing `icmp6` traffic. To a large extent, issues that are relevant for IPv4
    ICMP generally apply to IPv6 ICMP6 as well, but in addition, ICMP6 is used for
    several mechanisms that were handled differently in IPv4\. We’ll dip into some
    of these issues after walking through the issues that are relevant for both IP
    protocol versions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Do We Let It All Through?
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The obvious question becomes, “If ICMP is such a good and useful thing, shouldn’t
    we let it all through all the time?” The answer is that it depends.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Letting diagnostic traffic pass unconditionally makes debugging easier, of
    course, but it also makes it relatively easy for others to extract information
    about your network. So, a rule like the following might not be optimal if you
    want to cloak the internal workings of your IPv4 network:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you want the same free flow of messages for your IPv6 traffic, the corresponding
    rule is this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In all fairness, it should also be said that you might find some ICMP and ICMP6
    traffic quite harmlessly riding piggyback on your `keep state` rules.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'The Easy Way Out: The Buck Stops Here'
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The easiest solution could very well be to allow all ICMP and ICMP6 traffic
    from your local network through and to let probes from elsewhere stop at your
    gateway:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is assuming, of course that you’ve identified the list of desirable ICMP
    and ICMP6 types to fill out your macro definitions. We’ll get back to those shortly.
    Stopping probes at the gateway might be an attractive option anyway, but let’s
    look at a few other options that’ll demonstrate some of PF’s flexibility.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Letting ping Through
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The rule set we have developed so far in this chapter has one clear disadvantage:
    Common troubleshooting commands, such as `ping` and `traceroute` (and their IPv6
    equivalents, `ping6` and `traceroute6`), will not work. That may not matter too
    much to your users, and because it was the `ping` command that scared people into
    filtering or blocking ICMP traffic in the first place, there are apparently some
    people who feel we’re better off without it. However, you’ll find these troubleshooting
    tools useful. And with a couple of small additions to the rule set, they will
    be available to you.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'The diagnostic commands `ping` and `ping6` rely on the ICMP and ICMP6 *echo
    request* (and the matching *echo reply*) types, and in order to keep our rule
    set tidy, we start by defining another set of macros:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we add rules that use the definitions:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The macros and the rules mean that ICMP and ICMP6 packets with type *echo request*
    will be allowed through and matching *echo replies* will be allowed to pass back
    due to PF’s stateful nature. This is all the `ping` and `ping6` commands need
    in order to produce their expected results.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: If you need more or other types of ICMP or ICMP6 packets to go through, you
    can expand `icmp_types` and `icmp6_types` to lists of those packet types you want
    to allow.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Helping traceroute
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `traceroute` command (and the IPv6 variant `traceroute6`) is useful when
    your users claim that the Internet isn’t working. By default, Unix `traceroute`
    uses UDP connections according to a set formula based on destination. The following
    rules work with the `traceroute` and `traceroute6` commands on all forms of Unix
    I’ve had access to, including GNU/Linux:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This also gives you a first taste of what port ranges look like. They’re quite
    useful in some contexts.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Experience so far indicates that `traceroute` and `traceroute6` implementations
    on other operating systems work roughly the same way. One notable exception is
    Microsoft Windows. On that platform, the *tracert.exe* program and its IPv6 sister
    *tracert6.exe* use ICMP echo requests for this purpose. So if you want to let
    Windows traceroutes through, you need only the first rule, much as when letting
    `ping` through. The Unix `traceroute` program can be instructed to use other protocols
    as well and will behave remarkably like its Microsoft counterpart if you use its
    `-I` command-line option. You can check the `traceroute` man page (or its source
    code, for that matter) for all the details.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: This solution is based on a sample rule I found in an `openbsd-misc` post. I’ve
    found that list, and the searchable list archives (accessible among other places
    from *[http://marc.info/](http://marc.info/)*), to be a valuable resource whenever
    you need OpenBSD or PF-related information.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Path MTU Discovery
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last bit I’ll remind you about when it comes to troubleshooting is the path
    MTU discovery. Internet protocols are designed to be device-independent, and one
    consequence of device independence is that you cannot always predict reliably
    what the optimal packet size is for a given connection. The main constraint on
    your packet size is called the *maximum transmission unit*, or *MTU*, which sets
    the upper limit on the packet size for an interface. The `ifconfig` command will
    show you the MTU for your network interfaces.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern TCP/IP implementations expect to be able to determine the correct packet
    size for a connection through a process that simply involves sending packets of
    varying sizes within the MTU of the local link with the “do not fragment” flag
    set. If a packet then exceeds the MTU somewhere along the way to the destination,
    the host with the lower MTU will return an ICMP packet indicating “type 3, code
    4” and quoting its local MTU when the local upper limit has been reached. Now,
    you don’t need to dive for the RFCs right away. Type 3 means *destination unreachable*,
    and code 4 is short for *fragmentation needed, but the “do not fragment” flag
    is set*. So if your connections to other networks, which may have MTUs that differ
    from your own, seem suboptimal, you could try changing your list of ICMP types
    slightly to let the IPv4 destination-unreachable packets through:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see, this means you do not need to change the `pass` rule itself:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now I’ll let you in on a little secret: In almost all cases, these rules aren’t
    necessary for purposes of path MTU discovery (but they don’t hurt either). However,
    even though the default PF `keep state` behavior takes care of most of the ICMP
    traffic you’ll need, PF does let you filter on all variations of ICMP types and
    codes. For IPv6, you’d probably want to let the more common ICMP6 diagnostics
    through, such as the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This means that we let echo requests and destination unreachable, time exceeded,
    and parameter problem messages pass for IPv6 traffic. Thanks to the macro definitions,
    you don’t need to touch the `pass` rule for the ICMP6 case either:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: But it’s worth keeping in mind that IPv6 hosts rely on ICMP6 messages for automatic
    configuration-related tasks, and you may want to explicitly filter in order to
    allow or deny specific ICMP6 types at various points in your network.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: For example, you’ll want to let a router and its clients exchange router solicitation
    and router advertisement messages (ICMP6 type `routeradv` and `routersol`, respectively),
    while you may want to make sure that neighbor advertisements and neighbor solicitations
    (ICMP6 type `neighbradv` and `neighbrsol`, respectively) stay confined within
    their directly connected networks.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: If you want to delve into more detail, the list of possible types and codes
    are documented in the `icmp(4)` and `icmp6(4)` man pages. The background information
    is available in the RFCs.^([[19](#ftn.ch03fn07)])
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Tables Make Your Life Easier
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, you may be thinking that this setup gets awfully static and rigid. There
    will, after all, be some kinds of data relevant to filtering and redirection at
    a given time, but they don’t deserve to be put into a configuration file! Quite
    right, and PF offers mechanisms for handling those situations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '*Tables* are one such feature. They’re useful as lists of IP addresses that
    can be manipulated without reloading the entire rule set and also when fast lookups
    are desirable.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Table names are always enclosed in `< >`, like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, the network `192.168.2.0/24` is part of the table with one exception:
    The address `192.168.2.5` is excluded using the `!` operator (logical NOT). The
    keyword `persist` makes sure the table itself will exist, even if no rules currently
    refer to it.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to load tables from files where each item is on a separate
    line, such as the file */etc/clients*:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This, in turn, is used to initialize the table in */etc/pf.conf*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So, for example, you can change one of our earlier rules to read like this
    to manage outgoing traffic from your client computers:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With this in hand, you can manipulate the table’s contents live, like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that this changes the in-memory copy of the table only, meaning that the
    change will not survive a power failure or reboot, unless you arrange to store
    your changes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'You might opt to maintain the on-disk copy of the table with a `cron` job that
    dumps the table content to disk at regular intervals, using a command such as
    the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Alternatively, you could edit the */etc/clients* file and replace the in-memory
    table contents with the file data:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For operations you’ll be performing frequently, sooner or later, you’ll end
    up writing shell scripts. It’s likely that routine operations on tables, such
    as inserting or removing items or replacing table contents, will be part of your
    housekeeping scripts in the near future.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: One common example is to enforce network access restrictions via `cron` jobs
    that replace the contents of the tables referenced as `from` addresses in the
    `pass` rules at specific times. In some networks, you may even need different
    access rules for different days of the week. The only real limitations lie in
    your own needs and your creativity.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be returning to some handy uses of tables frequently over the next chapters,
    and we’ll look at a few programs that interact with tables in useful ways.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: ^([[13](#ch03fn01)]) In fact, the `keep state` part denotes the default behavior
    and is redundant if you’re working with a PF version taken from OpenBSD 4.1 or
    later. However, there’s generally no need to remove the specification from existing
    rules you come across when upgrading from earlier versions. To ease the transition,
    the examples in this book will make this distinction when needed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: ^([[14](#ch03fn02)]) RFC 1631, “The IP Network Address Translator (NAT),” dated
    May 1994, and RFC 1918, “Address Allocation for Private Internets,” dated February
    1996, provide the details about NAT.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: ^([[15](#ch03fn03)]) To quote the project home page at *[http://www.kame.net/](http://www.kame.net/)*,
    “The KAME project was a joint effort of six companies in Japan to provide a free
    stack of IPv6, IPsec, and Mobile IPv6 for BSD variants.” The main research and
    development activities were considered complete in March 2006, with only maintenance
    activity continuing now that the important parts have been incorporated into the
    relevant systems.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: ^([[16](#ch03fn04)]) This is true unless, of course, the information changed
    in the meantime. Some sysadmins are fond of practical jokes, but most of the time
    changes in DNS zone information are due to real-world needs in that particular
    organization or network.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: ^([[17](#ch03fn05)]) The earliest RFC describing the FTP protocol is RFC 114,
    dated April 10, 1971\. The switch to TCP/IP happened with FTP version 5, as defined
    in RFCs 765 and 775, dated June and December 1980, respectively.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: ^([[18](#ch03fn06)]) An encrypted version of the protocol, dubbed FTPS, is specified
    in RFC4217, but support remains somewhat spotty.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: ^([[19](#ch03fn07)]) The main RFCs describing ICMP and some related techniques
    are 792, 950, 1191, 1256, 2521, and 6145\. ICMP updates for IPv6 are in RFC 3542
    and RFC 4443\. These documents are available in a number of places on the Web,
    such as *[http://www.ietf.org/](http://www.ietf.org/)* and *[http://www.faqs.org/](http://www.faqs.org/)*,
    and probably also via your package system.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
