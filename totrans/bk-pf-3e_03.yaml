- en: Chapter 3. Into the Real World
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三章. 进入真实世界
- en: '![Into the Real World](httpatomoreillycomsourcenostarchimages2127149.png.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![进入真实世界](httpatomoreillycomsourcenostarchimages2127149.png.jpg)'
- en: 'The previous chapter demonstrated the configuration for basic packet filtering
    on a single machine. In this chapter, we’ll build on that basic setup but move
    into more conventional territory: the packet-filtering *gateway*. Although most
    of the items in this chapter are potentially useful in a single-machine setup,
    our main focus is to set up a gateway that forwards a selection of network traffic
    and handles common network services for a basic local network.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章演示了单台机器上基本数据包过滤的配置。在这一章中，我们将在此基础设置上进行扩展，但将进入更常规的领域：数据包过滤“网关”。尽管这一章中的大部分内容在单机设置中可能也很有用，但我们的主要关注点是设置一个网关，转发特定的网络流量并处理基本本地网络的常见网络服务。
- en: A Simple Gateway
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的网关
- en: 'We’ll start with building what you probably associate with the term *firewall*:
    a machine that acts as a gateway for at least one other machine. In addition to
    forwarding packets between its various networks, this machine’s mission will be
    to improve the signal-to-noise ratio in the network traffic it handles. That’s
    where our PF configuration comes in.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从构建你可能与“防火墙”一词关联的东西开始：一台作为至少一台其他机器网关的机器。除了在它的多个网络之间转发数据包外，这台机器的使命是提高它所处理的网络流量的信噪比。这就是我们的PF配置发挥作用的地方。
- en: But before diving into the practical configuration details, we need to dip into
    some theory and flesh out some concepts. Bear with me; this will end up saving
    you some headaches I’ve seen on mailing lists, newsgroups, and Web forums all
    too often.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但在深入实际的配置细节之前，我们需要深入一些理论，完善一些概念。请耐心等一下；这将帮助你避免我在邮件列表、新闻组和网络论坛上经常看到的一些头痛问题。
- en: 'Keep It Simple: Avoid the Pitfalls of in, out, and on'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持简单：避免陷入“in”、“out”和“on”的误区
- en: In the single-machine setup, life is relatively simple. Traffic you create should
    either pass out to the rest of the world or be blocked by your filtering rules,
    and you get to decide what you want to let in from elsewhere.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在单机设置中，生活相对简单。你创建的流量应该要么传递到外部世界，要么被你的过滤规则阻止，而你可以决定想要让哪些流量从其他地方进入。
- en: When you set up a gateway, your perspective changes. You go from the “It’s me
    versus the network out there” mindset to “I’m the one who decides what to pass
    to or from all the networks I’m connected to.” The machine has several, or at
    least two, network interfaces, each connected to a separate network, and its primary
    function (or at least the one we’re interested in here) is to forward network
    traffic between networks. Conceptually, the network would look something like
    [Figure 3-1](ch03.html#network_with_a_single_gateway "Figure 3-1. Network with
    a single gateway").
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设置一个网关时，你的视角会发生变化。你从“是我与外部网络对抗”的心态转变为“我是决定所有我连接的网络之间传输什么内容的人”。这台机器有多个，或者至少有两个，网络接口，每个接口连接到一个独立的网络，它的主要功能（或者至少是我们在这里关注的功能）是转发网络流量在各个网络之间。概念上，网络看起来应该像[图3-1](ch03.html#network_with_a_single_gateway
    "图3-1. 具有单一网关的网络")那样。
- en: '![Network with a single gateway](httpatomoreillycomsourcenostarchimages2127151.png.jpg)Figure 3-1. Network
    with a single gateway'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '![具有单一网关的网络](httpatomoreillycomsourcenostarchimages2127151.png.jpg)图3-1. 具有单一网关的网络'
- en: It’s very reasonable to think that if you want traffic to pass from the network
    connected to `re1` to hosts on the network connected to `re0`, you’ll need a rule
    like the following:^([[13](#ftn.ch03fn01)])
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望将流量从连接到`re1`的网络传递到连接到`re0`的主机，认为你需要像下面这样的规则是非常合理的：^([[13](#ftn.ch03fn01)])
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, one of the most common and most complained-about mistakes in firewall
    configuration is not realizing that the `to` keyword doesn’t in itself guarantee
    passage to the end point. The `to` keyword here means only that a packet or connection
    must have a destination address that matches those criteria in order to match
    the rule. The rule we just wrote lets the traffic pass `in` to just the gateway
    itself and `on` the specific interface named in the rule. To allow the packets
    in a bit further and to move on to the next network, we need a matching rule that
    says something like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在防火墙配置中，最常见且最令人抱怨的错误之一是没有意识到`to`关键字本身并不能保证数据包能到达终点。这里的`to`关键字仅仅意味着数据包或连接必须具有与这些标准匹配的目的地址，才能匹配该规则。我们刚才写的规则允许流量“进入”到网关本身，并且“在”规则中指定的特定接口上。为了让数据包进一步进入并传递到下一个网络，我们需要一个匹配的规则，类似这样：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: But please stop and take a moment to read those rules one more time. This last
    rule allows only packets with a destination in the network directly connected
    to `re0` to pass, and nothing else. If that’s exactly what you want, fine. In
    other contexts, such rules are, while perfectly valid, more specific than the
    situation calls for. It’s very easy to let yourself dive deeply into specific
    details and lose the higher-level view of the configuration’s purpose—and maybe
    earn yourself a few extra rounds of debugging in the process.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请停下来再看一遍这些规则。最后这一条规则只允许目的地在直接连接到 `re0` 的网络中的数据包通过，其他的都不行。如果这正是你想要的，那就好了。在其他情况下，这样的规则虽然完全有效，但比实际需要的要更具体。很容易让自己陷入具体细节而忽视配置目的的更高层次视角——并可能在此过程中让自己陷入更多的调试循环。
- en: 'If there are good reasons for writing very specific rules, like the preceding
    ones, you probably already know that you need them and why. By the time you have
    finished this book (if not a bit earlier), you should be able to articulate the
    circumstances when more specific rules are needed. However, for the basic gateway
    configurations in this chapter, it’s likely that you’ll want to write rules that
    are not interface-specific. In fact, in some cases, it isn’t useful to specify
    the direction either; you’d simply use a rule like the following to let your local
    network access the Internet:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有充分的理由编写非常具体的规则，比如前面的规则，你可能已经知道需要这些规则以及为什么需要它们。当你读完本书（如果不是更早一些的话）时，你应该能够清楚地表达出在何种情况下需要更具体的规则。然而，对于本章中的基本网关配置，你可能会希望编写不特定于接口的规则。事实上，在某些情况下，指定方向并没有什么实际意义；你只需使用如下规则来让本地网络访问互联网：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For simple setups, interface-bound `in` and `out` rules are likely to add more
    clutter to your rule sets than they’re worth. For a busy network admin, a readable
    rule set is a safer one. (And we’ll look at some additional safety measures, like
    `antispoof`, in [Chapter 10](ch10.html "Chapter 10. Getting Your Setup Just Right").)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的设置，绑定到接口的 `in` 和 `out` 规则可能会为你的规则集增加比其价值更多的杂乱。对于繁忙的网络管理员来说，一个易于阅读的规则集是更安全的。（我们将在[第10章](ch10.html
    "第10章：让你的设置恰到好处")中讨论一些额外的安全措施，如 `antispoof`。）
- en: For the remainder of this book, with some exceptions, we’ll keep the rules as
    simple as possible for readability.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的其余部分，在一些例外情况下，我们将尽可能简化规则，以便于阅读。
- en: Network Address Translation vs. IPv6
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络地址转换与 IPv6
- en: Once we start handling traffic between separate networks, it’s useful to look
    at how network addresses work and why you’re likely to come across several different
    addressing schemes. The subject of network addresses has been a rich source of
    both confusion and buzzwords over the years. The underlying facts are sometimes
    hard to establish, unless you go to the source and wade through a series of RFCs.
    Over the next few paragraphs, I’ll make an effort to clear up some of the confusion.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始处理不同网络之间的流量，了解网络地址是如何工作的以及为什么你可能会遇到几种不同的地址方案就变得非常有用。多年来，网络地址一直是混乱和流行词汇的来源。除非你查阅相关文档并深入研究一系列
    RFC，否则很难确定其中的事实。在接下来的几段中，我将努力澄清一些混乱。
- en: For example, a widely held belief is that if you have an internal network that
    uses a totally different address range from the one assigned to the interface
    attached to the Internet, you’re safe, and no one from the outside can get at
    your network resources. This belief is closely related to the idea that the IP
    address of your firewall in the local network must be either `192.168.0.1` or
    `10.0.0.1`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个广泛流传的观点是，如果你拥有一个使用与连接互联网接口分配的地址范围完全不同的内部网络，那么你就安全了，外界无法访问你的网络资源。这个观点与这样一个想法密切相关：防火墙在本地网络中的
    IP 地址必须是 `192.168.0.1` 或 `10.0.0.1`。
- en: There’s an element of truth in both notions, and those addresses are common
    defaults. But the real story is that it’s possible to sniff one’s way past network
    address translation, although PF offers some tricks that make that task harder.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种观点都有一定的真实性，而且这些地址是常见的默认值。但真正的情况是，尽管 PF 提供了一些技巧使这一任务更难，但仍然有可能绕过网络地址转换。
- en: 'The real reason we use a specific set of internal address ranges and a different
    set of addresses for unique external address ranges isn’t primarily to address
    security concerns. Rather, it’s the easiest way to work around a design problem
    in the Internet protocols: a limited range of possible addresses.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一套特定的内部地址范围和一套不同的外部地址范围，并不是为了主要解决安全问题。而是因为这是绕过互联网协议设计问题的最简单方式：有限的地址范围。
- en: In the 1980s, when the Internet protocols were formulated, most computers on
    the Internet (or ARPANET, as it was known at the time) were large machines with
    anything from several dozen to several thousand users each. At the time, a 32-bit
    address space with more than four billion addresses seemed quite sufficient, but
    several factors have conspired to prove that assumption wrong. One factor is that
    the address-allocation process led to a situation where the largest chunks of
    the available address space were already allocated before some of the world’s
    more populous nations even connected to the Internet. The other, and perhaps more
    significant, factor was that by the early 1990s, the Internet was no longer a
    research project, but rather a commercially available resource with consumers
    and companies of all sizes consuming IP address space at an alarming rate.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在1980年代，当互联网协议被制定时，互联网上的大多数计算机（当时被称为ARPANET）都是大型计算机，每台有几十到几千个用户。当时，32位地址空间提供的超过40亿个地址似乎相当充足，但几个因素证明了这一假设是错误的。一个因素是地址分配过程导致在一些世界人口较多的国家甚至还没有连接互联网之前，已经分配了大量的地址空间。另一个，更重要的因素是，到1990年代初，互联网不再是一个研究项目，而是一个商业化的资源，消费者和各种规模的公司以惊人的速度消耗IP地址空间。
- en: The long-term solution was to redefine the Internet to use a larger address
    space. In 1998, the specification for IPv6, with 128 bits of address space for
    a total of 2^(128) addresses, was published as RFC 2460\. But while we were waiting
    for IPv6 to become generally available, we needed a stopgap solution. That solution
    came as a series of RFCs that specified how a gateway could forward traffic with
    IP addresses translated so that a large local network would look like just one
    computer to the rest of the Internet. Certain previously unallocated IP address
    ranges were set aside for these private networks. These were free for anyone to
    use, on the condition that traffic in those ranges wouldn’t be allowed out on
    the Internet untranslated. Thus, *network address translation (NAT)* was born
    in the mid-1990s and quickly became the default way to handle addressing in local
    networks.^([[14](#ftn.ch03fn02)])
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 长期解决方案是重新定义互联网，使用更大的地址空间。1998年，IPv6的规范发布了，提供了128位的地址空间，总共有2^(128)个地址，作为RFC 2460发布。但在我们等待IPv6广泛可用的同时，我们需要一个临时解决方案。这个解决方案通过一系列RFCs提出，指定了网关如何转发经过地址转换的流量，使得大型本地网络在互联网上看起来像一个计算机。某些以前未分配的IP地址范围被划定为这些私有网络。这些地址范围对任何人都是免费的，前提是这些范围内的流量不得未经转换直接进入互联网。因此，*网络地址转换（NAT）*在1990年代中期诞生，并迅速成为本地网络中处理地址的默认方式。^([[14](#ftn.ch03fn02)])
- en: PF supports IPv6 as well as the various IPv4 address translation tricks. (In
    fact, the BSDs were among the earliest IPv6 adopters, thanks to the efforts of
    the KAME project.^([[15](#ftn.ch03fn03)])) All systems that have PF also support
    both the IPv4 and the IPv6 address families. If your IPv4 network needs a NAT
    configuration, you can integrate the translation as needed in your PF rule set.
    In other words, if you’re using a system that supports PF, you can be reasonably
    sure that your IPv6 needs have been taken care of, at least on the operating-system
    level. However, some operating systems with a PF port use older versions of the
    code, and it’s important to be aware that the general rule that newer PF code
    is better applies equally to the IPv6 context.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: PF支持IPv6以及各种IPv4地址转换技巧。（实际上，BSD是最早采用IPv6的系统之一，得益于KAME项目的努力。^([[15](#ftn.ch03fn03)]))
    所有支持PF的系统也都支持IPv4和IPv6地址族。如果你的IPv4网络需要NAT配置，你可以在PF规则集中根据需要集成地址转换。换句话说，如果你使用的是支持PF的系统，你可以合理地确信，至少在操作系统层面，你的IPv6需求已经得到满足。然而，一些带有PF端口的操作系统使用的是较旧版本的代码，值得注意的是，“更新的PF代码更好”这一通用规则同样适用于IPv6环境。
- en: The examples in this book use mainly IPv4 addresses and NAT where appropriate,
    but most of the material is equally relevant to networks that have implemented
    IPv6.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的示例主要使用IPv4地址和必要时的NAT，但大部分内容同样适用于已实现IPv6的网络。
- en: 'Final Preparations: Defining Your Local Network'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最终准备：定义本地网络
- en: In [Chapter 2](ch02.html "Chapter 2. PF Configuration Basics"), we set up a
    configuration for a single, standalone machine. We’re about to extend that configuration
    to a gateway version, and it’s useful to define a few more macros to help readability
    and to conceptually separate the local networks where you have a certain measure
    of control from everything else. So how do you define your “local” network in
    PF terms?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章 PF配置基础")中，我们为一台单独的独立机器设置了配置。接下来，我们将把这个配置扩展到网关版本，并且定义一些宏来帮助提高可读性，并在概念上将你有一定控制权的本地网络与其他网络分开。那么，如何在PF术语中定义你的“本地”网络呢？
- en: Earlier in this chapter, you saw the *`interface`*`:network` notation. This
    is a nice piece of shorthand, but you can make your rule set even more readable
    and easier to maintain by taking the macro a bit further. For example, you could
    define a `$localnet` macro as the network directly attached to your internal interface
    (`re1:network` in our examples). Or you could change the definition of `$localnet`
    to an IP address/netmask notation to denote a network, such as `192.168.100.0/24`
    for a subnet of private IPv4 addresses or `2001:db8:dead:beef::/64` for an IPv6
    range.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，你已经看到了*`interface`*`:network`的表示法。这是一种很好的简写方式，但你可以通过稍微扩展宏的使用，使规则集更加易读且便于维护。例如，你可以将`$localnet`宏定义为直接连接到你内部接口的网络（在我们的示例中是`re1:network`）。或者，你也可以将`$localnet`的定义更改为IP地址/子网掩码表示法，来表示一个网络，比如`192.168.100.0/24`表示一个私有IPv4地址子网，或者`2001:db8:dead:beef::/64`表示一个IPv6范围。
- en: 'If your network environment requires it, you could define your `$localnet`
    as a list of networks. For example, a sensible `$localnet` definition combined
    with `pass` rules that use the macro, such as the following, could end up saving
    you a few headaches:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的网络环境要求，你可以将`$localnet`定义为一个网络列表。例如，结合使用宏的`pass`规则，像下面这样的合理`$localnet`定义，可能会帮你省去不少麻烦：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We’ll stick to the convention of using macros such as `$localnet` for readability
    from here on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们将坚持使用像`$localnet`这样的宏，来提高可读性。
- en: Setting Up a Gateway
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置网关
- en: We’ll take the single-machine configuration we built from the ground up in the
    previous chapter as our starting point for building our packet-filtering gateway.
    We assume that the machine has acquired another network card (or that you have
    set up a network connection from your local network to one or more other networks
    via Ethernet, PPP, or other means).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以上一章中从头开始构建的单机配置为基础，来构建我们的数据包过滤网关。我们假设机器已经安装了另一块网络卡（或者你已经通过以太网、PPP或其他方式，从本地网络连接到一个或多个其他网络）。
- en: In our context, it isn’t too interesting to look at the details of how the interfaces
    are configured. We just need to know that the interfaces are up and running.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的语境中，接口如何配置并不特别重要。我们只需要知道接口已经启用并正常工作。
- en: For the following discussion and examples, only the interface names will differ
    between a PPP setup and an Ethernet one, and we’ll do our best to get rid of the
    actual interface names as quickly as possible.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的讨论和示例中，PPP和以太网设置之间的唯一不同是接口名称，我们会尽量快速地去除接口名称，以便让示例更简洁。
- en: 'First, because packet forwarding is off by default in all BSDs, we need to
    turn it on in order to let the machine forward the network traffic it receives
    on one interface to other networks via one or more separate interfaces. Initially,
    we’ll do this on the command line with a `sysctl` command for traditional IPv4:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，因为BSD系统默认禁用了数据包转发，我们需要启用它，以便让计算机将接收到的网络流量从一个接口转发到其他网络通过一个或多个单独的接口。最初，我们将在命令行使用`sysctl`命令来启用传统的IPv4转发：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we need to forward IPv6 traffic, we use this `sysctl` command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要转发IPv6流量，我们使用这个`sysctl`命令：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is fine for now. However, in order for this to work once you reboot the
    computer at some time in the future, you need to enter these settings into the
    relevant configuration files.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这样设置是可以的。然而，为了在将来重新启动计算机时仍然有效，你需要将这些设置输入到相关的配置文件中。
- en: 'In OpenBSD and NetBSD, you do this by editing */etc/sysctl.conf* and adding
    IP-forwarding lines to the end of the file so the last lines look like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenBSD和NetBSD中，你需要通过编辑*/etc/sysctl.conf*并在文件末尾添加IP转发行，使得最后几行看起来像这样：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In FreeBSD, make the change by putting these lines in your */etc/rc.conf*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在FreeBSD中，通过将这些行添加到*/etc/rc.conf*来进行更改：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The net effect is identical; the FreeBSD *rc* script sets the two values via
    `sysctl` commands. However, a larger part of the FreeBSD configuration is centralized
    into the *rc.conf* file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最终效果是相同的；FreeBSD的*rc*脚本通过`sysctl`命令设置这两个值。然而，FreeBSD的更大一部分配置集中在*rc.conf*文件中。
- en: Now it’s time to check whether all of the interfaces you intend to use are up
    and running. Use **`ifconfig -a`** or **`ifconfig` *interface_name*** to find
    out.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是检查你打算使用的所有接口是否已经启动并运行的时机。使用**`ifconfig -a`**或**`ifconfig` *interface_name***来查看。
- en: 'The output of `ifconfig -a` on one of my systems looks like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我的一台系统上`ifconfig -a`的输出如下所示：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Your setup is most likely somewhat different. Here, the physical interfaces
    on the gateway are `xl0` and `fxp0`. The logical interfaces `lo0` (the loopback
    interface), `enc0` (the encapsulation interface for IPSEC use), and `pflog0` (the
    PF logging device) are probably on your system, too.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你的设置很可能与此不同。这里，网关上的物理接口是`xl0`和`fxp0`。系统中可能还会有逻辑接口`lo0`（回环接口）、`enc0`（用于IPSEC的封装接口）和`pflog0`（PF日志设备）。
- en: If you’re on a dial-up connection, you probably use some variant of PPP for
    the Internet connection, and your external interface is the `tun0` pseudo-device.
    If your connection is via some sort of broadband connection, you may have an Ethernet
    interface to play with. However, if you’re in the significant subset of ADSL users
    who use PPP over Ethernet (PPPoE), the correct external interface will be one
    of the pseudo-devices `tun0` or `pppoe0` (depending on whether you use userland
    `pppoe(8)` or kernel mode `pppoe(4)`), not the physical Ethernet interface.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是拨号连接，可能使用某种变体的PPP进行互联网连接，外部接口是`tun0`伪设备。如果你的连接是通过某种宽带连接，你可能会有一个以太网接口可供使用。然而，如果你是使用以太网PPP（PPPoE）的ADSL用户群体中的一员，那么正确的外部接口将是`tun0`或`pppoe0`中的一个伪设备（取决于你使用的是用户空间`pppoe(8)`还是内核模式`pppoe(4)`），而不是物理以太网接口。
- en: Depending on your specific setup, you may need to do some other device-specific
    configuration for your interfaces. After you have that set up, you can move on
    to the TCP/IP level and deal with the packet-filtering configuration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的具体设置，你可能需要对接口进行一些其他的设备特定配置。在配置完成后，你可以继续处理TCP/IP层面的问题，并进行数据包过滤配置。
- en: 'If you still intend to allow any traffic initiated by machines on the inside,
    your */etc/pf.conf* for your initial gateway setup could look roughly like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然打算允许来自内部机器的任何流量，你的初始网关设置中的*/etc/pf.conf*可能看起来大致如下：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note the use of macros to assign logical names to the network interfaces. Here,
    Realtek Ethernet cards are used, but this is the last time we’ll find this of
    any interest whatsoever in our context.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用宏为网络接口分配逻辑名称。在这里，使用的是Realtek以太网卡，但这是我们在此上下文中最后一次关注这个问题。
- en: In truly simple setups like this one, we may not gain very much by using macros
    like these, but once the rule sets grow a little larger, you’ll learn to appreciate
    the readability they add.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在像这样简单的设置中，使用这些宏可能不会带来太多好处，但一旦规则集变得稍微复杂些，你会开始欣赏它们所带来的可读性。
- en: One possible refinement to this rule set would be to remove the macro `ext_if`
    and replace the `$ext_if` references with the string `egress`, which is the name
    of the interface group that contains the interface that has the default route.
    Interface groups are not macros, so you would write the name `egress` without
    a leading `$` character.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个规则集的一个可能优化是去除宏`ext_if`，并将`$ext_if`的引用替换为字符串`egress`，这是包含默认路由的接口所在的接口组的名称。接口组不是宏，因此你应当不带`$`字符地写出名称`egress`。
- en: Also note the `match` rule with `nat-to`. This is where you handle NAT from
    the nonroutable address inside your local network to the sole official address
    assigned to you. If your network uses official, routable IPv4 addresses, you simply
    leave this line out of your configuration. The `match` rules, which were introduced
    in OpenBSD 4.6, can be used to apply actions when a connection matches the criteria
    without deciding whether a connection should be blocked or passed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意`nat-to`的`match`规则。这是处理从你本地网络中不可路由地址到分配给你的唯一官方地址的NAT的地方。如果你的网络使用官方的、可路由的IPv4地址，你可以直接省略这行配置。`match`规则是OpenBSD
    4.6中引入的，它们可以在连接匹配某些标准时应用动作，而不决定连接是应该被阻止还是通过。
- en: The parentheses surrounding the last part of the `match` rule `($ext_if)` are
    there to compensate for the possibility that the IP address of the external interface
    may be dynamically assigned. This detail will ensure that your network traffic
    runs without serious interruptions, even if the interface’s IP address changes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`match`规则最后部分`($ext_if)`周围的括号是为了补偿外部接口的IP地址可能是动态分配的情况。这个细节将确保即使接口的IP地址发生变化，你的网络流量也能顺利运行，不会出现严重的中断。'
- en: 'It’s time to sum up the rule set we’ve built so far: (1) We block all traffic
    originating outside our own network. (2) We make sure all IPv4 traffic initiated
    by hosts in our local network will pass into the outside world only with the source
    address rewritten to the routable address assigned to the gateway’s external interface.
    (3) Finally, we let all traffic from our local network (IPv4 and IPv6 both) and
    from the gateway itself pass. The keyword `self` in the final `pass` rule is a
    macro-ish reserved word in PF syntax that denotes all addresses assigned to all
    interfaces on the local host.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候总结我们迄今为止构建的规则集了：(1) 我们阻止来自我们自己网络外部的所有流量。 (2) 我们确保所有从我们本地网络中的主机发起的IPv4流量，在进入外部世界时，其源地址会被重写为网关外部接口分配的可路由地址。
    (3) 最后，我们允许来自我们本地网络（IPv4和IPv6均包括）和网关本身的所有流量通过。最后`pass`规则中的`self`关键字是PF语法中的一个类似宏的保留字，表示本地主机上所有接口分配的所有地址。
- en: 'If your operating system runs a pre-OpenBSD 4.7 PF version, your first gateway
    rule set would look something like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的操作系统运行的是OpenBSD 4.7之前的PF版本，你的第一个网关规则集可能看起来像这样：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `nat` rule here handles the translation much as does the `match` rule with
    `nat-to` in the previous example.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`nat`规则处理的转换方式与前一个示例中的`nat-to`的`match`规则类似。
- en: 'On the other hand, this rule set probably allows more traffic than you actually
    want to pass out of your network. In one of the networks where I’ve done a bit
    of work, the main part of the rule set is based on a macro called `client_out`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这个规则集可能允许比你实际希望通过的流量更多。在我曾经工作过的一些网络中，规则集的主要部分基于一个名为`client_out`的宏：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It has this `pass` rule:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它有这个`pass`规则：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This may be a somewhat peculiar selection of ports, but it’s exactly what my
    colleagues there needed at the time. Some of the numbered ports were needed for
    systems that were set up for specific purposes at other sites. Your needs probably
    differ at least in some details, but this should cover some of the more useful
    services.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个有些奇特的端口选择，但它正是我那里的同事们当时所需要的。有些编号端口是为其他站点上为特定目的设置的系统所需要的。你的需求在某些细节上可能有所不同，但这应该涵盖了一些更常用的服务。
- en: 'Here’s another `pass` rule that is useful to those who want the ability to
    administer machines from elsewhere:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一个`pass`规则，对那些希望能够从其他地方管理机器的人很有用：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Or use this form, if you prefer:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢，也可以使用这种格式：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When you leave out the `from` part entirely, the default is `from any`, which
    is quite permissive. It lets you log in from anywhere, which is great if you travel
    a lot and need SSH access from unknown locations around the world. If you’re not
    all that mobile—say you haven’t quite developed the taste for conferences in far-flung
    locations, or you feel your colleagues can fend for themselves while you’re on
    vacation—you may want to tighten up with a `from` part that includes only the
    places where you and other administrators are likely to log in from for legitimate
    reasons.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完全省略`from`部分时，默认值是`from any`，这相当宽松。它允许你从任何地方登录，这对你经常旅行并需要从全球未知地点进行SSH访问时非常有用。如果你不怎么流动——比如你还没完全习惯参加远方的会议，或者你觉得同事们可以在你度假时自己应对——你可能想通过包含仅限你和其他管理员从合法地点登录的`from`部分来加强安全性。
- en: 'Our very basic rule set is still not complete. Next, we need to make the name
    service work for our clients. We start with another macro at the start of our
    rule set:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的非常基础的规则集仍然不完整。接下来，我们需要让名称服务为我们的客户端工作。我们从规则集开始时的另一个宏开始：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is supplemented with a rule that passes the traffic we want through our
    firewall:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过一个规则来补充，该规则允许我们想要的流量通过防火墙：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note the `quick` keyword in this rule. We’ve started writing rule sets that
    consist of several rules, and it’s time to revisit the relationships and interactions
    between them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意此规则中的`quick`关键字。我们已经开始编写由多个规则组成的规则集，现在是时候重新审视它们之间的关系和互动了。
- en: As noted in the previous chapter, the rules are evaluated from top to bottom
    in the sequence they’re written in the configuration file. For each packet or
    connection evaluated by PF, *the last matching rule* in the rule set is the one
    that’s applied.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，规则是按照它们在配置文件中书写的顺序从上到下进行评估的。对于PF评估的每个数据包或连接，*最后匹配的规则*就是被应用的规则。
- en: The `quick` keyword offers an escape from the ordinary sequence. When a packet
    matches a `quick` rule, the packet is treated according to the present rule. The
    rule processing stops without considering any further rules that might have matched
    the packet. As your rule sets grow longer and more complicated, you’ll find this
    quite handy. For example, it’s useful when you need a few isolated exceptions
    to your general rules.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`quick`关键字提供了逃离普通顺序的方式。当一个数据包匹配到`quick`规则时，数据包会按照当前规则进行处理。规则处理停止，不再考虑可能匹配该数据包的其他规则。随着你的规则集变得越来越长和复杂，你会发现这非常方便。例如，当你需要一些与一般规则隔离的例外时，这会非常有用。'
- en: This `quick` rule also takes care of NTP, which is used for time synchronization.
    Common to both the name service and time synchronization protocols is that they
    may, under certain circumstances, communicate alternately over TCP and UDP.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`quick`规则还处理了NTP，它用于时间同步。名称服务和时间同步协议的共同点是，在某些情况下，它们可能会交替通过TCP和UDP进行通信。
- en: Testing Your Rule Set
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试你的规则集
- en: You may not have gotten around to writing that formal test suite for your rule
    sets just yet, but there’s every reason to test that your configuration works
    as expected.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还没来得及为你的规则集编写正式的测试套件，但完全有理由测试你的配置是否按预期工作。
- en: 'The same basic tests in the standalone example from the previous chapter still
    apply. But now you need to test from the other hosts in your network as well as
    from your packet-filtering gateway. For each of the services you specified in
    your `pass` rules, test that machines in your local network get meaningful results.
    From any machine in your local network, enter a command like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章中的独立示例中的基本测试仍然适用。但现在，你需要从你网络中的其他主机以及你的数据包过滤网关进行测试。对于你在`pass`规则中指定的每项服务，测试你本地网络中的机器是否获得了有意义的结果。从你本地网络中的任何机器，输入类似这样的命令：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It should return exactly the same results as when you tested the stand-alone
    rule set in the previous chapter, and traffic for the services you have specified
    should pass^([[16](#ftn.ch03fn04)]).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该返回与前一章中测试独立规则集时完全相同的结果，并且你指定的服务流量应该通过^([[16](#ftn.ch03fn04)])。
- en: You may not think it’s necessary, but it doesn’t hurt to check that the rule
    set works as expected from outside your gateway as well. If you’ve done exactly
    what this chapter says so far, it shouldn’t be possible to contact machines in
    your local network from the outside.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能觉得没必要，但检查一下规则集是否在你的网关外部按预期工作并没有坏处。如果你迄今为止做了本章所说的，那么从外部应该无法联系到你本地网络中的机器。
- en: Why Only IP Addresses—Not Hostnames or Domain Names?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么只有IP地址——而不是主机名或域名？
- en: Looking at the examples up to this point, you’ve probably noticed that the rule
    sets all have macros that expand into IP addresses or address ranges but never
    into hostnames or domain names. You’re probably wondering why. After all, you’ve
    seen that PF lets you use service names in your rule set, so why not include hostnames
    or domain names?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 看到到目前为止的示例，你可能已经注意到规则集中的宏总是展开为IP地址或地址范围，而从不展开为主机名或域名。你可能在想，为什么呢？毕竟，你已经看到PF允许在规则集中使用服务名称，那么为什么不包括主机名或域名呢？
- en: The answer is that if you used domain names and hostnames in your rule set,
    the rule set would be valid only after the name service was running and accessible.
    In the default configuration, PF is loaded before any network services are running.
    This means that if you want to use domain names and hostnames in your PF configuration,
    you’ll need to change the system’s startup sequence (by editing */etc/rc.local*,
    perhaps) to load the name service–dependent rule set only after the name service
    is available. If you have only a limited number of hostnames or domain names you
    want to reference in your PF configuration, it’s likely at least as useful to
    add those as IP addresses to name-mapping entries in your */etc/hosts* file and
    leave the *rc* scripts alone.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，如果你在规则集中使用了域名和主机名，那么规则集只有在名称服务运行并且可访问时才有效。在默认配置下，PF 会在任何网络服务运行之前加载。这意味着，如果你希望在
    PF 配置中使用域名和主机名，你需要改变系统的启动顺序（可能需要编辑 */etc/rc.local*），以便在名称服务可用后再加载依赖名称服务的规则集。如果你只需要引用少量的主机名或域名，将它们作为
    IP 地址添加到 */etc/hosts* 文件的名称映射条目中，并且不更改 *rc* 脚本，可能会更有用。
- en: That Sad Old FTP Thing
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那个悲伤的旧 FTP 协议
- en: 'The short list of real-life TCP ports we looked at a few moments back contained,
    among other things, *FTP*, the classic *file transfer protocol*. FTP is a relic
    of the early Internet, when experiments were the norm and security was not really
    on the horizon in any modern sense. FTP actually predates TCP/IP,^([[17](#ftn.ch03fn05)])
    and it’s possible to track the protocol’s development through more than 50 RFCs.
    After more than 30 years, FTP is both a sad old thing and a problem child—emphatically
    so for anyone trying to combine FTP and firewalls. FTP is an old and weird protocol
    with a lot to dislike. Here are the most common points against it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才简要查看的实际 TCP 端口清单中，包含了*FTP*——经典的*文件传输协议*。FTP 是早期互联网的遗物，那时实验是常态，安全性并不是现代意义上的一个关注点。事实上，FTP
    比 TCP/IP 还要早，^([[17](#ftn.ch03fn05)])，我们可以通过超过 50 个 RFC 来追踪这个协议的发展。经过 30 多年，FTP
    既是一个悲伤的老东西，也是一个问题孩子——特别是对于那些试图将 FTP 和防火墙结合使用的人来说。FTP 是一个古老且奇怪的协议，存在很多值得反感的地方。以下是反对它的最常见几点：
- en: Passwords are transferred in the clear.^([[18](#ftn.ch03fn06)])
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码以明文传输。^([[18](#ftn.ch03fn06)])
- en: The protocol demands the use of at least two TCP connections (control and data)
    on separate ports.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该协议要求至少使用两个 TCP 连接（控制和数据），并且需要使用不同的端口。
- en: When a session is established, data is communicated via ports usually selected
    at random.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当会话建立时，数据通常通过随机选择的端口进行传输。
- en: All of these points make for challenges security-wise, even before considering
    any potential weaknesses in client or server software that may lead to security
    issues. As any network graybeard will tell you, these things tend to crop up when
    you need them the least.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都会带来安全上的挑战，即便在考虑到客户端或服务器软件中的潜在弱点可能导致安全问题之前。正如任何网络老兵所说的，这些问题通常会在你最不需要的时候出现。
- en: Under any circumstances, other more modern and more secure options for file
    transfer exist, such as SFTP and SCP, which feature both authentication and data
    transfer via encrypted connections. Competent IT professionals should have a preference
    for some form of file transfer other than FTP.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，存在其他更现代、更安全的文件传输选项，例如 SFTP 和 SCP，这些协议都通过加密连接进行身份验证和数据传输。称职的 IT 专业人员应该偏好使用除
    FTP 之外的某种文件传输方式。
- en: 'Regardless of our professionalism and preferences, we sometimes must deal with
    things we would prefer not to use at all. In the case of FTP through firewalls,
    we can combat problems by redirecting the traffic to a small program that’s written
    specifically for this purpose. The upside for us is that handling FTP offers us
    a chance to look at two fairly advanced PF features: *redirection* and *anchors.*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不论我们多么专业，也有时候不得不处理一些我们根本不想使用的东西。在通过防火墙使用 FTP 时，我们可以通过将流量重定向到一个专门为此目的编写的小程序来解决问题。对我们来说，处理
    FTP 给了我们一个机会，去了解两个相对先进的 PF 特性：*重定向*和*锚点*。
- en: The easiest way to handle FTP in a default-to-block scenario such as ours is
    to have PF redirect the traffic for that service to an external application that
    acts as a *proxy* for the service. The proxy maintains its own named sub–rule
    set (an *anchor* in PF terminology), where it inserts or deletes rules as needed
    for the FTP traffic. The combination of redirection and the anchor provides a
    clean, well-defined interface between the packet-filtering subsystem and the proxy.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在像我们这样默认阻止的情况下，处理FTP的最简单方法是让PF将该服务的流量重定向到一个外部应用程序，这个应用程序充当该服务的*代理*。代理维护自己的命名子规则集（在PF术语中称为*锚点*），在其中根据需要插入或删除FTP流量的规则。重定向和锚点的组合提供了一个干净、明确的接口，连接数据包过滤子系统和代理。
- en: 'If We Must: ftp-proxy with Divert or Redirect'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果必须：带有Divert或Redirect的ftp-proxy
- en: Enabling FTP transfers through your gateway is amazingly simple, thanks to the
    FTP-proxy program included in the OpenBSD base system. The program is called—you
    guessed it—`ftp-proxy`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过你的网关启用FTP传输非常简单，这要归功于OpenBSD基础系统中包含的FTP代理程序。这个程序叫做——你猜对了——`ftp-proxy`。
- en: 'To enable `ftp-proxy`, you need to add this line to your */etc/rc.conf.local*
    file on OpenBSD:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用`ftp-proxy`，你需要在OpenBSD的*/etc/rc.conf.local*文件中添加这一行：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On FreeBSD, */etc/rc.conf* needs to contain at least the first of these two
    lines:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在FreeBSD中，*/etc/rc.conf*至少需要包含以下两行中的第一行：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you need to specify any command-line options to `ftp-proxy`, you put them
    in the `ftpproxy_flags` variable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为`ftp-proxy`指定任何命令行选项，你可以将它们放入`ftpproxy_flags`变量中。
- en: You can start the proxy manually by running */usr/sbin/ftp-proxy* if you like
    (or even better, use the */etc/rc.d/ftp-proxy* script with the `start` option
    on OpenBSD), and you may want to do this in order to check that the changes to
    the PF configuration you’re about to make have the intended effect.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以手动启动代理，运行*/usr/sbin/ftp-proxy*（或者更好的是，使用OpenBSD上的*/etc/rc.d/ftp-proxy*脚本并加上`start`选项），你可能想这样做，以检查你即将对PF配置所做的更改是否按预期生效。
- en: 'For a basic configuration, you need to add only three elements to your */etc/pf.conf*:
    the anchor and two `pass` rules. The anchor declaration looks like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本配置，你只需要向*/etc/pf.conf*添加三个元素：锚点和两个`pass`规则。锚点声明看起来像这样：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In pre-OpenBSD 4.7 versions, two anchor declarations were needed:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenBSD 4.7之前的版本中，需要两个锚点声明：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The proxy will insert the rules it generates for the FTP sessions here. Then,
    you also need a `pass` rule to let FTP traffic into the proxy:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 代理将在此插入它为FTP会话生成的规则。然后，你还需要一个`pass`规则，以允许FTP流量进入代理：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note the `divert-to` part. This redirects the traffic to the local port, where
    the proxy listens via the highly efficient, local-connections-only divert(4) interface.
    In OpenBSD versions 4.9 and older, the traffic diversion happened via an `rdr-to`.
    If you’re upgrading an existing pre-OpenBSD 5.0 configuration, you’ll need to
    update your `rdr-to` rules for the FTP proxy to use `divert-to` instead.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`divert-to`部分。它将流量重定向到本地端口，在那里代理通过高效的、本地连接专用的divert(4)接口监听流量。在OpenBSD 4.9及之前的版本中，流量重定向是通过`rdr-to`实现的。如果你正在升级一个旧的OpenBSD
    5.0之前的配置，你需要更新FTP代理的`rdr-to`规则，将其改为使用`divert-to`。
- en: 'If your operating system uses a pre-OpenBSD 4.7 PF version, you need this version
    of the redirection rule:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的操作系统使用的是OpenBSD 4.7之前的PF版本，你需要这个版本的重定向规则：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, make sure your rule set contains a `pass` rule to let the packets
    pass from the proxy to the rest of the world, where `$proxy` expands to the address
    to which the proxy daemon is bound:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保你的规则集包含一个`pass`规则，以允许数据包从代理传递到其他地方，在那里，`$proxy`扩展为代理守护进程绑定的地址：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Reload your PF configuration:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载你的PF配置：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Before you know it, your users will thank you for making FTP work.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不久之后，你的用户会感谢你让FTP工作。
- en: Variations on the ftp-proxy Setup
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ftp-proxy设置的变体
- en: The preceding example covers a basic setup where the clients in your local network
    need to contact FTP servers elsewhere. This configuration should work well with
    most combinations of FTP clients and servers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例涵盖了一个基本配置，其中你本地网络中的客户端需要联系其他地方的FTP服务器。这个配置应该与大多数FTP客户端和服务器的组合配合得很好。
- en: You can change the proxy’s behavior in various ways by adding options to the
    `ftpproxy_flags=` line. You may bump into clients or servers with specific quirks
    that you need to compensate for in your configuration, or you may want to integrate
    the proxy in your setup in specific ways, such as assigning FTP traffic to a specific
    queue. For these and other finer points of `ftp-proxy` configuration, your best
    bet is to start by studying the man page.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向`ftpproxy_flags=`行添加选项来改变代理的行为。你可能会遇到一些具有特定怪癖的客户端或服务器，你需要在配置中进行补偿，或者你可能希望以特定方式将代理集成到你的设置中，比如将FTP流量分配到特定的队列。对于这些以及其他`ftp-proxy`配置的细节，最好的办法是从研究手册页开始。
- en: If you’re interested in ways to run an FTP server protected by PF and `ftp-proxy`,
    you could look into running a separate `ftp-proxy` in reverse mode (using the
    `-R` option) on a separate port with its own redirecting `pass` rule. It’s even
    possible to set up the proxy to run in IPv6 mode, but if you’re ahead of the pack
    in running the modern protocol, you’re less likely to bother with FTP as your
    main file transfer protocol.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣了解如何在PF和`ftp-proxy`保护下运行FTP服务器，你可以考虑在单独的端口上以反向模式（使用`-R`选项）运行单独的`ftp-proxy`，并为其设置自己的重定向`pass`规则。甚至可以将代理设置为在IPv6模式下运行，但如果你在运行现代协议方面走在前面，你可能不会再将FTP作为主要的文件传输协议。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*If your PF version predates the ones described here, you’re running on an
    outdated, unsupported operating system. I strongly urge you to schedule an operating
    system upgrade as soon as possible. If an upgrade is for some reason not an option,
    please look up the first edition of this book and study the documentation for
    your operating system for information on how to use some earlier FTP proxies.*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你的PF版本早于这里描述的版本，那么你正在使用一个过时且不受支持的操作系统。我强烈建议你尽快安排操作系统升级。如果由于某种原因升级不可行，请查阅本书的第一版并研究你操作系统的文档，了解如何使用一些早期的FTP代理。*'
- en: Making Your Network Troubleshooting-Friendly
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使你的网络故障排除更友好
- en: 'Making your network troubleshooting-friendly is a potentially large subject.
    Generally, the debugging- or troubleshooting-friendliness of your TCP/IP network
    depends on how you treat the Internet protocol that was designed specifically
    with debugging in mind: ICMP.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使你的网络故障排除更友好是一个可能相当庞大的话题。一般来说，你的TCP/IP网络的调试或故障排除友好性取决于你如何处理专门为调试设计的Internet协议：ICMP。
- en: ICMP is the protocol for sending and receiving *control messages* between hosts
    and gateways, mainly to provide feedback to a sender about any unusual or difficult
    conditions en route to the target host.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP是用于在主机和网关之间发送和接收*控制消息*的协议，主要是为了向发送方提供有关到达目标主机的过程中出现的任何异常或困难情况的反馈。
- en: There’s a lot of ICMP traffic, which usually happens in the background while
    you are surfing the Web, reading mail, or transferring files. Routers (remember,
    you’re building one) use ICMP to negotiate packet sizes and other transmission
    parameters in a process often referred to as *path MTU discovery*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量的ICMP流量，通常在你浏览网页、阅读邮件或传输文件时会在后台发生。路由器（记住，你正在构建一个）使用ICMP来协商数据包大小和其他传输参数，这一过程通常被称为*路径MTU发现*。
- en: You may have heard admins refer to ICMP as either “evil” or, if their understanding
    runs a little deeper, “a necessary evil.” The reason for this attitude is purely
    historical. A few years back, it was discovered that the networking stacks of
    several operating systems contained code that could make the machine crash if
    it were sent a sufficiently large ICMP request.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听过管理员称ICMP为“邪恶”或，如果他们的理解稍微深入一点，则称其为“必要的邪恶”。这种态度的原因纯粹是历史性的。几年前，人们发现一些操作系统的网络堆栈中包含代码，如果收到足够大的ICMP请求，机器可能会崩溃。
- en: One of the companies that was hit hard by this was Microsoft, and you can find
    a lot of material on the *ping of death* bug by using your favorite search engine.
    However, this all happened in the second half of the 1990s, and all modern operating
    systems have thoroughly sanitized their network code since then (at least, that’s
    what we’re led to believe).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 受此影响最严重的公司之一是微软，你可以通过使用你喜欢的搜索引擎找到大量关于*死亡ping*漏洞的资料。然而，这一切发生在1990年代后半期，自那时以来，所有现代操作系统都彻底清理了它们的网络代码（至少，这是我们被告知的情况）。
- en: One of the early work-arounds was to simply block either ICMP echo (ping) requests
    or even all ICMP traffic. That measure almost certainly led to poor performance
    and hard-to-debug network problems. In some places, however, these rule sets have
    been around for almost two decades, and the people who put them there are still
    scared. There’s most likely little to no reason to worry about destructive ICMP
    traffic anymore, but here we’ll look at how to manage just what ICMP traffic passes
    to or from your network.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的解决方法之一是直接阻止 ICMP 回显（ping）请求，甚至是所有 ICMP 流量。这种措施几乎肯定导致了性能差和难以调试的网络问题。然而，在某些地方，这些规则集已经存在了将近二十年，而且设置这些规则的人仍然很害怕。现在，几乎没有理由再担心有害的
    ICMP 流量了，但我们还是会看看如何管理哪些 ICMP 流量能够进出你的网络。
- en: In modern IPv6 networks, the updated `icmp6` protocol plays a more crucial role
    than ever in parameter passing and even host configuration, and network admins
    are playing a high-stakes game while learning the finer points of blocking or
    passing `icmp6` traffic. To a large extent, issues that are relevant for IPv4
    ICMP generally apply to IPv6 ICMP6 as well, but in addition, ICMP6 is used for
    several mechanisms that were handled differently in IPv4\. We’ll dip into some
    of these issues after walking through the issues that are relevant for both IP
    protocol versions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代的 IPv6 网络中，更新后的 `icmp6` 协议在参数传递甚至主机配置中扮演着比以往更为关键的角色，网络管理员在学习如何屏蔽或允许 `icmp6`
    流量时，实际上是在玩一场高风险的游戏。在很大程度上，IPv4 的 ICMP 问题对于 IPv6 的 ICMP6 也同样适用，但除了这些，ICMP6 还用于几个在
    IPv4 中处理方式不同的机制。我们将在梳理适用于这两个 IP 协议版本的相关问题后，再深入这些问题。
- en: Do We Let It All Through?
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们是否让它全部通过？
- en: The obvious question becomes, “If ICMP is such a good and useful thing, shouldn’t
    we let it all through all the time?” The answer is that it depends.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 显然的问题是：“如果 ICMP 是如此有用且重要的东西，我们是不是应该一直让它全部通过？”答案是，这取决于具体情况。
- en: 'Letting diagnostic traffic pass unconditionally makes debugging easier, of
    course, but it also makes it relatively easy for others to extract information
    about your network. So, a rule like the following might not be optimal if you
    want to cloak the internal workings of your IPv4 network:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，让诊断流量不加限制地通过可以让调试变得更容易，但这也让其他人相对容易获取到关于你网络的信息。所以，如果你想隐藏你 IPv4 网络的内部工作原理，像下面这样的规则可能不是最优的：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you want the same free flow of messages for your IPv6 traffic, the corresponding
    rule is this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让你的 IPv6 流量也有类似的自由信息流通，对应的规则是这样的：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In all fairness, it should also be said that you might find some ICMP and ICMP6
    traffic quite harmlessly riding piggyback on your `keep state` rules.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 公正地说，还应该提到，你可能会发现一些 ICMP 和 ICMP6 流量无害地通过你的 `keep state` 规则悄悄进行。
- en: 'The Easy Way Out: The Buck Stops Here'
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最简单的解决办法：问题在这里解决
- en: 'The easiest solution could very well be to allow all ICMP and ICMP6 traffic
    from your local network through and to let probes from elsewhere stop at your
    gateway:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的解决方案可能是允许本地网络的所有 ICMP 和 ICMP6 流量通过，同时让来自其他地方的探测在你的网关处停止：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is assuming, of course that you’ve identified the list of desirable ICMP
    and ICMP6 types to fill out your macro definitions. We’ll get back to those shortly.
    Stopping probes at the gateway might be an attractive option anyway, but let’s
    look at a few other options that’ll demonstrate some of PF’s flexibility.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是假设你已经识别了你希望通过的 ICMP 和 ICMP6 类型，并将它们填入你的宏定义中。稍后我们会回到这些内容。无论如何，停止网关的探测可能是一个有吸引力的选项，但让我们看看其他几种选项，这些选项能展示
    PF 的灵活性。
- en: Letting ping Through
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让 ping 通过
- en: 'The rule set we have developed so far in this chapter has one clear disadvantage:
    Common troubleshooting commands, such as `ping` and `traceroute` (and their IPv6
    equivalents, `ping6` and `traceroute6`), will not work. That may not matter too
    much to your users, and because it was the `ping` command that scared people into
    filtering or blocking ICMP traffic in the first place, there are apparently some
    people who feel we’re better off without it. However, you’ll find these troubleshooting
    tools useful. And with a couple of small additions to the rule set, they will
    be available to you.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在本章中开发的规则集有一个明显的缺点：常用的故障排除命令，如 `ping` 和 `traceroute`（以及它们的 IPv6 等价命令
    `ping6` 和 `traceroute6`），将无法使用。这对于你的用户来说可能影响不大，而且正是 `ping` 命令最早让人们害怕 ICMP 流量，从而去过滤或阻止它，所以显然有些人认为没有它我们反而会更好。然而，你会发现这些故障排除工具非常有用。只需对规则集做几个小的调整，它们就能重新可用。
- en: 'The diagnostic commands `ping` and `ping6` rely on the ICMP and ICMP6 *echo
    request* (and the matching *echo reply*) types, and in order to keep our rule
    set tidy, we start by defining another set of macros:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 诊断命令`ping`和`ping6`依赖于ICMP和ICMP6的*回显请求*（以及匹配的*回显回复*）类型，为了保持规则集的整洁，我们首先定义另一个宏集：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we add rules that use the definitions:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加使用这些定义的规则：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The macros and the rules mean that ICMP and ICMP6 packets with type *echo request*
    will be allowed through and matching *echo replies* will be allowed to pass back
    due to PF’s stateful nature. This is all the `ping` and `ping6` commands need
    in order to produce their expected results.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏和规则意味着类型为*回显请求*的ICMP和ICMP6数据包将被允许通过，并且匹配的*回显回复*将被允许返回，因为PF具有状态性特征。这就是`ping`和`ping6`命令所需的一切，以产生它们预期的结果。
- en: If you need more or other types of ICMP or ICMP6 packets to go through, you
    can expand `icmp_types` and `icmp6_types` to lists of those packet types you want
    to allow.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多或其他类型的ICMP或ICMP6数据包通过，你可以将`icmp_types`和`icmp6_types`扩展为你希望允许的那些数据包类型的列表。
- en: Helping traceroute
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 帮助traceroute
- en: 'The `traceroute` command (and the IPv6 variant `traceroute6`) is useful when
    your users claim that the Internet isn’t working. By default, Unix `traceroute`
    uses UDP connections according to a set formula based on destination. The following
    rules work with the `traceroute` and `traceroute6` commands on all forms of Unix
    I’ve had access to, including GNU/Linux:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`traceroute`命令（以及IPv6版本`traceroute6`）在用户声称互联网无法连接时非常有用。默认情况下，Unix的`traceroute`使用UDP连接，依据基于目标的固定公式。以下规则适用于所有我能访问的Unix版本中的`traceroute`和`traceroute6`命令，包括GNU/Linux：'
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This also gives you a first taste of what port ranges look like. They’re quite
    useful in some contexts.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这也让你初步了解了端口范围的样子。在某些情况下它们非常有用。
- en: Experience so far indicates that `traceroute` and `traceroute6` implementations
    on other operating systems work roughly the same way. One notable exception is
    Microsoft Windows. On that platform, the *tracert.exe* program and its IPv6 sister
    *tracert6.exe* use ICMP echo requests for this purpose. So if you want to let
    Windows traceroutes through, you need only the first rule, much as when letting
    `ping` through. The Unix `traceroute` program can be instructed to use other protocols
    as well and will behave remarkably like its Microsoft counterpart if you use its
    `-I` command-line option. You can check the `traceroute` man page (or its source
    code, for that matter) for all the details.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止的经验表明，其他操作系统上的`traceroute`和`traceroute6`实现方式大致相同。一个显著的例外是微软Windows平台。在该平台上，*tracert.exe*程序及其IPv6版本*tracert6.exe*使用ICMP回显请求来实现此目的。因此，如果你希望让Windows的traceroute通过，你只需要第一个规则，就像允许`ping`通过一样。Unix的`traceroute`程序也可以被指示使用其他协议，并且如果你使用其`-I`命令行选项，它将表现得与微软的对应程序非常相似。你可以查阅`traceroute`手册页（或者它的源代码）来获取所有详细信息。
- en: This solution is based on a sample rule I found in an `openbsd-misc` post. I’ve
    found that list, and the searchable list archives (accessible among other places
    from *[http://marc.info/](http://marc.info/)*), to be a valuable resource whenever
    you need OpenBSD or PF-related information.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案基于我在`openbsd-misc`帖子中找到的一个示例规则。我发现了这个列表，并且可以在* [http://marc.info/](http://marc.info/)*等地方访问的可搜索的列表存档，是你需要OpenBSD或PF相关信息时一个有价值的资源。
- en: Path MTU Discovery
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路径MTU发现
- en: The last bit I’ll remind you about when it comes to troubleshooting is the path
    MTU discovery. Internet protocols are designed to be device-independent, and one
    consequence of device independence is that you cannot always predict reliably
    what the optimal packet size is for a given connection. The main constraint on
    your packet size is called the *maximum transmission unit*, or *MTU*, which sets
    the upper limit on the packet size for an interface. The `ifconfig` command will
    show you the MTU for your network interfaces.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在故障排除时我最后要提醒你的一点是路径MTU发现。互联网协议被设计为设备无关的，而设备无关的一个后果是你无法总是可靠地预测给定连接的最佳数据包大小。数据包大小的主要限制称为*最大传输单元*，或*MTU*，它设置了接口数据包大小的上限。`ifconfig`命令将显示你的网络接口的MTU。
- en: 'Modern TCP/IP implementations expect to be able to determine the correct packet
    size for a connection through a process that simply involves sending packets of
    varying sizes within the MTU of the local link with the “do not fragment” flag
    set. If a packet then exceeds the MTU somewhere along the way to the destination,
    the host with the lower MTU will return an ICMP packet indicating “type 3, code
    4” and quoting its local MTU when the local upper limit has been reached. Now,
    you don’t need to dive for the RFCs right away. Type 3 means *destination unreachable*,
    and code 4 is short for *fragmentation needed, but the “do not fragment” flag
    is set*. So if your connections to other networks, which may have MTUs that differ
    from your own, seem suboptimal, you could try changing your list of ICMP types
    slightly to let the IPv4 destination-unreachable packets through:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现代TCP/IP实现期望通过一个过程来确定连接的正确数据包大小，该过程仅涉及在本地链路的MTU范围内发送大小不同的数据包，并设置“不要分片”标志。如果数据包在到达目的地的过程中超出了某处的MTU，具有较低MTU的主机将返回一个ICMP数据包，指示“类型3，代码4”，并在本地上限已达到时引用其本地MTU。现在，你不需要马上去查RFC。类型3表示*目的地不可达*，代码4表示*需要分片，但“不要分片”标志已设置*。因此，如果你与其他网络的连接（它们的MTU可能与你的不同）似乎表现不佳，你可以尝试稍微更改你的ICMP类型列表，允许IPv4目的地不可达数据包通过：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see, this means you do not need to change the `pass` rule itself:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这意味着你不需要修改`pass`规则本身：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now I’ll let you in on a little secret: In almost all cases, these rules aren’t
    necessary for purposes of path MTU discovery (but they don’t hurt either). However,
    even though the default PF `keep state` behavior takes care of most of the ICMP
    traffic you’ll need, PF does let you filter on all variations of ICMP types and
    codes. For IPv6, you’d probably want to let the more common ICMP6 diagnostics
    through, such as the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我要告诉你一个小秘密：在几乎所有情况下，这些规则对于路径MTU发现来说并不是必须的（但它们也无妨）。然而，尽管PF的默认`keep state`行为可以处理大部分你需要的ICMP流量，PF确实允许你过滤所有ICMP类型和代码的变体。对于IPv6，你可能希望让更常见的ICMP6诊断信息通过，例如以下内容：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This means that we let echo requests and destination unreachable, time exceeded,
    and parameter problem messages pass for IPv6 traffic. Thanks to the macro definitions,
    you don’t need to touch the `pass` rule for the ICMP6 case either:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们允许回显请求、目的地不可达、超时以及参数问题消息通过IPv6流量。感谢宏定义，你也无需更改ICMP6情况的`pass`规则：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: But it’s worth keeping in mind that IPv6 hosts rely on ICMP6 messages for automatic
    configuration-related tasks, and you may want to explicitly filter in order to
    allow or deny specific ICMP6 types at various points in your network.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 但值得记住的是，IPv6主机依赖ICMP6消息来执行自动配置相关任务，你可能需要显式地过滤，以便在网络中的不同位置允许或拒绝特定的ICMP6类型。
- en: For example, you’ll want to let a router and its clients exchange router solicitation
    and router advertisement messages (ICMP6 type `routeradv` and `routersol`, respectively),
    while you may want to make sure that neighbor advertisements and neighbor solicitations
    (ICMP6 type `neighbradv` and `neighbrsol`, respectively) stay confined within
    their directly connected networks.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能希望让路由器及其客户端交换路由请求和路由通告消息（分别为ICMP6类型`routeradv`和`routersol`），同时，你可能希望确保邻居通告和邻居请求（分别为ICMP6类型`neighbradv`和`neighbrsol`）仅限于它们直接连接的网络内。
- en: If you want to delve into more detail, the list of possible types and codes
    are documented in the `icmp(4)` and `icmp6(4)` man pages. The background information
    is available in the RFCs.^([[19](#ftn.ch03fn07)])
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解更多细节，可能的类型和代码列表已经在`icmp(4)`和`icmp6(4)`手册页中记录。背景信息可以在RFC文档中找到。^([[19](#ftn.ch03fn07)])
- en: Tables Make Your Life Easier
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表格让你的生活更轻松
- en: By now, you may be thinking that this setup gets awfully static and rigid. There
    will, after all, be some kinds of data relevant to filtering and redirection at
    a given time, but they don’t deserve to be put into a configuration file! Quite
    right, and PF offers mechanisms for handling those situations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能会觉得这个设置显得非常静态和僵化。毕竟，某些时间点可能会有一些与过滤和重定向相关的数据，但它们不值得被写入配置文件！说得对，PF提供了处理这些情况的机制。
- en: '*Tables* are one such feature. They’re useful as lists of IP addresses that
    can be manipulated without reloading the entire rule set and also when fast lookups
    are desirable.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*表格*就是这样的一个功能。它们作为IP地址列表非常有用，可以在不重新加载整个规则集的情况下进行操作，并且在需要快速查找时也非常实用。'
- en: 'Table names are always enclosed in `< >`, like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 表格名称总是用`< >`括起来，像这样：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, the network `192.168.2.0/24` is part of the table with one exception:
    The address `192.168.2.5` is excluded using the `!` operator (logical NOT). The
    keyword `persist` makes sure the table itself will exist, even if no rules currently
    refer to it.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to load tables from files where each item is on a separate
    line, such as the file */etc/clients*:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This, in turn, is used to initialize the table in */etc/pf.conf*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So, for example, you can change one of our earlier rules to read like this
    to manage outgoing traffic from your client computers:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'With this in hand, you can manipulate the table’s contents live, like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that this changes the in-memory copy of the table only, meaning that the
    change will not survive a power failure or reboot, unless you arrange to store
    your changes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'You might opt to maintain the on-disk copy of the table with a `cron` job that
    dumps the table content to disk at regular intervals, using a command such as
    the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Alternatively, you could edit the */etc/clients* file and replace the in-memory
    table contents with the file data:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For operations you’ll be performing frequently, sooner or later, you’ll end
    up writing shell scripts. It’s likely that routine operations on tables, such
    as inserting or removing items or replacing table contents, will be part of your
    housekeeping scripts in the near future.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: One common example is to enforce network access restrictions via `cron` jobs
    that replace the contents of the tables referenced as `from` addresses in the
    `pass` rules at specific times. In some networks, you may even need different
    access rules for different days of the week. The only real limitations lie in
    your own needs and your creativity.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be returning to some handy uses of tables frequently over the next chapters,
    and we’ll look at a few programs that interact with tables in useful ways.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: ^([[13](#ch03fn01)]) In fact, the `keep state` part denotes the default behavior
    and is redundant if you’re working with a PF version taken from OpenBSD 4.1 or
    later. However, there’s generally no need to remove the specification from existing
    rules you come across when upgrading from earlier versions. To ease the transition,
    the examples in this book will make this distinction when needed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: ^([[14](#ch03fn02)]) RFC 1631, “The IP Network Address Translator (NAT),” dated
    May 1994, and RFC 1918, “Address Allocation for Private Internets,” dated February
    1996, provide the details about NAT.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: ^([[15](#ch03fn03)]) To quote the project home page at *[http://www.kame.net/](http://www.kame.net/)*,
    “The KAME project was a joint effort of six companies in Japan to provide a free
    stack of IPv6, IPsec, and Mobile IPv6 for BSD variants.” The main research and
    development activities were considered complete in March 2006, with only maintenance
    activity continuing now that the important parts have been incorporated into the
    relevant systems.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: ^([[16](#ch03fn04)]) This is true unless, of course, the information changed
    in the meantime. Some sysadmins are fond of practical jokes, but most of the time
    changes in DNS zone information are due to real-world needs in that particular
    organization or network.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[16](#ch03fn04)]) 除非信息在此期间发生了变化，否则这一点是正确的。当然，有些系统管理员喜欢恶作剧，但大多数情况下，DNS 区域信息的变化是由于该特定组织或网络的实际需求。
- en: ^([[17](#ch03fn05)]) The earliest RFC describing the FTP protocol is RFC 114,
    dated April 10, 1971\. The switch to TCP/IP happened with FTP version 5, as defined
    in RFCs 765 and 775, dated June and December 1980, respectively.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[17](#ch03fn05)]) 描述 FTP 协议的最早 RFC 是 RFC 114，日期为 1971年4月10日。随着 FTP 版本 5 的推出，切换到
    TCP/IP 协议，该版本定义在 RFC 765 和 775 中，分别发布于 1980年6月和12月。
- en: ^([[18](#ch03fn06)]) An encrypted version of the protocol, dubbed FTPS, is specified
    in RFC4217, but support remains somewhat spotty.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[18](#ch03fn06)]) 一种加密版本的协议，称为 FTPS，在 RFC4217 中有详细说明，但其支持仍然有些不稳定。
- en: ^([[19](#ch03fn07)]) The main RFCs describing ICMP and some related techniques
    are 792, 950, 1191, 1256, 2521, and 6145\. ICMP updates for IPv6 are in RFC 3542
    and RFC 4443\. These documents are available in a number of places on the Web,
    such as *[http://www.ietf.org/](http://www.ietf.org/)* and *[http://www.faqs.org/](http://www.faqs.org/)*,
    and probably also via your package system.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ^([[19](#ch03fn07)]) 描述 ICMP 及相关技术的主要 RFC 包括 792、950、1191、1256、2521 和 6145。IPv6
    的 ICMP 更新在 RFC 3542 和 RFC 4443 中。这些文档可以在互联网上的多个地方找到，例如 *[http://www.ietf.org/](http://www.ietf.org/)*
    和 *[http://www.faqs.org/](http://www.faqs.org/)*，并可能也可以通过你的包管理系统访问。
