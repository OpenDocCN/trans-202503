<html><head></head><body>
<h2 class="h2" id="app01"><span epub:type="pagebreak" id="page_241"/><strong><span class="big">A</span></strong><br/><strong>TOOLS OF THE TRADE</strong></h2>&#13;
<div class="image1"><img src="graphics/common-01.jpg" alt="image"/></div>&#13;
<p class="noindent">This section discusses different tools that you may want to use when researching a vehicle. I’ve chosen to focus on low-cost devices and software because it’s important to me that as many people as possible participate in the research.</p>&#13;
<p class="indent">Open Garages is willing to showcase and promote tools to aid with automotive research. If your company produces a great product, feel free to contact Open Garages, but unless there’s an open way to contribute to your tool, don’t expect free publicity.</p>&#13;
<h3 class="h3" id="app01lev1sec1"><strong>Hardware</strong></h3>&#13;
<p class="noindent">In this section, we’ll cover boards, like the ChipWhisperer, as well as dongle-like devices that provide CAN connectivity. We’ll first look at lower-cost, open source hardware and then explore some higher-end devices for those willing to spend a bit more money.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_242"/>Though there are many cost-effective devices for communicating with the CAN bus, the software needed to interact with these devices can be lacking, so you’ll often need to write your own.</p>&#13;
<h4 class="h4" id="app01lev2sec1"><strong><em>Lower-End CAN Devices</em></strong></h4>&#13;
<p class="noindent">These devices are useful for sniffing the contents of your CAN bus and injecting packets. They range from hobbyist-level boards to professional devices that support lots of custom features and can handle many different CAN buses simultaneously.</p>&#13;
<h5 class="h5" id="app01lev3sec1"><strong>Arduino Shields</strong></h5>&#13;
<p class="noindentb">Numerous Arduino and Arduino-like devices ($20 to $30, <em><a href="https://www.arduino.cc/">https://www.arduino.cc/</a></em>) will support CAN with the addition of an Arduino shield. Here are some Arduino shields that support CAN:</p>&#13;
<p class="uln"><strong>CANdiy-Shield</strong> MCP2515 CAN controller with two RJ45 connectors and a protoarea</p>&#13;
<p class="uln"><strong>ChuangZhou CAN-Bus Shield</strong> MCP2515 CAN controller with a D-sub connector and screw terminals</p>&#13;
<p class="uln"><strong>DFRobot CAN-Bus Shield</strong> STM32 controller with a D-sub connector</p>&#13;
<p class="uln"><strong>SeeedStudio SLD01105P CAN-Bus Shield</strong> MCP2515 CAN controller with a D-sub connector</p>&#13;
<p class="uln"><strong>SparkFun SFE CAN-Bus Shield</strong> MCP2515 CAN controller with a D-sub connector and an SD card holder; has connectors for an LCD and GPS module</p>&#13;
<p class="indentt">These shields are all pretty similar. Most run the MCP2515 CAN controller, though the DFRobot shield uses a STM32, which is faster with more buffer memory.</p>&#13;
<p class="indent">Regardless of which shield you choose, you’ll have to write code for the Arduino in order to sniff packets. Each shield comes with a library designed to interface with the shield programmatically. Ideally, these buses should support something like the LAWICEL protocol, which allows them to send and receive packets over serial via a userspace tool on the laptop, such as SocketCAN.</p>&#13;
<h5 class="h5" id="app01lev3sec2"><strong>Freematics OBD-II Telematics Kit</strong></h5>&#13;
<p class="noindent">This Arduino-based OBD-II Bluetooth adapter kit has both an OBD-II device and a data logger, and it comes with GPS, an accelerometer, and gyro and temperature sensors.</p>&#13;
<h5 class="h5" id="app01lev3sec3"><strong>CANtact</strong></h5>&#13;
<p class="noindent">CANtact, an open source device by Eric Evenchick, is a very affordable USB CAN device that works with Linux SocketCAN. It uses a DB 9 connector and <span epub:type="pagebreak" id="page_243"/>has the unique advantage of using jumper pins to change which pins are CAN and ground—a feature that allows it to support both US- and UK-style DB9 to OBD-II connectors. You can get CANtact from <em><a href="http://cantact.io/">http://cantact.io/</a></em>.</p>&#13;
<h5 class="h5" id="app01lev3sec4"><strong>Raspberry Pi</strong></h5>&#13;
<p class="indent">The Raspberry Pi is an alternative to the Arduino that costs about $30 to $40. The Pi provides a Linux operating system but doesn’t include a CAN transceiver, so you’ll need to purchase a shield.</p>&#13;
<p class="indentb">One of the advantages of using a Raspberry Pi over an Arduino is that it allows you to use the Linux SocketCAN tools directly, without the need to buy additional hardware. In general, a Raspberry Pi can talk to an MCP2515 over SPI with just some basic wiring. Here are some Raspberry Pi implementations:</p>&#13;
<p class="uln"><strong>Canberry</strong> MCP2515 CAN controller with screw terminals only (no D-sub connector; $23)</p>&#13;
<p class="uln"><strong>Carberry</strong> Two CAN bus lines and two GMLAN lines, LIN, and infrared (doesn’t appear to be an open source shield; $81)</p>&#13;
<p class="uln"><strong>PICAN CAN-Bus Board</strong> MCP2515 CAN controller with D-sub connector and screw terminals ($40 to $50)</p>&#13;
<h5 class="h5" id="app01lev3sec5"><strong>ChipKit Max32 Development Board and NetworkShield</strong></h5>&#13;
<p class="noindent">The ChipKit board is a development board that together with the NetworkShield can give you a network-interpretable CAN system, as discussed in “<a href="ch05.html#ch05lev2sec10">Translating CAN Bus Messages</a>” on <a href="ch05.html#page_85">page 85</a>. About $110, this open source hardware solution is touted by the OpenXC standard and supports prebuilt firmware from OpenXC, but you can also write your own firmware for it and do raw CAN.</p>&#13;
<h5 class="h5" id="app01lev3sec6"><strong>ELM327 Chipset</strong></h5>&#13;
<p class="noindent">The ELM327 chipset is by far the cheapest chipset available at anywhere (from $13 to $40), and it’s used in most cheap OBD device. It communicates with the OBD over serial and comes with just about any type of connector you can think of, from USB to Bluetooth, Wi-Fi, and so on. You can connect to ELM327 devices over serial, and they’re capable of sending packets other than OBD/UDS packets. For a full list of commands using the ELM327, see the data sheet at <em><a href="http://elmelectronics.com/DSheets/ELM327DS.pdf">http://elmelectronics.com/DSheets/ELM327DS.pdf</a></em>.</p>&#13;
<p class="indent">Unfortunately, the available CAN Linux tools won’t run on the ELM327, but Open Garages has begun a web initiative that includes sniffing drivers for the ELM327 called CANiBUS (<em><a href="https://github.com/Hive13/CANiBUS/">https://github.com/Hive13/CANiBUS/</a></em>). Be forewarned that the ELM327 has limited buffer space, so you’ll lose packets when sniffing and transmission can be a bit imprecise. If you’re in a pinch, however, this is the cheapest route.</p>&#13;
<p class="indent">If you’re willing to open the device and solder a few wires to your ELM327, you can reflash the firmware and convert it into a LAWICEL-compatible device, which allows your uber cheap ELM327 to work with <span epub:type="pagebreak" id="page_244"/>Linux and show up as an slcanX device! (You’ll find information on how to flash your ELM327 on the Area 515 makerspace blog from Des Moines, Iowa, at <em><a href="https://area515.org/elm327-hacking/">https://area515.org/elm327-hacking/</a></em>.)</p>&#13;
<h5 class="h5" id="app01lev3sec7"><strong>GoodThopter Board</strong></h5>&#13;
<p class="noindent">Travis Goodspeed, a well-known hardware hacker, has released an open source, low-cost board with a CAN interface called the GoodThopter. The GoodThopter, based on his popular GoodFet devices, uses MCP2515 and communicates over serial with its own custom interface. You’ll need to completely assemble and solder together the device yourself, but doing so should cost just a few dollars, depending on the parts you have available at your local hackerspace.</p>&#13;
<h5 class="h5" id="app01lev3sec8"><strong>ELM-USB Interface</strong></h5>&#13;
<p class="noindent">OBDTester.com sells a commercial ELM-32x-compatible device for around $60. OBDTester.com are the maintainers of the PyOBD library (see “<a href="app01.html#app01lev1sec2">Software</a>” on <a href="app01.html#page_246">page 246</a>).</p>&#13;
<h5 class="h5" id="app01lev3sec9"><strong>CAN232 and CANUSB Interface</strong></h5>&#13;
<p class="noindent">LAWICEL AB produces the commercial CAN device CAN232, which plugs into an RS232 port with a DB9 connector, and a USB version called CANUSB (the latter goes for $110 to $120). Because they’re made by the inventors of the LAWICEL protocol, these devices are guaranteed to work with the <span class="literal">can-utils</span> serial link modules.</p>&#13;
<h5 class="h5" id="app01lev3sec10"><strong>VSCOM Adapter</strong></h5>&#13;
<p class="noindent">The VSCOM is an affordable commercial USB CAN module from Vision Systems (<em><a href="http://www.vscom.de/usb-to-can.htm">http://www.vscom.de/usb-to-can.htm</a></em>) that uses the LAWICEL protocol. VSCOM works with the Linux <span class="literal">can-utils</span> over serial link (slcan) and provides good results. The device costs around $100 to $130.</p>&#13;
<h5 class="h5" id="app01lev3sec11"><strong>USB2CAN Interface</strong></h5>&#13;
<p class="noindent">The USB2CAN converter from 8devices (<em><a href="http://www.8devices.com/usb2can/">http://www.8devices.com/usb2can/</a></em>) is the cheapest alternative to a nonserial CAN interface. This small, commercial USB device will show up as a standard can0 device in Linux and has the most integrated support in this price range. Most devices that show up as canX raw devices are PCI cards and typically cost significantly more than this device.</p>&#13;
<h5 class="h5" id="app01lev3sec12"><strong>EVTV Due Board</strong></h5>&#13;
<p class="noindent">EVTV.me (<em><a href="http://store.evtv.me/">http://store.evtv.me/</a></em>) specializes in electric car conversions. They make lots of great tools for doing crazy things to your historic vehicle, like adding a Tesla drivetrain to it. One of their tools is a $100 open source CAN sniffer called the EVTV Due, which is basically an Arduino Due with <span epub:type="pagebreak" id="page_245"/>a built-in CAN transceiver and handle-screw terminals to interface with your CAN lines. This board was originally written to work solely with their SavvyCAN software, which uses their Generalized Vehicle Reverse Engineering Tool (GVRET), but it now supports SocketCAN as well.</p>&#13;
<h5 class="h5" id="app01lev3sec13"><strong>CrossChasm C5 Data Logger</strong></h5>&#13;
<p class="noindent">The CrossChasm C5 (<em><a href="http://www.crosschasm.com/technology/data-logging/">http://www.crosschasm.com/technology/data-logging/</a></em>) is a commercial device that supports the Ford VI firmware and costs about $120. The C5 supports the VI, which is also known as the CAN translator, to convert CAN messages to the OpenXC format, and it converts some proprietary CAN packets into a generic format to send over Bluetooth.</p>&#13;
<h5 class="h5" id="app01lev3sec14"><strong>CANBus Triple Board</strong></h5>&#13;
<p class="noindent">As I write this, the CANBus Triple (<em><a href="http://canb.us/">http://canb.us/</a></em>) is still in development. It uses a wiring harness designed to support Mazda, but it supports three CAN buses of any vehicle.</p>&#13;
<h4 class="h4" id="app01lev2sec2"><strong><em>Higher-End CAN Devices</em></strong></h4>&#13;
<p class="noindent">Higher-end devices will cost you more money, but they’re capable of receiving more simultaneous channels and offer more memory to help prevent packet loss. High-performance tools often support eight channels or more, but unless you’re working on racing vehicles, you probably don’t need that many channels, so be sure that you need devices like these before dropping any cash.</p>&#13;
<p class="indent">These devices often come with their own proprietary software or a software subscription at sometimes significant added cost. Make sure the software associated with the device you choose does what you want because you’ll usually be locked into their API and preferred hardware. If you need higher-end devices that work with Linux, try Kvaser, Peak, or EMS Wünsche. The devices from these companies typically use the sja1000 chipset at prices starting around $400.</p>&#13;
<h5 class="h5" id="app01lev3sec15"><strong>CAN Bus Y-Splitter</strong></h5>&#13;
<p class="noindent">A CAN bus Y-splitter is a very simple device that’s basically one DLC connector broken into two connectors, which allows you to plug a device into one port and a CAN sniffer into the other. These typically cost around $10 on Amazon and are actually quite simple to make yourself.</p>&#13;
<h5 class="h5" id="app01lev3sec16"><strong>HackRF SDR</strong></h5>&#13;
<p class="noindent">HackRF is an SDR from Great Scott Gadgets (<em><a href="https://greatscottgadgets.com/hackrf/">https://greatscottgadgets.com/hackrf/</a></em>). This open source hardware project can receive and transmit signals from 10 MHz to 6 GHz. At about $330, you can’t get a better SDR for the price.</p>&#13;
<h5 class="h5" id="app01lev3sec17"><span epub:type="pagebreak" id="page_246"/><strong>USRP SDR</strong></h5>&#13;
<p class="noindent">USRP (<em><a href="http://www.ettus.com/">http://www.ettus.com/</a></em>) is a professional, modular SDR device that you can build to suit your needs. USRP is open source to varying degrees at prices ranging from $500 to $2,000.</p>&#13;
<h5 class="h5" id="app01lev3sec18"><strong>ChipWhisperer Toolchain</strong></h5>&#13;
<p class="noindent">NewAE Technologies produces the ChipWhisperer (<em><a href="http://newae.com/chipwhisperer/">http://newae.com/chipwhisperer/</a></em>). As discussed in “<a href="ch08.html#ch08lev1sec3">Side-Channel Analysis with the ChipWhisperer</a>” on <a href="ch08.html#page_134">page 134</a>, the ChipWhisperer is a system for side-channel attacks, such as power analysis and clock glitching. Similar systems usually cost $30,000 or more, but the ChipWhisperer is an open source system that costs between $1,000 and $1,500.</p>&#13;
<h5 class="h5" id="app01lev3sec19"><strong>Red Pitaya Board</strong></h5>&#13;
<p class="noindent">Red Pitaya (<em><a href="http://redpitaya.com/">http://redpitaya.com/</a></em>) is an open source measurements tool that for around $500 replaces expensive measurement tools such as oscilloscopes, signal generators, and spectrum analyzers. Red Pitaya has LabView and Matlab interfaces, and you can write your own tools and applications for it. It even supports extensions for things like Arduino shields.</p>&#13;
<h3 class="h3" id="app01lev1sec2"><strong>Software</strong></h3>&#13;
<p class="noindent">As we did with hardware, we’ll focus first on open source tools and then cover more expensive ones.</p>&#13;
<h4 class="h4" id="app01lev2sec3"><strong><em>Wireshark</em></strong></h4>&#13;
<p class="noindent">Wireshark (<em><a href="https://www.wireshark.org/">https://www.wireshark.org/</a></em>) is a popular network sniffing tool. It is possible to use Wireshark on a CAN bus network as long as you are running Linux and using SocketCAN. Wireshark doesn’t have any features to help sort or decode CAN packets, but it could be useful in a pinch.</p>&#13;
<h4 class="h4" id="app01lev2sec4"><strong><em>PyOBD Module</em></strong></h4>&#13;
<p class="noindent">PyOBD (<em><a href="http://www.obdtester.com/pyobd">http://www.obdtester.com/pyobd</a></em>)—also known as <em>PyOBD2</em> and <em>PyOBD-II</em>—is a Python module that communicates with ELM327 devices (see <a href="app01.html#app01fig1">Figures A-1</a> and <a href="app01.html#app01fig2">A-2</a>). It’s based on the PySerial library and is designed to give you information on your OBD setup in a convenient interface. For a specific scan tool fork of PyOBD, see Austin Murphy’s OBD2 ScanTool (<em><a href="https://github.com/AustinMurphy/OBD2-Scantool/">https://github.com/AustinMurphy/OBD2-Scantool/</a></em>), which is attempting to become a more complete open source solution for diagnostic troubleshooting.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_247"/><img src="graphics/a-01.jpg" alt="image"/></div>&#13;
<p class="figcap"><em><a id="app01fig1"/>Figure A-1: PyOBD running diagnostic tests</em></p>&#13;
<div class="image"><img src="graphics/a-02.jpg" alt="image"/></div>&#13;
<p class="figcap"><em><a id="app01fig2"/>Figure A-2: PyOBD reading sensor data</em></p>&#13;
<h4 class="h4" id="app01lev2sec5"><strong><em>Linux Tools</em></strong></h4>&#13;
<p class="noindent">Linux supports CAN drivers out of the box, and SocketCAN provides a simple netlink (network card interface) experience when dealing with CAN. You can use its <span class="literal">can-utils</span> suite for a command line implementation, and as open source software, it’s easy to extend functionality to other utilities. (See <a href="ch03.html#ch03">Chapter 3</a> for more on SocketCAN.)</p>&#13;
<h4 class="h4" id="app01lev2sec6"><span epub:type="pagebreak" id="page_248"/><strong><em>CANiBUS Server</em></strong></h4>&#13;
<p class="noindent">CANiBUS is a web server written in Go by Open Garages (see <a href="app01.html#app01fig3">Figure A-3</a>). This server allows a room full of researchers to simultaneously work on the same vehicle, whether for instructional purposes or team reversing sessions. The Go language is portable to any operating system, but you may have issues with low-level drivers on certain platforms. For example, even if you’re running CANiBUS on Linux, you won’t be able to directly interact with SocketCAN because Go doesn’t support the necessary socket flags to initialize the CAN interface. (This problem could be addressed by implementing socketcand, but as of this writing, that feature has yet to be implemented.) CANiBUS does have a driver for ELM327 that supports generic sniffing. You can learn more about CANiBUS at <em><a href="http://wiki.hive13.org/view/CANiBUS/">http://wiki.hive13.org/view/CANiBUS/</a></em> and can download the source from <em><a href="https://github.com/Hive13/CANiBUS/">https://github.com/Hive13/CANiBUS/</a></em>.</p>&#13;
<div class="image"><img src="graphics/a-03.jpg" alt="image"/></div>&#13;
<p class="figcap"><em><a id="app01fig3"/>Figure A-3: CANiBUS group-based web sniffer</em></p>&#13;
<h4 class="h4" id="app01lev2sec7"><strong><em>Kayak</em></strong></h4>&#13;
<p class="noindent">Kayak (<em><a href="http://kayak.2codeornot2code.org/">http://kayak.2codeornot2code.org/</a></em>) is a Java-based GUI for analyzing CAN traffic. It has several advanced features, such as GPS tracking and record and playback capabilities. It utilizes socketcand in order to work on other operating systems, so you’ll need at least one Linux-based sniffer to support Kayak. (You’ll find more detail on setup and use in “<a href="app01.html#app01lev2sec7">Kayak</a>” on <a href="ch03.html#page_46">page 46</a>.)</p>&#13;
<h4 class="h4" id="app01lev2sec8"><strong><em>SavvyCAN</em></strong></h4>&#13;
<p class="noindent">SavvyCAN is a tool written by Collin Kidder of EVTV.me that uses another framework designed by EVTV.me, GVRET, to talk to HW sniffers such as the EVTV Due. SavvyCAN is an open source, Qt GUI–based tool that works on multiple operating systems (see <a href="app01.html#app01fig4">Figure A-4</a>). It includes several <span epub:type="pagebreak" id="page_249"/>very nice features, such as DBC editor, CAN bus graphing, log file diffing, several reverse engineering tools, and all the normal CAN sniffing features you would expect. SavvyCAN doesn’t talk to SocketCAN, but it can read in several different logfile formats, such as Bushmaster logs, Microchip logs, CRTD formats, and generic CSV-formatted logfiles.</p>&#13;
<div class="image"><img src="graphics/a-04.jpg" alt="image"/></div>&#13;
<p class="figcap"><em><a id="app01fig4"/>Figure A-4: SavvyCAN GUI</em></p>&#13;
<h4 class="h4" id="app01lev2sec9"><strong><em>O2OO Data Logger</em></strong></h4>&#13;
<p class="noindent">O2OO (<em><a href="http://www.vanheusden.com/O2OO/">http://www.vanheusden.com/O2OO/</a></em>) is an open source OBD-II data logger that works with ELM327 to record data to a SQLite database for graphing purposes. It also supports reading GPS data in NMEA format.</p>&#13;
<h4 class="h4" id="app01lev2sec10"><strong><em>Caring Caribou</em></strong></h4>&#13;
<p class="noindent">Caring Caribou (<em><a href="https://github.com/CaringCaribou/caringcaribou/">https://github.com/CaringCaribou/caringcaribou/</a></em>), written in Python, is designed to be the Nmap of automotive hacking. As of this writing, it’s still in its infancy, but it shows a lot of potential. Caring Caribou has some unique features, like the ability to brute-force diagnostic services, and handles XCP. It also has your standard sniff-and-send CAN functionality and will support your own modules.</p>&#13;
<h4 class="h4" id="app01lev2sec11"><span epub:type="pagebreak" id="page_250"/><strong><em>c0f Fingerprinting Tool</em></strong></h4>&#13;
<p class="noindent">CAN of Fingers (c0f) is an open source tool for fingerprinting CAN bus systems that can be found at <em><a href="https://github.com/zombieCraig/c0f/">https://github.com/zombieCraig/c0f/</a></em>. It has some basic support for identifying patterns in a CAN bus network stream, which can be useful when trying to find a specific signal on a noisy bus. (See “<a href="ch11.html#ch11lev3sec5">Using c0f</a>” on <a href="ch11.html#page_206">page 206</a> for an example of c0f at work.)</p>&#13;
<h4 class="h4" id="app01lev2sec12"><strong><em>UDSim ECU Simulator</em></strong></h4>&#13;
<p class="noindent">UDSim (<em><a href="https://github.com/zombieCraig/UDSim/">https://github.com/zombieCraig/UDSim/</a></em>) is a GUI tool that can monitor a CAN bus and automatically learn the devices attached to it by watching communications (see <a href="app01.html#app01fig5">Figure A-5</a>). It’s designed to be used with another diagnostic tool, such as a dealership tool or a scan tool from a local automotive store.</p>&#13;
<div class="image"><img src="graphics/a-05.jpg" alt="image"/></div>&#13;
<p class="figcap"><em><a id="app01fig5"/>Figure A-5: Sample screen from UDSim as it learns modules off a test bench</em></p>&#13;
<p class="indent">UDSim has three modes: learning, simulation, and attack. In learning mode, it identifies modules that respond to UDS diagnostic queries and monitors the responses. In simulation mode, it simulates a vehicle on the CAN bus to fool or test diagnostic tools. In attack mode, it creates a fuzzing profile for tools like Peach Fuzzer (<em><a href="http://www.peachfuzzer.com/">http://www.peachfuzzer.com/</a></em>).</p>&#13;
<h4 class="h4" id="app01lev2sec13"><strong><em>Octane CAN Bus Sniffer</em></strong></h4>&#13;
<p class="noindent">Octane (<em><a href="http://octane.gmu.edu/">http://octane.gmu.edu/</a></em>) is an open source CAN bus sniffer and injector with a very nice interface for sending and receiving CAN packets, including an XML trigger system. Currently, it runs only on Windows.</p>&#13;
<h4 class="h4" id="app01lev2sec14"><span epub:type="pagebreak" id="page_251"/><strong><em>AVRDUDESS GUI</em></strong></h4>&#13;
<p class="noindent">AVRDUDESS (<em><a href="http://blog.zakkemble.co.uk/avrdudess-a-gui-for-avrdude/">http://blog.zakkemble.co.uk/avrdudess-a-gui-for-avrdude/</a></em>) is a GUI frontend for AVRDUDE written in .NET, though it works fine with Mono on Linux. You’ll see AVRDUDESS in action in “<a href="ch08.html#ch08lev2sec9">Prepping Your Test with AVRDUDESS</a>” on <a href="ch08.html#page_139">page 139</a>.</p>&#13;
<h4 class="h4" id="app01lev2sec15"><strong><em>RomRaider ECU Tuner</em></strong></h4>&#13;
<p class="noindent">RomRaider (<em><a href="http://www.romraider.com/">http://www.romraider.com/</a></em>) is an open source tuning suite for the Subaru engine control unit that lets you view and log data and tune the ECU (see <a href="app01.html#app01fig6">Figure A-6</a>). It’s one of the few open source ECU tuners, and it can handle 3D views and live data logging. You’ll need a Tactrix Open Port 2.0 cable and Tactrix EcuFlash software in order to download and use the ECU’s firmware. Once you’ve downloaded the flash with EcuFlash, you can edit it with RomRaider. The editor is written in Java and currently works on Windows and Linux, though EcuFlash isn’t supported on Linux.</p>&#13;
<div class="image"><img src="graphics/a-06.jpg" alt="image"/></div>&#13;
<p class="figcap"><em><a id="app01fig6"/>Figure A-6: RomRaider tuning editor</em></p>&#13;
<h4 class="h4" id="app01lev2sec16"><strong><em>Komodo CAN Bus Sniffer</em></strong></h4>&#13;
<p class="noindent">Komodo is a higher-end sniffer with a nice multioperating system—Python SDK. It costs around $350 to $450 depending on whether you want a single- or dual-CAN interface. Komodo has isolation capabilities to prevent your computer from frying if you miswire something, as well as <span epub:type="pagebreak" id="page_252"/>eight general-purpose IO pins you can configure to trigger actions from external devices. Komodo comes with some decent software to get you up and running, but the real advantage is that you can write your own Komodo software.</p>&#13;
<h4 class="h4" id="app01lev2sec17"><strong><em>Vehicle Spy</em></strong></h4>&#13;
<p class="noindent">Vehicle Spy is a commercial tool from Intrepid Control Systems (<em><a href="http://store.intrepidcs.com/">http://store.intrepidcs.com/</a></em>) that’s specifically designed for reversing CAN and other vehicle communication protocols. The software requires one license per NeoVI or ValueCAN device, both proprietary devices for Vehicle Spy. The ValueCAN3 is the cheapest device that works with Vehicle Spy. It has one CAN interface and costs about $300. Add the Vehicle Spy Basic software and your cost will be about $1,300.</p>&#13;
<p class="indent">The NeoIV devices are higher end, with multiple configurable channels, starting at around $1,200. A basic package contains a NeoIV (Red) and Vehicle Spy Basic for $2,000, which saves a bit of money. Vehicle Spy Professional costs about $2,600 without hardware. (You’ll find several options on Intrepid’s site.)</p>&#13;
<p class="indent">All Intrepid hardware devices support uploading scripts to run on the bus in real time. Vehicle Spy Basic supports CAN/LIN RX/TX operations. You’ll need the professional version only if car hacking is going to be a full-time project for you or if you want to use ECU flashing or other advanced features, such as Node Simulation, scripting on the sniffer, or memory calibration.</p>&#13;
</body></html>