<html><head></head><body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_81"/><strong><span class="big">9</span><br/>SQL INJECTION</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/common.jpg"/></div>&#13;
<p class="noindent">When a vulnerability on a database-backed site allows an attacker to query or attack the site’s database using <em>SQL (Structured Query Language)</em>, it is known as a <em>SQL injection (SQLi)</em>. Often, SQLi attacks are highly rewarded because they can be devastating: attackers can manipulate or extract information or even create an administrator login for themselves in the database.</p>&#13;
<h3 class="h3" id="ch09lev1sec1"><span epub:type="pagebreak" id="page_82"/><strong>SQL Databases</strong></h3>&#13;
<p class="noindent">Databases store information in records and fields contained in a collection of tables. Tables contain one or more columns, and a row in a table represents a record in the database.</p>&#13;
<p class="indent">Users rely on SQL to create, read, update, and delete records in a database. The user sends SQL commands (statements or queries) to the database, and—assuming the commands are accepted—the database interprets the statements and performs some action. Popular SQL databases include MySQL, PostgreSQL, MSSQL, and so on. In this chapter, we’ll use MySQL, but the general concepts apply to all SQL databases.</p>&#13;
<p class="indent">SQL statements are made up of keywords and functions. For example, the following statement tells the database to select information from the <code>name</code> column in the <code>users</code> table for records where the ID column is equal to <code>1</code>.</p>&#13;
<pre>SELECT name FROM users WHERE id = 1;</pre>&#13;
<p class="indent">Many websites rely on databases to store information and use that information to dynamically generate content. For example, if the site <em>https://www.&lt;example&gt;.com/</em> stored your previous orders in a database that you accessed when you logged in with your account, your web browser would query the site’s database and generate HTML based on the information returned.</p>&#13;
<p class="indent">The following is a theoretical example of a server’s PHP code to generate a MySQL command after a user visits <em>https://www.&lt;example&gt;.com?name=peter</em>:</p>&#13;
<pre>   $name = <span class="ent">➊</span>$_GET['name'];<br/>&#13;
   $query = "SELECT * FROM users WHERE name = <span class="ent">➋</span>'$name' ";<br/>&#13;
<span class="ent">➌</span> mysql_query($query);</pre>&#13;
<p class="indent">The code uses <code>$_GET[]</code> <span class="ent">➊</span> to access the name value from the URL parameters specified between its brackets and stores the value in the <code>$name</code> variable. Then the parameter is passed to the <code>$query</code> variable <span class="ent">➋</span> without any sanitization. The <code>$query</code> variable represents the query to execute and fetches all data from the <code>users</code> table where the <code>name</code> column matches the value in the <code>name</code> URL parameter. The query executes by passing the <code>$query</code> variable to the PHP function <code>mysql_query</code> <span class="ent">➌</span>.</p>&#13;
<p class="indent">The site expects <code>name</code> to contain regular text. But if a user enters the malicious input <code>test' OR 1='1</code> into the URL parameter, such as <code>https://www</code>.<span class="codeitalic">example</span><code>.com?name=test' OR 1='1</code>, the executed query is this:</p>&#13;
<pre>$query = "SELECT * FROM users WHERE name = 'test<span class="ent">➊</span>' OR 1='1<span class="ent">➋</span>' ";</pre>&#13;
<p class="indent">The malicious input closes the opening single quote (<code>'</code>) after the value <code>test</code> <span class="ent">➊</span> and adds the SQL code <code>OR 1='1</code> to the end of the query. The hanging single quote in <code>OR 1='1</code> opens the closing single quote that is hardcoded after <span class="ent">➋</span>. If the injected query didn’t include an opening single quote, the hanging quote would cause SQL syntax errors, which would prevent the query from executing.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_83"/>SQL uses the conditional operators <code>AND</code> and <code>OR</code>. In this case, the SQLi modifies the <code>WHERE</code> clause to search for records where the <code>name</code> column matches <code>test</code> or the equation <code>1='1'</code> returns <code>true</code>. MySQL helpfully treats <code>'1'</code> as an integer, and because <code>1</code> always equals <code>1</code>, the condition is <code>true</code> and the query returns all records in the <code>users</code> table. But injecting <code>test' OR 1='1</code> won’t work when other parts of the query are sanitized. For example, you might use a query like this:</p>&#13;
<pre>$name = $_GET['name'];<br/>&#13;
$password = <span class="ent">➊</span>mysql_real_escape_string($_GET['password']);<br/>&#13;
$query = "SELECT * FROM users WHERE name = '$name' AND password = '$password' ";</pre>&#13;
<p class="indent">In this case, the <code>password</code> parameter is also user controlled but properly sanitized <span class="ent">➊</span>. If you used the same payload, <code>test' OR 1='1</code>, as the name and if your password was 12345, your statement would look like this:</p>&#13;
<pre>$query = "SELECT * FROM users WHERE name = 'test' OR 1='1' AND password = '12345' ";</pre>&#13;
<p class="indent">The query looks for all records where the <code>name</code> is <code>test</code> or <code>1='1'</code> and the <code>password</code> is <code>12345</code> (we’ll ignore the fact that this database stores plaintext passwords, which is another vulnerability). Because the password check uses an <code>AND</code> operator, this query won’t return data unless a record’s password is <code>12345</code>. Although this breaks our attempted SQLi, it doesn’t stop us from trying another attack method.</p>&#13;
<p class="indent">We need to eliminate the <code>password</code> parameter, which we can do by adding <code>;--, test' OR 1='1;--</code>. This injection accomplishes two tasks: the semicolon (<code>;</code>) ends the SQL statement, and the two dashes (<code>--</code>) tell the database that the remainder of the text is a comment. This injected parameter changes the query to <code>SELECT * FROM users WHERE name = 'test' OR 1='1';</code>. The <code>AND password = '12345'</code> code in the statement becomes a comment, so the command returns all records from the table. When you’re using <code>--</code> as a comment, keep in mind that MySQL requires a space after the dashes and the remaining query. Otherwise, MySQL will return errors without executing the command.</p>&#13;
<h3 class="h3" id="ch09lev1sec2"><strong>Countermeasures Against SQLi</strong></h3>&#13;
<p class="noindent">One protection available to prevent SQLi is the use of <em>prepared statements</em>, which are a database feature that executes repeated queries. The specific details of prepared statements are beyond the scope of this book, but they protect against SQLi because queries are no longer executed dynamically. The database uses the queries like templates by having placeholders for variables. As a result, even when users pass unsanitized data to a query, the injection can’t modify the database’s query template, thus preventing SQLi.</p>&#13;
<p class="indent">Web frameworks, such as Ruby on Rails, Django, Symphony, and so on, also offer built-in protections to help prevent SQLi. But they aren’t perfect and can’t prevent the vulnerability everywhere. The two simple examples of SQLi you’ve just seen usually won’t work on sites built with frameworks unless the site developers didn’t follow best practices or didn’t recognize <span epub:type="pagebreak" id="page_84"/>that protections weren’t automatically provided. For example, the site <em><a href="https://rails-sqli.org/">https://rails-sqli.org/</a></em> maintains a list of common SQLi patterns in Rails that result from developer mistakes. When testing for SQLi vulnerabilities, your best bet is to look for older websites that look custom built or use web frameworks and content management systems that don’t have all the built-in protections of current systems.</p>&#13;
<h3 class="h3" id="ch09lev1sec3"><strong>Yahoo! Sports Blind SQLi</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Medium</p>&#13;
<p class="hang"><strong>URL:</strong> <em><a href="https://sports.yahoo.com">https://sports.yahoo.com</a></em></p>&#13;
<p class="hang"><strong>Source:</strong> N/A</p>&#13;
<p class="hang"><strong>Date reported:</strong> February 16, 2014</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $3,705</p>&#13;
<p class="noindent">A <em>blind SQLi</em> vulnerability occurs when you can inject SQL statements into a query but can’t get a query’s direct output. The key to exploiting blind injections is to infer information by comparing the results of unmodified and modified queries. For example, in February 2014, Stefano Vettorazzi found a blind SQLi when testing the Yahoo! sports subdomain. The page took parameters through its URL, queried a database for information, and returned a list of NFL players based on the parameters.</p>&#13;
<p class="indent">Vettorazzi changed the following URL, which returned the NFL players in 2010, from this:</p>&#13;
<p class="hangtb"><em><a href="http://sports.yahoo.com/nfl/draft?year=2010&amp;type=20&amp;round=2">sports.yahoo.com/nfl/draft?year=2010&amp;type=20&amp;round=2</a></em></p>&#13;
<p class="indent">to this:</p>&#13;
<p class="hangtb"><em><a href="http://sports.yahoo.com/nfl/draft?year=2010--&amp;type=20&amp;round=2">sports.yahoo.com/nfl/draft?year=2010--&amp;type=20&amp;round=2</a></em></p>&#13;
<p class="indent">Vettorazzi added two dashes (<code>--</code>) to the <code>year</code> parameter in the second URL. <a href="ch09.xhtml#ch09fig01">Figure 9-1</a> shows what the page looked like in Yahoo! before Vettorazzi added the two dashes. <a href="ch09.xhtml#ch09fig02">Figure 9-2</a> shows the result after Vettorazzi added the dashes.</p>&#13;
<p class="indent">The players returned in <a href="ch09.xhtml#ch09fig01">Figure 9-1</a> are different from those returned in <a href="ch09.xhtml#ch09fig02">Figure 9-2</a>. We can’t see the actual query because the code is on the backend of the website. But the original query likely passed each URL parameter to a SQL query that looked something like this:</p>&#13;
<pre>SELECT * FROM players WHERE year = 2010 AND type = 20 AND round = 2;</pre>&#13;
<p class="indent">By adding two dashes to the <code>year</code> parameter, Vettorazzi would have altered the query to this:</p>&#13;
<pre>SELECT * FROM PLAYERS WHERE year = 2010-- AND type = 20 AND round = 2;</pre>&#13;
<div class="image"><span epub:type="pagebreak" id="page_85"/><a id="ch09fig01"/><img alt="image" src="../images/09fig01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-1: Yahoo! player search results with an unmodified <span class="codeitalic">year</span> parameter</em></p>&#13;
<div class="image"><a id="ch09fig02"/><img alt="image" src="../images/09fig02.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-2: Yahoo! player search results with a modified <span class="codeitalic">year</span> parameter including <span class="codeitalic">--</span></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_86"/>This Yahoo! bug is slightly unusual because queries must end with a semicolon in most, if not all, databases. Because Vettorazzi only injected two dashes and commented out the query’s semicolon, this query should fail and either return an error or no records. Some databases can accommodate queries without semicolons, so Yahoo! was either using this functionality or its code accommodated the error in some other way. Regardless, after Vettorazzi recognized the different results the queries returned, he tried to infer the database version the site was using by submitting the following code as the <code>year</code> parameter:</p>&#13;
<pre>(2010)and(if(mid(version(),1,1))='5',true,false))--</pre>&#13;
<p class="indent">The MySQL database <code>version()</code> function returns the current version of the MySQL database in use. The <code>mid</code> function returns part of the string passed to its first parameter according to its second and third parameters. The second argument specifies the starting position of the substring that the function will return, and the third argument specifies the length of the substring. Vettorazzi checked whether the site used MySQL by calling <code>version()</code>. Then he tried to get the first digit in the version number by passing the <code>mid</code> function <code>1</code> as its first argument for the starting position and <code>1</code> as its second argument for the substring length. The code checks the first digit of the MySQL version using an <code>if</code> statement.</p>&#13;
<p class="indent">The <code>if</code> statement takes three arguments: a logical check, the action to perform if the check is true, and the action to perform if the check is false. In this case, the code checks whether the first digit from <code>version</code> is <code>5</code>; if so, the query returns <code>true</code>. If not, the query returns <code>false</code>.</p>&#13;
<p class="indent">Then Vettorazzi connected the true/false output with the <code>year</code> parameter using the <code>and</code> operator, so if the major version of the MySQL database was 5, players in the year 2010 would be returned on the Yahoo! web page. The query works this way because the condition <code>2010 and true</code> would be <code>true</code>, whereas <code>2010 and false</code> would be <code>false</code> and return no records. Vettorazzi executed the query and received no records, as shown in <a href="ch09.xhtml#ch09fig03">Figure 9-3</a>, meaning the first digit of the value returned from <code>version</code> wasn’t <code>5</code>.</p>&#13;
<div class="image"><a id="ch09fig03"/><img alt="image" src="../images/09fig03.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-3: Yahoo! player search results were empty when the code checked whether the database version started with the number 5.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_87"/>This bug is a blind SQLi because Vettorazzi couldn’t inject his query and see the output directly on the page. But Vettorazzi could still find information about the site. By inserting Boolean checks, such as the version-checking <code>if</code> statement, Vettorazzi could infer the information he needed. He could have continued to extract information from the Yahoo! database. But finding information about the MySQL version through his test query was enough to confirm to Yahoo! that the vulnerability existed.</p>&#13;
<h4 class="h4" id="ch09lev2sec1"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">SQLi vulnerabilities, like other injection vulnerabilities, aren’t always difficult to exploit. One way to find a SQLi vulnerability is to test URL parameters and look for subtle changes to query results. In this case, adding the double dash changed the results of Vettorazzi’s baseline query, revealing the SQLi.</p>&#13;
<h3 class="h3" id="ch09lev1sec4"><strong>Uber Blind SQLi</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Medium</p>&#13;
<p class="hang"><strong>URL:</strong> <em>http://sctrack.email.uber.com.cn/track/unsubscribe.do/</em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/150156/">https://hackerone.com/reports/150156/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> July 8, 2016</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $4,000</p>&#13;
<p class="noindent">In addition to web pages, you can find blind SQLi vulnerabilities in other places, such as email links. In July 2016, Orange Tsai received an email advertisement from Uber. He noticed that the unsubscribe link included a base64-encoded string as a URL parameter. The link looked like this:</p>&#13;
<p class="hangtb"><em>http://sctrack.email.uber.com.cn/track/unsubscribe.do?p=eyJ1c2VyX2lkIjogIjU3NTUiLCAicmVjZWl2ZXIiOiAib3JhbmdlQG15bWFpbCJ9</em></p>&#13;
<p class="indent">Decoding the <code>p</code> parameter value <code>eyJ1c2VyX2lkIjogIjU3NTUiLCAicmVjZWl2ZXIiOiAib3JhbmdlQG15bWFpbCJ9</code> using base64 returns the JSON string <code>{"user_id": "5755", "receiver": "orange@mymail"}</code>. To the decoded string, Orange added the code <code>and sleep(12) = 1</code> to the encoded <code>p</code> URL parameter. This harmless addition makes the database take longer to respond to the unsubscribe action <code>{"user_id": "5755 and sleep(12)=1", "receiver": "orange@mymail"}</code>. If a site is vulnerable, the query execution evaluates <code>sleep(12)</code> and performs no action for 12 seconds before comparing the output of the <code>sleep</code> command to <code>1</code>. In MySQL, the <code>sleep</code> command normally returns 0, so this comparison will fail. But it doesn’t matter because the execution will take at least 12 seconds.</p>&#13;
<p class="indent">After Orange reencoded the modified payload and passed the payload to the URL parameter, he visited the unsubscribe link to confirm that the HTTP response took at least 12 seconds. Realizing he needed more concrete proof of the SQLi to send to Uber, he dumped the user name, host name, and database name using brute force. By doing so, he demonstrated that he could extract information from the SQLi vulnerability without accessing confidential data.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_88"/>A SQL function called <code>user</code> returns the user name and host name of a database in the form <em>&lt;user&gt;</em>@<em>&lt;host&gt;</em>. Because Orange couldn’t access output from his injected queries, he couldn’t call <code>user</code>. Instead, Orange modified his query to add a conditional check when the query looked up his user ID, comparing one character of the database’s user name and host name string at a time using the <code>mid</code> function. Similar to the Yahoo! Sports blind SQLi vulnerability in the previous bug report, Orange used a comparison statement and brute force to derive each character of the user name and host name string.</p>&#13;
<p class="indent">For example, Orange took the first character of the value returned from the <code>user</code> function using the <code>mid</code> function. Then he compared whether the character was equal to <code>'a'</code>, then <code>'b'</code>, then <code>'c'</code>, and so on. If the comparison statement was true, the server would execute the unsubscribe command. This result indicated that the first character of the <code>user</code> function’s return value was equal to the character it was being compared to. If the statement was false, the server would not try to unsubscribe Orange. By checking each character of the <code>user</code> function’s return value using this method, Orange could eventually derive the entire user name and host name.</p>&#13;
<p class="indent">Manually brute-forcing a string takes time, so Orange created a Python script that generated and submitted payloads to Uber on his behalf, as follows:</p>&#13;
<pre><span class="ent">➊</span> import json<br/>&#13;
   import string<br/>&#13;
   import requests<br/>&#13;
   from urllib import quote<br/>&#13;
   from base64 import b64encode<br/>&#13;
<span class="ent">➋</span> base = string.digits + string.letters + '_-@.'<br/>&#13;
<span class="ent">➌</span> payload = {"user_id": 5755, "receiver": "blog.orange.tw"}<br/>&#13;
<span class="ent">➍</span> for l in range(0, 30):<br/>&#13;
    <span class="ent">➎</span> for i in base:<br/>&#13;
        <span class="ent">➏</span> payload['user_id'] = "5755 and mid(user(),%d,1)='%c'#"%(l+1, i)<br/>&#13;
        <span class="ent">➐</span> new_payload = json.dumps(payload)<br/>&#13;
           new_payload = b64encode(new_payload)<br/>&#13;
           r = requests.get('http://sctrack.email.uber.com.cn/track/unsubscribe.<br/>&#13;
   do?p='+quote(new_payload))<br/>&#13;
        <span class="ent">➑</span> if len(r.content)&gt;0:<br/>&#13;
                   print i,<br/>&#13;
                   break</pre>&#13;
<p class="indent">The Python script begins with five lines of <code>import</code> statements <span class="ent">➊</span> that retrieve the libraries Orange needed to process HTTP requests, JSON, and string encodings.</p>&#13;
<p class="indent">A database user name and host name can be made up of any combination of uppercase letters, lowercase letters, numbers, hyphens (<code>-</code>), underscores (<code>_</code>), at symbols (<code>@</code>), or periods (<code>.</code>). At <span class="ent">➋</span>, Orange creates the <code>base</code> variable to hold these characters. The code at <span class="ent">➌</span> creates a variable to hold the payload that the script sends to the server. The line of code at <span class="ent">➏</span> is the injection, which uses the <code>for</code> loops at <span class="ent">➍</span> and <span class="ent">➎</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_89"/>Let’s look at the code at <span class="ent">➏</span> in detail. Orange references his user ID, 5755, with the string <code>user_id</code> as defined at <span class="ent">➌</span> to create his payloads. He uses the <code>mid</code> function and string processing to construct a payload similar to the Yahoo! bug earlier in this chapter. The <code>%d</code> and <code>%c</code> in the payload are string replacement placeholders. The <code>%d</code> is data that represents a digit, and the <code>%c</code> is character data.</p>&#13;
<p class="indent">The payload string starts at the first pair of double quotes (<code>"</code>) and ends at the second pair of double quotes before the third percent symbol at <span class="ent">➏</span>. The third percent symbol tells Python to replace the <code>%d</code> and <code>%c</code> placeholders with the values following the percent symbol in the parentheses. So the code replaces <code>%d</code> with <code>l+1</code> (the variable <code>l</code> plus the number <code>1</code>) and <code>%c</code> with the variable <code>i</code>. The hash mark (<code>#</code>) is another way of commenting in MySQL and renders any part of the query following Orange’s injection into a comment.</p>&#13;
<p class="indent">The <code>l</code> and <code>i</code> variables are the loop iterators at <span class="ent">➍</span> and <span class="ent">➎</span>. The first time the code enters <code>l in range (0,30)</code> at <span class="ent">➍</span>, <code>l</code> will be <code>0</code>. The value of <code>l</code> is the position in the user name and host name string returned by the <code>user</code> function that the script is trying to brute-force. Once the script has a position in the user name and host name string it’s testing, the code enters a nested loop at <span class="ent">➎</span> that iterates over each character in the <code>base</code> string. The first time the script iterates through both loops, <code>l</code> will be <code>0</code> and <code>i</code> will be <code>a</code>. These values are passed to the <code>mid</code> function at <span class="ent">➏</span> to create the payload <code>"5755 and mid(user(),0,1)='a'#"</code>.</p>&#13;
<p class="indent">In the next iteration of the nested <code>for</code> loop, the value of <code>l</code> will still be <code>0</code> and <code>i</code> will be <code>b</code> to create the payload <code>"5755 and mid(user(),0,1)='b'#"</code>. The position <code>l</code> will remain constant as the loop iterates though each character in <code>base</code> to create the payload at <span class="ent">➏</span>.</p>&#13;
<p class="indent">Each time a new payload is created, the code following <span class="ent">➐</span> converts the payload to JSON, reencodes the string using the <code>base64encode</code> function, and sends the HTTP request to the server. The code at <span class="ent">➑</span> checks whether the server responds with a message. If the character in <code>i</code> matches the user name substring at the position being tested, the script stops testing characters at that position and moves to the next position in the <code>user</code> string. The nested loop breaks and returns to the loop at <span class="ent">➍</span>, which increments <code>l</code> by <code>1</code> to test the next position of the user name string.</p>&#13;
<p class="indent">This proof of concept allowed Orange to confirm that the database user name and host name were <code>sendcloud_w@10.9.79.210</code> and the database name was <code>sendcloud</code> (to obtain the database name, replace <code>user</code> with <code>database</code> at <span class="ent">➏</span>). In response to the report, Uber confirmed that the SQLi hadn’t occurred on its server. The injection occurred on a third-party server that Uber was using, but Uber still paid a reward. Not all bounty programs will do the same. Uber likely paid a bounty because the exploit would allow an attacker to dump all of Uber’s customer email addresses from the <code>sendcloud</code> database.</p>&#13;
<p class="indent">Although you can write your own scripts as Orange did to dump database information from a vulnerable website, you can also use automated tools. <a href="app01.xhtml#app01">Appendix A</a> includes information about one such tool called sqlmap.</p>&#13;
<h4 class="h4" id="ch09lev2sec2"><span epub:type="pagebreak" id="page_90"/><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Keep an eye out for HTTP requests that accept encoded parameters. After you decode and inject your query into a request, be sure to reencode your payload so everything still matches the encoding the server expects.</p>&#13;
<p class="indent">Extracting a database name, user name, and host name is generally harmless, but be sure it’s within the permitted actions of the bounty program you’re working in. In some cases, the <code>sleep</code> command is enough for a proof of concept.</p>&#13;
<h3 class="h3" id="ch09lev1sec5"><strong>Drupal SQLi</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Hard</p>&#13;
<p class="hang"><strong>URL:</strong> Any Drupal site using version 7.32 or earlier</p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/31756/">https://hackerone.com/reports/31756/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> October 17, 2014</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $3,000</p>&#13;
<p class="noindent"><em>Drupal</em> is a popular open source content management system for building websites, similar to Joomla! and WordPress. It’s written in PHP and is <em>modular</em>, meaning you can install new functionality in units to a Drupal site. Every Drupal install contains <em>Drupal core</em>, which is a set of modules that runs the platform. These core modules require a connection to a database, such as MySQL.</p>&#13;
<p class="indent">In 2014, Drupal released an urgent security update to Drupal core because all Drupal sites were vulnerable to a SQLi vulnerability that could easily be abused by anonymous users. The impact of the vulnerability would allow an attacker to take over any unpatched Drupal site. Stefan Horst discovered the vulnerability when he noticed a bug in Drupal core’s prepared statement functionality.</p>&#13;
<p class="indent">The Drupal vulnerability occurred in Drupal’s database application programming interface (API). The Drupal API uses the PHP Data Objects (PDO) extension, which is an <em>interface</em> for accessing databases in PHP. An interface is a programming concept that guarantees inputs and outputs of a function without defining how the function is implemented. In other words, PDO hides the differences between databases so programmers can use the same functions to query and fetch data regardless of the database type. PDO includes support for prepared statements.</p>&#13;
<p class="indent">Drupal created a database API to use the PDO functionality. The API creates a Drupal database abstraction layer so developers never have to query the database directly with their own code. But they can still use prepared statements and use their code with any database type. The specifics of the API are beyond the scope of this book. But you need to know that the API will generate the SQL statements to query the database and has built-in security checks to prevent SQLi vulnerabilities.</p>&#13;
<p class="indent">Recall that prepared statements prevent SQLi vulnerabilities because an attacker can’t modify the query structure with malicious input, even if <span epub:type="pagebreak" id="page_91"/>the input is unsanitized. But prepared statements can’t protect against SQLi vulnerabilities if the injection occurs when the template is being created. If an attacker can inject malicious input during the template creation process, they can create their own malicious prepared statement. The vulnerability Horst discovered occurred because of SQL’s <code>IN</code> clause, which looks for values that exist in a list of values. For example, the code <code>SELECT * FROM users WHERE name IN ('peter', 'paul', 'ringo');</code> selects the data from the <code>users</code> table where the value in the <code>name</code> column is <code>peter</code>, <code>paul</code>, or <code>ringo</code>.</p>&#13;
<p class="indent">To understand why the <code>IN</code> clause is vulnerable, let’s look at the code behind Drupal’s API:</p>&#13;
<pre>$this-&gt;expandArguments($query, $args);<br/>&#13;
$stmt = $this-&gt;prepareQuery($query);<br/>&#13;
$stmt-&gt;execute($args, $options);</pre>&#13;
<p class="indent">The <code>expandArguments</code> function is responsible for building queries that use the <code>IN</code> clause. After <code>expandArguments</code> builds queries, it passes them to <code>prepareQuery</code>, which builds the prepared statements that the <code>execute</code> function executes. To understand the significance of this process, let’s look at the relevant code for <code>expandArguments</code> as well:</p>&#13;
<pre>   <span class="codeitalic1">--snip--</span><br/>&#13;
<span class="ent">➊</span> foreach(array_filter($args, `is_array`) as $key =&gt; $data) {<br/>&#13;
  <span class="ent">➋</span> $new_keys = array();<br/>&#13;
  <span class="ent">➌</span> foreach ($data as $i =&gt; $value) {<br/>&#13;
       --<span class="codeitalic1">snip</span>--<br/>&#13;
    <span class="ent">➍</span> $new_keys[$key . '_' . $i] = $value;<br/>&#13;
      }<br/>&#13;
     --<span class="codeitalic1">snip</span>--<br/>&#13;
   }</pre>&#13;
<p class="indent">This PHP code uses arrays. PHP can use associative arrays, which explicitly define keys as follows:</p>&#13;
<pre>['red' =&gt; 'apple', 'yellow' =&gt; 'banana']</pre>&#13;
<p class="indent">The keys in this array are <code>'red'</code> and <code>'yellow'</code>, and the array’s values are the fruits to the right of the arrow (<code>=&gt;</code>).</p>&#13;
<p class="indent">Alternatively, PHP can use a <em>structured array</em>, as follows:</p>&#13;
<pre>['apple', 'banana']</pre>&#13;
<p class="indent">A structured array’s keys are implicit and based on the position of the value in the list. For example, the key for <code>'apple'</code> is <code>0</code> and the key for <code>'banana'</code> is <code>1</code>.</p>&#13;
<p class="indent">The <code>foreach</code> PHP function iterates over an array and can separate the array key from its value. It can also assign each key and each value to its own variable and pass them to a block of code for processing. At <span class="ent">➊</span>, <code>foreach</code> takes each element of an array and verifies the value passed to it is an array by calling <code>array_filter($args, 'is_array')</code>. After the statement confirms it <span epub:type="pagebreak" id="page_92"/>has an array value, it assigns each of the array’s keys to <code>$key</code> and each of the values to <code>$data</code> for each iteration of the <code>foreach</code> loop. The code will modify the values in the array to create placeholders, so the code at <span class="ent">➋</span> initializes a new empty array to later hold the placeholder values.</p>&#13;
<p class="indent">To create the placeholders, the code at <span class="ent">➌</span> iterates through the <code>$data</code> array by assigning each key to <code>$i</code> and each value to <code>$value</code>. Then at <span class="ent">➍</span>, the <code>new_keys</code> array initialized at <span class="ent">➋</span> holds the first array’s key concatenated with the key at <span class="ent">➌</span>. The code’s intended outcome is to create data placeholders that look like <code>name_0</code>, <code>name_1</code>, and so on.</p>&#13;
<p class="indent">Here is what a typical query would look like using Drupal’s <code>db_query</code> function, which queries a database:</p>&#13;
<pre>db_query("SELECT * FROM {users} WHERE name IN (:name)",<br/>&#13;
  array(':name'=&gt;array('user1','user2')));</pre>&#13;
<p class="indent">The <code>db_query</code> function takes two parameters: a query that contains named placeholders for variables and an array of values to substitute for those placeholders. In this example, the placeholder is <code>:name</code> and is an array with the values <code>'user1'</code> and <code>'user2'</code>. In a structured array, the key for <code>'user1'</code> is <code>0</code> and the key for <code>'user2'</code> is <code>1</code>. When Drupal executes the <code>db_query</code> function, it calls the <code>expandArguments</code> function, which concatenates the keys to each value. The resulting query uses <code>name_0</code> and <code>name_1</code> in place of the keys, as shown here:</p>&#13;
<pre>SELECT * FROM users WHERE name IN (:name_0, :name_1)</pre>&#13;
<p class="indent">But the problem arises when you call <code>db_query</code> using an associative array, as in the following code:</p>&#13;
<pre>db_query("SELECT * FROM {users} where name IN (:name)",<br/>&#13;
  array(':name'=&gt;array('test);-- ' =&gt; 'user1', 'test' =&gt; 'user2')));</pre>&#13;
<p class="indent">In this case, <code>:name</code> is an array and its keys are <code>'test);--'</code> and <code>'test'</code>. When <code>expandArguments</code> receives the <code>:name</code> array and processes it to create the query, it generates this:</p>&#13;
<pre>SELECT * FROM users WHERE name IN (:name_test);-- , :name_test)</pre>&#13;
<p class="indent">We’ve injected a comment into the prepared statement. The reason this occurs is that <code>expandArguments</code> iterates through each array element to build placeholders but assumes it’s passed a structured array. In the first iteration, <code>$i</code> is assigned <code>'test);--'</code> and <code>$value</code> is assigned <code>'user1'</code>. The <code>$key</code> is <code>':name'</code> and combining that with <code>$i</code> results in <code>name_test);--</code>. In the second iteration, <code>$i</code> is assigned <code>'test'</code> and <code>$value</code> is <code>'user2'</code>. Combining <code>$key</code> with <code>$i</code> results in the value <code>name_test</code>.</p>&#13;
<p class="indent">This behavior allows malicious users to inject SQL statements into Drupal queries that rely on the <code>IN</code> clause. The vulnerability affects Drupal login functionality, making the SQLi vulnerability severe because any site user, including an anonymous user, could exploit it. Making matters <span epub:type="pagebreak" id="page_93"/>worse, PHP PDO supports the ability to execute multiple queries at once by default. This means an attacker could append additional queries to the user login query in order to execute non-<code>IN</code> clause SQL commands. For example, an attacker could use <code>INSERT</code> statements, which insert records into a database, to create an administrative user that they could then use to log in to the website.</p>&#13;
<h4 class="h4" id="ch09lev2sec3"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">This SQLi vulnerability wasn’t simply a matter of submitting a single quote and breaking a query. Rather, it required understanding how Drupal core’s database API handles the <code>IN</code> clause. The takeaway from this vulnerability is to be on the lookout for opportunities to alter the structure of input passed to a site. When a URL takes <code>name</code> as a parameter, try adding <code>[]</code> to the parameter to change it to an array and test how the site handles it.</p>&#13;
<h3 class="h3" id="ch09lev1sec6"><strong>Summary</strong></h3>&#13;
<p class="noindent">SQLi can be a significant vulnerability and dangerous for a site. If an attacker finds a SQLi, they might obtain full permissions to a site. In some situations, a SQLi vulnerability can be escalated by inserting data into the database that enables administrative permissions on the site, as in the Drupal example. When you’re looking for SQLi vulnerabilities, explore places where you can pass unescaped single or double quotes to a query. When you find a vulnerability, the indications that the vulnerability exists can be subtle, such as with blind injections. You should also look for places where you can pass data to a site in unexpected ways, such as where you can substitute array parameters in request data, as in the Uber bug.<span epub:type="pagebreak" id="page_94"/></p>&#13;
</body></html>