<html><head></head><body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_81"/><strong><span class="big">9</span><br/>SQL INJECTION</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/common.jpg"/></div>&#13;
<p class="noindent">When a vulnerability on a database-backed site allows an attacker to query or attack the site’s database using <em>SQL (Structured Query Language)</em>, it is known as a <em>SQL injection (SQLi)</em>. Often, SQLi attacks are highly rewarded because they can be devastating: attackers can manipulate or extract information or even create an administrator login for themselves in the database.</p>&#13;
<h3 class="h3" id="ch09lev1sec1"><span epub:type="pagebreak" id="page_82"/><strong>SQL Databases</strong></h3>&#13;
<p class="noindent">Databases store information in records and fields contained in a collection of tables. Tables contain one or more columns, and a row in a table represents a record in the database.</p>&#13;
<p class="indent">Users rely on SQL to create, read, update, and delete records in a database. The user sends SQL commands (statements or queries) to the database, and—assuming the commands are accepted—the database interprets the statements and performs some action. Popular SQL databases include MySQL, PostgreSQL, MSSQL, and so on. In this chapter, we’ll use MySQL, but the general concepts apply to all SQL databases.</p>&#13;
<p class="indent">SQL statements are made up of keywords and functions. For example, the following statement tells the database to select information from the <span class="literal">name</span> column in the <span class="literal">users</span> table for records where the ID column is equal to <span class="literal">1</span>.</p>&#13;
<p class="programs">SELECT name FROM users WHERE id = 1;</p>&#13;
<p class="indent">Many websites rely on databases to store information and use that information to dynamically generate content. For example, if the site <em>https://www.&lt;example&gt;.com/</em> stored your previous orders in a database that you accessed when you logged in with your account, your web browser would query the site’s database and generate HTML based on the information returned.</p>&#13;
<p class="indent">The following is a theoretical example of a server’s PHP code to generate a MySQL command after a user visits <em>https://www.&lt;example&gt;.com?name=peter</em>:</p>&#13;
<p class="programs">   $name = <span class="ent">➊</span>$_GET['name'];<br/>&#13;
   $query = "SELECT * FROM users WHERE name = <span class="ent">➋</span>'$name' ";<br/>&#13;
<span class="ent">➌</span> mysql_query($query);</p>&#13;
<p class="indent">The code uses <span class="literal">$_GET[]</span> <span class="ent">➊</span> to access the name value from the URL parameters specified between its brackets and stores the value in the <span class="literal">$name</span> variable. Then the parameter is passed to the <span class="literal">$query</span> variable <span class="ent">➋</span> without any sanitization. The <span class="literal">$query</span> variable represents the query to execute and fetches all data from the <span class="literal">users</span> table where the <span class="literal">name</span> column matches the value in the <span class="literal">name</span> URL parameter. The query executes by passing the <span class="literal">$query</span> variable to the PHP function <span class="literal">mysql_query</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">The site expects <span class="literal">name</span> to contain regular text. But if a user enters the malicious input <span class="literal">test' OR 1='1</span> into the URL parameter, such as <span class="literal">https://www</span>.<span class="codeitalic">example</span><span class="literal">.com?name=test' OR 1='1</span>, the executed query is this:</p>&#13;
<p class="programs">$query = "SELECT * FROM users WHERE name = 'test<span class="ent">➊</span>' OR 1='1<span class="ent">➋</span>' ";</p>&#13;
<p class="indent">The malicious input closes the opening single quote (<span class="literal">'</span>) after the value <span class="literal">test</span> <span class="ent">➊</span> and adds the SQL code <span class="literal">OR 1='1</span> to the end of the query. The hanging single quote in <span class="literal">OR 1='1</span> opens the closing single quote that is hardcoded after <span class="ent">➋</span>. If the injected query didn’t include an opening single quote, the hanging quote would cause SQL syntax errors, which would prevent the query from executing.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_83"/>SQL uses the conditional operators <span class="literal">AND</span> and <span class="literal">OR</span>. In this case, the SQLi modifies the <span class="literal">WHERE</span> clause to search for records where the <span class="literal">name</span> column matches <span class="literal">test</span> or the equation <span class="literal">1='1'</span> returns <span class="literal">true</span>. MySQL helpfully treats <span class="literal">'1'</span> as an integer, and because <span class="literal">1</span> always equals <span class="literal">1</span>, the condition is <span class="literal">true</span> and the query returns all records in the <span class="literal">users</span> table. But injecting <span class="literal">test' OR 1='1</span> won’t work when other parts of the query are sanitized. For example, you might use a query like this:</p>&#13;
<p class="programs">$name = $_GET['name'];<br/>&#13;
$password = <span class="ent">➊</span>mysql_real_escape_string($_GET['password']);<br/>&#13;
$query = "SELECT * FROM users WHERE name = '$name' AND password = '$password' ";</p>&#13;
<p class="indent">In this case, the <span class="literal">password</span> parameter is also user controlled but properly sanitized <span class="ent">➊</span>. If you used the same payload, <span class="literal">test' OR 1='1</span>, as the name and if your password was 12345, your statement would look like this:</p>&#13;
<p class="programs">$query = "SELECT * FROM users WHERE name = 'test' OR 1='1' AND password = '12345' ";</p>&#13;
<p class="indent">The query looks for all records where the <span class="literal">name</span> is <span class="literal">test</span> or <span class="literal">1='1'</span> and the <span class="literal">password</span> is <span class="literal">12345</span> (we’ll ignore the fact that this database stores plaintext passwords, which is another vulnerability). Because the password check uses an <span class="literal">AND</span> operator, this query won’t return data unless a record’s password is <span class="literal">12345</span>. Although this breaks our attempted SQLi, it doesn’t stop us from trying another attack method.</p>&#13;
<p class="indent">We need to eliminate the <span class="literal">password</span> parameter, which we can do by adding <span class="literal">;--, test' OR 1='1;--</span>. This injection accomplishes two tasks: the semicolon (<span class="literal">;</span>) ends the SQL statement, and the two dashes (<span class="literal">--</span>) tell the database that the remainder of the text is a comment. This injected parameter changes the query to <span class="literal">SELECT * FROM users WHERE name = 'test' OR 1='1';</span>. The <span class="literal">AND password = '12345'</span> code in the statement becomes a comment, so the command returns all records from the table. When you’re using <span class="literal">--</span> as a comment, keep in mind that MySQL requires a space after the dashes and the remaining query. Otherwise, MySQL will return errors without executing the command.</p>&#13;
<h3 class="h3" id="ch09lev1sec2"><strong>Countermeasures Against SQLi</strong></h3>&#13;
<p class="noindent">One protection available to prevent SQLi is the use of <em>prepared statements</em>, which are a database feature that executes repeated queries. The specific details of prepared statements are beyond the scope of this book, but they protect against SQLi because queries are no longer executed dynamically. The database uses the queries like templates by having placeholders for variables. As a result, even when users pass unsanitized data to a query, the injection can’t modify the database’s query template, thus preventing SQLi.</p>&#13;
<p class="indent">Web frameworks, such as Ruby on Rails, Django, Symphony, and so on, also offer built-in protections to help prevent SQLi. But they aren’t perfect and can’t prevent the vulnerability everywhere. The two simple examples of SQLi you’ve just seen usually won’t work on sites built with frameworks unless the site developers didn’t follow best practices or didn’t recognize <span epub:type="pagebreak" id="page_84"/>that protections weren’t automatically provided. For example, the site <em><a href="https://rails-sqli.org/">https://rails-sqli.org/</a></em> maintains a list of common SQLi patterns in Rails that result from developer mistakes. When testing for SQLi vulnerabilities, your best bet is to look for older websites that look custom built or use web frameworks and content management systems that don’t have all the built-in protections of current systems.</p>&#13;
<h3 class="h3" id="ch09lev1sec3"><strong>Yahoo! Sports Blind SQLi</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Medium</p>&#13;
<p class="hang"><strong>URL:</strong> <em><a href="https://sports.yahoo.com">https://sports.yahoo.com</a></em></p>&#13;
<p class="hang"><strong>Source:</strong> N/A</p>&#13;
<p class="hang"><strong>Date reported:</strong> February 16, 2014</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $3,705</p>&#13;
<p class="noindent">A <em>blind SQLi</em> vulnerability occurs when you can inject SQL statements into a query but can’t get a query’s direct output. The key to exploiting blind injections is to infer information by comparing the results of unmodified and modified queries. For example, in February 2014, Stefano Vettorazzi found a blind SQLi when testing the Yahoo! sports subdomain. The page took parameters through its URL, queried a database for information, and returned a list of NFL players based on the parameters.</p>&#13;
<p class="indent">Vettorazzi changed the following URL, which returned the NFL players in 2010, from this:</p>&#13;
<p class="hangtb"><em><a href="http://sports.yahoo.com/nfl/draft?year=2010&amp;type=20&amp;round=2">sports.yahoo.com/nfl/draft?year=2010&amp;type=20&amp;round=2</a></em></p>&#13;
<p class="indent">to this:</p>&#13;
<p class="hangtb"><em><a href="http://sports.yahoo.com/nfl/draft?year=2010--&amp;type=20&amp;round=2">sports.yahoo.com/nfl/draft?year=2010--&amp;type=20&amp;round=2</a></em></p>&#13;
<p class="indent">Vettorazzi added two dashes (<span class="literal">--</span>) to the <span class="literal">year</span> parameter in the second URL. <a href="ch09.xhtml#ch09fig01">Figure 9-1</a> shows what the page looked like in Yahoo! before Vettorazzi added the two dashes. <a href="ch09.xhtml#ch09fig02">Figure 9-2</a> shows the result after Vettorazzi added the dashes.</p>&#13;
<p class="indent">The players returned in <a href="ch09.xhtml#ch09fig01">Figure 9-1</a> are different from those returned in <a href="ch09.xhtml#ch09fig02">Figure 9-2</a>. We can’t see the actual query because the code is on the backend of the website. But the original query likely passed each URL parameter to a SQL query that looked something like this:</p>&#13;
<p class="programs">SELECT * FROM players WHERE year = 2010 AND type = 20 AND round = 2;</p>&#13;
<p class="indent">By adding two dashes to the <span class="literal">year</span> parameter, Vettorazzi would have altered the query to this:</p>&#13;
<p class="programs">SELECT * FROM PLAYERS WHERE year = 2010-- AND type = 20 AND round = 2;</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_85"/><a id="ch09fig01"/><img alt="image" src="../images/09fig01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-1: Yahoo! player search results with an unmodified <span class="codeitalic">year</span> parameter</em></p>&#13;
<div class="image"><a id="ch09fig02"/><img alt="image" src="../images/09fig02.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-2: Yahoo! player search results with a modified <span class="codeitalic">year</span> parameter including <span class="codeitalic">--</span></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_86"/>This Yahoo! bug is slightly unusual because queries must end with a semicolon in most, if not all, databases. Because Vettorazzi only injected two dashes and commented out the query’s semicolon, this query should fail and either return an error or no records. Some databases can accommodate queries without semicolons, so Yahoo! was either using this functionality or its code accommodated the error in some other way. Regardless, after Vettorazzi recognized the different results the queries returned, he tried to infer the database version the site was using by submitting the following code as the <span class="literal">year</span> parameter:</p>&#13;
<p class="programs">(2010)and(if(mid(version(),1,1))='5',true,false))--</p>&#13;
<p class="indent">The MySQL database <span class="literal">version()</span> function returns the current version of the MySQL database in use. The <span class="literal">mid</span> function returns part of the string passed to its first parameter according to its second and third parameters. The second argument specifies the starting position of the substring that the function will return, and the third argument specifies the length of the substring. Vettorazzi checked whether the site used MySQL by calling <span class="literal">version()</span>. Then he tried to get the first digit in the version number by passing the <span class="literal">mid</span> function <span class="literal">1</span> as its first argument for the starting position and <span class="literal">1</span> as its second argument for the substring length. The code checks the first digit of the MySQL version using an <span class="literal">if</span> statement.</p>&#13;
<p class="indent">The <span class="literal">if</span> statement takes three arguments: a logical check, the action to perform if the check is true, and the action to perform if the check is false. In this case, the code checks whether the first digit from <span class="literal">version</span> is <span class="literal">5</span>; if so, the query returns <span class="literal">true</span>. If not, the query returns <span class="literal">false</span>.</p>&#13;
<p class="indent">Then Vettorazzi connected the true/false output with the <span class="literal">year</span> parameter using the <span class="literal">and</span> operator, so if the major version of the MySQL database was 5, players in the year 2010 would be returned on the Yahoo! web page. The query works this way because the condition <span class="literal">2010 and true</span> would be <span class="literal">true</span>, whereas <span class="literal">2010 and false</span> would be <span class="literal">false</span> and return no records. Vettorazzi executed the query and received no records, as shown in <a href="ch09.xhtml#ch09fig03">Figure 9-3</a>, meaning the first digit of the value returned from <span class="literal">version</span> wasn’t <span class="literal">5</span>.</p>&#13;
<div class="image"><a id="ch09fig03"/><img alt="image" src="../images/09fig03.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-3: Yahoo! player search results were empty when the code checked whether the database version started with the number 5.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_87"/>This bug is a blind SQLi because Vettorazzi couldn’t inject his query and see the output directly on the page. But Vettorazzi could still find information about the site. By inserting Boolean checks, such as the version-checking <span class="literal">if</span> statement, Vettorazzi could infer the information he needed. He could have continued to extract information from the Yahoo! database. But finding information about the MySQL version through his test query was enough to confirm to Yahoo! that the vulnerability existed.</p>&#13;
<h4 class="h4" id="ch09lev2sec1"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">SQLi vulnerabilities, like other injection vulnerabilities, aren’t always difficult to exploit. One way to find a SQLi vulnerability is to test URL parameters and look for subtle changes to query results. In this case, adding the double dash changed the results of Vettorazzi’s baseline query, revealing the SQLi.</p>&#13;
<h3 class="h3" id="ch09lev1sec4"><strong>Uber Blind SQLi</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Medium</p>&#13;
<p class="hang"><strong>URL:</strong> <em>http://sctrack.email.uber.com.cn/track/unsubscribe.do/</em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/150156/">https://hackerone.com/reports/150156/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> July 8, 2016</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $4,000</p>&#13;
<p class="noindent">In addition to web pages, you can find blind SQLi vulnerabilities in other places, such as email links. In July 2016, Orange Tsai received an email advertisement from Uber. He noticed that the unsubscribe link included a base64-encoded string as a URL parameter. The link looked like this:</p>&#13;
<p class="hangtb"><em>http://sctrack.email.uber.com.cn/track/unsubscribe.do?p=eyJ1c2VyX2lkIjogIjU3NTUiLCAicmVjZWl2ZXIiOiAib3JhbmdlQG15bWFpbCJ9</em></p>&#13;
<p class="indent">Decoding the <span class="literal">p</span> parameter value <span class="literal">eyJ1c2VyX2lkIjogIjU3NTUiLCAicmVjZWl2ZXIiOiAib3JhbmdlQG15bWFpbCJ9</span> using base64 returns the JSON string <span class="literal">{"user_id": "5755", "receiver": "orange@mymail"}</span>. To the decoded string, Orange added the code <span class="literal">and sleep(12) = 1</span> to the encoded <span class="literal">p</span> URL parameter. This harmless addition makes the database take longer to respond to the unsubscribe action <span class="literal">{"user_id": "5755 and sleep(12)=1", "receiver": "orange@mymail"}</span>. If a site is vulnerable, the query execution evaluates <span class="literal">sleep(12)</span> and performs no action for 12 seconds before comparing the output of the <span class="literal">sleep</span> command to <span class="literal">1</span>. In MySQL, the <span class="literal">sleep</span> command normally returns 0, so this comparison will fail. But it doesn’t matter because the execution will take at least 12 seconds.</p>&#13;
<p class="indent">After Orange reencoded the modified payload and passed the payload to the URL parameter, he visited the unsubscribe link to confirm that the HTTP response took at least 12 seconds. Realizing he needed more concrete proof of the SQLi to send to Uber, he dumped the user name, host name, and database name using brute force. By doing so, he demonstrated that he could extract information from the SQLi vulnerability without accessing confidential data.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_88"/>A SQL function called <span class="literal">user</span> returns the user name and host name of a database in the form <em>&lt;user&gt;</em>@<em>&lt;host&gt;</em>. Because Orange couldn’t access output from his injected queries, he couldn’t call <span class="literal">user</span>. Instead, Orange modified his query to add a conditional check when the query looked up his user ID, comparing one character of the database’s user name and host name string at a time using the <span class="literal">mid</span> function. Similar to the Yahoo! Sports blind SQLi vulnerability in the previous bug report, Orange used a comparison statement and brute force to derive each character of the user name and host name string.</p>&#13;
<p class="indent">For example, Orange took the first character of the value returned from the <span class="literal">user</span> function using the <span class="literal">mid</span> function. Then he compared whether the character was equal to <span class="literal">'a'</span>, then <span class="literal">'b'</span>, then <span class="literal">'c'</span>, and so on. If the comparison statement was true, the server would execute the unsubscribe command. This result indicated that the first character of the <span class="literal">user</span> function’s return value was equal to the character it was being compared to. If the statement was false, the server would not try to unsubscribe Orange. By checking each character of the <span class="literal">user</span> function’s return value using this method, Orange could eventually derive the entire user name and host name.</p>&#13;
<p class="indent">Manually brute-forcing a string takes time, so Orange created a Python script that generated and submitted payloads to Uber on his behalf, as follows:</p>&#13;
<p class="programs"><span class="ent">➊</span> import json<br/>&#13;
   import string<br/>&#13;
   import requests<br/>&#13;
   from urllib import quote<br/>&#13;
   from base64 import b64encode<br/>&#13;
<span class="ent">➋</span> base = string.digits + string.letters + '_-@.'<br/>&#13;
<span class="ent">➌</span> payload = {"user_id": 5755, "receiver": "blog.orange.tw"}<br/>&#13;
<span class="ent">➍</span> for l in range(0, 30):<br/>&#13;
    <span class="ent">➎</span> for i in base:<br/>&#13;
        <span class="ent">➏</span> payload['user_id'] = "5755 and mid(user(),%d,1)='%c'#"%(l+1, i)<br/>&#13;
        <span class="ent">➐</span> new_payload = json.dumps(payload)<br/>&#13;
           new_payload = b64encode(new_payload)<br/>&#13;
           r = requests.get('http://sctrack.email.uber.com.cn/track/unsubscribe.<br/>&#13;
   do?p='+quote(new_payload))<br/>&#13;
        <span class="ent">➑</span> if len(r.content)&gt;0:<br/>&#13;
                   print i,<br/>&#13;
                   break</p>&#13;
<p class="indent">The Python script begins with five lines of <span class="literal">import</span> statements <span class="ent">➊</span> that retrieve the libraries Orange needed to process HTTP requests, JSON, and string encodings.</p>&#13;
<p class="indent">A database user name and host name can be made up of any combination of uppercase letters, lowercase letters, numbers, hyphens (<span class="literal">-</span>), underscores (<span class="literal">_</span>), at symbols (<span class="literal">@</span>), or periods (<span class="literal">.</span>). At <span class="ent">➋</span>, Orange creates the <span class="literal">base</span> variable to hold these characters. The code at <span class="ent">➌</span> creates a variable to hold the payload that the script sends to the server. The line of code at <span class="ent">➏</span> is the injection, which uses the <span class="literal">for</span> loops at <span class="ent">➍</span> and <span class="ent">➎</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_89"/>Let’s look at the code at <span class="ent">➏</span> in detail. Orange references his user ID, 5755, with the string <span class="literal">user_id</span> as defined at <span class="ent">➌</span> to create his payloads. He uses the <span class="literal">mid</span> function and string processing to construct a payload similar to the Yahoo! bug earlier in this chapter. The <span class="literal">%d</span> and <span class="literal">%c</span> in the payload are string replacement placeholders. The <span class="literal">%d</span> is data that represents a digit, and the <span class="literal">%c</span> is character data.</p>&#13;
<p class="indent">The payload string starts at the first pair of double quotes (<span class="literal">"</span>) and ends at the second pair of double quotes before the third percent symbol at <span class="ent">➏</span>. The third percent symbol tells Python to replace the <span class="literal">%d</span> and <span class="literal">%c</span> placeholders with the values following the percent symbol in the parentheses. So the code replaces <span class="literal">%d</span> with <span class="literal">l+1</span> (the variable <span class="literal">l</span> plus the number <span class="literal">1</span>) and <span class="literal">%c</span> with the variable <span class="literal">i</span>. The hash mark (<span class="literal">#</span>) is another way of commenting in MySQL and renders any part of the query following Orange’s injection into a comment.</p>&#13;
<p class="indent">The <span class="literal">l</span> and <span class="literal">i</span> variables are the loop iterators at <span class="ent">➍</span> and <span class="ent">➎</span>. The first time the code enters <span class="literal">l in range (0,30)</span> at <span class="ent">➍</span>, <span class="literal">l</span> will be <span class="literal">0</span>. The value of <span class="literal">l</span> is the position in the user name and host name string returned by the <span class="literal">user</span> function that the script is trying to brute-force. Once the script has a position in the user name and host name string it’s testing, the code enters a nested loop at <span class="ent">➎</span> that iterates over each character in the <span class="literal">base</span> string. The first time the script iterates through both loops, <span class="literal">l</span> will be <span class="literal">0</span> and <span class="literal">i</span> will be <span class="literal">a</span>. These values are passed to the <span class="literal">mid</span> function at <span class="ent">➏</span> to create the payload <span class="literal">"5755 and mid(user(),0,1)='a'#"</span>.</p>&#13;
<p class="indent">In the next iteration of the nested <span class="literal">for</span> loop, the value of <span class="literal">l</span> will still be <span class="literal">0</span> and <span class="literal">i</span> will be <span class="literal">b</span> to create the payload <span class="literal">"5755 and mid(user(),0,1)='b'#"</span>. The position <span class="literal">l</span> will remain constant as the loop iterates though each character in <span class="literal">base</span> to create the payload at <span class="ent">➏</span>.</p>&#13;
<p class="indent">Each time a new payload is created, the code following <span class="ent">➐</span> converts the payload to JSON, reencodes the string using the <span class="literal">base64encode</span> function, and sends the HTTP request to the server. The code at <span class="ent">➑</span> checks whether the server responds with a message. If the character in <span class="literal">i</span> matches the user name substring at the position being tested, the script stops testing characters at that position and moves to the next position in the <span class="literal">user</span> string. The nested loop breaks and returns to the loop at <span class="ent">➍</span>, which increments <span class="literal">l</span> by <span class="literal">1</span> to test the next position of the user name string.</p>&#13;
<p class="indent">This proof of concept allowed Orange to confirm that the database user name and host name were <span class="literal">sendcloud_w@10.9.79.210</span> and the database name was <span class="literal">sendcloud</span> (to obtain the database name, replace <span class="literal">user</span> with <span class="literal">database</span> at <span class="ent">➏</span>). In response to the report, Uber confirmed that the SQLi hadn’t occurred on its server. The injection occurred on a third-party server that Uber was using, but Uber still paid a reward. Not all bounty programs will do the same. Uber likely paid a bounty because the exploit would allow an attacker to dump all of Uber’s customer email addresses from the <span class="literal">sendcloud</span> database.</p>&#13;
<p class="indent">Although you can write your own scripts as Orange did to dump database information from a vulnerable website, you can also use automated tools. <a href="app01.xhtml#app01">Appendix A</a> includes information about one such tool called sqlmap.</p>&#13;
<h4 class="h4" id="ch09lev2sec2"><span epub:type="pagebreak" id="page_90"/><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Keep an eye out for HTTP requests that accept encoded parameters. After you decode and inject your query into a request, be sure to reencode your payload so everything still matches the encoding the server expects.</p>&#13;
<p class="indent">Extracting a database name, user name, and host name is generally harmless, but be sure it’s within the permitted actions of the bounty program you’re working in. In some cases, the <span class="literal">sleep</span> command is enough for a proof of concept.</p>&#13;
<h3 class="h3" id="ch09lev1sec5"><strong>Drupal SQLi</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Hard</p>&#13;
<p class="hang"><strong>URL:</strong> Any Drupal site using version 7.32 or earlier</p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/31756/">https://hackerone.com/reports/31756/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> October 17, 2014</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $3,000</p>&#13;
<p class="noindent"><em>Drupal</em> is a popular open source content management system for building websites, similar to Joomla! and WordPress. It’s written in PHP and is <em>modular</em>, meaning you can install new functionality in units to a Drupal site. Every Drupal install contains <em>Drupal core</em>, which is a set of modules that runs the platform. These core modules require a connection to a database, such as MySQL.</p>&#13;
<p class="indent">In 2014, Drupal released an urgent security update to Drupal core because all Drupal sites were vulnerable to a SQLi vulnerability that could easily be abused by anonymous users. The impact of the vulnerability would allow an attacker to take over any unpatched Drupal site. Stefan Horst discovered the vulnerability when he noticed a bug in Drupal core’s prepared statement functionality.</p>&#13;
<p class="indent">The Drupal vulnerability occurred in Drupal’s database application programming interface (API). The Drupal API uses the PHP Data Objects (PDO) extension, which is an <em>interface</em> for accessing databases in PHP. An interface is a programming concept that guarantees inputs and outputs of a function without defining how the function is implemented. In other words, PDO hides the differences between databases so programmers can use the same functions to query and fetch data regardless of the database type. PDO includes support for prepared statements.</p>&#13;
<p class="indent">Drupal created a database API to use the PDO functionality. The API creates a Drupal database abstraction layer so developers never have to query the database directly with their own code. But they can still use prepared statements and use their code with any database type. The specifics of the API are beyond the scope of this book. But you need to know that the API will generate the SQL statements to query the database and has built-in security checks to prevent SQLi vulnerabilities.</p>&#13;
<p class="indent">Recall that prepared statements prevent SQLi vulnerabilities because an attacker can’t modify the query structure with malicious input, even if <span epub:type="pagebreak" id="page_91"/>the input is unsanitized. But prepared statements can’t protect against SQLi vulnerabilities if the injection occurs when the template is being created. If an attacker can inject malicious input during the template creation process, they can create their own malicious prepared statement. The vulnerability Horst discovered occurred because of SQL’s <span class="literal">IN</span> clause, which looks for values that exist in a list of values. For example, the code <span class="literal">SELECT * FROM users WHERE name IN ('peter', 'paul', 'ringo');</span> selects the data from the <span class="literal">users</span> table where the value in the <span class="literal">name</span> column is <span class="literal">peter</span>, <span class="literal">paul</span>, or <span class="literal">ringo</span>.</p>&#13;
<p class="indent">To understand why the <span class="literal">IN</span> clause is vulnerable, let’s look at the code behind Drupal’s API:</p>&#13;
<p class="programs">$this-&gt;expandArguments($query, $args);<br/>&#13;
$stmt = $this-&gt;prepareQuery($query);<br/>&#13;
$stmt-&gt;execute($args, $options);</p>&#13;
<p class="indent">The <span class="literal">expandArguments</span> function is responsible for building queries that use the <span class="literal">IN</span> clause. After <span class="literal">expandArguments</span> builds queries, it passes them to <span class="literal">prepareQuery</span>, which builds the prepared statements that the <span class="literal">execute</span> function executes. To understand the significance of this process, let’s look at the relevant code for <span class="literal">expandArguments</span> as well:</p>&#13;
<p class="programs">   <span class="codeitalic1">--snip--</span><br/>&#13;
<span class="ent">➊</span> foreach(array_filter($args, `is_array`) as $key =&gt; $data) {<br/>&#13;
  <span class="ent">➋</span> $new_keys = array();<br/>&#13;
  <span class="ent">➌</span> foreach ($data as $i =&gt; $value) {<br/>&#13;
       --<span class="codeitalic1">snip</span>--<br/>&#13;
    <span class="ent">➍</span> $new_keys[$key . '_' . $i] = $value;<br/>&#13;
      }<br/>&#13;
     --<span class="codeitalic1">snip</span>--<br/>&#13;
   }</p>&#13;
<p class="indent">This PHP code uses arrays. PHP can use associative arrays, which explicitly define keys as follows:</p>&#13;
<p class="programs">['red' =&gt; 'apple', 'yellow' =&gt; 'banana']</p>&#13;
<p class="indent">The keys in this array are <span class="literal">'red'</span> and <span class="literal">'yellow'</span>, and the array’s values are the fruits to the right of the arrow (<span class="literal">=&gt;</span>).</p>&#13;
<p class="indent">Alternatively, PHP can use a <em>structured array</em>, as follows:</p>&#13;
<p class="programs">['apple', 'banana']</p>&#13;
<p class="indent">A structured array’s keys are implicit and based on the position of the value in the list. For example, the key for <span class="literal">'apple'</span> is <span class="literal">0</span> and the key for <span class="literal">'banana'</span> is <span class="literal">1</span>.</p>&#13;
<p class="indent">The <span class="literal">foreach</span> PHP function iterates over an array and can separate the array key from its value. It can also assign each key and each value to its own variable and pass them to a block of code for processing. At <span class="ent">➊</span>, <span class="literal">foreach</span> takes each element of an array and verifies the value passed to it is an array by calling <span class="literal">array_filter($args, 'is_array')</span>. After the statement confirms it <span epub:type="pagebreak" id="page_92"/>has an array value, it assigns each of the array’s keys to <span class="literal">$key</span> and each of the values to <span class="literal">$data</span> for each iteration of the <span class="literal">foreach</span> loop. The code will modify the values in the array to create placeholders, so the code at <span class="ent">➋</span> initializes a new empty array to later hold the placeholder values.</p>&#13;
<p class="indent">To create the placeholders, the code at <span class="ent">➌</span> iterates through the <span class="literal">$data</span> array by assigning each key to <span class="literal">$i</span> and each value to <span class="literal">$value</span>. Then at <span class="ent">➍</span>, the <span class="literal">new_keys</span> array initialized at <span class="ent">➋</span> holds the first array’s key concatenated with the key at <span class="ent">➌</span>. The code’s intended outcome is to create data placeholders that look like <span class="literal">name_0</span>, <span class="literal">name_1</span>, and so on.</p>&#13;
<p class="indent">Here is what a typical query would look like using Drupal’s <span class="literal">db_query</span> function, which queries a database:</p>&#13;
<p class="programs">db_query("SELECT * FROM {users} WHERE name IN (:name)",<br/>&#13;
  array(':name'=&gt;array('user1','user2')));</p>&#13;
<p class="indent">The <span class="literal">db_query</span> function takes two parameters: a query that contains named placeholders for variables and an array of values to substitute for those placeholders. In this example, the placeholder is <span class="literal">:name</span> and is an array with the values <span class="literal">'user1'</span> and <span class="literal">'user2'</span>. In a structured array, the key for <span class="literal">'user1'</span> is <span class="literal">0</span> and the key for <span class="literal">'user2'</span> is <span class="literal">1</span>. When Drupal executes the <span class="literal">db_query</span> function, it calls the <span class="literal">expandArguments</span> function, which concatenates the keys to each value. The resulting query uses <span class="literal">name_0</span> and <span class="literal">name_1</span> in place of the keys, as shown here:</p>&#13;
<p class="programs">SELECT * FROM users WHERE name IN (:name_0, :name_1)</p>&#13;
<p class="indent">But the problem arises when you call <span class="literal">db_query</span> using an associative array, as in the following code:</p>&#13;
<p class="programs">db_query("SELECT * FROM {users} where name IN (:name)",<br/>&#13;
  array(':name'=&gt;array('test);-- ' =&gt; 'user1', 'test' =&gt; 'user2')));</p>&#13;
<p class="indent">In this case, <span class="literal">:name</span> is an array and its keys are <span class="literal">'test);--'</span> and <span class="literal">'test'</span>. When <span class="literal">expandArguments</span> receives the <span class="literal">:name</span> array and processes it to create the query, it generates this:</p>&#13;
<p class="programs">SELECT * FROM users WHERE name IN (:name_test);-- , :name_test)</p>&#13;
<p class="indent">We’ve injected a comment into the prepared statement. The reason this occurs is that <span class="literal">expandArguments</span> iterates through each array element to build placeholders but assumes it’s passed a structured array. In the first iteration, <span class="literal">$i</span> is assigned <span class="literal">'test);--'</span> and <span class="literal">$value</span> is assigned <span class="literal">'user1'</span>. The <span class="literal">$key</span> is <span class="literal">':name'</span> and combining that with <span class="literal">$i</span> results in <span class="literal">name_test);--</span>. In the second iteration, <span class="literal">$i</span> is assigned <span class="literal">'test'</span> and <span class="literal">$value</span> is <span class="literal">'user2'</span>. Combining <span class="literal">$key</span> with <span class="literal">$i</span> results in the value <span class="literal">name_test</span>.</p>&#13;
<p class="indent">This behavior allows malicious users to inject SQL statements into Drupal queries that rely on the <span class="literal">IN</span> clause. The vulnerability affects Drupal login functionality, making the SQLi vulnerability severe because any site user, including an anonymous user, could exploit it. Making matters <span epub:type="pagebreak" id="page_93"/>worse, PHP PDO supports the ability to execute multiple queries at once by default. This means an attacker could append additional queries to the user login query in order to execute non-<span class="literal">IN</span> clause SQL commands. For example, an attacker could use <span class="literal">INSERT</span> statements, which insert records into a database, to create an administrative user that they could then use to log in to the website.</p>&#13;
<h4 class="h4" id="ch09lev2sec3"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">This SQLi vulnerability wasn’t simply a matter of submitting a single quote and breaking a query. Rather, it required understanding how Drupal core’s database API handles the <span class="literal">IN</span> clause. The takeaway from this vulnerability is to be on the lookout for opportunities to alter the structure of input passed to a site. When a URL takes <span class="literal">name</span> as a parameter, try adding <span class="literal">[]</span> to the parameter to change it to an array and test how the site handles it.</p>&#13;
<h3 class="h3" id="ch09lev1sec6"><strong>Summary</strong></h3>&#13;
<p class="noindent">SQLi can be a significant vulnerability and dangerous for a site. If an attacker finds a SQLi, they might obtain full permissions to a site. In some situations, a SQLi vulnerability can be escalated by inserting data into the database that enables administrative permissions on the site, as in the Drupal example. When you’re looking for SQLi vulnerabilities, explore places where you can pass unescaped single or double quotes to a query. When you find a vulnerability, the indications that the vulnerability exists can be subtle, such as with blind injections. You should also look for places where you can pass data to a site in unexpected ways, such as where you can substitute array parameters in request data, as in the Uber bug.<span epub:type="pagebreak" id="page_94"/></p>&#13;
</body></html>