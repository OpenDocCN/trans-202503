["```\nstatement = Return(exp)\n          | Expression(exp)\n          **| If(exp condition, statement then, statement? else)**\n          | Null\n```", "```\nif (a == 3) {\n    a = a + 1;\n    int b = a * 4;\n    return a && b;\n}\n```", "```\nif (a == 3)\n    return a;\nelse\n    b = 8;\n```", "```\nif (a)\n    if (a > 10)\n        return a;\n    else\n        return 10 - a;\n```", "```\nif (a > 100)\n    return 0;\nelse if (a > 50)\n    return 1;\nelse\n    return 2;\n```", "```\nif (a > 100)\n    return 0;\nelse\n    if (a > 50)\n        return 1;\n    else\n        return 2;\n```", "```\nIf(\n    condition=Binary(GreaterThan, Var(\"a\"), Constant(100)),\n    then=Return(Constant(0)),\n    else=If(\n        condition=Binary(GreaterThan, Var(\"a\"), Constant(50)),\n        then=Return(Constant(1)),\n        else=Return(Constant(2))\n    )\n)\n```", "```\n<statement> ::= \"return\" <exp> \";\"\n              | <exp> \";\"\n **| \"if\" \"(\" <exp> \")\" <statement> [\"else\" <statement>]**\n              | \";\"\n```", "```\nif (a)\n    if (a > 10)\n        return a;\n    else\n        return 10 - a;\n```", "```\nif (a) {\n    if (a > 10)\n        return a;\n    else\n        return 10 - a;\n}\n```", "```\nif (a) {\n    if (a > 10)\n        return a;\n}\nelse\n    return 10 - a;\n```", "```\nexp = Constant(int)\n    | Var(identifier)\n    | Unary(unary_operator, exp)\n    | Binary(binary_operator, exp, exp)\n| Assignment(exp, exp)\n **| Conditional(exp condition, exp, exp)**\n```", "```\n<exp> ::= <factor> | <exp> <binop> <exp> | **<exp> \"?\" <exp> \":\" <exp>**\n```", "```\na = 1 ? 2 : 3\n```", "```\na = (1 ? 2 : 3)\n```", "```\na || b ? 2 : 3\n```", "```\n(a || b) ? 2 : 3\n```", "```\n1 ? 2 : 3 || 4\n```", "```\n1 ? 2 : (3 || 4)\n```", "```\n1 ? 2 : a = 5\n```", "```\n(1 ? 2 : a) = 5\n```", "```\nx ? x = 1 : 2\n```", "```\nx ? (x = 1) : 2\n```", "```\na ? b ? 1 : 2 : 3\n```", "```\na ? (b ? 1 : 2) : 3\n```", "```\na ? 1 : b ? 2 : 3\n```", "```\na ? 1 : (b ? 2 : 3)\n```", "```\nparse_exp(tokens, min_prec):\n    left = parse_factor(tokens)\n    next_token = peek(tokens)\n    while next_token is a binary operator and precedence(next_token) >= min_prec:\n        if next_token is \"=\":\n            take_token(tokens) // remove \"=\" from list of tokens\n            right = parse_exp(tokens, precedence(next_token))\n            left = Assignment(left, right)\n        **else if next_token is \"?\":**\n            **middle = parse_conditional_middle(tokens)**\n            **right = parse_exp(tokens, precedence(next_token))**\n            **left = Conditional(left, middle, right)**\n        else:\n            operator = parse_binop(tokens)\n            right = parse_exp(tokens, precedence(next_token) + 1)\n            left = Binary(operator, left, right)\n        next_token = peek(tokens)\n    return left\n```", "```\nprogram = Program(function_definition)\nfunction_definition = Function(identifier name, block_item* body)\nblock_item = S(statement) | D(declaration)\ndeclaration = Declaration(identifier name, exp? init)\nstatement = Return(exp)\n          | Expression(exp)\n          **| If(exp condition, statement then, statement? else)**\n          | Null\nexp = Constant(int)\n| Var(identifier)\n    | Unary(unary_operator, exp)\n    | Binary(binary_operator, exp, exp)\n| Assignment(exp, exp)\n **| Conditional(exp condition, exp, exp)**\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or\n                | Equal | NotEqual | LessThan |LessOrEqual\n                | GreaterThan | GreaterOrEqual\n```", "```\n<program> ::= <function>\n<function> ::= \"int\" <identifier> \"(\" \"void\" \")\" \"{\" {<block-item>} \"}\"\n<block-item> ::= <statement> | <declaration>\n<declaration> ::= \"int\" <identifier> [\"=\" <exp>] \";\"\n<statement> ::= \"return\" <exp> \";\"\n              | <exp> \";\"\n **| \"if\" \"(\" <exp> \")\" <statement> [\"else\" <statement>]**\n              | \";\"\n<exp> ::= <factor> | <exp> <binop> <exp> **| <exp> \"?\" <exp> \":\" <exp>**\n<factor> ::= <int> | <identifier> | <unop> <factor> | \"(\" <exp> \")\"\n<unop> ::= \"-\" | \"~\" | \"!\"\n<binop> ::= \"-\" | \"+\" | \"*\" | \"/\" | \"%\" | \"&&\" | \"||\"\n          | \"==\" | \"!=\" | \"<\" | \"<=\" | \">\" | \">=\" | \"=\"\n<identifier> ::= ? An identifier token ?\n<int> ::= ? A constant token ?\n```", "```\n`<instructions for condition>`\nc = `<result of condition>`\nJumpIfZero(c, end)\n`<instructions for statement>`\nLabel(end)\n```", "```\n`<instructions for condition>`\nc = `<result of condition>`\nJumpIfZero(c, else_label)\n`<instructions for statement1>`\nJump(end)\nLabel(else_label)\n`<instructions for statement2>`\nLabel(end)\n```", "```\n`<instructions for condition>`\nc = `<result of condition>`\nJumpIfZero(c, e2_label)\n`<instructions to calculate e1>`\nv1 = `<result of e1>`\nresult = v1\nJump(end)\nLabel(e2_label)\n`<instructions to calculate e2>`\nv2 = `<result of e2>`\nresult = v2\nLabel(end)\n```", "```\n$ **./test_compiler** `**/path/to/your_compiler**` **--chapter 6 --goto**\n```"]