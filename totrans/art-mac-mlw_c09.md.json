["```\nmain:\n...\n0x000000010000b5fa    movabs     rcx, **0x7473696c702e74**\n0x000000010000b604    mov        qword [rbp+rax+var_209], rcx\n0x000000010000b60c    movabs     rcx, **0x746e6567612e706f**\n0x000000010000b616    mov        qword [rbp+rax+var_210], rcx\n0x000000010000b61e    movabs     rcx, **0x6f6c2d7865612e6d**\n0x000000010000b628    mov        qword [rbp+rax+var_218], rcx\n0x000000010000b630    movabs     rcx, **0x6f632f73746e6567**\n0x000000010000b63a    mov        qword [rbp+rax+var_220], rcx\n0x000000010000b642    movabs     rcx, **0x4168636e75614c2f**\n0x000000010000b64c    mov        qword [rbp+rax+var_228], rcx\n0x000000010000b654    movabs     rcx, **0x7972617262694c2f**\n0x000000010000b65e    mov        qword [rbp+rax+var_230], rcx\n```", "```\nmain:\n...\n0x000000010000b5fa    movabs     rcx, '**t.plist**'\n0x000000010000b604    mov        qword [rbp+rax+var_209], rcx\n0x000000010000b60c    movabs     rcx, '**op.agent**'\n0x000000010000b616    mov        qword [rbp+rax+var_210], rcx\n0x000000010000b61e    movabs     rcx, '**m.aex-lo**'\n0x000000010000b628    mov        qword [rbp+rax+var_218], rcx\n0x000000010000b630    movabs     rcx, '**gents/co**'\n0x000000010000b63a    mov        qword [rbp+rax+var_220], rcx\n0x000000010000b642    movabs     rcx, '**/LaunchA**'\n0x000000010000b64c    mov        qword [rbp+rax+var_228], rcx\n0x000000010000b654    movabs     rcx, '**/Library**'\n0x000000010000b65e    mov        qword [rbp+rax+var_230], rcx\n```", "```\n0x0000000100001fe5    mov        r13, qword [objc_msgSend]\n...\n0x0000000100002034    mov        rsi, @selector(**yoop:**)\n0x000000010000203b    lea        rdx, @\"F5Ur0CCFMOfWHjecxEqGLy...OLs=\"\n0x0000000100002042    mov        rdi, self\n1 0x0000000100002045    call       r13 \n\n2 0x0000000100002048    mov        rcx, rax \n```", "```\n% **lldb Final_Presentation.app** \n\n(lldb) **target create \"Final_Presentation.app\"**\nCurrent executable set to 'Final_Presentation.app' (x86_64).\n\n(lldb) **b 0x100002048**\n(lldb) **run**\n\nProcess 826 stopped\n* thread #5, stop reason = breakpoint 1.1\n\n(lldb) **po $rax**\nhttp://flux2key.com/liaROelcOeVvfjN/fsfSQNrIyxeRvXH.php?very=%@&xnvk=%@\n```", "```\n% **strings - Final_Presentation.app/Contents/MacOS/usrnode**\n\n/bin/sh\nopen -a\nSong.dat\nKEY_PATH\noX0s4Qj3GiAzAnOmzGqjOA==\nie8DGq3HZ82UqV9N4cpuVw==\nF5Ur0CCFMO/fWHjecxEqGLy/xq5gE98ZviUSLrtFPmHE6gRZGU7ZmXiW+/gzAouX\naagHdDG+YP9BEmHLCg9PVXOuIlMB12oTVPlb8CHvda6TWtptKmqJVvI4o63iQ36Shy9Y9hPtlh+kcrCL0uj+tQ==\n```", "```\n0x00007364    push       esi\n0x00007365    push       0xe555\n0x0000736b    call       **sub_9502**\n...\n0x00007380    push       0xe5d6 \n0x00007385    push       eax\n0x00007386    call       **sub_9502**\n...\n0x000073fd    push       0xe6b6\n0x00007402    push       edi\n0x00007403    call       **sub_9502**\n```", "```\n% **lldb Finder.app**\n\n(lldb) **process launch --stop-at-entry**\n(lldb) **b 0x00007408**\nBreakpoint 1: where = Finder`Finder[0x00007408], address = 0x00007408\n\n(lldb) **c**\nProcess 1130 resuming\nProcess 1130 stopped * thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n\n(lldb) **x/20s 0x0000e2f0**\n1 0x0000e2f8: \"89.34.111.113:443;\" \n0x0000e4f8: \"Password\"\n0x0000e52a: \"HostId-%Rand%\"\n0x0000e53b: \"Default Group\"\n0x0000e549: \"NC\"\n0x0000e54c: \"-\"\n2 0x0000e555: \"%home%/.defaults/Finder\" \n0x0000e5d6: \"com.mac.host\"\n0x0000e607: \"{0Q44F73L-1XD5-6N1H-53K4-I28DQ30QB8Q1}\"\n...\n```", "```\n0x000000010000239f    mov        rsi, @selector(yoop:)\n**0x00000001000023a6**    lea        rdx, @\"BouCfWujdfbAUfCos/iIOg==\"\n0x00000001000023ad    mov        r15, qword [_objc_msgSend] \n0x00000001000023b4    call       r15\n```", "```\n-(void *)yoop:(void *)string {\n\n  rax = [[[NSString alloc] initWithData:[[yu decode:string]\n         AESDecryptWithPassphrase:key] encoding:0x1] \n         stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];\n\n  return rax;\n}\n```", "```\n0x00007a93    mov        dword [esp+0x8], 0x38\n0x00007a9b    lea        eax, dword [ebx+0x105a7]    ;\"\\xDA\\xB3\\...\\x14\"\n0x00007aa1    mov        dword [esp+0x4], eax\n0x00007aa5    call       sub_d900 \n```", "```\n0x0000d908    mov        eax, dword [ebp+arg_4]\n1 0x0000d90b    movzx      edi, byte [eax]\n...\n0x0000d930    movzx      edx, byte [esi]\n0x0000d933    inc        esi\n0x0000d934    mov        byte [ebp+var_D], dl\n0x0000d937    mov        eax, edx\n0x0000d939    mov        edx, dword [ebp+arg_0]\n0x0000d93c    xor        eax, edi 1\n0x0000d93e    xor        eax, ecx\n2 0x0000d940    xor        eax, 0x47\n0x0000d943    mov        byte [edx+ecx-1], al\n0x0000d947    movzx      eax, byte [ebp+var_D]\n0x0000d94b    inc        ecx\n0x0000d94c    add        edi, eax\n0x0000d94e    cmp        ecx, dword [ebp+var_C]\n0x0000d951    jne        loc_d930\n```", "```\ndef decrypt(encryptedStr):\n   ...\n 1 key_1 = encryptedStr[0]\n   key_2 = 0x47   \n\n   for i in range(1, len(encryptedStr)): \n   2 byte = (encryptedStr[i] ^ key_1 ^ i ^ key_2) & 0xFF \n     decryptedStr.append(chr(byte)) \n\n     key_1 = encryptedStr[i] + key_1\n\n 3 return ''.join(decryptedStr) \n```", "```\n#from start to end of cString segment\n#extract/decrypt all strings\ni = cSectionStart\nwhile i < cSectionEnd:\n\n   #skip if item is just a 0x0\n   if 0 == cSegment.readByte(i):\n      i += 1\n      continue\n\n   stringStart = i\n   encryptedString = []\n   while (0 != cSegment.readByte(i)): 1\n      encryptedString.append(cSegment.readByte(i))\n      i += 1\n\n      decryptedString = decryptStr(encryptedString) 2\n      if decryptedString.isascii(): 3\n\n         print(decryptedString)\n\n         #add as inline comment and to all references 4\n         doc.getCurrentSegment().setInlineCommentAtAddress(stringStart, decryptedString)\n\n         for reference in cSegment.getReferencesOfAddress(stringStart):\n            doc.getCurrentSegment().setInlineCommentAtAddress(reference, decryptedString)\n```", "```\n0x00007a93    mov        dword [esp+0x8], 0x38\n0x00007a9b    lea        eax, dword [ebx+0x105a7] ; \"/Library/Caches/com.apple.LaunchServices\n                                                     -02300.csstore, \\xDA\\xB3\\...\\x14\"\n0x00007aa1    mov        dword [esp+0x4], eax\n0x00007aa5    call       sub_d900\n```", "```\n% **strings - EvilQuest/patch**\nHost: %s\nERROR: %s\n1PnYz01rdaiC0000013\n1MNsh21anlz906WugB2zwfjn0000083\n2Uy5DI3hMp7o0cq|T|14vHRz0000013\n3mTqdG3tFoV51KYxgy38orxy0000083\n0JVurl1WtxB53WxvoP18ouUM2Qo51c3v5dDi0000083\n2WVZmB2oRkhr1Y7s1D2asm{v1Al5AT33Xn3X0000053\n3iHMvK0RFo0r3KGWvD28URSu06OhV61tdk0t22nizO3nao1q0000033\n...\n```", "```\nlea     rdi, \"0hC|h71FgtPJ32afft3EzOyU3xFA7q0{LBxN3vZ\"...\ncall    **ei_str**\n...\nlea     rdi, \"0hC|h71FgtPJ19|69c0m4GZL1xMqqS3kmZbz3FW\"...\ncall    **ei_str**\n```", "```\n//library constructor\n//1\\. resolves address of malware's `ei_str` function\n//2\\. invokes it for all embedded encrypted strings\n__attribute__((constructor)) static void decrypt() {\n\n    //define & resolve the malware's ei_str function\n    typedef char* (*ei_str)(char* str);\n    ei_str ei_strFP = dlsym(RTLD_MAIN_ONLY, \"ei_str\");\n\n    //init pointers\n    //the __cstring segment starts 0xF98D after ei_str and is 0x29E9 long\n    char* start = (char*)ei_strFP + 0xF98D;\n    char* end = start + 0x29E9;\n    char* current = start;\n\n    //decrypt all strings\n    while(current < end) {\n\n      //decrypt and print out\n      char* string = ei_strFP(current);\n      printf(\"decrypted string (%#lx): %s\\n\", (unsigned long)current, string);\n\n      //skip to next string\n      current += strlen(current);\n    }\n\n    //bye!\n    exit(0);\n}\n```", "```\n% **DYLD_INSERT_LIBRARIES=**`<path to dylib>` `<path to EvilQuest>`\n```", "```\n% **DYLD_INSERT_LIBRARIES=/tmp/decryptor.dylib EvilQuest/patch**\n\ndecrypted string (0x10eb675ec): andrewka6.pythonanywhere.com\n\ndecrypted string (0x10eb67a95): *id_rsa*/i\ndecrypted string (0x10eb67c15): *key*.png/i\ndecrypted string (0x10eb67c35): *wallet*.png/i\ndecrypted string (0x10eb67c55): *key*.jpg/i\n\ndecrypted string (0x10eb67d12): [Memory Based Bundle]\ndecrypted string (0x10eb67d6b): ei_run_memory_hrd\n\ndecrypted string (0x10eb681ad): \n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n<key>Label</key>\n<string>%s</string>\n\n<key>ProgramArguments</key>\n<array>\n```", "```\n# **nvram boot-args=\"amfi_get_out_of_my_way=0x1\"**\n```", "```\ndlsym(dlopen(0x0, 0xa), 0x100058a91);\ndlsym(dlopen(0x0, 0xa), 0x100058a80);\ndlsym(dlopen(0x0, 0xa), 0x100058a64);\ndlsym(dlopen(0x0, 0xa), 0x100058a50);\ndlsym(dlopen(0x0, 0xa), 0x100058a30);\ndlsym(dlopen(0x0, 0xa), 0x100058a10);\ndlsym(dlopen(0x0, 0xa), 0x1000589f0); \n```", "```\nif (rax != 0x6956b086) {\n   if (rax != 0x6ad066c0) {\n       if (rax == 0x6b1464f0) {\n       *(int8_t *)byte_1000589fa = var_29 ^ 0x37;\n       *(int8_t *)byte_1000589fb = *(int8_t *)byte_1000589fb ^ 0x9a;\n       *(int8_t *)byte_1000589fc = *(int8_t *)byte_1000589fc ^ 0xc8;\n       *(int8_t *)byte_1000589fd = *(int8_t *)byte_1000589fd ^ 0xb2;\n       *(int8_t *)byte_1000589fe = *(int8_t *)byte_1000589fe ^ 0x15;\n       *(int8_t *)byte_1000589ff = *(int8_t *)byte_1000589ff ^ 0x78;\n       *(int8_t *)byte_100058a00 = *(int8_t *)byte_100058a00 ^ 0x1d;\n       ...\n       *(int8_t *)byte_100058a20 = *(int8_t *)byte_100058a20 ^ 0x69;\n       *(int8_t *)byte_100058a21 = *(int8_t *)byte_100058a21 ^ 0xab;\n       *(int8_t *)byte_100058a22 = *(int8_t *)byte_100058a22 ^ 0x02;\n       *(int8_t *)byte_100058a23 = *(int8_t *)byte_100058a23 ^ 0x46;\n```", "```\n% **upx -d ColdRoot.app/Contents/MacOS/com.apple.audio.driver** \n\n                       Ultimate Packer for eXecutables\n                          Copyright (C) 1996 - 2013\n\n  With LZMA support, Compiled by Mounir IDRASSI (mounir@idrix.fr)\n\n        File size         Ratio      Format               Name\n   --------------------   ------   -----------   ----------------------\n   3292828   <-  983040   29.85%    Mach/i386    com.apple.audio.driver\n\n  Unpacked 1 file.\n```", "```\n#define SG_PROTECTED_VERSION_1\t0x8 /* This segment is protected.  If the\n                                       segment starts at file offset 0, the\n                                       first page of the segment is not\n                                       protected.  All other pages of the\n                                       segment are protected. */\n```", "```\n% **otool -l HackingTeam/installer**\n...\n\nLoad command 1\n  cmd LC_SEGMENT\n  cmdsize 328\n  segname __TEXT\n  vmaddr 0x00001000\n  vmsize 0x00004000\n  fileoff 0\n  filesize 16384\n  maxprot 0x00000007\n  initprot 0x00000005\n  nsects 4\n  flags **0x8**\n```", "```\nstatic load_return_t load_segment( ... )\n{\n  ...\n\n  if (scp->flags & SG_PROTECTED_VERSION_1) {\n    ret = unprotect_dsmos_segment(file_start,\n file_end - file_start,\n            vp,\n            pager_offset,\n            map,\n            vm_start,\n            vm_end - vm_start);\n            if (ret != LOAD_SUCCESS) {\n                     return ret;\n            }\n  }\n```", "```\n(lldb) **memory read --binary --outfile /tmp/dumped.bin 0x7000 0xbffff --force** \n```", "```\nrax = decodeString(&encodedString);\nif (system(rax) != 0x0) goto leave;\n\nleave:\n    rax = exit(0xffffffffffffffff);\n    return rax;\n}\n```", "```\n(lldb) b system\nBreakpoint 1: where = libsystem_c.dylib`system, address = 0x00007fff67848fdd\n(lldb) c\n\nProcess 1253 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n    frame #0: 0x00007fff67848fdd libsystem_c.dylib`system\nlibsystem_c.dylib`system:\n->  0x7fff67848fdd <+0>: pushq  %rbp\n\n(lldb) x/s $rdi\n0x100205350: \"sysctl hw.model|grep Mac > /dev/null\" 1\n```", "```\n% **sysctl hw.model**\nhw.model: VMware7,1\n```", "```\n% **sysctl hw.model**\nhw.model: MacBookAir7,2\n```", "```\necho $((`sysctl -n hw.logicalcpu`/`sysctl -n hw.physicalcpu`))|grep 2 > /dev/null\n```", "```\n1 r14 = IOServiceMatching(\"IOEthernetInterface\");\nif (r14 != 0x0) {\n  rbx = CFDictionaryCreateMutable(...);\n  if (rbx != 0x0) {\n    CFDictionarySetValue(rbx, @\"IOPrimaryInterface\", **_kCFBooleanTrue);\n    CFDictionarySetValue(r14, @\"IOPropertyMatch\", rbx);\n    CFRelease(rbx);\n  }\n}\n...\nrdx = &var_5C0;\nif (IOServiceGetMatchingServices(r15, r14, rdx) == 0x0) {\n  ...\n  r12 = var_5C0;\n  rbx = IOIteratorNext(r12);\n  r14 = IORegistryEntryGetParentEntry(rbx, \"IOService\", rdx); \n  if (r14 == 0x0) {\n    rdx = **_kCFAllocatorDefault;\n  2 r15 = IORegistryEntryCreateCFProperty(var_35C, @\"IOMACAddress\", rdx, 0x0);\n```", "```\n(lldb) **po**[$rdi launchPath]\n/bin/sh\n\n(lldb) **po**[$rdi arguments]\n<__NSArrayI 0x10580dfd0>(\n -c, \n command -v csrutil > /dev/null && csrutil status | grep -v \"enabled\" > /dev/null && echo 1 || echo 0 \n)\n```", "```\n1 rax = [*0x10006c4a0 objectAtIndexedSubscript:0x51]; \n\nrdx = rax;\n2 if ([rbx fileExistsAtPath:rdx] != 0x0) goto fileExists; \n\nfileExists:\nrax = **exit(0x0);**\n```", "```\nstatic bool AmIBeingDebugged(void)\n    // Returns true if the current process is being debugged (either \n    // running under the debugger or has a debugger attached post facto).\n{\n    int                 junk;\n    int                 mib[4];\n    struct kinfo_proc   info;\n    size_t              size;\n\n    // Initialize the flags so that, if sysctl fails for some bizarre \n    // reason, we get a predictable result.\n\n info.kp_proc.p_flag = 0;\n\n    // Initialize mib, which tells sysctl the info we want, in this case\n    // we're looking for information about a specific process ID.\n\n    mib[0] = CTL_KERN;\n    mib[1] = KERN_PROC;\n    mib[2] = KERN_PROC_PID;\n    mib[3] = getpid();\n\n    // Call sysctl.\n\n    size = sizeof(info);\n    junk = sysctl(mib, sizeof(mib) / sizeof(*mib), &info, &size, NULL, 0);\n    assert(junk == 0);\n\n    // We're being debugged if the P_TRACED flag is set.\n\n    return ( (info.kp_proc.p_flag & P_TRACED) != 0 );\n}\n```", "```\nint main(int argc, char *argv[]) {\n...\n   if ((AmIBeingDebugged() & 0x1) == 0x0) { \n\n   //core malicious logic \n\n   }\n   else {\n    remove(argv[0]); \n}\n\nreturn 0;\n```", "```\n% **lldb proton**\n...\n\n(lldb) **r**\nProcess 666 exited with status = 45 (0x0000002d)\n```", "```\n0x000000010001e6b8    xor        edi, edi\n0x000000010001e6ba    mov        esi, 0xa\n0x000000010001e6bf    call     1 dlopen \n0x000000010001e6c4    mov        rbx, rax\n0x000000010001e6c7    lea        rsi, qword [ptrace]\n0x000000010001e6ce    mov        rdi, rbx\n0x000000010001e6d1    call     2 dlsym \n0x000000010001e6d6    mov        edi, 3 0x1f\n0x000000010001e6db    xor        esi, esi\n0x000000010001e6dd    xor        edx, edx\n0x000000010001e6df    xor        ecx, ecx\n0x000000010001e6e1    call       rax\n```", "```\n% **nm EvilQuest/patch**\n...\n\n0000000100007aa0 T _is_debugging\n0000000100007bc0 T _is_virtual_mchn\n```", "```\n0x000000010000b89a    call       **is_debugging**\n0x000000010000b89f    cmp        eax, 0x0\n0x000000010000b8a2    je         continue\n0x000000010000b8a8    mov        edi, 0x1\n0x000000010000b8ad    call       exit\n```", "```\nstartEncrypt:\n...\n0x000000010000238b    call       waitOrExit\n0x0000000100002390    test       eax, eax\n0x0000000100002392    je         leave\n```", "```\nstartEncrypt:\n...\n0x000000010000238b    nop\n0x000000010000238c    nop\n0x000000010000238d    nop\n...\n0x0000000100002396    nop\n0x0000000100002397    nop\n```", "```\n(lldb) **reg write $rip** `<new value>` \n```", "```\n% (lldb) **b 0x10000b8b2**\nBreakpoint 1: where = patch[0x000000010000b8b2]\n\n(lldb)**c**\nProcess 683 resuming\nProcess 683 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n\n->  0x10000b8b2: callq  0x100007c20\n    0x10000b8b7: leaq   0x7de2(%rip), %rdi\n    0x10000b8be: movl   $0x8, %esi\n    0x10000b8c3: movl   %eax, -0x38(%rbp)\n\n(lldb) **reg write $rip 0x10000b8b7**\n(lldb)**c**\n```", "```\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n->  0x10000b89f: cmpl   $0x0, %eax\n    0x10000b8a2: je     0x10000b8b2\n    0x10000b8a8: movl   $0x1, %edi\n    0x10000b8ad: callq  exit\n\n(lldb) **reg read $eax**\n       rax = 0x00000001\n\n(lldb) **reg write $eax 0**\n```"]