<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2a" id="ch22"><span epub:type="pagebreak" id="page_203"/><strong>22  Mask ROM Photography</strong></h2>&#13;
<p class="noindent">Some chips store their program bits as markings on the masks that lithographically draw the microchip. We call this a mask ROM, to distinguish it from EEPROM, flash ROM, and other field-programmable technologies. In this chapter, we’ll go over the theory behind photographing these ROMs to extract their bits, and in the following chapters we’ll work out examples of real targets from beginning to end.</p>&#13;
<p class="indent">Mask ROMs come in three types: via, diffusion, and implant. These are quite different chemically and physically, but in extracting them, we just need to understand them well enough to make the bits visible. <a href="ch22.xhtml#ch22tab1">Table 22.1</a> lists a number of microcontrollers and their ROM processes.</p>&#13;
<p class="indent"><em>Via</em> or <em>contact</em> ROMs use a via between layers to mark a bit. These aren’t very efficient for layout space, but they are quite easy to decode because the bits are clearly visible when you find them. Many of them, such as those in the Nintendo Game Boy, are even visible from the surface without delayering!</p>&#13;
<p class="indent"><em>Diffusion</em> ROMs are lower in the chip. Bits here are marked by the presence of a diffusion pool making a working transistor, or the absence of the diffusion pool breaking that transistor. Because they are so low, you almost always need to delayer the chip to see them, but there’s little risk of damaging the chip during the process.</p>&#13;
<p class="indent"><em>Implant</em> ROMs are the most frustrating of these three. Bits are encoded by an additional ion implant in an otherwise working transistor, and by some infernal coincidence the damaged and undamaged transistors are exactly the same color! These ROMs generally require delayering to the inside of the bits, then staining a difference into their coloring with a Dash etch, which we will discuss shortly.</p>&#13;
<table class="table95">&#13;
<colgroup>&#13;
<col style="width:70%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="borderb"><span epub:type="pagebreak" id="page_204"/><p class="tab-para">Model</p></td>&#13;
<td class="borderb"><p class="tab-para">ROM Type</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">TMS1000</p></td>&#13;
<td><p class="tab-para">Via</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">Game Boy</p></td>&#13;
<td><p class="tab-para">Via</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">T44C080C</p></td>&#13;
<td><p class="tab-para">Via</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">TMS320C15</p></td>&#13;
<td><p class="tab-para">Via</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">MSP430F1, F2, F4</p></td>&#13;
<td><p class="tab-para">Via</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">6500/1</p></td>&#13;
<td><p class="tab-para">Diffusion</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">EMZ1001</p></td>&#13;
<td><p class="tab-para">Diffusion</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">MYK82</p></td>&#13;
<td><p class="tab-para">Diffusion</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">Tengen Rabbit</p></td>&#13;
<td><p class="tab-para">Diffusion</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">TMS32C10NL</p></td>&#13;
<td><p class="tab-para">Diffusion</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">HCS300</p></td>&#13;
<td><p class="tab-para">Diffusion</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">Z8</p></td>&#13;
<td><p class="tab-para">Diffusion</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">SM590</p></td>&#13;
<td><p class="tab-para">Implant</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">MK3870</p></td>&#13;
<td><p class="tab-para">Implant</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">TLCS-47 (TMP47)</p></td>&#13;
<td><p class="tab-para">Implant</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="tab-cap1" id="ch22tab1">Table 22.1: Example ROM Types</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_205"/>There are of course as many ways to encode bits as there are unique shapes invented by the silicon wizards. I use these broad categories to describe the effort required for bit extraction, but there are of course ROMs with markings on the metal layers instead of the via layer, which are also surface visible. Like anything in reverse engineering, let’s use this abstraction until it ceases to be useful, then dig a little deeper to see what’s inside.</p>&#13;
<h3 class="h3" id="ch00lev1sec64"><strong>Microscopy</strong></h3>&#13;
<p class="noindent">Once the chip is ready, we’ll need to photograph it.</p>&#13;
<p class="indent">You will need a metallurgical microscope, which is one in which the column of light comes down through the lens to reflect back from the die. Microscopes that send light up through the sample are great for biology, but they will not help to photograph an opaque microchip.</p>&#13;
<p class="indent">A camera is also required. While it’s possible to get decent pictures from a lens adapter on a monocular microscope, it’s much easier to use a trinocular scope so that your own eyes can find the target and the camera is only required at the end for the photos.</p>&#13;
<p class="indent">It’s generally impossible to zoom out enough to keep the whole image in frame while also keeping its details in focus, so we instead photograph a series of shots that overlap one another. These can be combined after the fact with panorama software, such as Hugin.</p>&#13;
<p class="indent">This photography can be quite tedious at the limits of your scope’s capabilities, so I generally try to first make a whole-chip <span epub:type="pagebreak" id="page_206"/>panorama at minimum magnification and then follow that with high-magnification panoramas of my area of interest, such as the ROM. A million thanks to John McMaster for selling me a microscope with a motorized stage, so all of my photographs now have consistent spacing and filenames that indicate the row and column.</p>&#13;
<h3 class="h3" id="ch00lev1sec65"><strong>Delayering with Hydrofluoric Acid</strong></h3>&#13;
<p class="noindent">To delayer a chip, I heat it in dilute hydrofluoric acid (HF), which is available over the counter in the States as Whink or Rust-Go branded rust stain remover.</p>&#13;
<p class="indent">Hydrofluoric acid is dangerous to your bones, and it will damage them without giving the courtesy of much skin pain. Be very careful if you mess with this stuff, and do not skimp on safety.<sup><a id="ch22fn_1" href="footnotes.xhtml#ch22fn1">1</a></sup> Another hassle with hydrofluoric acid is that we are using it because it attacks glass, so we can’t very well use a glass beaker to hold the reaction. Plastic beakers, or plastic centrifuge tubes, are critical here.</p>&#13;
<p class="indent">As the HF attacks your target, you’ll see some bubbles as it reacts to metals. The first flurry of bubbles usually indicates the top metal layer, and in reactions where you need to get a particular depth into the chip, it’s often handy to delayer many chips at once and to sort them after the fact to find your right depth.</p>&#13;
<p class="indent">You might notice that the metal layers lift off of the chip rather than dissolving into a liquid. A little agitation is helpful to get these away from the die, so that they don’t mask your delayering reactions.</p>&#13;
<h3 class="h3" id="ch00lev1sec66"><span epub:type="pagebreak" id="page_207"/><strong>Dash Etching for Implant ROMs</strong></h3>&#13;
<p class="noindent">For implant ROMs, where the bits are identical in color, we need to give them different colors in order to photograph them. This is accomplished after delayering by a Dash etch, which is best described in Beck (1998) and McMaster (2019).</p>&#13;
<p class="indent">Delayering here can be quite confusing, as you can’t really see how close we are to the implants that we’d like to photograph. It might help to delayer many samples, returning those that haven’t been sufficiently delayered to the bath.</p>&#13;
<p class="indent">The Dash etch consists of three parts. Hydrofluoric acid and nitric acid attack the silicon, while acetic acid (HAc) buffers the reaction to slow it down. When the ratios are right, p-type doping will slightly tip this reaction in favor of oxidization, causing the p-type silicon to turn brown faster than the n-type silicon does.</p>&#13;
<p class="indent">I perform this with John McMaster’s Rust-Go solution, which is made from 3mL of 65% HNO<sub>3</sub>, 4mL of 12% HF (Rust-Go), and 8mL of acetic acid. The final proportions are roughly 4.3% HNO<sub>3</sub> and 3.2% HF; the remainder of the solution is HAc and H<sub>2</sub>O to buffer the reaction.</p>&#13;
<p class="indent">Beck recommends a solution of 3mL 65% HNO<sub>3</sub>, 1mL 48% HF, and 10 mL to 12 mL 98% HAc. McMaster himself has moved on to this mixture, and I only hesitate to follow because HF is a nasty poison.<sup><a id="ch22fn_2" href="footnotes.xhtml#ch22fn2">2</a></sup></p>&#13;
<p class="indent">Whichever solution is used, the already delayered die is placed into it under a bright light, such as that from a halogen fiber lamp. A minute or two under the light will darken the chip in splotches, and if you’re lucky, the ones will stand out as much darker than the zeroes.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_208"/><img id="ch22fig1" src="../images/f0208-01.jpg" alt="Image" width="777" height="1076"/></div>&#13;
<p class="figcap">Figure 22.1: TMP47C434N Implant ROM</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_209"/>It is absolutely critical to keep the metal content low during these reactions. You mustn’t have any metal salts from a delayering reaction on your glassware, and you mustn’t have any remnant of the lead frame beneath the die. Quite often, you can even see markings on the edge of the die from your tweezers during the reaction.</p>&#13;
<p class="indent"><a href="ch22.xhtml#ch22fig1">Figure 22.1</a> shows the datasheet description of the TMP47C-434N’s font implant ROM, along with a die photograph from my lab after staining the bits with a Dash etch. Notice how the Dash etch leads to uneven contrast; some are much darker or lighter than others.</p>&#13;
<h3 class="h3" id="ch00lev1sec67"><strong>From Photographs to Bits</strong></h3>&#13;
<p class="noindent">After capturing the bits photographically, it’s necessary to extract the bits digitally. One way to do this is by carefully writing them down, patiently marking each one or zero without losing your place or losing your mind. Another way is to let software do the boring work. “Work smarter, not harder,” as Coach Crigger would tell me back in high school.</p>&#13;
<p class="indent">An early public example of this is Rompar from Laurie (2013), a Python application written to mark the bits in a MARC4 microcontroller from a car’s key fob. More recently, Bitractor from Gerlinsky (2019) and my own Mask ROM Tool from Goodspeed (2024), both in C<code>++</code>. These three tools vary dramatically in their implementation and usage, but the general principle is to come up with a matrix of bit positions, then to sample the color of each bit to determine the difference between the ones and the zeroes.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_210"/><img id="ch22fig2" src="../images/f0210-01.jpg" alt="Image" width="778" height="389"/></div>&#13;
<p class="figcap">Figure 22.2: MYK82 Bits in the Diffusion Layer</p>&#13;
<div class="image"><img id="ch22fig3" src="../images/f0210-02.jpg" alt="Image" width="753" height="450"/></div>&#13;
<p class="figcap">Figure 22.3: Color Distributions from the MYK82 ROM</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_211"/>When you try this yourself, you will find that a naive sampling strategy is surprisingly effective. Most bits can be correctly decoded by a threshold in one color channel, usually red or green. It helps to improve those odds by drawing a histogram of samples in each color channel, to ensure that there is a clean bimodal separation between the ones and zeroes and that your threshold is set between the two groups.</p>&#13;
<p class="indentt">For a concrete example, <a href="ch22.xhtml#ch22fig2">Figure 22.2</a> shows a closeup of bits from the NSA’s MYK82 that we’ll discuss in detail and whose ROM we will dump in <a href="ch24.xhtml#ch24">Chapter 24</a>. You’ll see bits between the central squares and the horizontal wires as a rectangular box that’s darker than its surroundings. <a href="ch22.xhtml#ch22fig3">Figure 22.3</a> shows just how much darker the ones are than the zeroes in the red channel, a total separation with no bits on the threshold and very few near it. Green has a separation that is nearly as good, but the blue channel shows no real separation.</p>&#13;
<p class="indentt">In cases where a clean bimodal separation does not exist in any color channel, it can help to create one by image preprocessing or by sampling more than a single pixel. In my tool, I have sampling techniques that return the darkest of each color channel in a thin horizontal or vertical strip. This is particularly effective for over-etched diffusion ROMs, where bits have a bordering color but any color difference in the center of the bit has already been etched away.</p>&#13;
<p class="indentt">While the available bit-marking tools have many differences, they have all standardized on ASCII art as an export format. Generally, the wider axis is arbitrarily defined as X to fit with computer monitor dimensions, and you can expect some rotations to be necessary before decoding the bits.</p>&#13;
<h3 class="h3" id="ch00lev1sec68"><span epub:type="pagebreak" id="page_212"/><strong>From Bits to Bytes</strong></h3>&#13;
<p class="noindent">After extracting the bits in the physical order, you’ll need to rearrange them into bytes in the logical order. Before we jump into the tools that make this less painful, let’s discuss a little about why the bits are in such a confusing order to begin with.</p>&#13;
<p class="indent">In natural languages, we have considerable variety in our writing. Some languages are written from left to right, while others are written from right to left. Some represent words by groups of letters, some use ideograms, and a few mix these concepts, building one larger symbol out of smaller ones to represent a word.</p>&#13;
<p class="indent">ROMs also have some common rules and infinite variety in the arrangement, but there is one concept that they almost never implement. They almost never group the bits of a byte together, instead preferring to scatter them into eight columns, separated from one another for physical convenience.</p>&#13;
<p class="indent">To figure out the ordering of bits, one method is to very carefully study the bits of a ROM and to try out different patterns until they make sense. If you see 16 columns in a 16-bit microcontroller, for example, you might guess that one bit is taken from each column to make a word. Checking all of the words in both the top row and the bottom row might reveal an entry point of the program, making the entirety of the layout make sense.</p>&#13;
<p class="indent">Gerlinsky (2019) introduces BitViewer, a tool in <a href="ch22.xhtml#ch22fig4">Figure 22.4</a> that graphically displays bits, adjusting their organization so that a human operator can explore their meaning. After loading a bitstream, you can choose how tall and wide bit pixels are, how much spacing to put between them, and how many to group into a major column. Bits are selected individually or grouped into columns and rows, allowing an operator to spot patterns that reveal the ROM contents. This is much less painful than doing the same on graph paper.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_213"/><img id="ch22fig4" src="../images/f0213-01.jpg" alt="Image" width="777" height="463"/></div>&#13;
<p class="figcap">Figure 22.4: BitViewer from Gerlinsky (2019)</p>&#13;
<div class="image"><img id="ch22fig5" src="../images/f0213-02.jpg" alt="Image" width="778" height="393"/></div>&#13;
<p class="figcap">Figure 22.5: MaskRomTool from Goodspeed (2024)</p>&#13;
<table class="table95">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="topL"><span epub:type="pagebreak" id="page_214"/><p class="tab-para">cols-downl</p></td>&#13;
<td><p class="tab-para">First bit is top left,<br/>then move down,<br/>then move right.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="topL"><p class="tab-para">cols-downr</p></td>&#13;
<td><p class="tab-para">First bit is top right,<br/>then move down,<br/>then move left.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="topL"><p class="tab-para">cols-left</p></td>&#13;
<td><p class="tab-para">First bit is top right,<br/>then move left,<br/>then move down.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="topL"><p class="tab-para">cols-right</p></td>&#13;
<td><p class="tab-para">First bit is top left,<br/>then move right,<br/>then move down.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="topL"><p class="tab-para">squeeze-lr</p></td>&#13;
<td><p class="tab-para"><code>byte&amp;0xAA</code> use cols-left,<br/><code>byte&amp;0x55</code> use cols-right.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="tab-cap1" id="ch22tab2">Table 22.2: Zorrom Decoding Strategies</p>&#13;
<p class="indent">McMaster (2018) takes another approach in a program called Zorrom. It implements decoding strategies for a number of known chips, along with a series of transformations such as a flip on the X axis, rotating the bit matrix and inverting the bits. When you are lucky, which is about half the time, it can correctly solve the decoding given just the bits themselves and a guess at a few bits or bytes.</p>&#13;
<p class="indent">Zorrom’s decoding strategies are listed in <a href="ch22.xhtml#ch22tab2">Table 22.2</a>. To apply a strategy, first divide the bit columns into eight groups and then sample one bit from each group to form a byte, with the least significant bit being the one on the left. So for the cols-downr strategy, your first byte would be formed from the top right bit of every group. Your second byte would have its bits just beneath <span epub:type="pagebreak" id="page_215"/>those of the first, and after sampling a bit from every row of the groups, you would move one bit column to the right and start again from the top.</p>&#13;
<p class="indent">It doesn’t bother to support decoding strategies that start from the bottom of the group or that place the most significant bit on the left. These are handled by the existing strategies, after rotations and an optional flip on the X axis.</p>&#13;
<p class="indent">My own solution to bit decoding is called GatoROM, which runs both as a CLI tool and as a C<code>++</code> library. A GUI extension to my Mask ROM Tool from Goodspeed (2024) was then written using the library. It is shamelessly inspired by McMaster’s tool, implementing all of the necessary transformations for compatibility with his solver.</p>&#13;
<p class="indent">Used as a library, <code>void*</code> pointers allow a bidirectional association between the physically ordered bits and the logically ordered bytes of the ROM. You can select bytes in the hex viewer and then ask the software to highlight them in the GUI. This is incredibly handy when implementing new decoding strategies for chips that don’t quite fit the existing ones.</p>&#13;
<p class="indent">Whatever tooling you use to decode a ROM, the end result is a flat binary file containing the bytes. When you first get a meaningful decoding, be a little suspicious of its ordering, as small ordering mistakes might not be noticed until the ROM is disassembled and reverse engineered.<sup><a id="ch22fn_3" href="footnotes.xhtml#ch22fn3">3</a></sup></p>&#13;
</div>
</div>
</body></html>