["```\n\n      void commandLCD(uint8_t _command)\n\n      {\n\n      ❶ PORTD = (PORTD & 0x0F)|(_command & 0xF0);\n\n      ❷ PORTD &= ~(1<<PD0);\n\n      ❸ PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      ❹ PORTD &= ~(1<<PD1);\n\n      _delay_us(200);\n\n      ❺ PORTD = (PORTD & 0x0F)|(_command << 4);\n\n      ❻ PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      ❼ PORTD &= ~(1<<PD1);\n\n      _delay_ms(2);\n\n      }\n\n```", "```\n\n      `1111` \n      0000    // Ones are the higher nibble\n\n      0000\n      `1111` \n      // Ones are the lower nibble\n\n```", "```\n\n      void initLCD()\n\n      {\n\n      ❶ DDRD = 0b11111111;\n\n      _delay_ms(100);\n\n      ❷ commandLCD(0x02);\n\n      ❸ commandLCD(0x28);\n\n      ❹ commandLCD(0x0C);\n\n      ❺ commandLCD(0x06);\n\n      ❻ commandLCD(0x01);\n\n      _delay_ms(2);\n\n      }\n\n```", "```\n\n      void clearLCD()\n\n      {\n\n      ❶ commandLCD(0x01);\n\n      _delay_ms(2);\n\n      ❷ commandLCD(0x80);\n\n      _delay_ms(2);\n\n      }\n\n```", "```\n\n      void cursorLCD(uint8_t column, uint8_t row)\n\n      {\n\n      if (row == 0 && column<16)\n\n      {\n\n      ❶ commandLCD((column & 0x0F)|0x80);\n\n      }\n\n      else if (row == 1 && column<16)\n\n      {\n\n      ❷ commandLCD((column & 0x0F)|0xC0);\n\n      }\n\n      }\n\n```", "```\n\n      void printLCD(char *_string)\n\n      {\n\n      uint8_t i;\n\n      ❶ for (i=0; _string[i]!=0; i++)\n\n      {\n\n      ❷ PORTD = (PORTD & 0x0F)|(_string[i] & 0xF0);\n\n      ❸ PORTD |= (1<<PD0);\n\n      ❹ PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      ❺ PORTD &= ~(1<<PD1);\n\n      _delay_us(200);\n\n      ❻ PORTD = (PORTD & 0x0F)|(_string[i] << 4);\n\n      ❼ PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      ❽ PORTD &= ~(1<<PD1);\n\n      _delay_ms(2);\n\n      }\n\n      }\n\n```", "```\n\n      printLCD(\"AVR Workshop!\");\n\n      printLCD(\"3.141592654\");\n\n```", "```\n\n      char resultsArray[9];\n\n      printLCD(resultsArray);\n\n```", "```\n\n      // Project 52 - Using a Character LCD with Your AVR\n\n      #include <avr/io.h>\n\n      #include <util/delay.h>\n\n      #include <stdlib.h>\n\n      void initLCD()\n\n      {\n\n      DDRD = 0b11111111;\n\n      _delay_ms(100);\n\n      commandLCD(0x02);\n\n      commandLCD(0x28);\n\n      commandLCD(0x0C);\n\n      commandLCD(0x06);\n\n      commandLCD(0x01);\n\n      _delay_ms(2);\n\n      }\n\n      void commandLCD(uint8_t _command)\n\n      {\n\n      PORTD = (PORTD & 0x0F) | (_command & 0xF0\n\n      PORTD &= ~(1<<PD0);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1)\n\n      _delay_us(200);\n\n      PORTD = (PORTD & 0x0F) | (_command << 4);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_ms(2);\n\n      }\n\n      void clearLCD()\n\n      {\n\n      commandLCD (0x01);\n\n      _delay_ms(2);\n\n      commandLCD (0x80);\n\n      _delay_ms(2);\n\n      }\n\n      void printLCD(char *_string)\n\n      {\n\n      uint8_t i;\n\n      for(i=0; _string[i]!=0; i++)\n\n      {\n\n      PORTD = (PORTD & 0x0F) | (_string[i] & 0xF0);\n\n      PORTD |= (1<<PD0);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_us(200);\n\n      PORTD = (PORTD & 0x0F) | (_string[i] << 4);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_ms(2);\n\n      }\n\n      }\n\n      void cursorLCD(uint8_t column, uint8_t row)\n\n      // Move cursor to desired column (0–15), row (0–1)\n\n      {\n\n      if (row == 0 && column<16)\n\n      {\n\n      commandLCD((column & 0x0F)|0x80);\n\n      }\n\n      else if (row == 1 && column<16)\n\n      {\n\n      commandLCD((column & 0x0F)|0xC0);\n\n      }\n\n      }\n\n      int main()\n\n      {\n\n      ❶ initLCD();\n\n      ❷ char numbers[9];\n\n      ❸ int i;\n\n      while(1)\n\n      {\n\n      ❹ cursorLCD(1,0);\n\n      printLCD(\"AVR Workshop!\");\n\n      cursorLCD(0,1);\n\n      printLCD(\"Learning LCD use\");\n\n      _delay_ms(1000);\n\n      ❺ clearLCD();\n\n      cursorLCD(1,0);\n\n      printLCD(\"Counting up:\");\n\n      ❻ for (i = 0; i<10; i++)\n\n      {\n\n      ❼ itoa(i,numbers,10);\n\n      cursorLCD(i,1);\n\n      ❽ printLCD(numbers);\n\n      _delay_ms(1000);\n\n      }\n\n      clearLCD();\n\n      }\n\n      }\n\n```", "```\n\n      // Project 53 - Building an AVR-Based LCD Digital Clock\n\n      #include <avr/io.h>\n\n      #include <util/delay.h>\n\n      #include <stdlib.h>\n\n      // Variables to store time and date\n\n      uint8_t hours, minutes, seconds, dow, dom, mo, years;\n\n      void I2Cenable()\n\n      // Enable I2C bus\n\n      {\n\n      TWBR = 72;           // 100 kHz I2C bus\n\n      TWCR |= (1 << TWEN); // Enable I2C on PORTC4 and 5\n\n      }\n\n      void I2Cwait()\n\n      // Wait until I2C finishes an operation\n\n      {\n\n      // Wait until bit TWINT in TWCR is set to 1\n\n      while (!(TWCR & (1<<TWINT)));\n\n      }\n\n      void I2CstartWait(unsigned char address)\n\n      {\n\n      uint8_t status;\n\n      while (1)\n\n      {\n\n      // Send START condition\n\n      TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);\n\n      // Wait until transmission completes\n\n      I2Cwait();\n\n      // Check value of TWSR, and mask out status bits\n\n      status = TWSR & 0b11111000;\n\n      if ((status != 0b00001000) && (status != 0b00010000)) continue;\n\n      // Send device address\n\n      TWDR = address;\n\n      TWCR = (1<<TWINT) | (1<<TWEN);\n\n      // Wait until transmission completes\n\n      I2Cwait();\n\n      // Check value of TWSR, and mask out status bits\n\n      status = TWSR & 0b11111000;\n\n      if ((status == 0b00100000 )||(status == 0b01011000))\n\n      {\n\n      TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);\n\n      // Wait until stop condition is executed and I2C bus released\n\n      while(TWCR & (1<<TWSTO));\n\n      continue;\n\n      }\n\n      break;\n\n      }\n\n      }\n\n      void I2Cstop()\n\n      // Stop I2C bus and release GPIO pins\n\n      {\n\n      // Clear interrupt, enable I2C, generate stop condition\n\n      TWCR |= (1 << TWINT)|(1 << TWEN)|(1 << TWSTO);\n\n      }\n\n      void I2Cwrite(uint8_t data)\n\n      // Send ′data′ to I2C bus\n\n      {\n\n      TWDR = data;\n\n      TWCR |= (1 << TWINT)|(1 << TWEN);\n\n      I2Cwait();\n\n      }\n\n      uint8_t I2Cread()\n\n      // Read incoming byte of data from I2C bus\n\n      {\n\n      TWCR |= (1 << TWINT)|(1 << TWEN);\n\n      I2Cwait();\n\n      // Incoming byte is placed in TWDR register\n\n      return TWDR;\n\n      }\n\n      uint8_t I2CreadACK()\n\n      // Read incoming byte of data from I2C bus and ACK signal\n\n      {\n\n      TWCR |= (1 << TWINT)|(1 << TWEN)|(1 << TWEA);\n\n      I2Cwait();\n\n      // Incoming byte is placed in TWDR register\n\n      return TWDR;\n\n      }\n\n      uint8_t decimalToBcd(uint8_t val)\n\n      // Convert integer to BCD\n\n      {\n\n      return((val/10*16)+(val%10));\n\n      }\n\n      uint8_t bcdToDec(uint8_t val)\n\n      // Convert BCD to integer\n\n      {\n\n      return((val/16*10)+(val%16));\n\n      }\n\n      void setTimeDS3231(uint8_t hh, uint8_t mm, uint8_t ss, uint8_t dw, uint8_t dd,\n\n      uint8_t mo, uint8_t yy)\n\n      // Set the time on DS3231\n\n      {\n\n      I2CstartWait(0xD0);            // DS3231 write\n\n      I2Cwrite(0x00);                // Start with hours register\n\n      I2Cwrite(decimalToBcd(ss));    // Seconds\n\n      I2Cwrite(decimalToBcd(mm));    // Minutes\n\n      I2Cwrite(decimalToBcd(hh));    // Hours\n\n      I2Cwrite(decimalToBcd(dw));    // Day of week\n\n      I2Cwrite(decimalToBcd(dd));    // Date\n\n      I2Cwrite(decimalToBcd(mo));    // Month\n\n      I2Cwrite(decimalToBcd(yy));    // Year\n\n      I2Cstop();\n\n      }\n\n      void readTimeDS3231()\n\n      // Retrieve time and date from DS3231\n\n      {\n\n      I2CstartWait(0xD0);            // DS3231 write\n\n      I2Cwrite(0x00);                // Seconds register\n\n      I2CstartWait(0xD1);            // DS3231 read\n\n      seconds = bcdToDec(I2CreadACK());\n\n      minutes = bcdToDec(I2CreadACK());\n\n      hours = bcdToDec(I2CreadACK());\n\n      dow = bcdToDec(I2CreadACK());\n\n      dom = bcdToDec(I2CreadACK());\n\n      mo = bcdToDec(I2CreadACK());\n\n      years = bcdToDec(I2CreadACK());\n\n      }\n\n      void commandLCD(uint8_t _command)\n\n      {\n\n      // Takes command byte and sends upper nibble, lower nibble to LCD\n\n      PORTD = (PORTD & 0x0F) | (_command & 0xF0);\n\n      PORTD &= ~(1<<PD0);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_us(200);\n\n      PORTD = (PORTD & 0x0F) | (_command << 4);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_ms(2);\n\n      }\n\n      void initLCD()\n\n      {\n\n      DDRD = 0b11111111;\n\n      _delay_ms(100);\n\n      commandLCD(0x02);\n\n      commandLCD(0x28);\n\n      commandLCD(0x0C);\n\n      commandLCD(0x06);\n\n      commandLCD(0x01);\n\n      _delay_ms(2);\n\n      }\n\n      void clearLCD()\n\n      {\n\n      commandLCD (0x01);\n\n      _delay_ms(2);\n\n      commandLCD (0x80);\n\n      _delay_ms(2);\n\n      }\n\n      void printLCD(char *_string)\n\n      {\n\n      uint8_t i;\n\n      for(i=0; _string[i]!=0; i++)\n\n      {\n\n      PORTD = (PORTD & 0x0F) | (_string[i] & 0xF0);\n\n      PORTD |= (1<<PD0);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_us(200);\n\n      PORTD = (PORTD & 0x0F) | (_string[i] << 4);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_ms(2);\n\n      }\n\n      }\n\n      void cursorLCD(uint8_t column, uint8_t row)\n\n      // Move cursor to desired column (0–15), row (0–1)\n\n      {\n\n      if (row == 0 && column<16)\n\n      {\n\n      commandLCD((column & 0x0F)|0x80);\n\n      }\n\n      else if (row == 1 && column<16)\n\n      {\n\n      commandLCD((column & 0x0F)|0xC0);\n\n      }\n\n      }\n\n      int main()\n\n      {\n\n      initLCD();\n\n      I2Cenable();\n\n      char numbers[9];\n\n      // Uncomment to set time and date, then comment and reflash code\n\n      ❶ // setTimeDS3231(8,50,0,3,16,6,21); // h, m, s, dow, dom, m, y\n\n      while(1)\n\n      {\n\n      ❷ readTimeDS3231();\n\n      ❸ itoa(hours,numbers,10);          // Hours\n\n      cursorLCD(4,0);\n\n      ❹ if (hours==0)\n\n      {\n\n      printLCD(\"00\");\n\n      ❺ } else if (hours>0 && hours <10)\n\n      {\n\n      printLCD(\"0\");\n\n      printLCD(numbers);\n\n      } else if (hours>=10)\n\n      {\n\n      printLCD(numbers);\n\n      }\n\n      cursorLCD(6,0);\n\n      printLCD(\":\");\n\n      itoa(minutes,numbers,10);        // Minutes\n\n      cursorLCD(7,0);\n\n      if (minutes==0)\n\n      {\n\n      printLCD(\"00\");\n\n      } else if (minutes>0 && minutes <10)\n\n      {\n\n      printLCD(\"0\");\n\n      printLCD(numbers);\n\n      } else if (minutes>=10)\n\n      {\n\n      printLCD(numbers);\n\n      }\n\n      cursorLCD(0,9);\n\n      printLCD(\":\");\n\n      itoa(seconds,numbers,10);        // Seconds\n\n      cursorLCD(10,0);\n\n      if (seconds==0)\n\n      {\n\n      printLCD(\"00\");\n\n      } else if (seconds>0 && seconds <10)\n\n      {\n\n      printLCD(\"0\");\n\n      printLCD(numbers);\n\n      } else if (seconds>=10)\n\n      {\n\n      printLCD(numbers);\n\n      }\n\n      cursorLCD(2,1);                  // Day of week\n\n      ❻ switch(dow)\n\n      {\n\n      case 1 : printLCD(\"Mon\"); break;\n\n      case 2 : printLCD(\"Tue\"); break;\n\n      case 3 : printLCD(\"Wed\"); break;\n\n      case 4 : printLCD(\"Thu\"); break;\n\n      case 5 : printLCD(\"Fri\"); break;\n\n      case 6 : printLCD(\"Sat\"); break;\n\n      case 7 : printLCD(\"Sun\"); break;\n\n      }\n\n      itoa(dom,numbers,10);            // Day of month\n\n      cursorLCD(6,1);\n\n      if (dom<10)\n\n      {\n\n      printLCD(\"0\");\n\n      }\n\n      printLCD(numbers);\n\n      cursorLCD(8,1);\n\n      printLCD(\"/\");\n\n      itoa(mo,numbers,10);             // Month\n\n      cursorLCD(9,1);\n\n      if (mo<10)\n\n      {\n\n      printLCD(\"0\");\n\n      }\n\n      printLCD(numbers);\n\n      cursorLCD(11,1);\n\n      printLCD(\"/\");\n\n      itoa(years,numbers,10);          // Year\n\n      cursorLCD(12,1);\n\n      printLCD(numbers);\n\n      ❼ _delay_ms(900);\n\n      clearLCD();                      // Refresh LCD\n\n      }\n\n      }\n\n```", "```\n\n     int main()\n\n     {\n\n     ❶ float a = 1.2345678;\n\n     float b = 12345.678;\n\n     ❷ char displayNumber[10];\n\n     ❸ initLCD();\n\n     while(1)\n\n     {\n\n     ❹ cursorLCD(0,0);\n\n     ❺ dtostrf(a,9,7, displayNumber);\n\n     printLCD(displayNumber);\n\n     cursorLCD(0,1);\n\n     ❻ dtostrf(b,9,3, displayNumber);\n\n     printLCD(displayNumber);\n\n     _delay_ms(1000);\n\n     }\n\n     }\n\n```", "```\n\n      // Project 54 - LCD Digital Thermometer with Min/Max Display\n\n      #include <avr/io.h>\n\n      #include <util/delay.h>\n\n      #include <stdlib.h>\n\n      #include <math.h>\n\n      ❶ void startADC()\n\n      // Set up the ADC\n\n      {\n\n      ADMUX |= (1 << REFS0);              // Use AVcc pin with ADC\n\n      ADMUX |= (1 << MUX2) | (1 << MUX0); // Use ADC5 (pin 28)\n\n      // Prescaler for 16MHz (/128)\n\n      ❷ ADCSRA |= (1 << ADPS2) |(1 << ADPS1) | (1 << ADPS0);\n\n      ADCSRA |= (1 << ADEN);              // Enable ADC\n\n      }\n\n      void commandLCD(uint8_t _command)\n\n      {\n\n      PORTD = (PORTD & 0x0F) | (_command & 0xF0);\n\n      PORTD &= ~(1<<PD0);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_us(200);\n\n      PORTD = (PORTD & 0x0F) | (_command << 4);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_ms(2);\n\n      }\n\n      void initLCD()\n\n      {\n\n      DDRD = 0b11111111;\n\n      _delay_ms(100);\n\n      commandLCD(0x02);\n\n      commandLCD(0x28);\n\n      commandLCD(0x0C);\n\n      commandLCD(0x06);\n\n      commandLCD(0x01);\n\n      _delay_ms(2);\n\n      }\n\n      void clearLCD()\n\n      {\n\n      commandLCD (0x01);\n\n      _delay_ms(2);\n\n      commandLCD (0x80);\n\n      _delay_ms(2);\n\n      }\n\n      void printLCD(char *_string)\n\n      {\n\n      uint8_t i;\n\n      for(i=0; _string[i]!=0; i++)\n\n      {\n\n      PORTD = (PORTD & 0x0F) | (_string[i] & 0xF0);\n\n      PORTD |= (1<<PD0);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_us(200);\n\n      PORTD = (PORTD & 0x0F) | (_string[i] << 4);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_ms(2);\n\n      }\n\n      }\n\n      void cursorLCD(uint8_t column, uint8_t row)\n\n      // Move cursor to desired column (0–15), row (0–1)\n\n      {\n\n      if (row == 0 && column<16)\n\n      {\n\n      commandLCD((column & 0x0F)|0x80);\n\n      }\n\n      else if (row == 1 && column<16)\n\n      {\n\n      commandLCD((column & 0x0F)|0xC0);\n\n      }\n\n      }\n\n      int main()\n\n      {\n\n      DDRC = 0b00000000;                // Set PORTC as inputs\n\n      startADC();\n\n      initLCD();\n\n      char numbers[9];\n\n      float temperature;\n\n      float voltage;\n\n      float average;\n\n      ❸ float minimum = -273;             // Needs an initial value\n\n      float maximum;\n\n      uint16_t ADCvalue;\n\n      while(1)\n\n      {\n\n      ❹ // Take reading from TMP36 via ADC\n\n      ADCSRA |= (1 << ADSC);         // Start ADC measurement\n\n      while (ADCSRA & (1 << ADSC) ); // Wait for conversion\n\n      _delay_ms(10);\n\n      // Get value from ADC (which is 10-bit) register\n\n      ADCvalue = ADC;\n\n      // Convert reading to temperature value (Celsius)\n\n      voltage = (ADCvalue * 5);\n\n      voltage = voltage / 1024;\n\n      ❺ temperature = ((voltage - 0.5) * 100);\n\n      // Min/max and average\n\n      ❻ if (temperature < minimum)\n\n      {\n\n      minimum = temperature;\n\n      }\n\n      if (temperature > maximum)\n\n      {\n\n      maximum = temperature;\n\n      }\n\n      ❼ average = ((minimum+maximum)/2);\n\n      ❽ // Display information\n\n      cursorLCD(0,0);\n\n      printLCD(\"Current:\");\n\n      dtostrf(temperature,6,2,numbers);\n\n      printLCD(numbers);\n\n      cursorLCD(15,0);\n\n      printLCD(\"C\");\n\n      cursorLCD(0,1);\n\n      printLCD(\"Average:\");\n\n      dtostrf(average,6,2,numbers);\n\n      printLCD(numbers);\n\n      cursorLCD(15,1);\n\n      printLCD(\"C\");\n\n      _delay_ms(1000);\n\n      clearLCD();\n\n      cursorLCD(0,0);\n\n      printLCD(\"Minimum:\");\n\n      dtostrf(minimum,6,2,numbers);\n\n      printLCD(numbers);\n\n      cursorLCD(15,0);\n\n      printLCD(\"C\");\n\n      cursorLCD(0,1);\n\n      printLCD(\"Maximum:\");\n\n      dtostrf(maximum,6,2,numbers);\n\n      printLCD(numbers);\n\n      cursorLCD(15,1);\n\n      printLCD(\"C\");\n\n      _delay_ms(1000);\n\n      clearLCD();\n\n      }\n\n      }\n\n```", "```\n\n     uint8_t smiley[] = {27,27,0,4,0,17,10,4};\n\n```", "```\n\n      void writeLCD(uint8_t _data)\n\n      {\n\n      PORTD |= (1<<PD0); // RS high\n\n      PORTD = (PORTD & 0x0F) | (_data & 0xF0);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_us(200);\n\n      PORTD = (PORTD & 0x0F) | (_data);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_ms(2);\n\n      }\n\n```", "```\n\n      void createCC(uint8_t ccdata[], uint8_t slot)\n\n      {\n\n      uint8_t x;\n\n      ❶ commandLCD(0x40+(slot*8)); // Select character memory (0-7)\n\n      for (x = 0; x<8; x++)\n\n      {\n\n      ❷ writeLCD(ccdata[x]<<4);\n\n      }\n\n      }\n\n```", "```\n\n      void printCCLCD(uint8_t slot)\n\n      {\n\n      PORTD = (PORTD & 0x0F) | (slot & 0xF0);\n\n      PORTD |= (1<<PD0);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_us(200);\n\n      PORTD = (PORTD & 0x0F) | (slot << 4);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_ms(2);\n\n      }\n\n```", "```\n\n      // Project 55 - Displaying Custom LCD Characters\n\n      #include <avr/io.h>\n\n      #include <util/delay.h>\n\n      uint8_t ch0[] = {14,10,14,10,0,31,21,21};  // \"AM\"\n\n      uint8_t ch1[] = {14,10,14,8,0,31,21,21};   // \"PM\"\n\n      uint8_t ch2[] = {4,31,17,17,17,31,31,31};  // \"Battery\"\n\n      uint8_t ch3[] = {10,21,17,10,4,0,0,0};     // \"Heart\"\n\n      uint8_t ch4[] = {4,4,31,4,4,0,31,0};       // \"+ -\"\n\n      uint8_t ch5[] = {27,27,0,4,0,17,10,4};     // \"Happy face\"\n\n      uint8_t ch6[] = {17,10,17,4,4,0,14,17};    // \"Sad face\"\n\n      uint8_t ch7[] = {21,10,21,10,21,10,21,10}; // \"Pattern\"\n\n      ❶ void writeLCD(uint8_t _data)\n\n      // Used for writing to CGRAM\n\n      {\n\n      PORTD |= (1<<PD0); // RS high\n\n      PORTD = (PORTD & 0x0F) | (_data & 0xF0);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_us(200);\n\n      PORTD = (PORTD & 0x0F) | (_data);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_ms(2);\n\n      }\n\n      ❷ void commandLCD(uint8_t _command)\n\n      {\n\n      PORTD = (PORTD & 0x0F) | (_command & 0xF0);\n\n      PORTD &= ~(1<<PD0);                     // RS low\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_us(200);\n\n      PORTD = (PORTD & 0x0F) | (_command << 4);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_ms(2);\n\n      }\n\n      ❸ void createCC(uint8_t ccdata[], uint8_t slot)\n\n      // Sends custom character data to LCD\n\n      {\n\n      uint8_t x;\n\n      commandLCD(0x40+(slot*8));              // Select character memory (0–7)\n\n      for (x = 0; x<8; x++)\n\n      {\n\n      writeLCD(ccdata[x]<<4);\n\n      }\n\n      }\n\n      ❹ void printCCLCD(uint8_t slot)\n\n      {\n\n      PORTD = (PORTD & 0x0F) | (slot & 0xF0);\n\n      PORTD |= (1<<PD0);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_us(200);\n\n      PORTD = (PORTD & 0x0F) | (slot << 4);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_ms(2);\n\n      }\n\n      void initLCD()\n\n      {\n\n      DDRD = 0b11111111;\n\n      _delay_ms(100);\n\n      commandLCD(0x02);\n\n      commandLCD(0x28);\n\n      commandLCD(0x0C);\n\n      commandLCD(0x06);\n\n      commandLCD(0x01);\n\n      _delay_ms(2);\n\n      }\n\n      void clearLCD()\n\n      {\n\n      commandLCD (0x01);\n\n      _delay_ms(2);\n\n      commandLCD (0x80);\n\n      _delay_ms(2);\n\n      }\n\n      void printLCD(char *_string)\n\n      {\n\n      uint8_t i;\n\n      for(i=0; _string[i]!=0; i++)\n\n      {\n\n      PORTD = (PORTD & 0x0F) | (_string[i] & 0xF0);\n\n      PORTD |= (1<<PD0);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_us(200);\n\n      PORTD = (PORTD & 0x0F) | (_string[i] << 4);\n\n      PORTD |= (1<<PD1);\n\n      _delay_us(1);\n\n      PORTD &= ~(1<<PD1);\n\n      _delay_ms(2);\n\n      }\n\n      }\n\n      void cursorLCD(uint8_t column, uint8_t row)\n\n      // Move cursor to desired column (0–15), row (0–1)\n\n      {\n\n      if (row == 0 && column<16)\n\n      {\n\n      commandLCD((column & 0x0F)|0x80);\n\n      }\n\n      else if (row == 1 && column<16)\n\n      {\n\n      commandLCD((column & 0x0F)|0xC0);\n\n      }\n\n      }\n\n      int main()\n\n      {\n\n      initLCD();\n\n      while(1)\n\n      {\n\n      ❺ createCC(ch0,0); // \"AM\"\n\n      createCC(ch1,1); // \"PM\"\n\n      createCC(ch2,2); // \"Battery\"\n\n      createCC(ch3,3); // \"Heart\"\n\n      createCC(ch4,4); // \"+ -\"\n\n      createCC(ch5,5); // \"Happy face\"\n\n      createCC(ch6,6); // \"Sad face\"\n\n      createCC(ch7,7); // \"Pattern\"\n\n      ❻ cursorLCD(0,0);\n\n      printCCLCD(0);\n\n      cursorLCD(2,0);\n\n      printCCLCD(1);\n\n      cursorLCD(4,0);\n\n      printCCLCD(2);\n\n      cursorLCD(6,0);\n\n      printCCLCD(3);\n\n      cursorLCD(8,0);\n\n      printCCLCD(4);\n\n      cursorLCD(10,0);\n\n      printCCLCD(5);\n\n      cursorLCD(12,0);\n\n      printCCLCD(6);\n\n      cursorLCD(14,0);\n\n      printCCLCD(7);\n\n      _delay_ms(1000);\n\n      clearLCD();\n\n      }\n\n      }\n\n```"]