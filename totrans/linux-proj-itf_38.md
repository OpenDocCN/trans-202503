## 第三十八章 编写安全的特权程序

特权程序可以访问普通用户无法访问的功能和资源（文件、设备等）。程序可以通过两种方式之一运行特权：

+   程序在特权用户 ID 下启动。许多守护进程和网络服务器，通常以*root*身份运行，属于这一类。

+   程序设置了用户标识符（set-user-ID）或组标识符（set-group-ID）权限位。当一个设置了用户标识符（set-user-ID）或组标识符（set-group-ID）的程序被执行时，它会将进程的有效用户（组）ID 更改为与程序文件的所有者（组）相同。（我们在第 9.3 节首次描述了设置用户标识符和组标识符程序。）在本章中，我们有时会使用“set-user-ID-*root*”这个术语，来区分一个赋予进程超级用户权限的 set-user-ID 程序与赋予进程其他有效身份的程序。

如果一个特权程序存在漏洞，或者能被恶意用户破坏，那么系统或应用程序的安全性可能会受到威胁。从安全的角度来看，我们应该编写程序以最小化被攻击的可能性，并减少如果发生攻击时可能造成的损害。本章的内容就是关于这一主题，提供了一套安全编程的推荐实践，并描述了在编写特权程序时应该避免的各种陷阱。

## 是否需要设置用户标识符或组标识符程序？

关于设置用户标识符和组标识符程序的最佳建议之一是尽可能避免编写它们。如果有其他方式可以执行某个任务，而不涉及给予程序特权，那么我们通常应该选择这种替代方式，因为它消除了安全漏洞的可能性。

有时，我们可以将需要特权的功能隔离到一个独立的程序中，该程序执行单一任务，并在需要时在子进程中执行该程序。这种技术对于库特别有用。一个这样的用法示例由*pt_chown*程序提供，该程序在改变从属设备的所有权和权限：*grantpt()*")中进行了描述。

即使需要设置用户标识符（set-user-ID）或组标识符（set-group-ID），也并不总是需要将进程的身份设置为*root*。如果仅需要其他凭据来执行某个任务，那么应该优先选择这种方式，因为以*root*权限运行程序可能会导致安全漏洞。

考虑一个需要允许用户更新他们没有写权限的文件的设置用户 ID 程序。更安全的做法是为该程序创建一个专门的用户组账户（组 ID），将文件的组所有权更改为该组（并使该组具有写权限），然后编写一个设置组 ID 的程序，将进程的有效组 ID 设置为专门的组 ID。由于专门的组 ID 没有其他特权，这大大限制了如果程序存在 bug 或者被篡改时可能造成的损害。

## 最小特权操作

设置用户 ID（或设置组 ID）程序通常只在执行某些操作时需要特权。当程序（尤其是需要超级用户特权的程序）执行其他工作时，它应该禁用这些特权。当特权再也不需要时，它们应该被永久放弃。换句话说，程序应该始终以完成当前任务所需的*最小特权*运行。保存的设置用户 ID 功能就是为此目的而设计的（保存的设置用户 ID 和保存的设置组 ID）。

#### 仅在需要时持有特权

在设置用户 ID 程序中，我们可以使用以下 *seteuid()* 调用序列来暂时放弃然后重新获得特权：

```
uid_t orig_euid;

orig_euid = geteuid();
if (seteuid(getuid()) == -1)            /* Drop privileges */
    errExit("seteuid");

/* Do unprivileged work */

if (seteuid(orig_euid) == -1)           /* Reacquire privileges */
    errExit("seteuid");

/* Do privileged work */
```

第一个调用使调用进程的有效用户 ID 与其真实 ID 相同。第二个调用将有效用户 ID 恢复为保存的设置用户 ID 中的值。

对于设置组 ID 程序，保存的设置组 ID 保存程序最初的有效组 ID，*setegid()* 用于放弃并重新获得特权。我们在第九章中描述了 *seteuid()*、*setegid()* 以及以下建议中提到的其他类似系统调用，并在表 9-1 中总结了它们（在示例：显示进程凭证中）。

最安全的做法是在程序启动时立即放弃特权，然后在程序的后续部分根据需要临时重新获得它们。如果在某个时刻特权再也不需要了，那么程序应该通过确保保存的设置用户 ID 也被更改来永久放弃特权。这消除了程序可能通过栈溢出技术（如第 38.9 节所述）被欺骗重新获得特权的可能性。

#### 当特权再也不需要时，永久放弃它们

如果一个设置用户 ID 或设置组 ID 程序完成了所有需要特权的任务，那么它应当永久丢弃其特权，以消除任何可能发生的安全风险，这些风险可能源自程序因错误或其他意外行为被攻破。永久丢弃特权是通过将所有进程的用户（组）ID 重置为与真实（组）ID 相同的值来实现的。

从一个有效用户 ID 当前为 0 的设置用户 ID 为 *root* 的程序中，我们可以使用以下代码重置所有用户 ID：

```
if (setuid(getuid()) == -1)
    errExit("setuid");
```

然而，上述代码*并没有*重置保存的设置用户 ID，如果调用进程的有效用户 ID 当前为非零：当从有效用户 ID 非零的程序调用时，*setuid()* 仅更改有效用户 ID（获取和修改真实、有效和保存的 ID）。换句话说，在设置用户 ID 为 *root* 的程序中，以下序列并不会永久丢弃用户 ID 0：

```
/* Initial UIDs:    real=1000 effective=0 saved=0 */

/* 1\. Usual call to temporarily drop privilege */

orig_euid = geteuid();
if (seteuid(getuid() == -1)
    errExit("seteuid");

/* UIDs changed to: real=1000 effective=1000 saved=0 */

/* 2\. Looks like the right way to permanently drop privilege (WRONG!) */

if (setuid(getuid() == -1)
    errExit("setuid");

/* UIDs unchanged:  real=1000 effective=1000 saved=0 */
```

相反，我们必须在永久丢弃特权之前重新获得特权，通过在上述步骤 1 和步骤 2 之间插入以下调用：

```
if (seteuid(orig_euid) == -1)
    errExit("seteuid");
```

另一方面，如果我们有一个由 *root* 以外的用户拥有的设置用户 ID 程序，则由于 *setuid()* 不足以更改保存的设置用户 ID，我们必须使用 *setreuid()* 或 *setresuid()* 来永久丢弃特权标识符。例如，我们可以使用 *setreuid()* 来实现预期结果，如下所示：

```
if (setreuid(getuid(), getuid()) == -1)
    errExit("setreuid");
```

这段代码依赖于 Linux 实现中 *setreuid()* 的一个特性：如果第一个（*ruid*）参数不是 -1，那么保存的设置用户 ID 也会被设置为与（新的）有效用户 ID 相同的值。SUSv3 没有指定这一特性，但许多其他实现与 Linux 的行为相同。SUSv4 确实指定了这一特性。

*setregid()* 或 *setresgid()* 系统调用同样需要在设置组 ID 程序中使用，以永久丢弃特权组 ID，因为当程序的有效用户 ID 非零时，*setgid()* 仅更改调用进程的有效组 ID。

#### 关于更改进程凭证的通用点

在前面的页面中，我们描述了暂时和永久丢弃特权的技巧。现在，我们补充一些关于这些技巧使用的通用点：

+   一些更改进程凭证的系统调用的语义在不同系统之间有所不同。此外，这些系统调用的语义还取决于调用者是否具有特权（有效用户 ID 为 0）。有关详细信息，请参见第九章，尤其是修改进程凭证的系统调用总结。由于这些差异，[Tsafrir 等人，2008] 建议应用程序应使用特定于系统的 *非标准* 系统调用来更改进程凭证，因为在许多情况下，这些非标准的系统调用提供了比标准调用更简洁且一致的语义。在 Linux 上，这意味着使用 *setresuid()* 和 *setresgid()* 来更改用户和组凭证。虽然这些系统调用并非所有系统都有，但它们的使用可能会更不容易出错。（[Tsafrir 等人，2008] 提出了一个函数库，使用他们认为每个平台上最佳的接口来进行凭证更改。）

+   在 Linux 上，即使调用者的有效用户 ID 为 0，如果程序显式地修改了其权限，系统调用用于更改凭证时可能不会按预期行为执行。例如，如果禁用了 `CAP_SETUID` 能力，则尝试更改进程用户 ID 会失败，或者更糟糕的是，只会悄悄地更改部分请求的用户 ID。

+   由于前面提到的两点中的可能性，强烈推荐的做法是（例如，参见 [Tsafrir 等人，2008]）不仅要检查凭证更改的系统调用是否成功，还要验证更改是否按预期发生。例如，如果我们暂时丢弃或重新获取特权用户 ID 使用 *seteuid()*，则应该紧接着调用 *geteuid()* 来验证有效用户 ID 是否如预期所示。类似地，如果我们永久丢弃特权用户 ID，那么我们应该验证实际用户 ID、有效用户 ID 和已保存的用户 ID 是否都已成功更改为非特权用户 ID。不幸的是，虽然有标准的系统调用来检索实际和有效的 ID，但没有标准的系统调用来检索已保存的用户 ID。Linux 和一些其他系统提供了 *getresuid()* 和 *getresgid()* 来实现此目的；在某些其他系统中，我们可能需要使用诸如解析 `/proc` 文件中的信息等技术。

+   一些凭证更改只能由有效用户 ID 为 0 的进程执行。因此，在更改多个 ID（附加组 ID、组 ID 和用户 ID）时，我们应在丢弃特权 ID 时最后丢弃特权有效用户 ID。相反，在提升特权 ID 时，我们应首先提升特权有效用户 ID。

## 执行程序时要小心

当特权程序执行另一个程序时，无论是直接通过*exec()*，还是间接通过*system()*、*popen()*或类似的库函数，都需要小心。

#### 在执行另一个程序之前永久丢弃权限

如果一个设置用户 ID（或设置组 ID）程序执行另一个程序，则它应该确保所有进程的用户（组）ID 被重置为与真实用户（组）ID 相同的值，以便新程序不会带有特权启动，也无法重新获得特权。实现此目的的一种方法是，在执行*exec()*之前重置所有 ID，使用第 38.2 节中描述的技术。

通过在*exec()*之前调用*setuid(getuid())*，可以实现相同的结果。即使这个*setuid()*调用仅改变了有效用户 ID，而该进程的有效用户 ID 非零，权限仍然会被丢弃，因为（如保存的设置用户 ID 和保存的设置组 ID 中所述）成功的*exec()*会将有效用户 ID 复制到保存的设置用户 ID 中。（如果*exec()*失败，保存的设置用户 ID 将保持不变。如果程序随后需要执行其他特权工作，这可能会有用，因为*exec()*失败了。）

类似的方法（即*setgid(getgid())*）可以用于设置组 ID 程序，因为成功的*exec()*也会将有效的组 ID 复制到保存的设置组 ID。

例如，假设我们有一个由用户 ID 200 拥有的设置用户 ID 程序。当该程序由用户 ID 为 1000 的用户执行时，生成的进程的用户 ID 将如下所示：

```
real=1000 effective=200 saved=200
```

如果该程序随后执行*setuid(getuid())*调用，则进程用户 ID 将被更改为以下内容：

```
real=1000 effective=1000 saved=200
```

当该进程执行一个非特权程序时，进程的有效用户 ID 将被复制到保存的设置用户 ID 中，从而导致以下的进程用户 ID：

```
real=1000 effective=1000 saved=1000
```

#### 避免以特权身份执行 shell（或其他解释器）

在用户控制下运行的特权程序永远不应该直接或间接地执行 shell（通过*system()*、*popen()*、*execlp()*、*execvp()*或其他类似的库函数）。由于 shell（以及其他不受限制的解释器，如*awk*）的复杂性和强大功能，几乎不可能消除所有安全漏洞，即使被执行的 shell 不允许交互式访问。由此带来的风险是，用户可能能够在该进程的有效用户 ID 下执行任意的 shell 命令。如果必须执行 shell，请确保在此之前已经永久丢弃了权限。

### 注意

在第 27.6 节讨论的*system()*中，提到了一种可能发生的执行 shell 时的安全漏洞。

一些 UNIX 实现会在应用于解释器脚本时尊重设置用户 ID 和设置组 ID 的权限位（解释器脚本），这样，在运行脚本时，执行脚本的进程将假定某个其他（特权）用户的身份。由于前面描述的安全风险，Linux 像一些其他 UNIX 实现一样，在执行脚本时会默默忽略设置用户 ID 和设置组 ID 的权限位。即使在允许设置用户 ID 和设置组 ID 脚本的实现中，也应避免使用这些脚本。

#### 在*exec()*之前关闭所有不必要的文件描述符

在文件描述符和*exec()*")中，我们提到，默认情况下，文件描述符会在*exec()*调用时保持打开状态。特权程序可能会打开一个普通进程无法访问的文件。由此产生的打开文件描述符代表了一个特权资源。文件描述符应该在*exec()*之前关闭，以便被 exec 的程序无法访问相关文件。我们可以通过显式关闭文件描述符，或者通过设置其 close-on-exec 标志来做到这一点（文件描述符和*exec()*")）。

## 避免暴露敏感信息

当程序读取密码或其他敏感信息时，应执行所需的处理，然后立即从内存中删除这些信息。（在第 8.5 节中我们展示了一个示例。）将这些信息保留在内存中存在安全风险，原因如下：

+   包含数据的虚拟内存页面可能会被交换出去（除非它通过*mlock()*或类似方式锁定在内存中），然后可能会被特权程序从交换区读取。

+   如果进程接收到一个信号，导致其生成一个核心转储文件，那么该文件可能会被读取以获取相关信息。

根据上面提到的内容，作为一般原则，一个安全的程序应该防止核心转储，以确保无法通过核心转储文件检查到敏感信息。程序可以通过使用*setrlimit()*将`RLIMIT_CORE`资源限制设置为`0`来确保不会创建核心转储文件（见特定资源限制的详细信息）。

### 注意

默认情况下，Linux 不允许设置用户 ID 的程序在接收到信号时执行核心转储（核心转储文件），即使该程序已经丧失了所有特权。然而，其他 UNIX 实现可能没有提供此安全功能。

## 限制进程范围

在本节中，我们考虑通过哪些方式可以限制程序，从而在程序被破坏时减少所造成的损害。

#### 考虑使用能力

Linux 的能力机制将传统的全有或全无的 UNIX 权限机制划分为不同的单元，称为*能力*。进程可以独立地启用或禁用各个能力。通过仅启用其所需的那些能力，程序运行时的权限比使用完整*root*权限时要低。这减少了程序被破坏时可能造成的损害。

此外，通过使用能力和*securebits*标志，我们可以创建一个具有有限能力集但不是由*root*拥有的进程（即，其所有用户 ID 都为非零）。这样的进程将无法再使用*exec()*恢复完整的能力集。我们在第三十九章中描述了能力和*securebits*标志。

#### 考虑使用*chroot*监狱

在某些情况下，一种有用的安全技术是建立一个*chroot*监狱，以限制程序可以访问的目录和文件集合。（确保还调用*chdir()*，将进程的当前工作目录更改为监狱内的一个位置。）然而，请注意，*chroot*监狱不足以限制一个设有用户 ID-*root*的程序（参见改变进程的根目录：*chroot()*")）。

### 注意

使用*chroot*监狱的替代方法是*虚拟服务器*，它是在虚拟内核上实现的服务器。由于每个虚拟内核与可能在同一硬件上运行的其他虚拟内核隔离，因此虚拟服务器比*chroot*监狱更安全、更灵活。（其他一些现代操作系统也提供了自己的虚拟服务器实现。）Linux 上最早的虚拟化实现是用户模式 Linux（UML），它是 Linux 2.6 内核的标准部分。有关 UML 的更多信息，请访问[`user-mode-linux.sourceforge.net/`](http://user-mode-linux.sourceforge.net/)。更现代的虚拟内核项目包括 Xen（[`www.cl.cam.ac.uk/Research/SRG/netos/xen/`](http://www.cl.cam.ac.uk/Research/SRG/netos/xen/)）和 KVM（[`kvm.qumranet.com/`](http://kvm.qumranet.com/)）。

## 当心信号和竞争条件

用户可能会向他们启动的设有用户 ID 的程序发送任意信号。这些信号可能会在任何时间、以任何频率到达。我们需要考虑在程序执行的*任何*时刻发送信号可能导致的竞争条件。在适当的情况下，应该捕获、阻塞或忽略信号，以防止可能的安全问题。此外，信号处理程序的设计应尽可能简单，以减少无意中产生竞争条件的风险。

这个问题在停止进程的信号（例如，`SIGTSTP`和`SIGSTOP`）中尤为相关。问题场景如下：

1.  一个设置用户 ID 的程序决定了其运行时环境的某些信息。

1.  用户能够停止运行该程序的进程，并更改运行时环境的细节。这些更改可能包括修改文件的权限、改变符号链接的目标，或删除程序依赖的文件。

1.  用户通过`SIGCONT`信号恢复进程。此时，程序将继续执行，但基于关于其运行时环境的错误假设，这些假设可能导致安全漏洞。

这里描述的情况实际上只是一个*检查时间*、*使用时间*竞态条件的特殊情况。特权进程应避免基于之前验证的操作，因为这些验证可能不再有效（具体示例请参见检查文件可访问性：*access()*")中对*access()*系统调用的讨论）。即使用户无法向进程发送信号，这条指南仍然适用。停止一个进程的能力仅仅是让用户能够延长检查时间和使用时间之间的间隔。

### 注意

尽管在一次尝试中很难在检查时间和使用时间之间停止一个进程，但恶意用户可以反复执行设置用户 ID 的程序，并使用其他程序或 shell 脚本反复发送停止信号给设置用户 ID 的程序，改变其运行时环境。这大大增加了颠覆该设置用户 ID 程序的可能性。

## 执行文件操作和文件 I/O 时的陷阱

如果一个特权进程需要创建一个文件，那么我们必须注意该文件的所有权和权限，以确保在任何时候，即使是短暂的，文件也不会被恶意操控。以下指南适用：

+   进程的 umask（进程文件模式创建掩码：*umask()*")）应设置为一个确保进程永远不会创建公开可写文件的值，因为这些文件可能会被恶意用户修改。

+   由于文件的所有权是由创建进程的有效用户 ID 获取的，因此可能需要谨慎使用*seteuid()*或*setreuid()*来临时更改进程凭据，以确保新创建的文件不会归属于错误的用户。由于文件的组所有权*可能*由进程的有效组 ID 获取（参见新文件的所有权），对于设置组 ID 的程序也适用类似的说明，且可以使用相应的组 ID 调用来避免此类问题。（严格来说，在 Linux 上，新文件的所有者是由进程的文件系统用户 ID 确定的，通常该 ID 的值与进程的有效用户 ID 相同；请参阅第 9.5 节。）

+   如果一个设置用户 ID 为 *root* 的程序必须创建一个最初由它拥有的文件，但最终将由其他用户拥有，那么该文件应创建为最初不可被其他用户写入，无论是通过使用合适的*mode*参数来调用*open()*，还是通过在调用*open()*之前设置进程的 umask。之后，程序可以使用*fchown()*更改文件所有权，并在必要时使用*fchmod()*更改文件权限。关键点是，设置用户 ID 的程序应该确保它永远不会创建一个由程序所有者拥有的文件，且该文件即使是短暂地可供其他用户写入。

+   应该在打开的文件描述符上执行文件属性检查（例如，*open()* 后跟 *fstat()*），而不是通过检查与路径名关联的属性后再打开文件（例如，*stat()* 后跟 *open()*）。后一种方法会引发使用时与检查时的时间问题。

+   如果一个程序必须确保它是文件的创建者，那么在调用*open()*时应该使用`O_EXCL`标志。

+   特权程序应避免在公开可写的目录（如`/tmp`）中创建或依赖文件，因为这会使程序容易受到恶意攻击，创建未经授权的文件，且这些文件的名称会被特权程序所预期。必须在公开可写的目录中创建文件的程序，至少应确保文件名不可预测，可以使用诸如*mkstemp()*的函数（参见创建临时文件）。

## 不要信任输入或环境。

特权程序应避免对其接收到的输入或运行环境做出假设。

#### 不要信任环境列表。

设置用户 ID 和设置组 ID 的程序不应假设环境变量的值是可靠的。两个特别相关的变量是`PATH`和`IFS`。

`PATH` 确定 shell（以及 *system()* 和 *popen()*），以及 *execlp()* 和 *execvp()*，搜索程序的位置。恶意用户可以将 `PATH` 设置为一个可能会欺骗一个使用这些函数的 set-user-ID 程序，从而使其以特权身份执行任意程序。如果要使用这些函数，`PATH` 应该设置为一个可信的目录列表（但更好的做法是，执行程序时指定绝对路径）。然而，如前所述，最好在执行 shell 或使用上述函数之前先放弃特权。

`IFS` 指定 shell 解释为分隔命令行单词的定界字符。该变量应设置为空字符串，这意味着只有空白字符会被 shell 解释为单词分隔符。一些 shell 在启动时始终以这种方式设置 `IFS`。(执行 Shell 命令：*system()*") 介绍了一个关于 `IFS` 的漏洞，该漏洞出现在早期的 Bourne shell 中。)

在某些情况下，最安全的做法是清除整个环境变量列表（环境变量列表），然后使用已知安全值恢复选定的环境变量，特别是在执行可能会受到环境变量设置影响的其他程序或调用库时。

#### 防御性地处理不可信的用户输入

特权程序应在根据来自不可信来源的输入采取行动之前，仔细验证所有输入。这种验证可能包括检查数字是否在可接受的范围内，字符串是否具有可接受的长度，并且由可接受的字符组成。需要以这种方式验证的输入包括来自用户创建的文件、命令行参数、交互式输入、CGI 输入、电子邮件消息、环境变量、不可信用户可访问的进程间通信通道（如 FIFO、共享内存等）和网络数据包。

#### 避免对进程的运行时环境做出不可靠的假设

set-user-ID 程序应避免对其初始运行时环境做出不可靠的假设。例如，标准输入、输出或错误可能已经被关闭。（这些描述符可能在执行 set-user-ID 程序的程序中已经关闭。）在这种情况下，打开文件可能会无意中重用描述符 1（例如），因此，程序虽然认为它正在写入标准输出，但实际上它是在写入它打开的文件。

还有许多其他的可能性需要考虑。例如，某个进程可能会耗尽各种资源限制，例如可创建的进程数量限制、CPU 时间资源限制或文件大小资源限制，从而导致某些系统调用失败或生成各种信号。恶意用户可能会故意制造资源耗尽，以图破坏程序。

## 小心缓冲区溢出

小心缓冲区溢出（overrun），即输入值或复制的字符串超出了分配的缓冲区空间。切勿使用*gets()*，并谨慎使用诸如*scanf()*、*sprintf()*、*strcpy()*和*strcat()*等函数（例如，使用`if`语句防止缓冲区溢出）。

缓冲区溢出可以导致诸如*栈崩溃*（也称为*栈破坏*）等技术，其中恶意用户利用缓冲区溢出来将精心编码的字节放入栈帧中，以迫使特权程序执行任意代码。（有多个在线来源解释了栈崩溃的细节；另见 [Erickson, 2008] 和 [Anley, 2007]。）缓冲区溢出可能是计算机系统上最常见的安全漏洞来源，如 CERT（[`www.cert.org/`](http://www.cert.org/)）和 Bugtraq（[`www.securityfocus.com/`](http://www.securityfocus.com/)）发布的安全通报所证明。缓冲区溢出在网络服务器中尤其危险，因为它们使系统容易受到网络上任何地方的远程攻击。

### 注意

为了使栈崩溃更为困难——特别是为了在远程攻击网络服务器时使这种攻击更加耗时——从内核 2.6.12 开始，Linux 实现了*地址空间随机化*。该技术在虚拟内存顶部的 8 MB 范围内随机变化栈的位置。此外，如果软`RLIMIT_STACK`限制不是无限的，并且 Linux 特定的 `/proc/sys/vm/legacy_va_layout` 文件包含值 0，则内存映射的位置也可以被随机化。

更新版的 x86-32 架构提供了硬件支持，用于将页表标记为*NX*（"不执行"）。该功能用于防止在栈上执行程序代码，从而使栈崩溃更加困难。

对于上述提到的许多函数，存在安全的替代方案——例如*snprintf()*、*strncpy()*和*strncat()*——这些函数允许调用者指定应复制的最大字符数。它们会考虑指定的最大值，以避免溢出目标缓冲区。通常，这些替代方案更为推荐，但仍然需要谨慎处理。特别需要注意以下几点：

+   对于大多数这些函数，如果达到了指定的最大值，则会将源字符串的截断版本放入目标缓冲区。由于这种截断的字符串在程序语义上可能没有意义，因此调用者必须检查是否发生了截断（例如，使用*snprintf()*的返回值），并在发生时采取适当的措施。

+   使用*strncpy()*可能会影响性能。如果在调用*strncpy(s1*, *s2*, *n*)时，*s2*指向的字符串长度小于*n*字节，那么将会向*s1*写入填充的空字节，以确保总共写入*n*字节。

+   如果给*strncpy()*的最大大小值不足以包括终止空字符，那么目标字符串将*不会*以空字符结尾。

### 注意

一些 UNIX 实现提供了*strlcpy()*函数，该函数接受一个长度参数*n*，最多将*n - 1*字节复制到目标缓冲区，并始终在缓冲区末尾附加一个空字符。然而，这个函数并未在 SUSv3 中指定，也未在*glibc*中实现。此外，在调用者没有仔细检查字符串长度的情况下，这个函数只是将一个问题（缓冲区溢出）替换成另一个问题（悄悄丢弃数据）。

## 警惕拒绝服务攻击

随着基于互联网的服务增多，远程拒绝服务攻击的机会也相应增加。这些攻击试图通过向服务器发送格式错误的数据导致其崩溃，或通过向其发送大量虚假请求来使服务对合法客户端不可用。

### 注意

本地拒绝服务攻击也是可能的。最著名的例子是当用户运行一个简单的 fork 炸弹（一个反复创建子进程的程序，从而消耗掉系统中的所有进程槽）。然而，本地拒绝服务攻击的来源更容易确定，通常可以通过适当的物理和密码安全措施来防止。

处理格式错误的请求很简单——服务器应该编程严格检查其输入并避免缓冲区溢出，如上所述。

过载攻击更难处理。由于服务器无法控制远程客户端的行为或请求提交的速率，因此这些攻击是无法防止的。（服务器甚至可能无法确定攻击的真实来源，因为网络数据包的源 IP 地址可以被伪造。此外，分布式攻击可能会招募不知情的中介主机，将攻击指向目标系统。）尽管如此，可以采取各种措施来最小化过载攻击的风险和后果：

+   服务器应进行负载限制，在负载超过预定限制时丢弃请求。这将导致合法请求被丢弃，但能防止服务器和主机机器过载。使用资源限制和磁盘配额也有助于限制过度的负载。（有关磁盘配额的更多信息，请参见 [`sourceforge.net/projects/linuxquota/`](http://sourceforge.net/projects/linuxquota/)）。

+   服务器应该对与客户端的通信设置超时，这样如果客户端（可能是故意的）不响应，服务器就不会无限期地等待客户端。

+   在出现过载的情况下，服务器应记录适当的消息，以便系统管理员能及时了解到问题。（不过，日志记录应该受到限制，以防止日志记录本身导致系统过载。）

+   服务器应该进行编程，以便在面对意外负载时不会崩溃。例如，应严格进行边界检查，确保过多的请求不会溢出数据结构。

+   数据结构应设计为避免*算法复杂性攻击*。例如，二叉树可以平衡并在典型负载下提供可接受的性能。然而，攻击者可能构造一系列输入，导致树不平衡（在最坏的情况下相当于链表），这可能会严重影响性能。[Crosby & Wallach, 2003] 详细说明了此类攻击的性质，并讨论了可用于避免这些攻击的数据结构技术。

## 检查返回状态并安全失败

特权程序应始终检查系统调用和库函数是否成功，并且它们是否返回了预期的值。（当然，这对所有程序都是正确的，但对于特权程序尤其重要。）各种系统调用可能会失败，即使程序以*root*身份运行。例如，如果系统级进程数限制被触及，*fork()*可能会失败；如果在只读文件系统上执行*open()*以进行写入，可能会失败；或者，如果目标目录不存在，*chdir()*可能会失败。

即使系统调用成功，也可能需要检查其结果。例如，在需要的情况下，特权程序应检查成功的*open()*是否没有返回三个标准文件描述符之一：0、1 或 2。

最后，如果特权程序遇到意外情况，通常的适当行为是终止程序，或者在服务器的情况下，丢弃客户端请求。尝试修复意外问题通常需要做出假设，这些假设在所有情况下可能并不成立，并可能导致安全漏洞的产生。在这种情况下，最好让程序终止，或者让服务器记录日志并丢弃客户端的请求。

## 总结

特权程序可以访问普通用户无法访问的系统资源。如果这些程序被破坏，系统的安全性就会受到威胁。在本章中，我们提供了一套编写特权程序的指南。这些指南的目的是双重的：一是尽量减少特权程序被破坏的可能性，二是尽量减少在特权程序被破坏时可能造成的损害。

#### 进一步信息

[Viega & McGraw, 2002] 涵盖了与安全软件设计和实施相关的广泛主题。有关 UNIX 系统安全性的一般信息，以及关于安全编程技巧的章节，可以在[Garfinkel 等, 2003]中找到。[Bishop, 2005]详细介绍了计算机安全，Bishop 同一作者在[Bishop, 2003]中更为深入地讨论了这一主题。[Peikari & Chuvakin, 2004]描述了计算机安全，重点介绍了系统可能遭受攻击的各种方式。[Erickson, 2008] 和 [Anley, 2007] 都对各种安全漏洞进行了深入讨论，提供了足够的细节，帮助明智的程序员避免这些漏洞。[Chen 等, 2002] 是一篇描述和分析 UNIX set-user-ID 模型的论文。[Tsafrir 等, 2008] 修订并增强了[Chen 等, 2002]中的讨论。[Drepper, 2009] 提供了关于 Linux 上安全和防御性编程的大量技巧。

关于编写安全程序的多个信息来源可以在线获取，包括以下内容：

+   Matt Bishop 写了许多与安全相关的论文，这些论文可以在[`nob.cs.ucdavis.edu/~bishop/secprog`](http://nob.cs.ucdavis.edu/~bishop/secprog)上在线获取。其中最有趣的一篇是《如何编写 Setuid 程序》，（最初发表于*;login: 12(1) Jan/Feb 1986*）。虽然有些过时，但这篇论文包含了大量有用的技巧。

+   由 David Wheeler 编写的*Linux 和 Unix 安全编程指南*可以在[`www.dwheeler.com/secure-programs/`](http://www.dwheeler.com/secure-programs/)在线获取。

+   关于编写 set-user-ID 程序的有用清单可以在[`www.homeport.org/~adam/setuid.7.html`](http://www.homeport.org/~adam/setuid.7.html)在线获取。

## 练习

1.  以普通无特权用户身份登录，创建一个可执行文件（或复制一个现有文件，如`/bin/sleep`），并在该文件上启用 set-user-ID 权限位（*chmod u+s*）。尝试修改该文件（例如，*cat >> file*）。文件权限会发生什么变化（*ls -l*）？为什么会发生这种情况？

1.  编写一个类似于*sudo(8)*程序的 set-user-ID-*root*程序。该程序应支持以下命令行选项和参数：

    ```
    $ `./douser [-u` ``*`user`*`` `]` ``*`program-file arg1`*`` ``*`arg2`*`` `...`
    ```

    *douser*程序执行*program-file*，并使用给定的参数，就像是由*user*运行的一样。（如果省略了*-u*选项，则*user*默认应为*root*。）在执行*program-file*之前，*douser*应该请求输入*user*的密码，并与标准密码文件进行身份验证（参见示例 8-2，在总结中），然后将所有进程的用户和组 ID 设置为该用户的正确值。
