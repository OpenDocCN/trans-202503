<html><head></head><body>
<h2 class="h2" id="ch01"><span epub:type="pagebreak" id="page_1"/><strong><span class="big">1</span><br/>WHAT YOU NEED TO KNOW TO WRITE GREAT CODE</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/comm1.jpg"/></div>&#13;
<p class="noindents">The <em>Write Great Code (WGC)</em> series will teach you how to write code you can be proud of; code that will impress other programmers, satisfy customers, and prove popular with users; and code that people (customers, your boss, and so on) won’t mind paying top dollar to obtain. In general, the books in the <em><a href="gloss01.xhtml#gloss01_262">WGC</a></em> series will discuss how to write software that achieves legendary status, eliciting the awe and admiration of other programmers.</p>&#13;
<h3 class="h3" id="sec1_1"><strong>1.1 The Write Great Code Series</strong></h3>&#13;
<p class="noindent"><em>Write Great Code, Volume 1: Understanding the Machine</em> (<em><a href="gloss01.xhtml#gloss01_263">WGC1</a></em> hereafter) is the first of six books in the <em><a href="gloss01.xhtml#gloss01_262">WGC</a></em> series. Writing great code requires a combination of knowledge, experience, and skill that programmers usually obtain only after years of mistakes and discoveries. The purpose of this series is to share with both new and experienced programmers a few decades’ worth of <span epub:type="pagebreak" id="page_2"/>observations and experience. I hope that these books will help reduce the time and frustration it takes to learn things “the hard way.”</p>&#13;
<p class="indent">This book, <em><a href="gloss01.xhtml#gloss01_263">WGC1</a></em>, fills in the low-level details that are often skimmed over in a typical computer science or engineering curriculum. These details are the foundation for the solutions to many problems, and you can’t write efficient code without this information. Though I’m attempting to keep each book independent, <em><a href="gloss01.xhtml#gloss01_263">WGC1</a></em> might be considered a prerequisite for the subsequent volumes in the series.</p>&#13;
<p class="indent"><em>Write Great Code, Volume 2: Thinking Low-Level, Writing High-Level</em> (<em><a href="gloss01.xhtml#gloss01_264">WGC2</a></em>) immediately applies the knowledge from this book. <em><a href="gloss01.xhtml#gloss01_264">WGC2</a></em> will teach you how to analyze code written in a high-level language to determine the quality of the machine code that a compiler would generate for it. Optimizing compilers don’t always generate the best machine code possible—the statements and data structures you choose in your source files can have a big impact on the efficiency of the compiler’s output. <em><a href="gloss01.xhtml#gloss01_264">WGC2</a></em> will teach you how to write efficient code without resorting to assembly language.</p>&#13;
<p class="indent">There are many attributes of great code besides efficiency, and the third book in this series, <em>Write Great Code, Volume 3: Engineering Software</em> (<em><a href="gloss01.xhtml#gloss01_265">WGC3</a></em>), will cover some of those. <em><a href="gloss01.xhtml#gloss01_265">WGC3</a></em> will discuss software development metaphors, development methologies, types of developers, system documentation, and the Unified Modeling Language (UML). <em><a href="gloss01.xhtml#gloss01_265">WGC3</a></em> provides the basis for personal software engineering.</p>&#13;
<p class="indent">Great code begins with a great design. <em>Write Great Code, Volume 4: Designing Great Code</em> (<em><a href="gloss01.xhtml#gloss01_266">WGC4</a></em>), will describe the process of analysis and design (both structured and object-oriented). <em><a href="gloss01.xhtml#gloss01_266">WGC4</a></em> will teach you how to translate an initial concept into a working design for your software systems.</p>&#13;
<p class="indent"><em>Write Great Code, Volume 5: Great Coding</em> (<em><a href="gloss01.xhtml#gloss01_267">WGC5</a></em>) will teach you how to create source code that others can easily read and maintain, as well as how to improve your productivity without the burden of the “busy work” that many software engineering books discuss.</p>&#13;
<p class="indent">Great code <em>works</em>. Therefore, I’d be remiss not to include a book on testing, debugging, and quality assurance. Few programmers properly test their code. This generally isn’t because they find testing boring or beneath them, but because they don’t know <em>how</em> to test their programs, eradicate defects, and ensure the quality of their code. To help overcome this problem, <em>Write Great Code, Volume 6: Testing, Debugging, and Quality Assurance</em> (<em><a href="gloss01.xhtml#gloss01_268">WGC6</a></em>) will describe how to efficiently test your applications without all the drudgery engineers normally associate with this task.</p>&#13;
<h3 class="h3" id="sec1_2"><strong>1.2 What This Book Covers</strong></h3>&#13;
<p class="noindent">In order to write great code, you need to know how to write efficient code, and to write efficient code, you must understand how computer systems execute programs and how abstractions in programming languages map to the low-level hardware capabilities of the machine.</p>&#13;
<p class="indent">In the past, learning great coding techniques has required learning assembly language. While this isn’t a bad approach, it’s overkill. Learning <span epub:type="pagebreak" id="page_3"/>assembly language involves learning two related subjects: machine organization, and programming in assembly language. The real benefits of learning assembly language come from the machine organization component. Thus, this book focuses solely on machine organization so you can learn to write great code without the overhead of also learning assembly language.</p>&#13;
<p class="indent">Machine organization is a subset of computer architecture that covers low-level data types, internal CPU organization, memory organization and access, low-level machine operations, mass storage organization, peripherals, and how computers communicate with the rest of the world. This book concentrates on those parts of computer architecture and machine organization that are visible to the programmer or are helpful for understanding why system architects chose a particular system design. The goal of learning machine organization, and of this book, is not to enable you to design your own CPU or computer system, but to equip you to make the most efficient use of existing computer designs. Let’s do a quick run-through of the specific topics we’ll cover.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch02">Chapters 2</a>, <a href="ch04.xhtml#ch04">4</a>, and <a href="ch05.xhtml#ch05">5</a> deal with basic computer data representation—how computers represent signed and unsigned integer values, characters, strings, character sets, real values, fractional values, and other numeric and non-numeric quantities. Without a solid grasp of how computers represent these various data types internally, it’ll be difficult for you to understand why some operations that use these data types are so inefficient.</p>&#13;
<p class="indent"><a href="ch03.xhtml#ch03">Chapter 3</a> discusses binary arithmetic and bit operations used by most modern computer systems. It also offers several insights into how you can write better code by using arithmetic and logical operations in ways not normally taught in beginning programming courses. Learning these kinds of standard “tricks” is part of how you become a great programmer.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06">Chapter 6</a> introduces memory, discussing how the computer accesses its memory and describing characteristics of memory performance. This chapter also covers various machine code <em><a href="gloss01.xhtml#gloss01_8">addressing modes</a></em>, which CPUs use to access different types of data structures in memory. In modern applications, poor performance often occurs because the programmer, unaware of the ramifications of memory access in their programs, creates bottlenecks. <a href="ch06.xhtml#ch06">Chapter 6</a> addresses many of these ramifications.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch07">Chapter 7</a> returns to data types and representation by covering composite data types and memory objects: pointers, arrays, records, structures, and unions. All too often, programmers use large composite data structures without even considering the memory and performance impact of doing so. The low-level description of these high-level composite data types will make clear their inherent costs, so you can use them sparingly and wisely.</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch08">Chapter 8</a> discusses Boolean logic and digital design. This chapter provides the mathematical and logical background you’ll need to understand the design of CPUs and other computer system components. In particular, this chapter discusses how to optimize Boolean expressions, such as those found in common high-level programming language statements like <code>if</code> and <code>while</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_4"/>Continuing the hardware discussion from <a href="ch08.xhtml#ch08">Chapter 8</a>, <a href="ch09.xhtml#ch09">Chapter 9</a> discusses CPU architecture. A basic understanding of CPU design and operation is essential if you want to write great code. By writing your code in a manner consistent with how a CPU will execute it, you’ll get much better performance using fewer system resources.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10">Chapter 10</a> discusses CPU instruction set architecture. Machine instructions are the primitive units of execution on any CPU, and the duration of program execution is directly determined by the number and type of machine instructions the CPU must process. Learning how computer architects design machine instructions can provide valuable insight into why certain operations take longer to execute than others. Once you understand the limitations of machine instructions and how the CPU interprets them, you can use this information to turn mediocre code sequences into great ones.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11">Chapter 11</a> returns to the subject of memory, covering memory architecture and organization. This chapter is especially important for anyone wanting to write fast code. It describes the memory hierarchy and how to maximize the use of the cache and other fast memory components. You’ll learn about thrashing and how to avoid low-performance memory access in your applications.</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch12">Chapters 12</a> through <a href="ch15.xhtml#ch15">15</a> describe how computer systems communicate with the outside world. Many peripheral (input/output) devices operate at much lower speeds than the CPU and memory. You could write the fastest-executing sequence of instructions possible, and your application would still run slowly because you didn’t understand the limitations of the I/O devices in your system. These four chapters discuss generic I/O ports, system buses, buffering, handshaking, polling, and interrupts. They also explain how to efficiently use many popular PC peripheral devices, including keyboards, parallel (printer) ports, serial ports, disk drives, tape drives, flash storage, SCSI, IDE/ATA, USB, and sound cards.</p>&#13;
<h3 class="h3" id="sec1_3"><strong>1.3 Assumptions This Book Makes</strong></h3>&#13;
<p class="noindent">This book was written with certain assumptions about your prior knowledge. You’ll reap the greatest benefit from this material if your skill set matches the following:</p>&#13;
<ul>&#13;
<li class="noindent">You should be reasonably competent in at least one modern programming language. This includes C/C++, C#, Java, Swift, Python, Pascal/Delphi (Object Pascal), BASIC, and assembly, as well as languages like Ada, Modula-2, and FORTRAN.</li>&#13;
<li class="noindent">Given a small problem description, you should be capable of working through the design and implementation of a software solution for that problem. A typical semester or quarter course at a college or university (or several months’ experience on your own) should be sufficient background for this book.</li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_5"/>At the same time, this book is not language specific; its concepts transcend whatever programming language(s) you’re using. Furthermore, this book does not assume that you use or know any particular language. To help make the examples more accessible, the programming examples rotate among several languages. This book explains exactly how the example code operates so that even if you’re unfamiliar with the specific programming language, you’ll be able to understand its operation by reading the accompanying description.</p>&#13;
<p class="indent">This book uses the following languages and compilers in various examples:</p>&#13;
<ul>&#13;
<li class="noindent">C/C++: GCC, Microsoft’s Visual C++</li>&#13;
<li class="noindent">Pascal: Embarcadero’s Delphi, Free Pascal</li>&#13;
<li class="noindent">Assembly language: Microsoft’s MASM, HLA (High-Level Assembly), Gas (the Gnu Assembler; on the PowerPC and ARM)</li>&#13;
<li class="noindent">Swift 5 (Apple)</li>&#13;
<li class="noindent">Java (v6 or later)</li>&#13;
<li class="noindent">BASIC: Microsoft’s Visual Basic</li>&#13;
</ul>&#13;
<p class="indent">Often, the examples appear in multiple languages, so it’s usually safe to ignore a specific example if you don’t understand the syntax of the language it uses.</p>&#13;
<h3 class="h3" id="sec1_4"><strong>1.4 Characteristics of Great Code</strong></h3>&#13;
<p class="noindent">Different programmers will have different definitions for great code, so it’s impossible to provide an all-encompassing definition that will satisfy everyone. However, nearly everyone will agree that great code:</p>&#13;
<ul>&#13;
<li class="noindent">Uses the CPU efficiently (that is, it’s fast)</li>&#13;
<li class="noindent">Uses memory efficiently (that is, it’s small)</li>&#13;
<li class="noindent">Uses system resources efficiently</li>&#13;
<li class="noindent">Is easy to read and maintain</li>&#13;
<li class="noindent">Follows a consistent set of style guidelines</li>&#13;
<li class="noindent">Uses an explicit design that follows established software engineering conventions</li>&#13;
<li class="noindent">Is easy to enhance</li>&#13;
<li class="noindent">Is well tested and robust (that is, it works)</li>&#13;
<li class="noindent">Is well documented</li>&#13;
</ul>&#13;
<p class="indent">We could easily add dozens of items to this list. Some programmers, for example, may feel that great code must be portable, must follow a given set of programming style guidelines, or must be written in a certain language (or <em>not</em> be written in a certain language). Some may feel that great code must be written as simply as possible, while others believe that it must be <span epub:type="pagebreak" id="page_6"/>written quickly. Still others may feel that great code is created on time and under budget.</p>&#13;
<p class="indent">Here is the definition this book uses:</p>&#13;
<p class="block-quote">Great code is software that is written using a consistent and prioritized set of good software characteristics. In particular, great code follows a set of rules that guide the decisions a programmer makes when implementing an algorithm as source code.</p>&#13;
<p class="indent">Two different programs do not have to follow the same set of rules (that is, they need not possess the same set of characteristics) in order for both to be great. In one environment, the priority might be producing code that’s portable across different CPUs and operating systems. In a different environment, efficiency (speed) might be the primary goal, and portability might not be an issue. Neither program would qualify as great according to the rules of the other, but as long as the software consistently follows the guidelines established for that particular program, you can argue that it is an example of great code.</p>&#13;
<h3 class="h3" id="sec1_5"><strong>1.5 The Environment for This Book</strong></h3>&#13;
<p class="noindent">Although this book presents generic information, parts of the discussion will necessarily be specific to a particular system. Because the Intel Architecture PCs are, by far, the most common in use today, this book will use that platform when discussing specific system-dependent concepts.</p>&#13;
<p class="indent">Most of the specific examples in this book run on a late-model Intel Architecture (including AMD) CPU under macOS, Windows, or Linux, with a reasonable amount of RAM and other system peripherals normally found on a late-model PC. This book attempts to stick with standard library interfaces to the operating system (OS) wherever possible, and it makes OS-specific calls only when the alternative is to write “less than great” code. The concepts, if not the software itself, will apply to Android, Chrome, iOS, Macs, Unix boxes, embedded systems, and even mainframes, though you may need to research how to apply a concept to your platform.</p>&#13;
<h3 class="h3" id="sec1_6"><strong>1.6 Additional Tips</strong></h3>&#13;
<p class="noindent">No single book can completely cover everything you need to know in order to write great code. This book, therefore, concentrates on the areas that are most pertinent for machine organization, providing the 90 percent solution for those who are interested in writing the best possible code. To get that last 10 percent you’ll need additional help. Here are some suggestions:</p>&#13;
<p class="uln-indent"><strong>Learn assembly language.</strong> Fluency in at least one assembly language will fill in many missing details that you just won’t get by learning machine organization alone. Unless you plan to use assembly language in your software systems, you don’t have to learn it on the platform(s) to which you’re targeting your software. Probably your best bet is to <span epub:type="pagebreak" id="page_7"/>learn 80x86 assembly language on a PC, because there are lots of great software tools for learning Intel Architecture assembly language (for example, HLA) that simply don’t exist on other platforms. The point of learning assembly language here is not to write assembly code, but to learn the assembly paradigm. If you know 80x86 assembly language, you’ll have a good idea of how other CPUs (such as the ARM or the IA-64 family) operate.</p>&#13;
<p class="uln-indent"><strong>Study advanced computer architecture.</strong> Machine organization is a subset of computer architecture, but space limitations prevent full coverage of both in this book. While you may not need to know how to design your own CPUs, studying computer architecture might teach you something omitted here.</p>&#13;
<h3 class="h3" id="sec1_7"><strong>1.7 For More Information</strong></h3>&#13;
<p class="ref">Hennessy, John L., and David A. Patterson. <em>Computer Architecture: A Quantitative Approach</em>. 5th ed. Waltham, MA: Morgan Kaufmann, 2012.</p>&#13;
<p class="ref">Hyde, Randall. <em>The Art of Assembly Language</em>. 2nd ed. San Francisco: No Starch Press, 2010.<span epub:type="pagebreak" id="page_8"/></p>&#13;
</body></html>