<html><head></head><body><section class="chapter" epub:type="chapter" id="getting_your_setup_just_right" title="Chapter&#xA0;10.&#xA0;Getting Your Setup Just Right"><div class="titlepage"><div><div><h2 class="title">Chapter 10. Getting Your Setup Just Right</h2></div></div></div><div class="mediaobject"><a id="med_id00020"/><img alt="Getting Your Setup Just Right" src="httpatomoreillycomsourcenostarchimages2127149.png.jpg"/></div><p>By now, you’ve spent significant time designing your network and implementing that design in your PF configuration. Getting your setup just right—that is, removing any remaining setup bugs and inefficiencies—can be quite challenging at times.</p><p>This chapter describes options and methods that will help you get the setup you need. First, we’ll take a look at global options and settings that can have a profound influence on how your configuration behaves.</p><div class="sect1" title="Things You Can Tweak and What You Probably Should Leave Alone"><div class="titlepage"><div><div><h2 class="title" id="things_you_can_tweak_and_what_you_probab" style="clear: both">Things You Can Tweak and What You Probably Should Leave Alone</h2></div></div></div><p>Network configurations are inherently very tweakable. While browsing the <code class="literal">pf.conf</code> man page or other reference documentation, it’s easy to be overwhelmed by the number of options and settings that you could conceivably adjust in order to get that perfectly optimized setup.</p><p><a class="indexterm" id="iddle1086"/><a class="indexterm" id="iddle1218"/><a class="indexterm" id="iddle1773"/>Keep in mind that for PF in general, <span class="emphasis"><em>the defaults</em></span> are sane for most setups. Some settings and variables lend themselves to tuning; others should come with a big warning that they should be adjusted only in highly unusual circumstances, if at all.</p><p>Here, we’ll look at some of the global settings that you should know about, although you won’t need to change them in most circumstances.</p><p>These options are written as <code class="literal">set</code> <span class="emphasis"><em><code class="literal">option setting</code></em></span> and go <span class="emphasis"><em>after</em></span> any macro definitions in your <span class="emphasis"><em>pf.conf</em></span> file but <span class="emphasis"><em>before</em></span> translation or filtering rules.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note01"/>Note</h3><p><span class="emphasis"><em>If you read the <code class="literal">pf.conf</code> man page, you’ll discover that a few other options are available. However, most of those aren’t relevant in a network-testing and performance-tuning context.</em></span></p></div><div class="sect2" title="Block Policy"><div class="titlepage"><div><div><h3 class="title" id="block_policy">Block Policy</h3></div></div></div><p>The <code class="literal">block-policy</code> option determines which feedback, if any, PF will give to hosts that try to create connections that are subsequently blocked. The option has two possible values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">drop</code> drops blocked packets with no feedback.</p></li><li class="listitem"><p><code class="literal">return</code> returns with status codes, such as <code class="literal">Connection refused</code> or similar.</p></li></ul></div><p>The correct strategy for block policies has been the subject of considerable discussion over the years. The default setting for <code class="literal">block-policy</code> is <code class="literal">drop</code>, which means that the packet is silently dropped without any feedback. Silently dropping packets, however, makes it likely that the sender will resend the unacknowledged packets rather than drop the connection. Thus, the sender may keep up the effort until the relevant timeout counter expires. If you don’t want this behavior to be the default in your setup, set the block policy to <code class="literal">return</code>:</p><a id="pro_id00356"/><pre class="programlisting">set block-policy return</pre><p>This setting means that the sender’s networking stack will receive an unambiguous signal indicating that the connection was refused.</p><p>Whichever <code class="literal">block-policy</code> option you use will specify the <span class="emphasis"><em>global</em></span> default for your block policy. If necessary, however, you can still vary the blocking type for specific rules. For example, you could change the brute-force protection rule set from <a class="xref" href="ch06.html" title="Chapter 6. Turning the Tables for Proactive Defense">Chapter 6</a> to set <code class="literal">block-policy</code> to <code class="literal">return</code> but also use <code class="literal">block drop quick from &lt;bruteforce&gt;</code> to make the brute forcers waste time if they stick around once they’ve been added to the <code class="literal">&lt;bruteforce&gt;</code> table. You could also specify <code class="literal">drop</code> for traffic from nonroutable addresses coming in <a class="indexterm" id="iddle1168"/><a class="indexterm" id="iddle1169"/><a class="indexterm" id="iddle1185"/><a class="indexterm" id="iddle1186"/><a class="indexterm" id="iddle1253"/><a class="indexterm" id="iddle1355"/><a class="indexterm" id="iddle1815"/><a class="indexterm" id="iddle1897"/><a class="indexterm" id="iddle1900"/>on your Internet-facing interface or other clearly nondesirable traffic, such as attempts to enlist your gear in amplifying a distributed denial-of-service (DDoS) attack.<sup>[<a class="footnote" href="#ftn.ch10fn01" id="ch10fn01">49</a>]</sup></p></div><div class="sect2" title="Skip Interfaces"><div class="titlepage"><div><div><h3 class="title" id="skip_interfaces">Skip Interfaces</h3></div></div></div><p>The <code class="literal">skip</code> option lets you exclude specific interfaces from all PF processing. The net effect is like a <code class="literal">pass-all</code> rule for the interface, but it actually disables all PF processing on the interface. For example, you can use this option to disable filtering on the loopback interface group, where filtering in most configurations adds little in terms of security or convenience:</p><a id="pro_id00357"/><pre class="programlisting">set skip on lo</pre><p>In fact, filtering on the loopback interface is almost never useful, and it can lead to odd results with a number of common programs and services. The default is that <code class="literal">skip</code> is unset, which means that all configured interfaces can take part in PF processing. In addition to making your rule set slightly simpler, setting <code class="literal">skip</code> on interfaces where you don’t want to perform filtering results in a slight performance gain.</p></div><div class="sect2" title="State Policy"><div class="titlepage"><div><div><h3 class="title" id="state_policy">State Policy</h3></div></div></div><p>The <code class="literal">state-policy</code> option specifies how PF matches packets to the state table. It has two possible values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>With the default <code class="literal">floating</code> state policy, traffic can match state on all interfaces, not just the one where the state was created.</p></li><li class="listitem"><p>With an <code class="literal">if-bound</code> policy, traffic will match only on the interface where the state is created; traffic on other interfaces will not match the existing state.</p></li></ul></div><p>Like the <code class="literal">block-policy</code> option, this option specifies the global state-matching policy, but you can override the state-matching policy on a per-rule basis if needed. For example, in a rule set with the default <code class="literal">floating</code> policy, you could have a rule like this:</p><a id="pro_id00358"/><pre class="programlisting">pass out on egress inet proto tcp to any port $allowed modulate state (if-bound)</pre><p>With this rule, any return traffic trying to pass back in would need to pass on the same interface where the state was created in order to match the state-table entry.</p><p><a class="indexterm" id="iddle1013"/><a class="indexterm" id="iddle1015"/><a class="indexterm" id="iddle1260"/><a class="indexterm" id="iddle1376"/><a class="indexterm" id="iddle1425"/><a class="indexterm" id="iddle1895"/><a class="indexterm" id="iddle1896"/><a class="indexterm" id="iddle1975"/>The situations in which an <code class="literal">if-bound</code> policy is useful are rare enough that you should leave this setting at the default.</p></div><div class="sect2" title="State Defaults"><div class="titlepage"><div><div><h3 class="title" id="state_defaults">State Defaults</h3></div></div></div><p>Introduced in OpenBSD 4.5, the <code class="literal">state-defaults</code> option enables you to set specific state options as the default options for all rules in the rule set—unless those state options are specifically overridden by other options in individual rules.</p><p>Here’s a common example:</p><a id="pro_id00359"/><pre class="programlisting">set state-defaults pflow</pre><p>This option sets up all <code class="literal">pass</code> rules in the configuration to generate NetFlow data to be exported via a <code class="literal">pflow</code> device.</p><p>In some contexts, it makes sense to apply state-tracking options, such as connection limits, as a global state default for the entire rule set. Here’s an example:</p><a id="pro_id00360"/><pre class="programlisting">set state-defaults max 1500, max-src-conn 100, source-track rule</pre><p>This option sets the default maximum number of state entries per rule to 1,500, with a maximum of 100 simultaneous connections from any one host and with separate limits for each rule in the loaded rule set.</p><p>Any option that’s valid inside parentheses for <code class="literal">keep state</code> in an individual rule can also be included in a <code class="literal">set state-defaults</code> statement. Setting state defaults in this way is useful if there are state options that aren’t already system defaults that you want to apply to all rules in your configuration.</p></div><div class="sect2" title="Timeouts"><div class="titlepage"><div><div><h3 class="title" id="timeouts">Timeouts</h3></div></div></div><p>The <code class="literal">timeout</code> option sets the timeouts and related options for various interactions with the state-table entries. The majority of the available parameters are protocol-specific values stored in seconds and prefixed <code class="literal">tcp.</code>, <code class="literal">udp.</code>, <code class="literal">icmp.</code>, and <code class="literal">other.</code>. However, <code class="literal">adaptive.start</code> and <code class="literal">adaptive.end</code> denote the number of state-table entries.</p><p>The following <code class="literal">timeout</code> options affect state-table memory use and, to some extent, lookup speed:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="literal">adaptive.start</code> and <code class="literal">adaptive.end</code> values set the limits for scaling down timeout values once the number of state entries reaches the <code class="literal">adaptive.start</code> value. When the number of states reaches <code class="literal">adaptive.end</code>, all timeouts are set to 0, essentially expiring all states immediately. The defaults are 6,000 and 12,000 (calculated as 60 percent and 120 percent of the state limit, respectively). These settings are intimately related to the memory-pool limit parameters you set via the <code class="literal">limit</code> option.</p></li><li class="listitem"><p>The <code class="literal">interval</code> value denotes the number of seconds between purges of expired states and fragments. The default is 10 seconds.</p></li><li class="listitem"><p><a class="indexterm" id="iddle1426"/><a class="indexterm" id="iddle1430"/><a class="indexterm" id="iddle1641"/>The <code class="literal">frag</code> value denotes the number of seconds a fragment will be kept in an unassembled state before it’s discarded. The default is 30 seconds.</p></li><li class="listitem"><p>When set, <code class="literal">src.track</code> denotes the number of seconds source-tracking data will be kept after the last state has expired. The default is 0 seconds.</p></li></ul></div><p>You can inspect the current settings for all <code class="literal">timeout</code> parameters with <code class="literal">pfctl -s timeouts</code>. For example, the following display shows a system running with default values:</p><a id="pro_id00361"/><pre class="programlisting">$ <span class="strong"><strong>sudo pfctl -s timeouts</strong></span>&#13;
tcp.first                  120s&#13;
tcp.opening                 30s&#13;
tcp.established          86400s&#13;
tcp.closing                900s&#13;
tcp.finwait                 45s&#13;
tcp.closed                  90s&#13;
tcp.tsdiff                  30s&#13;
udp.first                   60s&#13;
udp.single                  30s&#13;
udp.multiple                60s&#13;
icmp.first                  20s&#13;
icmp.error                  10s&#13;
other.first                 60s&#13;
other.single                30s&#13;
other.multiple              60s&#13;
frag                        30s&#13;
interval                    10s&#13;
adaptive.start            6000 states&#13;
adaptive.end             12000 states&#13;
src.track                    0s</pre><p>These options can be used to tweak your setup for performance. However, changing the protocol-specific settings from the default values creates a significant risk that valid but idle connections might be dropped prematurely or blocked outright.</p></div><div class="sect2" title="Limits"><div class="titlepage"><div><div><h3 class="title" id="limits">Limits</h3></div></div></div><p>The <code class="literal">limit</code> option sets the size of the memory pools PF uses for state tables and address tables. These are hard limits, so you may need to increase or tune the values for various reasons. If your network is a busy one with larger numbers than the default values allow for, or if your setup requires large address tables or a large number of tables, then this section will be very relevant to you.</p><p>Keep in mind that the total amount of memory available through memory pools is taken from the <span class="emphasis"><em>kernel memory space</em></span>, and the total available is a function of total available kernel memory. Kernel memory is to some extent dynamic, but the amount of memory allocated to the kernel can never equal or exceed all physical memory in the system. (If that happened, there would be no space for user-mode programs to run.)</p><p><a class="indexterm" id="iddle1171"/><a class="indexterm" id="iddle1174"/><a class="indexterm" id="iddle1312"/><a class="indexterm" id="iddle1651"/>The amount of available pool memory depends on which hardware platform you use as well as on a number of hard-to-predict variables specific to the local system. On the i386 architecture, the maximum kernel memory is in the 768MB to 1GB range, depending on a number of factors, including the number and kind of hardware devices in the system. The amount actually available for allocation to memory pools comes out of this total, again depending on a number of system-specific variables.</p><p>To inspect the current <code class="literal">limit</code> settings, use <code class="literal">pfctl -sm</code>. Typical output looks like this:</p><a id="pro_id00362"/><pre class="programlisting">$ <span class="strong"><strong>sudo pfctl -sm</strong></span>&#13;
states        hard limit   10000&#13;
src-nodes     hard limit   10000&#13;
frags         hard limit    5000&#13;
tables        hard limit    1000&#13;
table-entries hard limit   200000</pre><p>To change these values, edit <span class="emphasis"><em>pf.conf</em></span> to include one or more lines with new <code class="literal">limit</code> values. For example, you could use the following lines to raise the hard limit for the number of states to 25,000 and for the number of table entries to 300,000:</p><a id="pro_id00363"/><pre class="programlisting">set limit states 25000&#13;
set limit table-entries 300000</pre><p>You can also set several <code class="literal">limit</code> parameters at the same time in a single line by enclosing them in brackets:</p><a id="pro_id00364"/><pre class="programlisting">set limit { states 25000, src-nodes 25000, table-entries 300000 }</pre><p>In the end, other than possibly increasing these three parameters for larger installations, you almost certainly shouldn’t change the limits at all. If you do, however, it’s important to watch your system logs for any indication that your changed limits have undesirable side effects or don’t fit in available memory. Setting the <code class="literal">debug</code> level to a higher value is potentially quite useful for watching the effects of tuning <code class="literal">limit</code> parameters.</p></div><div class="sect2" title="Debug"><div class="titlepage"><div><div><h3 class="title" id="debug">Debug</h3></div></div></div><p>The <code class="literal">debug</code> option determines what, if any, error information PF will generate at the <span class="emphasis"><em>kern.debug</em></span> log level. The default value is <code class="literal">err</code>, which means that only serious errors will be logged. Since OpenBSD 4.7, the log levels here correspond to the ordinary <code class="literal">syslog</code> levels, which range from <code class="literal">emerg</code> (panics are logged), <code class="literal">alert</code> (correctable but very serious errors are logged), <code class="literal">crit</code> (critical conditions are logged), and <code class="literal">err</code> (errors are logged) to <code class="literal">warning</code> (warnings are logged), <code class="literal">notice</code> (unusual conditions are logged), <code class="literal">info</code> (informational messages are logged), and <code class="literal">debug</code> (full debugging information, likely only useful to developers, is logged).</p><div class="note" title="Note"><h3 class="title"><a id="ch10note02"/>Note</h3><p><a class="indexterm" id="iddle1637"/><a class="indexterm" id="iddle1780"/><span class="emphasis"><em>In pre–OpenBSD 4.7 versions, PF used its own log-level system, with a default of <code class="literal">urgent</code> (equivalent to <code class="literal">err</code> in the new system). The other possible settings were <code class="literal">none</code> (no messages), <code class="literal">misc</code> (reporting slightly more than <code class="literal">urgent</code>), and <code class="literal">loud</code> (producing status messages for most operations). The <code class="literal">pfctl</code> parser still accepts the older-style debug levels for compatibility.</em></span></p></div><p>After one of my gateways ran at the <code class="literal">debug</code> level for a while, this is what a typical chunk of the <span class="emphasis"><em>/var/log/messages</em></span> file looked like:</p><a id="pro_id00365"/><pre class="programlisting"><span class="strong"><strong>$ tail -f /var/log/messages</strong></span>&#13;
Oct 4 11:41:11 skapet /bsd: pf_map_addr: selected address 194.54.107.19&#13;
Oct 4 11:41:15 skapet /bsd: pf: loose state match: TCP 194.54.107.19:25&#13;
194.54.107.19:25 158.36.191.135:62458 [lo=3178647045 high=3178664421 win=33304&#13;
modulator=0 wscale=1] [lo=3111401744 high=3111468309 win=17376 modulator=0&#13;
wscale=0] 9:9 R seq=3178647045 (3178647044) ack=3111401744 len=0 ackskew=0&#13;
pkts=9:12&#13;
Oct 4 11:41:15 skapet /bsd: pf: loose state match: TCP 194.54.107.19:25&#13;
194.54.107.19:25 158.36.191.135:62458 [lo=3178647045 high=3178664421 win=33304&#13;
modulator=0 wscale=1] [lo=3111401744 high=3111468309 win=17376 modulator=0&#13;
wscale=0] 10:10 R seq=3178647045 (3178647044) ack=3111401744 len=0 ackskew=0&#13;
pkts=10:12&#13;
Oct 4 11:42:24 skapet /bsd: pf_map_addr: selected address 194.54.107.19</pre><p>At the <code class="literal">debug</code> level, PF repeatedly reports the IP address for the interface it’s currently handling. In between the selected address messages, PF warns twice for the same packet that the sequence number is at the very edge of the expected range. This level of detail seems a bit overwhelming at first glance, but in some circumstances, studying this kind of output is the best way to diagnose a problem and later to check to see whether your solution helped.</p><div class="note" title="Note"><h3 class="title"><a id="ch10note03"/>Note</h3><p><span class="emphasis"><em>This option can be set from the command line with <code class="literal">pfctl -x</code>, followed by the debug level you want. The command <code class="literal">pfctl -x debug</code> gives you maximum debugging information; <code class="literal">pfctl -x none</code> turns off debug messages entirely.</em></span></p></div><p>Keep in mind that some <code class="literal">debug</code> settings can produce large amounts of log data and, in extreme cases, could impact performance all the way to self-denial-of-service level.</p></div><div class="sect2" title="Rule Set Optimization"><div class="titlepage"><div><div><h3 class="title" id="rule_set_optimization">Rule Set Optimization</h3></div></div></div><p>The <code class="literal">ruleset-optimization</code> option enables or sets the mode for the rule set optimizer. The default setting for <code class="literal">ruleset-optimization</code> in OpenBSD 4.1 and equivalents is <code class="literal">none</code>, which means that no rule set optimization is performed at load time. From OpenBSD 4.2 onward, the default is <code class="literal">basic</code>, which means that when the rule set loads, the optimizer performs the following actions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Removes duplicate rules</p></li><li class="listitem"><p>Removes rules that are subsets of other rules</p></li><li class="listitem"><p><a class="indexterm" id="iddle1019"/><a class="indexterm" id="iddle1259"/><a class="indexterm" id="iddle1328"/><a class="indexterm" id="iddle1580"/><a class="indexterm" id="iddle1732"/><a class="indexterm" id="iddle1746"/><a class="indexterm" id="iddle1800"/><a class="indexterm" id="iddle1804"/>Merges rules into tables if appropriate (typical rule-to-table optimizations are rules that pass, redirect, or block based on identical criteria, except source and/or target addresses)</p></li><li class="listitem"><p>Changes the order of rules to improve performance</p></li></ul></div><p>For example, say you have the macro <code class="literal">tcp_services = { ssh, www, https }</code> combined with the rule <code class="literal">pass proto tcp from any to self port $tcp_services</code>. Elsewhere in your rule set, you have a different rule that says <code class="literal">pass proto tcp from any to self port ssh</code>. The second rule is clearly a subset of the first, and they can be merged into one. Another common combination is having a <code class="literal">pass</code> rule like <code class="literal">pass proto tcp from any to int_if:network port $tcp_services</code> with otherwise identical <code class="literal">pass</code> rules, where the target addresses are all in the <code class="literal">int_if:network</code> range.</p><p>With <code class="literal">ruleset-optimization</code> set to <code class="literal">profile</code>, the optimizer analyzes the loaded rule set relative to network traffic in order to determine the optimal order of <code class="literal">quick</code> rules.</p><p>You can also set the value of the optimization option from the command line with <code class="literal">pfctl</code>:</p><a id="pro_id00366"/><pre class="programlisting">$ <span class="strong"><strong>sudo pfctl -o basic</strong></span></pre><p>This example enables the rule set optimization in <code class="literal">basic</code> mode.</p><p>Because the optimization may remove or reorder rules, the meaning of some statistics—mainly the number of evaluations per rule—may change in ways that are hard to predict. In most cases, however, the effect is negligible.</p></div><div class="sect2" title="Optimization"><div class="titlepage"><div><div><h3 class="title" id="optimization">Optimization</h3></div></div></div><p>The <code class="literal">optimization</code> option specifies profiles for state-timeout handling. The possible values are <code class="literal">normal</code>, <code class="literal">high-latency</code>, <code class="literal">satellite</code>, <code class="literal">aggressive</code>, and <code class="literal">conservative</code>. The recommendation is to keep the default <code class="literal">normal</code> setting unless you have very specific needs.</p><p>The values <code class="literal">high-latency</code> and <code class="literal">satellite</code> are synonyms; with these values, states expire more slowly in order to compensate for potential high latency.</p><p>The <code class="literal">aggressive</code> setting expires states early in order to save memory. This could, in principle, increase the risk of dropping idle-but-valid connections if your system is already close to its load and traffic limits, but anecdotal evidence indicates that the <code class="literal">aggressive</code> optimization setting rarely, if ever, interferes with valid traffic.</p><p>The <code class="literal">conservative</code> setting goes to great lengths to preserve states and idle connections, at the cost of some additional memory use.</p></div><div class="sect2" title="Fragment Reassembly"><div class="titlepage"><div><div><h3 class="title" id="fragment_reassembly">Fragment Reassembly</h3></div></div></div><p>The fragment reassembly options tied to <code class="literal">scrub</code> were significantly reworked in OpenBSD 4.6, which introduced the new <code class="literal">set reassemble</code> option to turn reassembly of fragmented packets on or off. If <code class="literal">reassemble</code> is set to <code class="literal">off</code>, fragmented packets are simply dropped unless they match a rule with the <a class="indexterm" id="iddle1056"/><a class="indexterm" id="iddle1180"/><a class="indexterm" id="iddle1213"/><a class="indexterm" id="iddle1488"/><a class="indexterm" id="iddle1805"/><code class="literal">fragment</code> option. The default is <code class="literal">set reassemble on</code>, which means that fragments are reassembled and that reassembled packets in which the do-not-fragment bit was set on individual fragments will have the bit cleared.</p></div></div><div class="sect1" title="Cleaning Up Your Traffic"><div class="titlepage"><div><div><h2 class="title" id="cleaning_up_your_traffic" style="clear: both">Cleaning Up Your Traffic</h2></div></div></div><p>The next two features we’ll discuss, <code class="literal">scrub</code> and <code class="literal">antispoof</code>, share a common theme: They provide automated protection against potentially dangerous clutter in your network traffic. Together, they’re commonly referred to as tools for “network hygiene” because they sanitize your networking considerably.</p><div class="sect2" title="Packet Normalization with scrub: OpenBSD 4.5 and Earlier"><div class="titlepage"><div><div><h3 class="title" id="packet_normalization_with_scrub_openbsd">Packet Normalization with scrub: OpenBSD 4.5 and Earlier</h3></div></div></div><p>In PF versions up to and including OpenBSD 4.5, the <code class="literal">scrub</code> keyword enables network traffic normalization. With <code class="literal">scrub</code>, fragmented packets are reassembled, and invalid fragments—such as overlapping fragments—are discarded, so the resulting packet is complete and unambiguous.</p><p>Enabling <code class="literal">scrub</code> provides a measure of protection against certain kinds of attacks based on incorrect handling of packet fragments.<sup>[<a class="footnote" href="#ftn.ch10fn02" id="ch10fn02">50</a>]</sup> A number of supplementing options are available, but the simplest form is suitable for most configurations:</p><a id="pro_id00367"/><pre class="programlisting">scrub in</pre><p>In order for certain services to work with <code class="literal">scrub</code>, specific options must be set. For example, some NFS implementations won’t work with <code class="literal">scrub</code> at all unless you use the <code class="literal">no-df</code> parameter to clear the do-not-fragment bit on any packets that have the bit set. Certain combinations of services, operating systems, and network configurations may require some of the more exotic <code class="literal">scrub</code> options.</p></div><div class="sect2" title="Packet Normalization with scrub: OpenBSD 4.6 Onward"><div class="titlepage"><div><div><h3 class="title" id="packet_normalization_with_scrub_-id00011">Packet Normalization with scrub: OpenBSD 4.6 Onward</h3></div></div></div><p>In OpenBSD 4.6, <code class="literal">scrub</code> was demoted from stand-alone rule material to become an action you could attach to <code class="literal">pass</code> or <code class="literal">match</code> rules (the introduction of <code class="literal">match</code> rules being one of the main new PF features in OpenBSD 4.6). One other important development in the same rewrite of the <code class="literal">scrub</code> code was that the numerous packet-reassembly options were eliminated in favor of the new <code class="literal">reassemble</code> option, which simply turns reassembly on or off.</p><p>With the new <code class="literal">scrub</code> syntax, you need to supply at least one option in parentheses. The following works quite well for several networks in my care:</p><a id="pro_id00368"/><pre class="programlisting">match in all scrub (no-df max-mss 1440)</pre><p><a class="indexterm" id="iddle1057"/><a class="indexterm" id="iddle1877"/><a class="indexterm" id="iddle1878"/>This option clears the do-not-fragment bit and sets the maximum segment size to 1,440 bytes.</p><p>Other variations are possible, and even though the list of <code class="literal">scrub</code> options shrank somewhat for the OpenBSD 4.6 version, you should be able to cater to specific needs by consulting the man pages and doing some experimentation. For most setups, a global match rule like the one quoted earlier is appropriate, but keep in mind that you can vary <code class="literal">scrub</code> options on a per-rule basis if needed.</p><p>If you find yourself needing to debug a <code class="literal">scrub</code>-related problem, study the <code class="literal">pf.conf</code> man page and consult the gurus on the relevant mailing lists.</p></div><div class="sect2" title="Protecting Against Spoofing with antispoof"><div class="titlepage"><div><div><h3 class="title" id="protecting_against_spoofing_with_antispo">Protecting Against Spoofing with antispoof</h3></div></div></div><p>Some very useful and common packet-handling actions could be written as PF rules, but not without becoming long, complicated, and error-prone rule set boilerplate. Thus, <code class="literal">antispoof</code> was implemented for a common special case of filtering and blocking. This mechanism protects against activity from spoofed or forged IP addresses, mainly by blocking packets that appear on interfaces traveling in directions that aren’t logically possible.</p><p>With <code class="literal">antispoof</code>, you can specify that you want to weed out spoofed traffic coming in from the rest of the world as well as any spoofed packets that might originate in your own network. <a class="xref" href="ch10.html#antispoof_drops_packets_that_come_in_fro" title="Figure 10-1. antispoof drops packets that come in from the wrong network.">Figure 10-1</a> illustrates the concept.</p><div class="figure"><a id="antispoof_drops_packets_that_come_in_fro"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00021"/><img alt="antispoof drops packets that come in from the wrong network." src="httpatomoreillycomsourcenostarchimages2127169.png.jpg"/></div></div><div class="figure-title">Figure 10-1. antispoof drops packets that come in from the wrong network.</div></div><p><a class="indexterm" id="iddle1196"/><a class="indexterm" id="iddle1197"/><a class="indexterm" id="iddle1973"/>To establish the kind of protection depicted in the diagram, specify <code class="literal">antispoof</code> for both interfaces in the illustrated network with these two lines:</p><a id="pro_id00369"/><pre class="programlisting">antispoof for $ext_if&#13;
antispoof for $int_if</pre><p>These lines expand to complex rules. The first one blocks incoming traffic when the source address appears to be part of the network directly connected to the antispoofed interface but arrives on a different interface. The second rule performs the same functions for the internal interface, blocking any traffic with apparently local network addresses that arrive on interfaces other than <code class="literal">$int_if</code>. Keep in mind, however, that <code class="literal">antispoof</code> isn’t designed to detect address spoofing for remote networks that aren’t directly connected to the machine running PF.</p></div></div><div class="sect1" title="Testing Your Setup"><div class="titlepage"><div><div><h2 class="title" id="testing_your_setup" style="clear: both">Testing Your Setup</h2></div></div></div><p>Now it’s time to dust off the precise specification that describes how your setup <span class="emphasis"><em>should</em></span> work.</p><p>The physical layout of our sample network is centered on a <span class="emphasis"><em>gateway</em></span> connected to the Internet via <code class="literal">$ext_if</code>. Attached to the gateway via <code class="literal">$int_if</code> is a <span class="emphasis"><em>local network</em></span> with workstations and possibly one or more servers for local use. Finally, we have a <span class="emphasis"><em>DMZ</em></span> connected to <code class="literal">$dmz_if</code>, populated with servers offering services to the local network and the Internet. <a class="xref" href="ch10.html#network_with_servers_in_a_dmz" title="Figure 10-2. Network with servers in a DMZ">Figure 10-2</a> shows the logical layout of the network.</p><div class="figure"><a id="network_with_servers_in_a_dmz"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00022"/><img alt="Network with servers in a DMZ" src="httpatomoreillycomsourcenostarchimages2127171.png.jpg"/></div></div><div class="figure-title">Figure 10-2. Network with servers in a DMZ</div></div><p><a class="indexterm" id="iddle1974"/>The corresponding rule set specification looks something like this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Machines outside our network should have access to the services offered by our servers in the DMZ and should not have access to the local network.</p></li><li class="listitem"><p>The machines in our local network, attached to <code class="literal">$int_if</code>, should have access to the services offered by the servers in the DMZ and access to a defined list of services outside our network.</p></li><li class="listitem"><p>The machines in the DMZ should have access to some network services in the outside world.</p></li></ul></div><p>The task at hand is to make sure the rule set we have in place actually implements the specification. We need to test the setup. A useful test would be to try the sequence in <a class="xref" href="ch10.html#sample_rule_set_test_case_sequence" title="Table 10-1. Sample Rule Set Test Case Sequence">Table 10-1</a>.</p><p>Your configuration may call for other tests or could differ in some particulars, but your real-life test scenario should specify how packets and connections should be logged. The main point is that you should decide what the expected and desired result for each of your test cases should be before you start testing.</p><p>In general, you should test using the applications you expect the typical user to have, such as Web browsers or mail clients on various operating systems. The connections should simply succeed or fail, according to specifications. If one or more of your basic tests gives an unexpected result, move on to debugging your rule set.</p><div class="table"><a id="sample_rule_set_test_case_sequence"/><div class="table-title">Table 10-1. Sample Rule Set Test Case Sequence</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Test Action</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Expected Result</p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Try a connection from the local network to each allowed port on the servers in the DMZ.</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>The connection should pass.</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Try a connection from the local network to each allowed port on servers outside your network.</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>The connection should pass.</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Try a connection on any port from the DMZ to the local network.</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>The connection should be blocked.</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Try a connection from the DMZ to each allowed port on servers outside your network.</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>The connection should pass.</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Try a connection from outside your network to <code class="literal">$webserver</code> in the DMZ on each port in <code class="literal">$webports</code>.</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>The connection should pass.</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>The connection should pass.Try a connection from outside your network to <code class="literal">$webserver</code> in the DMZ on port 25 (SMTP).</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>The connection should be blocked.</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Try a connection from outside your network to <code class="literal">$emailserver</code> in the DMZ on port 80 (HTTP).</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>The connection should be blocked.</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Try a connection from outside your network to <code class="literal">$emailserver</code> in the DMZ on port 25 (SMTP).</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>The connection should pass.</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p>Try a connection from outside your network to one or more machines in the local network.</p></td><td style="vertical-align: top; "><p>The connection should be blocked.</p></td></tr></tbody></table></div></div></div><div class="sect1" title="Debugging Your Rule Set"><div class="titlepage"><div><div><h2 class="title" id="debugging_your_rule_set" style="clear: both">Debugging Your Rule Set</h2></div></div></div><p><a class="indexterm" id="iddle1170"/><a class="indexterm" id="iddle1639"/><a class="indexterm" id="iddle1654"/>When your configuration doesn’t behave as expected, there may be an error in the rule set logic, so you need to find the error and correct it. Tracking down logic errors in your rule set can be time-consuming and could involve manually evaluating your rule set—both as it’s stored in the <span class="emphasis"><em>pf.conf</em></span> file and as the loaded version after macro expansions and any optimizations.</p><p>Users often initially blame PF for issues that turn out to be basic network problems. Network interfaces set to wrong duplex settings, bad netmasks, and faulty network hardware are common culprits.</p><p>Before diving into the rule set itself, you can easily determine whether the PF configuration is causing the problem. To do so, disable PF with <code class="literal">pfctl -d</code> to see whether the problem disappears. If the problem persists when PF is disabled, you should turn to debugging other parts of your network configuration instead. If the problem disappears upon disabling PF and you’re about to start adjusting your PF configuration, make sure that PF is enabled and that your rule set is loaded with this command:</p><a id="pro_id00370"/><pre class="programlisting"><span class="strong"><strong>$ sudo pfctl -si | grep Status</strong></span>&#13;
Status: Enabled for 20 days 06:28:24          Debug: err</pre><p><code class="literal">Status: Enabled</code> tells us that PF is enabled, so we try viewing the loaded rules with a different <code class="literal">pfctl</code> command:</p><a id="pro_id00371"/><pre class="programlisting"><span class="strong"><strong>$ sudo pfctl -sr</strong></span>&#13;
match in all scrub (no-df max-mss 1440)&#13;
block return log all&#13;
block return log quick from &lt;bruteforce&gt; to any&#13;
anchor "ftp-proxy/*" all</pre><p>Here, <code class="literal">pfctl -sr</code> is equivalent to <code class="literal">pfctl -s rules</code>. The output is likely to be a bit longer than that shown here, but this is a good example of what you should expect to see when a rule set is loaded.</p><p>For debugging purposes, consider adding the <code class="literal">-vv</code> flag to the <code class="literal">pfctl</code> command line to see rule numbers and some additional debug information, like this:</p><a id="pro_id00372"/><pre class="programlisting"><span class="strong"><strong>$ sudo pfctl -vvsr</strong></span>&#13;
@0 match in all scrub (no-df max-mss 1440)&#13;
  [ Evaluations: 341770    Packets: 3417668   Bytes: 2112276585  States: 125  ]&#13;
  [ Inserted: uid 0 pid 14717 State Creations: 92254 ]&#13;
@1 match out on nfe0 inet from 10.0.0.0/8 to any queue(q_def, q_pri) nat-to&#13;
(nfe0:1) round-robin static-port&#13;
  [ Evaluations: 341770    Packets: 0         Bytes: 0           States: 0    ]&#13;
  [ Inserted: uid 0 pid 14717 State Creations: 0 ]&#13;
@2 match out on nfe0 inet from 192.168.103.0/24 to any queue(q_def, q_pri)&#13;
nat-to (nfe0:1) round-robin static-port&#13;
  [ Evaluations: 68623     Packets: 2138128   Bytes: 1431276138  States: 103  ]&#13;
  [ Inserted: uid 0 pid 14717 State Creations: 39109 ]&#13;
@3 block return log all&#13;
  [ Evaluations: 341770    Packets: 114929    Bytes: 62705138    States: 0    ]&#13;
  [ Inserted: uid 0 pid 14717 State Creations: 0 ]&#13;
@4 block return log (all) quick from &lt;bruteforce:0&gt; to any&#13;
  [ Evaluations: 341770    Packets: 2         Bytes: 104         States: 0    ]&#13;
  [ Inserted: uid 0 pid 14717 State Creations: 0 ]&#13;
@5 anchor "ftp-proxy/*" all&#13;
  [ Evaluations: 341768    Packets: 319954    Bytes: 263432399   States: 0    ]&#13;
  [ Inserted: uid 0 pid 14717 State Creations: 70 ]</pre><p><a class="indexterm" id="iddle1483"/><a class="indexterm" id="iddle1733"/><a class="indexterm" id="iddle1951"/><a class="indexterm" id="iddle1957"/>Now you should perform a structured walk-through of the loaded rule set. Find the rules that match the packets you’re investigating. What’s the last matching rule? If more than one rule matches, is one of the matching rules a <code class="literal">quick</code> rule? (As you probably recall from earlier chapters, when a packet matches a <code class="literal">quick</code> rule, evaluation stops, and whatever the <code class="literal">quick</code> rule specifies is what happens to the packet.) If so, you’ll need to trace the evaluation until you hit the end of the rule set or the packet matches a <code class="literal">quick</code> rule, which then ends the process. If your rule set walk-through ends somewhere other than the rule you were expecting to match your packet, you’ve found your logic error. Be sure to watch out for <code class="literal">match</code> rules. If you can’t determine why a specific packet matched a particular <code class="literal">block</code> or <code class="literal">pass</code> rule, the reason could be that a <code class="literal">match</code> rule applied an action that made the packet or connection match filtering criteria other than the expected ones.</p><p>Rule set logic errors tend to fall into three types:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Your rule doesn’t match because it’s never evaluated. A <code class="literal">quick</code> rule earlier in the rule set matched, and the evaluation stopped.</p></li><li class="listitem"><p>Your rule is evaluated but doesn’t match the packet after all, due to the rule’s criteria.</p></li><li class="listitem"><p>Your rule is evaluated and the rule matches, but the packet also matches another rule later in the rule set. The last matching rule is the one that determines what happens to your connection.</p></li></ul></div><p><a class="xref" href="ch09.html" title="Chapter 9. Logging, Monitoring, and Statistics">Chapter 9</a> introduced <code class="literal">tcpdump</code> as a valuable tool for reading and interpreting PF logs. The program is also very well suited for viewing the traffic that passes on a specific interface. What you learned about PF’s logs and how to use <code class="literal">tcpdump</code>’s filtering features will come in handy when you want to track down exactly which packets reach which interface.</p><p>Here’s an example of using <code class="literal">tcpdump</code> to watch for TCP traffic (but not SSH or SMTP traffic) on the <code class="literal">xl0</code> interface and to print the result in very verbose mode (<code class="literal">vvv</code>):</p><a id="pro_id00373"/><pre class="programlisting"><span class="strong"><strong>$ sudo tcpdump -nvvvpi xl0 tcp and not port ssh and not port smtp</strong></span>&#13;
tcpdump: listening on xl0, link-type EN10MB&#13;
21:41:42.395178 194.54.107.19.22418 &gt; 137.217.190.41.80: S [tcp sum ok]&#13;
3304153886:3304153886(0) win 16384 &lt;mss 1460,nop,nop,sackOK,nop,wscale&#13;
0,nop,nop,timestamp 1308370594 0&gt; (DF) (ttl 63, id 30934, len 64)&#13;
21:41:42.424368 137.217.190.41.80 &gt; 194.54.107.19.22418: S [tcp sum ok]&#13;
1753576798:1753576798(0) ack 3304153887 win 5792 &lt;mss 1460,sackOK,timestamp&#13;
168899231 1308370594,nop,wscale 9&gt; (DF) (ttl 53, id 0, len 60)</pre><p>The connection shown here is a successful connection to a website.</p><p>There are more interesting things to look for, though, such as connections that fail when they shouldn’t according to your specifications or connections that succeed when your specification says they clearly shouldn’t.</p><p>The test in these cases involves tracking the packets’ path through your configuration. Once more, it’s useful to check whether PF is enabled or whether disabling PF makes a difference. Building on the result from that initial test, you then perform the same kind of analysis of the rule set as described previously:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Once you have a reasonable theory of how the packets should traverse your rule set and your network interfaces, use <code class="literal">tcpdump</code> to see the traffic on each of the interfaces in turn.</p></li><li class="listitem"><p>Use <code class="literal">tcpdump</code>’s filtering features to extract only the information you need—that is, to see only the packets that should match your specific case, such as <code class="literal">port smtp and dst 192.0.2.19</code>.</p></li><li class="listitem"><p>Find the place where your assumptions no longer match the reality of your network traffic.</p></li><li class="listitem"><p>Turn on logging for the rules that may be involved and turn <code class="literal">tcpdump</code> loose on the relevant <code class="literal">pflog</code> interface to see which rule the packets actually match.</p></li></ul></div><p>The main outline for the test procedure is fairly fixed. If you’ve narrowed down the cause to your PF configuration, again, it’s a case of finding out which rules match and which rule ends up determining whether the packet passes or is blocked.</p></div><div class="sect1" title="Know Your Network and Stay in Control"><div class="titlepage"><div><div><h2 class="title" id="know_your_network_and_stay_in_control" style="clear: both">Know Your Network and Stay in Control</h2></div></div></div><p>The recurring theme in this book has been how PF and related tools make it relatively easy for you, as the network administrator, to take control of your network and to make it behave the way you want it to behave—in other words, how PF allows you to build the network you need.</p><p>Running a network can be fun, and I hope you’ve enjoyed this tour of what I consider to be the best tool available for network security. In presenting PF, I made a conscious decision early on to introduce you to the methods and ways of thinking via interesting and useful configurations, rather than offering a full catalog of available features or, for that matter, making this book the complete reference. The complete PF reference already exists in the man pages, which are updated every six months with the new OpenBSD releases. You can also find further information in the resources I’ve listed in <a class="xref" href="apa.html" title="Appendix A. Resources">Appendix A</a>.</p><p>Now that you have a broad, basic knowledge of what PF can do, you can start building the network according to your own ideas of what you need. You’ve reached the point where you can find your way around the man pages and locate the exact information you need. This is when the fun part starts!</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" id="ftn.ch10fn01"><p><sup>[<a class="para" href="#ch10fn01">49</a>] </sup>If you’ve yet to be hit by this particular kind of nastiness, you will be. Here’s a writeup about a DDOS situation where the hamfistedness was about equally distributed between both sides—the attacker and the attacked: <span class="emphasis"><em><a class="ulink" href="http://bsdly.blogspot.com/2012/12/ddos-bots-are-people-or-manned-by-some.html" target="_top">http://bsdly.blogspot.com/2012/12/ddos-bots-are-people-or-manned-by-some.html</a></em></span>. Your attackers will likely be smarter and better equipped than these.</p></div><div class="footnote" id="ftn.ch10fn02"><p><sup>[<a class="para" href="#ch10fn02">50</a>] </sup>Some notable attack techniques, including several historical denial-of-service setups, have exploited bugs in fragment handling that could lead to out-of-memory conditions or other resource exhaustion. One such exploit, which was aimed at Cisco’s PIX firewall series, is described in the advisory at <span class="emphasis"><em><a class="ulink" href="http://www.cisco.com/en/US/products/products_security_advisory09186a008011e78d.shtml" target="_top">http://www.cisco.com/en/US/products/products_security_advisory09186a008011e78d.shtml</a>.</em></span></p></div></div></section></body></html>