- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: How the Linux Kernel Boots
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核如何引导
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: You now know the physical and logical structure of a Linux system, what the
    kernel is, and how to work with processes. This chapter will teach you how the
    kernel starts, or *boots*. In other words, you’ll learn how the kernel moves into
    memory and what it does up to the point where the first user process starts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在了解了 Linux 系统的物理和逻辑结构，了解了内核是什么以及如何处理进程。本章将教你内核是如何启动的，或者说是如何**引导**的。换句话说，你将学习内核如何进入内存，并且它在第一个用户进程启动之前做了什么。
- en: 'A simplified view of the boot process looks like this:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 引导过程的简化视图如下所示：
- en: The machine’s BIOS or boot firmware loads and runs a boot loader.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 机器的 BIOS 或引导固件加载并运行引导加载程序。
- en: The boot loader finds the kernel image on disk, loads it into memory, and starts
    it.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引导加载程序找到磁盘上的内核镜像，加载到内存中并启动它。
- en: The kernel initializes the devices and its drivers.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内核初始化设备及其驱动程序。
- en: The kernel mounts the root filesystem.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内核挂载根文件系统。
- en: The kernel starts a program called *init* with a process ID of 1\. This point
    is the *user space start*.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内核启动一个名为 *init* 的程序，进程 ID 为 1。这个点就是 *用户空间启动*。
- en: init sets the rest of the system processes in motion.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: init 启动其余系统进程。
- en: At some point, init starts a process allowing you to log in, usually at the
    end or near the end of the boot sequence.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在某个时刻，init 启动一个进程，允许你登录，通常是在引导过程的末尾或接近末尾时。
- en: This chapter covers the first couple of stages, focusing on the boot loaders
    and kernel. Chapter 6 continues with the user space start by detailing *systemd*,
    the most widespread version of init on Linux systems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了引导过程的前几个阶段，重点讲解引导加载程序和内核。第6章继续讲解用户空间的启动，详细介绍了 *systemd*，这是 Linux 系统上最广泛使用的
    init 版本。
- en: Being able to identify each stage of the boot process will prove invaluable
    to you in fixing boot problems and understanding the system as a whole. However,
    the default behavior in many Linux distributions often makes it difficult, if
    not impossible, to identify the first few boot stages as they proceed, so you’ll
    probably be able to get a good look only after they’ve completed and you log in.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 能够识别引导过程的每个阶段，对解决引导问题和理解系统整体结构是非常宝贵的。然而，许多 Linux 发行版的默认行为常常使得在引导过程中难以甚至无法识别最初的几个引导阶段，因此你可能只能在它们完成并且你登录后才能清楚看到。
- en: 5.1 Startup Messages
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 启动消息
- en: Traditional Unix systems produce many diagnostic messages upon boot that tell
    you about the boot process. The messages come first from the kernel and then from
    processes and initialization procedures that init starts. However, these messages
    aren’t pretty or consistent, and in some cases they aren’t even very informative.
    In addition, hardware improvements have caused the kernel to start much faster
    than before; the messages flash by so quickly, it can be difficult to see what’s
    happening. As a result, most current Linux distributions do their best to hide
    boot diagnostics with splash screens and other forms of filler to distract you
    while the system starts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 Unix 系统在引导时会产生许多诊断消息，告诉你引导过程的情况。这些消息首先来自内核，然后来自 init 启动的进程和初始化程序。然而，这些消息既不美观也不一致，在某些情况下甚至不太有用。此外，硬件的改进使得内核启动比以前更快；消息快速闪过，可能让你很难看清发生了什么。因此，大多数当前的
    Linux 发行版都会尽量隐藏引导诊断信息，通过启动画面和其他形式的填充来分散你的注意力。
- en: The best way to view the kernel’s boot and runtime diagnostic messages is to
    retrieve the journal for the kernel with the `journalctl` command. Running `journalctl
    -k` displays the messages from the current boot, but you can view previous boots
    with the `-b` option. We’ll cover the journal in more detail in Chapter 7.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 查看内核引导和运行时诊断信息的最佳方式是通过 `journalctl` 命令检索内核的日志。运行 `journalctl -k` 可以显示当前引导的消息，但你也可以使用
    `-b` 选项查看以前的引导。我们将在第7章详细介绍日志。
- en: If you don’t have systemd, you can check for a logfile such as */var/log/kern.log*
    or run the `dmesg` command to view the messages in the *kernel ring buffer*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有 systemd，你可以检查类似 */var/log/kern.log* 的日志文件，或者运行 `dmesg` 命令查看 *内核环形缓冲区*
    中的消息。
- en: 'Here’s a sample of what you can expect to see from the `journalctl -k` command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可以从 `journalctl -k` 命令中看到的一个示例：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After the kernel has started, the user-space startup procedure often generates
    messages. These messages will likely be more difficult to view and review because
    on most systems you won’t find them in a single logfile. Startup scripts are designed
    to send messages to the console that are erased after the boot process finishes.
    However, this isn’t a problem on Linux systems because systemd captures diagnostic
    messages from startup and runtime that would normally go to the console.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核启动后，用户空间启动过程通常会生成一些消息。由于在大多数系统上你不会在单一的日志文件中找到这些消息，它们可能更难查看和回顾。启动脚本被设计为将消息发送到控制台，消息会在引导过程完成后被清除。然而，这在Linux系统上并不是问题，因为systemd会捕获启动和运行时的诊断消息，这些消息通常会发送到控制台。
- en: 5.2 Kernel Initialization and Boot Options
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 内核初始化和启动选项
- en: 'Upon startup, the Linux kernel initializes in this general order:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，Linux内核按照以下一般顺序初始化：
- en: CPU inspection
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CPU检查
- en: Memory inspection
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存检查
- en: Device bus discovery
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设备总线发现
- en: Device discovery
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设备发现
- en: Auxiliary kernel subsystem setup (networking and the like)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 辅助内核子系统设置（如网络）
- en: Root filesystem mount
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根文件系统挂载
- en: User space start
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户空间启动
- en: The first two steps aren’t too remarkable, but when the kernel gets to devices,
    the question of dependencies arises. For example, the disk device drivers may
    depend on bus support and SCSI subsystem support, as you saw in Chapter 3. Then,
    later in the initialization process, the kernel must mount a root filesystem before
    starting init.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个步骤并不特别引人注目，但当内核处理设备时，就会出现依赖性的问题。例如，磁盘设备驱动程序可能依赖于总线支持和SCSI子系统支持，正如你在第3章中看到的那样。然后，在初始化过程的后期，内核必须挂载根文件系统，然后才能启动init。
- en: In general, you won’t have to worry about the dependencies, except that some
    necessary components may be loadable kernel modules rather than part of the main
    kernel. Some machines may need to load these kernel modules before the true root
    filesystem is mounted. We’ll cover this problem and its initial RAM filesystem
    (initrd) workaround solutions in Section 6.7.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你不需要担心依赖关系，除了某些必要的组件可能是可加载的内核模块，而不是主内核的一部分。一些机器可能需要在真正的根文件系统挂载之前加载这些内核模块。我们将在第6.7节中讨论这个问题及其初始RAM文件系统（initrd）解决方法。
- en: 'The kernel emits certain kinds of messages indicating that it’s getting ready
    to start its first user process:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 内核发出某些类型的消息，表示它准备开始启动第一个用户进程：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, not only is the kernel cleaning up some unused memory, but it’s also
    protecting its own data. Then, if you’re running a new enough kernel, you’ll see
    the kernel start the first user-space process as init:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，内核不仅清理了一些未使用的内存，还保护了自己的数据。然后，如果你运行的是较新的内核，你将看到内核启动第一个用户空间进程——init：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Later on, you should be able to see the root filesystem being mounted and systemd
    starting up, sending a few messages of its own to the kernel log:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，你应该能够看到根文件系统被挂载，并且systemd开始启动，将一些自己的消息发送到内核日志：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At this point, you definitely know that user space has started.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你肯定知道用户空间已经启动。
- en: 5.3 Kernel Parameters
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 内核参数
- en: When the Linux kernel starts, it receives a set of text-based *kernel parameters*
    containing a few additional system details. The parameters specify many different
    types of behavior, such as the amount of diagnostic output the kernel should produce
    and device driver–specific options.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当Linux内核启动时，它会接收到一组基于文本的*内核参数*，其中包含一些额外的系统详细信息。这些参数指定了许多不同类型的行为，例如内核应该生成的诊断输出量和设备驱动程序特定的选项。
- en: 'You can view the parameters passed to your system’s currently running kernel
    by looking at the */proc/cmdline* file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看*/proc/cmdline*文件来查看传递给当前运行内核的参数：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The parameters are either simple one-word flags, such as `ro` and `quiet`, or
    `key``=``value` pairs, such as `vt.handoff=1`. Many of the parameters are unimportant,
    such as the `splash` flag for displaying a splash screen, but one that is critical
    is the `root` parameter. This is the location of the root filesystem; without
    it, the kernel cannot properly perform the user space start.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数可以是简单的单词标志，如`ro`和`quiet`，也可以是`key``=``value`对，如`vt.handoff=1`。许多参数并不重要，例如用于显示启动画面的`splash`标志，但一个关键的参数是`root`参数。这个参数是根文件系统的位置；没有它，内核无法正确执行用户空间启动。
- en: 'The root filesystem can be specified as a device file, as in this example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 根文件系统可以指定为设备文件，如下例所示：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'On most contemporary systems, there are two alternatives that are more common.
    First, you might see a logical volume such as this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数现代系统中，有两种更常见的选择。首先，你可能会看到一个逻辑卷，像这样：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You may also see a UUID (see Section 4.2.4):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能会看到一个UUID（请参见第4.2.4节）：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Both of these are preferable because they do not depend on a specific kernel
    device mapping.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者都是首选，因为它们不依赖于特定的内核设备映射。
- en: The `ro` parameter instructs the kernel to mount the root filesystem in read-only
    mode upon user space start. This is normal; read-only mode ensures that `fsck`
    can check the root filesystem safely before trying to do anything serious. After
    the check, the bootup process remounts the root filesystem in read-write mode.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`ro`参数指示内核在用户空间启动时以只读模式挂载根文件系统。这是正常的；只读模式确保在执行任何重要操作之前，`fsck`可以安全地检查根文件系统。检查之后，启动过程会将根文件系统重新挂载为读写模式。'
- en: Upon encountering a parameter that it doesn’t understand, the Linux kernel saves
    that parameter. The kernel later passes the parameter to init when performing
    the user space start. For example, if you add `-s` to the kernel parameters, the
    kernel passes the `-s` to the init program to indicate that it should start in
    single-user mode.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到它不理解的参数时，Linux内核会保存该参数。内核稍后会在执行用户空间启动时将该参数传递给init。例如，如果你将`-s`添加到内核参数中，内核会将`-s`传递给init程序，表示它应该以单用户模式启动。
- en: If you’re interested in the basic boot parameters, the bootparam(7) manual page
    gives an overview. If you’re looking for something very specific, you can check
    out *kernel-params.txt*, a reference file that comes with the Linux kernel.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对基本的引导参数感兴趣，可以查看bootparam(7)手册页，它提供了概述。如果你在寻找非常具体的信息，可以查看*kernel-params.txt*，这是一个随Linux内核一起提供的参考文件。
- en: With these basics covered, you should feel free to skip ahead to Chapter 6 to
    learn the specifics of user space start, the initial RAM disk, and the init program
    that the kernel runs as its first process. The remainder of this chapter details
    how the kernel loads into memory and starts, including how it gets its parameters.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了这些基础知识后，你可以跳到第6章，学习用户空间启动、初始RAM磁盘以及内核作为第一个进程运行的初始化程序的具体内容。本章的其余部分详细介绍了内核如何加载到内存并启动，包括它如何获取参数。
- en: 5.4 Boot Loaders
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 引导加载程序
- en: 'At the start of the boot process, before the kernel and init start, a *boot
    loader* program starts the kernel. The boot loader’s job sounds simple: it loads
    the kernel into memory from somewhere on a disk and then starts the kernel with
    a set of kernel parameters. However, this job is more complicated than it appears.
    To understand why, consider the questions that the boot loader must answer:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动过程中，内核和初始化程序启动之前，*引导加载程序*会启动内核。引导加载程序的工作听起来很简单：它从磁盘的某个位置将内核加载到内存中，然后用一组内核参数启动内核。然而，这项工作比看起来复杂。为了理解为什么，考虑引导加载程序必须回答的问题：
- en: Where is the kernel?
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核在哪里？
- en: What kernel parameters should be passed to the kernel when it starts?
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动时应传递给内核哪些内核参数？
- en: The answers are (typically) that the kernel and its parameters are usually somewhere
    on the root filesystem. It may sound like the kernel parameters should be easy
    to find, but remember that the kernel itself is not yet running, and it’s the
    kernel that usually traverses a filesystem to find the necessary files. Worse,
    the kernel device drivers normally used to access the disk are also unavailable.
    Think of this as a kind of “chicken or egg” problem. It can get even more complicated
    than this, but for now, let’s see how a boot loader overcomes the obstacles of
    the drivers and the filesystem.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 答案通常是：内核及其参数通常位于根文件系统的某个位置。听起来内核参数应该很容易找到，但请记住，内核本身还没有启动，通常是内核遍历文件系统来查找必要的文件。更糟糕的是，通常用于访问磁盘的内核设备驱动程序也不可用。可以将其看作是一种“先有鸡还是先有蛋”的问题。情况可能比这更复杂，但现在，我们来看看引导加载程序如何克服驱动程序和文件系统的障碍。
- en: A boot loader does need a driver to access the disk, but it’s not the same one
    that the kernel uses. On PCs, boot loaders use the traditional *Basic Input/Output
    System (BIOS)* or the newer *Unified Extensible Firmware Interface (UEFI)* to
    access disks. (*Extensible Firmware Interface*, or *EFI*, and UEFI will be discussed
    in more detail in Section 5.8.2.) Contemporary disk hardware includes firmware
    allowing the BIOS or UEFI to access attached storage hardware via *Logical Block
    Addressing (LBA)*. LBA is a universal, simple way to access data from any disk,
    but its performance is poor. This isn’t a problem, though, because boot loaders
    are often the only programs that must use this mode for disk access; after starting,
    the kernel has access to its own high-performance drivers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载器确实需要一个驱动程序来访问磁盘，但它并不是内核使用的那个驱动程序。在PC上，引导加载器使用传统的*基本输入输出系统（BIOS）*或较新的*统一可扩展固件接口（UEFI）*来访问磁盘。（*可扩展固件接口*，或*EFI*，以及UEFI将在第5.8.2节中详细讨论。）当代磁盘硬件包括固件，允许BIOS或UEFI通过*逻辑块寻址（LBA）*访问附加的存储硬件。LBA是一种通用的、简单的方式来访问任何磁盘上的数据，但其性能较差。然而，这不是问题，因为引导加载器通常是唯一必须使用这种模式来访问磁盘的程序；一旦启动，内核就可以访问其自己的高性能驱动程序。
- en: Once access to the disk’s raw data has been resolved, the boot loader must do
    the work of locating the desired data on the filesystem. Most common boot loaders
    can read partition tables and have built-in support for read-only access to filesystems.
    Thus, they can find and read the files that they need to get the kernel into memory.
    This capability makes it far easier to dynamically configure and enhance the boot
    loader. Linux boot loaders have not always had this capability; without it, configuring
    the boot loader was more difficult.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解决了对磁盘原始数据的访问问题，引导加载器必须完成在文件系统中定位所需数据的工作。大多数常见的引导加载器可以读取分区表，并且内置支持只读访问文件系统。因此，它们可以找到并读取它们需要的文件，将内核加载到内存中。这种能力使得动态配置和增强引导加载器变得更加容易。Linux引导加载器并不总是具备这种能力；没有它，配置引导加载器会更加困难。
- en: In general, there’s been a pattern of the kernel adding new features (especially
    in storage technology), followed by boot loaders adding separate, simplified versions
    of those features to compensate.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，内核添加新特性（尤其是在存储技术方面）后，引导加载器会增加这些特性的独立简化版本，以作补充。
- en: 5.4.1 Boot Loader Tasks
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 引导加载器任务
- en: 'A Linux boot loader’s core functionality includes the ability to do the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Linux引导加载器的核心功能包括以下几项：
- en: Select from multiple kernels.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从多个内核中进行选择。
- en: Switch between sets of kernel parameters.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内核参数集之间切换。
- en: Allow the user to manually override and edit kernel image names and parameters
    (for example, to enter single-user mode).
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户手动覆盖并编辑内核镜像名称和参数（例如，进入单用户模式）。
- en: Provide support for booting other operating systems.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供对启动其他操作系统的支持。
- en: Boot loaders have become considerably more advanced since the inception of the
    Linux kernel, with features such as command-line history and menu systems, but
    a basic need has always been flexibility in kernel image and parameter selection.
    (One surprising phenomenon is that some needs have actually diminished. For example,
    because you can perform an emergency or recovery boot from a USB storage device,
    you rarely have to worry about manually entering kernel parameters or going into
    single-user mode.) Current boot loaders offer more power than ever, which can
    be particularly handy if you’re building custom kernels or just want to tweak
    parameters.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 自Linux内核诞生以来，引导加载器已经变得相当先进，拥有命令行历史记录和菜单系统等功能，但其基本需求始终是灵活选择内核镜像和参数。（一个令人惊讶的现象是，一些需求实际上已经减少。例如，由于你可以从USB存储设备进行紧急或恢复启动，你几乎不需要担心手动输入内核参数或进入单用户模式。）当前的引导加载器比以往更强大，特别是在构建自定义内核或只是想调整参数时，它们非常方便。
- en: 5.4.2 Boot Loader Overview
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 引导加载器概述
- en: 'Here are the main boot loaders that you may encounter:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你可能遇到的主要引导加载器：
- en: '**GRUB** A near-universal standard on Linux systems, with BIOS/MBR and UEFI
    versions.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GRUB** 在Linux系统中几乎是通用标准，具有BIOS/MBR和UEFI版本。'
- en: '**LILO** One of the first Linux boot loaders. ELILO is a UEFI version.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**LILO** 最早的Linux引导加载器之一。ELILO是其UEFI版本。'
- en: '**SYSLINUX** Can be configured to run from many different kinds of filesystems.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SYSLINUX** 可以配置为从多种不同的文件系统中运行。'
- en: '**LOADLIN** Boots a kernel from MS-DOS.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**LOADLIN** 从MS-DOS启动内核。'
- en: '**systemd-boot **A simple UEFI boot manager.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**systemd-boot** 一个简单的UEFI引导管理器。'
- en: '**coreboot** (formerly LinuxBIOS) A high-performance replacement for the PC
    BIOS that can include a kernel.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**coreboot**（前身为LinuxBIOS） 一种高性能的PC BIOS替代品，可以包含内核。'
- en: '**Linux Kernel EFISTUB** A kernel plug-in for loading the kernel directly from
    a EFI/UEFI System Partition (ESP).'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Linux内核EFISTUB** 一个用于直接从EFI/UEFI系统分区（ESP）加载内核的内核插件。'
- en: '**efilinux** A UEFI boot loader intended to serve as a model and reference
    for other UEFI boot loaders.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**efilinux** 一个UEFI引导加载程序，旨在作为其他UEFI引导加载程序的模型和参考。'
- en: This book deals almost exclusively with GRUB. The rationale behind using other
    boot loaders is that they’re simpler to configure than GRUB, they’re faster, or
    they provide some other special-purpose functionality.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本书几乎完全讨论GRUB。使用其他引导加载程序的理由是它们比GRUB更容易配置，它们的速度更快，或者它们提供其他特定功能。
- en: You can learn a lot about a boot loader by getting to a boot prompt where you
    can enter a kernel name and parameters. To do this, you need to know how to get
    to a boot prompt or menu. Unfortunately, this can sometimes be difficult to figure
    out because Linux distributions heavily customize boot loader behavior and appearance.
    It’s usually impossible to tell just by watching the boot process which boot loader
    the distribution uses.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过进入一个引导提示符，输入内核名称和参数，从而了解很多关于引导加载程序的信息。要做到这一点，你需要知道如何进入引导提示符或菜单。不幸的是，这有时可能很难弄清楚，因为Linux发行版会对引导加载程序的行为和外观进行高度自定义。通常，仅通过观看引导过程无法判断发行版使用的是哪种引导加载程序。
- en: The next sections tell you how to get to a boot prompt in order to enter a kernel
    name and parameters. Once you’re comfortable with that, you’ll see how to configure
    and install a boot loader.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将告诉你如何进入引导提示符，以便输入内核名称和参数。一旦你熟悉了这一点，你将看到如何配置和安装引导加载程序。
- en: 5.5 GRUB Introduction
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 GRUB介绍
- en: GRUB stands for *Grand Unified Boot Loader*. We’ll cover GRUB 2, but there’s
    also an older version called GRUB Legacy that’s no longer in active use.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: GRUB代表*Grand Unified Boot Loader*。我们将介绍GRUB 2，但也有一个叫做GRUB Legacy的旧版本，目前已不再使用。
- en: One of GRUB’s most important capabilities is filesystem navigation that allows
    for easy kernel image and configuration selection. One of the best ways to see
    this in action and to learn about GRUB in general is to look at its menu. The
    interface is easy to navigate, but there’s a good chance that you’ve never seen
    it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: GRUB最重要的功能之一是文件系统导航，它允许轻松选择内核镜像和配置。了解GRUB的一种最佳方式是查看它的菜单。这个界面易于导航，但你很可能从未见过它。
- en: To access the GRUB menu, press and hold shift when your BIOS startup screen
    first appears, or esc if your system has UEFI. Otherwise, the boot loader configuration
    may not pause before loading the kernel. [Figure 5-1](#figure5-1) shows the GRUB
    menu.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问GRUB菜单，请在BIOS启动屏幕首次出现时按住shift键，或如果你的系统使用UEFI则按esc键。否则，在加载内核之前，引导加载程序配置可能不会暂停。[图
    5-1](#figure5-1)显示了GRUB菜单。
- en: '![f05001](image_fi/500402c05/f05001.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![f05001](image_fi/500402c05/f05001.png)'
- en: 'Figure 5-1: GRUB menu'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-1：GRUB菜单
- en: 'Try the following to explore the boot loader:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下操作以探索引导加载程序：
- en: Reboot or power on your Linux system.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启或开机你的Linux系统。
- en: Hold down shift during the BIOS self-test or esc at the firmware splash screen
    to get the GRUB menu. (Sometimes these screens are not visible, so you have to
    guess when to press the button.)
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在BIOS自检期间按住shift键，或在固件启动画面按esc键以进入GRUB菜单。（有时这些画面不可见，因此你必须猜测何时按下按钮。）
- en: Press e to view the boot loader configuration commands for the default boot
    option. You should see something like [Figure 5-2](#figure5-2) (you might have
    to scroll down to see all of the details).![f05002](image_fi/500402c05/f05002.png)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 e 键查看默认引导选项的引导加载程序配置命令。你应该看到类似[图 5-2](#figure5-2)的内容（你可能需要向下滚动才能看到所有细节）。![f05002](image_fi/500402c05/f05002.png)
- en: 'Figure 5-2: GRUB configuration editor'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 5-2：GRUB 配置编辑器
- en: This screen tells us that for this configuration, the root is set with a UUID,
    the kernel image is */boot/vmlinuz-4.15.0-45-generic*, and the kernel parameters
    include `ro`, `quiet`, and `splash`. The initial RAM filesystem is */boot/initrd.img-4.15.0-45-generic*.
    But if you’ve never seen this sort of configuration before, you might find it
    somewhat confusing. Why are there multiple references to `root`, and why are they
    different? Why is `insmod` here? If you’ve seen this before, you might remember
    that it’s a Linux kernel feature normally run by udevd.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该屏幕告诉我们，对于此配置，根目录是通过 UUID 设置的，内核镜像是*/boot/vmlinuz-4.15.0-45-generic*，内核参数包括
    `ro`、`quiet` 和 `splash`。初始 RAM 文件系统是*/boot/initrd.img-4.15.0-45-generic*。但如果你以前从未见过这种配置，可能会感到有些困惑。为什么有多个
    `root` 的引用，它们为什么不同？为什么这里有 `insmod`？如果你以前见过这些，你可能会记得这是一个 Linux 内核特性，通常由 udevd 运行。
- en: The double takes are warranted, because GRUB doesn’t *use* the Linux kernel
    (remember, its job is to *start* the kernel). The configuration you see consists
    wholly of features and commands internal to GRUB, which exists in its own separate
    world.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种反复思考是有原因的，因为 GRUB 并不*使用* Linux 内核（记住，它的工作是*启动*内核）。你看到的配置完全由 GRUB 内部的特性和命令组成，GRUB
    存在于它自己的独立世界中。
- en: The confusion stems partly from the fact that GRUB borrows terminology from
    many sources. GRUB has its own “kernel” and its own `insmod` command to dynamically
    load GRUB modules, completely independent of the Linux kernel. Many GRUB commands
    are similar to Unix shell commands; there’s even an `ls` command to list files.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种困惑部分来源于 GRUB 借用了来自多个来源的术语。GRUB 有自己的“内核”和 `insmod` 命令来动态加载 GRUB 模块，完全独立于 Linux
    内核。许多 GRUB 命令类似于 Unix shell 命令；甚至有一个 `ls` 命令用来列出文件。
- en: By far, the most confusion results from GRUB’s use of the word *root*. Normally,
    you think of root as your system’s root filesystem. In a GRUB configuration, this
    is a kernel parameter, located somewhere after the image name of the `linux` command.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，最大的困惑来自于 GRUB 对“root”一词的使用。通常，你会将 root 视为系统的根文件系统。在 GRUB 配置中，这是一个内核参数，位于
    `linux` 命令的镜像名称之后的某个位置。
- en: Every other reference to root in the configuration is to the GRUB root, which
    exists only inside of GRUB. The GRUB “root” is the filesystem where GRUB searches
    for kernel and RAM filesystem image files.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 配置中每个其他的 `root` 引用都是指 GRUB 根目录，它仅存在于 GRUB 内部。GRUB 的“根目录”是 GRUB 用来搜索内核和 RAM 文件系统镜像文件的文件系统。
- en: In [Figure 5-2](#figure5-2), the GRUB root is first set to a GRUB-specific device
    (`hd0,msdos1`), a default value for this configuration 1. In the next command,
    GRUB then searches for a particular UUID on a partition 2. If it finds that UUID,
    it sets the GRUB root to that partition.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 5-2](#figure5-2)中，GRUB 根目录首先设置为 GRUB 特定设备（`hd0,msdos1`），这是该配置的默认值 1。接下来的命令中，GRUB
    会在一个分区中搜索特定的 UUID 2。如果找到了该 UUID，它将把 GRUB 根目录设置为该分区。
- en: To wrap it up, the `linux` command’s first argument (`/boot/vmlinuz-`. . .)
    is the location of the Linux kernel image file 3. GRUB loads this file from the
    GRUB root. The `initrd` command is similar, specifying the file for the initial
    RAM filesystem covered in Chapter 6 4.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，`linux` 命令的第一个参数（`/boot/vmlinuz-`. . .）是 Linux 内核镜像文件的位置 3。GRUB 从 GRUB
    根目录加载此文件。`initrd` 命令类似，指定了用于初始 RAM 文件系统的文件，详细内容在第 6 章 4 中。
- en: You can edit this configuration inside GRUB; doing so is usually the easiest
    way to temporarily fix an erroneous boot. To permanently fix a boot problem, you’ll
    need to change the configuration (see Section 5.5.2), but for now, let’s go one
    step deeper and examine some GRUB internals with the command-line interface.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GRUB 内编辑此配置；这样做通常是临时修复启动错误的最简单方法。要永久修复启动问题，你需要更改配置（见第 5.5.2 节），但现在，让我们深入一步，使用命令行界面来检查一些
    GRUB 内部的内容。
- en: 5.5.1 Exploring Devices and Partitions with the GRUB Command Line
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.1 使用 GRUB 命令行探索设备和分区
- en: As you can see in [Figure 5-2](#figure5-2), GRUB has its own device-addressing
    scheme. For example, the first hard disk found is named hd0, followed by hd1,
    and so on. Device name assignments are subject to change, but fortunately GRUB
    can search all partitions for UUIDs to find the one where the kernel resides,
    as you just saw in [Figure 5-2](#figure5-2) with the `search` command.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[图 5-2](#figure5-2)中所见，GRUB 有自己的设备寻址方案。例如，找到的第一个硬盘被命名为 hd0，接着是 hd1，依此类推。设备名称的分配是有可能变化的，但幸运的是，GRUB
    可以搜索所有分区的 UUID，找到包含内核的那个分区，就像你刚刚在[图 5-2](#figure5-2)中看到的那样，使用 `search` 命令。
- en: Listing Devices
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列出设备
- en: 'To get a feel for how GRUB refers to the devices on your system, access the
    GRUB command line by pressing c at the boot menu or configuration editor. You
    should get the GRUB prompt:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解 GRUB 如何引用系统上的设备，通过在启动菜单或配置编辑器中按 c 进入 GRUB 命令行。你应该会看到 GRUB 提示符：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can enter any command here that you see in a configuration, but to get
    started, try a diagnostic command instead: `ls`. With no arguments, the output
    is a list of devices known to GRUB:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里输入你在配置中看到的任何命令，但为了开始，试试一个诊断命令：`ls`。没有参数时，输出将是 GRUB 已知的设备列表：
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, there is one main disk device denoted by `(hd0)` and a single
    partition `(hd0,msdos1)`. If there were a swap partition on the disk, it would
    show up as well, such as `(hd0,msdos5)`. The `msdos` prefix on the partitions
    tells you that the disk contains an MBR partition table; it would begin with `gpt`
    for GPT, found on UEFI systems. (There are even deeper combinations with a third
    identifier, where a BSD disklabel map resides inside a partition, but you won’t
    normally have to worry about this unless you’re running multiple operating systems
    on one machine.)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，存在一个主要的磁盘设备，表示为 `(hd0)`，以及一个单独的分区 `(hd0,msdos1)`。如果磁盘上有交换分区，它也会显示出来，如
    `(hd0,msdos5)`。分区上的 `msdos` 前缀表示该磁盘包含 MBR 分区表；如果是 GPT 分区表，则会以 `gpt` 开头，出现在 UEFI
    系统中。（甚至还可以有更深层次的组合，带有第三个标识符，其中 BSD 磁盘标签映射位于分区内部，但通常除非你在一台机器上运行多个操作系统，否则无需担心这个问题。）
- en: 'To get more detailed information, use `ls -l`. This command can be particularly
    useful because it displays any UUIDs of the partition filesystems. For example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取更详细的信息，可以使用 `ls -l`。这个命令特别有用，因为它会显示分区文件系统的任何 UUID。例如：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This particular disk has a Linux ext2/3/4 filesystem on the first MBR partition.
    Systems using a swap partition will show another partition, but you won’t be able
    to tell its type from the output.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的磁盘在第一个 MBR 分区上有一个 Linux ext2/3/4 文件系统。使用交换分区的系统将显示另一个分区，但你无法从输出中看出它的类型。
- en: File Navigation
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件导航
- en: 'Now let’s look at GRUB’s filesystem navigation capabilities. Determine the
    GRUB root with the `echo` command (recall that this is where GRUB expects to find
    the kernel):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看 GRUB 的文件系统导航功能。使用 `echo` 命令确定 GRUB 根目录（记得这是 GRUB 期望找到内核的位置）：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To use GRUB’s `ls` command to list the files and directories in that root,
    you can append a forward slash to the end of the partition:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 GRUB 的 `ls` 命令列出该根目录中的文件和目录，你可以在分区后加上一个斜杠：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Because it’s inconvenient to type the actual root partition, you can substitute
    the `root` variable to save yourself some time:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于直接输入实际的根分区不方便，你可以用 `root` 变量来节省时间：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The output is a short list of file and directory names on that partition’s filesystem,
    such as *etc/*, *bin/*, and *dev/*. This is now a completely different function
    of the GRUB `ls` command. Before, you were listing devices, partition tables,
    and perhaps some filesystem header information. Now you’re actually looking at
    the contents of filesystems.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的是该分区文件系统的简短文件和目录列表，如 *etc/*、*bin/* 和 *dev/*。这现在是 GRUB `ls` 命令的一个完全不同的功能。之前，你是在列出设备、分区表，可能还有一些文件系统头信息。现在，你实际上是在查看文件系统的内容。
- en: 'You can take a deeper look into the files and directories on a partition in
    a similar manner. For example, to inspect the */boot* directory, start with the
    following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以类似的方式深入查看分区上的文件和目录。例如，要查看 */boot* 目录，从以下命令开始：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can also view all currently set GRUB variables with the `set` command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过 `set` 命令查看所有当前设置的 GRUB 变量：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: One of the most important of these variables is `$prefix`, the filesystem and
    directory where GRUB expects to find its configuration and auxiliary support.
    We’ll discuss GRUB configuration next.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量中最重要的之一是 `$prefix`，这是 GRUB 期望找到其配置和辅助支持的文件系统和目录。接下来我们将讨论 GRUB 配置。
- en: Once you’ve finished with the GRUB command-line interface, you can press esc
    to return to the GRUB menu. Alternatively, if you’ve set all of the necessary
    configuration for boot (including the `linux` and possibly `initrd` variables),
    you can enter the `boot` command to boot that configuration. In any case, boot
    your system. We’re going to explore the GRUB configuration, and that’s best done
    when you have your full system available.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 完成 GRUB 命令行界面后，你可以按 esc 返回 GRUB 菜单。或者，如果你已设置好所有必要的启动配置（包括 `linux` 和可能的 `initrd`
    变量），你可以输入 `boot` 命令以启动该配置。无论如何，启动你的系统。我们将探索 GRUB 配置，最好在你能启动完整系统时进行。
- en: 5.5.2 GRUB Configuration
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.2 GRUB 配置
- en: The GRUB configuration directory is usually */boot/grub* or */boot/grub2*. It
    contains the central configuration file, *grub.cfg*, an architecture-specific
    directory such as *i386-pc* containing loadable modules with a *.mod* suffix,
    and a few other items such as fonts and localization information. We won’t modify
    *grub.cfg* directly; instead, we’ll use the `grub-mkconfig` command (or `grub2-mkconfig`
    on Fedora).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: GRUB 配置目录通常是 */boot/grub* 或 */boot/grub2*。它包含中央配置文件 *grub.cfg*，一个特定架构的目录（如 *i386-pc*），该目录包含带有
    *.mod* 后缀的可加载模块，还有一些其他项目，如字体和本地化信息。我们不会直接修改 *grub.cfg*；相反，我们将使用 `grub-mkconfig`
    命令（在 Fedora 中为 `grub2-mkconfig`）。
- en: Reviewing grub.cfg
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 审查 grub.cfg
- en: 'First, take a quick look at *grub.cfg* to see how GRUB initializes its menu
    and kernel options. You’ll see that the file consists of GRUB commands, which
    usually begin with a number of initialization steps followed by a series of menu
    entries for different kernel and boot configurations. The initialization isn’t
    complicated, but there are a lot of conditionals at the beginning that might lead
    you to believe otherwise. This first part just consists of a bunch of function
    definitions, default values, and video setup commands such as this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，快速查看 *grub.cfg*，了解 GRUB 是如何初始化其菜单和内核选项的。你会看到该文件由 GRUB 命令组成，通常以一系列初始化步骤开始，接着是不同内核和启动配置的菜单项。初始化部分并不复杂，但开始部分有很多条件语句，可能会让你误以为这很复杂。第一部分只是由一堆函数定义、默认值和视频设置命令组成，例如：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Later in the configuration file, you’ll find the available boot configurations,
    each beginning with the `menuentry` command. You should be able to read and understand
    this example based on what you learned in the preceding section:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置文件的后面，你会找到可用的启动配置，每个配置都以 `menuentry` 命令开头。你应该能够根据前面部分学到的内容，理解这个示例：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Examine your *grub.cfg* file for `submenu` commands containing multiple `menuentry`
    commands. Many distributions use the `submenu` command for older versions of the
    kernel so that they don’t crowd the GRUB menu.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你的 *grub.cfg* 文件，查找包含多个 `menuentry` 命令的 `submenu` 命令。许多发行版使用 `submenu` 命令来管理旧版本的内核，以避免它们挤占
    GRUB 菜单。
- en: Generating a New Configuration File
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成新配置文件
- en: If you want to make changes to your GRUB configuration, don’t edit your *grub.cfg*
    file directly, because it’s automatically generated and the system occasionally
    overwrites it. You’ll set up your new configuration elsewhere and then run `grub-mkconfig`
    to generate the new configuration.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更改 GRUB 配置，不要直接编辑 *grub.cfg* 文件，因为它是自动生成的，并且系统会定期覆盖它。你应该在其他地方设置新的配置，然后运行
    `grub-mkconfig` 以生成新的配置。
- en: 'To see how the configuration generation works, look at the very beginning of
    *grub.cfg*. There should be comment lines such as this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解配置生成是如何工作的，可以查看 *grub.cfg* 的开头部分。应该有这样的注释行：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Upon further inspection, you’ll find that nearly every file in */etc/grub.d*
    is a shell script that produces a piece of the *grub.cfg* file. The `grub-mkconfig`
    command itself is a shell script that runs everything in */etc/grub.d*. Keep in
    mind that GRUB itself does not run these scripts at boot time; we run the scripts
    in user space to generate the *grub.cfg* file that GRUB runs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 经过进一步检查，你会发现 */etc/grub.d* 中几乎每个文件都是一个 shell 脚本，用于生成 *grub.cfg* 文件的一部分。`grub-mkconfig`
    命令本身就是一个 shell 脚本，它会执行 */etc/grub.d* 中的所有内容。请记住，GRUB 本身不会在启动时运行这些脚本；我们在用户空间运行这些脚本，以生成
    GRUB 运行的 *grub.cfg* 文件。
- en: Try it yourself as root. Don’t worry about overwriting your current configuration.
    This command by itself simply prints the configuration to the standard output.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以 root 身份自己操作。不要担心覆盖当前配置。此命令本身只是将配置打印到标准输出。
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What if you want to add menu entries and other commands to the GRUB configuration?
    The short answer is that you should put your customizations into a new *custom.cfg*
    file in your GRUB configuration directory (usually */boot/grub/custom.cfg*).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想向 GRUB 配置中添加菜单项和其他命令该怎么办？简短的回答是，你应该将自定义内容放入 GRUB 配置目录中的一个新的 *custom.cfg*
    文件中（通常是 */boot/grub/custom.cfg*）。
- en: 'The long answer is a little more complicated. The */etc/grub.d* configuration
    directory gives you two options: *40_custom* and *41_custom*. The first, *40_custom*,
    is a script that you can edit yourself, but it’s the least stable; a package upgrade
    is likely to destroy any changes you make. The *41_custom* script is simpler;
    it’s just a series of commands that load *custom.cfg* when GRUB starts. If you
    choose this second option, your changes won’t appear when you generate your configuration
    file because GRUB does all of the work at boot time.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 长答案稍微复杂一些。*/etc/grub.d* 配置目录为您提供了两个选项：*40_custom* 和 *41_custom*。第一个，*40_custom*，是一个您可以自己编辑的脚本，但它的稳定性最差；软件包升级可能会破坏您所做的任何更改。*41_custom*
    脚本较为简单；它只是一系列命令，在 GRUB 启动时加载 *custom.cfg*。如果选择第二个选项，您的更改在生成配置文件时不会显示，因为 GRUB 在启动时会完成所有工作。
- en: The two options for custom configuration files aren’t particularly extensive,
    and there’s nothing stopping you from adding your own scripts to generate configuration
    data. You might see some additions specific to your particular distribution in
    the */etc/grub.d* directory. For example, Ubuntu adds memory tester boot options
    (`memtest86+`) to the configuration.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义配置文件的两个选项并不是特别广泛，而且没有什么能阻止您添加自己的脚本来生成配置数据。您可能会在 */etc/grub.d* 目录中看到一些特定于您特定发行版的附加内容。例如，Ubuntu
    会将内存测试引导选项（`memtest86+`）添加到配置中。
- en: 'To write and install a newly generated GRUB configuration file, you can write
    the configuration to your GRUB directory with the `-o` option to `grub-mkconfig`,
    like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入并安装新生成的 GRUB 配置文件，您可以使用 `-o` 选项将配置写入 GRUB 目录，像这样使用 `grub-mkconfig`：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As usual, back up your old configuration and make sure that you’re installing
    to the correct directory.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，备份您的旧配置并确保您正在安装到正确的目录。
- en: Now we’re going to get into some of the more technical details of GRUB and boot
    loaders. If you’re tired of hearing about boot loaders and the kernel, skip to
    Chapter 6.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将深入讨论一些更技术性的 GRUB 和引导加载程序的细节。如果您厌倦了听引导加载程序和内核的内容，可以跳到第六章。
- en: 5.5.3 GRUB Installation
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.3 GRUB 安装
- en: Installing GRUB is more involved than configuring it. Fortunately, you won’t
    normally have to worry about installation because your distribution should handle
    it for you. However, if you’re trying to duplicate or restore a bootable disk,
    or preparing your own boot sequence, you might need to install it on your own.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 GRUB 比配置它要复杂一些。幸运的是，通常您无需担心安装，因为您的发行版应该会为您处理它。然而，如果您试图复制或恢复一个可启动磁盘，或者准备自己的引导顺序，您可能需要自行安装。
- en: 'Before proceeding, read Section 5.4 to get an idea of how PCs boot and determine
    whether you’re using MBR or UEFI boot. Next, build the GRUB software set and determine
    where your GRUB directory will be; the default is */boot/grub*. You may not need
    to build GRUB if your distribution does it for you, but if you do, see Chapter
    16 for how to build software from source code. Make sure that you build the correct
    target: it’s different for MBR or UEFI boot (and there are even differences between
    32-bit and 64-bit EFI).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，阅读第 5.4 节，了解 PC 如何启动，并确定您是使用 MBR 还是 UEFI 启动。接下来，构建 GRUB 软件集并确定您的 GRUB
    目录将在哪里；默认情况下是 */boot/grub*。如果您的发行版为您处理了 GRUB，您可能不需要构建它，但如果需要，请参阅第 16 章了解如何从源代码构建软件。确保构建正确的目标：MBR
    或 UEFI 启动有所不同（32 位和 64 位 EFI 之间甚至存在差异）。
- en: Installing GRUB on Your System
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在您的系统上安装 GRUB
- en: 'Installing the boot loader requires that you or an installer program determine
    the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 安装引导加载程序需要您或安装程序确定以下内容：
- en: The target GRUB directory as seen by your currently running system. As just
    mentioned, that’s usually */boot/grub*, but it might be different if you’re installing
    GRUB on another disk for use on another system.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前运行系统所看到的目标 GRUB 目录。如前所述，通常是 */boot/grub*，但如果您正在将 GRUB 安装到另一个磁盘以供其他系统使用，它可能会有所不同。
- en: The current device of the GRUB target disk.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GRUB 目标磁盘的当前设备。
- en: For UEFI booting, the current mount point of the EFI system partition (usually
    */boot/efi*).
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 UEFI 启动，当前的 EFI 系统分区挂载点（通常是 */boot/efi*）。
- en: Remember that GRUB is a modular system, but in order to load modules, it must
    read the filesystem that contains the GRUB directory. Your task is to construct
    a version of GRUB capable of reading that filesystem so that it can load the rest
    of its configuration (*grub.cfg*) and any required modules. On Linux, this usually
    means building a version of GRUB with its *ext2.mod* module (and possibly *lvm.mod*)
    preloaded. Once you have this version, all you need to do is place it on the bootable
    part of the disk and place the rest of the required files into */boot/grub*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，GRUB 是一个模块化系统，但为了加载模块，它必须读取包含 GRUB 目录的文件系统。你的任务是构建一个能够读取该文件系统的 GRUB 版本，以便它能够加载其余的配置文件
    (*grub.cfg*) 和所需的模块。在 Linux 上，这通常意味着构建一个预加载了 *ext2.mod* 模块（可能还包括 *lvm.mod*）的 GRUB
    版本。一旦你有了这个版本，你所需要做的就是将其放置在可启动的磁盘部分，并将其余所需的文件放入 */boot/grub* 中。
- en: 'Fortunately, GRUB comes with a utility called `grub-install` (not to be confused
    with `install-grub`, which you might find on some older systems), which performs
    most of the work of installing the GRUB files and configuration for you. For example,
    if your current disk is at */dev/sda* and you want to install GRUB on that disk’s
    MBR with your current */boot/grub* directory, use this command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，GRUB 提供了一个名为 `grub-install` 的工具（不要与某些旧系统中可能找到的 `install-grub` 混淆），该工具可以为你完成大部分安装
    GRUB 文件和配置的工作。例如，如果你当前的磁盘是 */dev/sda*，并且你想在该磁盘的 MBR 上安装 GRUB，并使用当前的 */boot/grub*
    目录，可以使用以下命令：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Installing GRUB Using MBR on an External Storage Device
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在外部存储设备上使用 MBR 安装 GRUB
- en: 'To install GRUB on a storage device outside the current system, you must manually
    specify the GRUB directory on that device as your current system now sees it.
    For example, say you have a target device of */dev/sdc* and that device’s root
    filesystem containing */boot* (for example, */dev/sdc1*) is mounted on */mnt*
    of your current system. This implies that when you install GRUB, your current
    system will see the GRUB files in */mnt/boot/grub*. When running `grub-install`,
    tell it where those files should go as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要在当前系统之外的存储设备上安装 GRUB，你必须手动指定该设备上的 GRUB 目录，因为你当前的系统会看到这个设备的目录。例如，假设你有一个目标设备
    */dev/sdc*，并且该设备的根文件系统包含 */boot*（例如，*/dev/sdc1*）已挂载在当前系统的 */mnt* 上。这意味着当你安装 GRUB
    时，当前系统将会看到 */mnt/boot/grub* 中的 GRUB 文件。在运行 `grub-install` 时，告诉它这些文件应该放置的位置，如下所示：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: On most MBR systems, */boot* is a part of the root filesystem, but some installations
    put */boot* into its own separate filesystem. Make sure that you know where your
    target */boot* resides.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 MBR 系统中，*/boot* 是根文件系统的一部分，但一些安装将 */boot* 放置在单独的文件系统中。确保你知道目标 */boot* 所在的位置。
- en: Installing GRUB with UEFI
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 UEFI 安装 GRUB
- en: 'UEFI installation is supposed to be easier, because all you have to do is copy
    the boot loader into place. But you also need to “announce” the boot loader to
    the firmware—that is, save the loader configuration to the NVRAM—with the `efibootmgr`
    command. The `grub-install` command runs this if it’s available, so normally you
    can install GRUB on a UEFI system like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI 安装应该更简单，因为你所需要做的只是将引导加载程序复制到指定位置。但你还需要通过 `efibootmgr` 命令“公告”引导加载程序给固件，也就是将加载程序配置保存到
    NVRAM 中。如果 `grub-install` 命令可用，它会自动运行此操作，因此通常你可以像这样在 UEFI 系统上安装 GRUB：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, `efi_dir` is where the UEFI directory appears on your current system (usually
    */boot/efi/EFI*, because the UEFI partition is typically mounted at */boot/efi*)
    and `name` is an identifier for the boot loader.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`efi_dir` 是当前系统中 UEFI 目录所在的位置（通常是 */boot/efi/EFI*，因为 UEFI 分区通常挂载在 */boot/efi*），而
    `name` 是引导加载程序的标识符。
- en: Unfortunately, many problems can crop up when you’re installing a UEFI boot
    loader. For example, if you’re installing to a disk that will eventually end up
    in another system, you have to figure out how to announce that boot loader to
    the new system’s firmware. And there are differences in the install procedure
    for removable media.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在安装 UEFI 引导加载程序时可能会遇到很多问题。例如，如果你要安装到最终会进入另一个系统的磁盘，你必须弄清楚如何将该引导加载程序公告给新系统的固件。而且，针对可移动媒体的安装过程也存在差异。
- en: But one of the biggest problems is UEFI secure boot.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 但其中一个最大的问题是 UEFI 安全启动。
- en: 5.6 UEFI Secure Boot Problems
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 UEFI 安全启动问题
- en: One newer problem affecting Linux installations is dealing with the *secure
    boot* feature found on recent PCs. When active, this UEFI mechanism requires any
    boot loader to be digitally signed by a trusted authority in order to run. Microsoft
    has required hardware vendors shipping Windows 8 and later with their systems
    to use secure boot. The result is that if you try to install an unsigned boot
    loader on these systems, the firmware will reject the loader and the operating
    system won’t load.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一个影响Linux安装的较新问题是处理最近PC中发现的*安全启动*功能。当启用时，此UEFI机制要求任何启动加载器必须由受信任的机构进行数字签名才能运行。微软要求硬件供应商在提供Windows
    8及以后版本的系统时，必须使用安全启动。结果是，如果你试图在这些系统上安装未签名的启动加载器，固件会拒绝该加载器，操作系统将无法启动。
- en: Major Linux distributions have no problem with secure boot because they include
    signed boot loaders, usually based on a UEFI version of GRUB. Often there’s a
    small signed shim that goes between UEFI and GRUB; UEFI runs the shim, which in
    turn executes GRUB. Protecting against booting unauthorized software is an important
    feature if your machine is not in a trustworthy environment or needs to meet certain
    security requirements, so some distributions go a step further and require that
    the entire boot sequence (including the kernel) be signed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的Linux发行版在安全启动方面没有问题，因为它们包含已签名的启动加载器，通常是基于UEFI版本的GRUB。通常会有一个小的已签名的shim，它位于UEFI和GRUB之间；UEFI运行shim，shim再执行GRUB。如果你的计算机不在可信环境中，或者需要满足某些安全要求，保护防止启动未经授权的软件是一个重要功能，因此一些发行版更进一步，要求整个启动过程（包括内核）都必须被签名。
- en: There are some disadvantages to secure boot systems, especially for someone
    experimenting with building their own boot loaders. You can get around the secure
    boot requirement by disabling it in the UEFI settings. However, this won’t work
    cleanly for dual-boot systems since Windows won’t run without secure boot enabled.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 安全启动系统有一些缺点，特别是对于那些尝试构建自己启动加载器的人来说。你可以通过在UEFI设置中禁用它来绕过安全启动要求。然而，这对于双启动系统来说无法干净地工作，因为Windows在未启用安全启动的情况下无法运行。
- en: 5.7 Chainloading Other Operating Systems
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7 链式引导其他操作系统
- en: UEFI makes it relatively easy to support loading other operating systems because
    you can install multiple boot loaders in the EFI partition. However, the older
    MBR style doesn’t support this functionality, and even if you do have UEFI, you
    may still have an individual partition with an MBR-style boot loader that you
    want to use. Instead of configuring and running a Linux kernel, GRUB can load
    and run a different boot loader on a specific partition on your disk; this is
    called *chainloading*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: UEFI使得支持加载其他操作系统相对容易，因为你可以在EFI分区中安装多个启动加载器。然而，较旧的MBR风格不支持此功能，即使你拥有UEFI，你可能仍然会有一个带MBR风格启动加载器的单独分区，你可能希望使用它。GRUB可以加载并在磁盘的特定分区上运行不同的启动加载器，而不是配置和运行Linux内核；这就是所谓的*链式引导*。
- en: 'To chainload, create a new menu entry in your GRUB configuration (using one
    of the methods described in the section “Generating a New Configuration File”).
    Here’s an example for a Windows installation on the third partition of a disk:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行链式引导，请在GRUB配置中创建一个新的菜单项（使用“生成新配置文件”部分中描述的方法之一）。以下是一个关于在磁盘第三分区上安装Windows的示例：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `+1` option tells `chainloader` to load whatever is at the first sector
    of a partition. You can also get it to directly load a file, by using a line like
    this to load the *io.sys* MS-DOS loader:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`+1`选项告诉`chainloader`加载分区的第一个扇区中的内容。你还可以通过使用类似的命令直接加载一个文件，例如加载*io.sys* MS-DOS加载器：'
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 5.8 Boot Loader Details
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.8 启动加载器详细信息
- en: 'Now we’ll look quickly at some boot loader internals. To understand how boot
    loaders like GRUB work, first we’ll survey how a PC boots when you turn it on.
    Because they must address the many inadequacies of traditional PC boot mechanisms,
    boot loading schemes have several variations, but there are two main ones: MBR
    and UEFI.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们快速看一下启动加载器的内部工作原理。为了理解像GRUB这样的启动加载器是如何工作的，我们首先来了解一下当你打开PC时它是如何启动的。由于必须解决传统PC启动机制的许多不足，启动加载方案有几种变化，但主要有两种：MBR和UEFI。
- en: 5.8.1 MBR Boot
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8.1 MBR启动
- en: In addition to the partition information described in Section 4.1, the MBR includes
    a small area of 441 bytes that the PC BIOS loads and executes after its Power-On
    Self-Test (POST). Unfortunately, this space is inadequate to house almost any
    boot loader, so additional space is necessary, resulting in what is sometimes
    called a *multistage boot loader*. In this case the initial piece of code in the
    MBR does nothing other than load the rest of the boot loader code. The remaining
    pieces of the boot loader are usually stuffed into the space between the MBR and
    the first partition on the disk. This isn’t terribly secure because anything can
    overwrite the code there, but most boot loaders do it, including most GRUB installations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第 4.1 节中描述的分区信息外，MBR 还包括一个 441 字节的小区域，PC BIOS 会在自检（POST）后加载并执行该区域的内容。不幸的是，这个空间不足以容纳几乎任何引导加载程序，因此需要额外的空间，这就导致了有时被称为
    *多阶段引导加载程序* 的情况。在这种情况下，MBR 中的初始代码除了加载其余的引导加载程序代码外不做任何事情。引导加载程序的其余部分通常会被塞入 MBR
    和磁盘上第一个分区之间的空间中。这并不特别安全，因为任何东西都可以覆盖那里存放的代码，但大多数引导加载程序都这么做，包括大多数 GRUB 安装。
- en: This scheme of shoving the boot loader code after the MBR doesn’t work with
    a GPT-partitioned disk using the BIOS to boot because the GPT information resides
    in the area after the MBR. (GPT leaves the traditional MBR alone for backward
    compatibility.) The workaround for GPT is to create a small partition called a
    *BIOS boot partition* with a special UUID (`21686148-6449-6E6F-744E-656564454649`)
    to give the full boot loader code a place to reside. However, this isn’t a common
    configuration, because GPT is normally used with UEFI, not the traditional BIOS.
    It’s usually found only in older systems that have very large disks (greater than
    2TB); these are too large for MBR.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 BIOS 启动的 GPT 分区磁盘上，传统的将引导加载程序代码放在 MBR 之后的方式不起作用，因为 GPT 信息位于 MBR 后面的区域。（GPT
    为了向后兼容，保留了传统的 MBR。）GPT 的解决方法是创建一个名为 *BIOS 启动分区* 的小分区，使用特殊的 UUID（`21686148-6449-6E6F-744E-656564454649`）为完整的引导加载程序代码提供一个存放位置。然而，这并不是一种常见配置，因为
    GPT 通常与 UEFI 一起使用，而不是传统的 BIOS。它通常只出现在具有非常大磁盘（大于 2TB）的旧系统中，这些磁盘太大，无法使用 MBR。
- en: 5.8.2 UEFI Boot
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8.2 UEFI 启动
- en: PC manufacturers and software companies realized that the traditional PC BIOS
    is severely limited, so they decided to develop a replacement called Extensible
    Firmware Interface (EFI), which we’ve already discussed a bit in a few places
    in this chapter. EFI took a while to catch on for most PCs, but today it’s the
    most common, especially now that Microsoft requires secure boot for Windows. The
    current standard is Unified EFI (UEFI), which includes features such as a built-in
    shell and the ability to read partition tables and navigate filesystems. The GPT
    partitioning scheme is part of the UEFI standard.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: PC 制造商和软件公司意识到传统的 PC BIOS 存在严重的局限性，因此他们决定开发一个替代方案，称为可扩展固件接口（EFI），我们在本章的多个地方已经简要讨论过
    EFI。虽然 EFI 花了一些时间才在大多数 PC 上得到普及，但如今它已经成为最常见的标准，尤其是在微软要求 Windows 启用安全启动之后。目前的标准是统一
    EFI（UEFI），它包括内置 shell、读取分区表和浏览文件系统的能力等功能。GPT 分区方案是 UEFI 标准的一部分。
- en: Booting is radically different on UEFI systems compared to MBR. For the most
    part, it’s much easier to understand. Rather than executable boot code residing
    outside of a filesystem, there’s always a special VFAT filesystem called the EFI
    System Partition (ESP), which contains a directory named *EFI*. The ESP is usually
    mounted on your Linux system at */boot/efi*, so you’ll probably find most of the
    EFI directory structure starting at */boot/efi/EFI*. Each boot loader has its
    own identifier and a corresponding subdirectory, such as *efi/microsoft*, *efi/apple*,
    *efi/ubuntu*, or *efi/grub*. A boot loader file has a *.efi* extension and resides
    in one of these subdirectories, along with other supporting files. If you go exploring,
    you might find files such as *grubx64.efi* (the EFI version of GRUB) and *shimx64.efi*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UEFI 系统上，启动过程与 MBR 系统截然不同。大多数情况下，它更容易理解。与其将可执行的引导代码存放在文件系统之外，UEFI 系统总是有一个名为
    EFI 系统分区（ESP）的特殊 VFAT 文件系统，该分区包含一个名为 *EFI* 的目录。ESP 通常挂载在你的 Linux 系统的 */boot/efi*
    目录下，因此你很可能会在 */boot/efi/EFI* 开始找到大部分 EFI 目录结构。每个引导加载程序都有自己的标识符和相应的子目录，例如 *efi/microsoft*、*efi/apple*、*efi/ubuntu*
    或 *efi/grub*。引导加载程序文件具有 *.efi* 扩展名，并位于这些子目录中，与其他支持文件一起。如果你进行探索，可能会发现一些文件，比如 *grubx64.efi*（GRUB
    的 EFI 版本）和 *shimx64.efi*。
- en: 'There’s a wrinkle, though: you can’t just put old boot loader code into the
    ESP, because the old code was written for the BIOS interface. Instead, you must
    provide a boot loader written for UEFI. For example, when using GRUB, you must
    install the UEFI version of GRUB rather than the BIOS version. And, as explained
    earlier in “Installing GRUB with UEFI,” you must announce new boot loaders to
    the firmware.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一个问题：你不能直接把旧的引导加载程序代码放入ESP中，因为旧的代码是为BIOS接口编写的。相反，你必须提供一个为UEFI编写的引导加载程序。例如，使用GRUB时，你必须安装UEFI版本的GRUB，而不是BIOS版本。而且，正如在《使用UEFI安装GRUB》中解释的那样，你必须将新的引导加载程序宣布给固件。
- en: Finally, as Section 5.6 noted, we have to contend with the “secure boot” issue.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如第5.6节所述，我们必须应对“安全引导”问题。
- en: 5.8.3 How GRUB Works
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8.3 GRUB的工作原理
- en: 'Let’s wrap up our discussion of GRUB by looking at how it does its work:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过看看GRUB是如何工作的来总结我们的讨论：
- en: The PC BIOS or firmware initializes the hardware and searches its boot-order
    storage devices for boot code.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PC BIOS或固件初始化硬件，并搜索其引导顺序存储设备中的引导代码。
- en: Upon finding the boot code, the BIOS/firmware loads and executes it. This is
    where GRUB begins.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在找到引导代码后，BIOS/固件加载并执行它。这是GRUB开始的地方。
- en: The GRUB core loads.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GRUB核心加载。
- en: The core initializes. At this point, GRUB can now access disks and filesystems.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 核心初始化。此时，GRUB现在可以访问磁盘和文件系统。
- en: GRUB identifies its boot partition and loads a configuration there.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GRUB识别其引导分区并加载配置。
- en: GRUB gives the user a chance to change the configuration.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GRUB给用户一个机会来更改配置。
- en: After a timeout or user action, GRUB executes the configuration (the sequence
    of commands in the *grub.cfg* file, as outlined in Section 5.5.2).
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在超时或用户操作后，GRUB执行配置（即*grub.cfg*文件中的命令序列，如第5.5.2节所述）。
- en: In the course of executing the configuration, GRUB may load additional code
    (modules) in the boot partition. Some of these modules may be preloaded.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行配置的过程中，GRUB可能会加载额外的代码（模块）到引导分区。一些模块可能是预加载的。
- en: GRUB executes a `boot` command to load and execute the kernel as specified by
    the configuration’s `linux` command.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GRUB执行`boot`命令来加载并执行配置中的`linux`命令所指定的内核。
- en: 'Steps 3 and 4 of this sequence, where the GRUB core loads, can be complicated
    due to the inadequacies of traditional PC boot mechanisms. The biggest question
    is “Where *is* the GRUB core?” There are three basic possibilities:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此序列中的第3步和第4步，在GRUB核心加载时，可能会因传统PC引导机制的不足而变得复杂。最大的问题是“GRUB核心*在哪里*？”有三种基本可能性：
- en: Partially stuffed between the MBR and the beginning of the first partition
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分被填充在MBR和第一个分区的开始之间
- en: In a regular partition
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在常规分区中
- en: 'In a special boot partition: a GPT boot partition, ESP, or elsewhere'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个特殊的引导分区中：一个GPT引导分区、ESP或其他地方
- en: In all cases except where you have an UEFI/ESP, the PC BIOS loads 512 bytes
    from the MBR, and that’s where GRUB starts. This little piece (derived from *boot.img*
    in the GRUB directory) isn’t yet the core, but it contains the start location
    of the core and loads the core from this point.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你有UEFI/ESP，否则PC BIOS从MBR加载512字节的数据，这就是GRUB开始的地方。这一小段（源自GRUB目录中的*boot.img*）还不是核心，但它包含了核心的起始位置，并从这里加载核心。
- en: However, if you have an ESP, the GRUB core goes there as a file. The firmware
    can navigate the ESP and directly execute all of GRUB or any other operating system
    loader located there. (You might have a shim in the ESP that goes just before
    GRUB to handle secure boot, but the idea is the same.)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你有ESP，GRUB核心作为文件存在于那里。固件可以浏览ESP并直接执行存放在其中的所有GRUB或其他操作系统引导加载程序。（你可能会在ESP中有一个shim，位于GRUB之前，用来处理安全引导问题，但基本思想是相同的。）
- en: Still, on most systems, this isn’t the complete picture. The boot loader might
    also need to load an initial RAM filesystem image into memory before loading and
    executing the kernel. That’s what the `initrd` configuration parameter specifies,
    and we’ll cover it in Section 6.7. But before you learn about the initial RAM
    filesystem, you should learn about the user space start—that’s where the next
    chapter begins.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大多数系统中，这还不是完整的图景。引导加载程序可能还需要在加载并执行内核之前，将初始RAM文件系统镜像加载到内存中。这就是`initrd`配置参数的作用，我们将在第6.7节中详细介绍。但在了解初始RAM文件系统之前，你应该先了解用户空间启动——这正是下一章的内容。
