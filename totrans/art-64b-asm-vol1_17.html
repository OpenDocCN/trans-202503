<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="847" id="Page_847"/>15</span><br/>
<span class="ChapterTitle">Managing Complex Projects</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">Most assembly language source files aren’t stand-alone programs. They’re components of a large set of source files, in different languages, compiled and linked together to form complex applications. <em>Programming in the large</em> is the term software engineers have coined to describe the processes, methodologies, and tools for handling the development of large software projects. </p>
<p>While everyone has their own idea of what <em>large</em> is, <em>separate compilation</em> is one of the more popular techniques that support programming in the large. Using separate compilation, you first break your large source files into manageable chunks. Then you compile the separate files into object code modules. Finally, you link the object modules together to form a complete program. If you need to make a small change to one of the modules, <span epub:type="pagebreak" title="848" id="Page_848"/>you need to reassemble only that one module; you do not need to reassemble the entire program. Once you’ve debugged and tested a large section of your code, continuing to assemble that same code when you make a small change to another part of your program is a waste of time. Imagine having to wait 20 or 30 minutes on a fast PC to assemble a program to which you’ve made a one-line change!</p>
<p>The following sections describe the tools MASM provides for separate compilation and how to effectively employ these tools in your programs for modularity and reduced development time.</p>
<h2 id="h1-501089c15-0001">	15.1	The include Directive</h2>
<p class="BodyFirst">The <code>include</code> directive, when encountered in a source file, merges a specified file into the compilation at the point of the <code>include</code> directive. The syntax for the <code>include</code> directive is</p>
<pre><code>include <var>filename</var></code></pre>
<p class="BodyContinued">where <var>filename</var> is a valid filename. By convention, MASM include files have an <em>.inc</em> (include) suffix, but the name of any file containing MASM assembly language source will work fine. A file being included into another file during assembly may itself include files. </p>
<p>Using the <code>include</code> directive by itself does not provide separate compilation. You <em>could</em> use the <code>include</code> directive to break a large source file into separate modules and join these modules together when you compile your file. The following example would include the <em>print.inc</em> and <em>getTitle.inc</em> files during the compilation of your program:</p>
<pre><code>include  print.inc
include  getTitle.inc</code></pre>
<p>Now your program will benefit from modularity. Alas, you will not save any development time. The <code>include</code> directive inserts the source file at the point of the <code>include</code> during compilation, exactly as though you had typed that code yourself. MASM still has to compile the code, and that takes time. If you are including a large number of source files (such as a huge library) into your assembly, the compilation process could take <em>forever</em>.</p>
<p>In general, you should <em>not</em> use the <code>include</code> directive to include source code as shown in the preceding example.<sup class="FootnoteReference"><a id="c15-footnoteref-1" href="#c15-footnote-1">1</a></sup> Instead, you should use the <code>include</code> directive to insert a common set of constants, types, external procedure declarations, and other such items into a program. Typically, an assembly language include file does <em>not</em> contain any machine code (outside of a macro; see <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span> for details). The purpose of using <code>include</code> files in this manner will become clearer after you see how the external declarations work.</p>
<h2 id="h1-501089c15-0002"><span epub:type="pagebreak" title="849" id="Page_849"/>	15.2	Ignoring Duplicate Include Operations</h2>
<p class="BodyFirst">As you begin to develop sophisticated modules and libraries, you will eventually discover a big problem: some header files need to include other header files. Well, this isn’t actually a big problem, but a problem will occur when one header file includes another, and that second header file includes another, and that third header file includes another, and . . . that last header file includes the first header file. Now <em>this</em> is a big problem, because it creates an infinite loop in the compiler and makes MASM complain about duplicate symbol definitions. After all, the first time it reads the header file, it processes all the declarations in that file; the second time around, it views all those symbols as duplicate symbols.</p>
<p>The standard technique for ignoring duplicate includes, well-known to C/C++ programmers, is to use conditional assembly to have MASM ignore the content of an include file. (See <span class="xref" itemid="xref_target_“Conditional Assembly (Compile-Time Decisions)” in Chapter 13">“Conditional Assembly (Compile-Time Decisions)” in Chapter 13</span>.) The trick is to place an <code>ifndef</code> (<em>if not defined</em>) statement around all statements in the include file. You specify the include file’s filename as the <code>ifndef</code> operand, substituting underlines for periods (or any other undefined symbol). Then, immediately after the <code>ifndef</code> statement, you define that symbol (using a numeric equate and assigning the symbol the constant 0 is typical). Here’s an example of this <code>ifndef</code> usage in action:</p>
<pre><code>              ifndef  myinclude_inc   ; Filename: myinclude.inc
myinclude_inc =       0

<var>Put all the source code lines for the include file here</var>

; The following statement should be the last non-blank line
; in the source file:

              endif  ; myinclude_inc</code></pre>
<p>On the second inclusion, MASM simply skips over the contents of the include file (including any <code>include</code> directives), which prevents the infinite loop and all the duplicate symbol definitions.</p>
<h2 id="h1-501089c15-0003">	15.3	Assembly Units and External Directives </h2>
<p class="BodyFirst">An <em>assembly unit</em> is the assembly of a source file plus any files it includes or indirectly includes. An assembly unit produces a single <em>.obj</em> file after assembly. The Microsoft linker takes multiple object files (produced by MASM or other compilers, such as MSVC) and combines them into a single executable unit (an <em>.exe</em> file). The main purpose of this section (and, indeed, this whole chapter) is to describe how these assembly units (<em>.obj</em> files) communicate linkage information to one another during the linking process. Assembly units are the basis for creating modular programs in assembly language.</p>
<p>To use MASM’s assembly unit facilities, you must create at least two source files. One file contains a set of variables and procedures used by the second. The second file uses those variables and procedures without knowing how they’re implemented. </p>
<p><span epub:type="pagebreak" title="850" id="Page_850"/>Instead of using the <code>include</code> directive to create modular programs, which wastes time because MASM must recompile bug-free code every time you assemble the main program, a much better solution would be to preassemble the debugged modules and link the object code modules together. This is what the <code>public</code>, <code>extern</code>, and <code>externdef</code> directives allow you to do.</p>
<p>Technically, all of the programs appearing in this book up to this point have been separately assembled modules (which happen to link with a C/C++ main program rather than another assembly language module). The assembly language main program named <code>asmMain</code> is nothing but a function compatible with C++ that the generic <em>c.cpp</em> program has called from its main program. Consider the body of <code>asmMain</code> from <span class="xref" itemid="xref_target_Listing 2-1 in Chapter 2"><a href="c02.xhtml#listing2-1" id="listinganchor2-1">Listing 2-1</a> in Chapter 2</span>:</p>
<pre><code>; Here is the "asmMain" function.

        public  asmMain
asmMain proc
         .
         .
         .
asmMain endp</code></pre>
<p>The <code>public asmMain</code> statement has been included in every program that has had an <code>asmMain</code> function without any definition or explanation. Well, now it’s time to deal with that oversight.</p>
<p>Normal symbols in a MASM source file are <em>private</em> to that particular source file and are inaccessible from other source files (which don’t directly include the file containing those private symbols, of course). That is, the <em>scope</em> of most symbols in a source file is limited to those lines of code within that particular source file (and any files it includes). The <code>public</code> directive tells MASM to make the specified symbol global to the assembly unit—accessible by other assembly units during the link phase. Through the <code>public asmMain</code> statement in the example programs appearing throughout this book, these sample programs have made the <code>asmMain</code> symbol global to the source file containing them so that the <em>c.cpp</em> program can call the <code>asmMain</code> function.</p>
<p>Simply making a symbol public is insufficient to use that symbol in another source file. The source file that wants to use the symbol must also declare that symbol as an <em>external</em> symbol. This notifies the linker that it will have to patch in the address of a public symbol whenever the file with the external declaration uses that symbol. For example, the <em>c.cpp</em> source file defines the <code>asmMain</code> symbol as external in the following lines of code (for what it’s worth, this declaration also defines the external symbols <code>getTitle </code>and <code>readLine</code>):</p>
<pre><code>// extern "C" namespace prevents
// "name mangling" by the C++
// compiler.

extern "C"
{
<span epub:type="pagebreak" title="851" id="Page_851"/>    // asmMain is the assembly language
    // code's "main program":
        
    void asmMain(void);
    
    // getTitle returns a pointer to a
    // string of characters from the
    // assembly code that specifies the
    // title of that program (which makes
    // this program generic and usable
    // with a large number of sample
    // programs in "The Art of 64-Bit
    // Assembly").
    
    char *getTitle(void);
    
    // C++ function that the assembly
    // language program can call:
    
    int readLine(char *dest, int maxLen);
    
};</code></pre>
<p>Note, in this example, that <code>readLine</code> is a C++ function defined in the <em>c.cpp</em> source file. C/C++ does not have an explicit public declaration. Instead, if you supply the source code for a function in a source file that declares that function to be external, C/C++ will automatically make that symbol public by virtue of the external declaration.</p>
<p>MASM actually has two external symbol declaration directives: <code>extern</code> and <code>externdef</code>.<sup class="FootnoteReference"><a id="c15-footnoteref-2" href="#c15-footnote-2">2</a></sup> These two directives use the syntax</p>
<pre><code>extern    <var>symbol</var>:<var>type</var>  {<var>optional_list_of_symbol:type_pairs</var>}
externdef <var>symbol</var>:<var>type</var>  {<var>optional_list_of_symbol:type_pairs</var>}</code></pre>
<p class="BodyContinued">where <var>symbol</var> is the identifier you want to use from another assembly unit, and <var>type</var> is the data type of that symbol. The data type can be any of the following:</p>
<ul>
<li><code>proc</code>, which indicates that the symbol is a procedure (function) name or a statement label</li>
<li>Any MASM built-in data type (such as <code>byte</code>, <code>word</code>, <code>dword</code>, <code>qword</code>, <code>oword</code>, and so on)</li>
<li>Any user-defined data type (such as a struct name)</li>
<li><code>abs</code>, which indicates a constant value</li>
</ul>
<p>The <code>abs</code> type isn’t for declaring generic external constants such as <code>someConst = 0</code>. Pure constant declarations, such as this one, would normally appear in a header file (an include file), which this section will describe <span epub:type="pagebreak" title="852" id="Page_852"/>shortly. Instead, the <code>abs</code> type is generally reserved for constants that are based on code offsets within an object module. For example, if you have the following code in an assembly unit,</p>
<pre><code>          public someLen
someStr   byte   "abcdefg"
someLen   =      $-someStr</code></pre>
<p class="BodyContinued"><code>someLen</code>’s type, in an <code>extern</code> declaration, would be <code>abs</code>.</p>
<p>Both directives use a comma-delimited list to allow multiple symbol declarations; for example:</p>
<pre><code>extern p:proc, b:byte, d:dword, a:abs</code></pre>
<p>I’d argue, however, that your programs will be more readable if you limit your external declarations to one symbol per statement.</p>
<p>When you place an <code>extern</code> directive in your program, MASM treats that declaration the same as any other symbol declaration. If the symbol already exists, MASM will generate a symbol-redefinition error. Generally, you should place all external declarations near the beginning of the source file to avoid any scoping or forward reference issues. Because the public directive does not actually define the symbol, the placement of the public directive is not as critical. Some programmers put all the public declarations at the beginning of a source file; others put the public declaration right before the definition of the symbol (as I’ve done with the <code>asmMain</code> symbol in most of the same programs). Either position is fine.</p>
<h2 id="h1-501089c15-0004">	15.4	Header Files in MASM</h2>
<p class="BodyFirst">Because a public symbol from one source file can be used by many assembly units, a small problem develops: you have to replicate the <code>extern</code> directive in all the files that use that symbol. For a small number of symbols, this is not much of a problem. However, as the number of external symbols increases, maintaining all these external symbols across multiple source files becomes burdensome. The MASM solution is the same as the C/C++ solution: header files.</p>
<p><em>Header files</em> are include files that contain external (and other) declarations that are common among multiple assembly units. They are called <em>header files</em> because the include statement that injects their code into a source file normally appears at the beginning (at the <em>head</em>) of the source file that uses them. This turns out to be the primary use of include files in MASM: to include external (and other) common declarations.</p>
<h2 id="h1-501089c15-0005">	15.5	The externdef Directive</h2>
<p class="BodyFirst">When you start using header files with large sets of library modules (assembly units), you’ll quickly discover a huge problem with the <code>extern</code> directive. Typically, you will create a single header file for a large set of library <span epub:type="pagebreak" title="853" id="Page_853"/>functions, with each function possibly appearing in its own assembly unit. Some library functions might use other functions in the same <em>library module</em> (a collection of object files); therefore, that particular library function’s source file might want to include the header file for the library in order to reference the external name of the other library function. </p>
<p>Unfortunately, if the header file contains the external definition for the function in the current source file, a symbol redefinition error occurs:</p>
<pre><code>; header.inc
           ifndef   header_inc
header_inc =        0

           extern  func1:proc
           extern  func2:proc

           endif   ; header_inc</code></pre>
<p>Assembly of the following source file produces an error because <code>func1</code> is already defined in the <em>header.inc</em> include file:</p>
<pre><code>; func1.asm

           include header.inc

           .code

func1      proc
             .
             .
             .
           call func2
             .
             .
             .
func1      endp
           end</code></pre>
<p>C/C++ doesn’t suffer from this problem because the external keyword doubles as both a public and an external declaration.</p>
<p>To overcome this problem, MASM introduced the <code>externdef</code> directive. This directive is similar to C/C++’s <code>external</code> directive: it behaves like an <code>extern</code> directive when the symbol is not present in a source file, and it behaves like a <code>public</code> directive when the symbol is defined in a source file. In addition, multiple <code>externdef</code> declarations for the same symbol may appear in a source file (though they should specify the same type for the symbol if multiple declarations do appear). Consider the previous <em>header.inc</em> header file modified to use <code>externdef</code> definitions:</p>
<pre><code>; header.inc
           ifndef     header_inc
header_inc =          0

<span epub:type="pagebreak" title="854" id="Page_854"/>           externdef  func1:proc
           externdef  func2:proc

           endif      ; header_inc</code></pre>
<p>Using this header file, the <em>func1.asm</em> assembly unit will compile correctly.</p>
<h2 id="h1-501089c15-0006">	15.6	Separate Compilation</h2>
<p class="BodyFirst">Way back in <span class="xref" itemid="xref_target_“The MASM Include Directive” in Chapter 11">“The MASM Include Directive” in Chapter 11</span>, I started putting the <code>print</code> and <code>getTitle</code> functions in include files so that I could simply include them in every source file that needed to use these functions rather than manually cutting and pasting these functions into every program. Clearly, these are good examples of programs that should be made into assembly units and linked with other programs rather than being included during assembly. </p>
<p><a href="#listing15-1" id="listinganchor15-1">Listing 15-1</a> is a header file that incorporates the necessary <code>print</code> and <code>getTitle</code> declarations:<sup class="FootnoteReference"><a id="c15-footnoteref-3" href="#c15-footnote-3">3</a></sup></p>
<pre><code>; aoalib.inc - Header file containing external function
;              definitions, constants, and other items used
;              by code in "The Art of 64-Bit Assembly."

            ifndef      aoalib_inc
aoalib_inc  equ         0

; Constant definitions:

; nl (newline constant):

nl          =           10

; SSE4.2 feature flags (in ECX):

SSE42       =       00180000h       ; Bits 19 and 20
AVXSupport  =       10000000h       ; Bit 28

; CPUID bits (EAX = 7, EBX register):

AVX2Support  =      20h             ; Bit 5 = AVX

**********************************************************

; External data declarations:

            externdef   ttlStr:byte

<span epub:type="pagebreak" title="855" id="Page_855"/>**********************************************************
 
; External function declarations:

            externdef   print:qword
            externdef   getTitle:proc

; Definition of C/C++ printf function that
; the print function will call (and some
; AoA sample programs call this directly,
; as well).

            externdef   printf:proc
            
            endif       ; aoalib_inc</code></pre>
<p class="CodeListingCaption"><a id="listing15-1">Listing 15-1</a>: <em>aoalib.inc</em> header file</p>
<p><a href="#listing15-2" id="listinganchor15-2">Listing 15-2</a> contains the <code>print</code> function used in <span class="xref" itemid="xref_target_“The MASM Include Directive” in Chapter 11">“The MASM Include Directive” in Chapter 11</span> converted to an assembly unit.</p>
<pre><code>; print.asm - Assembly unit containing the SSE/AVX dynamically
;             selectable print procedures.

            include aoalib.inc

            .data
            align   qword
print       qword   choosePrint     ; Pointer to print function
            
            .code

; print - "Quick" form of printf that allows the format string to
;         follow the call in the code stream. Supports up to five
;         additional parameters in RDX, R8, R9, R10, and R11.

; This function saves all the Microsoft ABI–volatile,
; parameter, and return result registers so that code
; can call it without worrying about any registers being
; modified (this code assumes that Windows ABI treats
; YMM6 to YMM15 as nonvolatile).

; Of course, this code assumes that AVX instructions are
; available on the CPU.

; Allows up to 5 arguments in:

;  RDX - Arg #1
;  R8  - Arg #2
;  R9  - Arg #3
;  R10 - Arg #4
;  R11 - Arg #5

<span epub:type="pagebreak" title="856" id="Page_856"/>; Note that you must pass floating-point values in
; these registers as well. The printf function
; expects real values in the integer registers. 

; There are two versions of this program, one that
; will run on CPUs without AVX capabilities (no YMM
; registers) and one that will run on CPUs that
; have AVX capabilities (YMM registers). The difference
; between the two is which registers they preserve
; (print_SSE preserves only XMM registers and will
; run properly on CPUs that don't have YMM register
; support; print_AVX will preserve the volatile YMM
; registers on CPUs with AVX support).

; On first call, determine if we support AVX instructions
; and set the "print" pointer to point at print_AVX or
; print_SSE:

choosePrint proc
            push    rax             ; Preserve registers that get
            push    rbx             ; tweaked by CPUID
            push    rcx
            push    rdx
            
            mov     eax, 1
            cpuid
            test    ecx, AVXSupport ; Test bit 28 for AVX
            jnz     doAVXPrint
            
            lea     rax, print_SSE  ; From now on, call
            mov     print, rax      ; print_SSE directly

; Return address must point at the format string
; following the call to this function! So we have
; to clean up the stack and JMP to print_SSE.

            pop     rdx
            pop     rcx
            pop     rbx
            pop     rax
            jmp     print_SSE
            
doAVXPrint: lea     rax, print_AVX  ; From now on, call
            mov     print, rax      ; print_AVX directly
            
; Return address must point at the format string
; following the call to this function! So we have
; to clean up the stack and JMP to print_AUX.

            pop     rdx
            pop     rcx
            pop     rbx
            pop     rax
            jmp     print_AVX

<span epub:type="pagebreak" title="857" id="Page_857"/>choosePrint endp

; Version of print that will preserve volatile
; AVX registers (YMM0 to YMM3):

thestr      byte "YMM4:%I64x", nl, 0
print_AVX   proc

; Preserve all the volatile registers
; (be nice to the assembly code that
; calls this procedure):

            push    rax
            push    rbx
            push    rcx
            push    rdx
            push    r8
            push    r9
            push    r10
            push    r11
            
; YMM0 to YMM7 are considered volatile, so preserve them:

            sub     rsp, 256
            vmovdqu ymmword ptr [rsp + 000], ymm0
            vmovdqu ymmword ptr [rsp + 032], ymm1
            vmovdqu ymmword ptr [rsp + 064], ymm2
            vmovdqu ymmword ptr [rsp + 096], ymm3
            vmovdqu ymmword ptr [rsp + 128], ymm4
            vmovdqu ymmword ptr [rsp + 160], ymm5
            vmovdqu ymmword ptr [rsp + 192], ymm6
            vmovdqu ymmword ptr [rsp + 224], ymm7
            
            push    rbp

returnAdrs  textequ &lt;[rbp + 328]&gt;

            mov     rbp, rsp
            sub     rsp, 256
            and     rsp, -16
            
; Format string (passed in RCX) is sitting at
; the location pointed at by the return address;
; load that into RCX:

            mov     rcx, returnAdrs
            
; To handle more than three arguments (four counting
; RCX), you must pass data on stack. However, to the
; print caller, the stack is unavailable, so use
; R10 and R11 as extra parameters (could be just
; junk in these registers, but pass them just
; in case).

<span epub:type="pagebreak" title="858" id="Page_858"/>            mov     [rsp + 32], r10
            mov     [rsp + 40], r11
            call    printf
            
; Need to modify the return address so
; that it points beyond the zero-terminating byte.
; Could use a fast strlen function for this, but
; printf is so slow it won't really save us anything.
            
            mov     rcx, returnAdrs
            dec     rcx
skipTo0:    inc     rcx
            cmp     byte ptr [rcx], 0
            jne     skipTo0
            inc     rcx
            mov     returnAdrs, rcx
            
            leave
            vmovdqu ymm0, ymmword ptr [rsp + 000]
            vmovdqu ymm1, ymmword ptr [rsp + 032]
            vmovdqu ymm2, ymmword ptr [rsp + 064]
            vmovdqu ymm3, ymmword ptr [rsp + 096]
            vmovdqu ymm4, ymmword ptr [rsp + 128]
            vmovdqu ymm5, ymmword ptr [rsp + 160]
            vmovdqu ymm6, ymmword ptr [rsp + 192]
            vmovdqu ymm7, ymmword ptr [rsp + 224]
            add     rsp, 256
            pop     r11
            pop     r10
            pop     r9
            pop     r8
            pop     rdx
            pop     rcx
            pop     rbx
            pop     rax
            ret
print_AVX   endp

; Version that will run on CPUs without
; AVX support and will preserve the
; volatile SSE registers (XMM0 to XMM3):

print_SSE   proc

; Preserve all the volatile registers
; (be nice to the assembly code that
; calls this procedure):

            push    rax
            push    rbx
            push    rcx
            push    rdx
            push    r8
            push    r9
<span epub:type="pagebreak" title="859" id="Page_859"/>            push    r10
            push    r11
            
; XMM0 to XMM3 are considered volatile, so preserve them:

            sub     rsp, 128
            movdqu  xmmword ptr [rsp + 00],  xmm0
            movdqu  xmmword ptr [rsp + 16],  xmm1
            movdqu  xmmword ptr [rsp + 32],  xmm2
            movdqu  xmmword ptr [rsp + 48],  xmm3
            movdqu  xmmword ptr [rsp + 64],  xmm4
            movdqu  xmmword ptr [rsp + 80],  xmm5
            movdqu  xmmword ptr [rsp + 96],  xmm6
            movdqu  xmmword ptr [rsp + 112], xmm7
            
            push    rbp

returnAdrs  textequ &lt;[rbp + 200]&gt;

            mov     rbp, rsp
            sub     rsp, 128
            and     rsp, -16
            
; Format string (passed in RCX) is sitting at
; the location pointed at by the return address;
; load that into RCX:

            mov     rcx, returnAdrs
            
; To handle more than three arguments (four counting
; RCX), you must pass data on stack. However, to the
; print caller, the stack is unavailable, so use
; R10 and R11 as extra parameters (could be just
; junk in these registers, but pass them just
; in case):

            mov     [rsp + 32], r10
            mov     [rsp + 40], r11
            call    printf
            
; Need to modify the return address so
; that it points beyond the zero-terminating byte.
; Could use a fast strlen function for this, but
; printf is so slow it won't really save us anything.
            
            mov     rcx, returnAdrs
            dec     rcx
skipTo0:    inc     rcx
            cmp     byte ptr [rcx], 0
            jne     skipTo0
            inc     rcx
            mov     returnAdrs, rcx
            
            leave
<span epub:type="pagebreak" title="860" id="Page_860"/>            movdqu  xmm0, xmmword ptr [rsp + 00] 
            movdqu  xmm1, xmmword ptr [rsp + 16] 
            movdqu  xmm2, xmmword ptr [rsp + 32] 
            movdqu  xmm3, xmmword ptr [rsp + 48] 
            movdqu  xmm4, xmmword ptr [rsp + 64] 
            movdqu  xmm5, xmmword ptr [rsp + 80] 
            movdqu  xmm6, xmmword ptr [rsp + 96] 
            movdqu  xmm7, xmmword ptr [rsp + 112] 
            add     rsp, 128
            pop     r11
            pop     r10
            pop     r9
            pop     r8
            pop     rdx
            pop     rcx
            pop     rbx
            pop     rax
            ret
print_SSE   endp            
            end</code></pre>
<p class="CodeListingCaption"><a id="listing15-2">Listing 15-2</a>: The <code>print</code> function appearing in an assembly unit</p>
<p>To complete all the common <em>aoalib</em> functions used thus far, here is <a href="#listing15-3" id="listinganchor15-3">Listing 15-3</a>.</p>
<pre><code>; getTitle.asm - The getTitle function converted to
;                an assembly unit.

; Return program title to C++ program:

            include aoalib.inc
            
            .code
getTitle    proc
            lea     rax, ttlStr
            ret
getTitle    endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing15-3">Listing 15-3</a>: The <code>getTitle</code> function as an assembly unit</p>
<p><a href="#listing15-4" id="listinganchor15-4">Listing 15-4</a> is a program that uses the assembly units in Listings 15-2 and 15-3.</p>
<pre><code>; Listing 15-4

; Demonstration of linking.

            include aoalib.inc
            
            .data
ttlStr      byte    "Listing 15-4", 0
            
<span epub:type="pagebreak" title="861" id="Page_861"/>***************************************************************
 
; Here is the "asmMain" function.

            .code
            public  asmMain
asmMain     proc
            push    rbx
            push    rsi
            push    rdi
            push    rbp
            mov     rbp, rsp
            sub     rsp, 56         ; Shadow storage
            
            call    print
            byte    "Assembly units linked", nl, 0

            leave
            pop     rdi
            pop     rsi
            pop     rbx
            ret     ; Returns to caller
asmMain     endp
            end</code></pre>
<p class="CodeListingCaption"><a id="listing15-4">Listing 15-4</a>: A main program that uses the <code>print</code> and <code>getTitle</code> assembly modules</p>
<p>So how do you build and run this program? Unfortunately, the <em>build.bat</em> batch file this book has been using up to this point will not do the job. Here’s a command that will assemble all the units and link them together:</p>
<pre><code>ml64 /c print.asm getTitle.asm listing15-4.asm
cl /EHa c.cpp print.obj getTitle.obj listing15-4.obj</code></pre>
<p>These commands will properly compile all source files and link together their object code to produce the executable file <em>c.exe</em>.</p>
<p>Unfortunately, the preceding commands defeat one of the major benefits of separate compilation. When you issue the <code>ml64 /c print.asm getTitle.asm listing15-4.asm</code> command, it will compile all the assembly source files. Remember, a major reason for separate compilation is to reduce compilation time on large projects. While the preceding commands work, they don’t achieve this goal.</p>
<p>To separately compile the two modules, you must run MASM separately on them. To compile the three source files separately, break the <code>ml64</code> invocation into three separate commands:</p>
<pre><code>ml64 /c print.asm
ml64 /c getTitle.asm
ml64 /c listing15-4.asm
cl /EHa c.cpp print.obj getTitle.obj listing15-4.obj</code></pre>
<p><span epub:type="pagebreak" title="862" id="Page_862"/>Of course, this sequence still compiles all three assembly source files. However, after the first time you execute these commands, you’ve built the <em>print.obj</em> and <em>getTitle.obj</em> files. From this point forward, as long as you don’t change the <em>print.asm</em> or <em>getTitle.asm</em> source files (and don’t delete the <em>print.obj</em> or <em>getTitle.obj</em> files), you can build and run the program in <a href="#listing15-4">Listing 15-4</a> by using these commands:</p>
<pre><code>ml64 /c listing15-4.asm
cl /EHa c.cpp print.obj getTitle.obj listing15-4.obj</code></pre>
<p>Now, you’ve saved the time needed to compile the <em>print.asm</em> and <em>getTitle.asm</em> files.</p>
<h2 id="h1-501089c15-0007">	15.7	An Introduction to Makefiles</h2>
<p class="BodyFirst">The <em>build.bat</em> file used throughout this book has been far more convenient than typing the individual build commands. Unfortunately, the build mechanism that <em>build.bat</em> supports is really good for only a few fixed source files. While you could easily construct a batch file to compile all the files in a large assembly project, running the batch file would reassemble every source file in the project. Although you can use complex command line functions to avoid some of this, there is an easier way: makefiles.</p>
<p>A <em>makefile</em> is a script in a special language (designed in early releases of Unix) that specifies how to execute a series of commands based on certain conditions, executed by the program make. If you’ve installed MSVC and MASM as part of Visual Studio, you’ve probably also installed (as part of that same process) Microsoft’s variant of make: <code>nmake.exe</code>.<sup class="FootnoteReference"><a id="c15-footnoteref-4" href="#c15-footnote-4">4</a></sup> To use <code>nmake.exe</code>, you execute it from a Windows command line as follows:</p>
<pre><code>nmake <var>optional_arguments</var></code></pre>
<p>If you execute <code>nmake</code> on a command line by itself (without any arguments), <code>nmake.exe</code> will search for a file named <em>makefile</em> and attempt to process the commands in that file. For many projects, this is very convenient. You will have all your project’s source files in a single directory (or in subdirectories hanging off that directory), and you will place a single makefile (named <em>makefile</em>) in that directory. By changing into that directory and executing <code>nmake</code> (or <code>make</code>), you can build the project with minimal fuss.</p>
<p>If you want to use a different filename than <em>makefile</em>, you must preface the filename with the <code>/f</code> option, as follows:</p>
<pre><code>nmake /f mymake.mak</code></pre>
<p>The filename doesn’t have to have the extension <em>.mak</em>. However, this is a popular convention when using makefiles that are not named <em>makefile</em>.</p>
<p><span epub:type="pagebreak" title="863" id="Page_863"/>The <code>nmake</code> program does provide many command line options, and <code>/help</code> will list them. Look up <code>nmake</code> documentation online for a description of the other command line options (most of them are advanced and are unnecessary for most tasks).</p>
<h3 id="h2-501089c15-0001">15.7.1	Basic Makefile Syntax</h3>
<p class="BodyFirst">A makefile is a standard ASCII text file containing a sequence of lines (or a set of multiple occurrences of this sequence) as follows:</p>
<pre><code><var>target</var>: <var>dependencies</var>
    <var>commands</var></code></pre>
<p>The <var>target</var><code>:</code><var> dependencies</var> line is optional. The <var>commands</var> item is a list of one or more command line commands, also optional. The <var>target</var> item, if present, must begin in column 1 of the source line it is on. The <var>commands</var> items must have at least one whitespace character (space or tab) in front of them (that is, they must not begin in column 1 of the source line). Consider the following valid makefile:</p>
<pre><code>c.exe:
  ml64 /c print.asm
  ml64 /c getTitle.asm
  ml64 /c listing15-4.asm
  cl /EHa c.cpp print.obj getTitle.obj listing15-4.obj</code></pre>
<p>If these commands appear in a file named <em>makefile</em> and you execute <code>nmake</code>, then <code>nmake</code> will execute these commands exactly like the command line interpreter would have executed them had they appeared in a batch file.</p>
<p>A <var>target</var> item is an identifier or a filename of some sort. Consider the following makefile:</p>
<pre><code>executable:
  ml64 /c listing15-4.asm
  cl /EHa c.cpp print.obj getTitle.obj listing15-4.obj

library:
  ml64 /c print.asm
  ml64 /c getTitle.asm</code></pre>
<p>This separates the build commands into two groups: one group specified by the <code>executable</code> label and one group specified by the <code>library</code> label. </p>
<p>If you run <code>nmake</code> without any command line options, <code>nmake</code> will execute only those commands associated with the very first target in the makefile. In this example, if you run <code>nmake</code> by itself, it will assemble <em>listing15-4.asm</em>, <em>print.asm</em>, and <em>getTitle.asm</em>; compile <em>c.cpp</em>; and attempt to link the resulting <em>c.obj</em> with <em>print.obj</em>, <em>getTitle.obj</em>, and <em>listing15-4.obj</em>. This should successfully produce the <em>c.exe</em> executable.</p>
<p><span epub:type="pagebreak" title="864" id="Page_864"/>To process the commands after the library target, specify the target name as an <code>nmake</code> command line argument:</p>
<pre><code>nmake library</code></pre>
<p>This <code>nmake</code> command compiles <em>print.asm</em> and <em>getTitle.asm</em>. So if you execute this command once (and never change <em>print.asm</em> or <em>getTitle.asm</em> thereafter), you need only execute the <code>nmake</code> command by itself to generate the executable file (or use <code>nmake executable</code> if you want to explicitly state that you are building the executable).</p>
<h3 id="h2-501089c15-0002">15.7.2	Make Dependencies</h3>
<p class="BodyFirst">Although the ability to specify which targets you want to build on the command line is very useful, as your projects get larger (with many source files and library modules), keeping track of which source files you need to recompile all the time can be burdensome and error prone; if you’re not careful, you’ll forget to compile an obscure library module after you’ve made changes to it and wonder why the application is still failing. The make dependencies option allows you to automate the build process to help avoid these problems.</p>
<p>A list of one or more (whitespace-separated) dependencies can follow a target in a makefile:</p>
<pre><code><var>target</var>: <var>dependency1</var> <var>dependency2</var> <var>dependency3</var> ...</code></pre>
<p>Dependencies are either target names (of targets appearing in that makefile) or filenames. If a dependency is a target name (that is not also a filename), <code>nmake</code> will go execute the commands associated with that target. Consider the following makefile:</p>
<pre><code>executable:
  ml64 /c listing15-4.asm
  cl /EHa c.cpp print.obj getTitle.obj listing15-4.obj

library:
  ml64 /c print.asm
  ml64 /c getTitle.asm

all: library executable</code></pre>
<p>The <code>all</code> target depends on the <code>library</code> and <code>executable</code> targets, so it will go execute the commands associated with those targets (and in the order <code>library</code>, <code>executable</code>, which is important because the <code>library</code> object files must be built before the associated object modules can be linked into the executable program). The <code>all</code> identifier is a common target in makefiles. Indeed, it is often the first or second target to appear in a makefile.</p>
<p>If a <var>target</var><code>: </code><var>dependencies</var> line becomes too long to be readable (<code>nmake</code> doesn’t really care too much about line length), you can break the line into multiple lines by putting a backslash character (<code>\</code>) as the last character on a line. The <code>nmake</code> program will combine source lines that end with a backslash with the next line in the makefile. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="865" id="Page_865"/><h2><span class="NoteHead">Note</span></h2>
<p>	The backslash must be the very last character on the line. Whitespace characters (tabs and spaces) are not allowed. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Target names and dependencies can also be filenames. Specifying a filename as a target name is generally done to tell the make system how to build that particular file. For example, we could rewrite the current example as follows:</p>
<pre><code>executable:
  ml64 /c listing15-4.asm
  cl /EHa c.cpp print.obj getTitle.obj listing15-4.obj

library: print.obj getTitle.obj

print.obj:
  ml64 /c print.asm

getTitle.obj:
  ml64 /c getTitle.asm

all: library executable</code></pre>
<p>When dependencies are associated with a target that is a filename, you can read the <var>target</var><code>: </code><var>dependencies</var> statement as “<var>target</var> depends on <var>dependencies</var>.” When processing a make command, <code>nmake</code> compares the modification date and time stamp of the files specified as target filenames and dependency filenames. </p>
<p>If the date and time of the target are older than <em>any</em> of the dependencies (or the target file doesn’t exist), <code>nmake</code> will execute the commands after the target. If the target file’s modification date and time are later (newer) than <em>all</em> of the dependent files, <code>nmake</code> will not execute the commands. If one of the dependencies after a target is itself a target elsewhere, <code>nmake</code> will first execute that command (to see if it modifies the target object, changing its modification date and time, and possibly causing <code>nmake</code> to execute the current target’s commands). If a target or dependency is just a label (it is not a filename), <code>nmake</code> will treat its modification date and time as older than any file.</p>
<p>Consider the following modification to the running <code>makefile</code> example:</p>
<pre><code>c.exe: print.obj getTitle.obj listing15-4.obj
  cl /EHa c.cpp print.obj getTitle.obj listing15-4.obj

listing15-4.obj: listing15-4.asm
  ml64 /c listing15-4.asm

print.obj: print.asm
  ml64 /c print.asm

getTitle.obj: getTitle.asm
  ml64 /c getTitle.asm</code></pre>
<p>Note that the <code>all</code> and <code>library</code> targets were removed (they turn out to be unnecessary) and that <code>executable</code> was changed to <em>c.exe</em> (the final target executable file).</p>
<p><span epub:type="pagebreak" title="866" id="Page_866"/>Consider the <em>c.exe</em> target. Because <em>print.obj</em>, <em>getTitle.obj</em>, and <em>listing15-4.obj</em> are all targets (as well as filenames), <code>nmake</code> will first go execute those targets. After executing those targets, <code>nmake</code> will compare the modification date and time of <em>c.exe </em>against that of the three object files. If <em>c.exe</em> is older than any of those object files, <code>nmake</code> will execute the command following the <em>c.exe</em> target line (to compile <em>c.cpp</em> and link it with the object files). If <em>c.exe</em> is newer than its dependent object files, <code>nmake</code> will not execute the command.</p>
<p>The same process happens, recursively, for each of the dependent object files following the <em>c.exe</em> target. While processing the <em>c.exe</em> target, <code>nmake</code> will go off and process the <em>print.obj</em>, <em>getTitle.obj</em>, and <em>listing15-4.obj</em> targets (in that order). In each case, <code>nmake</code> will compare the modification date and time of the <em>.obj</em> file with the corresponding <em>.asm</em> file. If the <em>.obj</em> file is newer than the <em>.asm</em> file, <code>nmake</code> returns to processing the <em>c.exe</em> target without doing anything; if the <em>.obj</em> file is older than the <em>.asm</em> file (or doesn’t exist), <code>nmake</code> executes the corresponding <code>ml64</code> command to generate a new <em>.obj</em> file.</p>
<p>If <em>c.exe</em> is newer than all the <em>.obj</em> files (and they are all newer than the <em>.asm</em> files), executing <code>nmake</code> does nothing (well, it will report that <em>c.exe</em> is up to date, but it will not process any of the commands in the makefile). If any of the files are out of date (because they’ve been modified), this makefile will compile and link only the files necessary to bring <em>c.exe</em> up to date.</p>
<p>The makefiles thus far are missing an important dependency: all of the <em>.asm </em>files include the <em>aoalib.inc</em> file. A change to <em>aoalib.inc</em> could possibly require a recompilation of these <em>.asm</em> files. This dependency has been added to <a href="#listing15-5">Listing 15-5</a>. This listing also demonstrates how to include comments in a makefile by using the <code>#</code> character at the beginning of a line.</p>
<pre><code># listing15-5.mak

# makefile for Listing 15-4.

listing15-4.exe:print.obj getTitle.obj listing15-4.obj
    cl /nologo /O2 /Zi /utf-8 /EHa /Felisting15-4.exe c.cpp \
            print.obj getTitle.obj listing15-4.obj
            
listing15-4.obj: listing15-4.asm aoalib.inc
  ml64 /nologo /c listing15-4.asm

print.obj: print.asm aoalib.inc
  ml64 /nologo /c print.asm

getTitle.obj: getTitle.asm aoalib.inc
  ml64 /nologo /c getTitle.asm</code></pre>
<p class="CodeListingCaption"><a id="listing15-5">Listing 15-5</a>: Makefile to build <a href="#listing15-4">Listing 15-4</a></p>
<p>Here’s the <code>nmake</code> command to build the program in <a href="#listing15-4">Listing 15-4</a> by using the makefile (<em>listing15-5.mak</em>) in <a href="#listing15-5">Listing 15-5</a>:</p>
<pre><code>C:\&gt;<b>nmake /f listing15-5.mak</b>

Microsoft (R) Program Maintenance Utility Version 14.15.26730.0
Copyright (C) Microsoft Corporation.  All rights reserved.

<span epub:type="pagebreak" title="867" id="Page_867"/>        ml64 /nologo /c print.asm
 Assembling: print.asm
        ml64 /nologo /c getTitle.asm
 Assembling: getTitle.asm
        ml64 /nologo /c listing15-4.asm
 Assembling: listing15-4.asm
        cl /nologo /O2 /Zi /utf-8 /EHa /Felisting15-4.exe c.cpp  print.obj getTitle.obj listing15-4.obj
c.cpp

C:\&gt;<b>listing15-4</b>
Calling Listing 15-4:
Assembly units linked
Listing 15-4 terminated</code></pre>
<h3 id="h2-501089c15-0003">15.7.3	Make Clean and Touch</h3>
<p class="BodyFirst">One common target you will find in most professionally made makefiles is <code>clean</code>. The <code>clean</code> target will delete an appropriate set of files to force the entire system to be remade the next time you execute the makefile. This command typically deletes all the <em>.obj</em> and <em>.exe</em> files associated with the project. <a href="#listing15-6" id="listinganchor15-6">Listing 15-6</a> provides a <code>clean</code> target for the makefile in <a href="#listing15-5">Listing 15-5</a>.</p>
<pre><code># listing15-6.mak
 
# makefile for Listing 15-4.

listing15-4.exe:print.obj getTitle.obj listing15-4.obj
    cl /nologo /O2 /Zi /utf-8 /EHa /Felisting15-4.exe c.cpp \
            print.obj getTitle.obj listing15-4.obj
            
listing15-4.obj: listing15-4.asm aoalib.inc
    ml64 /nologo /c listing15-4.asm

print.obj: print.asm aoalib.inc
    ml64 /nologo /c print.asm

getTitle.obj: getTitle.asm aoalib.inc
    ml64 /nologo /c getTitle.asm
  
clean:
    del getTitle.obj
    del print.obj
    del listing15-4.obj
    del c.obj
    del listing15-4.ilk
    del listing15-4.pdb
    del vc140.pdb
    del listing15-4.exe
    
# Alternative clean (if you like living dangerously):

# clean:
#   del *.obj
#   del *.ilk
<span epub:type="pagebreak" title="868" id="Page_868"/>#   del *.pdb
#   del *.exe</code></pre>
<p class="CodeListingCaption"><a id="listing15-6">Listing 15-6</a>: A <code>clean</code> target example</p>
<p>Here is a sample clean and remake operation:</p>
<pre><code>C:\&gt;<b>nmake /f listing15-6.mak clean</b>

Microsoft (R) Program Maintenance Utility Version 14.15.26730.0
Copyright (C) Microsoft Corporation.  All rights reserved.

        del getTitle.obj
        del print.obj
        del listing15-4.obj
        del c.obj
        del listing15-4.ilk
        del listing15-4.pdb
        del listing15-4.exe

C:\&gt;<b>nmake /f listing15-6.mak</b>

Microsoft (R) Program Maintenance Utility Version 14.15.26730.0
Copyright (C) Microsoft Corporation.  All rights reserved.

        ml64 /nologo /c print.asm
 Assembling: print.asm
        ml64 /nologo /c getTitle.asm
 Assembling: getTitle.asm
        ml64 /nologo /c listing15-4.asm
 Assembling: listing15-4.asm
        cl /nologo /O2 /Zi /utf-8 /EHa /Felisting15-4.exe c.cpp
           print.obj getTitle.obj listing15-4.obj
c.cpp</code></pre>
<p>If you want to force the recompilation of a single file (without manually editing and modifying it), a Unix utility comes in handy: <code>touch</code>. The <code>touch</code> program accepts a filename as its argument and goes in and updates the modification date and time of the file (without otherwise modifying the file). For example, after building <a href="#listing15-4">Listing 15-4</a> by using the makefile in <a href="#listing15-6">Listing 15-6</a>, were you to execute the command</p>
<pre><code>touch listing15-4.asm</code></pre>
<p class="BodyContinued">and then execute the makefile in <a href="#listing15-6">Listing 15-6</a> again, it would reassemble the code in <a href="#listing15-4">Listing 15-4</a>, recompile <em>c.cpp</em>, and produce a new executable.</p>
<p>Unfortunately, while <code>touch</code> is a standard Unix application and comes with every Unix and Linux distribution, it is not a standard Windows application.<sup class="FootnoteReference"><a id="c15-footnoteref-5" href="#c15-footnote-5">5</a></sup> Fortunately, you can easily find a version of <code>touch</code> for Windows on the internet. It’s also a relatively simple program to write. </p>
<h2 id="h1-501089c15-0008"><span epub:type="pagebreak" title="869" id="Page_869"/>	15.8	The Microsoft Linker and Library Code</h2>
<p class="BodyFirst">Many common projects reuse code that developers created long ago (or they use code that came from a source outside the developer’s organization). These libraries of code are relatively <em>static</em>: they rarely change during the development of a project that uses the library code. In particular, you would not normally incorporate the building of the libraries into a given project’s makefile. A specific project might list the library files as dependencies in the makefile, but the assumption is that the library files are built elsewhere and supplied as a whole to the project. Beyond that, one major difference exists between a library and a set of object code files: packaging.</p>
<p>Dealing with a myriad of separate object files can become troublesome when you’re working with true sets of library object files. A library may contain tens, hundreds, or even thousands of object files. Listing all of these object files (or even just the ones a project uses) is a lot of work and can lead to consistency errors. A common way to deal with this problem is to combine various object files into a separate package (file) known as a <em>library file</em>. Under Windows, library files typically have a <em>.lib</em> suffix.</p>
<p>For many projects, you will be given a library (<em>.lib</em>) file that packages together a specific library module. You supply this file to the linker when building your program, and the linker automatically picks out the object modules it needs from the library. This is an important point: including a library while building an executable does not automatically insert all of the code from that library into the executable. The linker is smart enough to extract only the object files it needs and to ignore the object files it doesn’t use (remember, a library is just a package containing a bunch of object files).</p>
<p>So the question is, “How do you create a library file?” The short answer is, “By using the Microsoft Library Manager program (<em>lib.exe</em>).” The basic syntax for the <code>lib</code> program is</p>
<pre><code>lib /out:<var>libname.lib</var> <var>list_of_.obj_files</var></code></pre>
<p class="BodyContinued">where <var>libname.lib</var> is the name of the library file you want to produce, and <var>list_of_.obj_files</var> is a (space-separated) list of object filenames you want to collect into the library. For example, if you want to combine the <em>print.obj</em> and <em>getTitle.obj</em> files into a library module (<em>aoalib.lib</em>), here’s the command to do it:</p>
<pre><code>lib /out:aoalib.lib getTitle.obj print.obj</code></pre>
<p>Once you have a library module, you can specify it on a linker (or <code>ml64</code> or <code>cl</code>) command line just as you would an object file. For example, to link in the <em>aoalib.lib</em> module with the program in <a href="#listing15-4">Listing 15-4</a>, you could use the following command:</p>
<pre><code>cl /EHa /Felisting15-4.exe c.cpp listing15-4.obj aoalib.lib</code></pre>
<p>The <code>lib</code> program supports several command line options. You can get a list of those options by using this command:</p>
<pre><code>lib /?</code></pre>
<p><span epub:type="pagebreak" title="870" id="Page_870"/>See the online Microsoft documentation for a description of the various commands. Perhaps the most useful of the options is</p>
<pre><code>lib /list <var>lib_filename.lib</var></code></pre>
<p class="BodyContinued">where <var>lib_filename.lib</var> represents a library filename. This will print a list of the object files contained within that library module. For example, <code>lib /list aoalib.lib</code> produces the following output:</p>
<pre><code>C:\&gt;<b>lib /list aoalib.lib</b>
Microsoft (R) Library Manager Version 14.15.26730.0
Copyright (C) Microsoft Corporation.  All rights reserved.

getTitle.obj
print.obj</code></pre>
<p>MASM provides a special directive, <code>includelib</code>, that lets you specify libraries to include. This directive has the syntax</p>
<pre><code>includelib <var>lib_filename.lib</var></code></pre>
<p class="BodyContinued">where <var>lib_filename.lib</var> is the name of the library file you want to include. This directive embeds a command in the object file that MASM produces that passes this library filename along to the linker. The linker will then automatically load the library file when processing the object module containing the <code>includelib</code> directive. </p>
<p>This activity is identical to manually specifying the library filename to the linker (from the command line). Whether you prefer to put the <code>includelib</code> directive in a MASM source file, or include the library name on the linker (or <code>ml64</code>/<code>cl</code>) command line, is up to you. In my experience, most assembly language programmers (especially when writing stand-alone assembly language programs) prefer the <code>includelib</code> directive.</p>
<h2 id="h1-501089c15-0009">	15.9	Object File and Library Impact on Program Size</h2>
<p class="BodyFirst">The basic unit of linkage in a program is the object file. When combining object files to form an executable, the Microsoft linker will take all of the data from a single object file and merge it into the final executable. This is true even if the main program doesn’t call all the functions (directly or indirectly) in the object module or use all the data in that object file. So, if you put 100 routines in a single assembly language source file and compile them into an object module, the linker will include the code for all 100 routines in your final executable even if you use only one of them. </p>
<p>If you want to avoid this situation, you should break those 100 routines into 100 separate object modules and combine the resulting 100 object files into a single library. When the Microsoft linker processes that library file, it will pick out the single object file containing the function the program uses <span epub:type="pagebreak" title="871" id="Page_871"/>and incorporate only that object file into the final executable. Generally, this is far more efficient than linking in a single object file with 100 functions buried in it.</p>
<p>The key word in that last sentence is <em>generally</em>. In fact, there are some good reasons for combining multiple functions into a single object file. First of all, consider what happens when the linker merges an object file into an executable. To ensure proper alignment, whenever the linker takes a section or segment (for example, the <code>.code</code> section) from an object file, it adds sufficient padding so that the data in that section is aligned on that section’s specified alignment boundary. Most sections have a default 16-byte section alignment, so the linker will align each section from the object file it links in on a 16-byte boundary. Normally, this isn’t too bad, especially if your procedures are large. However, suppose those 100 procedures you’ve created are all really short (a few bytes each). Then you wind up wasting a lot of space. </p>
<p>Granted, on modern machines, a few hundred bytes of wasted space won’t amount to much. However, it might be more practical to combine several of these procedures into a single object module (even if you don’t call them all) to fill in some of the wasted space. Don’t go overboard, though; once you’ve gone beyond the alignment, whether you’re wasting space because of padding or wasting space because you’re including code that never gets called, you’re still wasting space.</p>
<h2 id="h1-501089c15-0010">	15.10	For More Information</h2>
<p class="BodyFirst">Although it is an older book, covering MASM version 6, <em>The Waite Group’s Microsoft Macro Assembler Bible</em> by Nabajyoti Barkakati and this author (Sams, 1992) goes into much greater detail about MASM’s external directives (<code>extern</code>, <code>externdef</code>, and <code>public</code>) and include files.</p>
<p>You can also find the MASM 6 manual (the last published edition) online.</p>
<p>For more information about makefiles, check out these resources:</p>
<ul>
<li>Wikipedia: <a href="https://en.wikipedia.org/wiki/Make_(software)" class="LinkURL">https://en.wikipedia.org/wiki/Make_(software)</a></li>
<li><em>Managing Projects with GNU Make</em>, Third Edition, by Robert Mecklenburg (O’Reilly Media, 2004)</li>
<li><em>The GNU Make Book </em>by John Graham-Cumming (No Starch Press, 2015)</li>
</ul>
<h2 id="h1-501089c15-0011">	15.11	Test Yourself</h2>
<ol class="decimal">
<li value="1">What statement(s) would you use to prevent recursive include files? </li>
<li value="2">What is an assembly unit? </li>
<li value="3">What directive would you use to tell MASM that a symbol is global and visible outside the current source file?</li>
<li value="4">What directive(s) would you use to tell MASM to use a global symbol from another object module?</li>
<li value="5"><span epub:type="pagebreak" title="872" id="Page_872"/>Which directive prevents duplicate symbol errors when an external symbol is defined within an assembly source file? </li>
<li value="6">What external data type declaration would you use to access an external constant symbol? </li>
<li value="7">What external data type declaration would you use to access an external procedure?</li>
<li value="8">What is the name of Microsoft’s make program? </li>
<li value="9">What is the basic makefile syntax?</li>
<li value="10">What is a makefile-dependent file?</li>
<li value="11">What does a makefile <code>clean</code> command typically do?</li>
<li value="12">What is a library file?</li>
</ol>
<section class="footnotes">
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c15-footnote-1" href="#c15-footnoteref-1">1.</a></sup> There is nothing wrong with this, except that it does not take advantage of separate compilation.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c15-footnote-2" href="#c15-footnoteref-2">2.</a></sup> Technically, MASM has three external directives; <span class="LiteralFootnote"><code>extrn</code></span> is an older name for <span class="LiteralFootnote"><code>extern</code></span>. They are just synonyms. This book uses the <span class="LiteralFootnote"><code>extern</code></span> variant.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c15-footnote-3" href="#c15-footnoteref-3">3.</a></sup> This source file is also part of the generic <em>aoalib.inc</em> header file used to encompass various library functions appearing throughout this book.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c15-footnote-4" href="#c15-footnoteref-4">4.</a></sup> <span class="LiteralFootnote"><code>nmake</code></span> stands for <em>new make</em>, which is Microsoft’s way of saying that it didn’t adhere to the standard make language. That’s fine; <span class="LiteralFootnote"><code>nmake</code></span> will behave just like the Unix variants for the simple operations we need.</p></aside>
<aside class="FootnoteEntry"><p><sup class="FootnoteReference"><a id="c15-footnote-5" href="#c15-footnoteref-5">5.</a></sup> Also see <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10/" class="LinkURL">https://docs.microsoft.com/en-us/windows/wsl/install-win10/</a> to see how to gain access to Linux utilities under Windows.</p></aside>
</section>
</section>
</body></html>