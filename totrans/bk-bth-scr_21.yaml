- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 19 READING FILES AND OTHER INPUTS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19 读取文件和其他输入
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: By far the most involved syntax and powerful functionality of the already powerful
    for command is unleashed with the /F option, which allows for *file reading*.
    The optionless for command can do quite a bit with a file such as getting its
    name, path, drive, size, and attributes, pretty much everything concerning a file
    except its actual contents. Enter the /F option.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，功能强大的 for 命令的最复杂语法和最强大的功能是通过 /F 选项实现的，它允许进行*文件读取*。没有选项的 for 命令已经能够处理文件，比如获取文件的名称、路径、驱动器、大小和属性，几乎涵盖了与文件相关的所有内容，除了文件的实际内容。接下来就是
    /F 选项。
- en: After introducing its syntax, I’ll demonstrate how to read a file, record by
    record. You’ll learn how to manipulate the input data, place the entire contents
    of a record into a variable, or break it into what Batch calls tokens. By tokenizing
    the data, you’ll be able to extract just the portions of data you desire.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍语法后，我将演示如何逐条记录地读取文件。你将学习如何操作输入数据，将记录的全部内容放入变量中，或将其拆分为批处理所称的 tokens。通过对数据进行标记化处理，你将能够提取你需要的特定数据部分。
- en: Although the for /F command ostensibly reads files, the input can take on other
    forms. This command can treat a string as a single record file, and you can even
    use the output from another Batch command as its input. All of this will allow
    you to manipulate and process different forms of information in many different
    ways.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 for /F 命令表面上是用于读取文件的，但输入也可以采用其他形式。这个命令可以将字符串视为单个记录文件，甚至可以将另一个批处理命令的输出作为其输入。所有这些将允许你以多种不同的方式处理和操作不同形式的信息。
- en: The for Command with the /F Option
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 含 /F 选项的 for 命令
- en: 'The /F option transforms the for command into a multifaceted tool for reading
    files. This command with this particular option has multiple forms, but I’ll start
    by considering just one. Here’s the general syntax of the form or variant of the
    for /F command that reads a file or a set of files:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: /F 选项将 for 命令转变为一个多功能的文件读取工具。带有此选项的命令有多种形式，但我将首先考虑其中一种。以下是读取文件或文件集的 for /F 命令的通用语法：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In comparison to the optionless for command, this syntax is quite different.
    Most obviously, the /F option is in place. I’ve also changed the generic input
    placeholder inside the parentheses to the more specific term of file-set, but
    that’s little more than nomenclature. In comparison to the optionless version
    of the command, this variant accepts only a file, a file mask, or multiple files
    or file masks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与没有选项的 for 命令相比，这种语法有很大不同。最明显的是，/F 选项已经到位。我还将括号内的通用输入占位符更改为更具体的术语 file-set，但这仅仅是命名上的不同。与没有选项的命令版本相比，这个变体只接受一个文件、文件掩码或多个文件或文件掩码。
- en: The most significant difference is the addition of the ["suboptions"] clause.
    The square brackets indicate that these suboptions are themselves optional, but
    if you include them, encase them in double quotes. Each of the possible suboptions
    is denoted with its own specific keyword. I’ll discuss one of them, usebackq,
    later in this chapter, but the others have a direct impact on how you will read
    and manipulate the data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最显著的区别是增加了["suboptions"]子句。方括号表示这些子选项本身是可选的，但如果包含它们，必须用双引号括起来。每个可能的子选项都有自己的特定关键字。我将在本章稍后讨论其中一个子选项
    usebackq，但其他子选项会直接影响你如何读取和操作数据。
- en: Reading the Contents of a File
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取文件内容
- en: The keywords tokens, delims, skip, and eol might not roll easily off the tongue,
    but they’re instrumental elements of the suboptions clause, which controls the
    reading of files. The best way to see what they do is to explore the behavior
    of the for /F command without options and then add in the clauses associated with
    these four keywords one by one to demonstrate their usefulness.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 tokens、delims、skip 和 eol 可能不容易说出口，但它们是子选项子句的关键元素，控制着文件的读取。了解它们的最佳方法是探索没有选项的
    for /F 命令的行为，然后逐一添加与这四个关键字相关的子句，以展示它们的用途。
- en: 'Let’s return to the introduction of the for command in [Chapter 17](chapter17.xhtml)
    where I briefly worked with a file named *FourBrits.txt* but said nothing about
    its contents. For this demonstration, assume that it’s a small file of four records.
    Each record has five elements, the first being a language and the remainder being
    four particular male names as they are written in that language. The spaces or
    tabs delimit the elements, and here are the complete contents of the file:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到[第17章](chapter17.xhtml)中for命令的介绍部分，在那里我简要处理了一个名为*FourBrits.txt*的文件，但没有提及其内容。对于这个演示，假设这是一个包含四条记录的小文件。每条记录有五个元素，第一个是语言，其余四个是该语言中写出的四个特定男性名字。元素之间由空格或制表符分隔，下面是文件的完整内容：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Consider this for command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个for命令：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is exactly what you’d now expect: a single line of data displaying
    the path and filename of the input file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 输出正是你现在期望的：一行数据，显示输入文件的路径和文件名：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To demonstrate the new option, I’ll add /F to the logic:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示新选项，我将在逻辑中添加/F：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And now the output:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是输出：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Such a small change results in a vastly different outcome. Instead of a single
    write to the console in the form of the filename, the code now outputs the first
    word of each record inside the file itself. Due to the /F option, the command
    is opening and reading the contents of the file. There’s still much to work out,
    but the command is actually reading each of the four records in the file, setting
    %%a to the first word in the record. If the file had contained 64 populated records,
    the previous logic would have written 64 words to the console on the same number
    of lines.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个小小的变化导致了截然不同的结果。现在，代码不是以文件名的形式向控制台写入单条信息，而是输出文件中每条记录的第一个单词。由于/F选项，命令正在打开并读取文件的内容。还有很多工作要做，但命令实际上是在读取文件中的每一条记录，并将%%a设置为记录中的第一个单词。如果文件包含64条记录，那么之前的逻辑将在控制台上写入64个单词，每个单词占一行。
- en: This output raises many more questions than it answers. Why isn’t this writing
    the entire record? Can we parse out just parts of the record? Must we read every
    record? This is where the keywords in the suboptions clause from the general syntax
    come into play.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出引发了更多问题，而不是解答了它们。为什么这不是写入整个记录？我们可以只解析记录的一部分吗？我们必须读取每条记录吗？这就是通用语法中的suboptions子句的关键字发挥作用的地方。
- en: Tokenizing the Data
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标记化数据
- en: 'A *token* in Batch is an element of a record, and by default each token is
    delimited by spaces or tabs. Inspecting the first record in the file, it contains
    exactly five tokens:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Batch中，一个*标记*是记录的一个元素，默认情况下，每个标记由空格或制表符分隔。检查文件中的第一条记录，它正好包含五个标记：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By default, Batch sets the number of tokens to 1. This explains why in the previous
    example, the interpreter resolved %%a to the first word (or token) in each record
    and dropped the rest of the record.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Batch将标记数量设置为1。这解释了为什么在之前的示例中，解释器将%%a解析为每条记录中的第一个单词（或标记），并丢弃了记录中的其余部分。
- en: 'To change this default, you can use the tokens clause; it’s the tokens keyword
    followed by an equal sign and the setting, which in this case is 2:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改这个默认值，你可以使用tokens子句；它是tokens关键字，后面跟着一个等号和设置，在这种情况下是2：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The tokens clause tells the interpreter which token or tokens to pass into
    the loop as the for variable. Executing this code produces the following output
    written to the console:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: tokens子句告诉解释器将哪个标记或哪些标记作为for变量传递到循环中。执行此代码会产生以下输出，写入控制台：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Due to the tokens clause, the interpreter now sends the second word or token
    into the loop, writing John and its translations to the console. Setting it to
    5 would have retrieved Richard’s name instead. With this clause you can extract
    a single token with relative ease.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于tokens子句，解释器现在将第二个单词或标记传递到循环中，将John及其翻译写入控制台。将其设置为5将检索到Richard的名字。通过这个子句，你可以相对轻松地提取单个标记。
- en: Extracting Multiple Tokens
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提取多个标记
- en: It’s nice to be able to pull out individual tokens, but it’s more useful to
    be able to pull out multiple and select tokens. To extract all five tokens, assign
    the text 1-5 to the tokens keyword. But this raises an interesting question. How
    will those five tokens be resolved with only the single variable, %%a, defined?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 能够提取单个标记很不错，但能够提取多个并选择标记会更有用。要提取所有五个标记，将文本1-5分配给tokens关键字。但这引出了一个有趣的问题。如何仅通过定义单个变量%%a来解析这五个标记呢？
- en: 'Additional variables are elegantly implied in simple alphabetical order. If
    %%a is the variable defined in the for /F command, it resolves to the first token
    defined in the tokens clause, then %%b resolves to the second, %%c to the third,
    %%d to the fourth, and, finally, %%e to the fifth. Consider the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的变量以简单的字母顺序优雅地表示。如果%%a是for /F命令中定义的变量，它解析为标记子句中定义的第一个标记，接着%%b解析为第二个，%%c解析为第三个，%%d解析为第四个，最后%%e解析为第五个。考虑以下内容：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code formats the record so that the language is followed by a colon and
    two spaces. Then in the output, the names are separated by commas and spaces with
    a conjunction before the last name:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将记录格式化，使语言后跟冒号和两个空格。然后，在输出中，名称之间用逗号和空格分隔，最后一个名字前有一个连接词：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also pick and choose which tokens to extract instead of a range. A
    comma in the tokens clause separates the desired tokens. This code sends only
    the second and fourth tokens into the loop:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以选择提取特定的标记，而不是一个范围。在标记子句中，用逗号分隔所需的标记。此代码仅将第二个和第四个标记传入循环：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This result is written to the console:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将写入控制台：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The second token from the data record is now the first token the tokens clause
    defines, so Batch assigns it to %%a, not %%b. Likewise, %%b now resolves to the
    fourth token in the record, which is the second token selected. More succinctly,
    the variable letter mimics the token’s position defined by the tokens clause—not
    its position in the record.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，数据记录中的第二个标记是标记子句定义的第一个标记，因此Batch将其分配给%%a，而不是%%b。同样，%%b现在解析为记录中的第四个标记，也就是第二个选中的标记。简而言之，变量字母模仿的是标记子句中定义的标记位置，而不是它在记录中的位置。
- en: 'To this point, I’ve used %%a as the for variable. Regardless of the letter
    you choose for the variable, the interpreter assigns subsequent tokens to corresponding
    letters in the alphabet. The previous code is functionally equivalent to the following
    code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我使用了%%a作为for变量。无论你选择哪个字母作为变量，解释器都会将后续标记分配给字母表中的相应字母。之前的代码在功能上等价于以下代码：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The only difference is that I’ve changed %%a to %%x, meaning that %%y now resolves
    to the second token instead of %%b.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是我将%%a改为了%%x，这意味着%%y现在解析为第二个标记，而不是%%b。
- en: The catch is that choosing %%x as the for variable limits you to just three
    possible tokens, because there’s nothing to assign after %%z (despite the efforts
    of Dr. Seuss in *On Beyond Zebra!*). You won’t see this nearly as often, but numbers
    also work. For instance, if you extract three tokens and define the for variable
    as %%7, the interpreter will use %%8 and %%9 for the implied tokens.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，选择%%x作为for变量限制了你只能处理三个可能的标记，因为在%%z之后没有更多的标记可以分配（尽管《超越斑马》（*On Beyond Zebra!*）中的Dr.
    Seuss努力过）。你不会经常看到这种情况，但数字也有效。例如，如果你提取三个标记并将for变量定义为%%7，解释器将使用%%8和%%9作为隐式标记。
- en: The keyword also accepts a combination of numbers, commas, and dashes. For instance,
    the tokens=1,3-5 clause processes all of the tokens except John, the second token.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该关键字还接受数字、逗号和短横线的组合。例如，tokens=1,3-5子句处理除John（第二个标记）之外的所有标记。
- en: Extracting the Remainder of a Record
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提取记录的其余部分
- en: 'There’s another twist concerning the tokens keyword. An asterisk represents
    the remainder of the input record as is, including embedded whitespaces. Consider
    this code using 2* in the tokens clause:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 关于标记关键字，还有另一个变化。星号表示输入记录的其余部分，包括嵌入的空格。考虑这段使用 2* 的代码在标记子句中的情况：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This command assigns the second token to %%a because of the 2 in the clause;
    then the interpreter assigns the remainder of the record, the third, fourth, and
    fifth tokens, including any embedded spaces and tabs, to %%b because of the asterisk
    (*). The language, the first token in each record, isn’t to be found anywhere
    in the output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将第二个标记分配给%%a，因为子句中的2；然后解释器将记录的其余部分，即第三、第四和第五个标记，包括任何嵌入的空格和制表符，分配给%%b，因为星号(*)。语言，即每个记录中的第一个标记，在输出中找不到：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To bring this discussion full circle, when we simply added the /F option to
    the for command at the beginning of the chapter, the default tokens clause passed
    the first token only into the code block. On many occasions you’ll want to extract
    the entire record exactly as it appears in the input file as a single entity.
    Since the asterisk represents the rest of the input record, assigning it alone
    to tokens selects the entire record:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这个讨论圆满结束，当我们在本章开始时仅仅为 for 命令添加了 /F 选项时，默认的标记子句只将第一个标记传递到代码块。在许多情况下，你会希望将整个记录完整地提取出来，正如它在输入文件中所呈现的那样作为一个整体。由于星号代表输入记录的其余部分，单独将它分配给标记就会选择整个记录：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Also notice that I changed the variable to %%r. Here’s the output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 同时请注意，我将变量改为 %%r。这里是输出结果：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The prior use of %%a would have worked fine, but I’ve changed it here for two
    reasons: first, r stands for *record*, and second, as a simple reminder that any
    alphabetic character will work.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之前使用 %%a 完全可以正常工作，但我在这里做了修改，原因有两个：首先，r 代表*记录*，其次，作为一个简单的提醒，任何字母字符都可以使用。
- en: NOTE
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*As mentioned in [Chapter 17](chapter17.xhtml), the for variable is actually
    case-sensitive, and some nonalphanumeric characters are permitted. This means
    %%a and %%b resolve only to the first two tokens for the variable defined as %%a;
    %%A and %%B won’t work, unless you change the for variable to %%A. I probably
    don’t need to mention this, but those oddball characters (think %%#) don’t lend
    themselves at all to extracting multiple tokens.*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*如[第17章](chapter17.xhtml)中所提到，for 变量实际上是区分大小写的，并且允许一些非字母数字字符。这意味着 %%a 和 %%b
    仅能解析为定义为 %%a 的变量的前两个标记；%%A 和 %%B 不会生效，除非你将 for 变量改为 %%A。我可能不需要再提，但那些奇怪的字符（比如 %%#）根本不适合用来提取多个标记。*'
- en: Defining the Set of Data Delimiters
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义数据分隔符集
- en: Being able to break up an input record into tokens defined by delimiters such
    as spaces and tabs is powerful indeed, but in many instances, you don’t have control
    over the data in the file that you’re reading, and a different delimiter, or even
    a set of delimiters, would be far more applicable. The delims keyword defines
    one to many *delimiters* used to tokenize the data.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将输入记录分解为由空格和制表符等分隔符定义的标记确实非常强大，但在许多情况下，你无法控制正在读取的文件中的数据，而不同的分隔符，甚至是多个分隔符，会更加适用。delims
    关键字定义了用于标记数据的一种或多种*分隔符*。
- en: Parsing Comma-Delimited Data
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解析逗号分隔数据
- en: A comma-delimited format is a popular and easy way of storing data. For instance,
    a *.csv* file contains any number of comma-delimited records, and you can open
    it and view the data with Excel. Each token is delimited by a comma, and each
    token can contain spaces. Before demonstrating how Batch reads in CSV data, I’ll
    need some setup.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号分隔格式是一种流行且简便的存储数据方式。例如，*.csv* 文件包含任意数量的逗号分隔记录，你可以使用 Excel 打开并查看数据。每个标记由逗号分隔，每个标记可以包含空格。在展示
    Batch 如何读取 CSV 数据之前，我需要做一些设置。
- en: 'The *FourBrits.txt* file might contain a name with embedded spaces such as
    Richard aka Ringo. In the space-delimited examples discussed so far, this text
    constitutes three distinct tokens. I’ll now reformat the data and present it in
    a comma-delimited file called *FourBrits.csv*. The contents of this file will
    be the same as its like-named *.txt* file except for the delimiters and Richard’s
    alias:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*FourBrits.txt* 文件可能包含带有嵌入空格的名字，比如 Richard aka Ringo。在之前讨论的空格分隔示例中，这段文本包含三个不同的标记。我现在将重新格式化数据，并以逗号分隔的文件
    *FourBrits.csv* 提供。该文件的内容将与其同名的 *.txt* 文件相同，只是分隔符和 Richard 的别名有所不同：'
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next task is to modify the for /F command so that it treats the commas
    as delimiters in lieu of the spaces, and I’ll accomplish this with the delims
    keyword. When the keyword isn’t present, the interpreter defaults to the set of
    delimiters containing just the space and tab characters. In the following example,
    delims=, defines the set of delimiters as a single character, the comma:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步任务是修改 for /F 命令，使其将逗号作为分隔符而不是空格，我将通过 delims 关键字实现这一点。当关键字不存在时，解释器会默认为只包含空格和制表符字符的分隔符集。在以下示例中，delims=,
    将分隔符集定义为单个字符，即逗号：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When the interpreter now comes to the fifth and final token—a name followed
    by aka Ringo—it writes the text to the console complete with its embedded spaces:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当解释器遇到第五个也是最后一个标记——一个名字后跟别名 Ringo 时——它会将文本写入控制台，保留其中的空格：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Ringo is nontranslatable.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Ringo 是不可翻译的。
- en: Pipe-delimited data files are also popular; the delims=| clause parses the input
    data on the pipe so that embedded spaces and commas won’t create additional tokens.
    The equal sign can even be a delimiter with the delims== clause. (You’ll see an
    example of that before long.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管道分隔的数据文件也很流行；delims=|子句解析输入数据中的管道，这样内嵌的空格和逗号就不会创建额外的标记。等号甚至可以作为分隔符，使用delims==子句。（你很快会看到相关示例。）
- en: Defining Multiple Delimiters
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义多个分隔符
- en: 'You can even define multiple delimiters with a single delims clause. The following
    code defines the set of delimiters to be the comma and the space. It’s subtle,
    but in comparison to the previous example, the only change is that I’ve added
    a space in between delims=, and the trailing double quote:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以通过一个delims子句定义多个分隔符。以下代码将分隔符集合定义为逗号和空格。虽然很微妙，但与之前的示例相比，唯一的变化是我在delims=和后续的双引号之间添加了一个空格：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The interpreter will now see a new token whenever it encounters a space or a
    comma. The fifth token will be only the name Richard, in some language, with aka
    and Ringo relegated to the unassigned sixth and seventh tokens, respectively.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，解释器每次遇到空格或逗号时，都会看到一个新的标记。第五个标记将仅包含名字Richard，而aka和Ringo分别被分配到未分配的第六个和第七个标记。
- en: 'To demonstrate an even larger set of delimiters, I’ll use a one-record file
    named *Alphabets.txt*, containing the uppercase and lowercase Latin alphabets,
    with one space separating them:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示更大范围的分隔符，我将使用一个名为*Alphabets.txt*的单记录文件，其中包含大写和小写的拉丁字母，中间用一个空格隔开：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Omitting the delims clause entirely invokes the default delimiter set and results
    in just two tokens, the uppercase and the lowercase character sets, and nothing
    more. Instead, in the following code, I’m setting the delims keyword to the Delims
    text and a trailing space:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 完全省略delims子句将调用默认的分隔符集合，并仅生成两个标记：大写字符集和小写字符集，除此之外没有更多内容。相反，在以下代码中，我将delims关键字设置为Delims文本和一个尾随空格：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If each of the seven delimiters occurs just once in the data, it seems logical
    that this logic creates eight tokens. That’s not necessarily true, but I’ve defined
    that many with the tokens=1-8 clause and added the same number of echo commands.
    But let’s keep an eye on the number of tokens generated. Here’s the resulting
    output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据中每个分隔符仅出现一次，似乎逻辑上会产生八个标记。虽然这不一定是正确的，但我已经通过tokens=1-8子句定义了这么多个标记，并添加了相同数量的echo命令。让我们关注一下生成的标记数量。以下是结果输出：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There is much to point out here, including the fact that the delimiter set
    is case-sensitive. The uppercase D is one delimiter, but not d. The lowercase
    letters e, l, i, m, and s, along with a space, round out the set of delimiters.
    It’s a little easier to see the origin of these seven tokens when looking at the
    original data with the delimiters (other than the space) bolded:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有许多需要注意的点，包括分隔符集合是区分大小写的事实。大写字母D是一个分隔符，但小写字母d不是。小写字母e、l、i、m和s，以及空格，组成了完整的分隔符集合。当查看原始数据，并将除了空格以外的分隔符加粗时，更容易理解这七个标记的来源：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that this data has two of the delimiters (l and m) listed sequentially,
    and because nothing is between them, you might expect the interpreter to assign
    null or nothing to the sixth token and bump the text after it, nopqr, to the seventh
    token. Batch, however, treats the consecutive delimiters (lm) as a single delimiter
    so that the sixth token is the text nopqr. Thus, tuvwxyz is the seventh token,
    and since nothing comes after it, the eighth token resolves to nothing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些数据中列出了两个分隔符（l 和 m）按顺序排列，并且由于它们之间没有任何内容，你可能会预期解释器将为第六个标记分配空值或空白，并将其后面的文本nopqr移到第七个标记。然而，Batch将连续的分隔符（lm）视为一个单一的分隔符，因此第六个标记是文本nopqr。因此，tuvwxyz是第七个标记，且由于它后面没有内容，第八个标记的值为空。
- en: Be careful to use only tokens that you’ve defined. If the clause had been tokens=1-7,
    the final echo command would have resulted in Token 8 = %h, because %%h wouldn’t
    have been the eighth token; it would have been a percent sign escaping another
    percent sign, followed by a hardcoded character.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意只使用你已定义的标记。如果子句是tokens=1-7，最终的echo命令将导致Token 8 = %h，因为%%h不会是第八个标记；它将是一个百分号转义另一个百分号，后面跟着一个硬编码的字符。
- en: When parsing comma-delimited (or pipe-delimited) data, many compiled languages
    treat consecutive delimiters as two delimiters, honoring the null in between them,
    which makes perfect sense. Batch, however, typically delimits on spaces, and one
    look at the original *FourBrits.txt* data with its varying number of spaces between
    each word makes it clear that it also makes perfectly good sense to treat multiple
    spaces as a single delimiter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析逗号分隔（或管道分隔）数据时，许多编译语言将连续的分隔符视为两个分隔符，并尊重它们之间的空值，这完全是合理的。然而，Batch 通常以空格作为分隔符，只需看看原始的*FourBrits.txt*
    数据，其中每个单词之间的空格数量不一，就可以清楚地看到，视多个空格为单一分隔符也是非常合乎逻辑的。
- en: Unfortunately, this does lead to some frustration when instead of spaces, your
    data is delimited by commas, but in [Chapter 20](chapter20.xhtml), I’ll show you
    how to make the for loop honor the nulls between consecutive delimiters. However,
    if I have control over the input data that’s delimited on just a comma, I’ll always
    write a null element to the file as a space in between two commas.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这确实会带来一些挫败感，尤其是当数据不是以空格，而是逗号分隔时，但在[第20章](chapter20.xhtml)中，我会向你展示如何让 for
    循环尊重连续分隔符之间的空值。然而，如果我能够控制仅以逗号分隔的输入数据，我会总是在两个逗号之间写入一个空元素作为空格。
- en: I’ve listed the space last in the set of delimiters because it has to come last.
    I hate to disparage the interpreter yet again, but it gets confused if it finds
    the space anywhere else. For that reason, when including a space in the delimiter
    set, the delims clause must come at the end of the suboptions, just prior to the
    trailing double quote.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我将空格放在分隔符集合中的最后，因为它必须排在最后。我不想再次贬低解释器，但如果空格出现在其他位置，它会感到困惑。因此，在将空格包含在分隔符集合中时，delims
    子句必须放在子选项的最后，紧接在结尾的双引号之前。
- en: Skipping Header Records
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 跳过头部记录
- en: As you’ve just seen, the tokens and delims keywords have a great deal of nuance.
    The next couple are far more straightforward, especially the skip keyword, which
    lets you skip any number of header records as you read a file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如你刚刚看到的，tokens 和 delims 关键字有很多微妙之处。接下来的几个关键字则简单得多，特别是 skip 关键字，它可以让你在读取文件时跳过任意数量的头部记录。
- en: 'Let’s return to the original *FourBrits.txt* file and add a header record before
    the unchanged content in the next four records:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到原始的*FourBrits.txt* 文件，在接下来的四条记录之前添加一个头部记录：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s run the same for /F loop from the tokens keyword discussion:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行来自 tokens 关键字讨论的相同的 for /F 循环：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It processes the header line as any other, producing the following garbage
    output, followed by the four lines of good output (only one of which I’m showing):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它将头部行作为其他行一样处理，输出以下垃圾数据，后面跟着四行有效输出（我只展示其中一行）：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Fortunately, the skip keyword defines the number of records to be skipped at
    the beginning of the file. This will skip the first record and process the data
    records perfectly:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，skip 关键字定义了在文件开头要跳过的记录数。这样就会跳过第一条记录，并完美处理数据记录：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If there had been three header records, the skip=3 clause would have made the
    for command start at the fourth record.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有三条头部记录，skip=3 子句会使 for 命令从第四条记录开始。
- en: Suppressing Comment Records
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 抑制注释记录
- en: While the skip keyword skips records only at the beginning of a file, the eol
    keyword, which stands for *end of line* comment character, bypasses all records
    in the file that start with a defined character. If I were being charitable, I’d
    say that when the interpreter sees the defined *character* in the first byte of
    a record, it considers the character to be the *end of line* and treats what remains
    as a *comment*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 skip 关键字仅跳过文件开头的记录，但 eol 关键字（表示*行尾*注释字符）跳过文件中所有以定义字符开头的记录。如果我要宽容一点的话，我会说，当解释器在记录的第一个字节中看到定义的*字符*时，它会将该字符视为*行尾*，并将剩余部分视为*注释*。
- en: 'To demonstrate, let’s edit the input file again. This time I’m adding a second
    comment record, and more important, each comment record now starts with a period:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们再次编辑输入文件。这一次，我添加了第二条注释记录，更重要的是，每条注释记录现在都以句点开头：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Adding the eol=. clause to the same for command instructs the interpreter to
    skip the comment lines, regardless of where they appear in the data, and process
    only the remaining records:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 向相同的 for 命令中添加 eol=. 子句指示解释器跳过所有注释行，无论它们在数据中出现的位置如何，并只处理其余的记录：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Unfortunately, this straightforward keyword has its very own batveat. Given
    that the delims clause accepts a list of delimiters, you’re probably expecting
    the eol clause to accept one to many characters. But no, it accepts only a single
    character.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个简单明了的关键字也有它自己的限制。鉴于 `delims` 子句接受一组分隔符，你可能期望 `eol` 子句接受一个或多个字符。但实际上，它只接受一个字符。
- en: The phrase tokens, delims, skip, and eol doesn’t quite roll off the tongue quite
    like John, Paul, George, and Ringo, but these fabulous four keywords allow for
    a great deal of flexibility, and there will be more examples of clauses associated
    with these keywords in this chapter and others.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 `tokens`、`delims`、`skip` 和 `eol` 可能不像 John、Paul、George 和 Ringo 那样朗朗上口，但这四个精彩的关键字提供了极大的灵活性，本章及其他章节中还会有更多与这些关键字相关的子句示例。
- en: Defining the Input
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义输入
- en: You now know how to read a file with the for /F command, but you might not yet
    know how to read a *file*—there’s a distinction. A traditional file is a collection
    of bytes organized into records stored in a referenceable location on a drive
    defined by a directory and filename. A *file* is some sort of input readable by
    the for /F command; it can take different forms and doesn’t have to be something
    that an editor can open.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道如何使用 `for /F` 命令读取一个文件，但你可能还不知道如何读取一个*文件*——这之间是有区别的。传统的文件是由存储在驱动器上的一个可引用位置中的记录组成的字节集合，这些记录通过目录和文件名进行定义。而*文件*是某种可以被
    `for /F` 命令读取的输入；它可以采取不同的形式，并不一定是编辑器能够打开的东西。
- en: Other than a traditional file, this command can accept a string as input and
    also the output of another Batch command. As you’ll soon see, subtle difference
    in the syntax dictates the type of input.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了传统的文件，这个命令还可以接受字符串作为输入，也可以接受另一个批处理命令的输出。正如你将很快看到的那样，语法中的微小差别决定了输入的类型。
- en: File Input
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件输入
- en: 'The file-set input is a traditional file or set of files. I’ve already shown
    several examples of that form throughout this chapter. Each example contained
    one file inside the parentheses, and we now know those inputs were files because
    of the lack of any encasing quotes, single or double. What you’ve yet to see is
    a set of files. The following command reads the contents of two files in the order
    that they are listed in the file-set, delimited by a comma or a space, or both
    for readability:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 文件集输入是传统的文件或一组文件。我在本章中已经展示了几次这种形式的示例。每个示例中括号内都包含一个文件，现在我们知道这些输入是文件，因为没有任何围绕的引号，无论是单引号还是双引号。你还没有看到的是一组文件。以下命令按文件集中的列出顺序读取两个文件的内容，文件之间由逗号、空格或两者的组合作为分隔符，方便阅读：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Assuming that the first file, *FourBrits.txt*, has four records, the for /F
    command processes each in order, writing four lines to the console. The interpreter
    then closes that file and opens *MoreBrits.txt*. Each record in this file triggers
    one execution of the logic inside the code block and writes one more line to the
    console. I also removed the file paths, so the interpreter will look for these
    files in the current directory and the directories defined in the path variable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 假设第一个文件 *FourBrits.txt* 有四条记录，`for /F` 命令按顺序处理每一条记录，向控制台写入四行。解释器接着关闭该文件并打开 *MoreBrits.txt*。此文件中的每一条记录都会触发一次代码块内逻辑的执行，并向控制台再写入一行。我还删除了文件路径，因此解释器将在当前目录以及路径变量中定义的目录中查找这些文件。
- en: String Input
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串输入
- en: 'Here is the general syntax for the for /F command using a string as input.
    Take note of the input inside the parentheses:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用字符串作为输入的 `for /F` 命令的一般语法。请注意括号内的输入：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This form replaces the input text with "string". The double quotes tell the
    interpreter that they are encasing some sort of text, while a complete lack of
    quotes tells the interpreter to consider the input to be a file or a set of files.
    Everything else works exactly the same.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式将输入文本替换为“字符串”。双引号告诉解释器它们包围的是某种文本，而完全没有引号则告诉解释器考虑输入为文件或一组文件。其他部分的工作方式完全相同。
- en: 'The following for /F command is similar to other examples used earlier in this
    chapter, other than the input:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `for /F` 命令与本章前面使用的其他示例类似，唯一不同的是输入：
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The only difference is that I’ve taken the last line of text from *FourBrits.txt*,
    removed some extra spaces for readability, and entered it as the string encased
    in double quotes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是，我已将 *FourBrits.txt* 的最后一行文本移除了一些额外的空格以提高可读性，并将其作为被双引号包围的字符串输入。
- en: 'The echo command inside the code block doesn’t know the source of the five
    tokens, whether it’s from a hardcoded string or a record read from a file. Here’s
    the familiar result:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块中的 `echo` 命令并不知道这五个标记的来源，是否来自硬编码的字符串或从文件读取的记录。这里是我们熟悉的结果：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, the text inside the parentheses is hardcoded, but you can use
    a variable containing text, as long as it’s encased in double quotes. You can
    use any string as input, and the interpreter treats it like a single record file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，括号内的文本是硬编码的，但你也可以使用包含文本的变量，只要它被双引号括起来。你可以使用任何字符串作为输入，解释器会将其视为一个单一记录文件。
- en: 'This feature allows for sophisticated string parsing. I actually used this
    feature in [Chapter 5](chapter5.xhtml) with absolutely no explanation of how it
    worked, promising an explanation later. A for /F command converted a boolean to
    a boolean string, where the bGod boolean contained one of two values, true==true
    or false==x. At the time I mentioned, while attributing it to little more than
    a magic trick, that the command strips off the two equal signs and all that follows,
    giving bStrGod the value of true or false:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性使得复杂的字符串解析成为可能。实际上，我在 [第 5 章](chapter5.xhtml) 中使用了这个功能，却完全没有解释它是如何工作的，承诺稍后会解释。`for
    /F` 命令将布尔值转换为布尔字符串，其中 `bGod` 布尔值包含两个值中的一个，`true==true` 或 `false==x`。当时我提到，尽管将其归结为不过是个魔术技巧，这个命令会去掉两个等号及其后的所有内容，从而将
    `bStrGod` 的值设为 `true` 或 `false`：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With what you’ve learned in this chapter, you can now figure out how this works.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章所学，你现在可以弄清楚它是如何工作的。
- en: The for /F command treats the resolved boolean encased in double quotes inside
    the parentheses as string or text input. The delims clause defines the equal sign
    as the only delimiter, and since I haven’t defined the tokens keyword, the default
    clause of tokens=1 is implied. The result is that the word before the equal signs
    is the first token, and the interpreter resolves it as %%b (for *boolean*, of
    course), while discarding the second token coming after the equal signs. The set
    command then assigns that first token to the boolean string on its first and only
    execution.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`for /F` 命令将括号内双引号中的解析布尔值视为字符串或文本输入。`delims` 子句将等号定义为唯一的分隔符，并且由于我没有定义 `tokens`
    关键字，所以隐式地采用了默认子句 `tokens=1`。结果是，等号前的词是第一个标记，解释器将其解析为 `%%b`（当然是为 *boolean*），同时丢弃等号后面的第二个标记。`set`
    命令然后在第一次也是唯一一次执行时将第一个标记赋值给布尔字符串。'
- en: So, it’s not a magic trick at all, instead just a concise means of pulling a
    single delimited value out of a larger string with a single line of code. Behold
    the power of the for /F command and its multiple inputs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这根本不是什么魔术，而仅仅是一种简洁的方法，通过一行代码从更大的字符串中提取一个单一的分隔值。请看 `for /F` 命令及其多个输入的强大功能。
- en: Command Input
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 命令输入
- en: 'What’s inside the parentheses dictates the input of any for /F command. You
    know that no quotes indicate a file and that double quotes indicate a string.
    Single quotes indicate that another Batch command is the input, and here’s its
    general syntax:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 括号内的内容决定了任何 `for /F` 命令的输入。你知道没有引号表示一个文件，双引号表示一个字符串。单引号表示另一个 Batch 命令是输入，下面是它的一般语法：
- en: '[PRE37]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Any Batch command entered between the single quotes executes first, with its
    resulting stdout being the input to the for /F command. The interpreter then processes
    what it considers to be the input, line by line if there’s more than one, as if
    it were a file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在单引号之间输入的任何 Batch 命令会先执行，其结果的标准输出（stdout）将作为 `for /F` 命令的输入。解释器随后会逐行处理它认为是输入的内容，如果有多行，就像处理一个文件一样。
- en: 'To demonstrate the usefulness of a command as input, consider the dir command
    introduced in [Chapter 13](chapter13.xhtml). The following command lists all of
    the text files in the given directory:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示命令作为输入的有用性，考虑在 [第 13 章](chapter13.xhtml) 中介绍的 `dir` 命令。以下命令列出给定目录中的所有文本文件：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The /B option produces a list of filenames and extensions only—no file dates
    and sizes, and no header and trailer lines. But the command simply writes this
    information to stdout for your perusal and little more. Many times, you’ll want
    to take this list of files and execute some logic against each one. For example,
    let’s write some code to change the extension on all *.txt* files in a directory
    to *.bak* to signify that they’re backup files.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`/B` 选项只会生成文件名和扩展名的列表——没有文件日期和大小，也没有头部和尾部行。命令只会将这些信息写入标准输出供你查看，仅此而已。很多时候，你会想将这个文件列表拿来对每个文件执行某些逻辑。例如，让我们编写一些代码，将目录中所有
    `*.txt` 文件的扩展名改为 `*.bak`，以表示它们是备份文件。'
- en: 'The single quotes tell the for /F command that the input is a command. The
    dir command generates a list of filenames, each with an extension and no path:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号告诉 for /F 命令输入的是一个命令。dir 命令生成一个文件名列表，每个文件名都带有扩展名但没有路径：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The tokens=* clause ensures that %%f takes on the entire string as its value
    as it enumerates through the list of files. The default clause would have dropped
    everything after the first embedded space in the name. The ren command renames
    the file, using the modifier for the filename (N) and tacking on the hardcoded
    extension.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: tokens=* 子句确保 %%f 在遍历文件列表时将整个字符串作为其值。默认子句会丢弃名称中第一个嵌入空格后的所有内容。ren 命令重命名文件，使用文件名的修改符（N），并附加上硬编码的扩展名。
- en: I hope that you can appreciate how extremely impressive this is. Three commands
    are bound up together to perform quite a bit in just a couple lines of code. For
    those who use this often, it can become commonplace, and for others it might just
    be overwhelming, but in many languages something like this isn’t possible without
    an intermediate file. With this technique, the dir command isn’t just something
    that can dump information to the console or into a file (although that can also
    be useful). The unadulterated bare format of the output was clearly designed for
    this purpose. You can perform many processes, simple or complex, on any number
    of files. I’ll expand on this when I delve into some real-world applications.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能理解这一点有多么令人印象深刻。三个命令被绑定在一起，只需几行代码就可以完成相当多的操作。对于经常使用它的人来说，这可能变得司空见惯，而对于其他人来说，可能会觉得有些压倒性，但在许多语言中，类似的操作没有中间文件是做不到的。使用这种技术，dir
    命令不仅仅是将信息输出到控制台或文件中（虽然这也很有用）。输出的原始格式显然是为此目的设计的。你可以对任意数量的文件执行许多处理，无论是简单的还是复杂的。我会在深入一些实际应用时进一步展开。
- en: Alternative Syntax for Input Types
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入类型的替代语法
- en: For some inputs the syntax just discussed simply doesn’t work. Sometimes a filename
    contains embedded spaces, but encasing it in double quotes turns it into string
    input. If a string contains a double quote, you can’t encase it in a pair of those
    characters. Likewise, commands sometimes contain single quotes. These cases pose
    a problem requiring a different syntax, and the usebackq keyword, the last of
    the suboptions available with the for /F command, is the solution.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些输入，刚才讨论的语法根本不起作用。有时文件名包含空格，但将其用双引号括起来会使其变成字符串输入。如果字符串中包含双引号，你就无法将其用一对双引号括起来。同样，命令有时会包含单引号。这些情况就需要不同的语法，而
    usebackq 关键字，作为 for /F 命令的最后一个子选项，是解决方案。
- en: Before going any further, some Batch abbreviations are obvious; I probably didn’t
    need to tell you that delims is short for *delimiters* and that tokens is short
    for, well, *tokens*. But there’s a good chance that you are puzzled by the cryptic
    text usebackq. The keyword stands for *use back quote*, which probably doesn’t
    help much, but at least now you’ll know how to pronounce it when you see it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入之前，有些批处理缩写是显而易见的；我大概不需要告诉你 delims 是 *delimiters* 的缩写，tokens 是 *tokens* 的缩写。但你可能会对这个加密的文本
    usebackq 感到困惑。这个关键字代表 *use back quote*，虽然这可能没什么帮助，但至少现在你知道看到它时该怎么发音了。
- en: File Input
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件输入
- en: The best way to show the usefulness of the usebackq keyword is to re-create
    the type of situation that surely led to its creation. Many examples to this point
    in the chapter have read a file named *FourBrits.txt*. I rarely embed spaces in
    filenames, but someone else might have named this file *Four Brits.txt*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 展示 usebackq 关键字有用性的最佳方法是重新创建一种无疑促使其诞生的情境。到目前为止，本章中的许多示例都读取了一个名为 *FourBrits.txt*
    的文件。我很少在文件名中嵌入空格，但别人可能会将这个文件命名为 *Four Brits.txt*。
- en: 'To demonstrate the problem spaces can cause, I’ve lifted the following for
    /F command verbatim from earlier, except the filename now contains an embedded
    space:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示空格可能带来的问题，我从之前的内容中直接复制了以下 for /F 命令，只是文件名现在包含了一个嵌入的空格：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Batch considers this to be two files (not one) and will likely fail, not being
    able to find an extensionless file named *Four*. The obvious solution is to put
    double quotes around the path and filename, but the for /F command will treat
    that as a text string instead of a filename, so that won’t work.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理将此视为两个文件（而不是一个），可能会失败，因为找不到名为 *Four* 且没有扩展名的文件。显而易见的解决方案是将路径和文件名用双引号括起来，但
    for /F 命令会将其视为文本字符串而不是文件名，因此这种方法行不通。
- en: 'The solution is to use the usebackq keyword *and* double quotes around the
    input:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用 usebackq 关键字 *并* 在输入周围加上双引号：
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This keyword also makes it easier to process paths and filenames containing
    special characters such as parentheses.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关键字还使处理包含特殊字符（如括号）的路径和文件名变得更容易。
- en: 'The for /F command successfully reads the file and produces the same output
    as before. You can even read multiple files, each with embedded spaces in their
    names:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`for /F` 命令成功地读取文件并产生与之前相同的输出。你甚至可以读取多个文件，每个文件的名字中都有空格：'
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice that the filenames are delimited by a comma and that a set of double
    quotes encases each filename.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，文件名由逗号分隔，并且每个文件名都被一对双引号括起来。
- en: 'Here’s the general syntax of the command using a file-set as input with the
    usebackq keyword:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用文件集作为输入并带有 `usebackq` 关键字的命令的一般语法：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This keyword changes the rules. Double quotes can surround each filename, although
    it still works with the keyword and without any double quotes, assuming the filename
    has no embedded spaces.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关键字改变了规则。双引号可以包围每个文件名，尽管它在没有双引号的情况下仍然与关键字一起工作，前提是文件名中没有嵌入空格。
- en: String Input
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串输入
- en: 'The usebackq keyword solved one problem but created another. It enables the
    use of double quotes around a filename, but this seems to disallow the ability
    to process a string. The solution is to encase the text in a different character
    and that character is the single quote. Here’s the general syntax:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`usebackq` 关键字解决了一个问题，但又创造了另一个问题。它允许在文件名周围使用双引号，但这似乎禁止了处理字符串的能力。解决方案是将文本用不同的字符括起来，这个字符就是单引号。以下是一般语法：'
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Therefore, the following two for commands are functionally equivalent:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下两个 `for` 命令在功能上是等价的：
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Without usebackq, I’m encasing the short list of Stooges in double quotes, but
    single quotes encase the same text when the keyword is present. (I’m also using
    the break or *no operation* command to make these commands valid while focusing
    on the keyword and the type of quotes, but these commands produce no output.)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 `usebackq`，我将 Stooges 的简短列表括在双引号中，而当关键字存在时，单引号会将相同的文本括起来。（我还使用了 `break`
    或 *无操作* 命令，使这些命令在关注关键字和引号类型的同时有效，但这些命令不会产生任何输出。）
- en: 'Why does Batch provide two means of performing the same task? To answer this
    question, I’ll use a string of Chicago airports, each encased in parentheses for
    some unknown reason, as the input. The following two commands are functionally
    equivalent:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 Batch 提供两种执行相同任务的方法？为了回答这个问题，我将使用一串芝加哥机场的名称，每个机场名出于某种未知原因都被括在括号中，作为输入。以下两个命令在功能上是等价的：
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The first example, which doesn’t use usebackq, is far more workable. You must
    escape special characters such as the parentheses when using the keyword, all
    because of the lack of double quotes. But without the keyword, these characters
    are just along for the ride inside the double quotes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例，没有使用 `usebackq`，要更加易于操作。你必须转义特殊字符，如括号，因为缺少双引号。但如果没有关键字，这些字符只是出现在双引号中的一部分。
- en: 'But the one character that will never work in a double-quoted string is a solitary
    double quote itself—even when escaped. Returning to the Stooges, while Iggy Pop
    was the front man for *The Stooges*, he clearly wasn’t a member of *The Three
    Stooges*, so I might want to put his name in scare quotes, or double quotes, to
    denote the irony:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在双引号字符串中，唯一永远不起作用的字符就是孤立的双引号本身——即使它被转义。回到 Stooges，虽然 Iggy Pop 是 *The Stooges*
    的主唱，但他显然不是 *The Three Stooges* 的成员，所以我可能想用引号或者双引号把他的名字括起来，以表示讽刺：
- en: '[PRE47]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: (The interpreter is intelligent enough to handle an even number of double quotes
    inside a set of double quotes, but for clarity I always use the keyword and encase
    the entire input in single quotes when the string has any double quotes.)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: （解释器足够智能，可以处理双引号字符串中的双引号个数是偶数的情况，但为了清晰起见，当字符串中包含任何双引号时，我总是使用关键字并将整个输入用单引号括起来。）
- en: 'This for /F command writes the following to the console:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `for /F` 命令将以下内容写入控制台：
- en: '[PRE48]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: (Poor Shemp, everyone forgets about Shemp.)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: （可怜的 Shemp，大家都忘了 Shemp。）
- en: Command Input
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 命令输入
- en: 'You just learned to use single quotes when also using usebackq and string input,
    so you can no longer use them to encase a command. But this general syntax allows
    you to use the keyword with a command as input:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学会了在使用 `usebackq` 和字符串输入时使用单引号，因此你不能再用它们来括起命令。但是，这种通用语法允许你将关键字与命令作为输入一起使用：
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In some fonts the two characters encasing the command input might look like
    single quotes, but they’re something new.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些字体中，括住命令输入的两个字符可能看起来像单引号，但它们是全新的字符。
- en: This brings us back to the cliffhanger concerning the meaning of the text usebackq
    or *use back quote*. It’s named for those crooked single quotes encasing the command,
    which are more properly called back quotes (or back ticks). The keyboard key for
    the back quote is just above TAB and to the left of the key for the number 1 on
    most keyboards. This key does double duty, as shifting it gets you the tilde.
    It’s relegated to the nether regions of the keyboard because it’s rarely if ever
    touched by most, but it’s an instrumental key for Batch coders.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们回到那个悬而未决的问题，关于文本 usebackq 或 *use back quote* 的含义。这个名称源于那些弯曲的单引号，它们把命令括起来，实际上这些单引号更准确地说是反引号（或称为反撇号）。反引号的键在大多数键盘上位于
    TAB 键的上方和数字 1 键的左侧。这个键有双重功能，按住 Shift 键可以输入波浪号。它被 relegated 到键盘的底层区域，因为大多数人几乎从不使用它，但它是
    Batch 编程者的一个重要键。
- en: 'The following for /F commands are functionally equivalent; the first one mimics
    a command from the prior section, and the second one uses the keyword and back
    quotes:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 for /F 命令是功能等效的；第一个模仿了前一节的一个命令，第二个使用了关键字和反引号：
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The first line supports instances where the encased command might contain a
    back quote, while you’d use the second line—the syntax with the usebackq keyword—when
    the command might contain a single quote.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行支持命令中可能包含反引号的情况，而你会使用第二行—带有 usebackq 关键字的语法—当命令可能包含单引号时。
- en: When to Use usebackq
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 何时使用 usebackq
- en: 'You can implement each type of input with or without usebackq, so when should
    you use the keyword? In a sentence: whenever possible, I use usebackq for file-set
    and command inputs, and I don’t for string input.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在有或没有 usebackq 的情况下实现每种类型的输入，那么应该什么时候使用这个关键字呢？简单来说：无论何时可能，我都会对文件集和命令输入使用
    usebackq，对于字符串输入则不使用。
- en: Encasing the input in double quotes allows for the most flexibility and should
    be done whenever possible. It supports embedded spaces in the input and many characters
    that might otherwise require escaping. Hence, when processing a file-set, I use
    double quotes and usebackq, and when processing a string, I use double quotes
    and omit the keyword.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 用双引号括起输入能够提供最大的灵活性，并且应该在可能的情况下使用。它支持输入中嵌入空格和许多可能需要转义的字符。因此，在处理文件集时，我使用双引号和 usebackq，而在处理字符串时，我使用双引号并省略该关键字。
- en: When the input is a command, double quotes don’t enter into the calculus. Some
    may skip the keyword to save a few keystrokes, but I use the usebackq keyword
    and back quotes around the input for two reasons. First, while both the single
    quote and back quote are unlikely characters in a command, the back quote is even
    more unlikely. More important, when you see the single quotes, you immediately
    ask whether the input is a string or a command; the back quotes remove all ambiguity;
    it’s a command.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入是一个命令时，双引号不会参与计算。有些人可能会跳过关键词来节省一些按键，但我使用 usebackq 关键字和反引号将输入括起来，原因有两个。首先，虽然单引号和反引号在命令中都不太常见，但反引号更不常见。更重要的是，当你看到单引号时，你会立刻问自己输入是字符串还是命令；而反引号消除了所有的歧义，它就是一个命令。
- en: If you implement my recommendations, the end result will be that anyone looking
    at your for /F commands will be able to infer a great deal from the input. If
    it’s encased in back quotes, it’s a command; if it’s encased in double quotes,
    focus shifts to usebackq. If it’s present, the input is a file-set; if not, it’s
    a string. There are three more forms available in the event of a blue moon, but
    you’ll see an input string containing a double quote or an input command containing
    a back quote less frequently than you’ll see two full moons in a calendar month.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你实施我的建议，最终结果是任何查看你 for /F 命令的人都能够从输入中推断出很多信息。如果它被反引号括起来，那就是一个命令；如果它被双引号括起来，焦点就转移到了
    usebackq 上。如果存在，那输入就是一个文件集；如果没有，那它就是一个字符串。还有三种形式在“蓝月亮”时可用，但你会比看到两次满月还要少见到包含双引号的输入字符串或包含反引号的输入命令。
- en: As one final note on the usebackq, if you don’t find this keyword cryptic enough,
    the q is optional. You can replace every instance of usebackq appearing in the
    code listings in this chapter with its synonym useback. I’m usually in favor of
    reducing keystrokes, but this puts an additional veil over something that’s already
    inscrutable to many.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 usebackq 的最后一个提示，如果你觉得这个关键字还不够难懂，q 是可选的。你可以用它的同义词 useback 替换本章代码示例中出现的每一个
    usebackq 实例。我通常支持减少按键次数，但这样做会在已经对许多人来说难以理解的东西上加上一层面纱。
- en: Real-World Applications
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实际应用
- en: The ability to read files and to treat strings and the outputs of commands as
    if they were files has many applications. Truly understanding the different types
    of inputs possible for a for /F command will allow you to come up with imaginative
    solutions to problems that may have seemed intractable not long ago.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Process Only Large Files in a Folder
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Chapter 17](chapter17.xhtml), I explored an application that passed a number
    of files into a bat file to be processed one by one. In this example, we’ll still
    process files individually, but instead of a list of arguments, let’s process
    all *.txt* files in a particular folder. To make it a little more interesting,
    let’s process only large files, defined as any file at least 100KB in size.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: You can feed the dir command into the for /F command as input with back quotes
    encasing the command if using the usebackq keyword. The bare format option, /B,
    produces a clean list of files without headers and is tailor-made for this purpose,
    but the file size is lost with this option, so let’s drop that idea, at least
    for now.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: However, not using the /B option presents other challenges. File dates and times
    will be present, along with header and trailer records. You’ll want to use the
    size of each file to evaluate whether it’s large enough to process, but the pesky
    commas in the displayed file size will be more than a nuisance.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 13](chapter13.xhtml), I mentioned that the /-C option of the dir
    command suppresses the commas, but to figure out how to parse what you want out
    of its output, you’ll want to see a sample. Unless you possess a memory far more
    detailed than mine, an essential step in building any complex for /F command with
    an embedded command is to execute that embedded command, the command that will
    be inside the back quotes, and inspect its output. Here’s the command, where workDir
    is the folder in question:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'It might generate something like the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: There’s a lot to unpack here, but with this data you can construct the rest
    of the for /F command. You’re interested in the four detail records, but there
    are five header records, including the empty records, so you’ll want to avoid
    them with the skip=5 clause.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to figure out the best way to find the tokens that correspond
    to the file size and name. The space character is one of the default delimiters,
    and it’ll work great here, but notice that if you had wanted the month, day, year,
    hour, or minutes out of the data, you would have used a delims clause defining
    a delimiter set of forward slashes, colons, and spaces. Given that the space is
    the delimiter, you must now put on your interpreter hat and look for the space-delimited
    tokens. The date is the first token, and the time comprises the next two tokens;
    because of the embedded space, the meridiem (AM/PM) becomes the third token. Hence,
    the fourth token is the file size with the remainder of the data being the filename.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: To represent size, you’ll use %%s as the for variable, meaning that %%t will
    be the filename and extension. (If you use %%e as the size, then %%f becomes the
    file.)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示大小，你将使用 `%%s` 作为 `for` 变量，这意味着 `%%t` 将是文件名及扩展名。（如果你使用 `%%e` 作为大小，那么 `%%f`
    就变成了文件。）
- en: It might be tempting to consider the filename to be the fifth token, but filenames
    can contain spaces, and any space in the name will delimit yet another token.
    Fortunately, the filename comes at the end of the data, meaning that the tokens=4*
    clause assigns two tokens. The fourth token is the file size, and thanks to the
    asterisk, the rest of the data, which is the filename, becomes the fifth token.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有诱惑认为文件名是第五个令牌，但文件名中可能包含空格，任何空格都会将其分隔成另一个令牌。幸运的是，文件名出现在数据的末尾，这意味着 `tokens=4*`
    子句会将其分配为两个令牌。第四个令牌是文件大小，由于有星号，其余数据即文件名则成为第五个令牌。
- en: 'You’re not done, but you can put together the main structure of the for /F
    command. Everything discussed is here, in particular, the dir command inside back
    quotes:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你还没有完成，但可以将 `for /F` 命令的主要结构组合起来。这里讨论的所有内容都在这里，尤其是反引号中的 `dir` 命令：
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Before calling the logic to process a big file, you’ll need to navigate two
    if commands. The first simply verifies that the file size, %%s, is greater than
    or equal to 100000. The for /F command allows you to skip header records, but
    trailer records are still in play, so you must get creative. Notice in the dir
    command output that the fourth token in both trailer records is the text bytes,
    which surely won’t be the case for the detail records you’re interested in. Hence,
    you’ll need a second if command to filter out those two unwanted records by inspecting
    the same %%s variable.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用处理大文件的逻辑之前，你需要处理两个 `if` 命令。第一个简单地验证文件大小 `%%s` 是否大于或等于 100000。`for /F` 命令允许你跳过头部记录，但尾部记录仍然会影响结果，因此你必须灵活处理。在
    `dir` 命令的输出中，注意到两个尾部记录的第四个令牌是字节数，这肯定不适用于你感兴趣的详细记录。因此，你需要一个第二个 `if` 命令，通过检查同一个
    `%%s` 变量来过滤掉这两条不需要的记录。
- en: 'Now you can put it all together:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以将它们组合起来了：
- en: '[PRE54]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If the workDir variable is populated with the working directory of the text
    files, this code is ready to process the big text files represented by %%t. Also,
    it might seem quite odd that %%s is used in both numeric and alpha compares. In
    [Chapter 4](chapter4.xhtml), I mentioned that numeric and alpha values are ordered;
    letters are considered to be greater than numbers, so the bytes geq 100000 conditional
    clause is always true. If it had always been false, you could have omitted the
    second if command.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `workDir` 变量已填充为文本文件的工作目录，那么此代码就可以处理由 `%%t` 表示的大型文本文件了。此外，可能会觉得很奇怪，`%%s`
    被用于数值和字母比较。在[第4章](chapter4.xhtml)中，我提到过，数值和字母值是有顺序的；字母被认为大于数字，因此字节数大于等于 100000
    的条件子句总是为真。如果它一直为假，那么你本可以省略第二个 `if` 命令。
- en: Multiple solutions always exist, and it’s great to see a different way to think
    through an issue. I’m going to take another pass at the /B option of the dir command.
    I know that it won’t provide the file size, but maybe there’s another way to get
    it. I showed how to use modifiers to get the size of a file using the optionless
    for command in [Chapter 17](chapter17.xhtml). Maybe two for commands will be better
    than one.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 总是存在多个解决方案，看到以不同方式思考问题是一件很棒的事情。我打算再次尝试 `dir` 命令的 `/B` 选项。我知道它不会提供文件大小，但也许有其他方法可以获取它。我在[第17章](chapter17.xhtml)中展示了如何使用修饰符来获取文件大小，使用不带选项的
    `for` 命令。也许两个 `for` 命令会比一个更好。
- en: 'I’ll start with this solution, which implements nested for commands:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从这个解决方案开始，它实现了嵌套的 `for` 命令：
- en: '[PRE55]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The outer for command has the /F option, along with the usebackq keyword, and
    it uses %%f as its variable. Its input is a dir command with the /B option encased
    in back quotes. The tokens=* clause ensures that the code passes each filename,
    regardless of embedded spaces, into the code block, where I immediately prepend
    it with the path, put it in double quotes, and use it as the input to the inner
    for command.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 外部 `for` 命令具有 `/F` 选项，并使用 `usebackq` 关键字，同时它将 `%%f` 用作变量。它的输入是一个带有 `/B` 选项的
    `dir` 命令，并用反引号包裹。`tokens=*` 子句确保无论文件名中是否有空格，代码都会将每个文件名传入代码块，在这里我会立即为其添加路径，用双引号括起来，并将其作为输入传递给内部
    `for` 命令。
- en: That inner command, which doesn’t sport the /F option, uses %%g as its variable,
    but anything other than %%f would have been good form. I’m deriving the file size
    with the use of a modifier, %%~Zg; if it’s large enough, the call command invokes
    the routine that processes large files.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个内部命令没有使用 /F 选项，它使用%%g作为变量，但除了%%f之外，任何其他变量名都可以是良好的格式。我通过使用修饰符%%~Zg来推导文件大小；如果文件足够大，call命令会调用处理大文件的例程。
- en: Nested for commands don’t behave much differently from their non-nested cousins,
    but an important point is the alpha character chosen for the for variable of each
    command. I could’ve used %%f for both commands, but I always use unique values,
    as it’s simply clearer and easier to read. In addition, the outer variable is
    still available inside the inner command, but only if it hasn’t been stepped on
    by the inner variable.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的for命令与非嵌套命令的行为差别不大，但一个重要的点是每个命令所选的for变量的字母字符。我本可以为两个命令都使用%%f，但我总是使用唯一的值，因为这样更清晰、更易读。此外，外部变量在内部命令中仍然可用，但前提是它没有被内部变量覆盖。
- en: To prevent a for variable conflict, they should not only be different, but I
    also recommend staggering them so that any implied variables don’t collide. For
    instance, if the outer command is extracting three tokens from the input data
    and using %%f as its for variable, then %%g and %%h should also be off limits
    for the inner command.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止for变量冲突，它们不仅要不同，而且我还建议错开它们，以确保任何隐含的变量不会发生冲突。例如，如果外部命令从输入数据中提取三个标记并使用%%f作为其for变量，那么%%g和%%h也应当避免在内部命令中使用。
- en: You’ve seen two solutions to the same problem. One used a more complex command
    to parse the data, and the other used nested commands. Which way is better is
    debatable. What isn’t debatable is that just as in other languages, multiple possible
    solutions exist for all problems. Never settle.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了两个解决同一问题的方法。一个使用了更复杂的命令来解析数据，另一个则使用了嵌套命令。哪种方式更好是有争议的，但无可争议的是，和其他语言一样，所有问题都有多种可能的解决方案。永远不要满足于一个解决方案。
- en: Global Text Replacement
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 全局文本替换
- en: Imagine you maintain an old system that runs a number of executables, many of
    which are housed on an old server. The team is decommissioning the server, *\\OldServer*,
    and replacing it with the aptly named *\\NewServer*. The plan is to move every
    file on the old box to the new box with the same directory structure.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你维护一个旧系统，运行着许多可执行文件，其中许多文件存放在一台旧服务器上。团队正在退役这台服务器*\\OldServer*，并用恰如其分地命名为*\\NewServer*的新服务器替换它。计划是将旧服务器上的每个文件迁移到新服务器，并保持相同的目录结构。
- en: Fortunately, your team has wisely implemented and adhered to a consistent naming
    convention for the variables that define each program; they all start with _pgm.
    You control the creation of some of these variables, but not all. You’ll never
    be able to track them all down, but to cut over to the new server successfully,
    you’ll need to tweak all of these variables on the fly—that is, you’ll need to
    change the text for the old server to the new text, and you can’t even get a list
    of all the variable names.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你的团队明智地实施并遵循了一致的命名规范，定义每个程序的变量都以_pgm开头。你控制其中一些变量的创建，但不是所有变量。你永远无法追踪到所有变量，但为了顺利切换到新服务器，你需要实时调整所有这些变量——也就是说，你需要将旧服务器的文本更改为新服务器的文本，而且你甚至无法获取所有变量名的列表。
- en: 'The first problem to solve is retrieving the list of variable names in a given
    execution. In [Chapter 2](chapter2.xhtml), you learned that the following command
    generates a list of all currently active variables that start with the text _pgm:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个需要解决的问题是检索给定执行中的变量名列表。在[第2章](chapter2.xhtml)中，你学习了以下命令会生成所有当前活动的变量列表，这些变量名以_pgm开头：
- en: '[PRE56]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If just four such variables were set, the following might be the result of
    the command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仅设置了四个这样的变量，以下可能是命令的结果：
- en: '[PRE57]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The first and last of these need tweaking, the second has already been updated
    with the new text, and third has a completely different directory structure. You’ll
    need to update two of these without altering the other two. The solution entails
    the previous set command as the input to a for /F command. The code block will
    accept the variable name and value and reset the variable to its value with the
    updated text.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这些中的第一项和最后一项需要调整，第二项已经使用了新文本更新，第三项有一个完全不同的目录结构。你需要更新其中两个，而不改变另外两个。解决方案包括将前一个set命令作为for
    /F命令的输入。代码块将接受变量名和对应的值，并用更新后的文本重置该变量。
- en: 'The following for /F command is one solution:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下for /F命令是其中一种解决方案：
- en: '[PRE58]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You’ve placed the command set _pgm between back quotes and used the usebackq
    keyword in the for /F command. When using the dir command as input, I stressed
    the importance of understanding its output, and the same holds true for the set
    command. Looking at the four sample lines of output, the commonality between them
    is that a variable name is followed by a value, separated by an equal sign. Thus,
    you’re delimiting on the equal sign with the delims== clause and extracting both
    tokens with the tokens=1,2 clause. The for variable, %%p, is the variable name,
    implying that %%q is its value.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你将命令set _pgm放在反引号之间，并在for /F命令中使用了usebackq关键字。使用dir命令作为输入时，我强调了理解其输出的重要性，同样的道理也适用于set命令。查看四行示例输出，它们的共同点是变量名后面跟着一个值，两者之间用等号隔开。因此，你通过delims==子句按等号进行分隔，并使用tokens=1,2子句提取两个令牌。for变量%%p是变量名，意味着%%q是它的值。
- en: This code resets the variable in the code block with just two commands. You
    assign the original value of the input variable, %%q, to tempPgm, a temporary
    variable. The second command resets the variable name, %%p, to that value with
    *\\OldServer\* replaced with *\\NewServer\*. Notice that because tempPgm is being
    set and then used inside of a code block, you must use exclamation marks to resolve
    the variable to its current value.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码仅用两个命令就能重置代码块中的变量。你将输入变量%%q的原始值赋给临时变量tempPgm。第二个命令将变量名%%p重置为该值，并将*\\OldServer*替换为*\\NewServer*。注意，由于tempPgm在代码块中被设置并使用，因此必须使用感叹号来解析该变量的当前值。
- en: This logic updates all variables with this specific prefix while ignoring those
    without the prefix. There are many other applications based on this principle.
    You could reset all similarly named variables to null by replacing the code in
    the code block with one command, set %%p=, and using the default tokens clause.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个逻辑会更新所有具有特定前缀的变量，同时忽略没有该前缀的变量。基于这一原则还有很多其他应用。你可以通过用一个命令set %%p=替换代码块中的代码，并使用默认的tokens子句，来将所有类似名称的变量重置为null。
- en: Notes on the Documentation
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档说明
- en: 'I’ve taken some liberties with the general syntax of the different forms of
    the for /F command, so I’ll compare what you’ve seen here to what’s in the help
    documentation and explain my reasons. First, this is exactly what you’ll find
    by running for /?:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我对不同形式的for /F命令的语法做了一些调整，所以我将把你在这里看到的与帮助文档中的内容进行比较，并解释我的理由。首先，这是你通过运行for /?命令可以看到的内容：
- en: '[PRE59]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'I instead list the three forms that I use almost exclusively, followed by the
    ones I use infrequently:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我列出了我几乎专门使用的三种形式，然后是我不常使用的几种：
- en: '[PRE60]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: First off, I have more of an affinity for lowercase characters than most coders.
    Also, I’ve replaced the ["options"] clause with ["suboptions"]. This for command
    already has one option, /F, and I see no reason to introduce another type of option,
    so I’ve settled on the term *suboptions*, but both of these tweaks are cosmetic.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我比大多数程序员更喜欢小写字母。而且，我将["options"]子句替换为["suboptions"]。这个for命令已经有一个选项/F，我认为没有必要再引入另一种类型的选项，所以我选择了*suboptions*这个术语，但这两个调整都是表面上的。
- en: I’ve dropped [command-parameters] from the end of each, which just states that
    the command could have parameters, but that’s obvious and unworthy of the extra
    ink. To truly do it correctly, I could’ve shown additional optional commands as
    well as optional parentheses defining a possible code block. To be readable, it
    has to be a bit vague, so I’ve decided to also make it succinct.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我去掉了每行末尾的[command-parameters]，因为这只是说明命令可能有参数，但这显而易见，不值得浪费额外的篇幅。为了真正正确地展示，我本可以显示额外的可选命令以及定义可能代码块的可选括号。为了让文档更具可读性，它必须保持一定的模糊性，因此我决定让它简洁明了。
- en: Another difference is that I’ve used two percent signs for the for variable,
    %%variable, as opposed to one. The help shows how you would execute the command
    from the command prompt, where the only difference is that it calls for a single
    percent sign. This is a book about bat files, not the command prompt, and the
    command is usually too complex to be entered at the prompt anyway.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是，我对for变量%%variable使用了两个百分号，而不是一个。帮助文档显示了如何从命令提示符执行命令，唯一的区别是它调用的是单个百分号。这是一本关于bat文件的书，而不是命令提示符，而且命令通常过于复杂，不适合在提示符下输入。
- en: I explicitly show the usebackq keyword in the forms that use it, while the help
    documentation places them after an odd heading. To accommodate this change, I’ve
    also placed the other suboptions inside the square brackets because they are still
    optional.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我明确地在使用usebackq关键字的形式中展示它，而帮助文档将其放在一个奇怪的标题后面。为了适应这一变化，我还将其他子选项放入方括号中，因为它们仍然是可选的。
- en: The final difference is in the first form, and it’s the most critical one. When
    researching this book, I was absolutely flabbergasted to notice that the two forms
    using the file-set as input are identical in the help. Adding the usebackq keyword
    means that double quotes can now encase the input. Technically, they don’t have
    to be there, but isn’t that the whole point of using usebackq? I’m hard-pressed
    to come up with an instance where I wouldn’t want the double quotes while using
    the keyword, so I’m including them in my documentation, but understand that they
    are optional.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的区别在于第一个形式，这也是最关键的一点。在研究这本书时，我感到非常震惊，发现两个使用文件集作为输入的形式在帮助文档中是相同的。添加usebackq关键字意味着现在双引号可以包含输入内容。从技术上讲，它们并不一定需要存在，但这不正是使用usebackq的意义所在吗？我很难想出在使用该关键字时我不想使用双引号的情况，因此我在文档中包含了它们，但请理解它们是可选的。
- en: Use the forms that make sense to you. Better yet, start with one set or the
    other (I hope mine) and build on it in your own personal documentation about the
    for command.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对你有意义的形式。更好的是，选择其中一个形式开始（我希望是我的形式），然后在你自己的for命令文档中进行构建。
- en: Deconstructing Any for Command
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拆解任何for命令
- en: 'The for command, especially when followed by the /F option, can be overwhelming.
    You can pack quite a bit of logic into just a few lines of code. When you come
    across one of these constructs, it can be difficult to know exactly where to start
    your analysis. I’ve deconstructed many of these commands (a good number being
    my own) over the years, and whenever I see a command starting with for, I use
    these questions and steps to figure out what the code is doing:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: for命令，尤其是跟随/F选项时，可能会让人感到压倒性。你可以在仅几行代码中加入相当多的逻辑。当你遇到这样的构造时，可能很难准确知道从哪里开始分析。我多年来已经拆解了许多这样的命令（其中不少是我自己写的），每当我看到一个以for开头的命令时，我都会使用这些问题和步骤来弄清楚代码在做什么：
- en: 1.  What’s the option? Is it optionless, /D, /R, /L, or /F?
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  什么是选项？是没有选项、/D、/R、/L还是/F？
- en: 2.  Based on the option, what type of input is it using? If it’s optionless,
    is the input a file, files, or a list of values? If it’s /D, expect a directory
    as input. If it’s /R, expect a recursive process on an input of one or more files.
    If it’s /L, look at the three numbers defining the iterative loop. In all four
    of these cases, next step through the logic in the code block given the input.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  根据选项，它使用的是什么类型的输入？如果没有选项，那么输入是文件、文件集还是值的列表？如果是/D选项，期望输入为一个目录。如果是/R选项，期望对一个或多个文件进行递归处理。如果是/L选项，查看定义迭代循环的三个数字。在这四种情况下，按照输入的逻辑步骤通过代码块。
- en: But if the option is /F, you’ve only just begun the deconstruction. What type
    of input is the command using? If there are no quotes, the input is a file-set;
    if back quotes, a command. If double quotes, usebackq translates to a file-set;
    otherwise, a string. If single quotes, usebackq translates to a string; otherwise,
    a command.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果选项是/F，那么你才刚刚开始拆解。命令使用的是什么类型的输入？如果没有引号，输入是文件集；如果是反引号，则是一个命令。如果是双引号，usebackq将其转换为文件集；否则是一个字符串。如果是单引号，usebackq将其转换为字符串；否则是一个命令。
- en: 3.  Determine what the input is contributing. Does the file-set have a wildcard?
    Roughly how many files are being processed? What type of data is in the file or
    files? Is the string hardcoded or a variable? What does the command do, and what’s
    its output? Roughly how many lines of output are created? How consistent is the
    data—that is, will there be header or trailer data?
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  确定输入贡献了什么。文件集是否包含通配符？大概处理了多少个文件？文件或文件中的数据是什么类型？该字符串是硬编码的还是变量？命令做了什么，输出是什么？大致创建了多少行输出？数据的稳定性如何——也就是说，会有头部或尾部数据吗？
- en: 4.  Examine the suboptions and determine how the input is being manipulated.
    Based on the tokens and delims clauses (or their defaults), how many tokens are
    created, and how will they be populated from the input? Are any records dropped
    with skip or eol clauses?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  检查子选项，并确定输入是如何被处理的。根据tokens和delims子句（或它们的默认值），会创建多少个标记，它们将如何从输入中填充？是否有记录通过skip或eol子句被丢弃？
- en: 5.  Identify the for variable, perhaps %%i, and determine the input data associated
    with it and its subsequent variables, perhaps %%j and %%k.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  识别 for 变量，可能是 %%i，并确定与之相关的输入数据及其后续变量，可能是 %%j 和 %%k。
- en: 6.  Examine the code block. Determine how the for variable, and any implied
    variables, are referenced. Is something being copied, renamed, deleted, or processed
    in any way?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  检查代码块。确定 for 变量以及任何隐含变量的引用方式。是否有文件被复制、重命名、删除或以其他方式处理？
- en: 'Maybe these questions and steps seem overwhelming, but to demonstrate how easy
    they are to use, let’s deconstruct some code. Someone you just met online has
    given you this command telling you that it will back up some files. Just run it:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 也许这些问题和步骤看起来令人难以应对，但为了展示它们的简单性，让我们拆解一些代码。某个刚认识的在线用户给了你这个命令，告诉你它会备份一些文件。只需要运行它：
- en: '[PRE61]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'But before executing this, you should deconstruct it. Using the prior six steps:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 但在执行之前，你应该先拆解它。使用之前的六个步骤：
- en: 1.  The option is /F.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  选项是/F。
- en: 2.  Back quotes encase the input, so it’s a command.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  反引号包裹输入，所以它是一个命令。
- en: '3.  The source argument of the xcopy is an asterisk, meaning that the command
    copies all files from the current directory to an oddly named folder using two
    pseudo-environment variables that I’ve yet to discuss (but will in [Chapter 21](chapter21.xhtml)).
    If this command copies five files successfully, the output will be a list of the
    five source files, followed by the trailer record stating: 5 File(s) copied.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  xcopy 的源参数是星号，这意味着该命令将当前目录中的所有文件复制到一个奇怪命名的文件夹中，使用了两个伪环境变量，我还没有讨论（但会在[第21章](chapter21.xhtml)中讨论）。如果此命令成功复制五个文件，输出将是五个源文件的列表，后面跟着一条记录，写着：5
    个文件已复制。
- en: 4.  Based on the tokens clause and the lack of a delims clause, this code extracts
    the first and third tokens from the space-delimited input. For most of the output,
    the first token is the full path and name of the source file, assuming that there
    are no embedded spaces, and the third token is null. For the last line of input,
    or the trailer record, the first token resolves to the number of files copied,
    while the third token is the word copied.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  基于 tokens 子句和缺少 delims 子句，该代码提取了从空格分隔输入中提取的第一个和第三个标记。对于大部分输出，第一个标记是源文件的完整路径和名称，假设文件名中没有嵌入空格，第三个标记为空。对于输入的最后一行，或者说记录的结尾，第一个标记解析为已复制的文件数量，而第三个标记是“copied”这个词。
- en: 5.  The %%x is the path and filename up until the last line of output when it
    becomes the number of files copied. The %%y is nothing at all (again assuming
    no embedded spaces) before resolving to copied while processing the last line
    of output. So far, so good.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  %%x 是路径和文件名，直到输出的最后一行，当它变成已复制的文件数量时。%%y 完全为空（假设没有嵌入的空格），在处理输出的最后一行时解析为“copied”。到目前为止，一切正常。
- en: 6.  Shifting to the code block, the if command filters out the last record where
    %%y resolves to the specific text, meaning that for every file that’s copied the
    echo command replaces its entire contents with what looks to be a vague threat.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  切换到代码块，if 命令过滤掉最后一条记录，其中 %%y 解析为特定文本，这意味着每个被复制的文件，echo 命令都会将其整个内容替换成看似模糊的威胁。
- en: This looks to be more than a little suspicious. The code is hiding away all
    files from the current directory, including the bat file itself assuming it’s
    in the current directory, in a randomly named folder. Then it wipes out and replaces
    the contents of each source file with some text. It’s of little consolation that
    files with embedded spaces in their name may be spared.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有点可疑。代码将当前目录中的所有文件隐藏起来，包括假设它在当前目录中的 bat 文件本身，放进一个随机命名的文件夹中。然后它擦除并替换每个源文件的内容，替换成一些文本。即使带有嵌入空格的文件名可能会被保留下来也无济于事。
- en: Because you now know how to deconstruct a for command, you weren’t fooled by
    this bat file. Without executing the code, you’ve deduced that it’s malicious
    code—a bat virus.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你现在知道如何拆解一个 for 命令，所以你没有被这个 bat 文件欺骗。你没有执行代码，但已经推断出它是恶意代码——一个 bat 病毒。
- en: Summary
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, you learned about the file reading option of the for command,
    and you learned that it does much more than read files. The input can be a file,
    a string, or the output of a command, each with distinct syntaxes. I detailed
    the syntax for manipulating the input data, creating tokens, and using those tokens
    in the code block of the command. I also demonstrated much of this functionality
    with some real-world problems, finishing up with a discussion about how to deconstruct
    this important command.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你了解了for命令的文件读取选项，并且学到了它不仅仅是读取文件。输入可以是文件、字符串，或者是命令的输出，每种都有不同的语法。我详细介绍了如何操作输入数据、创建标记，并在命令的代码块中使用这些标记的语法。我还通过一些现实世界的问题展示了这些功能，最后讨论了如何拆解这个重要的命令。
- en: In the next chapter, I’ll close out [Part II](part2.xhtml) with an examination
    of a few advanced techniques that will either solve a problem associated with
    using the for command or solve a problem with the use of the for command.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将通过考察一些高级技巧来结束[第二部分](part2.xhtml)，这些技巧要么解决与使用for命令相关的问题，要么解决for命令使用中的问题。
