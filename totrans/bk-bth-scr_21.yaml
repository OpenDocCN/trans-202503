- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 19 READING FILES AND OTHER INPUTS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By far the most involved syntax and powerful functionality of the already powerful
    for command is unleashed with the /F option, which allows for *file reading*.
    The optionless for command can do quite a bit with a file such as getting its
    name, path, drive, size, and attributes, pretty much everything concerning a file
    except its actual contents. Enter the /F option.
  prefs: []
  type: TYPE_NORMAL
- en: After introducing its syntax, I’ll demonstrate how to read a file, record by
    record. You’ll learn how to manipulate the input data, place the entire contents
    of a record into a variable, or break it into what Batch calls tokens. By tokenizing
    the data, you’ll be able to extract just the portions of data you desire.
  prefs: []
  type: TYPE_NORMAL
- en: Although the for /F command ostensibly reads files, the input can take on other
    forms. This command can treat a string as a single record file, and you can even
    use the output from another Batch command as its input. All of this will allow
    you to manipulate and process different forms of information in many different
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: The for Command with the /F Option
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The /F option transforms the for command into a multifaceted tool for reading
    files. This command with this particular option has multiple forms, but I’ll start
    by considering just one. Here’s the general syntax of the form or variant of the
    for /F command that reads a file or a set of files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In comparison to the optionless for command, this syntax is quite different.
    Most obviously, the /F option is in place. I’ve also changed the generic input
    placeholder inside the parentheses to the more specific term of file-set, but
    that’s little more than nomenclature. In comparison to the optionless version
    of the command, this variant accepts only a file, a file mask, or multiple files
    or file masks.
  prefs: []
  type: TYPE_NORMAL
- en: The most significant difference is the addition of the ["suboptions"] clause.
    The square brackets indicate that these suboptions are themselves optional, but
    if you include them, encase them in double quotes. Each of the possible suboptions
    is denoted with its own specific keyword. I’ll discuss one of them, usebackq,
    later in this chapter, but the others have a direct impact on how you will read
    and manipulate the data.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the Contents of a File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The keywords tokens, delims, skip, and eol might not roll easily off the tongue,
    but they’re instrumental elements of the suboptions clause, which controls the
    reading of files. The best way to see what they do is to explore the behavior
    of the for /F command without options and then add in the clauses associated with
    these four keywords one by one to demonstrate their usefulness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s return to the introduction of the for command in [Chapter 17](chapter17.xhtml)
    where I briefly worked with a file named *FourBrits.txt* but said nothing about
    its contents. For this demonstration, assume that it’s a small file of four records.
    Each record has five elements, the first being a language and the remainder being
    four particular male names as they are written in that language. The spaces or
    tabs delimit the elements, and here are the complete contents of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider this for command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is exactly what you’d now expect: a single line of data displaying
    the path and filename of the input file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate the new option, I’ll add /F to the logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And now the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Such a small change results in a vastly different outcome. Instead of a single
    write to the console in the form of the filename, the code now outputs the first
    word of each record inside the file itself. Due to the /F option, the command
    is opening and reading the contents of the file. There’s still much to work out,
    but the command is actually reading each of the four records in the file, setting
    %%a to the first word in the record. If the file had contained 64 populated records,
    the previous logic would have written 64 words to the console on the same number
    of lines.
  prefs: []
  type: TYPE_NORMAL
- en: This output raises many more questions than it answers. Why isn’t this writing
    the entire record? Can we parse out just parts of the record? Must we read every
    record? This is where the keywords in the suboptions clause from the general syntax
    come into play.
  prefs: []
  type: TYPE_NORMAL
- en: Tokenizing the Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *token* in Batch is an element of a record, and by default each token is
    delimited by spaces or tabs. Inspecting the first record in the file, it contains
    exactly five tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: By default, Batch sets the number of tokens to 1. This explains why in the previous
    example, the interpreter resolved %%a to the first word (or token) in each record
    and dropped the rest of the record.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change this default, you can use the tokens clause; it’s the tokens keyword
    followed by an equal sign and the setting, which in this case is 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The tokens clause tells the interpreter which token or tokens to pass into
    the loop as the for variable. Executing this code produces the following output
    written to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Due to the tokens clause, the interpreter now sends the second word or token
    into the loop, writing John and its translations to the console. Setting it to
    5 would have retrieved Richard’s name instead. With this clause you can extract
    a single token with relative ease.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting Multiple Tokens
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It’s nice to be able to pull out individual tokens, but it’s more useful to
    be able to pull out multiple and select tokens. To extract all five tokens, assign
    the text 1-5 to the tokens keyword. But this raises an interesting question. How
    will those five tokens be resolved with only the single variable, %%a, defined?
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional variables are elegantly implied in simple alphabetical order. If
    %%a is the variable defined in the for /F command, it resolves to the first token
    defined in the tokens clause, then %%b resolves to the second, %%c to the third,
    %%d to the fourth, and, finally, %%e to the fifth. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This code formats the record so that the language is followed by a colon and
    two spaces. Then in the output, the names are separated by commas and spaces with
    a conjunction before the last name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pick and choose which tokens to extract instead of a range. A
    comma in the tokens clause separates the desired tokens. This code sends only
    the second and fourth tokens into the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This result is written to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The second token from the data record is now the first token the tokens clause
    defines, so Batch assigns it to %%a, not %%b. Likewise, %%b now resolves to the
    fourth token in the record, which is the second token selected. More succinctly,
    the variable letter mimics the token’s position defined by the tokens clause—not
    its position in the record.
  prefs: []
  type: TYPE_NORMAL
- en: 'To this point, I’ve used %%a as the for variable. Regardless of the letter
    you choose for the variable, the interpreter assigns subsequent tokens to corresponding
    letters in the alphabet. The previous code is functionally equivalent to the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The only difference is that I’ve changed %%a to %%x, meaning that %%y now resolves
    to the second token instead of %%b.
  prefs: []
  type: TYPE_NORMAL
- en: The catch is that choosing %%x as the for variable limits you to just three
    possible tokens, because there’s nothing to assign after %%z (despite the efforts
    of Dr. Seuss in *On Beyond Zebra!*). You won’t see this nearly as often, but numbers
    also work. For instance, if you extract three tokens and define the for variable
    as %%7, the interpreter will use %%8 and %%9 for the implied tokens.
  prefs: []
  type: TYPE_NORMAL
- en: The keyword also accepts a combination of numbers, commas, and dashes. For instance,
    the tokens=1,3-5 clause processes all of the tokens except John, the second token.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting the Remainder of a Record
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There’s another twist concerning the tokens keyword. An asterisk represents
    the remainder of the input record as is, including embedded whitespaces. Consider
    this code using 2* in the tokens clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This command assigns the second token to %%a because of the 2 in the clause;
    then the interpreter assigns the remainder of the record, the third, fourth, and
    fifth tokens, including any embedded spaces and tabs, to %%b because of the asterisk
    (*). The language, the first token in each record, isn’t to be found anywhere
    in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To bring this discussion full circle, when we simply added the /F option to
    the for command at the beginning of the chapter, the default tokens clause passed
    the first token only into the code block. On many occasions you’ll want to extract
    the entire record exactly as it appears in the input file as a single entity.
    Since the asterisk represents the rest of the input record, assigning it alone
    to tokens selects the entire record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Also notice that I changed the variable to %%r. Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The prior use of %%a would have worked fine, but I’ve changed it here for two
    reasons: first, r stands for *record*, and second, as a simple reminder that any
    alphabetic character will work.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*As mentioned in [Chapter 17](chapter17.xhtml), the for variable is actually
    case-sensitive, and some nonalphanumeric characters are permitted. This means
    %%a and %%b resolve only to the first two tokens for the variable defined as %%a;
    %%A and %%B won’t work, unless you change the for variable to %%A. I probably
    don’t need to mention this, but those oddball characters (think %%#) don’t lend
    themselves at all to extracting multiple tokens.*'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Set of Data Delimiters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Being able to break up an input record into tokens defined by delimiters such
    as spaces and tabs is powerful indeed, but in many instances, you don’t have control
    over the data in the file that you’re reading, and a different delimiter, or even
    a set of delimiters, would be far more applicable. The delims keyword defines
    one to many *delimiters* used to tokenize the data.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing Comma-Delimited Data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A comma-delimited format is a popular and easy way of storing data. For instance,
    a *.csv* file contains any number of comma-delimited records, and you can open
    it and view the data with Excel. Each token is delimited by a comma, and each
    token can contain spaces. Before demonstrating how Batch reads in CSV data, I’ll
    need some setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *FourBrits.txt* file might contain a name with embedded spaces such as
    Richard aka Ringo. In the space-delimited examples discussed so far, this text
    constitutes three distinct tokens. I’ll now reformat the data and present it in
    a comma-delimited file called *FourBrits.csv*. The contents of this file will
    be the same as its like-named *.txt* file except for the delimiters and Richard’s
    alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The next task is to modify the for /F command so that it treats the commas
    as delimiters in lieu of the spaces, and I’ll accomplish this with the delims
    keyword. When the keyword isn’t present, the interpreter defaults to the set of
    delimiters containing just the space and tab characters. In the following example,
    delims=, defines the set of delimiters as a single character, the comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When the interpreter now comes to the fifth and final token—a name followed
    by aka Ringo—it writes the text to the console complete with its embedded spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Ringo is nontranslatable.
  prefs: []
  type: TYPE_NORMAL
- en: Pipe-delimited data files are also popular; the delims=| clause parses the input
    data on the pipe so that embedded spaces and commas won’t create additional tokens.
    The equal sign can even be a delimiter with the delims== clause. (You’ll see an
    example of that before long.)
  prefs: []
  type: TYPE_NORMAL
- en: Defining Multiple Delimiters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can even define multiple delimiters with a single delims clause. The following
    code defines the set of delimiters to be the comma and the space. It’s subtle,
    but in comparison to the previous example, the only change is that I’ve added
    a space in between delims=, and the trailing double quote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The interpreter will now see a new token whenever it encounters a space or a
    comma. The fifth token will be only the name Richard, in some language, with aka
    and Ringo relegated to the unassigned sixth and seventh tokens, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate an even larger set of delimiters, I’ll use a one-record file
    named *Alphabets.txt*, containing the uppercase and lowercase Latin alphabets,
    with one space separating them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Omitting the delims clause entirely invokes the default delimiter set and results
    in just two tokens, the uppercase and the lowercase character sets, and nothing
    more. Instead, in the following code, I’m setting the delims keyword to the Delims
    text and a trailing space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If each of the seven delimiters occurs just once in the data, it seems logical
    that this logic creates eight tokens. That’s not necessarily true, but I’ve defined
    that many with the tokens=1-8 clause and added the same number of echo commands.
    But let’s keep an eye on the number of tokens generated. Here’s the resulting
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There is much to point out here, including the fact that the delimiter set
    is case-sensitive. The uppercase D is one delimiter, but not d. The lowercase
    letters e, l, i, m, and s, along with a space, round out the set of delimiters.
    It’s a little easier to see the origin of these seven tokens when looking at the
    original data with the delimiters (other than the space) bolded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this data has two of the delimiters (l and m) listed sequentially,
    and because nothing is between them, you might expect the interpreter to assign
    null or nothing to the sixth token and bump the text after it, nopqr, to the seventh
    token. Batch, however, treats the consecutive delimiters (lm) as a single delimiter
    so that the sixth token is the text nopqr. Thus, tuvwxyz is the seventh token,
    and since nothing comes after it, the eighth token resolves to nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful to use only tokens that you’ve defined. If the clause had been tokens=1-7,
    the final echo command would have resulted in Token 8 = %h, because %%h wouldn’t
    have been the eighth token; it would have been a percent sign escaping another
    percent sign, followed by a hardcoded character.
  prefs: []
  type: TYPE_NORMAL
- en: When parsing comma-delimited (or pipe-delimited) data, many compiled languages
    treat consecutive delimiters as two delimiters, honoring the null in between them,
    which makes perfect sense. Batch, however, typically delimits on spaces, and one
    look at the original *FourBrits.txt* data with its varying number of spaces between
    each word makes it clear that it also makes perfectly good sense to treat multiple
    spaces as a single delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this does lead to some frustration when instead of spaces, your
    data is delimited by commas, but in [Chapter 20](chapter20.xhtml), I’ll show you
    how to make the for loop honor the nulls between consecutive delimiters. However,
    if I have control over the input data that’s delimited on just a comma, I’ll always
    write a null element to the file as a space in between two commas.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve listed the space last in the set of delimiters because it has to come last.
    I hate to disparage the interpreter yet again, but it gets confused if it finds
    the space anywhere else. For that reason, when including a space in the delimiter
    set, the delims clause must come at the end of the suboptions, just prior to the
    trailing double quote.
  prefs: []
  type: TYPE_NORMAL
- en: Skipping Header Records
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you’ve just seen, the tokens and delims keywords have a great deal of nuance.
    The next couple are far more straightforward, especially the skip keyword, which
    lets you skip any number of header records as you read a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s return to the original *FourBrits.txt* file and add a header record before
    the unchanged content in the next four records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s run the same for /F loop from the tokens keyword discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It processes the header line as any other, producing the following garbage
    output, followed by the four lines of good output (only one of which I’m showing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Fortunately, the skip keyword defines the number of records to be skipped at
    the beginning of the file. This will skip the first record and process the data
    records perfectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If there had been three header records, the skip=3 clause would have made the
    for command start at the fourth record.
  prefs: []
  type: TYPE_NORMAL
- en: Suppressing Comment Records
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While the skip keyword skips records only at the beginning of a file, the eol
    keyword, which stands for *end of line* comment character, bypasses all records
    in the file that start with a defined character. If I were being charitable, I’d
    say that when the interpreter sees the defined *character* in the first byte of
    a record, it considers the character to be the *end of line* and treats what remains
    as a *comment*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, let’s edit the input file again. This time I’m adding a second
    comment record, and more important, each comment record now starts with a period:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the eol=. clause to the same for command instructs the interpreter to
    skip the comment lines, regardless of where they appear in the data, and process
    only the remaining records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this straightforward keyword has its very own batveat. Given
    that the delims clause accepts a list of delimiters, you’re probably expecting
    the eol clause to accept one to many characters. But no, it accepts only a single
    character.
  prefs: []
  type: TYPE_NORMAL
- en: The phrase tokens, delims, skip, and eol doesn’t quite roll off the tongue quite
    like John, Paul, George, and Ringo, but these fabulous four keywords allow for
    a great deal of flexibility, and there will be more examples of clauses associated
    with these keywords in this chapter and others.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You now know how to read a file with the for /F command, but you might not yet
    know how to read a *file*—there’s a distinction. A traditional file is a collection
    of bytes organized into records stored in a referenceable location on a drive
    defined by a directory and filename. A *file* is some sort of input readable by
    the for /F command; it can take different forms and doesn’t have to be something
    that an editor can open.
  prefs: []
  type: TYPE_NORMAL
- en: Other than a traditional file, this command can accept a string as input and
    also the output of another Batch command. As you’ll soon see, subtle difference
    in the syntax dictates the type of input.
  prefs: []
  type: TYPE_NORMAL
- en: File Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The file-set input is a traditional file or set of files. I’ve already shown
    several examples of that form throughout this chapter. Each example contained
    one file inside the parentheses, and we now know those inputs were files because
    of the lack of any encasing quotes, single or double. What you’ve yet to see is
    a set of files. The following command reads the contents of two files in the order
    that they are listed in the file-set, delimited by a comma or a space, or both
    for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Assuming that the first file, *FourBrits.txt*, has four records, the for /F
    command processes each in order, writing four lines to the console. The interpreter
    then closes that file and opens *MoreBrits.txt*. Each record in this file triggers
    one execution of the logic inside the code block and writes one more line to the
    console. I also removed the file paths, so the interpreter will look for these
    files in the current directory and the directories defined in the path variable.
  prefs: []
  type: TYPE_NORMAL
- en: String Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is the general syntax for the for /F command using a string as input.
    Take note of the input inside the parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This form replaces the input text with "string". The double quotes tell the
    interpreter that they are encasing some sort of text, while a complete lack of
    quotes tells the interpreter to consider the input to be a file or a set of files.
    Everything else works exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following for /F command is similar to other examples used earlier in this
    chapter, other than the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The only difference is that I’ve taken the last line of text from *FourBrits.txt*,
    removed some extra spaces for readability, and entered it as the string encased
    in double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The echo command inside the code block doesn’t know the source of the five
    tokens, whether it’s from a hardcoded string or a record read from a file. Here’s
    the familiar result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the text inside the parentheses is hardcoded, but you can use
    a variable containing text, as long as it’s encased in double quotes. You can
    use any string as input, and the interpreter treats it like a single record file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature allows for sophisticated string parsing. I actually used this
    feature in [Chapter 5](chapter5.xhtml) with absolutely no explanation of how it
    worked, promising an explanation later. A for /F command converted a boolean to
    a boolean string, where the bGod boolean contained one of two values, true==true
    or false==x. At the time I mentioned, while attributing it to little more than
    a magic trick, that the command strips off the two equal signs and all that follows,
    giving bStrGod the value of true or false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: With what you’ve learned in this chapter, you can now figure out how this works.
  prefs: []
  type: TYPE_NORMAL
- en: The for /F command treats the resolved boolean encased in double quotes inside
    the parentheses as string or text input. The delims clause defines the equal sign
    as the only delimiter, and since I haven’t defined the tokens keyword, the default
    clause of tokens=1 is implied. The result is that the word before the equal signs
    is the first token, and the interpreter resolves it as %%b (for *boolean*, of
    course), while discarding the second token coming after the equal signs. The set
    command then assigns that first token to the boolean string on its first and only
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: So, it’s not a magic trick at all, instead just a concise means of pulling a
    single delimited value out of a larger string with a single line of code. Behold
    the power of the for /F command and its multiple inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Command Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What’s inside the parentheses dictates the input of any for /F command. You
    know that no quotes indicate a file and that double quotes indicate a string.
    Single quotes indicate that another Batch command is the input, and here’s its
    general syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Any Batch command entered between the single quotes executes first, with its
    resulting stdout being the input to the for /F command. The interpreter then processes
    what it considers to be the input, line by line if there’s more than one, as if
    it were a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the usefulness of a command as input, consider the dir command
    introduced in [Chapter 13](chapter13.xhtml). The following command lists all of
    the text files in the given directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The /B option produces a list of filenames and extensions only—no file dates
    and sizes, and no header and trailer lines. But the command simply writes this
    information to stdout for your perusal and little more. Many times, you’ll want
    to take this list of files and execute some logic against each one. For example,
    let’s write some code to change the extension on all *.txt* files in a directory
    to *.bak* to signify that they’re backup files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The single quotes tell the for /F command that the input is a command. The
    dir command generates a list of filenames, each with an extension and no path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The tokens=* clause ensures that %%f takes on the entire string as its value
    as it enumerates through the list of files. The default clause would have dropped
    everything after the first embedded space in the name. The ren command renames
    the file, using the modifier for the filename (N) and tacking on the hardcoded
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that you can appreciate how extremely impressive this is. Three commands
    are bound up together to perform quite a bit in just a couple lines of code. For
    those who use this often, it can become commonplace, and for others it might just
    be overwhelming, but in many languages something like this isn’t possible without
    an intermediate file. With this technique, the dir command isn’t just something
    that can dump information to the console or into a file (although that can also
    be useful). The unadulterated bare format of the output was clearly designed for
    this purpose. You can perform many processes, simple or complex, on any number
    of files. I’ll expand on this when I delve into some real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative Syntax for Input Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For some inputs the syntax just discussed simply doesn’t work. Sometimes a filename
    contains embedded spaces, but encasing it in double quotes turns it into string
    input. If a string contains a double quote, you can’t encase it in a pair of those
    characters. Likewise, commands sometimes contain single quotes. These cases pose
    a problem requiring a different syntax, and the usebackq keyword, the last of
    the suboptions available with the for /F command, is the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Before going any further, some Batch abbreviations are obvious; I probably didn’t
    need to tell you that delims is short for *delimiters* and that tokens is short
    for, well, *tokens*. But there’s a good chance that you are puzzled by the cryptic
    text usebackq. The keyword stands for *use back quote*, which probably doesn’t
    help much, but at least now you’ll know how to pronounce it when you see it.
  prefs: []
  type: TYPE_NORMAL
- en: File Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The best way to show the usefulness of the usebackq keyword is to re-create
    the type of situation that surely led to its creation. Many examples to this point
    in the chapter have read a file named *FourBrits.txt*. I rarely embed spaces in
    filenames, but someone else might have named this file *Four Brits.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the problem spaces can cause, I’ve lifted the following for
    /F command verbatim from earlier, except the filename now contains an embedded
    space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Batch considers this to be two files (not one) and will likely fail, not being
    able to find an extensionless file named *Four*. The obvious solution is to put
    double quotes around the path and filename, but the for /F command will treat
    that as a text string instead of a filename, so that won’t work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to use the usebackq keyword *and* double quotes around the
    input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This keyword also makes it easier to process paths and filenames containing
    special characters such as parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The for /F command successfully reads the file and produces the same output
    as before. You can even read multiple files, each with embedded spaces in their
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the filenames are delimited by a comma and that a set of double
    quotes encases each filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the general syntax of the command using a file-set as input with the
    usebackq keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This keyword changes the rules. Double quotes can surround each filename, although
    it still works with the keyword and without any double quotes, assuming the filename
    has no embedded spaces.
  prefs: []
  type: TYPE_NORMAL
- en: String Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The usebackq keyword solved one problem but created another. It enables the
    use of double quotes around a filename, but this seems to disallow the ability
    to process a string. The solution is to encase the text in a different character
    and that character is the single quote. Here’s the general syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, the following two for commands are functionally equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Without usebackq, I’m encasing the short list of Stooges in double quotes, but
    single quotes encase the same text when the keyword is present. (I’m also using
    the break or *no operation* command to make these commands valid while focusing
    on the keyword and the type of quotes, but these commands produce no output.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Why does Batch provide two means of performing the same task? To answer this
    question, I’ll use a string of Chicago airports, each encased in parentheses for
    some unknown reason, as the input. The following two commands are functionally
    equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The first example, which doesn’t use usebackq, is far more workable. You must
    escape special characters such as the parentheses when using the keyword, all
    because of the lack of double quotes. But without the keyword, these characters
    are just along for the ride inside the double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the one character that will never work in a double-quoted string is a solitary
    double quote itself—even when escaped. Returning to the Stooges, while Iggy Pop
    was the front man for *The Stooges*, he clearly wasn’t a member of *The Three
    Stooges*, so I might want to put his name in scare quotes, or double quotes, to
    denote the irony:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: (The interpreter is intelligent enough to handle an even number of double quotes
    inside a set of double quotes, but for clarity I always use the keyword and encase
    the entire input in single quotes when the string has any double quotes.)
  prefs: []
  type: TYPE_NORMAL
- en: 'This for /F command writes the following to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: (Poor Shemp, everyone forgets about Shemp.)
  prefs: []
  type: TYPE_NORMAL
- en: Command Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You just learned to use single quotes when also using usebackq and string input,
    so you can no longer use them to encase a command. But this general syntax allows
    you to use the keyword with a command as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In some fonts the two characters encasing the command input might look like
    single quotes, but they’re something new.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us back to the cliffhanger concerning the meaning of the text usebackq
    or *use back quote*. It’s named for those crooked single quotes encasing the command,
    which are more properly called back quotes (or back ticks). The keyboard key for
    the back quote is just above TAB and to the left of the key for the number 1 on
    most keyboards. This key does double duty, as shifting it gets you the tilde.
    It’s relegated to the nether regions of the keyboard because it’s rarely if ever
    touched by most, but it’s an instrumental key for Batch coders.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following for /F commands are functionally equivalent; the first one mimics
    a command from the prior section, and the second one uses the keyword and back
    quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The first line supports instances where the encased command might contain a
    back quote, while you’d use the second line—the syntax with the usebackq keyword—when
    the command might contain a single quote.
  prefs: []
  type: TYPE_NORMAL
- en: When to Use usebackq
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can implement each type of input with or without usebackq, so when should
    you use the keyword? In a sentence: whenever possible, I use usebackq for file-set
    and command inputs, and I don’t for string input.'
  prefs: []
  type: TYPE_NORMAL
- en: Encasing the input in double quotes allows for the most flexibility and should
    be done whenever possible. It supports embedded spaces in the input and many characters
    that might otherwise require escaping. Hence, when processing a file-set, I use
    double quotes and usebackq, and when processing a string, I use double quotes
    and omit the keyword.
  prefs: []
  type: TYPE_NORMAL
- en: When the input is a command, double quotes don’t enter into the calculus. Some
    may skip the keyword to save a few keystrokes, but I use the usebackq keyword
    and back quotes around the input for two reasons. First, while both the single
    quote and back quote are unlikely characters in a command, the back quote is even
    more unlikely. More important, when you see the single quotes, you immediately
    ask whether the input is a string or a command; the back quotes remove all ambiguity;
    it’s a command.
  prefs: []
  type: TYPE_NORMAL
- en: If you implement my recommendations, the end result will be that anyone looking
    at your for /F commands will be able to infer a great deal from the input. If
    it’s encased in back quotes, it’s a command; if it’s encased in double quotes,
    focus shifts to usebackq. If it’s present, the input is a file-set; if not, it’s
    a string. There are three more forms available in the event of a blue moon, but
    you’ll see an input string containing a double quote or an input command containing
    a back quote less frequently than you’ll see two full moons in a calendar month.
  prefs: []
  type: TYPE_NORMAL
- en: As one final note on the usebackq, if you don’t find this keyword cryptic enough,
    the q is optional. You can replace every instance of usebackq appearing in the
    code listings in this chapter with its synonym useback. I’m usually in favor of
    reducing keystrokes, but this puts an additional veil over something that’s already
    inscrutable to many.
  prefs: []
  type: TYPE_NORMAL
- en: Real-World Applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ability to read files and to treat strings and the outputs of commands as
    if they were files has many applications. Truly understanding the different types
    of inputs possible for a for /F command will allow you to come up with imaginative
    solutions to problems that may have seemed intractable not long ago.
  prefs: []
  type: TYPE_NORMAL
- en: Process Only Large Files in a Folder
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Chapter 17](chapter17.xhtml), I explored an application that passed a number
    of files into a bat file to be processed one by one. In this example, we’ll still
    process files individually, but instead of a list of arguments, let’s process
    all *.txt* files in a particular folder. To make it a little more interesting,
    let’s process only large files, defined as any file at least 100KB in size.
  prefs: []
  type: TYPE_NORMAL
- en: You can feed the dir command into the for /F command as input with back quotes
    encasing the command if using the usebackq keyword. The bare format option, /B,
    produces a clean list of files without headers and is tailor-made for this purpose,
    but the file size is lost with this option, so let’s drop that idea, at least
    for now.
  prefs: []
  type: TYPE_NORMAL
- en: However, not using the /B option presents other challenges. File dates and times
    will be present, along with header and trailer records. You’ll want to use the
    size of each file to evaluate whether it’s large enough to process, but the pesky
    commas in the displayed file size will be more than a nuisance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 13](chapter13.xhtml), I mentioned that the /-C option of the dir
    command suppresses the commas, but to figure out how to parse what you want out
    of its output, you’ll want to see a sample. Unless you possess a memory far more
    detailed than mine, an essential step in building any complex for /F command with
    an embedded command is to execute that embedded command, the command that will
    be inside the back quotes, and inspect its output. Here’s the command, where workDir
    is the folder in question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'It might generate something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: There’s a lot to unpack here, but with this data you can construct the rest
    of the for /F command. You’re interested in the four detail records, but there
    are five header records, including the empty records, so you’ll want to avoid
    them with the skip=5 clause.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to figure out the best way to find the tokens that correspond
    to the file size and name. The space character is one of the default delimiters,
    and it’ll work great here, but notice that if you had wanted the month, day, year,
    hour, or minutes out of the data, you would have used a delims clause defining
    a delimiter set of forward slashes, colons, and spaces. Given that the space is
    the delimiter, you must now put on your interpreter hat and look for the space-delimited
    tokens. The date is the first token, and the time comprises the next two tokens;
    because of the embedded space, the meridiem (AM/PM) becomes the third token. Hence,
    the fourth token is the file size with the remainder of the data being the filename.
  prefs: []
  type: TYPE_NORMAL
- en: To represent size, you’ll use %%s as the for variable, meaning that %%t will
    be the filename and extension. (If you use %%e as the size, then %%f becomes the
    file.)
  prefs: []
  type: TYPE_NORMAL
- en: It might be tempting to consider the filename to be the fifth token, but filenames
    can contain spaces, and any space in the name will delimit yet another token.
    Fortunately, the filename comes at the end of the data, meaning that the tokens=4*
    clause assigns two tokens. The fourth token is the file size, and thanks to the
    asterisk, the rest of the data, which is the filename, becomes the fifth token.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’re not done, but you can put together the main structure of the for /F
    command. Everything discussed is here, in particular, the dir command inside back
    quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Before calling the logic to process a big file, you’ll need to navigate two
    if commands. The first simply verifies that the file size, %%s, is greater than
    or equal to 100000. The for /F command allows you to skip header records, but
    trailer records are still in play, so you must get creative. Notice in the dir
    command output that the fourth token in both trailer records is the text bytes,
    which surely won’t be the case for the detail records you’re interested in. Hence,
    you’ll need a second if command to filter out those two unwanted records by inspecting
    the same %%s variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can put it all together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If the workDir variable is populated with the working directory of the text
    files, this code is ready to process the big text files represented by %%t. Also,
    it might seem quite odd that %%s is used in both numeric and alpha compares. In
    [Chapter 4](chapter4.xhtml), I mentioned that numeric and alpha values are ordered;
    letters are considered to be greater than numbers, so the bytes geq 100000 conditional
    clause is always true. If it had always been false, you could have omitted the
    second if command.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple solutions always exist, and it’s great to see a different way to think
    through an issue. I’m going to take another pass at the /B option of the dir command.
    I know that it won’t provide the file size, but maybe there’s another way to get
    it. I showed how to use modifiers to get the size of a file using the optionless
    for command in [Chapter 17](chapter17.xhtml). Maybe two for commands will be better
    than one.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start with this solution, which implements nested for commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The outer for command has the /F option, along with the usebackq keyword, and
    it uses %%f as its variable. Its input is a dir command with the /B option encased
    in back quotes. The tokens=* clause ensures that the code passes each filename,
    regardless of embedded spaces, into the code block, where I immediately prepend
    it with the path, put it in double quotes, and use it as the input to the inner
    for command.
  prefs: []
  type: TYPE_NORMAL
- en: That inner command, which doesn’t sport the /F option, uses %%g as its variable,
    but anything other than %%f would have been good form. I’m deriving the file size
    with the use of a modifier, %%~Zg; if it’s large enough, the call command invokes
    the routine that processes large files.
  prefs: []
  type: TYPE_NORMAL
- en: Nested for commands don’t behave much differently from their non-nested cousins,
    but an important point is the alpha character chosen for the for variable of each
    command. I could’ve used %%f for both commands, but I always use unique values,
    as it’s simply clearer and easier to read. In addition, the outer variable is
    still available inside the inner command, but only if it hasn’t been stepped on
    by the inner variable.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent a for variable conflict, they should not only be different, but I
    also recommend staggering them so that any implied variables don’t collide. For
    instance, if the outer command is extracting three tokens from the input data
    and using %%f as its for variable, then %%g and %%h should also be off limits
    for the inner command.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve seen two solutions to the same problem. One used a more complex command
    to parse the data, and the other used nested commands. Which way is better is
    debatable. What isn’t debatable is that just as in other languages, multiple possible
    solutions exist for all problems. Never settle.
  prefs: []
  type: TYPE_NORMAL
- en: Global Text Replacement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine you maintain an old system that runs a number of executables, many of
    which are housed on an old server. The team is decommissioning the server, *\\OldServer*,
    and replacing it with the aptly named *\\NewServer*. The plan is to move every
    file on the old box to the new box with the same directory structure.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, your team has wisely implemented and adhered to a consistent naming
    convention for the variables that define each program; they all start with _pgm.
    You control the creation of some of these variables, but not all. You’ll never
    be able to track them all down, but to cut over to the new server successfully,
    you’ll need to tweak all of these variables on the fly—that is, you’ll need to
    change the text for the old server to the new text, and you can’t even get a list
    of all the variable names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first problem to solve is retrieving the list of variable names in a given
    execution. In [Chapter 2](chapter2.xhtml), you learned that the following command
    generates a list of all currently active variables that start with the text _pgm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If just four such variables were set, the following might be the result of
    the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The first and last of these need tweaking, the second has already been updated
    with the new text, and third has a completely different directory structure. You’ll
    need to update two of these without altering the other two. The solution entails
    the previous set command as the input to a for /F command. The code block will
    accept the variable name and value and reset the variable to its value with the
    updated text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following for /F command is one solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: You’ve placed the command set _pgm between back quotes and used the usebackq
    keyword in the for /F command. When using the dir command as input, I stressed
    the importance of understanding its output, and the same holds true for the set
    command. Looking at the four sample lines of output, the commonality between them
    is that a variable name is followed by a value, separated by an equal sign. Thus,
    you’re delimiting on the equal sign with the delims== clause and extracting both
    tokens with the tokens=1,2 clause. The for variable, %%p, is the variable name,
    implying that %%q is its value.
  prefs: []
  type: TYPE_NORMAL
- en: This code resets the variable in the code block with just two commands. You
    assign the original value of the input variable, %%q, to tempPgm, a temporary
    variable. The second command resets the variable name, %%p, to that value with
    *\\OldServer\* replaced with *\\NewServer\*. Notice that because tempPgm is being
    set and then used inside of a code block, you must use exclamation marks to resolve
    the variable to its current value.
  prefs: []
  type: TYPE_NORMAL
- en: This logic updates all variables with this specific prefix while ignoring those
    without the prefix. There are many other applications based on this principle.
    You could reset all similarly named variables to null by replacing the code in
    the code block with one command, set %%p=, and using the default tokens clause.
  prefs: []
  type: TYPE_NORMAL
- en: Notes on the Documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I’ve taken some liberties with the general syntax of the different forms of
    the for /F command, so I’ll compare what you’ve seen here to what’s in the help
    documentation and explain my reasons. First, this is exactly what you’ll find
    by running for /?:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'I instead list the three forms that I use almost exclusively, followed by the
    ones I use infrequently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: First off, I have more of an affinity for lowercase characters than most coders.
    Also, I’ve replaced the ["options"] clause with ["suboptions"]. This for command
    already has one option, /F, and I see no reason to introduce another type of option,
    so I’ve settled on the term *suboptions*, but both of these tweaks are cosmetic.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve dropped [command-parameters] from the end of each, which just states that
    the command could have parameters, but that’s obvious and unworthy of the extra
    ink. To truly do it correctly, I could’ve shown additional optional commands as
    well as optional parentheses defining a possible code block. To be readable, it
    has to be a bit vague, so I’ve decided to also make it succinct.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is that I’ve used two percent signs for the for variable,
    %%variable, as opposed to one. The help shows how you would execute the command
    from the command prompt, where the only difference is that it calls for a single
    percent sign. This is a book about bat files, not the command prompt, and the
    command is usually too complex to be entered at the prompt anyway.
  prefs: []
  type: TYPE_NORMAL
- en: I explicitly show the usebackq keyword in the forms that use it, while the help
    documentation places them after an odd heading. To accommodate this change, I’ve
    also placed the other suboptions inside the square brackets because they are still
    optional.
  prefs: []
  type: TYPE_NORMAL
- en: The final difference is in the first form, and it’s the most critical one. When
    researching this book, I was absolutely flabbergasted to notice that the two forms
    using the file-set as input are identical in the help. Adding the usebackq keyword
    means that double quotes can now encase the input. Technically, they don’t have
    to be there, but isn’t that the whole point of using usebackq? I’m hard-pressed
    to come up with an instance where I wouldn’t want the double quotes while using
    the keyword, so I’m including them in my documentation, but understand that they
    are optional.
  prefs: []
  type: TYPE_NORMAL
- en: Use the forms that make sense to you. Better yet, start with one set or the
    other (I hope mine) and build on it in your own personal documentation about the
    for command.
  prefs: []
  type: TYPE_NORMAL
- en: Deconstructing Any for Command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The for command, especially when followed by the /F option, can be overwhelming.
    You can pack quite a bit of logic into just a few lines of code. When you come
    across one of these constructs, it can be difficult to know exactly where to start
    your analysis. I’ve deconstructed many of these commands (a good number being
    my own) over the years, and whenever I see a command starting with for, I use
    these questions and steps to figure out what the code is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  What’s the option? Is it optionless, /D, /R, /L, or /F?
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Based on the option, what type of input is it using? If it’s optionless,
    is the input a file, files, or a list of values? If it’s /D, expect a directory
    as input. If it’s /R, expect a recursive process on an input of one or more files.
    If it’s /L, look at the three numbers defining the iterative loop. In all four
    of these cases, next step through the logic in the code block given the input.
  prefs: []
  type: TYPE_NORMAL
- en: But if the option is /F, you’ve only just begun the deconstruction. What type
    of input is the command using? If there are no quotes, the input is a file-set;
    if back quotes, a command. If double quotes, usebackq translates to a file-set;
    otherwise, a string. If single quotes, usebackq translates to a string; otherwise,
    a command.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Determine what the input is contributing. Does the file-set have a wildcard?
    Roughly how many files are being processed? What type of data is in the file or
    files? Is the string hardcoded or a variable? What does the command do, and what’s
    its output? Roughly how many lines of output are created? How consistent is the
    data—that is, will there be header or trailer data?
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Examine the suboptions and determine how the input is being manipulated.
    Based on the tokens and delims clauses (or their defaults), how many tokens are
    created, and how will they be populated from the input? Are any records dropped
    with skip or eol clauses?
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Identify the for variable, perhaps %%i, and determine the input data associated
    with it and its subsequent variables, perhaps %%j and %%k.
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Examine the code block. Determine how the for variable, and any implied
    variables, are referenced. Is something being copied, renamed, deleted, or processed
    in any way?
  prefs: []
  type: TYPE_NORMAL
- en: 'Maybe these questions and steps seem overwhelming, but to demonstrate how easy
    they are to use, let’s deconstruct some code. Someone you just met online has
    given you this command telling you that it will back up some files. Just run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'But before executing this, you should deconstruct it. Using the prior six steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  The option is /F.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Back quotes encase the input, so it’s a command.
  prefs: []
  type: TYPE_NORMAL
- en: '3.  The source argument of the xcopy is an asterisk, meaning that the command
    copies all files from the current directory to an oddly named folder using two
    pseudo-environment variables that I’ve yet to discuss (but will in [Chapter 21](chapter21.xhtml)).
    If this command copies five files successfully, the output will be a list of the
    five source files, followed by the trailer record stating: 5 File(s) copied.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Based on the tokens clause and the lack of a delims clause, this code extracts
    the first and third tokens from the space-delimited input. For most of the output,
    the first token is the full path and name of the source file, assuming that there
    are no embedded spaces, and the third token is null. For the last line of input,
    or the trailer record, the first token resolves to the number of files copied,
    while the third token is the word copied.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  The %%x is the path and filename up until the last line of output when it
    becomes the number of files copied. The %%y is nothing at all (again assuming
    no embedded spaces) before resolving to copied while processing the last line
    of output. So far, so good.
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Shifting to the code block, the if command filters out the last record where
    %%y resolves to the specific text, meaning that for every file that’s copied the
    echo command replaces its entire contents with what looks to be a vague threat.
  prefs: []
  type: TYPE_NORMAL
- en: This looks to be more than a little suspicious. The code is hiding away all
    files from the current directory, including the bat file itself assuming it’s
    in the current directory, in a randomly named folder. Then it wipes out and replaces
    the contents of each source file with some text. It’s of little consolation that
    files with embedded spaces in their name may be spared.
  prefs: []
  type: TYPE_NORMAL
- en: Because you now know how to deconstruct a for command, you weren’t fooled by
    this bat file. Without executing the code, you’ve deduced that it’s malicious
    code—a bat virus.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about the file reading option of the for command,
    and you learned that it does much more than read files. The input can be a file,
    a string, or the output of a command, each with distinct syntaxes. I detailed
    the syntax for manipulating the input data, creating tokens, and using those tokens
    in the code block of the command. I also demonstrated much of this functionality
    with some real-world problems, finishing up with a discussion about how to deconstruct
    this important command.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I’ll close out [Part II](part2.xhtml) with an examination
    of a few advanced techniques that will either solve a problem associated with
    using the for command or solve a problem with the use of the for command.
  prefs: []
  type: TYPE_NORMAL
