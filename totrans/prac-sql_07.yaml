- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Joining Tables in a Relational Database
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系数据库中连接表
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In Chapter 2, I introduced the concept of a *relational database*, an application
    that supports data stored across multiple, related tables. In a relational model,
    each table typically holds data on a single entity—such as students, cars, purchases,
    houses—and each row in the table describes one of those entities. A process known
    as a *table join* allows us to link rows in one table to rows in other tables.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，我介绍了*关系数据库*的概念，这是一种支持数据跨多个相关表存储的应用程序。在关系模型中，每张表通常保存一个单独实体的数据——如学生、汽车、购买、房屋——表中的每一行描述该实体之一。一个被称为*表连接*的过程，允许我们将一张表中的行与其他表中的行进行连接。
- en: The concept of relational databases came from the British computer scientist
    Edgar F. Codd. While working for IBM in 1970, he published a paper called “A Relational
    Model of Data for Large Shared Data Banks.” His ideas revolutionized database
    design and led to the development of SQL. With the relational model, you can build
    tables that eliminate duplicate data, are easier to maintain, and provide for
    increased flexibility in writing queries to get just the data you want.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库的概念来源于英国计算机科学家埃德加·F·科德（Edgar F. Codd）。1970年，在为IBM工作时，他发布了一篇名为《大型共享数据银行的数据关系模型》（A
    Relational Model of Data for Large Shared Data Banks）的论文。他的观点彻底改变了数据库设计，并推动了SQL的发展。通过关系模型，你可以构建消除重复数据、更易维护并且在编写查询时提供更高灵活性的表，从而精确地获取你需要的数据。
- en: Linking Tables Using JOIN
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JOIN链接表
- en: 'To connect tables in a query, we use a `JOIN ... ON` construct (or one of the
    other `JOIN` variants I’ll cover in this chapter). A `JOIN`, which is part of
    the ANSI SQL standard, links one table to another in the database using a *Boolean*
    value expression in the `ON` clause. A commonly used syntax tests for equality
    and commonly takes this form:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要在查询中连接表，我们使用`JOIN ... ON`结构（或者本章我将介绍的其他`JOIN`变体）。`JOIN`是ANSI SQL标准的一部分，它通过`ON`子句中的*布尔*值表达式将一张表与另一张表连接。常用的语法测试相等性，通常采用如下形式：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is similar to the basic `SELECT` you’ve already learned, but instead of
    naming one table in the `FROM` clause, we name a table, give the `JOIN` keyword,
    and then name a second table. The `ON` clause follows, where we place an expression
    using the equals comparison operator. When the query runs, it returns rows from
    both tables where the expression in the `ON` clause evaluates to `true`, meaning
    values in the specified columns are equal.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这与你已经学习的基本`SELECT`类似，但我们不再在`FROM`子句中指定一个表，而是命名一个表，给出`JOIN`关键字，然后再命名第二个表。接着是`ON`子句，我们在这里使用等式比较操作符放置一个表达式。当查询执行时，它会返回两个表中`ON`子句表达式为`true`的行，意味着指定列中的值相等。
- en: 'You can use any expression that evaluates to the *Boolean* results `true` or
    `false`. For example, you could match where values from one column are greater
    than or equal to values in the other:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用任何评估为*布尔*结果`true`或`false`的表达式。例如，你可以匹配一个列中的值是否大于或等于另一个列中的值：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That’s rare, but it’s an option if your analysis requires it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况很少见，但如果你的分析需要，还是可以选择这种方式。
- en: Relating Tables with Key Columns
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用关键列关联表
- en: 'Consider this example of relating tables with key columns: imagine you’re a
    data analyst with the task of checking on a public agency’s payroll spending by
    department. You file a Freedom of Information Act request for that agency’s salary
    data, expecting to receive a simple spreadsheet listing each employee and their
    salary, arranged like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用关键列关联表的例子：假设你是一个数据分析师，任务是检查一个公共机构按部门划分的薪资支出。你向该机构提交了一份信息自由法案（Freedom of
    Information Act）请求，期望收到一份简单的电子表格，列出每个员工及其薪水，格式如下：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But that’s not what arrives. Instead, the agency sends you a data dump from
    its payroll system: a dozen CSV files, each representing one table in its database.
    You read the document explaining the data layout (be sure to always ask for it!)
    and start to make sense of the columns in each table. Two tables stand out: one
    named `employees` and another named `departments`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上并不是这样。相反，机构向你发送了来自其薪资系统的数据转储：十几个CSV文件，每个文件代表数据库中的一张表。你阅读了文档，了解了数据布局（一定要记得请求这份文档！），并开始理解每张表中的列。两张表特别突出：一张名为`employees`，另一张名为`departments`。
- en: Using the code in [Listing 7-1](#listing7-1), let’s create versions of these
    tables, insert rows, and examine how to join the data in both tables. Using the
    `analysis` database you’ve created for these exercises, run all the code, and
    then look at the data either by using a basic `SELECT` statement or by clicking
    the table name in pgAdmin and selecting **View/Edit Data**▶**All Rows**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [列表 7-1](#listing7-1) 中的代码，让我们创建这些表的版本，插入行，并检查如何连接两个表中的数据。使用你为这些练习创建的 `analysis`
    数据库，运行所有代码，然后通过使用基本的 `SELECT` 语句查看数据，或通过点击 pgAdmin 中的表名并选择 **查看/编辑数据**▶**所有行**。
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 7-1: Creating the `departments` and `employees` tables'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-1：创建 `departments` 和 `employees` 表
- en: 'The two tables follow Codd’s relational model in that each describes attributes
    about a single entity: the agency’s departments and employees. In the `departments`
    table, you should see the following contents:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个表遵循 Codd 的关系模型，因为每个表描述了一个单一实体的属性：机构的部门和员工。在 `departments` 表中，你应该看到以下内容：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `dept_id` column is the table’s primary key. A *primary key* is a column
    or collection of columns whose values uniquely identify each row in a table. A
    valid primary key column enforces certain constraints:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`dept_id` 列是表的主键。*主键*是一个列或列的集合，其值唯一标识表中的每一行。有效的主键列会强制执行某些约束：'
- en: The column or collection of columns must have a unique value for each row.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列或列的集合必须为每一行提供唯一值。
- en: The column or collection of columns can’t have missing values.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列或列的集合不能有缺失值。
- en: You define the primary key for `departments` 1 and `employees` 4 using a `CONSTRAINT`
    keyword, which I’ll cover in depth with additional constraint types in Chapter
    8. The values in `dept_id` uniquely identify each row in `departments`, and although
    this example contains only a department name and city, this table would likely
    include additional information, such as an address or contact information.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 `CONSTRAINT` 关键字为 `departments` 1 和 `employees` 4 定义了主键，我将在第 8 章中详细介绍其他约束类型。`dept_id`
    中的值唯一标识 `departments` 中的每一行，尽管这个例子只包含了部门名称和城市，但这个表可能还会包括其他信息，比如地址或联系信息。
- en: 'The `employees` table should have the following contents:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`employees` 表应该包含以下内容：'
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The values in `emp_id` uniquely identify each row in the `employees` table.
    To identify which department each employee works in, the table includes a `dept_id`
    column. The values in this column refer to values in the `departments` table’s
    primary key. We call this a *foreign key*, which you add as a constraint 3 when
    creating the table. A foreign key constraint requires that its values already
    exist in the columns it references. Often, that’s another table’s primary key,
    but it can reference any columns that have unique values for each row. So, values
    in `dept_id` in the `employees` table must exist in `dept_id` in the `departments`
    table; otherwise, you can’t add them. This helps enforce the integrity of the
    data. Unlike a primary key, a foreign key column can be empty, and it can contain
    duplicate values.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`emp_id` 中的值唯一标识 `employees` 表中的每一行。为了确定每个员工所属的部门，表中包含了一个 `dept_id` 列。该列中的值引用
    `departments` 表的主键中的值。我们称之为*外键*，你在创建表时作为约束 3 添加。外键约束要求其值在它所引用的列中已经存在。通常，这些值是另一个表的主键，但它也可以引用任何具有唯一值的列。因此，`employees`
    表中的 `dept_id` 值必须在 `departments` 表中的 `dept_id` 存在；否则，你不能添加它们。这有助于维护数据的完整性。与主键不同，外键列可以为空，并且可以包含重复值。'
- en: In this example, the `dept_id` associated with the employee `Julia Reyes` is
    `1`; this refers to the value of `1` in the `departments` table’s primary key,
    `dept_id`. That tells us that `Julia Reyes` is part of the `Tax` department located
    in `Atlanta`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，与员工 `Julia Reyes` 关联的 `dept_id` 为 `1`；这指的是 `departments` 表中主键 `dept_id`
    的值 `1`。这告诉我们 `Julia Reyes` 是位于 `Atlanta` 的 `Tax` 部门的一员。
- en: The `departments` table also includes a `UNIQUE` constraint, which I’ll discuss
    in more depth in “The UNIQUE Constraint” in the next chapter. Briefly, it guarantees
    that values in a column, or a combination of values in more than one column, are
    unique. Here, it requires that each row have a unique pair of values for `dept`
    and `city` 2, which helps avoid duplicate data—the table won’t have two departments
    in Atlanta named `Tax`, for example. Often, you can use such unique combinations
    to create a *natural key* for a primary key, which we’ll also discuss in the next
    chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`departments`表还包括一个`UNIQUE`约束，我将在下一章的“UNIQUE约束”中更详细地讨论。简而言之，它保证某一列中的值，或多列值的组合，是唯一的。在这里，它要求每一行在`dept`和`city`列中都有一对唯一的值，这有助于避免重复数据——例如，表中不会有两个名为“Tax”的亚特兰大部门。通常，你可以使用这种唯一的组合来创建一个*自然键*作为主键，我们将在下一章进一步讨论。'
- en: 'You might ask: what’s the advantage of breaking data into components like this?
    Well, consider what this sample of data would look like if you had received it
    the way you initially thought you would, all in one table:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问：将数据拆分成这样组成的好处是什么？那么，考虑一下如果你按照最初的想法，将所有数据都放在一个表中，数据会是什么样子：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'First, when you combine data from various entities in one table, inevitably
    you have to repeat information. This happens here: the department name and location
    are spelled out for each employee. This may be acceptable when the table consists
    of four rows like this, or even 4,000\. But when a table holds millions of rows,
    repeating lengthy strings is redundant and wastes precious space.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当你将来自不同实体的数据组合到一个表中时，不可避免地需要重复信息。在这里，部门名称和位置会为每个员工重复显示。当表仅包含四行数据时，或者即使是4,000行时，这种重复是可以接受的。但当表中有数百万行时，重复的冗长字符串既冗余又浪费宝贵的空间。
- en: Second, cramming all that data into one table makes managing the data difficult.
    What if the Marketing department changes its name to Brand Marketing? Each row
    in the table would require an update, which can introduce errors if someone mistakenly
    updates some but not all the rows. In this model, an update to a department name
    is much simpler—just change one row in a table.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，将所有数据压缩到一个表中会使得数据管理变得困难。如果营销部门的名字更改为品牌营销（Brand Marketing）怎么办？表中的每一行都需要更新，如果有人不小心只更新了一部分行而不是所有行，就可能会引入错误。在这种模型中，更新部门名称要简单得多——只需更改表中的一行。
- en: Finally, the fact that information is organized, or *normalized*, across several
    tables doesn’t prevent us from viewing it as a whole. We can always query the
    data using `JOIN` to bring columns from tables together.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，信息被组织或*规范化*在多个表中，并不会妨碍我们将其作为一个整体来查看。我们总是可以通过`JOIN`查询数据，将多个表的列合并在一起。
- en: Now that you know the basics of how tables can relate, let’s look at how to
    join them in a query.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了表如何关联的基本知识，接下来我们来看看如何在查询中连接它们。
- en: Querying Multiple Tables Using JOIN
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`JOIN`查询多个表
- en: When you join tables in a query, the database connects rows in both tables where
    the columns you specified for the join have values that result in the `ON` clause
    expression returning `true`. The query results then include columns from both
    tables if you requested them as part of the query. You also can use columns from
    the joined tables to filter results using a `WHERE` clause.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在查询中连接表时，数据库会在两个表中连接你指定用于连接的列，只有当这些列的值使得`ON`子句的表达式返回`true`时，才会连接。查询结果会包含来自两个表的列，前提是你在查询中要求它们。你还可以使用连接表中的列，通过`WHERE`子句过滤结果。
- en: 'Queries that join tables are similar in syntax to basic `SELECT` statements.
    The difference is that the query also specifies the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 连接表的查询在语法上与基本的`SELECT`语句类似。不同之处在于查询还指定了以下内容：
- en: The tables and columns to join, using a SQL `JOIN ... ON` construct
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要连接的表和列，使用SQL `JOIN ... ON`结构
- en: The type of join to perform using variations of the `JOIN` keyword
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`JOIN`关键字的变体来指定要执行的连接类型
- en: Let’s look at the `JOIN ... ON` construct syntax first and then explore various
    types of joins. To join the example `employees` and `departments` tables and see
    all the related data from both, start by writing a query like the one in [Listing
    7-2](#listing7-2).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看一下`JOIN ... ON`结构的语法，然后再探索不同类型的连接。为了连接示例中的`employees`和`departments`表，并查看两个表的所有相关数据，可以从编写类似[Listing
    7-2](#listing7-2)的查询开始。
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 7-2: Joining the `employees` and `departments` tables'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-2: 连接`employees`和`departments`表'
- en: In the example, you include an asterisk wildcard with the `SELECT` statement
    to include all columns from all tables used in the query 1. Next, in the `FROM`
    clause, you place the `JOIN` keyword 2 between the two tables you want to link.
    Finally, you specify the expression to evaluate using the `ON` clause 3. For each
    table, you provide the table name, a period, and the column that contains the
    key values. An equal sign goes between the two table and column names.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你在`SELECT`语句中使用了一个星号通配符，以便从查询中使用的所有表中包含所有列。接下来，在`FROM`子句中，你将`JOIN`关键字放置在你想要连接的两个表之间。最后，你使用`ON`子句指定要评估的表达式。对于每个表，你提供表名、一个句点和包含关键值的列名。两个表和列名之间用等号连接。
- en: 'When you run the query, the results include all values from both tables where
    values in the `dept_id` columns match. In fact, even the `dept_id` column appears
    twice because you selected all columns of both tables:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行查询时，结果将包括两个表中所有在`dept_id`列中匹配的值。事实上，甚至`dept_id`列也会出现两次，因为你选择了两个表的所有列：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, even though the data lives in two tables, each with a focused set of columns,
    you can query those tables to pull the relevant data back together. In “Selecting
    Specific Columns in a Join” later in this chapter, I’ll show you how to retrieve
    only the columns you want from both tables.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使数据存在于两个表中，每个表都有一组专注的列，你仍然可以查询这些表，将相关数据汇总到一起。在本章稍后的“在连接中选择特定列”一节中，我将向你展示如何从两个表中只检索你需要的列。
- en: Understanding JOIN Types
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解JOIN类型
- en: 'There’s more than one way to join tables in SQL, and the type of join you’ll
    use depends on how you want to retrieve data. The following list describes the
    different types of joins. While reviewing each, it’s helpful to think of two tables
    side by side, one on the left of the `JOIN` keyword and the other on the right.
    A data-driven example of each join follows the list:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL中有多种连接表的方法，使用哪种连接取决于你希望如何检索数据。以下列表描述了不同类型的连接。在回顾每种连接时，思考将两个表并排放置，一个在`JOIN`关键字的左边，另一个在右边会很有帮助。每种连接的具体数据驱动示例如下所示：
- en: '`JOIN` Returns rows from both tables where matching values are found in the
    joined columns of both tables. Alternate syntax is `INNER JOIN`.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`JOIN` 返回两个表中在连接列中找到匹配值的行。另一种语法是`INNER JOIN`。'
- en: '`LEFT JOIN` Returns every row from the left table. When SQL finds a row with
    a matching value in the right table, values from that row are included in the
    results. Otherwise, no values from the right table are displayed.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LEFT JOIN` 返回左侧表中的每一行。当SQL在右侧表中找到匹配的值时，这一行的值会包含在结果中。否则，右侧表的值不会显示。'
- en: '`RIGHT JOIN` Returns every row from the right table. When SQL finds a row with
    a matching value in the left table, values from that row are included in the results.
    Otherwise, no values from the left table are displayed.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RIGHT JOIN` 返回右侧表中的每一行。当SQL在左侧表中找到匹配的值时，这一行的值会包含在结果中。否则，左侧表的值不会显示。'
- en: '`FULL OUTER JOIN` Returns every row from both tables and joins the rows where
    values in the joined columns match. If there’s no match for a value in either
    the left or right table, the query result contains no values for that table.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FULL OUTER JOIN` 返回两个表中的每一行，并在连接列中的值匹配时合并这些行。如果左侧或右侧表中的某个值没有匹配项，则查询结果中不会显示该表的任何值。'
- en: '`CROSS JOIN` Returns every possible combination of rows from both tables.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CROSS JOIN` 返回两个表中所有可能的行组合。'
- en: 'Let’s use data to see these joins in action. Say you have two simple tables
    that hold names of schools for a district that is planning future enrollments:
    `district_2020` and `district_2035`. There are four rows in `district_2020`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过数据来看看这些连接是如何运作的。假设你有两个简单的表，分别存储一个学区的学校名称，学区计划未来的入学情况：`district_2020` 和
    `district_2035`。`district_2020` 中有四行数据：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are five rows in `district_2035`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`district_2035` 中有五行数据：'
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that the district expects changes over time. Only schools with an `id`
    of `1`, `2`, and `6` exist in both tables, while others appear in just one of
    them. This scenario is common, and a common first task for a data analyst—especially
    if you have tables with many more rows than these—is to use SQL to identify which
    schools are present in both tables. Using different joins can help you find those
    schools, plus other details.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，学区预计会随着时间发生变化。只有`id`为`1`、`2`和`6`的学校同时出现在两个表中，而其他学校仅出现在其中一个表中。这种情况很常见，也是数据分析师的一个常见初始任务——特别是当你处理的表比这两个表有更多行时——你可以使用SQL来识别哪些学校同时出现在两个表中。使用不同的连接可以帮助你找到这些学校以及其他相关信息。
- en: Again, using your `analysis` database, run the code in [Listing 7-3](#listing7-3)
    to build and populate these two tables.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用你的`analysis`数据库，运行[Listing 7-3](#listing7-3)中的代码，来构建和填充这两个表。
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 7-3: Creating two tables to explore `JOIN` types'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-3: 创建两个表以探索`JOIN`类型'
- en: 'We create and fill two tables: the declarations for these should by now look
    familiar, but there’s one new element: we add a primary key to each table. After
    the declaration for the `district_2020` `id` column 1 and the `district_2035`
    `id` column 2, the keywords `CONSTRAINT` `key_name` `PRIMARY KEY` indicate that
    those columns will serve as the primary key for their table. That means for each
    row in both tables, the `id` column must be filled and contain a value that is
    unique for each row in that table. Finally, we use the familiar `INSERT` statements
    3 to add the data to the tables.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建并填充了两个表：这些声明现在应该看起来很熟悉，但有一个新的元素：我们为每个表添加了主键。在`district_2020`的`id`列1和`district_2035`的`id`列2之后，关键字`CONSTRAINT`
    `key_name` `PRIMARY KEY`表明这些列将作为它们各自表的主键。这意味着每个表中的每一行，`id`列都必须填充，并且包含该表中每一行唯一的值。最后，我们使用熟悉的`INSERT`语句3将数据添加到表中。
- en: JOIN
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JOIN
- en: We use `JOIN`, or `INNER` `JOIN`, when we want to return only rows from both
    tables where values match in the columns we used for the join. To see an example
    of this, run the code in [Listing 7-4](#listing7-4), which joins the two tables
    you just made.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望返回仅包含在两个表中匹配列值的行时，我们使用`JOIN`或`INNER JOIN`。要查看这个示例，请运行[Listing 7-4](#listing7-4)中的代码，它连接了你刚刚创建的两个表。
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 7-4: Using `JOIN`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-4: 使用`JOIN`'
- en: 'Similar to the method we used in [Listing 7-2](#listing7-2), we name the two
    tables to join on both sides of the `JOIN` keyword. Then, in the `ON` clause,
    we specify the expression we’re using for the join, in this case equality in the
    `id` columns of both tables. Three school IDs exist in both tables, so the query
    returns only the three rows where those IDs match. Schools that exist in only
    one of the two tables don’t appear in the result. Notice also that the columns
    from the table on the left side of the `JOIN` keyword display on the left of the
    result table:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们在[Listing 7-2](#listing7-2)中使用的方法，我们在`JOIN`关键字两侧指定要连接的两个表。然后，在`ON`子句中，我们指定用于连接的表达式，在这个例子中是两个表的`id`列的相等性。两个表中都有三个学校ID，因此查询只返回这三个ID匹配的行。仅存在于其中一个表中的学校不会出现在结果中。还要注意，`JOIN`关键字左侧表中的列会显示在结果表的左侧：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When should you use `JOIN`? Typically, when you’re working with well-structured,
    well-maintained datasets and need to find rows that exist in all the tables you’re
    joining. Because `JOIN` doesn’t provide rows that exist in only one of the tables,
    if you want to see all the data in one or more of the tables, use one of the other
    join types.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 什么时候应该使用`JOIN`？通常，当你处理结构良好、维护良好的数据集时，并且需要找到在所有连接的表中都存在的行。因为`JOIN`不会返回仅在一个表中存在的行，所以如果你想查看一个或多个表中的所有数据，请使用其他类型的连接。
- en: JOIN with USING
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用USING的JOIN
- en: If you’re using identical names for columns in a join’s `ON` clause, you can
    reduce redundant output and simplify the query syntax by substituting a `USING`
    clause in place of the `ON` clause, as in [Listing 7-5](#listing7-5).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在`JOIN`的`ON`子句中使用相同名称的列，你可以通过用`USING`子句替代`ON`子句，减少冗余输出并简化查询语法，如在[Listing
    7-5](#listing7-5)中所示。
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 7-5: `JOIN` with `USING`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-5: 使用`USING`的`JOIN`'
- en: 'After naming the tables to join, we add `USING` 1 followed by, in parentheses,
    the name of the column for the join in both tables—in this case, `id`. If we’re
    joining on more than one column, we separate them by commas in the parentheses.
    Run the query, and you should see these results:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定要连接的表后，我们添加`USING` 1，后面跟着括号中的列名，这个列名是两个表用于连接的列——在这个例子中是`id`。如果我们要在多个列上进行连接，我们将在括号内用逗号分隔它们。运行查询后，你应该看到以下结果：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that `id`, which in the case of this `JOIN` is present in both tables and
    has identical values, is displayed just once. It’s a simple, handy shorthand.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`id`在这个`JOIN`中出现在两个表中，并且具有相同的值，因此它只显示一次。这是一个简单且方便的简写方式。
- en: LEFT JOIN and RIGHT JOIN
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LEFT JOIN 和 RIGHT JOIN
- en: In contrast to `JOIN`, the `LEFT JOIN` and `RIGHT JOIN` keywords each return
    all rows from one table and, when a row with a matching value in the other table
    exists, values from that row are included in the results. Otherwise, no values
    from the other table are displayed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与`JOIN`相比，`LEFT JOIN`和`RIGHT JOIN`关键字分别返回一个表的所有行，并且当另一个表中存在匹配值的行时，会将该行的值包括在结果中。否则，另一个表中的值不会显示。
- en: Let’s look at `LEFT JOIN` in action first. Execute the code in [Listing 7-6](#listing7-6).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 `LEFT JOIN` 的实际操作。执行 [列表 7-6](#listing7-6) 中的代码。
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 7-6: Using `LEFT JOIN`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-6：使用 `LEFT JOIN`
- en: 'The result of the query shows all four rows from `district_2020`, which is
    on the left side of the join, as well as the three rows in `district_2035` where
    values match in the `id` columns. Because `district_2035` doesn’t contain a value
    of `5` in its `id` column, there’s no match, so `LEFT` `JOIN` returns an empty
    row on the right rather than omitting the entire row from the left table as with
    `JOIN`. Finally, the rows from `district_2035` that don’t match any values in
    `district_2020` are omitted from the results:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的结果显示了来自 `district_2020` 的所有四行，这些数据位于连接的左侧，以及 `district_2035` 中与 `id` 列值匹配的三行。因为
    `district_2035` 的 `id` 列中没有值为 `5` 的数据，所以没有匹配项，因此 `LEFT` `JOIN` 会在右侧返回一行空数据，而不是像
    `JOIN` 那样完全省略左表中的行。最后，`district_2035` 中没有与 `district_2020` 匹配的任何值的行会从结果中省略：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We see similar but opposite behavior by running `RIGHT JOIN`, as in [Listing
    7-7](#listing7-7).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `RIGHT JOIN`，我们可以看到类似但相反的行为，正如 [列表 7-7](#listing7-7) 中所示。
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 7-7: Using `RIGHT JOIN`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-7：使用 `RIGHT JOIN`
- en: 'This time, the query returns all rows from `district_2035`, which is on the
    right side of the join, plus rows from `district_2020` where the `id` columns
    have matching values. The query result omits the row of `district_2020` where
    there’s no match with `district_2035` on `id`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，查询返回了来自 `district_2035` 的所有行，这些数据位于连接的右侧，以及 `district_2020` 中 `id` 列值匹配的行。查询结果会省略没有与
    `district_2035` 在 `id` 上匹配的 `district_2020` 行：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You’d use either of these join types in a few circumstances:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下几种情况下，你可以使用这些连接类型之一：
- en: You want your query results to contain all the rows from one of the tables.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你希望查询结果包含其中一个表的所有行。
- en: You want to look for missing values in one of the tables. An example is when
    you’re comparing data about an entity representing two different time periods.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你希望查找一个表中的缺失值。例如，在比较表示两个不同时间段的实体数据时。
- en: When you know some rows in a joined table won’t have matching values.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你知道某些连接表中的行没有匹配的值时。
- en: As with `JOIN`, you can substitute the `USING` clause for the `ON` clause if
    the tables meet the criteria.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 和 `JOIN` 一样，如果表满足条件，你可以用 `USING` 子句替换 `ON` 子句。
- en: FULL OUTER JOIN
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FULL OUTER JOIN
- en: When you want to see all rows from both tables in a join, regardless of whether
    any match, use the `FULL OUTER JOIN` option. To see it in action, run [Listing
    7-8](#listing7-8).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望在连接中查看两个表的所有行时，无论是否匹配任何数据，都可以使用 `FULL OUTER JOIN` 选项。要查看其效果，请运行 [列表 7-8](#listing7-8)。
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 7-8: Using `FULL OUTER JOIN`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-8：使用 `FULL OUTER JOIN`
- en: 'The result gives every row from the left table, including matching rows and
    blanks for missing rows from the right table, followed by any leftover missing
    rows from the right table:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 结果返回了左表中的每一行，包括匹配的行以及右表中缺失行的空白数据，后面跟着右表中剩余的缺失行：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A full outer join is admittedly less useful and used less often than inner
    and left or right joins. Still, you can use it for a couple of tasks: to link
    two data sources that partially overlap or to visualize the degree to which tables
    share matching values.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `FULL OUTER JOIN` 明确来说不如内连接以及左连接或右连接那样常用且有用，但你仍然可以在一些任务中使用它：比如连接两个部分重叠的数据源，或者可视化表格之间共享匹配值的程度。
- en: CROSS JOIN
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CROSS JOIN
- en: In a `CROSS JOIN` query, the result (also known as a *Cartesian product*) lines
    up each row in the left table with each row in the right table to present all
    possible combinations of rows. [Listing 7-9](#listing7-9) shows the `CROSS JOIN`
    syntax; because the join doesn’t need to find matches between key columns, there’s
    no need to provide an `ON` clause.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CROSS JOIN` 查询中，结果（也称为 *笛卡尔积*）将左表中的每一行与右表中的每一行配对，展示所有可能的行组合。[列表 7-9](#listing7-9)
    显示了 `CROSS JOIN` 的语法；因为该连接不需要在关键列之间查找匹配项，因此无需提供 `ON` 子句。
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 7-9: Using `CROSS JOIN`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-9：使用 `CROSS JOIN`
- en: 'The result has 20 rows—the product of four rows in the left table times five
    rows in the right:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 结果有20行——即左表中的四行与右表中的五行的乘积：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Unless you want to take an extra-long coffee break, I suggest avoiding a `CROSS
    JOIN` query on large tables. Two tables with 250,000 records each would produce
    a result set of 62.5 *billion* rows and tax even the hardiest server. A more practical
    use would be generating data to create a checklist, such as all colors you’d want
    to offer for each of a handful of shirt styles in a store.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你想要一个超长的咖啡休息时间，否则建议避免在大型表上使用`CROSS JOIN`查询。两张表，每张有25万条记录，将生成625亿行的结果集，这会给即便是最强大的服务器也带来巨大压力。一个更实际的用途是生成数据来创建一个清单，比如为商店中的几种衬衫款式提供的所有颜色。
- en: Using NULL to Find Rows with Missing Values
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`NULL`查找缺失值的行
- en: Any time you join tables, it’s wise to investigate whether the key values in
    one table appear in the other, and which values are missing, if any. Discrepancies
    happen for all sorts of reasons. Some data may have changed over time. For example,
    a table of new products will likely contain codes that aren’t present in an older
    product table. Or there could be problems such as a clerical errors or incomplete
    output from the database. All this is important context for making correct inferences
    about the data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你连接表时，明智的做法是检查一个表中的关键值是否出现在另一个表中，以及是否有任何缺失的值。差异发生的原因有很多种。有些数据可能随着时间变化。例如，一个新产品的表格可能包含在旧产品表格中不存在的代码。或者可能存在问题，如文书错误或数据库输出不完整。这些都是进行正确数据推断时的重要背景信息。
- en: 'When you have only a handful of rows, eyeballing the data is an easy way to
    look for rows with missing data, as we did in the previous join examples. For
    large tables, you need a better strategy: filtering to show all rows without a
    match. To do this, we employ the keyword `NULL`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只有少量行时，通过眼睛观察数据是一种简单的方式来查找缺失数据的行，正如我们在前面的连接示例中所做的那样。对于大型表格，你需要更好的策略：筛选出所有没有匹配的行。为此，我们使用关键字`NULL`。
- en: In SQL, `NULL` is a special value that represents a condition in which there’s
    no data present or where the data is unknown because it wasn’t included. For example,
    if a person filling out an address form skips the “Middle Initial” field, rather
    than storing an empty string in the database, we’d use `NULL` to represent the
    unknown value. It’s important to keep in mind that `NULL` is different from `0`
    or an empty string that you’d place in a text column using two quotes (`''`).
    Both those values could have some unintended meaning that’s open to misinterpretation,
    so you use `NULL` to show that the value is unknown. And unlike `0` or an empty
    string, you can use `NULL` across data types.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL中，`NULL`是一个特殊值，表示没有数据或数据因为没有包含而未知。例如，如果一个人填写地址表单时跳过了“中间名首字母”字段，我们就不会在数据库中存储空字符串，而是使用`NULL`来表示未知值。需要记住的是，`NULL`与`0`或空字符串（你可以使用两个引号（`''`）表示）是不同的。这两者可能有一些意图不明确的含义，容易被误解，因此我们使用`NULL`来表示值是未知的。与`0`或空字符串不同，你可以在不同的数据类型中使用`NULL`。
- en: When a SQL join returns empty rows in one of the tables, those columns don’t
    come back empty but instead come back with the value `NULL`. In [Listing 7-10](#listing7-10),
    we’ll find those rows by adding a `WHERE` clause to filter for `NULL` by using
    the phrase `IS NULL` on the `id` column of the `district_2035` table. If we wanted
    to look for columns *with* data, we’d use `IS NOT NULL`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当SQL连接返回其中一个表的空行时，这些列不会返回为空，而是返回值`NULL`。在[列表7-10](#listing7-10)中，我们将通过添加`WHERE`子句，使用`IS
    NULL`来筛选`district_2035`表的`id`列，以找到那些行。如果我们想查看有数据的列，我们会使用`IS NOT NULL`。
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 7-10: Filtering to show missing values with `IS NULL`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-10：使用`IS NULL`筛选出缺失值
- en: Now the result of the join shows only the one row from the table on the left
    of the join that didn’t have a match in the table on the right. This is commonly
    referred to as an *anti-join*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，连接的结果仅显示左侧表中没有在右侧表中匹配的那一行。这通常被称为*反连接（anti-join）*。
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It’s easy to reverse the output to see rows on the table on the right of the
    join that have no matches with the table on the left. You’d change the query to
    use a `RIGHT JOIN` and modify the `WHERE` clause to filter on `district_2020.id
    IS NULL`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易反转输出，以查看右侧表中与左侧表没有匹配的行。你只需将查询改为使用`RIGHT JOIN`，并修改`WHERE`子句，筛选出`district_2020.id
    IS NULL`。
- en: Understanding the Three Types of Table Relationships
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解三种表关系类型
- en: 'Part of the science (or art, some may say) of joining tables involves understanding
    how the database designer intends for the tables to relate, also known as the
    database’s *relational model*. There are three types of table relationships: one
    to one, one to many, and many to many.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 连接表的一部分科学（或者说艺术，一些人可能会这么说）涉及到理解数据库设计者如何设计表之间的关系，这也被称为数据库的*关系模型*。表关系有三种类型：一对一、一对多和多对多。
- en: One-to-One Relationship
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一对一关系
- en: 'In our `JOIN` example in [Listing 7-4](#listing7-4), there are no duplicate
    `id` values in either table: only one row in the `district_2020` table exists
    with an `id` of `1`, and only one row in the `district_2035` table has an `id`
    of `1`. That means any given `id` in either table will find no more than one match
    in the other table. In database parlance, this is called a *one-to-one* relationship.
    Consider another example: joining two tables with state-by-state census data.
    One table might contain household income data and the other data is about educational
    attainment. Both tables would have 51 rows (one for each state plus Washington,
    D.C.), and if we joined them on a key such as state name, state abbreviation,
    or a standard geography code, we’d have only one match for each key value in each
    table.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们[例子7-4](#listing7-4)中的`JOIN`操作里，两个表中的`id`值没有重复：`district_2020`表中只有一行`id`为`1`，而`district_2035`表中只有一行`id`为`1`。这意味着在任意表中的`id`在另一个表中最多只能找到一个匹配项。在数据库术语中，这称为*一对一*关系。考虑另一个例子：连接两个包含州级人口普查数据的表。一个表可能包含家庭收入数据，另一个表则是关于教育水平的数据。两个表都会有51行（每个州加上华盛顿特区），如果我们根据州名、州缩写或标准地理代码来连接它们，那么每个表中的每个键值只会有一个匹配项。
- en: One-to-Many Relationship
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一对多关系
- en: In a *one-to-many* relationship, a key value in one table will have multiple
    matching values in another table’s joined column. Consider a database that tracks
    automobiles. One table would hold data on manufacturers, with one row each for
    Ford, Honda, Tesla, and so on. A second table with model names, such as Mustang,
    Civic, Model 3, and Accord, would have several rows matching each row in the manufacturers’
    table.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在*一对多*关系中，一个表中的关键值将在另一个表的连接列中有多个匹配值。考虑一个追踪汽车的数据库。一个表会包含制造商数据，每个制造商（例如福特、本田、特斯拉等）占一行。另一个表则包含模型名称，例如野马、思域、Model
    3和雅阁，每个制造商表中的行会与这些行匹配。
- en: Many-to-Many Relationship
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多对多关系
- en: 'A *many-to-many* relationship exists when multiple items in one table can relate
    to multiple items in another table, and vice versa. For example, in a baseball
    league, each player can be assigned to multiple positions, and each position can
    be played by multiple players. Because of this complexity, many-to-many relationships
    usually feature a third, intermediate table in between the two. In the case of
    the baseball league, a database might have a `players` table, a `positions` table,
    and a third called `players_positions` that has two columns that support the many-to-many
    relationship: the `id` from the `players` table and the `id` from the `positions`
    table.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*多对多*关系出现在一个表中的多个项可以与另一个表中的多个项相关联，反之亦然。例如，在一个棒球联赛中，每个球员可以被分配到多个位置，而每个位置也可以由多个球员担任。由于这种复杂性，多对多关系通常会涉及一个第三个中间表。在棒球联赛的例子中，数据库可能会有一个`players`表、一个`positions`表，以及一个第三个表`players_positions`，它有两个列来支持多对多关系：来自`players`表的`id`和来自`positions`表的`id`。'
- en: Understanding these relationships is essential because it helps us discern whether
    the results of queries accurately reflect the structure of the database.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些关系至关重要，因为它帮助我们判断查询结果是否准确反映了数据库的结构。
- en: Selecting Specific Columns in a Join
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在连接中选择特定列
- en: So far, we’ve used the asterisk wildcard to select all columns from both tables.
    That’s okay for quick data checks, but more often you’ll want to specify a subset
    of columns. You can focus on just the data you want and avoid inadvertently changing
    the query results if someone adds a new column to a table.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了星号通配符来选择两个表中的所有列。这对于快速检查数据是可以的，但更常见的情况是你需要指定一个列的子集。你可以专注于你想要的数据，并避免在有人向表中添加新列时不小心改变查询结果。
- en: As you learned in single-table queries, to select particular columns you use
    the `SELECT` keyword followed by the desired column names. When joining tables,
    it’s a best practice to include the table name along with the column. The reason
    is that more than one table can contain columns with the same name, which is certainly
    true of our joined tables so far.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在单表查询中所学到的，选择特定列时，需要使用`SELECT`关键字，后面跟上所需的列名。在连接多个表时，最佳实践是将表名与列名一起写明。原因是，多个表可能包含相同名称的列，这在我们当前的连接表中是完全正确的。
- en: 'Consider the following query, which tries to fetch an `id` column without naming
    the table:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下查询，它尝试在没有指定表名的情况下获取`id`列：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Because `id` exists in both `district_2020` and `district_2035`, the server
    throws an error that appears in pgAdmin’s results pane: `column reference "id"
    is ambiguous`. It’s not clear which table `id` belongs to.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`id`在`district_2020`和`district_2035`中都存在，服务器会抛出一个错误，在pgAdmin的结果面板中显示：`column
    reference "id" is ambiguous`（列引用“id”不明确）。目前无法判断`id`属于哪个表。
- en: To fix the error, we need to add the table name in front of each column we’re
    querying, as we do in the `ON` clause. [Listing 7-11](#listing7-11) shows the
    syntax, specifying that we want the `id` column from `district_2020`. We’re also
    fetching the school names from both tables.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修正错误，我们需要在每个查询的列前面加上表名，正如我们在`ON`子句中所做的那样。[示例 7-11](#listing7-11)展示了语法，指定我们想要从`district_2020`中获取`id`列。我们还从两个表中获取学校名称。
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 7-11: Querying specific columns in a join'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-11：在连接查询中特定列的查询
- en: 'We simply prefix each column name with the table it comes from, and the rest
    of the query syntax is the same. The result returns the requested columns from
    each table:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在每个列名前加上它所在的表名，其余查询语法保持不变。结果会返回来自每个表的请求列：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can also add the `AS` keyword we used previously with census data to make
    it clear in the results that the `id` column is from `district_2020`. The syntax
    would look like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加之前在普查数据中使用过的`AS`关键字，使结果中明确标识`id`列来自`district_2020`。语法如下所示：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This would display the name of the `district_2020 id` column as `d20_id` in
    the results.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`district_2020 id`列的名称将以`d20_id`的形式显示在结果中。
- en: Simplifying JOIN Syntax with Table Aliases
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用表别名简化JOIN语法
- en: Specifying the table for a column is easy enough, but repeating a lengthy table
    name for multiple columns clutters your code. One of the best ways to serve your
    colleagues is to write code that’s readable, which should generally not involve
    making them wade through a table name repeated over 25 columns! One way to write
    more concise code is to use a shorthand approach called *table aliases*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为列指定表名其实不难，但对于多个列重复书写冗长的表名会让你的代码显得杂乱。为同事写可读性强的代码是最好的方式，而这通常不应该让他们在超过25列的代码中重复查找表名！编写更简洁代码的一种方法是使用一种叫做*表别名*的简写方式。
- en: To create a table alias, we place a character or two after the table name when
    we declare it in the `FROM` clause. (You can use more than a couple of characters
    for an alias, but if the goal is to simplify code, don’t go overboard.) Those
    characters then serve as an alias we can use instead of the full table name anywhere
    we reference the table in the code. [Listing 7-12](#listing7-12) demonstrates
    how this works.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 创建表别名时，我们在`FROM`子句中声明表时，表名后加一个或两个字符作为别名。（你可以为别名使用多个字符，但如果目标是简化代码，就不要过多使用。）这些字符将作为别名，我们可以在代码中任何引用表的位置使用它。[示例
    7-12](#listing7-12)展示了这种方式的使用。
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 7-12: Simplifying code with table aliases'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-12：使用表别名简化代码
- en: In the `FROM` clause, we declare the alias `d20` to represent `district_2020`
    and the alias `d35` to represent `district_2035` 1 using the `AS` keyword. Both
    aliases are shorter than the table names but still meaningful. Once that’s in
    place, we can use the aliases instead of the full table names everywhere else
    in the code. Immediately, our SQL looks more compact, and that’s ideal. Note that
    the `AS` keyword is optional here; you can omit it when declaring an alias for
    both table names and column names.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FROM`子句中，我们使用`AS`关键字声明了`district_2020`的别名`d20`，以及`district_2035`的别名`d35`。这两个别名比表名更短，但依然有意义。一旦这样做，我们就可以在代码的其他地方使用别名代替完整的表名。我们的SQL立刻变得更简洁，这是理想的做法。请注意，`AS`关键字在这里是可选的；你可以在声明表名和列名的别名时省略它。
- en: Joining Multiple Tables
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接多个表
- en: 'Of course, SQL joins aren’t limited to two tables. We can continue adding tables
    to the query as long as we have columns with matching values to join on. Let’s
    say we obtain two more school-related tables and want to join them to `district_2020`
    in a three-table join. The `district_2020_enrollment` table has the number of
    students per school:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，SQL 连接不仅限于两个表。只要我们有匹配的列值可以进行连接，我们就可以继续将表添加到查询中。假设我们获得了另外两个与学校相关的表，并且想要在三表连接中将它们与
    `district_2020` 连接。`district_2020_enrollment` 表包含每个学校的学生人数：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `district_2020_grades` table contains the grade levels housed in each building:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`district_2020_grades` 表包含每个楼宇中所在的年级：'
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To write the query, we’ll use [Listing 7-13](#listing7-13) to create the tables,
    load the data, and run a query to join them to `district_2020`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写查询，我们将使用[列表 7-13](#listing7-13)来创建表，加载数据，并运行查询将它们连接到 `district_2020`。
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 7-13: Joining multiple tables'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-13：连接多个表
- en: After we run the `CREATE TABLE` and `INSERT` portions of the script, we have
    new `district_2020_enrollment` and `district_2020_grades` tables, each with records
    that relate to `district_2020` from earlier in the chapter. We then connect all
    three tables.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 `CREATE TABLE` 和 `INSERT` 部分的脚本后，我们得到了新的 `district_2020_enrollment` 和 `district_2020_grades`
    表，每个表都包含与本章前面提到的 `district_2020` 相关的记录。然后，我们将所有三个表连接起来。
- en: In the `SELECT` query, we join `district_2020` to `district_2020_enrollment`
    1 using the tables’ `id` columns. We also declare table aliases to keep the code
    compact. Next, the query joins `district_2020` to `district_2020_grades`, again
    on the `id` columns 2.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SELECT` 查询中，我们通过表的 `id` 列将 `district_2020` 与 `district_2020_enrollment` 连接
    1。我们还声明了表别名，以保持代码简洁。接下来，查询将 `district_2020` 与 `district_2020_grades` 连接，再次使用 `id`
    列 2。
- en: 'Our result now includes columns from all three tables:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果现在包括来自所有三个表的列：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you need to, you can add even more tables to the query using additional joins.
    You can also join on different columns, depending on the tables’ relationships.
    Although there is no hard limit in SQL to the number of tables you can join in
    a single query, some database systems might impose one. Check the documentation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你还可以通过额外的连接将更多表添加到查询中。你也可以根据表之间的关系，在不同的列上进行连接。虽然 SQL 中并没有硬性限制一个查询中可以连接的表数量，但某些数据库系统可能会设置限制。请查阅相关文档。
- en: Combining Query Results with Set Operators
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用集合运算符合并查询结果
- en: 'Certain instances require us to re-order our data so that columns from various
    tables aren’t returned side by side, as a join produces, but brought together
    into one result. Examples include required input formats for JavaScript-based
    data visualizations or analysis with libraries used in the R and Python programming
    languages. One way to manipulate our data this way is to use the ANSI standard
    SQL *set operators* `UNION`, `INTERSECT`, and `EXCEPT`. Set operators combine
    the results of multiple `SELECT` queries. Here’s a quick look at what each does:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 某些情况下，我们需要重新排序数据，以使得来自不同表的列不是像连接那样并排返回，而是聚集在一个结果中。示例包括基于 JavaScript 的数据可视化或使用
    R 和 Python 编程语言库进行分析的输入格式要求。实现这种数据操作的一种方法是使用 ANSI 标准 SQL *集合运算符* `UNION`、`INTERSECT`
    和 `EXCEPT`。集合运算符将多个 `SELECT` 查询的结果合并。下面是每个运算符的简要介绍：
- en: '`UNION` Given two queries, it appends the rows in the results of the second
    query to the rows returned by the first query and removes duplicates, producing
    a combined set of distinct rows. Modifying the syntax to `UNION ALL` will return
    all rows, including duplicates.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UNION` 给定两个查询，它将第二个查询的结果行附加到第一个查询返回的行，并删除重复项，生成一个包含唯一行的组合集合。将语法修改为 `UNION
    ALL` 会返回所有行，包括重复项。'
- en: '`INTERSECT` Returns only rows that exist in the results of both queries and
    removes duplicates.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`INTERSECT` 只返回同时存在于两个查询结果中的行，并删除重复项。'
- en: '`EXCEPT` Returns rows that exist in the results of the first query but not
    in the results of the second query. Duplicates are removed.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EXCEPT` 返回仅存在于第一个查询结果中，但不在第二个查询结果中的行。重复项会被移除。'
- en: For each of these, both queries must produce the same number of columns, and
    the resulting columns from both queries must have compatible data types. Let’s
    continue using our school district tables for brief examples of how they work.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些操作，两个查询必须生成相同数量的列，并且来自两个查询的结果列必须具有兼容的数据类型。让我们继续使用学校区表，简要展示它们的工作原理。
- en: UNION and UNION ALL
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UNION 和 UNION ALL
- en: In [Listing 7-14](#listing7-14), we use `UNION` to combine queries that retrieve
    all rows from both `district_2020` and `district_2035`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 7-14](#listing7-14)中，我们使用 `UNION` 来组合检索 `district_2020` 和 `district_2035`
    中所有行的查询。
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 7-14: Combining query results with `UNION`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-14：使用 `UNION` 合并查询结果
- en: 'The query consists of two complete `SELECT` statements with the `UNION` keyword
    1 placed between them. The `ORDER BY` 2 on the `id` column happens after the set
    operation occurs and thus can’t be listed as part of each `SELECT`. From our work
    with this data already, you know that these queries will return several rows that
    are identical in both tables. But by merging the queries with `UNION`, our results
    eliminate duplicates:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 该查询由两个完整的`SELECT`语句组成，中间用`UNION`关键字1连接。`ORDER BY` 2位于`id`列上，发生在集合操作之后，因此不能作为每个`SELECT`的一部分列出。从我们已经处理的数据来看，你知道这些查询将返回两个表中完全相同的几行。但是通过将查询合并为`UNION`，我们的结果消除了重复项：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice that the names of the schools are in the column `school_2020`, which
    is part of the first query’s results. The school names in the second query’s column
    `school_2035` from the `district_2035` table were simply appended to the results
    from the first query. For that reason, the columns in the second query must match
    those in the first and have compatible data types.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，学校的名称在`school_2020`列中，这是第一个查询结果的一部分。第二个查询中来自`district_2035`表的`school_2035`列的学校名称被简单地附加到第一个查询的结果中。因此，第二个查询中的列必须与第一个查询中的列匹配，并且具有兼容的数据类型。
- en: If we want the results to include duplicate rows, we substitute `UNION ALL`
    for `UNION` in the query, as in [Listing 7-15](#listing7-15).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望结果包含重复行，我们可以在查询中将`UNION`替换为`UNION ALL`，就像在[示例 7-15](#listing7-15)中一样。
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 7-15: Combining query results with `UNION ALL`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-15：使用 `UNION ALL` 合并查询结果
- en: 'That produces all rows, with duplicates included:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生所有行，包含重复项：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally, it’s often helpful to customize merged results. You may want to know,
    for example, which table values in each row came from, or you may want to include
    or exclude certain columns. [Listing 7-16](#listing7-16) shows one example using
    `UNION ALL`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，定制合并结果通常是有帮助的。例如，你可能想知道每一行的表值来自哪里，或者你可能想包含或排除某些列。[示例 7-16](#listing7-16)展示了使用`UNION
    ALL`的一个例子。
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 7-16: Customizing a `UNION` query'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-16：自定义 `UNION` 查询
- en: In the first query’s `SELECT` statement 1, we designate the string `2020` as
    the value to fill a column named `year`. We also do this in the second query using
    `2035` as the string. This is similar to the technique you employed in the section
    “Adding a Value to a Column During Import” in Chapter 5. Then, we rename the `school_2020`
    column 2 as `school` because it will show schools from both years.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个查询的`SELECT`语句1中，我们将字符串`2020`指定为填充名为`year`的列的值。我们在第二个查询中也使用`2035`作为字符串。这个方法与第5章“导入时向列添加值”部分中使用的技术类似。然后，我们将`school_2020`列2重命名为`school`，因为它将显示来自两个年份的学校。
- en: 'Execute the query to see the results:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 执行查询以查看结果：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now our query produces a year designation for each school, and we can see, for
    example, that the row with Dover Middle School comes from the result of querying
    the `district_2020` table.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的查询为每所学校生成一个年份标识，例如，我们可以看到 Dover 中学的那一行来自查询`district_2020`表的结果。
- en: INTERSECT and EXCEPT
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: INTERSECT 和 EXCEPT
- en: Now that you know how to use `UNION`, you can apply the same concepts to `INTERSECT`
    and `EXCEPT`. [Listing 7-17](#listing7-17) shows both, which you can run separately
    to see how the results differ.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何使用`UNION`，你可以将相同的概念应用到`INTERSECT`和`EXCEPT`。[示例 7-17](#listing7-17)展示了两者，你可以分别运行它们以查看结果的差异。
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 7-17: Combining query results with `INTERSECT` and `EXCEPT`'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-17：使用 `INTERSECT` 和 `EXCEPT` 合并查询结果
- en: 'The query using `INTERSECT` 1 returns just the rows that exist in the results
    of both queries and eliminates duplicates:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`INTERSECT` 1的查询仅返回在两个查询结果中都存在的行，并消除重复项：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The query using `EXCEPT` 2 returns rows that exist in the first query but not
    in the second, also eliminating duplicates if present:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`EXCEPT` 2的查询返回在第一个查询中存在但在第二个查询中不存在的行，并消除可能存在的重复项：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Along with `UNION`, queries using `INTERSECT` and `EXCEPT` give you plenty of
    ability to arrange and examine your data.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与`UNION`一起，使用`INTERSECT`和`EXCEPT`的查询为你提供了充足的能力来安排和检查数据。
- en: Finally, let’s return briefly to joins to see how you can perform calculations
    on numbers in different tables.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们简要回到连接，看看如何对不同表中的数字进行计算。
- en: Performing Math on Joined Table Columns
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对连接表列执行数学运算
- en: The math functions we explored in Chapter 6 are just as usable when working
    with joined tables. We need to include the table name when referencing a column
    in an operation, as we did when selecting table columns. If you work with any
    data that has a new release at regular intervals, you’ll find this concept useful
    for joining a newly released table to an older one and exploring how values have
    changed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第6章探讨的数学函数在处理连接后的表格时同样适用。当在操作中引用某个列时，我们需要包括表格名称，就像在选择表格列时一样。如果你处理的是任何定期发布的新数据，你会发现这个概念对于将新发布的表格与旧表格连接并探索数值变化非常有用。
- en: That’s certainly what I and many journalists do each time a new set of census
    data is released. We’ll load the new data and try to find patterns in the growth
    or decline of the population, income, education, and other indicators. Let’s look
    at how to do this by revisiting the `us_counties_pop_est_2019` table we created
    in Chapter 5 and loading similar county data that shows 2010 county population
    estimates into a new table. To make the table, import the data, and join it to
    the 2019 estimates, run the code in [Listing 7-18](#listing7-18).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我和许多记者每次发布新一轮人口普查数据时所做的事情。我们会加载新数据，并试图找出人口、收入、教育和其他指标的增长或下降模式。让我们通过重新访问我们在第5章创建的`us_counties_pop_est_2019`表，并加载显示2010年县级人口估算数据的新表来看看如何操作。为了创建表格，导入数据，并将其与2019年估算数据进行连接，请运行[Listing
    7-18](#listing7-18)中的代码。
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Listing 7-18: Performing math on joined census tables'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-18: 在连接的人口普查表上进行数学运算'
- en: In this code, we’re building on earlier foundations. We have the familiar `CREATE
    TABLE` statement 1, which for this exercise includes state, county, and region
    codes, and we have columns with the names of the states and counties. It also
    includes an `estimates_base_2010` column that has the Census Bureau’s estimated
    2010 population for each county (the Census Bureau modifies its complete, every-10-year
    count to create a base number for comparisons with estimates later in the decade).
    The `COPY` statement 2 imports a CSV file with the census data; you can find *us_counties_pop_est_2010.csv*
    along with all of the book’s resources at [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/).
    After you’ve downloaded the file, you’ll need to change the file path to the location
    where you saved it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们在前面的基础上进行构建。我们有熟悉的`CREATE TABLE`语句1，针对本次练习，它包含州、县和区域代码，并且有列显示州和县的名称。它还包括一个`estimates_base_2010`列，其中包含美国人口普查局为每个县估算的2010年人口（美国人口普查局将其每10年一次的完整人口普查数据进行修改，以创建一个基准数字，用于与后续年度的估算数据进行比较）。`COPY`语句2导入一个包含人口普查数据的CSV文件；你可以在[https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/)找到*us_counties_pop_est_2010.csv*以及本书的所有资源。下载文件后，你需要更改文件路径，以指向你保存该文件的位置。
- en: When you’ve finished the import, you should have a table named `us_counties_pop_est_2010`
    with 3,142 rows. Now that we have tables with population estimates for 2010 and
    2019, it makes sense to calculate the percent change in population for each county
    between those years. Which counties have led the nation in growth? Which ones
    have seen a decline in population?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 完成导入后，你应该会得到一个名为`us_counties_pop_est_2010`的表格，包含3,142行数据。现在我们有了2010年和2019年的人口估算表格，计算每个县在这两年之间的人口百分比变化就显得很有意义了。哪些县在增长方面领先全国？哪些县则出现了人口下降？
- en: We’ll use the percent change formula we used in Chapter 6 to get the answer.
    The `SELECT` statement 3 includes the county and state names from the 2019 table,
    which is aliased with `c2019`. Next are the population estimate columns from the
    2019 and 2010 tables, both renamed using `AS` to simplify their names in the results.
    To get the raw change in population, we subtract the 2010 estimates base from
    the 2019 estimates, and to find the percent change, we employ the formula 4 and
    round the result to one decimal point.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用第6章中使用的百分比变化公式来得出答案。`SELECT`语句3包括来自2019年表格的县名和州名，这些数据被别名为`c2019`。接下来是2019年和2010年表格中的人口估算列，两个列都使用`AS`重命名，以简化结果中的列名。为了得到人口的原始变化，我们从2019年的估算数据中减去2010年的基准估算值，而要计算百分比变化，我们使用公式4，并将结果四舍五入到小数点后一位。
- en: 'We join by matching values in two columns in both tables: `state_fips` and
    `county_fips` 5. The reason to join on two columns instead of one is that in both
    tables, the combination of a state code and a county code represents a unique
    county. We combine the two conditions using the `AND` logical operator. Using
    that syntax, rows are joined when both conditions are satisfied. Finally, we sort
    the results in descending order by percent change 6 so we can see the fastest
    growers at the top.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过匹配两个表中两个列的值来连接：`state_fips` 和 `county_fips` 5。之所以使用两个列而不是一个列进行连接，是因为在这两个表中，州代码和县代码的组合代表了一个唯一的县。我们使用
    `AND` 逻辑运算符将这两个条件组合起来。使用该语法时，只有当两个条件都满足时，行才会被连接。最后，我们按百分比变化6降序排列结果，这样我们就可以看到增长最快的地区排在前面。
- en: 'That’s a lot of work, but it’s worth it. Here’s what the first five rows of
    the results indicate:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要很多工作，但这是值得的。以下是结果的前五行所显示的内容：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Two counties, McKenzie in North Dakota and Loving in Texas, more than doubled
    their populations from 2010 to 2019, with other North Dakota and Texas counties
    showing substantial gains. Each of these places has its own story. For McKenzie
    County and others in North Dakota, a boom in oil and gas exploration in the Bakken
    geological formation is behind the surge. That’s just one valuable insight we’ve
    extracted from this analysis and a starting point for understanding national population
    trends.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 两个县，北达科他州的麦肯齐县和德克萨斯州的洛文县，从2010年到2019年人口增长了两倍以上，其他北达科他州和德克萨斯州的县也显示出显著的增长。这些地方每个都有自己的故事。对于麦肯齐县和北达科他州的其他县，巴肯地质层中的石油和天然气勘探热潮是人口激增的背后原因。这只是我们从这次分析中提取的一个有价值的洞见，也是理解国家人口趋势的起点。
- en: Wrapping Up
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Given that table relationships are foundational to database architecture, learning
    to join tables in queries allows you to handle many of the more complex datasets
    you’ll encounter. Experimenting with the different types of joins on tables can
    tell you a great deal about how data has been gathered and reveal when there’s
    a quality issue. Make trying various joins a routine part of your exploration
    of a new dataset.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于表关系是数据库架构的基础，学习如何在查询中连接表使你能够处理你将遇到的许多更复杂的数据集。在表之间实验不同类型的连接操作可以让你了解数据是如何收集的，并揭示何时存在质量问题。将尝试不同的连接方式作为你探索新数据集的一项常规任务。
- en: 'Moving forward, we’ll continue building on these bigger concepts as we drill
    deeper into finding information in datasets and working with the nuances of handling
    data types and making sure we have quality data. But first, we’ll look at one
    more foundational element: employing best practices to build reliable, speedy
    databases with SQL.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，我们将继续在这些更大的概念基础上深入挖掘，寻找数据集中的信息，并处理数据类型的细节，确保数据的质量。但首先，我们将看看另一个基础元素：采用最佳实践使用SQL构建可靠、高效的数据库。
