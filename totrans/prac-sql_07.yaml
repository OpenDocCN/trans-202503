- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Joining Tables in a Relational Database
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In Chapter 2, I introduced the concept of a *relational database*, an application
    that supports data stored across multiple, related tables. In a relational model,
    each table typically holds data on a single entity—such as students, cars, purchases,
    houses—and each row in the table describes one of those entities. A process known
    as a *table join* allows us to link rows in one table to rows in other tables.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of relational databases came from the British computer scientist
    Edgar F. Codd. While working for IBM in 1970, he published a paper called “A Relational
    Model of Data for Large Shared Data Banks.” His ideas revolutionized database
    design and led to the development of SQL. With the relational model, you can build
    tables that eliminate duplicate data, are easier to maintain, and provide for
    increased flexibility in writing queries to get just the data you want.
  prefs: []
  type: TYPE_NORMAL
- en: Linking Tables Using JOIN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To connect tables in a query, we use a `JOIN ... ON` construct (or one of the
    other `JOIN` variants I’ll cover in this chapter). A `JOIN`, which is part of
    the ANSI SQL standard, links one table to another in the database using a *Boolean*
    value expression in the `ON` clause. A commonly used syntax tests for equality
    and commonly takes this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to the basic `SELECT` you’ve already learned, but instead of
    naming one table in the `FROM` clause, we name a table, give the `JOIN` keyword,
    and then name a second table. The `ON` clause follows, where we place an expression
    using the equals comparison operator. When the query runs, it returns rows from
    both tables where the expression in the `ON` clause evaluates to `true`, meaning
    values in the specified columns are equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use any expression that evaluates to the *Boolean* results `true` or
    `false`. For example, you could match where values from one column are greater
    than or equal to values in the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That’s rare, but it’s an option if your analysis requires it.
  prefs: []
  type: TYPE_NORMAL
- en: Relating Tables with Key Columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider this example of relating tables with key columns: imagine you’re a
    data analyst with the task of checking on a public agency’s payroll spending by
    department. You file a Freedom of Information Act request for that agency’s salary
    data, expecting to receive a simple spreadsheet listing each employee and their
    salary, arranged like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But that’s not what arrives. Instead, the agency sends you a data dump from
    its payroll system: a dozen CSV files, each representing one table in its database.
    You read the document explaining the data layout (be sure to always ask for it!)
    and start to make sense of the columns in each table. Two tables stand out: one
    named `employees` and another named `departments`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the code in [Listing 7-1](#listing7-1), let’s create versions of these
    tables, insert rows, and examine how to join the data in both tables. Using the
    `analysis` database you’ve created for these exercises, run all the code, and
    then look at the data either by using a basic `SELECT` statement or by clicking
    the table name in pgAdmin and selecting **View/Edit Data**▶**All Rows**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-1: Creating the `departments` and `employees` tables'
  prefs: []
  type: TYPE_NORMAL
- en: 'The two tables follow Codd’s relational model in that each describes attributes
    about a single entity: the agency’s departments and employees. In the `departments`
    table, you should see the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dept_id` column is the table’s primary key. A *primary key* is a column
    or collection of columns whose values uniquely identify each row in a table. A
    valid primary key column enforces certain constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: The column or collection of columns must have a unique value for each row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The column or collection of columns can’t have missing values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You define the primary key for `departments` 1 and `employees` 4 using a `CONSTRAINT`
    keyword, which I’ll cover in depth with additional constraint types in Chapter
    8. The values in `dept_id` uniquely identify each row in `departments`, and although
    this example contains only a department name and city, this table would likely
    include additional information, such as an address or contact information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `employees` table should have the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The values in `emp_id` uniquely identify each row in the `employees` table.
    To identify which department each employee works in, the table includes a `dept_id`
    column. The values in this column refer to values in the `departments` table’s
    primary key. We call this a *foreign key*, which you add as a constraint 3 when
    creating the table. A foreign key constraint requires that its values already
    exist in the columns it references. Often, that’s another table’s primary key,
    but it can reference any columns that have unique values for each row. So, values
    in `dept_id` in the `employees` table must exist in `dept_id` in the `departments`
    table; otherwise, you can’t add them. This helps enforce the integrity of the
    data. Unlike a primary key, a foreign key column can be empty, and it can contain
    duplicate values.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the `dept_id` associated with the employee `Julia Reyes` is
    `1`; this refers to the value of `1` in the `departments` table’s primary key,
    `dept_id`. That tells us that `Julia Reyes` is part of the `Tax` department located
    in `Atlanta`.
  prefs: []
  type: TYPE_NORMAL
- en: The `departments` table also includes a `UNIQUE` constraint, which I’ll discuss
    in more depth in “The UNIQUE Constraint” in the next chapter. Briefly, it guarantees
    that values in a column, or a combination of values in more than one column, are
    unique. Here, it requires that each row have a unique pair of values for `dept`
    and `city` 2, which helps avoid duplicate data—the table won’t have two departments
    in Atlanta named `Tax`, for example. Often, you can use such unique combinations
    to create a *natural key* for a primary key, which we’ll also discuss in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might ask: what’s the advantage of breaking data into components like this?
    Well, consider what this sample of data would look like if you had received it
    the way you initially thought you would, all in one table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'First, when you combine data from various entities in one table, inevitably
    you have to repeat information. This happens here: the department name and location
    are spelled out for each employee. This may be acceptable when the table consists
    of four rows like this, or even 4,000\. But when a table holds millions of rows,
    repeating lengthy strings is redundant and wastes precious space.'
  prefs: []
  type: TYPE_NORMAL
- en: Second, cramming all that data into one table makes managing the data difficult.
    What if the Marketing department changes its name to Brand Marketing? Each row
    in the table would require an update, which can introduce errors if someone mistakenly
    updates some but not all the rows. In this model, an update to a department name
    is much simpler—just change one row in a table.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the fact that information is organized, or *normalized*, across several
    tables doesn’t prevent us from viewing it as a whole. We can always query the
    data using `JOIN` to bring columns from tables together.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the basics of how tables can relate, let’s look at how to
    join them in a query.
  prefs: []
  type: TYPE_NORMAL
- en: Querying Multiple Tables Using JOIN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you join tables in a query, the database connects rows in both tables where
    the columns you specified for the join have values that result in the `ON` clause
    expression returning `true`. The query results then include columns from both
    tables if you requested them as part of the query. You also can use columns from
    the joined tables to filter results using a `WHERE` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Queries that join tables are similar in syntax to basic `SELECT` statements.
    The difference is that the query also specifies the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The tables and columns to join, using a SQL `JOIN ... ON` construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of join to perform using variations of the `JOIN` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at the `JOIN ... ON` construct syntax first and then explore various
    types of joins. To join the example `employees` and `departments` tables and see
    all the related data from both, start by writing a query like the one in [Listing
    7-2](#listing7-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-2: Joining the `employees` and `departments` tables'
  prefs: []
  type: TYPE_NORMAL
- en: In the example, you include an asterisk wildcard with the `SELECT` statement
    to include all columns from all tables used in the query 1. Next, in the `FROM`
    clause, you place the `JOIN` keyword 2 between the two tables you want to link.
    Finally, you specify the expression to evaluate using the `ON` clause 3. For each
    table, you provide the table name, a period, and the column that contains the
    key values. An equal sign goes between the two table and column names.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the query, the results include all values from both tables where
    values in the `dept_id` columns match. In fact, even the `dept_id` column appears
    twice because you selected all columns of both tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So, even though the data lives in two tables, each with a focused set of columns,
    you can query those tables to pull the relevant data back together. In “Selecting
    Specific Columns in a Join” later in this chapter, I’ll show you how to retrieve
    only the columns you want from both tables.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding JOIN Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There’s more than one way to join tables in SQL, and the type of join you’ll
    use depends on how you want to retrieve data. The following list describes the
    different types of joins. While reviewing each, it’s helpful to think of two tables
    side by side, one on the left of the `JOIN` keyword and the other on the right.
    A data-driven example of each join follows the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JOIN` Returns rows from both tables where matching values are found in the
    joined columns of both tables. Alternate syntax is `INNER JOIN`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LEFT JOIN` Returns every row from the left table. When SQL finds a row with
    a matching value in the right table, values from that row are included in the
    results. Otherwise, no values from the right table are displayed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RIGHT JOIN` Returns every row from the right table. When SQL finds a row with
    a matching value in the left table, values from that row are included in the results.
    Otherwise, no values from the left table are displayed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`FULL OUTER JOIN` Returns every row from both tables and joins the rows where
    values in the joined columns match. If there’s no match for a value in either
    the left or right table, the query result contains no values for that table.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CROSS JOIN` Returns every possible combination of rows from both tables.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s use data to see these joins in action. Say you have two simple tables
    that hold names of schools for a district that is planning future enrollments:
    `district_2020` and `district_2035`. There are four rows in `district_2020`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There are five rows in `district_2035`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the district expects changes over time. Only schools with an `id`
    of `1`, `2`, and `6` exist in both tables, while others appear in just one of
    them. This scenario is common, and a common first task for a data analyst—especially
    if you have tables with many more rows than these—is to use SQL to identify which
    schools are present in both tables. Using different joins can help you find those
    schools, plus other details.
  prefs: []
  type: TYPE_NORMAL
- en: Again, using your `analysis` database, run the code in [Listing 7-3](#listing7-3)
    to build and populate these two tables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-3: Creating two tables to explore `JOIN` types'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create and fill two tables: the declarations for these should by now look
    familiar, but there’s one new element: we add a primary key to each table. After
    the declaration for the `district_2020` `id` column 1 and the `district_2035`
    `id` column 2, the keywords `CONSTRAINT` `key_name` `PRIMARY KEY` indicate that
    those columns will serve as the primary key for their table. That means for each
    row in both tables, the `id` column must be filled and contain a value that is
    unique for each row in that table. Finally, we use the familiar `INSERT` statements
    3 to add the data to the tables.'
  prefs: []
  type: TYPE_NORMAL
- en: JOIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use `JOIN`, or `INNER` `JOIN`, when we want to return only rows from both
    tables where values match in the columns we used for the join. To see an example
    of this, run the code in [Listing 7-4](#listing7-4), which joins the two tables
    you just made.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-4: Using `JOIN`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the method we used in [Listing 7-2](#listing7-2), we name the two
    tables to join on both sides of the `JOIN` keyword. Then, in the `ON` clause,
    we specify the expression we’re using for the join, in this case equality in the
    `id` columns of both tables. Three school IDs exist in both tables, so the query
    returns only the three rows where those IDs match. Schools that exist in only
    one of the two tables don’t appear in the result. Notice also that the columns
    from the table on the left side of the `JOIN` keyword display on the left of the
    result table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When should you use `JOIN`? Typically, when you’re working with well-structured,
    well-maintained datasets and need to find rows that exist in all the tables you’re
    joining. Because `JOIN` doesn’t provide rows that exist in only one of the tables,
    if you want to see all the data in one or more of the tables, use one of the other
    join types.
  prefs: []
  type: TYPE_NORMAL
- en: JOIN with USING
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re using identical names for columns in a join’s `ON` clause, you can
    reduce redundant output and simplify the query syntax by substituting a `USING`
    clause in place of the `ON` clause, as in [Listing 7-5](#listing7-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-5: `JOIN` with `USING`'
  prefs: []
  type: TYPE_NORMAL
- en: 'After naming the tables to join, we add `USING` 1 followed by, in parentheses,
    the name of the column for the join in both tables—in this case, `id`. If we’re
    joining on more than one column, we separate them by commas in the parentheses.
    Run the query, and you should see these results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that `id`, which in the case of this `JOIN` is present in both tables and
    has identical values, is displayed just once. It’s a simple, handy shorthand.
  prefs: []
  type: TYPE_NORMAL
- en: LEFT JOIN and RIGHT JOIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In contrast to `JOIN`, the `LEFT JOIN` and `RIGHT JOIN` keywords each return
    all rows from one table and, when a row with a matching value in the other table
    exists, values from that row are included in the results. Otherwise, no values
    from the other table are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at `LEFT JOIN` in action first. Execute the code in [Listing 7-6](#listing7-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-6: Using `LEFT JOIN`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the query shows all four rows from `district_2020`, which is
    on the left side of the join, as well as the three rows in `district_2035` where
    values match in the `id` columns. Because `district_2035` doesn’t contain a value
    of `5` in its `id` column, there’s no match, so `LEFT` `JOIN` returns an empty
    row on the right rather than omitting the entire row from the left table as with
    `JOIN`. Finally, the rows from `district_2035` that don’t match any values in
    `district_2020` are omitted from the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We see similar but opposite behavior by running `RIGHT JOIN`, as in [Listing
    7-7](#listing7-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-7: Using `RIGHT JOIN`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, the query returns all rows from `district_2035`, which is on the
    right side of the join, plus rows from `district_2020` where the `id` columns
    have matching values. The query result omits the row of `district_2020` where
    there’s no match with `district_2035` on `id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You’d use either of these join types in a few circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: You want your query results to contain all the rows from one of the tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to look for missing values in one of the tables. An example is when
    you’re comparing data about an entity representing two different time periods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you know some rows in a joined table won’t have matching values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with `JOIN`, you can substitute the `USING` clause for the `ON` clause if
    the tables meet the criteria.
  prefs: []
  type: TYPE_NORMAL
- en: FULL OUTER JOIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you want to see all rows from both tables in a join, regardless of whether
    any match, use the `FULL OUTER JOIN` option. To see it in action, run [Listing
    7-8](#listing7-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-8: Using `FULL OUTER JOIN`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result gives every row from the left table, including matching rows and
    blanks for missing rows from the right table, followed by any leftover missing
    rows from the right table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A full outer join is admittedly less useful and used less often than inner
    and left or right joins. Still, you can use it for a couple of tasks: to link
    two data sources that partially overlap or to visualize the degree to which tables
    share matching values.'
  prefs: []
  type: TYPE_NORMAL
- en: CROSS JOIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a `CROSS JOIN` query, the result (also known as a *Cartesian product*) lines
    up each row in the left table with each row in the right table to present all
    possible combinations of rows. [Listing 7-9](#listing7-9) shows the `CROSS JOIN`
    syntax; because the join doesn’t need to find matches between key columns, there’s
    no need to provide an `ON` clause.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-9: Using `CROSS JOIN`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result has 20 rows—the product of four rows in the left table times five
    rows in the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Unless you want to take an extra-long coffee break, I suggest avoiding a `CROSS
    JOIN` query on large tables. Two tables with 250,000 records each would produce
    a result set of 62.5 *billion* rows and tax even the hardiest server. A more practical
    use would be generating data to create a checklist, such as all colors you’d want
    to offer for each of a handful of shirt styles in a store.
  prefs: []
  type: TYPE_NORMAL
- en: Using NULL to Find Rows with Missing Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any time you join tables, it’s wise to investigate whether the key values in
    one table appear in the other, and which values are missing, if any. Discrepancies
    happen for all sorts of reasons. Some data may have changed over time. For example,
    a table of new products will likely contain codes that aren’t present in an older
    product table. Or there could be problems such as a clerical errors or incomplete
    output from the database. All this is important context for making correct inferences
    about the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have only a handful of rows, eyeballing the data is an easy way to
    look for rows with missing data, as we did in the previous join examples. For
    large tables, you need a better strategy: filtering to show all rows without a
    match. To do this, we employ the keyword `NULL`.'
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, `NULL` is a special value that represents a condition in which there’s
    no data present or where the data is unknown because it wasn’t included. For example,
    if a person filling out an address form skips the “Middle Initial” field, rather
    than storing an empty string in the database, we’d use `NULL` to represent the
    unknown value. It’s important to keep in mind that `NULL` is different from `0`
    or an empty string that you’d place in a text column using two quotes (`''`).
    Both those values could have some unintended meaning that’s open to misinterpretation,
    so you use `NULL` to show that the value is unknown. And unlike `0` or an empty
    string, you can use `NULL` across data types.
  prefs: []
  type: TYPE_NORMAL
- en: When a SQL join returns empty rows in one of the tables, those columns don’t
    come back empty but instead come back with the value `NULL`. In [Listing 7-10](#listing7-10),
    we’ll find those rows by adding a `WHERE` clause to filter for `NULL` by using
    the phrase `IS NULL` on the `id` column of the `district_2035` table. If we wanted
    to look for columns *with* data, we’d use `IS NOT NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-10: Filtering to show missing values with `IS NULL`'
  prefs: []
  type: TYPE_NORMAL
- en: Now the result of the join shows only the one row from the table on the left
    of the join that didn’t have a match in the table on the right. This is commonly
    referred to as an *anti-join*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It’s easy to reverse the output to see rows on the table on the right of the
    join that have no matches with the table on the left. You’d change the query to
    use a `RIGHT JOIN` and modify the `WHERE` clause to filter on `district_2020.id
    IS NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Three Types of Table Relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Part of the science (or art, some may say) of joining tables involves understanding
    how the database designer intends for the tables to relate, also known as the
    database’s *relational model*. There are three types of table relationships: one
    to one, one to many, and many to many.'
  prefs: []
  type: TYPE_NORMAL
- en: One-to-One Relationship
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our `JOIN` example in [Listing 7-4](#listing7-4), there are no duplicate
    `id` values in either table: only one row in the `district_2020` table exists
    with an `id` of `1`, and only one row in the `district_2035` table has an `id`
    of `1`. That means any given `id` in either table will find no more than one match
    in the other table. In database parlance, this is called a *one-to-one* relationship.
    Consider another example: joining two tables with state-by-state census data.
    One table might contain household income data and the other data is about educational
    attainment. Both tables would have 51 rows (one for each state plus Washington,
    D.C.), and if we joined them on a key such as state name, state abbreviation,
    or a standard geography code, we’d have only one match for each key value in each
    table.'
  prefs: []
  type: TYPE_NORMAL
- en: One-to-Many Relationship
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a *one-to-many* relationship, a key value in one table will have multiple
    matching values in another table’s joined column. Consider a database that tracks
    automobiles. One table would hold data on manufacturers, with one row each for
    Ford, Honda, Tesla, and so on. A second table with model names, such as Mustang,
    Civic, Model 3, and Accord, would have several rows matching each row in the manufacturers’
    table.
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-Many Relationship
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *many-to-many* relationship exists when multiple items in one table can relate
    to multiple items in another table, and vice versa. For example, in a baseball
    league, each player can be assigned to multiple positions, and each position can
    be played by multiple players. Because of this complexity, many-to-many relationships
    usually feature a third, intermediate table in between the two. In the case of
    the baseball league, a database might have a `players` table, a `positions` table,
    and a third called `players_positions` that has two columns that support the many-to-many
    relationship: the `id` from the `players` table and the `id` from the `positions`
    table.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding these relationships is essential because it helps us discern whether
    the results of queries accurately reflect the structure of the database.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting Specific Columns in a Join
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve used the asterisk wildcard to select all columns from both tables.
    That’s okay for quick data checks, but more often you’ll want to specify a subset
    of columns. You can focus on just the data you want and avoid inadvertently changing
    the query results if someone adds a new column to a table.
  prefs: []
  type: TYPE_NORMAL
- en: As you learned in single-table queries, to select particular columns you use
    the `SELECT` keyword followed by the desired column names. When joining tables,
    it’s a best practice to include the table name along with the column. The reason
    is that more than one table can contain columns with the same name, which is certainly
    true of our joined tables so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following query, which tries to fetch an `id` column without naming
    the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `id` exists in both `district_2020` and `district_2035`, the server
    throws an error that appears in pgAdmin’s results pane: `column reference "id"
    is ambiguous`. It’s not clear which table `id` belongs to.'
  prefs: []
  type: TYPE_NORMAL
- en: To fix the error, we need to add the table name in front of each column we’re
    querying, as we do in the `ON` clause. [Listing 7-11](#listing7-11) shows the
    syntax, specifying that we want the `id` column from `district_2020`. We’re also
    fetching the school names from both tables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-11: Querying specific columns in a join'
  prefs: []
  type: TYPE_NORMAL
- en: 'We simply prefix each column name with the table it comes from, and the rest
    of the query syntax is the same. The result returns the requested columns from
    each table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add the `AS` keyword we used previously with census data to make
    it clear in the results that the `id` column is from `district_2020`. The syntax
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This would display the name of the `district_2020 id` column as `d20_id` in
    the results.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying JOIN Syntax with Table Aliases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Specifying the table for a column is easy enough, but repeating a lengthy table
    name for multiple columns clutters your code. One of the best ways to serve your
    colleagues is to write code that’s readable, which should generally not involve
    making them wade through a table name repeated over 25 columns! One way to write
    more concise code is to use a shorthand approach called *table aliases*.
  prefs: []
  type: TYPE_NORMAL
- en: To create a table alias, we place a character or two after the table name when
    we declare it in the `FROM` clause. (You can use more than a couple of characters
    for an alias, but if the goal is to simplify code, don’t go overboard.) Those
    characters then serve as an alias we can use instead of the full table name anywhere
    we reference the table in the code. [Listing 7-12](#listing7-12) demonstrates
    how this works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-12: Simplifying code with table aliases'
  prefs: []
  type: TYPE_NORMAL
- en: In the `FROM` clause, we declare the alias `d20` to represent `district_2020`
    and the alias `d35` to represent `district_2035` 1 using the `AS` keyword. Both
    aliases are shorter than the table names but still meaningful. Once that’s in
    place, we can use the aliases instead of the full table names everywhere else
    in the code. Immediately, our SQL looks more compact, and that’s ideal. Note that
    the `AS` keyword is optional here; you can omit it when declaring an alias for
    both table names and column names.
  prefs: []
  type: TYPE_NORMAL
- en: Joining Multiple Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Of course, SQL joins aren’t limited to two tables. We can continue adding tables
    to the query as long as we have columns with matching values to join on. Let’s
    say we obtain two more school-related tables and want to join them to `district_2020`
    in a three-table join. The `district_2020_enrollment` table has the number of
    students per school:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `district_2020_grades` table contains the grade levels housed in each building:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To write the query, we’ll use [Listing 7-13](#listing7-13) to create the tables,
    load the data, and run a query to join them to `district_2020`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-13: Joining multiple tables'
  prefs: []
  type: TYPE_NORMAL
- en: After we run the `CREATE TABLE` and `INSERT` portions of the script, we have
    new `district_2020_enrollment` and `district_2020_grades` tables, each with records
    that relate to `district_2020` from earlier in the chapter. We then connect all
    three tables.
  prefs: []
  type: TYPE_NORMAL
- en: In the `SELECT` query, we join `district_2020` to `district_2020_enrollment`
    1 using the tables’ `id` columns. We also declare table aliases to keep the code
    compact. Next, the query joins `district_2020` to `district_2020_grades`, again
    on the `id` columns 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our result now includes columns from all three tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you need to, you can add even more tables to the query using additional joins.
    You can also join on different columns, depending on the tables’ relationships.
    Although there is no hard limit in SQL to the number of tables you can join in
    a single query, some database systems might impose one. Check the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Query Results with Set Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Certain instances require us to re-order our data so that columns from various
    tables aren’t returned side by side, as a join produces, but brought together
    into one result. Examples include required input formats for JavaScript-based
    data visualizations or analysis with libraries used in the R and Python programming
    languages. One way to manipulate our data this way is to use the ANSI standard
    SQL *set operators* `UNION`, `INTERSECT`, and `EXCEPT`. Set operators combine
    the results of multiple `SELECT` queries. Here’s a quick look at what each does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UNION` Given two queries, it appends the rows in the results of the second
    query to the rows returned by the first query and removes duplicates, producing
    a combined set of distinct rows. Modifying the syntax to `UNION ALL` will return
    all rows, including duplicates.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`INTERSECT` Returns only rows that exist in the results of both queries and
    removes duplicates.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`EXCEPT` Returns rows that exist in the results of the first query but not
    in the results of the second query. Duplicates are removed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each of these, both queries must produce the same number of columns, and
    the resulting columns from both queries must have compatible data types. Let’s
    continue using our school district tables for brief examples of how they work.
  prefs: []
  type: TYPE_NORMAL
- en: UNION and UNION ALL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Listing 7-14](#listing7-14), we use `UNION` to combine queries that retrieve
    all rows from both `district_2020` and `district_2035`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-14: Combining query results with `UNION`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The query consists of two complete `SELECT` statements with the `UNION` keyword
    1 placed between them. The `ORDER BY` 2 on the `id` column happens after the set
    operation occurs and thus can’t be listed as part of each `SELECT`. From our work
    with this data already, you know that these queries will return several rows that
    are identical in both tables. But by merging the queries with `UNION`, our results
    eliminate duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the names of the schools are in the column `school_2020`, which
    is part of the first query’s results. The school names in the second query’s column
    `school_2035` from the `district_2035` table were simply appended to the results
    from the first query. For that reason, the columns in the second query must match
    those in the first and have compatible data types.
  prefs: []
  type: TYPE_NORMAL
- en: If we want the results to include duplicate rows, we substitute `UNION ALL`
    for `UNION` in the query, as in [Listing 7-15](#listing7-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-15: Combining query results with `UNION ALL`'
  prefs: []
  type: TYPE_NORMAL
- en: 'That produces all rows, with duplicates included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Finally, it’s often helpful to customize merged results. You may want to know,
    for example, which table values in each row came from, or you may want to include
    or exclude certain columns. [Listing 7-16](#listing7-16) shows one example using
    `UNION ALL`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-16: Customizing a `UNION` query'
  prefs: []
  type: TYPE_NORMAL
- en: In the first query’s `SELECT` statement 1, we designate the string `2020` as
    the value to fill a column named `year`. We also do this in the second query using
    `2035` as the string. This is similar to the technique you employed in the section
    “Adding a Value to a Column During Import” in Chapter 5. Then, we rename the `school_2020`
    column 2 as `school` because it will show schools from both years.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the query to see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now our query produces a year designation for each school, and we can see, for
    example, that the row with Dover Middle School comes from the result of querying
    the `district_2020` table.
  prefs: []
  type: TYPE_NORMAL
- en: INTERSECT and EXCEPT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you know how to use `UNION`, you can apply the same concepts to `INTERSECT`
    and `EXCEPT`. [Listing 7-17](#listing7-17) shows both, which you can run separately
    to see how the results differ.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-17: Combining query results with `INTERSECT` and `EXCEPT`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The query using `INTERSECT` 1 returns just the rows that exist in the results
    of both queries and eliminates duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The query using `EXCEPT` 2 returns rows that exist in the first query but not
    in the second, also eliminating duplicates if present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Along with `UNION`, queries using `INTERSECT` and `EXCEPT` give you plenty of
    ability to arrange and examine your data.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s return briefly to joins to see how you can perform calculations
    on numbers in different tables.
  prefs: []
  type: TYPE_NORMAL
- en: Performing Math on Joined Table Columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The math functions we explored in Chapter 6 are just as usable when working
    with joined tables. We need to include the table name when referencing a column
    in an operation, as we did when selecting table columns. If you work with any
    data that has a new release at regular intervals, you’ll find this concept useful
    for joining a newly released table to an older one and exploring how values have
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: That’s certainly what I and many journalists do each time a new set of census
    data is released. We’ll load the new data and try to find patterns in the growth
    or decline of the population, income, education, and other indicators. Let’s look
    at how to do this by revisiting the `us_counties_pop_est_2019` table we created
    in Chapter 5 and loading similar county data that shows 2010 county population
    estimates into a new table. To make the table, import the data, and join it to
    the 2019 estimates, run the code in [Listing 7-18](#listing7-18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-18: Performing math on joined census tables'
  prefs: []
  type: TYPE_NORMAL
- en: In this code, we’re building on earlier foundations. We have the familiar `CREATE
    TABLE` statement 1, which for this exercise includes state, county, and region
    codes, and we have columns with the names of the states and counties. It also
    includes an `estimates_base_2010` column that has the Census Bureau’s estimated
    2010 population for each county (the Census Bureau modifies its complete, every-10-year
    count to create a base number for comparisons with estimates later in the decade).
    The `COPY` statement 2 imports a CSV file with the census data; you can find *us_counties_pop_est_2010.csv*
    along with all of the book’s resources at [https://nostarch.com/practical-sql-2nd-edition/](https://nostarch.com/practical-sql-2nd-edition/).
    After you’ve downloaded the file, you’ll need to change the file path to the location
    where you saved it.
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve finished the import, you should have a table named `us_counties_pop_est_2010`
    with 3,142 rows. Now that we have tables with population estimates for 2010 and
    2019, it makes sense to calculate the percent change in population for each county
    between those years. Which counties have led the nation in growth? Which ones
    have seen a decline in population?
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the percent change formula we used in Chapter 6 to get the answer.
    The `SELECT` statement 3 includes the county and state names from the 2019 table,
    which is aliased with `c2019`. Next are the population estimate columns from the
    2019 and 2010 tables, both renamed using `AS` to simplify their names in the results.
    To get the raw change in population, we subtract the 2010 estimates base from
    the 2019 estimates, and to find the percent change, we employ the formula 4 and
    round the result to one decimal point.
  prefs: []
  type: TYPE_NORMAL
- en: 'We join by matching values in two columns in both tables: `state_fips` and
    `county_fips` 5. The reason to join on two columns instead of one is that in both
    tables, the combination of a state code and a county code represents a unique
    county. We combine the two conditions using the `AND` logical operator. Using
    that syntax, rows are joined when both conditions are satisfied. Finally, we sort
    the results in descending order by percent change 6 so we can see the fastest
    growers at the top.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s a lot of work, but it’s worth it. Here’s what the first five rows of
    the results indicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Two counties, McKenzie in North Dakota and Loving in Texas, more than doubled
    their populations from 2010 to 2019, with other North Dakota and Texas counties
    showing substantial gains. Each of these places has its own story. For McKenzie
    County and others in North Dakota, a boom in oil and gas exploration in the Bakken
    geological formation is behind the surge. That’s just one valuable insight we’ve
    extracted from this analysis and a starting point for understanding national population
    trends.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given that table relationships are foundational to database architecture, learning
    to join tables in queries allows you to handle many of the more complex datasets
    you’ll encounter. Experimenting with the different types of joins on tables can
    tell you a great deal about how data has been gathered and reveal when there’s
    a quality issue. Make trying various joins a routine part of your exploration
    of a new dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving forward, we’ll continue building on these bigger concepts as we drill
    deeper into finding information in datasets and working with the nuances of handling
    data types and making sure we have quality data. But first, we’ll look at one
    more foundational element: employing best practices to build reliable, speedy
    databases with SQL.'
  prefs: []
  type: TYPE_NORMAL
