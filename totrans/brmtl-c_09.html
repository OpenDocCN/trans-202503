<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="117" id="Page_117"/>8</span><br/>
<span class="ChapterTitle">Complex Data Types</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">In this chapter, we’ll move beyond arrays and simple types to create more complex data types. We’ll start with a simple <code>enum</code> that defines a named list of items. Then we’ll look at structures and unions, which hold values of different types, accessed by name (unlike arrays, which contain values of a single type accessed by number or index). To make a custom data type, we’ll combine enums, structures, and unions. In addition, we’ll explore how structures are used in embedded programming. Finally, we’ll take a look at <code>typedef</code>, which allows us to define our own data type from existing types.</p>
<h2 id="h1-501621c08-0001"><span epub:type="pagebreak" title="118" id="Page_118"/>Enums</h2>
<p class="BodyFirst">An <em>enumerated type</em>, or <code>enum</code>, is a data type that allows us to define a named list of items. For example, if we want to store a limited set of colors in a variable, we could enter the following:</p>
<pre><code>const uint8_t COLOR_RED = 0;
const uint8_t COLOR_BLUE = 1;
const uint8_t COLOR_GREEN = 2;

#define colorType uint8_t;

colorType colorIWant = COLOR_RED</code></pre>
<p>Although this will work, we would still need to keep track of the various colors. Fortunately, C will do that for us if we use an <code>enum</code>:</p>
<pre><code>enum colorType {
    COLOR_RED,
    COLOR_BLUE,
    COLOR_GREEN
};

enum colorType colorIWant = COLOR_RED;</code></pre>
<p>With <code>enum</code>, C does the bookkeeping for us. If we have only three colors, that’s not much of a problem. However, the X Window System has more than 750 named colors. Keeping track of all those numbers is a nontrivial process.</p>
<p>C tends to be a bit loose when it comes to types. Internally, C assigns <code>COLOR_RED</code>, <code>COLOR_BLUE</code>, and <code>COLOR_GREEN</code> the integer values of 0, 1, and 2, respectively. We normally don’t care about that, but sometimes this assignment surfaces. For example, this:</p>
<pre><code>enum colorType fgColor = COLOR_GREEN;
printf("The foreground color is %d\n", fgColor);</code></pre>
<p class="BodyContinued">will print the following:</p>
<pre><code>The foreground color is 2</code></pre>
<p>Also, C does not type-check <code>enum</code> assignments. For example, the following statement will not generate an error or warning:</p>
<pre><code>colorIWant = 33;</code></pre>
<p>Our <code>enum</code> defines three colors, so the legal numbers for colors are 0, 1, and 2—not 33. This can be a problem.</p>
<p>Suppose we write a function to print the color stored in <code>colorIWant</code>. What will users think when they see the following output?</p>
<pre><code>Your box color is 33.</code></pre>
<p><span epub:type="pagebreak" title="119" id="Page_119"/>Printing an incorrect answer like this gives the user a good indication that your program is broken. You can give a better one if you use the <code>enum</code> value to index an array. Here’s an example:</p>
<pre><code>static const char* const colorNames = {"Red", "Blue", "Green"};
<em>--snip--</em>
printf("Your box color is %s\n", colorNames[colorIWant]);</code></pre>
<p>Now if <code>colorIWant</code> is 33, the program will print:</p>
<pre><code>Your box color is @ @@@�HH   pp�-�=�=�px�-�=�=�888 XXXDDS�td888 P�td</code></pre>
<p>Your results may vary, depending on what data there is in element 33 of a three-element array.</p>
<h2 id="h1-501621c08-0002">Preprocessor Tricks and Enums</h2>
<p class="BodyFirst">In this section, you’ll learn how to use some advanced preprocessor directives to make dealing with enums a little easier. First, I want to say that 999 times out of 1,000, using a clever trick will cause more trouble than it’s worth. Simple and clear is almost always better than complex and clever. This situation is one of the few exceptions.</p>
<p>Let’s take a look at some code that defines colors and the names of colors.</p>
<pre><code>// WARNING: Do not change this without changing colorNames.
enum colorType {
    COLOR_RED,
    COLOR_BLUE,
    COLOR_GREEN
};

// WARNING: Do not change this without changing colorType.
static const char* const colorNames = {
    "COLOR_RED", "COLOR_BLUE", "COLOR_GREEN"};</code></pre>
<p>This example has two items that depend on each other: <code>colorType</code> and <code>colorNames</code>. The programmer who wrote it was nice enough to put in a comment indicating that those two items are linked, and the two items are actually defined next to each other. (Sometimes two items that depend on each other can be in different files without comments indicating the linkage.)</p>
<p>As programmers, we want our code to be as simple as possible. Having two different items that must be updated simultaneously is not ideal. We can solve this problem through the clever use of the preprocessor:</p>
<pre><code>// This is the beginning of a clever trick to define both the values and
// the names for the enum colorType. The list below will be used twice,
// once to generate the value and once to generate the names.

#define COLOR_LIST                      \
<span epub:type="pagebreak" title="120" id="Page_120"/>        DEFINE_ITEM(COLOR_RED),         \
        DEFINE_ITEM(COLOR_BLUE),        \
        DEFINE_ITEM(COLOR_GREEN)

// Define DEFINE_ITEM so it generates the actual values for the enum.
#define DEFINE_ITEM(X) X
enum colorType {
   COLOR_LIST
};
#undef DEFINE_ITEM

// Define DEFINE_ITEM so it generates the names for the enum.
#define DEFINE_ITEM(X) #X
static const char* colorNames[] = {
   COLOR_LIST
};
#undef DEFINE_ITEM</code></pre>
<p>Let’s start with the first definition:</p>
<pre><code>#define COLOR_LIST                      \
        DEFINE_ITEM(COLOR_RED),         \
        DEFINE_ITEM(COLOR_BLUE),        \
        DEFINE_ITEM(COLOR_GREEN)</code></pre>
<p>The backslash (<code>\</code>) tells the C preprocessor that the line is continued. We’ve put them all in the same column, so it’s obvious if we accidentally omit one.</p>
<p>Now everywhere we use <code>COLOR_LIST</code>, the C preprocessor will turn it into the following:</p>
<pre><code>DEFINE_ITEM(COLOR_RED), DEFINE_ITEM(COLOR_BLUE), DEFINE_ITEM(COLOR_GREEN)</code></pre>
<p>When we define the <code>enum</code>, we need our list to be the following:</p>
<pre><code>COLOR_RED, COLOR_BLUE, COLOR_GREEN</code></pre>
<p>We get this by defining <code>DEFINE_ITEM</code> to output only the item name:</p>
<pre><code>#define DEFINE_ITEM(X) X</code></pre>
<p>This means that the following code:</p>
<pre><code>enum colorType {
   COLOR_LIST
};</code></pre>
<p class="BodyContinued">gets turned into this:</p>
<pre><code>enum colorType {
    COLOR_RED, COLOR_BLUE, COLOR_GREEN
};</code></pre>
<p><span epub:type="pagebreak" title="121" id="Page_121"/>Now we erase the definition of <code>DEFINE_ITEM</code> since we don’t need it anymore for the <code>enum</code> definition:</p>
<pre><code>#undef DEFINE_ITEM</code></pre>
<p>Next, we define the <code>colorNames</code> list by redefining the <code>DEFINE_ITEM</code> macro:</p>
<pre><code>#define DEFINE_ITEM(X) #X</code></pre>
<p>The hash mark (<code>#</code>) tells the preprocessor to change the token that follows into a string, so now <code>COLOR_LIST</code> will expand into the following:</p>
<pre><code>"COLOR_RED","COLOR_BLUE","COLOR_GREEN"</code></pre>
<p>Here is the full definition for <code>colorNames</code>:</p>
<pre><code>#define DEFINE_ITEM(X) #X
static const char* colorNames[] = {
   COLOR_LIST
};
#undef DEFINE_ITEM</code></pre>
<p>The comments are a vital part of this definition. Any time you use a cute trick like this, document it well so that the poor person maintaining this code has some idea of what you did.</p>
<h2 id="h1-501621c08-0003">Structures</h2>
<p class="BodyFirst">The C <em>structure </em>(<code>struct</code>) allows us to group together multiple items of different types. The items, called <em>fields</em>, are identified by name. It’s different from an array that defines a data structure containing items of the same type, and the items, called <em>elements</em>, are indexed by number. For example, consider this structure that groups together information describing a house:</p>
<pre><code>struct house {
    uint8_t stories;        // Number of stories in the house
    uint8_t bedrooms;       // Number of bedrooms
    uint32_t squareFeet;    // Size of the house
};</code></pre>
<p>To access an element of a structure, use the format <var>variable.field</var>, with a dot in the middle. For example:</p>
<pre><code>struct house myHouse;
--snip--
myHouse.stories = 2;
myHouse.bedrooms = 4;
myHouse.squareFeet = 5000;</code></pre>
<p><span epub:type="pagebreak" title="122" id="Page_122"/>The following program shows how to put this all together:</p>
<p class="CodeLabel"><b>struct.c</b></p>
<pre><code>/**
 * Demonstrate the use of a structure.
 */

#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

struct house {
    uint8_t stories;        // Number of stories in the house
    uint8_t bedrooms;       // Number of bedrooms
    uint32_t squareFeet;    // Size of the house
};

int main() {
    struct house myHouse;   // The house for this demo

    myHouse.stories = 2;
    myHouse.bedrooms = 4;
    myHouse.squareFeet = 5000;
    printf("House -- Stories: %d Bedrooms %d Square Feet %d\n",
        myHouse.stories, myHouse.bedrooms, myHouse.squareFeet);
    printf("Size of the structure %ld\n", sizeof(myHouse));
    return (0);
}</code></pre>
<p>Let’s debug this program in the STM32 Workbench (see <a href="#figure8-1" id="figureanchor8-1">Figure 8-1</a>).</p>
<figure>
<img src="image_fi/501621c08/f08001.png" alt="f08001" class=""/>
<figcaption><p><a id="figure8-1">Figure 8-1</a>: The <span class="LiteralInCaption"><code>struct</code></span> variable display</p></figcaption>
</figure>
<p>Stopping on line 20, we can now see the structure in the variable list. Clicking the + icon expands the structure to show what’s in it.</p>
<h3 id="h2-501621c08-0001">Structures in Memory</h3>
<p class="BodyFirst">Let’s take a look at how the C compiler will lay out this structure in memory. The compiler needs to allocate 1 byte for <code>stories</code> (<code>uint8_t</code>), 1 byte for <code>bedrooms</code> (<code>uint8_t</code>), and 4 bytes for <code>squareFeet</code> (<code>uint32_t</code>). Logically, the layout should look like <a href="#table8-1" id="tableanchor8-1">Table 8-1</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table8-1">Table 8-1</a>: Structure Layout<span epub:type="pagebreak" title="123" id="Page_123"/></p></figcaption>
<table id="table-501621c08-0001" border="1">
<thead>
<tr>
<td><b>Offset</b></td>
<td><b>Type</b></td>
<td><b>Field</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>uint8_t</code></td>
<td><code>stories</code></td>
</tr>
<tr>
<td>1</td>
<td><code>uint8_t</code></td>
<td><code>bedrooms</code></td>
</tr>
<tr>
<td>2</td>
<td><code>uint32_t</code></td>
<td rowspan="4" class="shaded middle"><code>squareFeet</code></td>
</tr>
<tr>
<td>3</td>
<td/>
</tr>
<tr>
<td>4</td>
<td/>
</tr>
<tr>
<td>5</td>
<td/>
</tr>
</tbody>
</table>
</figure>
<p>From <a href="#table8-1">Table 8-1</a>, we see that the structure takes up 6 bytes. However, when we run the program, we see the following output:</p>
<pre><code>Size of the structure 8</code></pre>
<p>Where did the other 2 bytes come from?</p>
<p>The problem is memory design. On the ARM chip (and many others), memory is organized as a series of 32-bit integers aligned on a 4-byte boundary, like so:</p>
<table id="tabular-501621c08-0002" border="1" class="blank"><tbody>
<tr>
<td><code>0x10000</code></td>
<td>32 bits</td>
</tr>
<tr>
<td><code>0x10004</code></td>
<td>32 bits</td>
</tr>
<tr>
<td><code>0x10008</code></td>
<td>32 bits</td>
</tr>
</tbody>
<tbody>
<tr>
<td><code>. . .</code></td>
<td/>
</tr>
</tbody>
</table>
<p>Let’s say we want an 8-bit byte at <code>0x10001</code>. The machine fetches 32 bits from <code>0x10000</code> and then throws away 24 bits, which is wasteful because extra data is fetched, although there is no performance hit.</p>
<p>Now let’s say we need a 32-bit integer starting at <code>0x10002</code>. Attempting to fetch this data directly results in an alignment exception that will abort our program. The computer has to do the following:</p>
<ol class="decimal">
<li value="1">Fetch 16 bits from <code>0x10000</code>.</li>
<li value="2">Fetch 16 bits from <code>0x10004</code>.</li>
<li value="3">Combine them.</li>
</ol>
<p>The internal ARM circuitry does <em>not</em> complete these steps. Instead, the compiler must generate multiple instructions to do the work, which isn’t good for performance. (We go into this in more detail later in the chapter.)</p>
<p>It would be much nicer if <code>squareFeet</code> aligned on a 4-byte boundary instead of a 2-byte boundary, so the compiler optimizes the layout of the structure by adding 2 bytes of padding. This makes the structure larger but much easier to deal with. <a href="#table8-2" id="tableanchor8-2">Table 8-2</a> shows the structure’s actual adjusted layout.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table8-2">Table 8-2</a>: Padded Structure Layout<span epub:type="pagebreak" title="124" id="Page_124"/></p></figcaption>
<table id="table-501621c08-0003" border="1">
<thead>
<tr>
<td><b>Offset</b></td>
<td><b>Type</b></td>
<td><b>Field</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td><code>uint8_t</code></td>
<td><code>stories</code></td>
</tr>
<tr>
<td>1</td>
<td><code>uint8_t</code></td>
<td><code>bedrooms</code></td>
</tr>
<tr>
<td>2</td>
<td><code>uint8_t</code></td>
<td>(padding)</td>
</tr>
<tr>
<td>3</td>
<td><code>uint8_t</code></td>
<td>(padding)</td>
</tr>
<tr>
<td>4</td>
<td><code>uint32_t</code></td>
<td rowspan="4" class="shaded middle"><code>squareFeet</code></td>
</tr>
<tr>
<td>5</td>
<td/>
</tr>
<tr>
<td>6</td>
<td/>
</tr>
<tr>
<td>7</td>
<td/>
</tr>
</tbody>
</table>
</figure>
<p>This extra padding is sometimes a problem. For example, if you have a lot of houses and very limited memory, the padding in each house structure adds up to a lot of wasted space.</p>
<p>Another example is in embedded programming. I had an old, pre-iPod music device called the Rio that didn’t come with Linux tools to load the music onto the device, so I wrote some tools myself. Every data block had a header that looked something like this:</p>
<pre><code>struct dataBlockHeader {
    uint32_t nextBlock;      // Number of the next block in this song
    uint16_t timeStamp;      // Time in seconds of this section of the song
    uint32_t previousBlock;  // Number of the previous block in the song
};</code></pre>
<p>When I first loaded songs on my Rio, they would play fine. But when I pressed Rewind to back up a few seconds, the device would go crazy and start the song all over again. The problem was that GCC was adding padding to the structure:</p>
<pre><code>struct dataBlockHeader {
    uint32_t nextBlock;      // Number of the next block in this song
    uint16_t timeStamp;      // Time in seconds of this section of the song
    <b>uint16_t padding;        // Automatically added</b>
    uint32_t previousBlock;  // Number of the previous block in the song
};</code></pre>
<p>As a result, what the Rio thought was the previous block was instead some padding and half the value of the previous block. No wonder the device became confused.</p>
<p>The solution was to tell the compiler not to add padding with the <code>packed</code> attribute:</p>
<pre><code>struct dataBlockHeader {
    uint32_t nextBlock;      // Number of the next block in this song
    uint16_t timeStamp;      // Time in seconds of this section of the song
<span epub:type="pagebreak" title="125" id="Page_125"/>    uint32_t previousBlock;  // Number of the previous block in the song
}  <b>__attribute__((packed));</b></code></pre>
<p>In this example, <code>__attribute__((packed))</code> is a GNU extension to the C language, and it may not work on other compilers.</p>
<h3 id="h2-501621c08-0002">Accessing Unaligned Data</h3>
<p class="BodyFirst">By default, the compiler will “adjust” the alignment of elements of a structure for efficient memory access. As we’ve seen, hardware designers sometimes have different ideas, and in order to get the structure to match the hardware, we have to include the <code>__attribute__((packed))</code> directive.</p>
<p>To see why the compiler makes such adjustments, let’s write a program that does both aligned and unaligned 32-bit accesses. The packed structure is more compact, but it requires more code to access the 32-bit value. The unpacked structure is efficient to access, but it takes up more memory.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Every time I’ve had to use the <code>__attribute__((packed))</code> directive, it was to make a structure compatible with the hardware I was given—hardware designed by other engineers who didn’t know about the alignment issues they were causing.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The following program shows how both the packed and unpacked structures are accessed:</p>
<pre><code>/*
 * A demonstration of packed and unpacked.
 * This program does nothing useful except
 * generate an assembly listing showing
 * how hard it is to access squareFeet
 * in a packed structure.
 *
 * To run -- don't. Compile and look at the
 * assembly listing instead.
 */

#include "stm32f0xx.h"
#include "stm32f0xx_nucleo.h"

// An example of an unpacked structure
struct unpackedHouse {
    uint8_t stories;     // Number of stories in the house
    uint8_t bedrooms;    // Number of bedrooms
    uint32_t squareFeet; // Size of the house
    uint8_t doors;       // Number of doors
    uint8_t windows;     // Number of windows
};

// An example of a packed structure
struct packedHouse {
    uint8_t stories;     // Number of stories in the house
    uint8_t bedrooms;    // Number of bedrooms
    uint32_t squareFeet; // Size of the house
<span epub:type="pagebreak" title="126" id="Page_126"/>    uint8_t doors;       // Number of doors
    uint8_t windows;     // Number of windows
} __attribute__((packed));

// A place to dump squareFeet for unpackedHouse
volatile uint32_t unpackedFeet;
volatile uint32_t packedFeet;   // A place to dump squareFeet for packedHouse

// An example unpackedHouse -- values chosen to make demonstration easier
struct unpackedHouse theUnpackedHouse = {0x01, 0x02, 0x11223344, 0x03, 0x04};

// An example packedHouse -- values chosen to make demonstration easier
struct   packedHouse thePackedHouse = {0x01, 0x02, 0x11223344, 0x03, 0x04};

int main(void)
{
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> unpackedFeet = theUnpackedHouse.squareFeet;
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> packedFeet = thePackedHouse.squareFeet;

    for(;;);
}</code></pre>
<p>First, let’s look at the code generated to fetch an aligned <code>uint32_t</code><span class="DigitalOnly"> </span><span class="CodeAnnotation" aria-label="annotation1">1</span> (comments added):</p>
<pre><code>;unpackedFeet = theUnpackedHouse.squareFeet;
    ldr     r3, .L3       ; Get address of theUnpackedHouse.
    ldr     r2, [r3, #4]  ; Get data at offset 4
                          ; (theUnpackedHouse.squareFeet).
<var>--snip--</var>
L3: theUnpackedHouse</code></pre>
<p>It uses one instruction to get the address of the structure and one to get the value.</p>
<p>Now let’s look at the unaligned fetch <span class="CodeAnnotation" aria-label="annotation2">2</span>:</p>
<pre><code>;  packedFeet = thePackedHouse.squareFeet;
    ldr     r3, .L3+8     ; Get address of thePackedHouse.
    ldrh    r2, [r3, #2]  ; Get uint16_t at offset 2 (0x3344).
                          ; (Byte order puts the low-order bytes first.)

    ldrh    r3, [r3, #4]  ; Get uint16_t at offset 4 (0x1122).
                          ; (High bytes come after low.)

    lsls    r3, r3, #16   ; r3 contains the top 1/2 of squareFeet
                          ; in the bottom 16 bits of r3.
                          ; Shift it left into the top half.

    orrs    r3, r2        ; Combine the two halves.

.L3: theUnpackedHouse
     thePackedHouse</code></pre>
<p><span epub:type="pagebreak" title="127" id="Page_127"/>The unaligned fetch requires four instructions instead of the one required by an aligned fetch. The program must use two load instructions to get the two halves of the number: one shift to get the top half to the top of the register, and a logical OR to combine the two numbers.</p>
<p>Code like this must be used every time an unaligned <code>uint32_t</code> is loaded or stored. You can see why the compiler might want to avoid doing that and adds padding.</p>
<h3 id="h2-501621c08-0003">Structure Initialization</h3>
<p class="BodyFirst">We can initialize structures by putting the initializer list inside curly brackets (<code>{}</code>). For example, the following statement declares and initializes <code>myHouse</code> with one statement:</p>
<pre><code>struct house {
    uint8_t stories;        // Number of stories in the house
    uint8_t bedrooms;       // Number of bedrooms
    uint32_t squareFeet;    // Size of the house
};

// 2 stories
// 5 bedrooms
// 2500 square feet
struct house myHouse = {2, 5, 2500};</code></pre>
<p>In early versions of the language, that was the only way to initialize structures. Later, when C99 (the C specification finalized in 1999) came along, a new feature called <em>designated initializers</em> was added to let you initialize fields by name. Here’s an example:</p>
<pre><code>struct house myHouse = {
  stories: 2,
  bedrooms: 5,
  squareFeet: 2500
};</code></pre>
<p>The fields must be in the same order as they are declared in the structure. The GCC compiler has an extension that lets you use designated initializers using a different method:</p>
<pre><code>struct house myHouse = {
    .stories: 2,
    .squareFeet: 2500,
    .bedrooms: 5
};</code></pre>
<p>In this case, the order does not have to match the order in which the fields were declared.</p>
<h3 id="h2-501621c08-0004"><span epub:type="pagebreak" title="128" id="Page_128"/>Structure Assignment</h3>
<p class="BodyFirst">C does not allow you to assign one array to another, but it does allow you to assign one structure to another. Here’s an example:</p>
<pre><code>int array1[5];           // An array
int array2[5];           // Another array

array1 = array2;         // Illegal

struct example {
    int array[5];        // Array inside a structure
};
struct example struct1;  // A structure
struct example struct2;  // Another structure

// Initialize structure 2

struct1 = struct2;       // Structure assignment allowed</code></pre>
<p>If these were arrays, assignment would be illegal, but since they are structures, it works.</p>
<h3 id="h2-501621c08-0005">Structure Pointers</h3>
<p class="BodyFirst">C’s parameter-passing mechanism uses <em>call by value</em>, meaning that if we pass a parameter to a procedure, it copies the value of the parameter onto the stack. This practice is not a problem when we have something small like a 2-byte integer, but most structures are not very small and actually can be quite large. When a structure is passed as a parameter, <em>the entire structure is copied onto the stack</em>, making it an expensive operation. Here’s an example:</p>
<pre><code>// A rectangle
struct rectangle {
    unsigned int width;  // Width of the rectangle
    unsigned int height; // Height of a rectangle
};

// Inefficient parameter passing
unsigned int area(const struct rectangle aRectangle)
{
    return (aRectangle.width * aRectangle.height);
}</code></pre>
<p>What’s going on here is that in order to perform the “call by value” parameter passing, the compiler must generate code to copy <code>aRectangle</code> in its entirety onto the stack. For larger structures, that can use a lot of stack space and take up a lot of time copying the data.</p>
<p>It’s more efficient to pass a structure as a pointer:</p>
<pre><code>// Efficient parameter passing
unsigned int area(const struct rectangle* const aRectangle)
<span epub:type="pagebreak" title="129" id="Page_129"/>{
    return ((*aRectangle).rectangle * (*aRectangle).height);
}</code></pre>
<p>In this case, only the pointer (a small item) is passed as a parameter. In the case of the ARM compiler, this is done by putting it in a register: quick, easy, and no stack space used.</p>
<p>One of the advantages of call by value is any changes to the parameter are not passed back to the caller. But we didn’t make any changes, so that’s not an issue.</p>
<p>When we passed parameters as pointers, we used <code>const</code> to indicate that no changes to the parameters were allowed.</p>
<p>It’s a little awkward to access a member of a structure pointer using the <code>(*rectangle).height</code> syntax. Because of this, C has added some syntactic sugar that allows us to use a shortcut—the <code>-&gt;</code> operator:</p>
<pre><code>// Efficient parameter passing
unsigned int area(const struct rectangle* const aRectangle)
{
    return (aRectangle-&gt;rectangle * aRectangle-&gt;height);
}</code></pre>
<p>C feels free to treat an array as a pointer and a pointer as an array. When an array is passed in as a parameter, the array is automatically turned into a pointer. When an array is specified as a procedure parameter, it is automatically turned into a pointer behind your back.</p>
<p>Saying C is “call by value” is not strictly true. It’s more precise to say, “C is called by value, except for arrays, which are called by pointer value.”</p>
<h3 id="h2-501621c08-0006">Structure Naming</h3>
<p class="BodyFirst">Like many things in C, the naming of structures is not all that simple. That’s because in a single C structure declaration, we can define a structure name (or not) and a variable (or not). Here’s the general syntax for a structure definition:</p>
<pre><code>struct [<var>struct-name</var>] {
    <var>field1</var>;
    <var>field2</var>;
<em>--snip--</em>
} [<var>var-name(s)</var>];</code></pre>
<p>Let’s consider the example when we don’t have a structure name:</p>
<pre><code>// A box to put our stuff into
struct {
    uint32_t width;     // Width of the box
    uint32_t height;    // Height of the box
} aBox;</code></pre>
<p><span epub:type="pagebreak" title="130" id="Page_130"/>This defines the <code>aBox</code> variable, but what type is <code>aBox</code>? It is a structure with no name, or an <em>anonymous structure</em>. Anonymous structures can be used to define a variable only when the structure is defined. They do not specify a structure name that can be used in later declarations.</p>
<p>Now let’s consider the case where we leave off the variable name:</p>
<pre><code>struct box {
    uint32_t width;     // Width of the box
    uint32_t height;    // Height of the box
};</code></pre>
<p>This defines a structure type but no variables. It can be used later to define a variable:</p>
<pre><code>struct box aBox; // Box to put stuff into</code></pre>
<p>We can put in both a structure name and a variable name in the same declaration:</p>
<pre><code>struct box {
    uint32_t width;     // Width of the box
    uint32_t height;    // Height of the box
} aBox;</code></pre>
<p>This defines both a <code>box</code> structure and a variable <code>aBox</code>.</p>
<p>C has one more trick up its sleeve—we can have a structure definition with no structure name and no variable name:</p>
<pre><code>// Silly definition
struct {
    uint32_t width;     // Width of the box
    uint32_t height;    // Height of the box
};</code></pre>
<p>Because there is no structure name, we can use this only to access the variable defined here. But no variable is defined here, so we can’t access anything, which means that although it’s perfectly legal, it’s also perfectly useless.</p>
<h2 id="h1-501621c08-0004">Unions</h2>
<p class="BodyFirst">A <code>union</code> is like a <code>struct</code> except that instead of each field being assigned a different location, all the fields are stored in the same location. Here’s an example:</p>
<pre><code>union value {
    uint32_t anInteger;
    float aFloat;
};</code></pre>
<p><span epub:type="pagebreak" title="131" id="Page_131"/>The compiler allocates 4 bytes for the <code>uint32_t</code> and <em>the same 4 bytes</em> for the <code>float</code>. Let’s take a look at this in action:</p>
<pre><code>union value theValue;   // Define the value.

theValue.anInteger = 5; // anInteger is 5.
theValue.aFloat = 1.0;  // Assign the field aFloat/wipe out anInteger.</code></pre>
<p>The second assignment actually changes <code>anInteger</code> to 1065353216 (0x3f800000). It’s a very strange integer, but as a floating point, it’s 1.0.</p>
<p>Good programming practice is to use the same field name for storing and retrieving a value from an union. For example:</p>
<pre><code>    theValue.aFloat = 1.2;
    float someFloat = theValue.aFloat;   // Assigns someFloat 1.2</code></pre>
<p>When you use different fields, the results will be different on different machines.</p>
<pre><code>    theValue.aFloat = 1.2;
    int someInt = theValue.anInteger;   // Results machine-dependent</code></pre>
<p>In this case the value of <code>someInt</code> will depend on the size of an integer, the size of a float, the floating-point format, and the byte order, all of which are processor-dependent.</p>
<p>Now let’s talk about the byte order problem. Let’s say you have four cards in your hand, numbered 1, 2, 3, and 4. You want to put them into a row of four boxes in front of you. So, you take the top card and put it in the leftmost box, you put the next card in the box to the right of that, and so on. Your boxes now contain the following:</p>
<table id="tabular-501621c08-0004" border="1" class="blank"><tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>When you pick up the cards, you start at the right and put each card on top of the pile. The result is that you get 1, 2, 3, and 4 in order back in your hand.</p>
<p>Now another person comes along and puts the cards in the boxes starting on the right side and going left. Their boxes look like this:</p>
<table id="tabular-501621c08-0005" border="1" class="blank"><tbody>
<tr>
<td>4</td>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>They pick up the cards starting at the left and work right. Again, this person will wind up with 1, 2, 3, and 4 in their hand, in exactly that order.</p>
<p>What I’ve just described is how two different CPU architectures will store numbers in memory. In some cases it will be 1, 2, 3, and 4 and in others 4, 3, 2, and 1. As long as you are storing and retrieving the same size number, byte order makes no difference.</p>
<p><span epub:type="pagebreak" title="132" id="Page_132"/>Now let’s say you want to store four cards in the boxes but retrieve only two, which means your boxes look like this:</p>
<table id="tabular-501621c08-0006" border="1" class="blank"><tbody>
<tr>
<td>1</td>
<td>2</td>
<td class="shaded">3</td>
<td class="shaded">4</td>
</tr>
</tbody>
</table>
<p>When you pick up your cards, you get only 1 and 2.</p>
<p>However, the other person’s storage looks like this:</p>
<table id="tabular-501621c08-0007" border="1" class="blank"><tbody>
<tr>
<td>4</td>
<td>3</td>
<td class="shaded">2</td>
<td class="shaded">1</td>
</tr>
</tbody>
</table>
<p>The leftmost <em>n</em> boxes are always used when retrieving cards, so this person will start at the left and grab 3 and 4, meaning they’ll get a different result.</p>
<p>This difference is caused by the two of you using a different order when storing and retrieving cards. The same thing happens in computers. Different computers store things in different orders. As a result, you are going to get different answers on different machines if you try and store one type of data and retrieve another.</p>
<p>Therefore, if you put something in <code>theValue.anInteger</code>, the only way you’re guaranteed to get consistent results is to take it out using only the <code>theValue.anInteger</code> field.</p>
<h2 id="h1-501621c08-0005">Creating a Custom Type</h2>
<p class="BodyFirst">We’re now going to take all three of our new data types—<code>struct</code>, <code>union</code>, and <code>enum</code>—and combine them into one large data type in order to draw a shape on the screen. The shape can be a square, rectangle, circle, or triangle. Each of those shapes can be described differently.</p>
<p>All we need to describe a square is a single side:</p>
<pre><code>struct square {
    unsigned int side; // Size of the square
};</code></pre>
<p>To describe a rectangle, we need a width and height:</p>
<pre><code>struct rectangle {
    unsigned int width;   // Width of the rectangle
    unsigned int height;  // Height of the rectangle
};</code></pre>
<p>We can draw a circle with only its radius:</p>
<pre><code>struct circle {
    unsigned int radius;  // Radius of the circle
};</code></pre>
<p>Finally, to draw a triangle, we describe the base and height:</p>
<pre><code>struct triangle {
<span epub:type="pagebreak" title="133" id="Page_133"/>    unsigned int base;    // Base of the triangle
    unsigned int height;  // How high is it?
};</code></pre>
<p>A generic shape type should hold any one of these, which indicates that we need a <code>union</code>. But in order to draw a shape, we need to know not only its description but also what type of shape it is. The <code>enum</code> data type was designed for a limited list of simple values:</p>
<pre><code>enum shapeType {
    SHAPE_SQUARE, SHAPE_RECTANGLE, SHAPE_CIRCLE, SHAPE_TRIANGLE
};</code></pre>
<p>Now we get to define our data structure:</p>
<pre><code>struct shape {
    enum shapeType type;   // The type of the shape
    union {
       struct square theSquare;
       struct rectangle theRectangle;
       struct circle theCircle;
       struct triangle theTriangle;
    } dimensions;
};</code></pre>
<p>The first field is <code>type</code>, which contains the type of shape contained in the structure. The second field contains the <code>dimensions</code> of the shape. It’s a <code>union</code> because different shapes have different dimensions.</p>
<p>The code to draw the shapes looks something like the following:</p>
<pre><code>void drawShape(const shape* const theShape) {
    switch (theShape-&gt;type) {
        case SHAPE_SQUARE:
            drawSquare(theShape-&gt;dimensions.theSquare.side);
            break;
        case SHAPE_RECTANGLE:
            drawSquare(theShape-&gt;dimensions.theRectangle.width,
                       theShape-&gt;dimensions.theRectangle.height);
            // ... other shapes</code></pre>
<p>This design pattern is fairly common in C programming: a <code>union</code> that can hold many different types of data and an <code>enum</code> that tells which type we actually have.</p>
<h2 id="h1-501621c08-0006">Structures and Embedded Programming</h2>
<p class="BodyFirst">In this section, we take a hardware specification and turn it into a C structure, using what we’ve learned so far about structures and alignment.</p>
<p>The small computer system interface (SCSI) was designed to provide a standard way of transferring data to and from devices. It started in 1986 <span epub:type="pagebreak" title="134" id="Page_134"/>and since has been expanded and enhanced a great deal. It works by sending a structure called a command block to the device and getting back data and status messages in return.</p>
<p>When first written, the SCSI standard defined the <code>READ (6)</code> command, which limited the block address to 16 bits, allowing for a disk of up to 16MB, which was large for the time. Of course, disk makers quickly created bigger disks, so the SCSI people had to create a new command to allow for a bigger drive. This was the <code>READ (10)</code> command, which was followed by the <code>READ (12)</code>, <code>READ (16)</code>, and <code>READ (32)</code> commands. The <code>READ (32)</code> command uses a 64-bit block address. Hopefully, it will take the disk manufacturers a little time to catch up and create an 8-zebibyte disk.</p>
<p><a href="#figure8-2" id="figureanchor8-2">Figure 8-2</a> shows the command block for the <code>READ (10)</code> command. If we want to read data from the disk, we’ll need a C structure to contain this information and send it to the device.</p>
<figure>
<img src="image_fi/501621c08/f08002.png" alt="f08002" class=""/>
<figcaption><p><a id="figure8-2">Figure 8-2</a>: The <span class="LiteralInCaption"><code>READ (10)</code></span> command block</p></figcaption>
</figure>
<p>At first, it seems like a simple translation:</p>
<pre><code>struct read10 {
    uint8_t opCode;    // Op code for read
    uint8_t flags;     // Flag bits
    <b>uint32_t lba;      // Logical block address</b>
    uint8_t group;     // Command group
    uint16_t transferLength;  // Length of the data to read
    uint8_t control;   // Control bits, the NACA being the only one defined
};
#include &lt;assert.h&gt;

int main() {
    assert(sizeof(struct read10) == 10);</code></pre>
<p>Now, because we’re paranoid and careful, the first thing we did in the program was to put in an <code>assert</code> statement to make sure our definition matches the hardware. An <code>assert</code> statement aborts the program if <span epub:type="pagebreak" title="135" id="Page_135"/>the condition is not true. If we expect the <code>read10</code> control block to contain 10 bytes and it doesn’t, our program has a big problem. And we do too, because the <code>assert</code> fails.</p>
<p>So what happened? Inspecting the structure, we see that the <code>lba</code> field (a <code>uint32</code>) is aligned on a 2-byte boundary. The compiler wants to put it on a 4-byte boundary, so it added 2 bytes of padding. We need to pack the structure:</p>
<pre><code>struct read10 {
    uint8_t opCode;    // Op code for read
    uint8_t flags;     // Flag bits
    uint32_t lba;      // Logical block address
    uint8_t group;     // Command group
    uint16_t transferLength;  // Length of the data to read
    uint8_t control;   //  Control bits, the NACA being the only one defined
} __attribute__((packed));</code></pre>
<p>The <code>packed</code> attribute tells GCC to not add any padding. As a result, our structure is inefficient, but it matches the hardware. Also, our <code>assert</code> doesn’t fail, so we’ve done it right.</p>
<h2 id="h1-501621c08-0007">typedef</h2>
<p class="BodyFirst">We can define our own types using the <code>typedef</code> statement. For example, the following statement defines a new <code>dimension</code> type:</p>
<pre><code>typedef unsigned int dimension;  // Dimension for use in the plans</code></pre>
<p>This type is equivalent to an <code>unsigned int</code> and can be used like any other type:</p>
<pre><code>dimension width;   // Width of the thing in furlongs</code></pre>
<p>The syntax of a <code>typedef</code> is similar to that of a variable declaration. It contains the <code>typedef</code> keyword and the name of the initial type, as well as the name of the defined type:</p>
<pre><code>typedef <var>initialtype</var> <var>newtypename</var>;  // A type definition</code></pre>
<p>One example of <code>typedef</code> can be found in the <em>stdint.h</em> file, which is included in many of our programs:</p>
<pre><code>// These typedefs are system-dependent.
typedef signed char        int8_t;
typedef unsigned char      uint8_t;
typedef signed short int   int16_t;
typedef unsigned short int uint16_t;
typedef signed int         int32_t;
typedef unsigned int       uint32_t;</code></pre>
<p><span epub:type="pagebreak" title="136" id="Page_136"/>In the early days of C, an <code>int</code> could be 16 or 32 bits, depending on the processor. In the early days of programming, if users wanted to use a 16-bit integer (which the old C standard didn’t support), they had to put something like this in their code:</p>
<pre><code>#ifdef ON_16_BIT_CPU
typedef signed int   int16_t;
#else // ON_32_BIT_CPU
typedef signed short int   int16_t;
#endif</code></pre>
<p>After years of having to define our own precise data types, the C standards committee created the <em>stdint.h</em> header file and made it a part of the language.</p>
<h3 id="h2-501621c08-0007">Function Pointers and typedef</h3>
<p class="BodyFirst">C allows pointers to functions, which are useful when doing callbacks. For example, we might tell a graphics system to call a given function when a button is pressed. The code for that might look like the following:</p>
<pre><code>registerButtonPressHandler(functionToHandleButtonPress);</code></pre>
<p>The <code>functionToHandleButtonPress</code> parameter is a pointer to a function that returns an integer and takes a constant event pointer as its single argument. That sentence is a mess, and it doesn’t get any easier when we translate it to C:</p>
<pre><code>int (*ButtonCallback)(const struct event* const theEvent);</code></pre>
<p>The first set of parentheses is required because without it we define a function that returns an integer pointer:</p>
<pre><code>// Define function that returns int*
int* getPointer(...)</code></pre>
<p>Rather than remember these convoluted syntax rules, let’s simplify the syntax using <code>typedef</code>:</p>
<pre><code>// Function type for callback function
typedef int ButtonCallbackType(const struct event* const theEvent);

// Pointer to callback function
typedef ButtonCallbackType* ButtonCallbackPointer;</code></pre>
<p>This changes the definition of <code>registerButtonPressHandler</code> from:</p>
<pre><code>void registerButtonPressHandler(int (*callbackPointer)
     (const struct event* const theEvent));</code></pre>
<p class="BodyContinued">to this:</p>
<pre><code>void registerButtonPressHandler(ButtonCallbackPointer callbackPointer);</code></pre>
<p><span epub:type="pagebreak" title="137" id="Page_137"/>The <code>typedef</code> provides a way of organizing types to simplify our code, as well as make things clearer.</p>
<h3 id="h2-501621c08-0008">typedef and struct</h3>
<p class="BodyFirst">We’ve already seen how we can use <code>struct</code> to define a structured data type.</p>
<pre><code>struct rectangle {
    uint32_t width;  // Width of the rectangle
    uint32_t height; // Height of the rectangle
};</code></pre>
<p>To use this structure, we must use the <code>struct</code> keyword:</p>
<pre><code>struct rectangle bigRectangle;   // A big rectangle</code></pre>
<p>The <code>typedef</code> statement allows us to avoid using the <code>struct</code> keyword:</p>
<pre><code>typedef struct{
    uint32_t width;       // Width of the rectangle
    uint32_t height;      // Height of the rectangle
} rectangle;

rectangle bigRectangle;   // A big rectangle</code></pre>
<p>The <code>typedef</code> in this case tells C that we want to define a new <code>rectangle</code> type.</p>
<p>Some people believe that using <code>typedef</code> to define a new structure type makes the code simpler and cleaner. Others prefer to use <code>struct</code> because it makes it obvious that a variable is a <code>struct</code>. The syntax is optional, so use whatever works best for you.</p>
<h2 id="h1-501621c08-0008">Summary</h2>
<p class="BodyFirst">This chapter is all about organizing data. The <code>enum</code> type allows you to organize simple name lists without having to worry about which field gets what value. Structures provide a powerful tool for organizing data of different types. For embedded programmers, they are also useful for communicating with actual hardware devices. However, keep in mind that a hardware designer’s idea of how a structure is laid out can be different from what C thinks it should be.</p>
<p>While structures can hold only a fixed set of data, unions can hold multiple sets (just not at the same time). Between the two of them, we have a great deal of control over how we store data.</p>
<p>Another tool for organizing data is the <code>typedef</code> directive, which allows us to define our own types. It lets us represent data using familiar types instead of being forced to use the basic C types.</p>
<p>Many complex data types exist, and C provides a good set of tools for managing them.</p>
<h2 id="h1-501621c08-0009"><span epub:type="pagebreak" title="138" id="Page_138"/>Programming Problems</h2>
<ol class="decimal">
<li value="1">Create a structure to hold a fraction. Then create procedures that add, subtract, multiply, and divide fractions. The fractions should be stored in normalized form. In other words, 2/4 should be stored as 1/2.</li>
<li value="2">Create a structure called <code>car</code> that holds attributes common to both electric and gas-powered cars. Add to it a union with two fields, <code>electric</code> and <code>gas</code>, that are structures that hold attributes specific to that type of car. For example, <code>numberOfPassengers</code> is common to all cars. The field <code>chargingTime</code> would be electric-only.</li>
<li value="3">Write a structure to describe a student (single class). The data should contain not only the student’s name and ID number but also an array containing the student’s grades.</li>
<li value="4">Write a structure to handle the data shown in <a href="#figure8-3" id="figureanchor8-3">Figure 8-3</a>.
<figure>
<img src="image_fi/501621c08/f08003.png" alt="f08003" class=""/>
<figcaption><p><a id="figure8-3">Figure 8-3</a>: IPv4 header format</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The IP structure uses <em>network byte order</em>, or big-endian format.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside></li>
<li value="5">The Southern California Railroad has the only Acme Traffic Signal (the one with arms and lights) actually at an intersection. To change the signal from STOP to GO, the controller must do the following:
<ol class="lower-alpha">
<li value="1">Turn off the STOP light.</li>
<li value="2">Turn on the GO light.</li>
<li value="3">Turn on the DIRECTION relay.</li>
<li value="4">Energize the ARM relay.</li>
<li value="5">Wait 3 seconds.</li>
<li value="6"><span epub:type="pagebreak" title="139" id="Page_139"/>Turn off the ARM relay.</li>
<li value="7">Turn off the DIRECTION relay.</li></ol>
<p class="ListBody">We have the following commands available: (1) change state of light <em>x</em> to <em>y</em>, where <em>x</em> is STOP or GO, and <em>y</em> is ON or OFF; (2) set DIRECTION relay power to <em>x</em>, where <em>x</em> is ON or OFF; and (3) sleep for <em>n</em> seconds. Write a structure for each command. Then write a union that holds an <code>enum</code> to identify the command and the structure for the given command.</p>
</li>
</ol>
</section>
</body></html>