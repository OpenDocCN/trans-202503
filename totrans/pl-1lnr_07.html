<html><head></head><body><section class="chapter" title="Chapter&#xA0;8.&#xA0;Useful Regular Expressions" epub:type="chapter" id="useful_regular_expressions"><div class="titlepage"><div><div><h2 class="title">Chapter 8. Useful Regular Expressions</h2></div></div></div><p><a id="idx00062" class="indexterm"/><a id="idx00327" class="indexterm"/><a id="idx00529" class="indexterm"/><a id="idx00576" class="indexterm"/>In this chapter, we’ll look at various regular expressions and how to use them in some handy one-liners. The regular expressions include matching IP addresses, HTTP headers, and email addresses; matching numbers and number ranges; and extracting and changing matches. I’ll also share some regular expression puzzles and best practices. This chapter will be a bit different from previous ones because I’ll start with a regular expression and then write a one-liner that uses it.</p><div class="sect1" title="8.1 Match something that looks like an IP address"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="eight_1_match_something_that_looks_like">8.1 Match something that looks like an IP address</h2></div></div></div><a id="I_programlisting8_id313957"/><pre class="programlisting">/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/</pre><p>This regular expression doesn’t actually guarantee that the thing that matched is, in fact, a valid IP; it simply matches something that looks like an IP address. For example, it matches a valid IP such as <code class="literal">81.198.240.140</code> as well as an invalid IP such as <code class="literal">936.345.643.21</code>.</p><p><a id="idx00103" class="indexterm"/><a id="idx00521" class="indexterm"/><a id="idx00536" class="indexterm"/>Here’s how it works. The <code class="literal">^</code> at the beginning of the regular expression is an anchor that matches the beginning of the string. Next, <code class="literal">\d{1,3}</code> matches one, two, or three consecutive digits. The <code class="literal">\.</code> matches a dot. The <code class="literal">$</code> at the end is an anchor that matches the end of the string. (You use both <code class="literal">^</code> and <code class="literal">$</code> anchors to prevent strings like <code class="literal">foo213.3.1.2bar</code> from matching.)</p><p>You can simplify this regular expression by grouping the first three repeated <code class="literal">\d{1,3}\.</code> expressions:</p><a id="I_programlisting8_id314035"/><pre class="programlisting">/^(\d{1,3}\.){3}\d{1,3}$/</pre><p>Say you have a file with the following content and you want to extract only the lines that look like IP addresses:</p><a id="I_programlisting8_id314043"/><pre class="programlisting">81.198.240.140
1.2.3.4
5.5
444.444.444.444
90.9000.90000.90000
127.0.0.1</pre><p>To extract only the matching lines, you can write this:</p><a id="I_programlisting8_id314050"/><pre class="programlisting">perl -ne 'print if /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/'</pre><p>which should print</p><a id="I_programlisting8_id314058"/><pre class="programlisting">81.198.240.140
1.2.3.4
444.444.444.444
127.0.0.1</pre><p>One-liner 8.3 explains how to match an IP precisely, not just something that looks like an IP.</p></div><div class="sect1" title="8.2 Test whether a number is in the range 0 to 255"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="eight_2_test_whether_a_number_is_in_the">8.2 Test whether a number is in the range 0 to 255</h2></div></div></div><a id="I_programlisting8_id314077"/><pre class="programlisting">/^([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/</pre><p>I like to challenge people with puzzles. One of my favorites is to ask someone to come up with a regular expression that matches a number range. Writing one is actually quite tricky if you’ve never done so before.</p><p>Here’s how it works. A number can have one, two, or three digits. If the number has one digit, you allow it to be anything <code class="literal">[0-9]</code>. If it has two digits, you also let it be any combination of <code class="literal">[0-9][0-9]</code>. But if the number has three digits, it has to be either one hundred–something or two hundred–something. If the number is one hundred–something, <code class="literal">1[0-9][0-9]</code> matches it. If the number is two hundred–something, the number is either 200 to 249 (which is matched by <code class="literal">2[0-4][0-9]</code>) or it’s 250 to 255 (which is matched by <code class="literal">25[0-5]</code>).</p><p><a id="idx00063" class="indexterm"/><a id="idx00328" class="indexterm"/><a id="idx00460" class="indexterm"/><a id="idx00515" class="indexterm"/><a id="idx00624" class="indexterm"/>Let’s confirm this regular expression really matches all numbers in the range 0 to 255 and write a one-liner to do it:</p><a id="I_programlisting8_id314161"/><pre class="programlisting">perl -le '
  map { $n++ if /^([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/ } 0..255;
  END { print $n }
'</pre><p>This one-liner outputs 256, the total numbers in the range 0 to 255. It iterates over the range 0 to 255 and increments the <code class="literal">$n</code> variable for every number that matches. If the output value was less than 256, you’d know that some numbers didn’t match.</p><p>Let’s also make sure this one-liner doesn’t match numbers above 255:</p><a id="I_programlisting8_id314178"/><pre class="programlisting">perl -le '
  map { $n++ if /^([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$/ } 0..1000;
  END { print $n }
'</pre><p>Although there are 1001 iterations, from 0 to 1000, the final value of <code class="literal">$n</code> and the output should still be 256 because numbers greater than 255 should not match. If the value was greater than 256, you’d know that too many numbers matched and the regular expression was incorrect.</p></div><div class="sect1" title="8.3 Match an IP address"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="eight_3_match_an_ip_address">8.3 Match an IP address</h2></div></div></div><a id="I_programlisting8_id314202"/><pre class="programlisting">my $ip_part = qr/[0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]/;
if ($ip =~ /^$ip_part\.$ip_part\.$ip_part\.$ip_part$/) {
  print "valid ip\n";
}</pre><p>This regular expression combines the ideas from the previous two regular expressions (8.1 and 8.2) and introduces the <code class="literal">qr/.../</code> operator, which lets you construct a regular expression and save it in a variable. Here, I’m saving the regular expression that matches all numbers in the range 0 to 255 in the <code class="literal">$ip_part</code> variable. Next, the <code class="literal">$ip_part</code> matches the four parts of the IP address.</p><p><a id="idx00060" class="indexterm"/><a id="idx00197" class="indexterm"/><a id="idx00526" class="indexterm"/><a id="idx00567" class="indexterm"/>You can simplify this by grouping the first three IP parts:</p><a id="I_programlisting8_id314259"/><pre class="programlisting">if ($ip =~ /^($ip_part\.){3}$ip_part$/) {
  print "valid ip\n";
}</pre><p>Let’s run this on the same file from one-liner 8.1. If you have this file as input:</p><a id="I_programlisting8_id314267"/><pre class="programlisting">81.198.240.140
1.2.3.4
5.5
444.444.444.444
90.9000.90000.90000
127.0.0.1</pre><p>and your one-liner is</p><a id="I_programlisting8_id314274"/><pre class="programlisting">perl -ne '
  $ip_part = qr{([0-9]|[0-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])};
  print if /^($ip_part\.){3}$ip_part$/
'</pre><p>then the output is</p><a id="I_programlisting8_id314282"/><pre class="programlisting">81.198.240.140
1.2.3.4
127.0.0.1</pre><p>As you can see, only the valid IP addresses are printed.</p></div><div class="sect1" title="8.4 Check whether a string looks like an email address"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="eight_4_check_whether_a_string_looks_lik">8.4 Check whether a string looks like an email address</h2></div></div></div><a id="I_programlisting8_id314300"/><pre class="programlisting">/\S+@\S+\.\S+/</pre><p>This regular expression makes sure the string looks like an email address; it doesn’t guarantee the string is an email address, however. First, it matches something that’s not whitespace (<code class="literal">\S+</code>) up to the <code class="literal">@</code> symbol; then it matches as much as possible until it finds a dot; then it matches some more.</p><p>If the matches succeed, you know the string at least looks like an email address with the <code class="literal">@</code> symbol and a dot in it. For example, <code class="literal">cats@catonmat.net</code> matches, but <code class="literal">cats@catonmat</code> doesn’t because the regular expression can’t find the dot that’s required in a fully qualified domain name.</p><p><a id="idx00198" class="indexterm"/><a id="idx00399" class="indexterm"/><a id="idx00408" class="indexterm"/><a id="idx00468" class="indexterm"/><a id="idx00524" class="indexterm"/><a id="idx00578" class="indexterm"/><a id="idx00593" class="indexterm"/>Here’s a much more robust way to see whether a string is a valid email address, using the <code class="literal">Email::Valid</code> module:</p><a id="I_programlisting8_id314393"/><pre class="programlisting">use Email::Valid;
print Email::Valid-&gt;address('cats@catonmat.net') ? 'valid email' : 'invalid email';</pre><p>Here, you use the ternary operator <code class="literal">cond ? true : false</code>. If the <code class="literal">cond</code> is true, the <code class="literal">true</code> part executes; otherwise the <code class="literal">false</code> part executes. This prints <code class="literal">valid email</code> if the email is valid; if not, it prints <code class="literal">invalid email</code>.</p><p>So a one-liner would look like this:</p><a id="I_programlisting8_id314428"/><pre class="programlisting">perl -MEmail::Valid -ne 'print if Email::Valid-&gt;address($_)'</pre><p>Here, if the email address is valid, you simply print it.</p></div><div class="sect1" title="8.5 Check whether a string is a number"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="eight_5_check_whether_a_string_is_a_numb">8.5 Check whether a string is a number</h2></div></div></div><p>Determining whether a string is a number is difficult with a regular expression. This is a derivation of a regular expression that matches decimal numbers.</p><p>I start with Perl’s <code class="literal">\d</code> regular expression, which matches the digits 0 through 9:</p><a id="I_programlisting8_id314462"/><pre class="programlisting">/^\d+$/</pre><p>This regular expression matches one or more digits <code class="literal">\d</code> from the beginning of the string <code class="literal">^</code> to the end at <code class="literal">$</code>. But it doesn’t match numbers such as <code class="literal">+3</code> and <code class="literal">-3</code>. Let’s modify the regular expression to match them:</p><a id="I_programlisting8_id314490"/><pre class="programlisting">/^[+-]?\d+$/</pre><p>Here, the <code class="literal">[+-]?</code> means “match an optional plus or a minus before the digits.” This regular expression now matches <code class="literal">+3</code> and <code class="literal">-3</code> but not <code class="literal">-0.3</code>. Let’s add that:</p><a id="I_programlisting8_id314513"/><pre class="programlisting">/^[+-]?\d+\.?\d*$/</pre><p>I’ve expanded the previous regular expression by adding <code class="literal">\.?\d*</code>, which matches an optional dot followed by zero or more numbers. Now we’re in business. This regular expression also matches numbers like <code class="literal">-0.3</code> and <code class="literal">0.3</code>, though it would not match numbers such as <code class="literal">123,456</code> or <code class="literal">.5</code>.</p><p>A much better way to match a decimal number is to use the <code class="literal">Regexp::Common</code> module. For example, to match a decimal number, you can use <code class="literal">$RE{num}{real}</code> from <code class="literal">Regexp::Common</code>. Here’s a one-liner that filters the input and prints only the decimal numbers:</p><a id="I_programlisting8_id314557"/><pre class="programlisting">perl -MRegexp::Common -ne 'print if /$RE{num}{real}/'</pre><p><a id="idx00539" class="indexterm"/><a id="idx00585" class="indexterm"/><a id="idx00672" class="indexterm"/>This one-liner also matches and prints numbers such as <code class="literal">123,456</code> and <code class="literal">.5</code>.</p><p>How about matching positive hexadecimal numbers? Here’s how:</p><a id="I_programlisting8_id314601"/><pre class="programlisting">/^0x[0-9a-f]+$/i</pre><p>This one-liner matches the hex prefix <code class="literal">0x</code> followed by the hex number itself. The <code class="literal">/i</code> flag at the end ensures the match is case insensitive. For example, <code class="literal">0x5af</code> matches, <code class="literal">0X5Fa</code> matches, but <code class="literal">97</code> doesn’t because <code class="literal">97</code> has no hex prefix.</p><p>Better still, use <code class="literal">$RE{num}{hex}</code> because it supports negative numbers, decimal places, and number grouping.</p><p>How about matching octals?</p><a id="I_programlisting8_id314643"/><pre class="programlisting">/^0[0-7]+$/</pre><p>Octal numbers are prefixed by 0, which is followed by the octal digits <code class="literal">0-7</code>. For example, <code class="literal">013</code> matches but <code class="literal">09</code> doesn’t because it’s not a valid octal number. Using <code class="literal">$RE{num}{oct}</code> is better because it supports negative octal numbers, octal numbers with decimal places, and number grouping.</p><p>Finally, we come to binary matching:</p><a id="I_programlisting8_id314671"/><pre class="programlisting">/^[01]+$/</pre><p>Binary base consists of only 0s and 1s, so <code class="literal">010101</code> matches but <code class="literal">210101</code> doesn’t because <code class="literal">2</code> is not a valid binary digit.</p><p><code class="literal">Regexp::Common</code> also offers a better regular expression for matching binary numbers: <code class="literal">$RE{num}{bin}</code>.</p></div><div class="sect1" title="8.6 Check whether a word appears in a string twice"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="eight_6_check_whether_a_word_appears_in">8.6 Check whether a word appears in a string twice</h2></div></div></div><a id="I_programlisting8_id314705"/><pre class="programlisting">/(<span class="emphasis"><em>word</em></span>).*\1/</pre><p>This regular expression matches a word followed by something or nothing at all, followed by the same word. Here, <code class="literal">(word)</code> captures the word in group 1, and <code class="literal">\1</code> refers to the contents of group 1, which is the same as writing <code class="literal">/(word).*word/</code>. For example, <code class="literal">silly things are silly</code> matches <code class="literal">/(silly).*\1/</code>, but <code class="literal">silly things are boring</code> doesn’t because <code class="literal">silly</code> is not repeated in the string.</p></div><div class="sect1" title="8.7 Increase all integers in a string by one"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="eight_7_increase_all_integers_in_a_strin">8.7 Increase all integers in a string by one</h2></div></div></div><a id="I_programlisting8_id314756"/><pre class="programlisting">$str =~ s/(\d+)/$1+1/ge</pre><p><a id="idx00091" class="indexterm"/><a id="idx00309" class="indexterm"/><a id="idx00323" class="indexterm"/><a id="idx00575" class="indexterm"/>Here, you use the substitution operator <code class="literal">s</code> to match all integers <code class="literal">(\d+)</code>, put them in capture group 1, and then replace them with their value incremented by one: <code class="literal">$1+1</code>. The <code class="literal">g</code> flag finds all numbers in the string, and the <code class="literal">e</code> flag evaluates <code class="literal">$1+1</code> as a Perl expression. For example, <code class="literal">this 1234 is awesome 444</code> is turned into <code class="literal">this 1235 is awesome 445</code>.</p><p>Note that this regular expression doesn’t increment floating-point numbers because it uses <code class="literal">\d+</code> to match integers. To increment floating-point numbers, use the <code class="literal">$RE{num}{real}</code> regular expression from one-liner 8.5. Here’s a sample one-liner that uses <code class="literal">$RE{num}{real}</code>:</p><a id="I_programlisting8_id314841"/><pre class="programlisting">perl -MRegexp::Common -pe 's/($RE{num}{real})/$1+1/ge'</pre><p>If you pass this one-liner the input <code class="literal">weird 44.5 line -1.25</code>, it prints <code class="literal">weird 45.5 line -0.25</code>.</p></div><div class="sect1" title="8.8 Extract the HTTP User-Agent string from HTTP headers"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="eight_8_extract_the_http_user-agent_stri">8.8 Extract the HTTP User-Agent string from HTTP headers</h2></div></div></div><a id="I_programlisting8_id314866"/><pre class="programlisting">/^User-Agent: (.+)$/</pre><p>HTTP headers are formatted as <code class="literal">Key: Value</code> pairs. You can easily parse such strings by instructing the regular expression engine to save the <code class="literal">Value</code> part in the <code class="literal">$1</code> group variable. For example, if the HTTP headers contain the following:</p><a id="I_programlisting8_id314886"/><pre class="programlisting">Host: www.catonmat.net
Connection: keep-alive
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_0_0; en-US)
Accept: application/xml,application/xhtml+xml,text/html
Accept-Encoding: gzip,deflate,sdch
Accept-Language: en-US,en;q=0.8
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3</pre><p>then the regular expression will extract the string <code class="literal">Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_0_0; en-US)</code>.</p></div><div class="sect1" title="8.9 Match printable ASCII characters"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="eight_9_match_printable_ascii_characters">8.9 Match printable ASCII characters</h2></div></div></div><a id="idx00071" class="indexterm"/><a id="idx00107" class="indexterm"/><a id="idx00305" class="indexterm"/><a id="idx00308" class="indexterm"/><a id="idx00401" class="indexterm"/><a id="idx00525" class="indexterm"/><a id="idx00527" class="indexterm"/><a id="I_programlisting8_id314972"/><pre class="programlisting">/[ -~]/</pre><p>This regular expression is tricky and smart. To understand it, take a look at <code class="literal">man ascii</code>, and you’ll see that space starts at value <code class="literal">0x20</code> and the <code class="literal">~</code> character is <code class="literal">0x7e</code>. The expression <code class="literal">[ -~]</code> defines a range of characters from the space until <code class="literal">~</code>. Because all characters between the space and <code class="literal">~</code> are printable, this regular expression matches all printable characters. This is my favorite regular expression of all time because it’s quite puzzling when you first see it. What does it match? A space, a dash, and a tilde? No, it matches a range of characters from the space until the tilde!</p><p>To invert the match, place <code class="literal">^</code> as the first character in the group:</p><a id="I_programlisting8_id315016"/><pre class="programlisting">/[^ -~]/</pre><p>This matches the opposite of <code class="literal">[ -~]</code>, that is, all nonprintable characters.</p></div><div class="sect1" title="8.10 Extract text between two HTML tags"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="eight_10_extract_text_between_two_html_t">8.10 Extract text between two HTML tags</h2></div></div></div><a id="I_programlisting8_id315039"/><pre class="programlisting">m|&lt;strong&gt;([^&lt;]*)&lt;/strong&gt;|</pre><p>Before I explain this regular expression, let me say that it’s okay to match HTML with regular expressions only for quick hacks when you need to get things done and move on. You should <span class="emphasis"><em>never</em></span> use regular expressions to match and parse HTML in serious applications because HTML is actually a complicated language, and, in general, it can’t be parsed by a regular expression. Instead, use modules like <code class="literal">HTML::TreeBuilder</code> to accomplish the task more cleanly!</p><p>This regular expression saves text between the <code class="literal">&lt;strong&gt;...&lt;/strong&gt;</code> HTML tags in the <code class="literal">$1</code> special variable. The trickiest part of this one-liner is <code class="literal">([^&lt;]*)</code>, which matches everything up to the <code class="literal">&lt;</code> character. It’s a regular expression idiom.</p><p>For example, if the HTML you’re trying to match is <code class="literal">&lt;strong&gt;hello&lt;/strong&gt;</code>, then this regular expression captures <code class="literal">hello</code> in the <code class="literal">$1</code> variable. However, if the HTML you’re trying to match is <code class="literal">&lt;strong&gt;&lt;em&gt;hello&lt;/em&gt;
&lt;/strong&gt;</code>, then this regular expression doesn’t match at all because there is another HTML tag between <code class="literal">&lt;strong&gt;</code> and <code class="literal">&lt;/strong&gt;</code>.</p><p>To extract everything between two HTML tags, including other HTML tags, you can write:</p><a id="I_programlisting8_id315108"/><pre class="programlisting">m|&lt;strong&gt;(.*?)&lt;/strong&gt;|</pre><p><a id="idx00244" class="indexterm"/><a id="idx00306" class="indexterm"/><a id="idx00528" class="indexterm"/><a id="idx00540" class="indexterm"/><a id="idx00587" class="indexterm"/>This regular expression saves everything between <code class="literal">&lt;strong&gt;...&lt;/strong&gt;</code> in the <code class="literal">$1</code> variable. For example, if the HTML is <code class="literal">&lt;strong&gt;&lt;em&gt;hello&lt;/em&gt;
&lt;/strong&gt;</code>, this regular expression sets <code class="literal">$1</code> to <code class="literal">&lt;em&gt;hello&lt;/em&gt;</code>. The <code class="literal">(.*?)</code> part of the regular expression matches everything between the two nearest <code class="literal">&lt;strong&gt;</code> and <code class="literal">&lt;/strong&gt;</code> tags. The question mark <code class="literal">?</code> in this regular expression controls its greediness.</p><p>If you want to be a good citizen and use <code class="literal">HTML::TreeBuilder</code>, then a Perl program that does the same thing would look like this:</p><a id="I_programlisting8_id315205"/><pre class="programlisting">use warnings;
use strict;
use HTML::TreeBuilder;
my $tree = HTML::TreeBuilder-&gt;new_from_content(
  "&lt;strong&gt;&lt;em&gt;hello&lt;/em&gt;&lt;/strong&gt;"
);
my $strong = $tree-&gt;look_down(_tag =&gt; 'strong');
if ($strong) {
  print $_-&gt;as_HTML for $strong-&gt;content_list;
}
$tree-&gt;delete;</pre><p>Here, I created a new <code class="literal">HTML::TreeBuilder</code> instance from the given string; then I found the <code class="literal">&lt;strong&gt;</code> tag and dumped all the child elements of the <code class="literal">&lt;strong&gt;</code> tag as HTML. As you can see, although writing a program like this isn’t suitable as a one-liner, it’s a much more robust solution.</p></div><div class="sect1" title="8.11 Replace all &lt;b&gt; tags with &lt;strong&gt;"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="eight_11_replace_all_b_tags_with_strong">8.11 Replace all &lt;b&gt; tags with &lt;strong&gt;</h2></div></div></div><a id="I_programlisting8_id315236"/><pre class="programlisting">$html =~ s|&lt;(/)?b&gt;|&lt;$1strong&gt;|g</pre><p>Here, I assume that the HTML is in the variable <code class="literal">$html</code>. The expression <code class="literal">&lt;(/)?b&gt;</code> matches the opening and closing <code class="literal">&lt;b&gt;</code> tags, captures the optional closing tag slash in the group <code class="literal">$1</code>, and then replaces the matched tag with either <code class="literal">&lt;strong&gt;</code> or <code class="literal">&lt;/strong&gt;</code>, depending on whether it finds an opening or closing tag.</p><p>Remember that the correct way to do this is to use <code class="literal">HTML::TreeBuilder</code> and write a proper program. You should only use this regular expression for a quick hack. Here’s what a program that uses <code class="literal">HTML::TreeBuilder</code> looks like:</p><a id="I_programlisting8_id315280"/><pre class="programlisting">use warnings;
use strict;
use HTML::TreeBuilder;
my $tree = HTML::TreeBuilder-&gt;new_from_content("
  &lt;div&gt;&lt;p&gt;&lt;b&gt;section 1&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;section 2&lt;/b&gt;&lt;/p&gt;&lt;/div&gt;
");
my @bs = $tree-&gt;look_down(_tag =&gt; 'b');
$_-&gt;tag('strong') for @bs;
print $tree-&gt;as_HTML;
$tree-&gt;delete;</pre><p><a id="idx00373" class="indexterm"/><a id="idx00535" class="indexterm"/>Here, I’ve created the <code class="literal">HTML::TreeBuilder</code> object from the given string; next, I found all the <code class="literal">&lt;b&gt;</code> tags, stored them in the <code class="literal">@bs</code> array, and then looped over all <code class="literal">@bs</code> and changed their tag name to <code class="literal">&lt;strong&gt;</code>.</p></div><div class="sect1" title="8.12 Extract all matches from a regular expression"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="eight_12_extract_all_matches_from_a_regu">8.12 Extract all matches from a regular expression</h2></div></div></div><a id="I_programlisting8_id315340"/><pre class="programlisting">my @matches = $text =~ /<span class="emphasis"><em>regex</em></span>/g;</pre><p>Here, the regular expression match is evaluated in the list context, which makes it return all matches. The matches are put in the <code class="literal">@matches</code> variable.</p><p>For example, the following regular expression extracts all integers from a string:</p><a id="I_programlisting8_id315359"/><pre class="programlisting">my $t = "10 hello 25 moo 30 foo";
my @nums = $text =~ /\d+/g;</pre><p>After executing this code, <code class="literal">@nums</code> contains <code class="literal">(10, 25, 30)</code>. You can also use parentheses to capture only part of the string. For example, here’s how to capture only the values from a line containing lots of key-value pairs (such as <code class="literal">key=value</code>), separated by semicolons:</p><a id="I_programlisting8_id315380"/><pre class="programlisting">my @vals = $text =~ /[^=]+=([^;]+)/g;</pre><p>This regular expression first matches the keys through <code class="literal">[^=]+</code>, then it matches the <code class="literal">=</code> character that separates the keys and values, and then it matches the values <code class="literal">([^;]+)</code>. As you can see, the value part of the regular expression is wrapped in parentheses so the values are captured.</p><p>Here’s an example. Say you have a file with the following contents:</p><a id="I_programlisting8_id315404"/><pre class="programlisting">access=all; users=peter,alastair,bill; languages=awk,sed,perl</pre><p>and you write this one-liner:</p><a id="I_programlisting8_id315413"/><pre class="programlisting">perl -nle 'my @vals = $_ =~ /[^=]+=([^;]+)/g; print "@vals"'</pre><p>Running it outputs the following:</p><a id="I_programlisting8_id315421"/><pre class="programlisting">all peter,alastair,bill awk,sed,perl</pre><p>These are the values for the <code class="literal">access</code>, <code class="literal">users</code>, and <code class="literal">languages</code> keys!</p></div></section></body></html>