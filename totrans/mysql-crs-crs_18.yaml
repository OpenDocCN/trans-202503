- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tips and Tricks
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll build confidence in your new MySQL skills by reviewing
    common pitfalls and how to avoid them. Then, you’ll look at transactions and the
    MySQL command line client. You’ll also learn how to load data to and from files.
  prefs: []
  type: TYPE_NORMAL
- en: Common Mistakes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL can process sets of information very quickly. You can update thousands
    of rows in the blink of an eye. While this gives you a lot of power, it also means
    there is greater potential for mistakes, like running SQL against the wrong database
    or server or running partial SQL statements.
  prefs: []
  type: TYPE_NORMAL
- en: Working in the Wrong Database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with relational databases like MySQL, you need to be cognizant
    of which database you’re working in. It’s surprisingly common to run a SQL statement
    in the wrong one. Let’s look at some ways you can avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: Say you’ve been asked to create a new database called `distribution` and to
    create a table called `employee`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might use these SQL commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you’re using MySQL Workbench to run the commands, you’ll see two green checkmarks
    in the lower panel telling you that your database and table were successfully
    created ([Figure 14-1](#figure14-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c14/f14001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-1: You used MySQL Workbench to create an `employee` table in the
    `distribution` database . . . didn’t you?'
  prefs: []
  type: TYPE_NORMAL
- en: Everything looks good, so you declare victory and move on to your next task.
    Then you start to get calls saying that the table wasn’t created. What went wrong?
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you created the `distribution` database, you didn’t set your current
    database to `distribution` before you created the table. Your new `employee` table
    instead was created in whatever your current database happened to be at the time.
    You should have included the `use` command before you created the table, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'One way to avoid creating a table in the wrong database is to *fully qualify*
    the table name when you create it. You can specify the name of the database to
    create the table in, so that even if you aren’t currently in that database, the
    table will be created there. Here you specify that you want to create the `employee`
    table in the `distribution` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way you could have avoided creating the table in the wrong database
    is by checking what your current database was before creating the table, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If your result was anything other than `distribution`, this would have alerted
    you that you forgot to correctly set your current database with the `use` command.
  prefs: []
  type: TYPE_NORMAL
- en: You can fix such a mistake by figuring out which database the `employee` table
    was created in, dropping the table, and then re-creating the `employee` table
    in the `distribution` database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine which database or databases have an `employee` table, run this
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ve queried the `tables` table in the `information_schema` database, and
    selected the `create_time` column to see if this table was created recently. The
    output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It’s possible that you could have different tables named `employee` in more
    than one database. If that were the case, your query would have returned more
    than one row. But in this example, the only database with an `employee` table
    is `bank`, so that’s where your table was mistakenly created.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an extra check, see how many rows are in the `employee` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There are no rows in this table, which is expected for a table that was created
    by mistake. Confident that the `employee` table in the `bank` database is the
    one you accidentally created in the wrong place, you can now run these commands
    to correct your mistake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Your `employee` table in the `bank` database has been removed, and an `employee`
    table in the `distribution` database has been created.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could have moved the table from one database to the other with the `alter
    table` command instead, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It’s preferable to drop and re-create a table rather than altering the table,
    however, especially if the table has triggers or foreign keys associated with
    it that might still be pointing to the wrong database.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Wrong Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, SQL statements can be executed against the wrong MySQL server. Companies
    often set up different servers for production and development. The *production*
    environment is the live environment that end users access, so you want to be careful
    with its data. The *development* environment is where developers test new code.
    Since the data in this environment is seen only by developers, you should always
    test your SQL statements here before releasing them to production.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s not unusual for a developer to have two windows open: one connected to
    the production server and one connected to the development server. If you’re not
    careful, you can make changes in the wrong window.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using a tool like MySQL Workbench, consider naming your connections
    *Production* and *Development* so that its tabs clearly state which environment
    is which (see [Figure 14-2](#figure14-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c14/f14002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-2: Naming the MySQL Workbench tabs Development and Production'
  prefs: []
  type: TYPE_NORMAL
- en: To name connections in MySQL Workbench, go to **Database**▶**Manage Connections**.
    In the Setup New Connection window that opens, enter a connection name like Development
    or Production that specifies the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Other tools have similar ways to mark production and development environments.
    Some allow you to change the background color, so you might consider setting your
    production screen to red as a reminder to be careful in that environment.
  prefs: []
  type: TYPE_NORMAL
- en: Leaving where Clauses Incomplete
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you insert, update, or delete data in a table, it’s crucial that your `where`
    clause is complete. If it isn’t, you run the risk of changing unintended rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you own a used car dealership and you store the cars you have in stock
    in the `inventory` table. Check what’s in the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Looking at a Ford Focus on the lot, you notice that you have it listed as green,
    but its color is actually closer to blue. You decide to update its color in the
    database ([Listing 14-1](#listing14-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-1: An `update` statement with incomplete criteria in the `where`
    clause'
  prefs: []
  type: TYPE_NORMAL
- en: When you run the `update` statement, you’re surprised to see MySQL return a
    message of `3 row(s) affected`. You meant to update only one row, but it appears
    that three rows were changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You run a query to see what happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Because the `where` clause in your `update` statement was missing criteria,
    you mistakenly updated the color of every Ford Focus in the table to `blue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `update` statement in [Listing 14-1](#listing14-1) should have been:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The last line is missing in [Listing 14-1](#listing14-1). With this additional
    criteria, the `update` statement would have changed just *green* Ford Focuses
    to blue. Since you had only one green Ford Focus on the lot, only the correct
    car would have been updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more efficient way to do the update would have been to use the VIN (Vehicle
    Identification Number) in your `where` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Since each car has a distinct VIN, with this approach you are guaranteed that
    your `update` statement will update just one vehicle.
  prefs: []
  type: TYPE_NORMAL
- en: Either of these `update` statements would have provided enough criteria to identify
    the one row you intended to change, and you would have updated just that row.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple sanity check you can perform before you insert, update, or delete
    rows is to `select` from the table using the same `where` clause. For example,
    if you were planning to run the `update` statement in [Listing 14-1](#listing14-1),
    you would run this `select` statement first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The results would have been:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The query produces a list of the rows that you are about to update. If you really
    wanted to update all three rows, you could then run the `update` statement that
    uses the same `where` clause. In this case, you would have recognized that this
    `where` clause in your `select` statement matched too many rows and could have
    avoided updating more than the single row you intended.
  prefs: []
  type: TYPE_NORMAL
- en: Running Partial SQL Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MySQL Workbench has three lightning bolt icons that can be used for executing
    SQL statements in different ways. Each icon’s actions are listed in [Table 14-1](#table14-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 14-1: Lightning Bolt Icons in MySQL Workbench'
  prefs: []
  type: TYPE_NORMAL
- en: '| Simple lightning bolt ![i14001](image_fi/503007c14/i14001.png) | Executes
    the selected statements or, if nothing is selected, all statements |'
  prefs: []
  type: TYPE_TB
- en: '| Cursor lightning bolt ![i14002](image_fi/503007c14/i14002.png) | Executes
    the statement under the keyboard cursor |'
  prefs: []
  type: TYPE_TB
- en: '| Magnifying glass lightning bolt ![i14003](image_fi/503007c14/i14003.png)
    | Executes the EXPLAIN plan for the statement under the cursor |'
  prefs: []
  type: TYPE_TB
- en: Most MySQL Workbench users will use the simple and cursor lightning bolt icons
    for their day-to-day work. The magnifying glass lightning bolt is used less often,
    as it is an optimization tool that explains what steps MySQL would take to run
    your query.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use the simple lightning bolt icon without realizing part of your SQL
    statement is highlighted, you’ll inadvertently run that highlighted section. For
    example, say you want to delete the Toyota Prius from the `inventory` table. You
    write the following `delete` statement to delete the car with the Prius’s VIN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, you’ll use MySQL Workbench to run your `delete` statement ([Figure 14-3](#figure14-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c14/f14003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-3: Mistakenly deleting all rows in the table using MySQL Workbench'
  prefs: []
  type: TYPE_NORMAL
- en: When you click the simple lightning bolt icon, MySQL tells you that all rows
    in the table were deleted. What happened?
  prefs: []
  type: TYPE_NORMAL
- en: Before you ran the `delete` statement, you mistakenly highlighted the first
    line of the SQL command. This told MySQL to delete all rows in the table, rather
    than the one you attempted to specify.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can lessen the possibility of mistakes by executing statements as part
    of a transaction. A *transaction* is a group of one or more SQL statements that
    can be *committed* (made permanent) or *rolled* *back* (canceled). For example,
    before updating your `inventory` table, you could use the `start transaction`
    command to begin a transaction that you can later commit or roll back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `begin` command is an alias for `start transaction`. You can use either.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run your `update` statement and MySQL returns a message of `3 row(s)
    affected`, but you were expecting one row to be changed, you can roll back the
    transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Your `update` gets rolled back, the changes are canceled, and the rows remain
    unchanged in the table. To make the changes permanent, commit the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Transactions are helpful when you’re using Data Manipulation Language (DML)
    statements like `insert`, `update`, or `delete`. Data Definition Language (DDL)
    statements like `create function`, `drop procedure`, or `alter table` shouldn’t
    be made in a transaction. They can’t be rolled back—running them will automatically
    commit the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Until you commit or roll back your `update` statement, MySQL will keep the table
    locked. For example, if you run these commands
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: the `inventory` table will remain locked and no other users will be able to
    make changes to its data until you commit or roll back your changes. If you start
    the transaction and then go to lunch without committing or rolling it back, you
    might come back to some angry database users.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting an Existing System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may find yourself supporting a MySQL system that has already been developed.
    A good way to start to understand an existing system is by browsing through its
    database objects using MySQL Workbench ([Figure 14-4](#figure14-4)).
  prefs: []
  type: TYPE_NORMAL
- en: You can learn a lot about an existing system by exploring using MySQL’s navigator
    panel. Are there many databases with a few tables in each one, or are there one
    or two databases with a lot of tables in each? What are the naming conventions
    you should follow? Are there many stored procedures, or is most of the business
    logic handled outside of MySQL in a programming language like PHP or Python? Have
    primary and foreign keys been set up for most tables? Do they use many triggers?
    Looking at the procedures, functions, and triggers, which delimiter do they use?
    Check the existing database objects and follow that lead when it comes to naming
    conventions for any new code you add to the system.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c14/f14004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-4: Exploring an existing MySQL database'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the hardest part of supporting an existing system is understanding
    the problem set and terminology of the application. A good first question for
    you to ask is, “What are the most important tables?” Focus your attention on learning
    about them first. You can select from the table and understand how those primary
    key values uniquely identify the rows in the table. Check for triggers on those
    tables and look through the trigger code to understand what actions happen automatically
    when data in the tables is changed.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL Workbench also presents a nice graphical depiction of the way that MySQL
    objects hang together. For example, you can see in [Figure 14-4](#figure14-4)
    that databases have tables, stored procedures, and functions. Tables have columns,
    indexes, foreign keys, and triggers.
  prefs: []
  type: TYPE_NORMAL
- en: Using the MySQL Command Line Client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MySQL command line client, `mysql`, allows you to run SQL commands from
    the command line interface of your computer (often called the *console*, *command*
    *prompt*, or *terminal*). This is useful in situations where you want to run SQL
    statements against a MySQL database but don’t need a graphical user interface
    like MySQL Workbench.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the command line of your computer, enter `mysql` to start the MySQL command
    line client tool, and supply additional information like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can also use single-letter options with a single dash—for example, `-h`
    instead of `--host`; `-D` for `--database`; and `-u` and `-p` for `--user` and
    `--password=`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: You specify the host where the MySQL server is located with `--host`. In this
    example, the MySQL server is installed on my computer, so I’ve supplied the value
    `localhost`. If you’re connecting to a server that’s installed on another computer,
    you can the specify the host, like `--host www.nostarch.com`, or supply an IP
    address.
  prefs: []
  type: TYPE_NORMAL
- en: Then, enter the name of the database you want to connect to after `--database`,
    your MySQL user ID after `--user`, and your MySQL password after the `--password=`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see this warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s because you supplied the database password in plaintext. This isn’t
    a great idea, as anyone looking over your shoulder could see your password. A
    more secure approach is to let `mysql` prompt you for it. If you use `-p` at the
    command line without specifying the password, the tool will prompt you to enter
    the password. As you type the letters of the password, asterisks will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach is to use the MySQL configuration utility to securely store
    your credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You specify host and user with the `--host` and `--user` options. The `--password`
    option allows you to enter your password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have saved credentials, you can use the `print --all` option to show
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The password appears as asterisks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can enter the MySQL command line client, `mysql`, at the command line
    without having to enter your username, password, or host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In other words, you can log in to MySQL by providing only the name of the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might wonder why you would use a text-based tool like `mysql` when more
    sophisticated graphical tools like MySQL Workbench are available. The `mysql`
    tool is particularly useful when you want to run SQL statements that are in a
    script file. A *script file* is a set of SQL commands saved in a file on your
    computer. For example, you could create a file called *max_and_min_indexes.sql*
    that contains the following SQL statements, which get the market index with the
    smallest and largest values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then run the SQL script from your command line using `mysql`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You used `<` so that `mysql` will take its input from the *min_and_max.sql*
    script, and `>` so that it will write its output to the *min_and_max.txt* file.
    If you supply the password, in this case `icu2`, don’t add a space after `-p`.
    Strangely, `-picu2` works but `-p icu2` does not.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you run the command, the output file *min_and_max.txt* should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `mysql` tool writes a tab between the columns in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Loading Data from a File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Oftentimes you’ll get data in the form of files, such as accepting a data feed
    from another organization. The `load data` command reads data from a file and
    writes it into a table.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test loading data from a file into a table, I created a data file on my
    computer called *market_indexes.txt* in the *C:\Users\rick\market\* directory.
    The file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The file contains the names and current value of three financial market indexes.
    It is *tab-delimited*, which means that the fields in the file are separated by
    the tab character.
  prefs: []
  type: TYPE_NORMAL
- en: 'In MySQL, load the file into a table like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You use the `load data` command and specify `local`, which tells MySQL to look
    for the data file on your local computer, not on the server where MySQL is installed.
    By default, `load data` loads tab-delimited files.
  prefs: []
  type: TYPE_NORMAL
- en: After the `infile` keyword, you give the name of the input file you want to
    load. In this example, you’re using the path of a file on a Windows computer.
    To specify the directory where the file is located on Windows, use forward slashes,
    as backslashes will result in an error. To load a file in a Mac or Linux environment,
    use forward slashes as usual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the data that was loaded into the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: There were two fields in the file and two columns in the table, so the fields
    on the left were loaded into the first column and the fields on the right were
    loaded into the second column in the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common data file format is a *comma-separated values (CSV)* file. You
    could have loaded a data file called *market_indexes.csv* that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: To load this file, add the syntax `fields terminated by ","` to declare the
    delimiter in this file as a comma. MySQL uses the commas in the data file to identify
    the beginning and end of the fields.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Occasionally, you’ll want to load a data file that has a header row, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can have `load data` skip the header by using the `ignore` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: There was one header line in the data file, so you used the `ignore 1 lines`
    syntax to prevent the first line from loading into the table. The three rows of
    data are loaded, but the `Financial Index` and `Current Value` headings in the
    data file are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Loading Data to a File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can provide data to another department or organization by sending data files.
    One way to write data from the database to a file is to use the syntax `select...into
    outfile`. You can run queries and select the results to a file rather than to
    your screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify which delimiters you want to use to format the output. Create
    a CSV file containing the values in the `market_index` table like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You select all values from the `market_index` table and write them to the *market_index.csv*
    file in the *C:/ProgramData/MySQL/MySQL Server 8.0/Uploads* directory on the host
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: You use commas as the delimiter in your output file by using the syntax `fields
    terminated by ','`.
  prefs: []
  type: TYPE_NORMAL
- en: The `optionally enclosed by` `'"'` line tells MySQL to wrap fields in quotes
    for any columns that have a `string` data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your *market_index.csv* gets created like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `select...into outfile` syntax can create a file only on the server where
    MySQL is running. It can’t create a file on your local computer.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the MySQL command line client (`mysql`) is a tried-and-true way to run
    SQL commands that has been used for decades, MySQL Shell (`mysqlsh`) is a newer
    MySQL command line client tool that can run SQL, Python, or JavaScript commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'You saw earlier that the `mysql` syntax to run a script called *min_and_max.sql*
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer, you could use MySQL Shell to run that same script using this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The syntax is similar, except you call `mysqlsh` instead of `mysql`. Also, since
    `mysqlsh` can run in SQL, Python, or JavaScript mode, you need to specify `--sql`
    to run in SQL mode. (The default mode is JavaScript.)
  prefs: []
  type: TYPE_NORMAL
- en: MySQL Shell comes with a handy utility called *parallel table import* (`import-table`)
    that can load large data files to tables faster than `load data`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When you use the `import-table` utility, you need to call `mysqlsh` with the
    `--mysql` syntax ❶ to use a classic MySQL protocol connection to communicate between
    the client and the MySQL server.
  prefs: []
  type: TYPE_NORMAL
- en: To run the parallel table import utility, use the `-- util` syntax and then
    give the name of the utility you want to use—in this case, `import-table` ❷. You
    provide the name of the file you want to load, *c:\Users\rick\market_indexes.txt*,
    and the database, `investment`, as well as the table that you want to load the
    data into, `market_index`.
  prefs: []
  type: TYPE_NORMAL
- en: The choice to use `mysql` or `mysqlsh` is yours. As `mysqlsh` matures, more
    developers will move to it and away from `mysql`. If you have a large data load
    that is slow to run, using `mysqlsh` with its parallel table import utility will
    be considerably faster than using `load data`.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about MySQL Shell at [https://dev.mysql.com/doc/mysql-shell/8.0/en/](https://dev.mysql.com/doc/mysql-shell/8.0/en/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you looked at some tips and tricks, including how to avoid
    making common mistakes, use transactions, support existing systems, and load data
    to and from files.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll call MySQL from programming languages like PHP,
    Python, and Java.
  prefs: []
  type: TYPE_NORMAL
