- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Optimizing Performance
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: This chapter is aimed squarely at developers who want lightning-fast applications
    and are willing to take the time to make that happen. We’ll first discuss profiler
    tools to evaluate WebAssembly module performance and investigate how to compare
    the performance of WebAssembly with similar JavaScript code. We’ll spend some
    time looking at strategies to improve the performance of our WebAssembly, including
    inlining functions, replacing multiplication and division with bit-shifts, combining
    constants, and removing code using Dead Code Elimination (DCE).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门面向那些希望实现极速应用程序并愿意为此付出时间和精力的开发人员。我们将首先讨论性能分析工具，评估WebAssembly模块性能，并研究如何将WebAssembly的性能与类似的JavaScript代码进行比较。我们还将探讨一些提升WebAssembly性能的策略，包括内联函数、用位移操作替代乘法和除法、合并常量，以及使用死代码消除（DCE）删除冗余代码。
- en: 'We’ll also delve into other methods for determining a module’s performance:
    we’ll use `console.log` and `Date.now` to measure our application’s performance
    and use the testing suite *benchmark.js* to gather detailed performance data for
    an application. Then, just for fun, we’ll print the Chrome JavaScript V8 engine’s
    Intermediate Representation (IR) bytecode for a JavaScript function. JavaScript
    IR bytecode can give you insight into the work a JavaScript function does, which
    is helpful for evaluating whether to write a function in WebAssembly or JavaScript.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨确定模块性能的其他方法：我们将使用`console.log`和`Date.now`来衡量应用程序的性能，并使用测试工具*benchmark.js*来收集应用程序的详细性能数据。然后，为了好玩，我们将打印出Chrome
    JavaScript V8引擎的中间表示（IR）字节码。JavaScript IR字节码可以帮助你了解JavaScript函数的工作原理，这对于评估是否使用WebAssembly或JavaScript编写函数非常有帮助。
- en: Using a Profiler
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用性能分析器
- en: '*Profilers* are tools that analyze different aspects of an application’s performance,
    including the app’s memory usage and execution time. This can help you make decisions
    about where to optimize and what to optimize for. You’ll often need to make trade-offs
    between different types of optimizations. For example, you’ll need to decide whether
    to focus on improving your time to interactive (TTI) so users can begin using
    your application as soon as possible or focusing on peak performance once your
    application is up and running. If you’re writing a game, it’s worth having a long
    load time to ensure the game will run more smoothly once it finishes downloading.
    However, an online store might prefer to ensure the user can interact with the
    website as soon as possible. In most cases, you’ll need to balance between the
    two, and using a profiler can help.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*性能分析器*是用来分析应用程序性能的工具，包括应用程序的内存使用和执行时间。这可以帮助你做出关于优化的决策，确定优化的方向和重点。你通常需要在不同类型的优化之间做出权衡。例如，你需要决定是优先提升交互时间（TTI），以便用户能够尽快使用你的应用程序，还是在应用程序运行时优化峰值性能。如果你正在开发一款游戏，可能需要较长的加载时间，以确保游戏在下载完成后能够顺畅运行。然而，在线商店可能更倾向于确保用户尽快与网站进行交互。在大多数情况下，你需要在这两者之间找到平衡，使用性能分析器可以帮助你做出这个决策。'
- en: Profilers are also efficient at finding bottlenecks in your code, allowing you
    to focus your time and effort in those locations. We’ll look at the Chrome and
    Firefox profilers, because they currently have the best support for WebAssembly.
    We’ll be profiling the collision detection app from Chapter 8.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析器还非常高效地帮助你发现代码中的瓶颈，帮助你将时间和精力集中在这些关键区域。我们将关注Chrome和Firefox的性能分析器，因为它们目前对WebAssembly提供了最好的支持。我们将对第8章中的碰撞检测应用进行性能分析。
- en: Chrome Profiler
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Chrome 性能分析器
- en: You’ll want to use a new incognito browser window with the Chrome profiler.
    Incognito windows don’t load website caches, cookies, or Chrome plug-ins, which
    cause problems when profiling because they run additional JavaScript code and
    affect the performance of the site you want to profile. The caches and cookies
    are usually less problematic, but can clutter your environment with data unrelated
    to the code you’re profiling. You can open an incognito window from the menu on
    the top right of your web browser by clicking **New incognito window**, as shown
    in [Figure 9-1](#figure9-1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Chrome性能分析器时，你需要使用一个新的隐身浏览器窗口。隐身窗口不会加载网站缓存、Cookies或Chrome插件，这些都会在分析时引发问题，因为它们会运行额外的JavaScript代码并影响你想要分析的站点性能。缓存和Cookies通常问题不大，但它们会把与你分析的代码无关的数据引入你的环境。你可以通过点击浏览器右上角菜单中的**新建隐身窗口**来打开隐身窗口，如[图9-1](#figure9-1)所示。
- en: '![f09001](Images/f09001.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![f09001](Images/f09001.png)'
- en: 'Figure 9-1: Open an incognito window in Chrome.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-1：在 Chrome 中打开隐身窗口。
- en: After opening an incognito browser window, make sure you’re running a web server
    using the command `node server.js` from your command line and enter **localhost:8080/collide.html**
    into your web browser. Click **More Tools**▶**Developer tools** from the menu
    in the top right, as shown in [Figure 9-2](#figure9-2).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 打开隐身浏览器窗口后，确保在命令行中使用`node server.js`命令运行一个Web服务器，然后在浏览器中输入**localhost:8080/collide.html**。从右上角菜单中点击**更多工具**▶**开发者工具**，如[图
    9-2](#figure9-2)所示。
- en: '![f09002](Images/f09002.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![f09002](Images/f09002.png)'
- en: 'Figure 9-2: Open the Developer tools in Chrome.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2：在 Chrome 中打开开发者工具。
- en: You should see several tabs across the top of the Developer tools. To see the
    profiler, click **Performance**, as shown in [Figure 9-3](#figure9-3).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到开发者工具顶部的多个标签。要查看性能分析器，点击**性能**，如[图 9-3](#figure9-3)所示。
- en: '![f09003](Images/f09003.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![f09003](Images/f09003.png)'
- en: 'Figure 9-3: Open the Performance tab in Chrome.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-3：在 Chrome 中打开性能标签。
- en: 'The Performance tab offers two options when you initially open it: Record and
    Reload. The Record button begins recording a profile without reloading the application.
    This kind of profiling is most important when you’re less concerned about the
    startup time of your application and more concerned with peak performance. Before
    we profile, make sure the Memory checkbox at the top of the Performance tab is
    selected. If it isn’t, the memory heap won’t be profiled. If you want to profile
    your application from initialization, you would click the Reload button. Click
    **Record** to continue. Once you’ve recorded for about five seconds, click **Stop**
    as shown in [Figure 9-4](#figure9-4).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 性能标签在你第一次打开时提供两个选项：记录和重新加载。记录按钮会在不重新加载应用程序的情况下开始录制性能数据。这种性能分析最适用于你不太关心应用程序启动时间，而更关注峰值性能的情况。在我们开始性能分析之前，确保在性能标签的顶部勾选了内存复选框。如果没有勾选，内存堆将不会被分析。如果你希望从应用初始化开始进行性能分析，可以点击重新加载按钮。点击**记录**继续。一旦录制了大约五秒钟，点击**停止**，如[图
    9-4](#figure9-4)所示。
- en: '![f09004](Images/f09004.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![f09004](Images/f09004.png)'
- en: 'Figure 9-4: Recording a profile in Chrome'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-4：在 Chrome 中录制性能数据
- en: When recording stops, the profiler will open and show a recording of every frame
    rendered by your application. A Summary tab in the bottom half shows that the
    vast majority of this application’s execution time is tied up in Scripting ([Figure
    9-5](#figure9-5)), which includes JavaScript and WebAssembly time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当录制停止后，性能分析器会打开，并展示应用程序渲染的每一帧记录。底部的摘要标签显示，应用程序执行的大部分时间都花费在了脚本执行（[图 9-5](#figure9-5)），这包括
    JavaScript 和 WebAssembly 时间。
- en: '![f09005](Images/f09005.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![f09005](Images/f09005.png)'
- en: 'Figure 9-5: Chrome Performance tab after recording the profile'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-5：录制性能数据后的 Chrome 性能标签
- en: On this main Performance page, a pie chart shows the processing time spent Scripting,
    Rendering, Painting, System, and Idle. Above the pie chart is a series of tabs,
    including Summary, Bottom-Up, Call Tree, and Event Log,all of which we’ll explore
    in this chapter. The section above these tabs shows the JS Heap memory allocated,
    and above that, the rendered frames, CPU, and FPS information. Let’s take a quick
    look at the JavaScript heap memory in the next section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主要的性能页面中，一个饼图展示了在脚本执行、渲染、绘制、系统和空闲时间中花费的处理时间。饼图上方是一些标签，包括摘要、从下到上、调用树和事件日志，我们将在本章中进行探讨。以上这些标签的上方显示了分配的
    JS 堆内存，此外，还有渲染的帧数、CPU 和 FPS 信息。接下来，我们将快速查看 JavaScript 堆内存。
- en: JavaScript Heap Memory
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JavaScript 堆内存
- en: The profile in [Figure 9-5](#figure9-5) shows that there’s been a growth in
    heap memory. We’ll spend a little time investigating why this is happening. First,
    we’ll check how much memory is allocated before it’s garbage collected. Some developers
    believe that because JavaScript is a garbage collected language, they don’t need
    to be concerned about memory. Unfortunately, that’s not the case; it’s still possible
    for your code to create objects faster than they can be garbage collected. It’s
    also possible to hold on to references to objects longer than they’re needed,
    leaving JavaScript unable to know if it should delete them. If an application
    is growing in memory size as quickly as this one is, it makes sense to watch how
    much memory is allocated before garbage collection. Then try to understand where
    the application allocates memory. Right now, the heap size is about 1MB.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-5](#figure9-5) 中的分析显示堆内存有增长。我们将花些时间调查为什么会发生这种情况。首先，我们检查在垃圾回收前分配了多少内存。一些开发者认为，因为
    JavaScript 是一种垃圾回收语言，所以他们不需要担心内存问题。不幸的是，这并非如此；你的代码仍然可能创建对象的速度超过垃圾回收器能回收它们的速度。也有可能将对象的引用保持得比实际需要的时间更长，这样
    JavaScript 无法判断是否应该删除这些对象。如果一个应用程序的内存增长速度像这个一样快，那么监控垃圾回收前分配的内存是很有意义的。然后，尝试理解应用程序在哪里分配了内存。目前，堆内存的大小大约是
    1MB。'
- en: After some additional profiling, we can see that the JS Heap grows to 2.2MB,
    and after the garbage collector runs, the heap size drops back down to 1.2MB.
    It might take several minutes before the garbage collector runs, so please be
    patient. [Figure 9-6](#figure9-6) shows the profile of the JS Heap during garbage
    collection. As you can see, on the right side of the graph, the size of the heap
    takes a sudden significant drop in size of 1MB.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些额外的性能分析后，我们可以看到 JS 堆内存增长到 2.2MB，而在垃圾回收器运行后，堆内存大小降回到 1.2MB。垃圾回收器运行可能需要几分钟，所以请耐心等待。[图
    9-6](#figure9-6) 显示了垃圾回收过程中 JS 堆内存的变化情况。如你所见，在图表的右侧，堆内存大小突然显著下降了 1MB。
- en: '![f09006](Images/f09006.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![f09006](Images/f09006.png)'
- en: 'Figure 9-6: Memory drop during garbage collection'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-6：垃圾回收期间的内存下降
- en: It’s best to determine precisely where this memory allocation is happening,
    because if we could slow the growth of the heap, it would potentially reduce the
    burden on the garbage collector.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最好精确地确定这个内存分配发生的位置，因为如果我们能减缓堆内存的增长，它有可能减少垃圾回收器的负担。
- en: Following the Memory Allocation
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内存分配跟踪
- en: Because the growth of the heap is consistent, we can deduce that memory allocation
    is likely happening every frame render. The majority of the work this application
    does is in the WebAssembly module, so we first comment out the WebAssembly call
    to see whether the memory continues to show the same JS Heap growth profile. Open
    *collide.html* and comment out the call to `animation_wasm()` inside the `animate`
    function, as shown in [Listing 9-1](#listing9-1).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于堆内存的增长是持续的，我们可以推测内存分配可能发生在每一帧的渲染过程中。这个应用程序的大部分工作都在 WebAssembly 模块中完成，因此我们首先注释掉
    WebAssembly 的调用，看看内存是否继续显示相同的 JS 堆增长分析。打开 *collide.html*，并如 [清单 9-1](#listing9-1)
    所示，注释掉 `animate` 函数内的 `animation_wasm()` 调用。
- en: '**collide.html**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**collide.html**'
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 9-1: Commenting out the `animation_wasm` function call'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-1：注释掉 `animation_wasm` 函数调用
- en: Now reload the page and record a new profile. [Figure 9-7](#figure9-7) shows
    the new JS Heap profile without the `animation_wasm` function call.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新加载页面并记录一个新的性能分析。[图 9-7](#figure9-7) 显示了没有 `animation_wasm` 函数调用的新的 JS 堆内存分析。
- en: '![f09007](Images/f09007.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![f09007](Images/f09007.png)'
- en: 'Figure 9-7: Heap memory allocation graph after the `animation_wasm`function
    is removed'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-7：`animation_wasm` 函数移除后的堆内存分配图
- en: Without the call to the WebAssembly module, the app no longer functions properly.
    However, you can still see the same JS Heap growth profile, so the growth in memory
    doesn’t appear to be coming from the WebAssembly module. Let’s uncomment the call
    to the WebAssembly module; then comment out the call to `ctx.putImageData` and
    create another profile, as shown in [Listing 9-2](#listing9-2).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 没有对 WebAssembly 模块的调用后，应用程序无法正常运行。然而，你仍然可以看到相同的 JS 堆内存增长分析，因此内存的增长似乎不是来自 WebAssembly
    模块。接下来，我们取消注释 WebAssembly 模块的调用，然后注释掉 `ctx.putImageData` 的调用，并创建另一个性能分析，正如 [清单
    9-2](#listing9-2) 所示。
- en: '**collide.html**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**collide.html**'
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 9-2: The `animation_wasm` function is back in; `putImageData` is removed.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-2：`animation_wasm` 函数已恢复，`putImageData` 被移除。
- en: With the call to `ctx.putImageData` commented out, we can now create a new profile
    to check the memory growth ([Figure 9-8](#figure9-8)).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释掉 `ctx.putImageData` 调用后，我们现在可以创建一个新的分析结果来检查内存增长情况（[图 9-8](#figure9-8)）。
- en: '![f09008](Images/f09008.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![f09008](Images/f09008.png)'
- en: 'Figure 9-8: Memory growth is slower when the `putImageData` call is removed.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-8：移除 `putImageData` 调用时，内存增长变慢。
- en: Without the call to `ctx.putImageData`, the memory growth slowed tremendously.
    Growth is still occurring, but it has a slower stair step growth pattern rather
    than an almost straight vertical line up. It appears that the call to `ctx.putImageData`
    is internally creating large objects that the garbage collector will eventually
    need to remove. Now we know how that memory is being allocated. Because `ctx.putImageData`
    is a built-in function, there isn’t anything we can do to optimize it. If memory
    allocation had been the problem, we would need to look into an alternative means
    to render to the canvas.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有 `ctx.putImageData` 调用的情况下，内存增长明显变慢。虽然增长依然存在，但其增长呈现较慢的阶梯型模式，而不是几乎垂直的直线。这表明，`ctx.putImageData`
    调用内部可能正在创建一些大型对象，垃圾回收器最终需要删除它们。现在我们知道内存是如何分配的。由于 `ctx.putImageData` 是一个内置函数，我们无法优化它。如果内存分配是问题所在，我们就需要寻找其他方式来渲染到画布上。
- en: Frames
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 帧
- en: In the Profiler window is an area above the heap memory that provides more performance
    information, including the frames per second (fps) rendered. It also shows a graph
    that displays CPU usage. And there are small thumbnails of each frame rendered.
    When you move your mouse over these frames, you can watch how your application
    rendered its animation ([Figure 9-9](#figure9-9)), which can be very helpful if
    your application isn’t working as expected.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析器窗口中，堆内存上方有一个区域，提供更多的性能信息，包括渲染的每秒帧数（fps）。它还显示了一个显示 CPU 使用率的图表，并展示了每一帧渲染的小缩略图。当你将鼠标悬停在这些帧上时，你可以观察到应用程序如何渲染其动画（[图
    9-9](#figure9-9)），这对你调试应用程序是否按预期工作非常有帮助。
- en: '![f09009](Images/f09009.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![f09009](Images/f09009.png)'
- en: 'Figure 9-9: Viewing the individual frame render in the profiler'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-9：在分析器中查看单独的帧渲染
- en: You can hover your mouse over the green *Frames* boxes to see the fps at any
    point in the profile ([Figure 9-10](#figure9-10)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将鼠标悬停在绿色的*Frames*框上，查看分析中任意时刻的 fps（[图 9-10](#figure9-10)）。
- en: '![f09010](Images/f09010.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![f09010](Images/f09010.png)'
- en: 'Figure 9-10: Viewing fps in the profiler'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-10：在分析器中查看 fps
- en: As you can see, the frame rate at this point in the application’s execution
    is 18 fps. When we scrub over the frames, the number hovers between 17 and 20\.
    Frames per second is the primary measure of performance for the collision detection
    app, so we’ll need to remember the profile showing us roughly 18 fps to compare
    it with later results. Keep in mind that running the profiler appears to harm
    the app’s performance, so although the results are useful relative to each other,
    they might not be totally accurate on how the app runs in the wild.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在应用程序执行的这一时刻，帧率为 18 fps。当我们拖动帧时，帧数在 17 和 20 之间徘徊。每秒帧数是碰撞检测应用性能的主要衡量标准，因此我们需要记住大约
    18 fps 的分析结果，以便与之后的结果进行比较。请记住，运行分析器似乎会影响应用程序的性能，因此尽管这些结果在相互比较时很有用，但它们可能并不完全准确地反映应用程序在实际环境中的表现。
- en: Bottom-Up
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自下而上
- en: The Bottom-Up tab shows the functions called within the application, the total
    time they ran, and the Self Time, which is the amount of time the function ran
    excluding the time spent in the functions they call. Self Time is very useful
    because functions that call other functions that take a long time to run will
    always show a longer Total Time, as you can see in [Figure 9-11](#figure9-11).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 自下而上的标签显示了应用程序内调用的函数、它们运行的总时间以及自时间（Self Time），即函数运行的时间，排除了它调用的其他函数所花费的时间。自时间非常有用，因为调用其他运行时间较长的函数的函数，总时间总是会比较长，正如你在[图
    9-11](#figure9-11)中看到的那样。
- en: '![f09011](Images/f09011.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![f09011](Images/f09011.png)'
- en: 'Figure 9-11: Chrome’s Bottom-Up tab window'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-11：Chrome 的自下而上标签窗口
- en: The Self Time for `<wasm-unnamed>` is by far the longest. The Total Time is
    longer in several functions, such as `animate`, because the `animate` function
    calls the WebAssembly module. It’s a bit disappointing that Chrome doesn’t indicate
    which function it calls inside the WebAssembly module, but we can determine at
    a glance that the application spends more than 90 percent of its processing time
    executing WebAssembly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`<wasm-unnamed>`的自时间是最长的。总时间在多个函数中更长，例如`animate`，因为`animate`函数调用了WebAssembly模块。令人有些失望的是，Chrome没有指出它在WebAssembly模块中调用了哪个函数，但我们可以一眼看出，应用程序有超过90%的处理时间是在执行WebAssembly。'
- en: Firefox Profiler
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Firefox性能分析器
- en: Using the Firefox profiler is another excellent way to gather performance data
    on your application. I recommend opening a private window when you run the Firefox
    profiler. Do this by opening the menu in the top right of the browser and clicking
    **New Private Window** ([Figure 9-12](#figure9-12)).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Firefox性能分析器是收集应用程序性能数据的另一种优秀方式。我建议在运行Firefox性能分析器时打开一个私人窗口。可以通过打开浏览器右上角的菜单，点击**新建私人窗口**来实现（[图9-12](#figure9-12)）。
- en: '![f09012](Images/f09012.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![f09012](Images/f09012.png)'
- en: 'Figure 9-12: Open a New Private Window in Firefox.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-12：在Firefox中打开一个新的私人窗口。
- en: Open the profiler by clicking **Web Developer**▶**Performance** ([Figure 9-13](#figure9-13)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**Web开发者**▶**性能**来打开性能分析器（[图9-13](#figure9-13)）。
- en: '![f09013](Images/f09013.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![f09013](Images/f09013.png)'
- en: 'Figure 9-13: Click **Web Developer**▶**Performance** in the Firefox menu.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-13：在Firefox菜单中点击**Web开发者**▶**性能**。
- en: In the Performance menu, click the **Start Recording Performance** button to
    record performance data. After a few seconds, stop recording. [Figure 9-14](#figure9-14)
    shows something similar to what you should see in the Performance tab. The Waterfall
    tab (which is the default view after recording) shows the top-level function calls
    and how long they take to execute.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能菜单中，点击**开始录制性能**按钮以录制性能数据。几秒钟后，停止录制。[图9-14](#figure9-14)展示了你应该在性能标签中看到的内容类似的结果。Waterfall标签（这是录制后的默认视图）显示了顶级函数调用以及它们执行所需的时间。
- en: '![f09014](Images/f09014.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![f09014](Images/f09014.png)'
- en: 'Figure 9-14: Firefox Performance window Waterfall tab'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-14：Firefox性能窗口中的Waterfall标签
- en: Scroll down to see where the garbage collection takes place and how long it
    takes to run. This report is a bit boring for our application, which primarily
    executes `requestAnimationFrame`. The three tabs across the top of the window
    provide more information. The Waterfall tab gives you a general idea of where
    tasks are running long. We won’t go into detail about the Waterfall tab, because
    it’s more of a *runtime at a glance* summary. Instead we’ll look at the Call Tree
    and JS Flame Chart tabs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动以查看垃圾回收发生的位置以及执行所需的时间。对于我们的应用程序来说，这个报告有点无聊，因为它主要执行`requestAnimationFrame`。窗口顶部的三个标签提供了更多信息。Waterfall标签让你大致了解任务执行时间过长的地方。我们不会详细讲解Waterfall标签，因为它更像是一个*一目了然的运行时*总结。相反，我们将重点查看Call
    Tree和JS Flame Chart标签。
- en: Call Tree
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Call Tree
- en: The Call Tree tab shows the function calls in which the application spends most
    of its time. The interface allows you to drill down into each of the functions
    and see the calls they make. [Figure 9-15](#figure9-15) shows a screenshot of
    the Call Tree tab.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Call Tree标签显示了应用程序花费大部分时间的函数调用。该界面允许你深入查看每个函数，并查看它们调用了哪些函数。[图9-15](#figure9-15)展示了Call
    Tree标签的截图。
- en: '![f09015](Images/f09015.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![f09015](Images/f09015.png)'
- en: 'Figure 9-15: Firefox Call Tree tab'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-15：Firefox的Call Tree标签
- en: One nice feature is that you can click the name of your WebAssembly file, and
    the link will take you to the proper function in your WebAssembly code. The function
    names are lost, but an index showing the function number in WAT follows the `wasm-function`
    label. That makes it a little easier to determine what the function calls.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的功能是，你可以点击WebAssembly文件的名称，链接会将你带到WebAssembly代码中的相应函数。函数名称会丢失，但一个显示函数编号的索引会跟随`wasm-function`标签。这样可以稍微帮助确定函数调用的内容。
- en: JS Flame Chart
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JS Flame Chart
- en: The JS Flame Chart tab is pretty much the same information you see in the Call
    Tree tab, but it’s organized along a timeline instead of as a summary. You can
    zoom in on a specific portion of the chart to see which functions are running
    at that point in the profile ([Figure 9-16](#figure9-16)).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: JS Flame Chart标签显示的信息与Call Tree标签中看到的信息几乎相同，但它是按照时间线组织的，而不是作为总结。你可以放大图表的特定部分，查看在该时间点上执行的函数（[图9-16](#figure9-16)）。
- en: '![f09016](Images/f09016.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![f09016](Images/f09016.png)'
- en: 'Figure 9-16: Firefox JS Flame Chart tab'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-16：Firefox JS 火焰图标签
- en: Here is the call to the JavaScript `animate` function. The `animate` function
    spends most of its time running `wasm-function[6]`, which is the seventh function
    in our WAT code, called `$main`. The `$main` function calls `wasm-function[5]`,
    which is the sixth function (`$get_obj_attr`) and `wasm-function[1]` (`$abs`).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调用 JavaScript `animate` 函数的代码。`animate` 函数大部分时间运行 `wasm-function[6]`，这是我们
    WAT 代码中的第七个函数，名为 `$main`。`$main` 函数调用了 `wasm-function[5]`，即第六个函数（`$get_obj_attr`）和
    `wasm-function[1]`（`$abs`）。
- en: Each one of these tabs shows the minimum and maximum fps on the left side and
    the average fps on the right side. The left side of the profiler looks something
    like [Figure 9-17](#figure9-17).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个标签页都显示了最小和最大帧率在左侧，平均帧率在右侧。分析器的左侧类似于 [图 9-17](#figure9-17)。
- en: '![f09017](Images/f09017.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![f09017](Images/f09017.png)'
- en: 'Figure 9-17: Firefox max and min fps'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-17：Firefox 最大和最小帧率
- en: As you can see, the maximum fps is a bit more than 22, and the minimum is a
    little less than 5 fps. As mentioned earlier, running the profiler might impact
    the fps. The average fps is on the right side of the profiler ([Figure 9-18](#figure9-18)).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，最大帧率略高于 22，最小帧率略低于 5 fps。如前所述，运行分析器可能会影响帧率。平均帧率显示在分析器的右侧（[图 9-18](#figure9-18)）。
- en: '![f09018](Images/f09018.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![f09018](Images/f09018.png)'
- en: 'Figure 9-18: Firefox average fps'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-18：Firefox 平均帧率
- en: The average fps for this profile was approximately 14 fps. In the next section,
    we’ll look at how to improve the app’s performance using `wasm-opt`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置文件的平均帧率约为 14 fps。在下一节中，我们将探讨如何使用 `wasm-opt` 改善应用性能。
- en: wasm-opt
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: wasm-opt
- en: We use the `wasm-opt` command line tool to run performance optimizations on
    a WebAssembly file. It comes with `wat-wasm` and *Binaryen.js*. If you’ve installed
    `wat-wasm` to use for the `wat2wasm` tool, you should already have a version and
    can skip the next section. If not, install *Binaryen.js*, which is a JavaScript
    version of the Binaryen WebAssembly tool for converting an Intermediate Representation
    (IR) into WebAssembly code. It has some helpful options for optimizing WebAssembly
    code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `wasm-opt` 命令行工具对 WebAssembly 文件进行性能优化。它随 `wat-wasm` 和 *Binaryen.js* 一起提供。如果你已经安装了
    `wat-wasm` 来使用 `wat2wasm` 工具，那么你应该已经有一个版本，可以跳过下一节。如果没有，安装 *Binaryen.js*，它是 Binaryen
    WebAssembly 工具的 JavaScript 版本，用于将中间表示（IR）转换为 WebAssembly 代码。它提供了一些有用的选项来优化 WebAssembly
    代码。
- en: Installing Binaryen
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Binaryen
- en: 'There are several options for installing Binaryen. I recommend using *Binaryen.js*,
    which you can install using `npm` with the following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Binaryen 有几种选择。我推荐使用 *Binaryen.js*，你可以通过 `npm` 使用以下命令来安装：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For those interested in building it from the source, it’s available on GitHub
    at [https://github.com/WebAssembly/binaryen](https://github.com/WebAssembly/binaryen).
    There is also an `npm` package called `wasm-opt` that will install the platform-specific
    binaries for *Binaryen*, but I would recommend installing `wat-wasm` or *binaryen.js*
    using `npm` instead.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有兴趣从源代码构建的人，可以在 GitHub 上找到它，地址是 [https://github.com/WebAssembly/binaryen](https://github.com/WebAssembly/binaryen)。还有一个名为
    `wasm-opt` 的 `npm` 包，它会为*Binaryen* 安装特定平台的二进制文件，但我推荐使用 `npm` 安装 `wat-wasm` 或 *binaryen.js*。
- en: Running wasm-opt
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行 wasm-opt
- en: The `wasm-opt` tool has a number of flags you can use to minimize the download
    size and optimize the execution of your WebAssembly module. You use these flags
    to tell the optimizer whether to focus on performance or download size. If a change
    can be made to reduce the file size without affecting performance, that change
    will be made in either case. The same is true if a change can be made to improve
    the performance without affecting download size. These flags tell the compiler
    which optimization to prefer when there is a trade-off to consider.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-opt` 工具提供了许多标志，你可以使用这些标志来最小化下载大小并优化 WebAssembly 模块的执行。你可以使用这些标志告诉优化器是关注性能还是下载大小。如果有变动可以减少文件大小而不影响性能，那么无论如何都会进行修改。如果有变动可以改善性能而不影响下载大小，也是如此。这些标志告诉编译器在需要权衡时应该优先考虑哪种优化。'
- en: We’ll run `wasm-opt` against our *collide.wasm* file with both types of flags,
    starting with the size optimization preference and then compiling it again with
    a performance preference. These flags will be the same with any toolchain that
    uses Binaryen, such as Emscripten or AssemblyScript. The first two flags we’ll
    look at will optimize the WAT file for size.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两种标志运行`wasm-opt`，首先使用针对文件大小的优化偏好，然后再次编译以优化性能。这些标志适用于任何使用Binaryen的工具链，如Emscripten或AssemblyScript。我们首先将查看的两个标志会优化WAT文件的大小。
- en: Optimizing for Download Size
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 针对下载大小的优化
- en: 'The `wasm-opt` command has two flags that optimize your WebAssembly file for
    download size: `-Oz` and `-Os`. The O is a capital letter O, not a zero. The `-Oz`
    flag creates a smaller WebAssembly file but takes longer to reduce the size of
    the file. The `-Os` file creates a slightly larger WebAssembly file but takes
    less time to execute. Our application is small, so the time it takes to run either
    optimization will also be minimal. You might use `-Os` if you’re creating a sizeable
    Emscripten project that takes a long time to compile. For our purposes, we don’t
    need to use `-Os`. [Listing 9-3](#listing9-3) shows how to optimize our *collide.wasm*
    file to reduce its size using the `-Oz` flag.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-opt`命令有两个标志可以优化你的WebAssembly文件以减小下载大小：`-Oz`和`-Os`。O是大写字母O，而不是数字零。`-Oz`标志会创建一个更小的WebAssembly文件，但缩小文件大小所需的时间更长。`-Os`标志会创建一个略大的WebAssembly文件，但执行时间较短。我们的应用程序很小，因此无论运行哪种优化，所需时间也都非常短。你可能会在创建一个大型Emscripten项目时使用`-Os`，因为它需要较长的编译时间。就我们的目的而言，我们不需要使用`-Os`。[清单9-3](#listing9-3)显示了如何使用`-Oz`标志优化我们的*collide.wasm*文件以减小其大小。'
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 9-3: Running `wasm-opt` to optimize the *collide.wasm* file for download
    size'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-3：运行`wasm-opt`以优化*collide.wasm*文件的下载大小
- en: When you run this optimization, the size of the WebAssembly file shrinks from
    709 bytes to 666 bytes. That’s only about a 6 percent reduction, but we didn’t
    have to do any work to get there. Typically, you’ll get better size reductions
    when you use this flag with a toolchain.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此优化时，WebAssembly文件的大小从709字节减少到666字节。减少了大约6%的大小，但我们没有做任何额外的工作来实现这个效果。通常，当你使用此标志和工具链时，会获得更好的大小减少效果。
- en: Optimizing for Execution Time
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 针对执行时间的优化
- en: 'When you’re writing a game, you’ll be more interested in improving the fps
    than the download time. There are three optimization flags: `-O1`, `-O2`, and
    `-O3`. Again, the O is a letter o, not a zero. The `-O3` flag provides the highest
    level of optimization but takes the longest to execute. The `-O1` flag executes
    in the shortest time but provides the least optimization. The `-O2` flag is somewhere
    in between the two. Because our app is so small there isn’t a significant difference
    between the time it takes to run `-O1` and `-O3`. In [Listing 9-4](#listing9-4),
    we use the `-O3` flag to get the most from our optimization of the *collide.wasm*
    file.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写游戏时，你会更关注提升帧率（fps）而不是下载时间。有三个优化标志：`-O1`、`-O2` 和 `-O3`。再说一遍，O是字母o，而不是数字零。`-O3`标志提供了最高级别的优化，但执行时间最长。`-O1`标志执行时间最短，但优化效果最差。`-O2`标志介于两者之间。由于我们的应用程序非常小，`-O1`和`-O3`的执行时间差异不大。在[清单9-4](#listing9-4)中，我们使用`-O3`标志来从我们的优化中获取最大收益，优化的是*collide.wasm*文件。
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 9-4: Using `wasm-opt` to optimize performance of the *collide.wasm*
    file'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-4：使用`wasm-opt`优化*collide.wasm*文件的性能
- en: Once you have the new version of the *collide.wasm* file, modify the *collide.html*
    file to run the optimized version. Now when we run it through a profiler, we can
    get an idea of the performance improvement. Profiling with Chrome shows the app
    now running at 35 fps ([Figure 9-19](#figure9-19)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了新的*collide.wasm*文件版本，修改*collide.html*文件以运行优化后的版本。现在，当我们通过分析器运行它时，可以了解性能的提升情况。在Chrome中进行分析，显示应用现在运行在35
    fps的帧率上（[图9-19](#figure9-19)）。
- en: '![f09019](Images/f09019.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![f09019](Images/f09019.png)'
- en: 'Figure 9-19: New fps in Chrome for the optimized *collide-3.wasm* file'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-19：优化后的*collide-3.wasm*文件在Chrome中的新帧率
- en: '[Figure 9-10](#figure9-10) showed that the original frame rate was 18 fps.
    Just running `wasm-opt` can double the frame rate of your application in Chrome.
    Let’s see what happens when we run our profiler in Firefox ([Figure 9-20](#figure9-20)).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-10](#figure9-10)显示了原始帧率为18 fps。仅仅运行`wasm-opt`就能使你的应用在Chrome中帧率翻倍。接下来，让我们看看在Firefox中运行分析器时会发生什么（[图9-20](#figure9-20)）。'
- en: '![f09020](Images/f09020.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![f09020](Images/f09020.png)'
- en: 'Figure 9-20: New fps in Firefox for the optimized *collide-3.wasm* file'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-20：优化后的*collide-3.wasm*文件在Firefox中的新帧率
- en: Looking back at [Figure 9-18](#figure9-18), we were only running at an average
    of 14 fps in our initial run, so the frame rate more than doubled in Firefox.
    In the next section, we’ll look at the disassembled optimized WAT code to see
    the kinds of optimizations `wasm-opt` made.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾[图 9-18](#figure9-18)，我们在最初的运行中只达到了平均 14 帧每秒，因此在 Firefox 中，帧率几乎翻倍。在接下来的章节中，我们将查看反汇编后的优化
    WAT 代码，看看 `wasm-opt` 做了哪些优化。
- en: Looking at Optimized WAT Code
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看优化后的 WAT 代码
- en: You should have the WebAssembly extension for VS Code installed (we did this
    in Chapter 1)*.* In Visual Studio, you can right-click a WebAssembly file and
    select Show WebAssembly to view the WAT for a given WebAssembly file. In [Listing
    9-5](#listing9-5), we use `wasm2wat` at the command line to convert the optimized
    *collide-3.wasm* file into a WAT file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经安装了 VS Code 的 WebAssembly 扩展（我们在第一章中做了这一步）。在 Visual Studio 中，你可以右键点击一个
    WebAssembly 文件，选择“显示 WebAssembly”来查看给定 WebAssembly 文件的 WAT。在[清单 9-5](#listing9-5)中，我们使用命令行中的
    `wasm2wat` 将优化后的 *collide-3.wasm* 文件转换为 WAT 文件。
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 9-5: Run `wasm2wat` to disassemble *collide-3.wasm* to WAT.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-5：运行 `wasm2wat` 将 *collide-3.wasm* 反汇编为 WAT。
- en: Open *collide.wat* next to *collide-3.wat* in VS Code, and look at the updates
    `wasm-opt` made to the WebAssembly file, as shown in [Figure 9-21](#figure9-21).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 VS Code 中打开 *collide.wat* 和 *collide-3.wat*，查看 `wasm-opt` 对 WebAssembly
    文件所做的更新，如[图 9-21](#figure9-21)所示。
- en: In the optimized code, all the function and variable names are gone. I’ve added
    a few comments to help you follow along. You can quickly see that the optimization
    has reduced the number of functions from seven to three. The optimization achieved
    this by expanding many of the small functions into inline code. In one of the
    remaining functions, the optimization removed a variable. You might create two
    different variables when, technically, you need only one because it makes the
    code more straightforward to read. The optimizer can detect this and reduce the
    number of variables. Also notice that the optimizer replaces multiplication by
    powers of 2 with left shifts. For example, in the code in [Figure 9-21](#figure9-21),
    the optimizer has replaced a multiplication by 4 with a left shift of 2\. In the
    next section, we’ll take a closer look at how some of these strategies improve
    performance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化后的代码中，所有的函数和变量名都消失了。我添加了一些注释来帮助你跟进。你可以很快看到，优化将函数的数量从七个减少到三个。优化通过将许多小函数展开为内联代码实现了这一点。在剩下的函数之一中，优化移除了一个变量。你可能会创建两个不同的变量，而实际上只需要一个，因为这样可以使代码更易于阅读。优化器可以检测到这一点并减少变量的数量。还要注意，优化器将乘法运算替换为二的幂次左移。例如，在[图
    9-21](#figure9-21)中的代码，优化器将乘以 4 替换为了左移 2 位。在接下来的章节中，我们将更详细地探讨这些策略如何提升性能。
- en: '![f09021](Images/f09021.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![f09021](Images/f09021.png)'
- en: 'Figure 9-21: Comparing an optimized and an unoptimized version of *collide.wat*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-21：比较优化版本和未优化版本的 *collide.wat*
- en: Strategies for Improving Performance
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升性能的策略
- en: Now we’ll look into some of the strategies you can use to improve your WebAssembly
    application’s performance. The optimizer uses some of these techniques, and you
    can code your application in such a way that you make the optimizer’s job easier.
    Sometimes you might want to look at the WAT code generated by the optimizer to
    obtain tips on ways you can improve code. Let’s look at a few common optimization
    techniques you can use with WAT.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看一些可以用来提升 WebAssembly 应用程序性能的策略。优化器使用了一些这些技术，你也可以通过编写代码来使优化器的工作变得更加简单。有时，你可能希望查看优化器生成的
    WAT 代码，从中获得改进代码的建议。让我们来看看你可以在 WAT 中使用的一些常见优化技术。
- en: Inlining Functions
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内联函数
- en: Calling a function has a tiny bit of overhead. That overhead is not typically
    a big problem unless the function is called thousands or millions of times a second.
    Inlining a function is the process of replacing a function call with an inline
    copy of the same code. Doing this removes the additional processing overhead required
    to make the function call but increases the size of the WebAssembly module, because
    it duplicates the code wherever the function was called. When we ran the optimizer
    on the *collide.wasm* module, it inlined four of the seven functions. Let’s look
    at a quick example of inlining a function. The following WAT code isn’t a part
    of an application; it’s just a demonstration. In [Listing 9-6](#listing9-6), we
    create a function that adds three numbers together and then create another function
    to call `$add_three` a few times.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个函数有一点点开销。除非函数每秒被调用成千上万次，否则这种开销通常不会成为大问题。内联函数是将函数调用替换为该函数相同代码的过程。这样做可以去除执行函数调用所需的额外处理开销，但会增加
    WebAssembly 模块的大小，因为它在每个调用该函数的地方都会复制代码。当我们对*collide.wasm*模块运行优化器时，它内联了七个函数中的四个。让我们看一个内联函数的简单示例。以下的
    WAT 代码并不是应用的一部分，它只是一个演示。在[Listing 9-6](#listing9-6)中，我们创建了一个将三个数字相加的函数，然后创建了另一个函数来多次调用`$add_three`。
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 9-6: Demonstration code for us to inline'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-6：用于内联的演示代码
- en: We’ll focus on inlining as the optimization for this section. To inline these
    functions, we cut and paste the contents of the function in every place where
    it’s called. In [Listing 9-7](#listing9-7), the grayed-out code is the original
    function call, and the code that follows is the inlined function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于内联作为本节的优化方法。为了内联这些函数，我们将函数的内容复制粘贴到每个调用它的地方。在[Listing 9-7](#listing9-7)中，灰色代码是原始的函数调用，后面的代码是内联的函数。
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 9-7: Example of hand-inlined code'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-7：手动内联代码示例
- en: Inlining the function calls might expose other optimization opportunities. For
    example, you can see that we’re adding `2` and later adding `13`. Because both
    of these values are constants, the code would perform better if we just added
    `15`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 内联函数调用可能会暴露其他优化机会。例如，你可以看到我们在添加`2`之后又添加了`13`。由于这两个值都是常量，如果我们直接添加`15`，代码的性能会更好。
- en: 'Let’s write a little module that could potentially be inlined, compile and
    optimize it, and then look at the code generated by `wasm-opt`. We’ll create a
    module with three functions: `$add_three`, `$square`, and `$inline_test`. Create
    a WAT file named *inline.wat* and add the code in [Listing 9-8](#listing9-8).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个可能会被内联的模块，编译并优化它，然后查看`wasm-opt`生成的代码。我们将创建一个包含三个函数的模块：`$add_three`、`$square`和`$inline_test`。创建一个名为*inline.wat*的
    WAT 文件，并在其中添加[Listing 9-8](#listing9-8)中的代码。
- en: '**inline.wat**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**inline.wat**'
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 9-8: We’ll use `wasm-opt` to inline this code'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-8：我们将使用`wasm-opt`来内联这段代码
- en: 'The `$add_three` function is the same function we inlined by hand in [Listing
    9-7](#listing9-7). The `$square` function multiplies the value on the top of the
    stack against itself, and the `$inline_test` function is the calling function.
    Let’s compile the `$inline_test` function using `wat2wasm`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`$add_three`函数是我们在[Listing 9-7](#listing9-7)中手动内联的相同函数。`$square`函数将栈顶的值与自身相乘，而`$inline_test`函数是调用函数。让我们使用`wat2wasm`编译`$inline_test`函数：'
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we can optimize it using `wasm-opt`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`wasm-opt`进行优化：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, let’s convert it back to WAT using `wasm2wat`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用`wasm2wat`将其转换回 WAT：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we can open *inline-opt.wat* and see what our optimized code looks like
    ([Listing 9-9](#listing9-9)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以打开*inline-opt.wat*，查看我们的优化代码是什么样的（[Listing 9-9](#listing9-9)）。
- en: '**inline-opt.wat**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**inline-opt.wat**'
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 9-9: The optimized version of *inline.wat*, *inline-opt.wat*, inlines
    both functions.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-9：优化后的*inline.wat*版本，*inline-opt.wat*，内联了两个函数。
- en: The optimizer removed the two functions `$add_three` and `$square`, and placed
    that code inline in the `inline_test` function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器移除了两个函数`$add_three`和`$square`，并将这些代码内联到`inline_test`函数中。
- en: Multiply and Divide vs. Shift
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 乘法和除法与位移
- en: Chapter 8 showed how to shift integer bits to the right as a faster way to multiply
    by powers of 2\. For example, a shift left of 3 is the same as multiplying by
    2³, which is 8\. Similarly, shifting an integer to the right is the same as dividing
    by that power of 2\. For example, a right shift of 4 is the same as dividing by
    2⁴, which is 16\. Let’s see how `wasm-opt` deals with power-of-2 multiplication
    and division. Create a new WAT file named *pow2_mul.wat* and add the code in [Listing
    9-10](#listing9-10), which creates a module to multiply and divide by powers of
    2.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章展示了如何通过将整数位向右移动作为乘以2的幂的更快方法。例如，向左移动3位等同于乘以2³，即8。同样，将整数向右移动等同于除以该2的幂。例如，右移4位等同于除以2⁴，即16。让我们看看`wasm-opt`如何处理2的幂的乘法和除法。创建一个新的WAT文件，命名为*pow2_mul.wat*，并将[清单
    9-10](#listing9-10)中的代码添加进去，创建一个模块用于乘以和除以2的幂。
- en: '**pow2_mul.wat**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**pow2_mul.wat**'
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 9-10: A function to multiply and divide by powers of 2'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-10：一个用于乘以和除以2的幂的函数
- en: Compile this code using `wat2wasm`, use `wasm-opt` to optimize the WebAssembly
    file, and then disassemble the WebAssembly file back into a WAT file using `wasm2wat`.
    Then open the optimized version of *pow2_mul.wat* in VS Code, as shown in [Listing
    9-11](#listing9-11).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`wat2wasm`编译这段代码，使用`wasm-opt`优化WebAssembly文件，然后使用`wasm2wat`将WebAssembly文件反汇编回WAT文件。接着在VS
    Code中打开优化后的*pow2_mul.wat*，如[清单 9-11](#listing9-11)所示。
- en: '**pow2_mul_optimized.wat**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**pow2_mul_optimized.wat**'
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 9-11: Optimized version of the `pow2_mul` function from [Listing 9-10](#listing9-10)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-11：来自[清单 9-10](#listing9-10)的`pow2_mul`函数的优化版本
- en: Notice that the optimized code performs the division on the second parameter
    before performing the multiplication on the first parameter. When you multiply
    by a power-of-2 constant, `wasm-opt` will convert this into a left shift. However,
    `wasm-opt` doesn’t always replace a power-of-2 division with a right shift. Later
    in this chapter, we’ll spend some time running different versions of this code
    through *benchmark.js* to see how they perform. We’ll compare the optimized code
    generated by `wasm-opt` to code we optimize by hand to see if we can do better.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，优化后的代码会在执行乘法之前先对第二个参数进行除法操作。当你乘以一个2的幂常量时，`wasm-opt`会将其转换为左移操作。然而，`wasm-opt`并不总是将2的幂的除法替换为右移操作。在本章后面，我们将花些时间通过*benchmark.js*运行不同版本的代码，看看它们的性能如何。我们将比较由`wasm-opt`生成的优化代码与我们手动优化的代码，看看是否能够做得更好。
- en: Combining Constants
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 合并常量
- en: Often, optimizations will combine constants to improve performance. For example,
    say you have two constant offsets you need to add together. Your original code
    has *x* = 3 + 8, but this code would perform better if you just set *x* = 11 at
    the start. Cases like this aren’t always obvious to the human eye, but `wasm-opt`
    is efficient at hunting down these situations for you. As an example, create a
    WAT file named *combine_constants.wat* and add the code in [Listing 9-12](#listing9-12),
    which simply combines three constants.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，优化会合并常量以提高性能。例如，假设你有两个常量偏移量需要加在一起。你原来的代码是*x* = 3 + 8，但如果你一开始就将*x* = 11，性能会更好。像这样的情况人眼不总是能轻易看出来，但`wasm-opt`非常高效，能够帮你找出这些情况。作为例子，创建一个WAT文件，命名为*combine_constants.wat*，并将[清单
    9-12](#listing9-12)中的代码添加进去，该代码仅仅是将三个常量合并在一起。
- en: '**combine_constants.wat**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**combine_constants.wat**'
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 9-12: A function that adds three constants together'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-12：一个将三个常量相加的函数
- en: Notice that the value returned by `$combine_constants` will always be 85\. The
    `wasm-opt` tool is smart enough to figure that out. When you run the code through
    `wat2wasm`, `wasm-opt`, and then `wasm2wat`, you’ll see the code in [Listing 9-13](#listing9-13).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`$combine_constants`返回的值将始终是85。`wasm-opt`工具足够智能，能够搞清楚这一点。当你通过`wat2wasm`运行代码，使用`wasm-opt`优化WebAssembly文件，再通过`wasm2wat`反汇编WebAssembly文件时，你会看到[清单
    9-13](#listing9-13)中的代码。
- en: '**combine_constants_optimized.wat**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**combine_constants_optimized.wat**'
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 9-13: The addition of three constants is combined into a single constant.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-13：三个常量的加法被合并为一个常量。
- en: The function in [Listing 9-13](#listing9-13) returns `85` 1 and doesn’t bother
    to perform the two additions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-13](#listing9-13)中的函数返回`85`，并且不再执行两个加法操作。'
- en: DCE
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DCE
- en: '*Dead Code Elimination (DCE)* is an optimization technique that removes any
    code not being called or exported by your module. This is a straightforward optimization
    that doesn’t improve the execution time but does reduce the size of the download.
    DCE happens no matter which optimization flag you use. Let’s look at a quick example.
    Open a new file named *dce_test.wat* and add the code in [Listing 9-14](#listing9-14),
    which creates a module with two functions that are never used.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*死代码消除 (DCE)* 是一种优化技术，用于删除模块中未被调用或导出的任何代码。这是一种直接的优化方法，虽然不会改善执行时间，但可以减少下载文件的大小。DCE
    无论使用哪种优化标志都会发生。我们来看一个简单的例子。打开一个名为*dce_test.wat*的新文件，并添加[清单 9-14](#listing9-14)中的代码，这段代码创建了一个包含两个永不使用的函数的模块。'
- en: '**dce_test.wat**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**dce_test.wat**'
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 9-14: This module has two unused functions.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-14：该模块包含两个未使用的函数。
- en: The first two functions, `$dead_code_1` 1 and `$dead_code_2` 2, aren’t called
    and aren’t exported. Any optimization we run will remove these functions. Run
    `wat2wasm` to generate the code, `wasm-opt` with the `-O3` flag to optimize it,
    and `wasm2wat` to convert it back into a WAT file. Open that new file to view
    the code after the optimization has run, as shown in [Listing 9-15](#listing9-15).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个函数`$dead_code_1` 1 和 `$dead_code_2` 2 没有被调用，也没有被导出。我们运行的任何优化都会删除这些函数。运行`wat2wasm`生成代码，使用`wasm-opt`与`-O3`标志进行优化，再使用`wasm2wat`将其转换回
    WAT 文件。打开新文件，查看优化后的代码，如[清单 9-15](#listing9-15)所示。
- en: '**dce_test_optimized.wat**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**dce_test_optimized.wat**'
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 9-15: Two functions are removed by DCE.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-15：两个函数被 DCE 移除。
- en: The only function that remains is `"dce_test"`. Using DCE has reduced the size
    of the module from 79 bytes to 46 bytes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的函数是 `"dce_test"`。使用 DCE 已将模块的大小从 79 字节减少到 46 字节。
- en: Comparing the Collision Detection App with JavaScript
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 JavaScript 比较碰撞检测应用
- en: We’ve seen how our WebAssembly collision detection app performs. Let’s write
    that code in JavaScript relatively quickly and compare how it performs to the
    WebAssembly version. Create a new web page named *collidejs.html*. Begin by adding
    a header and a canvas element to the *collide.html* page and resaving it as *collidejs.html*,
    as shown in [Listing 9-16](#listing9-16).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过 WebAssembly 碰撞检测应用的表现。接下来，让我们快速写出相同的代码，用 JavaScript 实现，并比较其与 WebAssembly
    版本的性能。创建一个名为 *collidejs.html* 的新网页。首先，向 *collide.html* 页面添加头部和 canvas 元素，并将其重新保存为
    *collidejs.html*，如[清单 9-16](#listing9-16)所示。
- en: '**collidejs.html (part 1 of 2)**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**collidejs.html（第1部分，共2部分）**'
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 9-16: HTML header and canvas element in *collidejs.html*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-16：*collidejs.html* 中的 HTML 头部和 canvas 元素
- en: This code is similar to the WebAssembly version of the app. The main difference
    will be in the `script` tag, shown in [Listing 9-17](#listing9-17). Add the following
    JavaScript in the `script` tag.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与该应用的 WebAssembly 版本相似。主要区别在于`script`标签，如[清单 9-17](#listing9-17)所示。在`script`标签中添加以下
    JavaScript 代码。
- en: '**collidejs.html (part 2 of 2)**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**collidejs.html（第2部分，共2部分）**'
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 9-17: JavaScript version of our collision detection application'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-17：我们的碰撞检测应用的 JavaScript 版本
- en: I won’t go into detail about the code in [Listing 9-17](#listing9-17) because
    its purpose is just to provide a comparison with the WebAssembly code in Chapter
    8. Now we can run *collidejs.html* in the Chrome and Firefox profilers to see
    how they perform. [Figure 9-22](#figure9-22) shows the frame rate for *collidejs.html*
    inside the Chrome profiler.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会详细讲解[清单 9-17](#listing9-17)中的代码，因为它的目的是为了与第8章中的 WebAssembly 代码进行对比。现在我们可以在
    Chrome 和 Firefox 分析器中运行 *collidejs.html* 来查看它们的表现。[图 9-22](#figure9-22)显示了 *collidejs.html*
    在 Chrome 分析器中的帧率。
- en: '![f09022](Images/f09022.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![f09022](Images/f09022.png)'
- en: 'Figure 9-22: The frame rate of our JavaScript app running in the Chrome profiler'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-22：我们的 JavaScript 应用在 Chrome 分析器中的帧率
- en: Chrome ran the JavaScript version of the app at about 9 fps, slower than both
    the unoptimized WebAssembly version, which ran at about 18 fps in Chrome, and
    the optimized version, which ran at 35 fps. The optimized version of the WebAssembly
    code was almost four times as fast in Chrome.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome 运行该 JavaScript 版本的应用时帧率约为 9 fps，比未优化的 WebAssembly 版本（在 Chrome 中运行约 18
    fps）和优化后的版本（运行帧率为 35 fps）都要慢。优化后的 WebAssembly 代码在 Chrome 中的运行速度几乎是原来的四倍。
- en: Now let’s look at how our JavaScript performed in Firefox ([Figure 9-23](#figure9-23)).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们的 JavaScript 在 Firefox 中的表现（如[图 9-23](#figure9-23)所示）。
- en: '![f09023](Images/f09023.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![f09023](Images/f09023.png)'
- en: 'Figure 9-23: The frame rate of our JavaScript app running in the Firefox profiler'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-23：我们的 JavaScript 应用在 Firefox 分析器中的帧率
- en: Firefox performed quite a bit better than Chrome for this application (almost
    twice as fast). It even managed to outperform the unoptimized version of the WebAssembly
    app on Firefox, which ran at around 14 fps. This was only a little more than half
    as fast as the optimized version of the WebAssembly app on Firefox, which ran
    at about 31 fps.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox 在这个应用程序中的表现明显优于 Chrome（几乎快一倍）。它甚至能够超越 WebAssembly 应用程序在 Firefox 上的未优化版本，后者大约运行在
    14 fps。这个速度仅为 Firefox 上优化版 WebAssembly 应用程序的一半左右，后者的帧率大约是 31 fps。
- en: In this section, you learned how to compare your WebAssembly code with similar
    JavaScript code using the Firefox and Chrome profilers. You should now be able
    to use this knowledge to compare different versions of your application on different
    browsers to get a feel for the kind of code that is best done in WebAssembly and
    what is best to do in JavaScript.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何使用 Firefox 和 Chrome 的性能分析工具将你的 WebAssembly 代码与类似的 JavaScript 代码进行比较。你现在应该能够利用这些知识，在不同浏览器上比较应用程序的不同版本，以了解哪些代码最好使用
    WebAssembly 编写，哪些则最好使用 JavaScript 编写。
- en: Hand Optimizing WAT
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动优化 WAT
- en: I spent some time hand optimizing my WebAssembly collider app and was able to
    improve my fps number even more. There were more changes than I can describe in
    this book. However, I want to point out the kinds of performance gains you might
    achieve if you want to take the time to optimize by hand. I was able to get the
    collider app to perform up to 36 fps in the Chrome profiler ([Figure 9-24](#figure9-24)).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我花了一些时间手动优化我的 WebAssembly 碰撞应用程序，结果我将帧率进一步提高了。在这本书中无法详细描述所有的更改。然而，我想指出的是，如果你愿意花时间进行手动优化，可能会获得哪些性能提升。我成功地将碰撞应用程序的帧率提高到
    Chrome 性能分析工具中的 36 fps ([图 9-24](#figure9-24))。
- en: '![f09024](Images/f09024.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![f09024](Images/f09024.png)'
- en: 'Figure 9-24: Hand optimized collider app running in Chrome'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-24：手动优化后的碰撞应用程序在 Chrome 中运行
- en: Firefox had an even higher frame rate of 52 fps ([Figure 9-25](#figure9-25)).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox 的帧率更高，达到了 52 fps ([图 9-25](#figure9-25))。
- en: '![f09025](Images/f09025.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![f09025](Images/f09025.png)'
- en: 'Figure 9-25: Hand optimized collider app running in Firefox'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-25：手动优化后的碰撞应用程序在 Firefox 中运行
- en: You can see the product of my hand optimization efforts at [https://wasmbook.com/collide.html](https://wasmbook.com/collide.html)and
    the WAT code at [https://wasmbook.com/collide.wat](https://wasmbook.com/collide.wat).
    I ran the Binaryen optimizer on my finely tuned code, and it actually slowed it
    down by a few fps. Binaryen is constantly improving their optimized output. Results
    may be different by the time you read this.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://wasmbook.com/collide.html](https://wasmbook.com/collide.html)
    上看到我手动优化后的成果，在 [https://wasmbook.com/collide.wat](https://wasmbook.com/collide.wat)
    上查看 WAT 代码。我对精心调优的代码运行了 Binaryen 优化器，但它实际上使帧率下降了几帧。Binaryen 一直在改进它的优化输出。到你阅读这篇文章时，结果可能会有所不同。
- en: Logging Performance
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能日志记录
- en: One of the simplest ways to log performance from a JavaScript app is by using
    the `Date` class and the `console.log` function. WebAssembly can’t write to the
    console without using JavaScript. For this reason, we’ll need to use JavaScript
    to log the performance of our WebAssembly and JavaScript code to the console.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 记录 JavaScript 应用程序性能的最简单方法之一是使用 `Date` 类和 `console.log` 函数。WebAssembly 无法在不使用
    JavaScript 的情况下写入控制台。因此，我们需要使用 JavaScript 来记录 WebAssembly 和 JavaScript 代码的性能到控制台。
- en: Let’s look at the overhead involved in making many calls from our JavaScript
    into the WebAssembly module. We’ll create a WebAssembly module with a few small
    functions that we can call repeatedly from JavaScript. Create a file named *mod_and.wat*
    file and add the code in [Listing 9-18](#listing9-18).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看从 JavaScript 调用 WebAssembly 模块时所涉及的开销。我们将创建一个 WebAssembly 模块，其中包含一些可以从
    JavaScript 中反复调用的小函数。创建一个名为 *mod_and.wat* 的文件，并添加 [清单 9-18](#listing9-18) 中的代码。
- en: '**mod_and.wat**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**mod_and.wat**'
- en: '[PRE21]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 9-18: Compare performance of remainder versus bitwise AND'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-18：比较余数与按位与操作的性能
- en: There are two functions in this module, a `$mod` function that finds the remainder
    of a division by `1000` and a `$and` function that uses a bitwise AND mask. Compile
    the *mod_and.wat* file using `wat2wasm`, and optimize it using `wasm-opt`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块中有两个函数，一个是 `$mod` 函数，它用于计算除以 `1000` 的余数，另一个是 `$and` 函数，它使用按位与操作。使用 `wat2wasm`
    编译 *mod_and.wat* 文件，并使用 `wasm-opt` 进行优化。
- en: Next, we need to create a JavaScript function to run this WAT module and test
    it against the equivalent JavaScript code. Create a new file named *mod_and.js*
    and add the code in [Listing 9-19](#listing9-19).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个 JavaScript 函数来运行这个 WAT 模块，并将其与等效的 JavaScript 代码进行测试。创建一个名为 *mod_and.js*
    的新文件，并添加 [清单 9-19](#listing9-19) 中的代码。
- en: '**mod_and.js**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**mod_and.js**'
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 9-19: Recording the runtime with `Date.now` and `console.log`'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-19：使用`Date.now`和`console.log`记录运行时间
- en: Before running each block of code, we set a variable `start_time` to `Date.now()`.
    Doing so sets the `start_time` variable to the current time in milliseconds. When
    we complete the code, we log `Date.now``() - start_time`, which gives us the runtime
    of our test in milliseconds. We’ll do this for our WebAssembly module and our
    JavaScript code to compare the two.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行每个代码块之前，我们设置一个变量`start_time`为`Date.now()`。这样做将`start_time`变量设置为当前时间的毫秒数。完成代码后，我们记录`Date.now()
    - start_time`，这将给出我们测试的运行时间（毫秒）。我们会对WebAssembly模块和JavaScript代码执行这个操作，以便比较两者。
- en: 'Now that we have our *mod_and.js* function, we can run it using the following
    `node` command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了*mod_and.js*函数，可以使用以下`node`命令来运行它：
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[Listing 9-20](#listing9-20) shows the output after running *mod_and.js*.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-20](#listing9-20)显示了运行*mod_and.js*后的输出。'
- en: '[PRE24]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 9-20: Output from *mod_and.js*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-20：*mod_and.js*的输出
- en: The `mod` function took 29 milliseconds to run four million times. The `and`
    function took 23 milliseconds to run four million times. The JavaScript version
    only took 4 milliseconds to run four million times. So if WebAssembly is so fast,
    why did it take between five and seven times as long to run those functions? The
    problem is that calls between JavaScript and WebAssembly have some overhead. Calling
    a small function four million times also incurs the cost of that overhead four
    million times. Let’s rewrite our code to execute our functions a few million times
    from within the WebAssembly rather than from a loop in the JavaScript.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod`函数执行四百万次花费了29毫秒。`and`函数执行四百万次花费了23毫秒。JavaScript版本执行四百万次只花费了4毫秒。那么，如果WebAssembly这么快，为什么它的执行时间却是这些函数的五到七倍呢？问题在于JavaScript和WebAssembly之间的调用存在一些开销。调用一个小函数四百万次时，也会产生四百万次开销的成本。让我们重写代码，从WebAssembly内部执行这些函数，而不是从JavaScript的循环中调用它们。'
- en: First, we’ll rewrite our WebAssembly module to include the loop inside the module
    instead of inside the JavaScript. Create a new WAT file named *mod_and_loop.wat*
    and add the code in [Listing 9-21](#listing9-21).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将重写WebAssembly模块，将循环包含在模块内部，而不是在JavaScript内部。创建一个新的WAT文件，命名为*mod_and_loop.wat*，并添加[列表
    9-21](#listing9-21)中的代码。
- en: '**mod_and_loop.wat**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**mod_and_loop.wat**'
- en: '[PRE25]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 9-21: Looping version of the bitwise AND/modulo functions'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-21：按位与/取余函数的循环版本
- en: These functions do the same tasks as the functions in the original, but the
    program runs them 100 million times. We’ll need to change the JavaScript file
    to call these functions once and to run the JavaScript 100 million times. That
    way, we can compare the performance with the WebAssembly module, which we earlier
    changed to execute our function 100 million times. Create a new function named
    *mod_and_loop.js* and add the code in [Listing 9-22](#listing9-22).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数执行的任务与原始函数相同，但程序将它们执行1亿次。我们需要修改JavaScript文件，只调用这些函数一次，并让JavaScript执行1亿次。这样，我们就可以将性能与WebAssembly模块进行比较，后者已经修改为执行函数1亿次。创建一个名为*mod_and_loop.js*的新函数，并添加[列表
    9-22](#listing9-22)中的代码。
- en: '**mod_and_loop.js**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**mod_and_loop.js**'
- en: '[PRE26]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 9-22: JavaScript that runs the `and_loop`, `mod_loop`, and comparable
    JavaScript'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-22：运行`and_loop`、`mod_loop`和相应JavaScript代码的JavaScript
- en: We call the `mod_loop` and the `and_loop` functions, recording the time each
    loop took to execute. Next, we run our loop where we perform a modulo 100 million
    times and record how long that took. If we compile and optimize our WebAssembly
    module and then run *mod_and_loop.js* using `node`, we should see something like
    the output in [Listing 9-23](#listing9-23).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`mod_loop`和`and_loop`函数，记录每个循环执行所花的时间。接下来，我们运行一个循环，在其中执行100百万次取余操作，并记录所花费的时间。如果我们编译并优化WebAssembly模块，然后使用`node`运行*mod_and_loop.js*，我们应该看到类似[列表
    9-23](#listing9-23)中的输出。
- en: '[PRE27]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 9-23: Output from *mod_and_loop.js*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-23：*mod_and_loop.js*的输出
- en: Now the WebAssembly is 67 percent faster than the same JavaScript code. It was
    somewhat disappointing that the bitwise AND didn’t perform much better than a
    modulo, as I had hoped it would. However, we now know how to do the simplest performance
    test using `console.log` in conjunction with `Date.now()`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在WebAssembly比相同的JavaScript代码快了67%。虽然按位与操作的性能没有比取余操作好多少，这点让我有些失望，但至少我们现在知道如何使用`console.log`结合`Date.now()`进行最简单的性能测试了。
- en: More Sophisticated Testing with benchmark.js
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用benchmark.js进行更复杂的测试
- en: If you want to make your testing a bit more sophisticated than just using logs
    and `Date.now`, you can install a performance testing module, such as *benchmark.js*.
    Earlier in [Listing 9-10](#listing9-10), we created a WebAssembly function that
    multiplied by 16 and then divided by 8, and ran it through `wasm-opt` to see how
    Binaryen would optimize the code for us. The optimizer swapped the multiplication
    actions with a shift but didn’t swap in a shift for the divide. It also rearranged
    the division and the multiplication.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让你的测试比仅使用日志和 `Date.now` 更复杂一些，可以安装一个性能测试模块，例如*benchmark.js*。在[清单 9-10](#listing9-10)中，我们创建了一个
    WebAssembly 函数，它先乘以16然后除以8，并通过 `wasm-opt` 查看 Binaryen 如何优化我们的代码。优化器用位移操作替换了乘法，但没有用位移替换除法操作，它还重新排列了除法和乘法的顺序。
- en: Let’s test several versions of this WebAssembly module, including the original
    and the version generated by the optimizer, to see whether it’s possible to outdo
    the optimizer with a bit of effort. We’ll use *benchmark.js* to test the performance
    of all of these functions. Create a new WAT file named *pow2_test.wat* and add
    the code in [Listing 9-24](#listing9-24).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将测试这个 WebAssembly 模块的几个版本，包括原始版本和优化器生成的版本，看看是否可以通过一些努力超越优化器的效果。我们将使用*benchmark.js*来测试所有这些函数的性能。创建一个新的
    WAT 文件，命名为*pow2_test.wat*，并添加[清单 9-24](#listing9-24)中的代码。
- en: '**pow2_test.wat (part 1 of 5)**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**pow2_test.wat（第1部分，共5部分）**'
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 9-24: The beginning of the module with the original function'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-24：模块开始与原始函数
- en: '[Listing 9-24](#listing9-24) shows the original version of our power-of-2 test,
    where we multiplied by 16 and divided by 8\.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 9-24](#listing9-24) 显示了我们原始的2的幂次测试版本，在其中我们先乘以16，然后除以8\。'
- en: The next function, in [Listing 9-25](#listing9-25), runs the division before
    the multiplication. I wanted to test this because `wasm-opt` swapped the multiplication
    and division functions, and I was curious to know whether that had a positive
    effect on the function’s performance.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数在[清单 9-25](#listing9-25)中，先进行除法再进行乘法。我想测试这个，因为`wasm-opt`交换了乘法和除法函数，我很好奇这是否对函数性能产生了积极的影响。
- en: '**pow2_test.wat (part 2 of 5)**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**pow2_test.wat（第2部分，共5部分）**'
- en: '[PRE29]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 9-25: Swap the division and multiplication'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-25：交换除法和乘法顺序
- en: The next function, in [Listing 9-26](#listing9-26), uses a shift for both power-of-2
    multiplication and division. We also use the order inserted by the optimizer,
    where the division happens before the multiplication.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数在[清单 9-26](#listing9-26)中，使用了二进制位移进行2的幂次乘法和除法。我们还使用了优化器插入的顺序，其中除法发生在乘法之前。
- en: '**pow2_test.wat (part 3 of 5)**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**pow2_test.wat（第3部分，共5部分）**'
- en: '[PRE30]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 9-26: Change the multiply and divide expressions to binary shifts'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-26：将乘法和除法表达式改为二进制位移
- en: Next, in [Listing 9-27](#listing9-27), we use a shift for both division and
    multiplication, but this time we don’t change the order of the division and multiplication
    from the original code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在[清单 9-27](#listing9-27)中，我们使用了位移操作进行除法和乘法，但这次我们没有改变除法和乘法的顺序，仍然保留了原始代码中的顺序。
- en: '**pow2_test.wat (part 4 of 5)**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**pow2_test.wat（第4部分，共5部分）**'
- en: '[PRE31]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 9-27: The original order with multiply before divide'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-27：原始顺序，先乘法再除法
- en: This next function, in [Listing 9-28](#listing9-28), is the version of the code
    produced by `wasm-opt` with the `-O3` flag.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个函数在[清单 9-28](#listing9-28)中，这是通过 `wasm-opt` 和 `-O3` 标志生成的代码版本。
- en: '**pow2_test.wat (part 5 of 5)**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**pow2_test.wat（第5部分，共5部分）**'
- en: '[PRE32]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 9-28: The `wasm-opt` optimized version of the function'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-28：`wasm-opt`优化版本的函数
- en: 'Now we can compile this module with `wat2wasm`, but we should *not* optimize
    it, because we’re trying to test the WAT code as it is without modifications from
    the optimizer. Next, we need to create our *benchmark.js* code. First, we’ll need
    to install the *benchmark.js* module using `npm`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以用`wat2wasm`编译这个模块，但我们*不应该*优化它，因为我们要测试原始的 WAT 代码，避免优化器的修改。接下来，我们需要创建我们的*benchmark.js*代码。首先，我们需要使用
    `npm` 安装 *benchmark.js* 模块：
- en: '[PRE33]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now we can write a JavaScript program to test the WebAssembly functions using
    *benchmark.js*. Let’s break this program into several chunks and walk through
    them a piece at a time. Add the code in [Listing 9-29](#listing9-29) to *benchmark_test.js*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写一个 JavaScript 程序，使用*benchmark.js*测试 WebAssembly 函数。让我们把这个程序分成几个部分，一次讲解一个部分。将[清单
    9-29](#listing9-29)中的代码添加到*benchmark_test.js*中。
- en: '**benchmark_test.js**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**benchmark_test.js**'
- en: '[PRE34]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 9-29: The first part of the *benchmark_test.js* JavaScript file'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-29：*benchmark_test.js* JavaScript 文件的第一部分
- en: First, we require 1 the `benchmark` module, and then create a new `suite` 2
    object from that module. We require the `fs` 3 module and use that to load the
    WebAssembly module into a `byte` array. We then define a series of variables to
    hold the functions in the WebAssembly module. We log out a `rainbow` 4 color separator
    that displays `RUNNING BENCHMARK` to make it easier to spot where the benchmark
    begins as we scroll back up through our stats. If you’re like me, you might change
    the module as you benchmark it, in which case, it can be helpful to have a conspicuous
    place where the benchmarking begins.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们引入 1 `benchmark` 模块，然后从该模块创建一个新的 `suite` 2 对象。接着，我们引入 `fs` 3 模块，并用它将 WebAssembly
    模块加载到 `byte` 数组中。然后，我们定义一系列变量来保存 WebAssembly 模块中的函数。我们记录一个 `rainbow` 4 颜色分隔符，显示
    `RUNNING BENCHMARK`，以便在回滚查看统计数据时更容易找到基准测试的起点。如果你像我一样在基准测试时更改模块，那么在一个显眼的位置标记基准测试开始的地方会很有帮助。
- en: In [Listing 9-30](#listing9-30), we’ll add a function we can call to initialize
    and run the benchmark suite. Add the following function to *benchmark_test.js*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 9-30](#listing9-30) 中，我们将添加一个可以调用的函数，用于初始化并运行基准测试套件。将以下函数添加到 *benchmark_test.js*
    中。
- en: '**benchmark_test.js**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**benchmark_test.js**'
- en: '[PRE35]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 9-30: The `init_benchmark` function'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-30：`init_benchmark` 函数
- en: We define the `init_benchmark()` 1 function, which calls `suite.add`2 from the
    benchmark module for each of the functions in our WebAssembly module. Using `suite.add`
    tells the benchmark suite to test that function and log the results with the string
    passed as the second parameter. The `suite.on` function sets an event callback
    for different events that occur during a benchmark test. The first call to `suite.on`
    3 sets the callback for each cycle, which will output the function we tested and
    the stats for that test. The next call to `suite.on` 4 sets the callback for the
    completion of the benchmark test, which will use the `filter` 5 method to `log`
    6 the fastest and slowest functions. We then filter on `'successful'` 7 to get
    an array of all the functions that ran successfully. We `sort` 8 that array by
    the `mean` (average) runtime for that cycle. That sorts the cycles from the fastest
    to the slowest runtime. We can then loop 9 through each of those cycles, printing
    them from fastest to slowest. At the end of this function, we `run` a the `suite`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了 `init_benchmark()` 1 函数，它为 WebAssembly 模块中的每个函数调用基准测试模块中的 `suite.add`2。使用
    `suite.add` 告诉基准测试套件测试该函数，并用作为第二个参数传递的字符串记录结果。`suite.on` 函数设置了一个事件回调，用于处理基准测试期间发生的不同事件。第一次调用
    `suite.on` 3 设置回调，用于每个周期，这将输出我们测试的函数和该测试的统计数据。接下来的调用 `suite.on` 4 设置回调，用于基准测试完成时，它将使用
    `filter` 5 方法来 `log` 6 最快和最慢的函数。然后，我们按 `'successful'` 7 过滤，获取所有成功运行的函数数组。我们根据该周期的
    `mean`（平均）运行时间 `sort` 8 该数组。这样可以将周期按从最快到最慢的运行时间进行排序。然后，我们可以通过循环 9 遍历这些周期，从最快到最慢地打印它们。在该函数的最后，我们
    `run` 了 `suite`。
- en: With the `init_benchmark` function defined, in [Listing 9-31](#listing9-31)
    we create the asynchronous IIFE to instantiate our WebAssembly module and call
    `init_benchmark`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了 `init_benchmark` 函数后，在 [列表 9-31](#listing9-31) 中，我们创建了异步 IIFE 来实例化我们的 WebAssembly
    模块并调用 `init_benchmark`。
- en: '**benchmark_test.js**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**benchmark_test.js**'
- en: '[PRE36]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 9-31: Asynchronous IIFE instantiates WebAssembly and runs *benchmark**.js**.*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 9-31：异步 IIFE 实例化 WebAssembly 并运行 *benchmark**.js**。 '
- en: 'Here we `instantiate` 1 our WebAssembly module and set all of the functions
    2 we’ll be calling from *benchmark.js*. We then run *benchmark.js* by calling
    `init_benchmark()` 3. Now we can run our application using `node` with the following
    command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们 `instantiate` 1 我们的 WebAssembly 模块，并设置所有我们将从 *benchmark.js* 中调用的函数 2。然后，通过调用
    `init_benchmark()` 3 运行 *benchmark.js*。现在，我们可以使用 `node` 并通过以下命令运行我们的应用程序：
- en: '[PRE37]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[Figure 9-26](#figure9-26) shows the output.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-26](#figure9-26) 显示了输出结果。'
- en: '![f09026](Images/f09026.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![f09026](Images/f09026.png)'
- en: 'Figure 9-26: Output from *benchmark_test.js*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-26：*benchmark_test.js* 的输出
- en: 'Interestingly, the slowest of these functions was the `wasm-opt` optimized
    version: the original version and the `wasm-opt` optimized version executed in
    about the same time. The fastest run was the code where we replaced the `i32.mul`
    and `i32.div_u` operations with shifts, and reordered the calls in the way that
    the `wasm-opt` tool rearranged them. This illustrates that you can’t assume that
    `wasm-opt` (or any programmatic optimizer) will always give you the highest-performing
    code. Running performance tests on your application is always advisable.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，最慢的这些函数是 `wasm-opt` 优化版本：原始版本和 `wasm-opt` 优化版本的执行时间差不多。最快的运行是我们将 `i32.mul`
    和 `i32.div_u` 操作替换为位移，并按 `wasm-opt` 工具重排的顺序重新排序调用。这表明，你不能假设 `wasm-opt`（或任何程序化优化工具）总是能给你最优性能的代码。始终建议对你的应用程序进行性能测试。
- en: Comparing WebAssembly and JavaScript with --print-bytecode
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `--print-bytecode` 比较 WebAssembly 和 JavaScript
- en: In this section, we’ll geek out on low-level bytecode. It’s fun and interesting
    to look at what the JavaScript JIT generates. It’s also fascinating to compare
    with WebAssembly and intriguing to think about how to improve performance. If
    this topic doesn’t interest you, feel free to skip ahead to the next section.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨低级字节码。观察 JavaScript JIT 生成的字节码既有趣又令人兴奋。将其与 WebAssembly 进行比较也很有趣，思考如何提高性能更是引人入胜。如果这个话题不感兴趣，你可以跳过并继续看下一节。
- en: Let’s briefly look at how to make a better comparison between WebAssembly code
    and JavaScript. V8 compiles JavaScript into an IR bytecode, which looks a lot
    like an assembly language or WAT. IR uses registers and an accumulator but isn’t
    machine specific. We can use IR to compare the JavaScript code after it runs through
    the JIT compiler with our WebAssembly code. Because they’re both low-level bytecodes,
    it gives us a better *apples to apples* comparison to look at. But keep in mind
    that the JavaScript code will need to be parsed and compiled into this bytecode
    at runtime, whereas WebAssembly is compiled ahead of time.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要看看如何在 WebAssembly 代码和 JavaScript 之间做更好的对比。V8 将 JavaScript 编译成 IR 字节码，看起来很像汇编语言或
    WAT。IR 使用寄存器和累加器，但不是机器特定的。我们可以使用 IR 来比较经过 JIT 编译器运行后的 JavaScript 代码和我们的 WebAssembly
    代码。因为它们都是低级字节码，这让我们能进行更好的*类比比较*。但请记住，JavaScript 代码需要在运行时解析并编译成这种字节码，而 WebAssembly
    是提前编译的。
- en: Let’s create a small JavaScript program and use the `node --print-bytecode`
    flag to look at the bytecode generated from that JavaScript. Create a JavaScript
    file named *print_bytecode.js* and add the code in [Listing 9-32](#listing9-32).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个小的 JavaScript 程序，并使用 `node --print-bytecode` 标志查看由该 JavaScript 生成的字节码。创建一个名为
    *print_bytecode.js* 的 JavaScript 文件，并添加 [Listing 9-32](#listing9-32) 中的代码。
- en: '**print_bytecode.js**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**print_bytecode.js**'
- en: '[PRE38]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: // if we don't call this, the function is removed in dce check
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: // 如果我们不调用这个，函数会在 DCE 检查中被移除
- en: '[PRE39]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 9-32: The `bytecode_test` function that we’ll execute with the `--print-bytecode`
    flag'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 9-32: 我们将用 `--print-bytecode` 标志执行的 `bytecode_test` 函数'
- en: This `bytecode_test` function is similar to the code that we performance tested
    in [Listing 9-22](#listing9-22). It’s a simple `for`loop that takes the modulo
    of the `i` counter, stores it in `x`, and then returns `99`. It doesn’t really
    do anything useful, but I wanted to work with a function that is easy to understand,
    so we can compile it into bytecode.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `bytecode_test` 函数类似于我们在 [Listing 9-22](#listing9-22) 中进行性能测试的代码。它是一个简单的
    `for` 循环，取 `i` 计数器的模数，将其存储在 `x` 中，然后返回 `99`。它其实没有做什么有用的事情，但我想用一个易于理解的函数，这样我们可以将其编译成字节码。
- en: We then call the function in addition to defining it; otherwise, V8 will remove
    it as a part of DCE. We can then run the `node` command in [Listing 9-33](#listing9-33)
    to print the bytecode.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们除了定义这个函数，还需要调用它；否则 V8 会将其作为 DCE 的一部分移除。我们可以在 [Listing 9-33](#listing9-33)
    中运行 `node` 命令来打印字节码。
- en: '[PRE40]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Listing 9-33: Run `node` with the `--print-bytecode` flag'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 9-33: 使用 `--print-bytecode` 标志运行 `node`'
- en: We pass the `--print-bytecode` flag to `node` to instruct it to print the bytecode.
    We also pass in the `--print-bytecode-filter` flag, setting it to the name of
    our function to print that function’s bytecode. If we don’t include the filter
    flag, the output will be way more bytecode than we want to look at. Finally, we
    pass `node` the name of the JavaScript file. Run *print_bytecode.js* with the
    flags from [Listing 9-33](#listing9-33), and you should get the output in [Listing
    9-34](#listing9-34).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`node`传递`--print-bytecode`标志，指示它打印字节码。我们还传递`--print-bytecode-filter`标志，将其设置为我们函数的名称，以便打印该函数的字节码。如果不包含过滤器标志，输出的字节码将远超我们需要查看的部分。最后，我们传递`node`
    JavaScript 文件的名称。使用来自[示例 9-33](#listing9-33)的标志运行*print_bytecode.js*，你应该能在[示例
    9-34](#listing9-34)中看到输出结果。
- en: '[PRE41]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 9-34: Bytecode output from *print_bytecode.js*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-34：*print_bytecode.js*的字节码输出
- en: The right side of the output in [Listing 9-34](#listing9-34) has the opcodes
    for the IR. Here I’ve listed those opcodes and added WAT-style comments on the
    right side. Instead of a stack machine, the bytecode that the V8 engine generated
    is for a virtual register machine with an accumulator register. The *accumulator*
    is where this virtual machine performs its calculations. Take a quick look at
    the code in [Listing 9-35](#listing9-35), which V8 generated.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-34](#listing9-34)中输出的右侧显示了IR的操作码。在这里，我列出了这些操作码，并在右侧添加了WAT风格的注释。V8引擎生成的字节码并不是栈机器，而是一个虚拟寄存器机器，它具有一个累加器寄存器。*累加器*是这个虚拟机器进行计算的地方。快速查看[示例
    9-35](#listing9-35)中的代码，这段代码是V8生成的。'
- en: '[PRE42]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 9-35: Opcodes with an explanation after the *;;* characters'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 9-35：带有解释的操作码，解释位于 *;;* 字符后
- en: The IR for V8 uses an accumulator. Accumulator machines have one general-purpose
    register where the accumulator does all of the math instead of doing it in the
    other registers. The opcodes with the letter `a` in them usually refer to the
    accumulator, and `r` usually refers to a register. For example, the first opcode
    after `StackCheck` is `LdaZero`, which loads (`Ld`) the accumulator (`a`) with
    0 (`Zero`). Then the line `Star` `r0` stores (`St`) the value in the accumulator
    (`a`) into a register (`r`) and then passes in `r0` to define that register. It
    does this because the IR can’t set `Register0` to a value of 0 directly; instead,
    it needs to load that value into the accumulator and then move the value in the
    accumulator into `Register0`. Later in the code, you see `LdaSmi.ExtraWide`. This
    loads (`Ld`) the accumulator (`a`) with a small integer (`Smi`) that uses all
    32 bits (`ExtraWide`). If you loaded a number that used 16 bits, it would have
    displayed `Wide` instead of `ExtraWide`, and 8 bits wouldn’t have anything following
    `LdaSmi`. The `TestLessThan` opcode compares the value in the register specified
    (`r1`) with the value in the accumulator. The line `JumpIfFalse` `[22]` checks
    whether the `TestLessThan` resulted in false, and if so, jumps 22 bytes forward.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: V8 的 IR 使用了一个累加器。累加器机器有一个通用寄存器，所有的计算都由累加器在其中完成，而不是在其他寄存器中进行。带有字母`a`的操作码通常指的是累加器，而`r`通常指的是寄存器。例如，`StackCheck`后的第一个操作码是`LdaZero`，它将0（`Zero`）加载到累加器（`a`）中。然后，`Star`
    `r0`这一行将累加器（`a`）中的值存储（`St`）到寄存器（`r`）中，并将`r0`传入定义该寄存器。之所以这么做，是因为IR不能直接将`Register0`设为0的值；相反，它需要先将该值加载到累加器中，然后再将累加器中的值移动到`Register0`。在代码后面，你会看到`LdaSmi.ExtraWide`。这将一个使用所有32位（`ExtraWide`）的小整数（`Smi`）加载到累加器（`a`）中。如果你加载的是一个使用16位的数字，它会显示`Wide`而不是`ExtraWide`，如果是8位的数字，则`LdaSmi`后面不会跟任何东西。`TestLessThan`操作码比较指定寄存器（`r1`）中的值与累加器中的值。`JumpIfFalse`
    `[22]`这一行检查`TestLessThan`的结果是否为假，如果是，则跳转22个字节。
- en: The `--print-bytecode` flag can be a useful tool to help performance tune your
    JavaScript. If you’re familiar with WAT or assembly, it’s not difficult to understand.
    It can also be useful in comparing your WAT code with JavaScript for performance
    tuning reasons in both parts of your WebAssembly application.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`--print-bytecode`标志是一个有用的工具，可以帮助你调优JavaScript性能。如果你熟悉WAT或汇编语言，它并不难理解。它还可以用于比较你的WAT代码与JavaScript之间的性能调优，适用于WebAssembly应用程序的两个部分。'
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed several tools for evaluating the performance of
    our WAT code. We also compared our code to the performance of equivalent JavaScript.
    Then we explored several strategies for improving the performance of our WebAssembly
    module.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们讨论了几种评估WAT代码性能的工具。我们还将我们的代码与等效的JavaScript性能进行了比较。然后，我们探索了几种提升WebAssembly模块性能的策略。
- en: We looked at the profiler in the Chrome web browser and discussed the Summary
    page and the JS Heap Memory section, which provided information about memory spikes
    and garbage collection. We also looked at the fps in our profile, which is an
    excellent way to determine the performance of a game or UI heavy application.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查看了Chrome浏览器中的性能分析器，讨论了概况页面和JS堆内存部分，它们提供了关于内存波动和垃圾回收的信息。我们还查看了我们的分析数据中的fps，这是评估游戏或UI密集型应用程序性能的绝佳方式。
- en: We used the Firefox profiler to investigate our collision detection application.
    The Firefox profiler offers a few extra tools, including the Call Tree and the
    JS Flame Chart. We tracked down the WAT function that was called by using the
    `wasm-function[index]` listed in the profiler.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Firefox的性能分析器调查了我们的碰撞检测应用程序。Firefox性能分析器提供了一些额外的工具，包括调用树和JS火焰图。我们通过分析性能分析器中的`wasm-function[index]`，追踪到了被调用的WAT函数。
- en: Next, we installed *Binaryen.js* and used the `wasm-opt` tool to optimize our
    WebAssembly module for either download size or peak performance. We also disassembled
    it back into WAT code, so we could view the changes the optimizer made.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们安装了*Binaryen.js*并使用`wasm-opt`工具优化了WebAssembly模块，以优化下载大小或峰值性能。我们还将其反汇编回WAT代码，以便查看优化器所做的更改。
- en: We then looked into a variety of strategies for improving the peak performance
    of our application, including inlining functions, replacing multiplication and
    division with bit-shifts, and combining constants. We discussed DCE, which the
    optimizer performs to remove any unused functions from our module.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们研究了提高应用程序峰值性能的各种策略，包括内联函数、用位移操作替代乘法和除法，以及合并常量。我们还讨论了DCE（死代码消除），它是优化器执行的操作，用于删除我们模块中未使用的函数。
- en: We created a JavaScript version of our application to compare the performance
    of JavaScript against that of the WebAssembly module.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个JavaScript版本的应用程序，用以比较JavaScript与WebAssembly模块的性能。
- en: After using the profiler throughout most of this chapter, we looked at other
    methods for determining our module’s performance. Using `console.log` and `Date.now`
    is the simplest method of measuring performance in an application, and the testing
    suite *benchmark.js* provides more detailed information for evaluating the performance
    of different functions. Just for fun, we printed the V8 IR bytecode to evaluate
    JavaScript code further and compared it with WebAssembly. In the next chapter,
    you’ll learn about debugging the WebAssembly modules.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的大部分内容中使用了性能分析工具后，我们还研究了其他几种确定模块性能的方法。使用`console.log`和`Date.now`是衡量应用程序性能最简单的方法，而测试工具*benchmark.js*则提供了更详细的信息，用于评估不同函数的性能。为了好玩，我们还打印了V8
    IR字节码，进一步评估了JavaScript代码，并将其与WebAssembly进行了对比。在下一章中，您将学习如何调试WebAssembly模块。
