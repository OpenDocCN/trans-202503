- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Optimizing Performance
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: This chapter is aimed squarely at developers who want lightning-fast applications
    and are willing to take the time to make that happen. We’ll first discuss profiler
    tools to evaluate WebAssembly module performance and investigate how to compare
    the performance of WebAssembly with similar JavaScript code. We’ll spend some
    time looking at strategies to improve the performance of our WebAssembly, including
    inlining functions, replacing multiplication and division with bit-shifts, combining
    constants, and removing code using Dead Code Elimination (DCE).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门面向那些希望实现极速应用程序并愿意为此付出时间和精力的开发人员。我们将首先讨论性能分析工具，评估WebAssembly模块性能，并研究如何将WebAssembly的性能与类似的JavaScript代码进行比较。我们还将探讨一些提升WebAssembly性能的策略，包括内联函数、用位移操作替代乘法和除法、合并常量，以及使用死代码消除（DCE）删除冗余代码。
- en: 'We’ll also delve into other methods for determining a module’s performance:
    we’ll use `console.log` and `Date.now` to measure our application’s performance
    and use the testing suite *benchmark.js* to gather detailed performance data for
    an application. Then, just for fun, we’ll print the Chrome JavaScript V8 engine’s
    Intermediate Representation (IR) bytecode for a JavaScript function. JavaScript
    IR bytecode can give you insight into the work a JavaScript function does, which
    is helpful for evaluating whether to write a function in WebAssembly or JavaScript.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨确定模块性能的其他方法：我们将使用`console.log`和`Date.now`来衡量应用程序的性能，并使用测试工具*benchmark.js*来收集应用程序的详细性能数据。然后，为了好玩，我们将打印出Chrome
    JavaScript V8引擎的中间表示（IR）字节码。JavaScript IR字节码可以帮助你了解JavaScript函数的工作原理，这对于评估是否使用WebAssembly或JavaScript编写函数非常有帮助。
- en: Using a Profiler
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用性能分析器
- en: '*Profilers* are tools that analyze different aspects of an application’s performance,
    including the app’s memory usage and execution time. This can help you make decisions
    about where to optimize and what to optimize for. You’ll often need to make trade-offs
    between different types of optimizations. For example, you’ll need to decide whether
    to focus on improving your time to interactive (TTI) so users can begin using
    your application as soon as possible or focusing on peak performance once your
    application is up and running. If you’re writing a game, it’s worth having a long
    load time to ensure the game will run more smoothly once it finishes downloading.
    However, an online store might prefer to ensure the user can interact with the
    website as soon as possible. In most cases, you’ll need to balance between the
    two, and using a profiler can help.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*性能分析器*是用来分析应用程序性能的工具，包括应用程序的内存使用和执行时间。这可以帮助你做出关于优化的决策，确定优化的方向和重点。你通常需要在不同类型的优化之间做出权衡。例如，你需要决定是优先提升交互时间（TTI），以便用户能够尽快使用你的应用程序，还是在应用程序运行时优化峰值性能。如果你正在开发一款游戏，可能需要较长的加载时间，以确保游戏在下载完成后能够顺畅运行。然而，在线商店可能更倾向于确保用户尽快与网站进行交互。在大多数情况下，你需要在这两者之间找到平衡，使用性能分析器可以帮助你做出这个决策。'
- en: Profilers are also efficient at finding bottlenecks in your code, allowing you
    to focus your time and effort in those locations. We’ll look at the Chrome and
    Firefox profilers, because they currently have the best support for WebAssembly.
    We’ll be profiling the collision detection app from Chapter 8.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析器还非常高效地帮助你发现代码中的瓶颈，帮助你将时间和精力集中在这些关键区域。我们将关注Chrome和Firefox的性能分析器，因为它们目前对WebAssembly提供了最好的支持。我们将对第8章中的碰撞检测应用进行性能分析。
- en: Chrome Profiler
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Chrome 性能分析器
- en: You’ll want to use a new incognito browser window with the Chrome profiler.
    Incognito windows don’t load website caches, cookies, or Chrome plug-ins, which
    cause problems when profiling because they run additional JavaScript code and
    affect the performance of the site you want to profile. The caches and cookies
    are usually less problematic, but can clutter your environment with data unrelated
    to the code you’re profiling. You can open an incognito window from the menu on
    the top right of your web browser by clicking **New incognito window**, as shown
    in [Figure 9-1](#figure9-1).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Chrome性能分析器时，你需要使用一个新的隐身浏览器窗口。隐身窗口不会加载网站缓存、Cookies或Chrome插件，这些都会在分析时引发问题，因为它们会运行额外的JavaScript代码并影响你想要分析的站点性能。缓存和Cookies通常问题不大，但它们会把与你分析的代码无关的数据引入你的环境。你可以通过点击浏览器右上角菜单中的**新建隐身窗口**来打开隐身窗口，如[图9-1](#figure9-1)所示。
- en: '![f09001](Images/f09001.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![f09001](Images/f09001.png)'
- en: 'Figure 9-1: Open an incognito window in Chrome.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-1：在 Chrome 中打开隐身窗口。
- en: After opening an incognito browser window, make sure you’re running a web server
    using the command `node server.js` from your command line and enter **localhost:8080/collide.html**
    into your web browser. Click **More Tools**▶**Developer tools** from the menu
    in the top right, as shown in [Figure 9-2](#figure9-2).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 打开隐身浏览器窗口后，确保在命令行中使用`node server.js`命令运行一个Web服务器，然后在浏览器中输入**localhost:8080/collide.html**。从右上角菜单中点击**更多工具**▶**开发者工具**，如[图
    9-2](#figure9-2)所示。
- en: '![f09002](Images/f09002.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![f09002](Images/f09002.png)'
- en: 'Figure 9-2: Open the Developer tools in Chrome.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2：在 Chrome 中打开开发者工具。
- en: You should see several tabs across the top of the Developer tools. To see the
    profiler, click **Performance**, as shown in [Figure 9-3](#figure9-3).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到开发者工具顶部的多个标签。要查看性能分析器，点击**性能**，如[图 9-3](#figure9-3)所示。
- en: '![f09003](Images/f09003.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![f09003](Images/f09003.png)'
- en: 'Figure 9-3: Open the Performance tab in Chrome.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-3：在 Chrome 中打开性能标签。
- en: 'The Performance tab offers two options when you initially open it: Record and
    Reload. The Record button begins recording a profile without reloading the application.
    This kind of profiling is most important when you’re less concerned about the
    startup time of your application and more concerned with peak performance. Before
    we profile, make sure the Memory checkbox at the top of the Performance tab is
    selected. If it isn’t, the memory heap won’t be profiled. If you want to profile
    your application from initialization, you would click the Reload button. Click
    **Record** to continue. Once you’ve recorded for about five seconds, click **Stop**
    as shown in [Figure 9-4](#figure9-4).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 性能标签在你第一次打开时提供两个选项：记录和重新加载。记录按钮会在不重新加载应用程序的情况下开始录制性能数据。这种性能分析最适用于你不太关心应用程序启动时间，而更关注峰值性能的情况。在我们开始性能分析之前，确保在性能标签的顶部勾选了内存复选框。如果没有勾选，内存堆将不会被分析。如果你希望从应用初始化开始进行性能分析，可以点击重新加载按钮。点击**记录**继续。一旦录制了大约五秒钟，点击**停止**，如[图
    9-4](#figure9-4)所示。
- en: '![f09004](Images/f09004.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![f09004](Images/f09004.png)'
- en: 'Figure 9-4: Recording a profile in Chrome'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-4：在 Chrome 中录制性能数据
- en: When recording stops, the profiler will open and show a recording of every frame
    rendered by your application. A Summary tab in the bottom half shows that the
    vast majority of this application’s execution time is tied up in Scripting ([Figure
    9-5](#figure9-5)), which includes JavaScript and WebAssembly time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当录制停止后，性能分析器会打开，并展示应用程序渲染的每一帧记录。底部的摘要标签显示，应用程序执行的大部分时间都花费在了脚本执行（[图 9-5](#figure9-5)），这包括
    JavaScript 和 WebAssembly 时间。
- en: '![f09005](Images/f09005.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![f09005](Images/f09005.png)'
- en: 'Figure 9-5: Chrome Performance tab after recording the profile'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-5：录制性能数据后的 Chrome 性能标签
- en: On this main Performance page, a pie chart shows the processing time spent Scripting,
    Rendering, Painting, System, and Idle. Above the pie chart is a series of tabs,
    including Summary, Bottom-Up, Call Tree, and Event Log,all of which we’ll explore
    in this chapter. The section above these tabs shows the JS Heap memory allocated,
    and above that, the rendered frames, CPU, and FPS information. Let’s take a quick
    look at the JavaScript heap memory in the next section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主要的性能页面中，一个饼图展示了在脚本执行、渲染、绘制、系统和空闲时间中花费的处理时间。饼图上方是一些标签，包括摘要、从下到上、调用树和事件日志，我们将在本章中进行探讨。以上这些标签的上方显示了分配的
    JS 堆内存，此外，还有渲染的帧数、CPU 和 FPS 信息。接下来，我们将快速查看 JavaScript 堆内存。
- en: JavaScript Heap Memory
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JavaScript 堆内存
- en: The profile in [Figure 9-5](#figure9-5) shows that there’s been a growth in
    heap memory. We’ll spend a little time investigating why this is happening. First,
    we’ll check how much memory is allocated before it’s garbage collected. Some developers
    believe that because JavaScript is a garbage collected language, they don’t need
    to be concerned about memory. Unfortunately, that’s not the case; it’s still possible
    for your code to create objects faster than they can be garbage collected. It’s
    also possible to hold on to references to objects longer than they’re needed,
    leaving JavaScript unable to know if it should delete them. If an application
    is growing in memory size as quickly as this one is, it makes sense to watch how
    much memory is allocated before garbage collection. Then try to understand where
    the application allocates memory. Right now, the heap size is about 1MB.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-5](#figure9-5) 中的分析显示堆内存有增长。我们将花些时间调查为什么会发生这种情况。首先，我们检查在垃圾回收前分配了多少内存。一些开发者认为，因为
    JavaScript 是一种垃圾回收语言，所以他们不需要担心内存问题。不幸的是，这并非如此；你的代码仍然可能创建对象的速度超过垃圾回收器能回收它们的速度。也有可能将对象的引用保持得比实际需要的时间更长，这样
    JavaScript 无法判断是否应该删除这些对象。如果一个应用程序的内存增长速度像这个一样快，那么监控垃圾回收前分配的内存是很有意义的。然后，尝试理解应用程序在哪里分配了内存。目前，堆内存的大小大约是
    1MB。'
- en: After some additional profiling, we can see that the JS Heap grows to 2.2MB,
    and after the garbage collector runs, the heap size drops back down to 1.2MB.
    It might take several minutes before the garbage collector runs, so please be
    patient. [Figure 9-6](#figure9-6) shows the profile of the JS Heap during garbage
    collection. As you can see, on the right side of the graph, the size of the heap
    takes a sudden significant drop in size of 1MB.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些额外的性能分析后，我们可以看到 JS 堆内存增长到 2.2MB，而在垃圾回收器运行后，堆内存大小降回到 1.2MB。垃圾回收器运行可能需要几分钟，所以请耐心等待。[图
    9-6](#figure9-6) 显示了垃圾回收过程中 JS 堆内存的变化情况。如你所见，在图表的右侧，堆内存大小突然显著下降了 1MB。
- en: '![f09006](Images/f09006.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![f09006](Images/f09006.png)'
- en: 'Figure 9-6: Memory drop during garbage collection'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-6：垃圾回收期间的内存下降
- en: It’s best to determine precisely where this memory allocation is happening,
    because if we could slow the growth of the heap, it would potentially reduce the
    burden on the garbage collector.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最好精确地确定这个内存分配发生的位置，因为如果我们能减缓堆内存的增长，它有可能减少垃圾回收器的负担。
- en: Following the Memory Allocation
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 内存分配跟踪
- en: Because the growth of the heap is consistent, we can deduce that memory allocation
    is likely happening every frame render. The majority of the work this application
    does is in the WebAssembly module, so we first comment out the WebAssembly call
    to see whether the memory continues to show the same JS Heap growth profile. Open
    *collide.html* and comment out the call to `animation_wasm()` inside the `animate`
    function, as shown in [Listing 9-1](#listing9-1).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于堆内存的增长是持续的，我们可以推测内存分配可能发生在每一帧的渲染过程中。这个应用程序的大部分工作都在 WebAssembly 模块中完成，因此我们首先注释掉
    WebAssembly 的调用，看看内存是否继续显示相同的 JS 堆增长分析。打开 *collide.html*，并如 [清单 9-1](#listing9-1)
    所示，注释掉 `animate` 函数内的 `animation_wasm()` 调用。
- en: '**collide.html**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**collide.html**'
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 9-1: Commenting out the `animation_wasm` function call'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-1：注释掉 `animation_wasm` 函数调用
- en: Now reload the page and record a new profile. [Figure 9-7](#figure9-7) shows
    the new JS Heap profile without the `animation_wasm` function call.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新加载页面并记录一个新的性能分析。[图 9-7](#figure9-7) 显示了没有 `animation_wasm` 函数调用的新的 JS 堆内存分析。
- en: '![f09007](Images/f09007.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![f09007](Images/f09007.png)'
- en: 'Figure 9-7: Heap memory allocation graph after the `animation_wasm`function
    is removed'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-7：`animation_wasm` 函数移除后的堆内存分配图
- en: Without the call to the WebAssembly module, the app no longer functions properly.
    However, you can still see the same JS Heap growth profile, so the growth in memory
    doesn’t appear to be coming from the WebAssembly module. Let’s uncomment the call
    to the WebAssembly module; then comment out the call to `ctx.putImageData` and
    create another profile, as shown in [Listing 9-2](#listing9-2).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 没有对 WebAssembly 模块的调用后，应用程序无法正常运行。然而，你仍然可以看到相同的 JS 堆内存增长分析，因此内存的增长似乎不是来自 WebAssembly
    模块。接下来，我们取消注释 WebAssembly 模块的调用，然后注释掉 `ctx.putImageData` 的调用，并创建另一个性能分析，正如 [清单
    9-2](#listing9-2) 所示。
- en: '**collide.html**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**collide.html**'
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 9-2: The `animation_wasm` function is back in; `putImageData` is removed.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-2：`animation_wasm` 函数已恢复，`putImageData` 被移除。
- en: With the call to `ctx.putImageData` commented out, we can now create a new profile
    to check the memory growth ([Figure 9-8](#figure9-8)).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释掉 `ctx.putImageData` 调用后，我们现在可以创建一个新的分析结果来检查内存增长情况（[图 9-8](#figure9-8)）。
- en: '![f09008](Images/f09008.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![f09008](Images/f09008.png)'
- en: 'Figure 9-8: Memory growth is slower when the `putImageData` call is removed.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-8：移除 `putImageData` 调用时，内存增长变慢。
- en: Without the call to `ctx.putImageData`, the memory growth slowed tremendously.
    Growth is still occurring, but it has a slower stair step growth pattern rather
    than an almost straight vertical line up. It appears that the call to `ctx.putImageData`
    is internally creating large objects that the garbage collector will eventually
    need to remove. Now we know how that memory is being allocated. Because `ctx.putImageData`
    is a built-in function, there isn’t anything we can do to optimize it. If memory
    allocation had been the problem, we would need to look into an alternative means
    to render to the canvas.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有 `ctx.putImageData` 调用的情况下，内存增长明显变慢。虽然增长依然存在，但其增长呈现较慢的阶梯型模式，而不是几乎垂直的直线。这表明，`ctx.putImageData`
    调用内部可能正在创建一些大型对象，垃圾回收器最终需要删除它们。现在我们知道内存是如何分配的。由于 `ctx.putImageData` 是一个内置函数，我们无法优化它。如果内存分配是问题所在，我们就需要寻找其他方式来渲染到画布上。
- en: Frames
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 帧
- en: In the Profiler window is an area above the heap memory that provides more performance
    information, including the frames per second (fps) rendered. It also shows a graph
    that displays CPU usage. And there are small thumbnails of each frame rendered.
    When you move your mouse over these frames, you can watch how your application
    rendered its animation ([Figure 9-9](#figure9-9)), which can be very helpful if
    your application isn’t working as expected.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析器窗口中，堆内存上方有一个区域，提供更多的性能信息，包括渲染的每秒帧数（fps）。它还显示了一个显示 CPU 使用率的图表，并展示了每一帧渲染的小缩略图。当你将鼠标悬停在这些帧上时，你可以观察到应用程序如何渲染其动画（[图
    9-9](#figure9-9)），这对你调试应用程序是否按预期工作非常有帮助。
- en: '![f09009](Images/f09009.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![f09009](Images/f09009.png)'
- en: 'Figure 9-9: Viewing the individual frame render in the profiler'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-9：在分析器中查看单独的帧渲染
- en: You can hover your mouse over the green *Frames* boxes to see the fps at any
    point in the profile ([Figure 9-10](#figure9-10)).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将鼠标悬停在绿色的*Frames*框上，查看分析中任意时刻的 fps（[图 9-10](#figure9-10)）。
- en: '![f09010](Images/f09010.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![f09010](Images/f09010.png)'
- en: 'Figure 9-10: Viewing fps in the profiler'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-10：在分析器中查看 fps
- en: As you can see, the frame rate at this point in the application’s execution
    is 18 fps. When we scrub over the frames, the number hovers between 17 and 20\.
    Frames per second is the primary measure of performance for the collision detection
    app, so we’ll need to remember the profile showing us roughly 18 fps to compare
    it with later results. Keep in mind that running the profiler appears to harm
    the app’s performance, so although the results are useful relative to each other,
    they might not be totally accurate on how the app runs in the wild.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在应用程序执行的这一时刻，帧率为 18 fps。当我们拖动帧时，帧数在 17 和 20 之间徘徊。每秒帧数是碰撞检测应用性能的主要衡量标准，因此我们需要记住大约
    18 fps 的分析结果，以便与之后的结果进行比较。请记住，运行分析器似乎会影响应用程序的性能，因此尽管这些结果在相互比较时很有用，但它们可能并不完全准确地反映应用程序在实际环境中的表现。
- en: Bottom-Up
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自下而上
- en: The Bottom-Up tab shows the functions called within the application, the total
    time they ran, and the Self Time, which is the amount of time the function ran
    excluding the time spent in the functions they call. Self Time is very useful
    because functions that call other functions that take a long time to run will
    always show a longer Total Time, as you can see in [Figure 9-11](#figure9-11).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 自下而上的标签显示了应用程序内调用的函数、它们运行的总时间以及自时间（Self Time），即函数运行的时间，排除了它调用的其他函数所花费的时间。自时间非常有用，因为调用其他运行时间较长的函数的函数，总时间总是会比较长，正如你在[图
    9-11](#figure9-11)中看到的那样。
- en: '![f09011](Images/f09011.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![f09011](Images/f09011.png)'
- en: 'Figure 9-11: Chrome’s Bottom-Up tab window'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-11：Chrome 的自下而上标签窗口
- en: The Self Time for `<wasm-unnamed>` is by far the longest. The Total Time is
    longer in several functions, such as `animate`, because the `animate` function
    calls the WebAssembly module. It’s a bit disappointing that Chrome doesn’t indicate
    which function it calls inside the WebAssembly module, but we can determine at
    a glance that the application spends more than 90 percent of its processing time
    executing WebAssembly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`<wasm-unnamed>`的自时间是最长的。总时间在多个函数中更长，例如`animate`，因为`animate`函数调用了WebAssembly模块。令人有些失望的是，Chrome没有指出它在WebAssembly模块中调用了哪个函数，但我们可以一眼看出，应用程序有超过90%的处理时间是在执行WebAssembly。'
- en: Firefox Profiler
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Firefox性能分析器
- en: Using the Firefox profiler is another excellent way to gather performance data
    on your application. I recommend opening a private window when you run the Firefox
    profiler. Do this by opening the menu in the top right of the browser and clicking
    **New Private Window** ([Figure 9-12](#figure9-12)).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Firefox性能分析器是收集应用程序性能数据的另一种优秀方式。我建议在运行Firefox性能分析器时打开一个私人窗口。可以通过打开浏览器右上角的菜单，点击**新建私人窗口**来实现（[图9-12](#figure9-12)）。
- en: '![f09012](Images/f09012.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![f09012](Images/f09012.png)'
- en: 'Figure 9-12: Open a New Private Window in Firefox.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-12：在Firefox中打开一个新的私人窗口。
- en: Open the profiler by clicking **Web Developer**▶**Performance** ([Figure 9-13](#figure9-13)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**Web开发者**▶**性能**来打开性能分析器（[图9-13](#figure9-13)）。
- en: '![f09013](Images/f09013.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![f09013](Images/f09013.png)'
- en: 'Figure 9-13: Click **Web Developer**▶**Performance** in the Firefox menu.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-13：在Firefox菜单中点击**Web开发者**▶**性能**。
- en: In the Performance menu, click the **Start Recording Performance** button to
    record performance data. After a few seconds, stop recording. [Figure 9-14](#figure9-14)
    shows something similar to what you should see in the Performance tab. The Waterfall
    tab (which is the default view after recording) shows the top-level function calls
    and how long they take to execute.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能菜单中，点击**开始录制性能**按钮以录制性能数据。几秒钟后，停止录制。[图9-14](#figure9-14)展示了你应该在性能标签中看到的内容类似的结果。Waterfall标签（这是录制后的默认视图）显示了顶级函数调用以及它们执行所需的时间。
- en: '![f09014](Images/f09014.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![f09014](Images/f09014.png)'
- en: 'Figure 9-14: Firefox Performance window Waterfall tab'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-14：Firefox性能窗口中的Waterfall标签
- en: Scroll down to see where the garbage collection takes place and how long it
    takes to run. This report is a bit boring for our application, which primarily
    executes `requestAnimationFrame`. The three tabs across the top of the window
    provide more information. The Waterfall tab gives you a general idea of where
    tasks are running long. We won’t go into detail about the Waterfall tab, because
    it’s more of a *runtime at a glance* summary. Instead we’ll look at the Call Tree
    and JS Flame Chart tabs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动以查看垃圾回收发生的位置以及执行所需的时间。对于我们的应用程序来说，这个报告有点无聊，因为它主要执行`requestAnimationFrame`。窗口顶部的三个标签提供了更多信息。Waterfall标签让你大致了解任务执行时间过长的地方。我们不会详细讲解Waterfall标签，因为它更像是一个*一目了然的运行时*总结。相反，我们将重点查看Call
    Tree和JS Flame Chart标签。
- en: Call Tree
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Call Tree
- en: The Call Tree tab shows the function calls in which the application spends most
    of its time. The interface allows you to drill down into each of the functions
    and see the calls they make. [Figure 9-15](#figure9-15) shows a screenshot of
    the Call Tree tab.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Call Tree标签显示了应用程序花费大部分时间的函数调用。该界面允许你深入查看每个函数，并查看它们调用了哪些函数。[图9-15](#figure9-15)展示了Call
    Tree标签的截图。
- en: '![f09015](Images/f09015.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![f09015](Images/f09015.png)'
- en: 'Figure 9-15: Firefox Call Tree tab'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-15：Firefox的Call Tree标签
- en: One nice feature is that you can click the name of your WebAssembly file, and
    the link will take you to the proper function in your WebAssembly code. The function
    names are lost, but an index showing the function number in WAT follows the `wasm-function`
    label. That makes it a little easier to determine what the function calls.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的功能是，你可以点击WebAssembly文件的名称，链接会将你带到WebAssembly代码中的相应函数。函数名称会丢失，但一个显示函数编号的索引会跟随`wasm-function`标签。这样可以稍微帮助确定函数调用的内容。
- en: JS Flame Chart
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JS Flame Chart
- en: The JS Flame Chart tab is pretty much the same information you see in the Call
    Tree tab, but it’s organized along a timeline instead of as a summary. You can
    zoom in on a specific portion of the chart to see which functions are running
    at that point in the profile ([Figure 9-16](#figure9-16)).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: JS Flame Chart标签显示的信息与Call Tree标签中看到的信息几乎相同，但它是按照时间线组织的，而不是作为总结。你可以放大图表的特定部分，查看在该时间点上执行的函数（[图9-16](#figure9-16)）。
- en: '![f09016](Images/f09016.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![f09016](Images/f09016.png)'
- en: 'Figure 9-16: Firefox JS Flame Chart tab'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Here is the call to the JavaScript `animate` function. The `animate` function
    spends most of its time running `wasm-function[6]`, which is the seventh function
    in our WAT code, called `$main`. The `$main` function calls `wasm-function[5]`,
    which is the sixth function (`$get_obj_attr`) and `wasm-function[1]` (`$abs`).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Each one of these tabs shows the minimum and maximum fps on the left side and
    the average fps on the right side. The left side of the profiler looks something
    like [Figure 9-17](#figure9-17).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![f09017](Images/f09017.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-17: Firefox max and min fps'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the maximum fps is a bit more than 22, and the minimum is a
    little less than 5 fps. As mentioned earlier, running the profiler might impact
    the fps. The average fps is on the right side of the profiler ([Figure 9-18](#figure9-18)).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![f09018](Images/f09018.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-18: Firefox average fps'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The average fps for this profile was approximately 14 fps. In the next section,
    we’ll look at how to improve the app’s performance using `wasm-opt`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: wasm-opt
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use the `wasm-opt` command line tool to run performance optimizations on
    a WebAssembly file. It comes with `wat-wasm` and *Binaryen.js*. If you’ve installed
    `wat-wasm` to use for the `wat2wasm` tool, you should already have a version and
    can skip the next section. If not, install *Binaryen.js*, which is a JavaScript
    version of the Binaryen WebAssembly tool for converting an Intermediate Representation
    (IR) into WebAssembly code. It has some helpful options for optimizing WebAssembly
    code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Installing Binaryen
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several options for installing Binaryen. I recommend using *Binaryen.js*,
    which you can install using `npm` with the following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For those interested in building it from the source, it’s available on GitHub
    at [https://github.com/WebAssembly/binaryen](https://github.com/WebAssembly/binaryen).
    There is also an `npm` package called `wasm-opt` that will install the platform-specific
    binaries for *Binaryen*, but I would recommend installing `wat-wasm` or *binaryen.js*
    using `npm` instead.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Running wasm-opt
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `wasm-opt` tool has a number of flags you can use to minimize the download
    size and optimize the execution of your WebAssembly module. You use these flags
    to tell the optimizer whether to focus on performance or download size. If a change
    can be made to reduce the file size without affecting performance, that change
    will be made in either case. The same is true if a change can be made to improve
    the performance without affecting download size. These flags tell the compiler
    which optimization to prefer when there is a trade-off to consider.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: We’ll run `wasm-opt` against our *collide.wasm* file with both types of flags,
    starting with the size optimization preference and then compiling it again with
    a performance preference. These flags will be the same with any toolchain that
    uses Binaryen, such as Emscripten or AssemblyScript. The first two flags we’ll
    look at will optimize the WAT file for size.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两种标志运行`wasm-opt`，首先使用针对文件大小的优化偏好，然后再次编译以优化性能。这些标志适用于任何使用Binaryen的工具链，如Emscripten或AssemblyScript。我们首先将查看的两个标志会优化WAT文件的大小。
- en: Optimizing for Download Size
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 针对下载大小的优化
- en: 'The `wasm-opt` command has two flags that optimize your WebAssembly file for
    download size: `-Oz` and `-Os`. The O is a capital letter O, not a zero. The `-Oz`
    flag creates a smaller WebAssembly file but takes longer to reduce the size of
    the file. The `-Os` file creates a slightly larger WebAssembly file but takes
    less time to execute. Our application is small, so the time it takes to run either
    optimization will also be minimal. You might use `-Os` if you’re creating a sizeable
    Emscripten project that takes a long time to compile. For our purposes, we don’t
    need to use `-Os`. [Listing 9-3](#listing9-3) shows how to optimize our *collide.wasm*
    file to reduce its size using the `-Oz` flag.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-opt`命令有两个标志可以优化你的WebAssembly文件以减小下载大小：`-Oz`和`-Os`。O是大写字母O，而不是数字零。`-Oz`标志会创建一个更小的WebAssembly文件，但缩小文件大小所需的时间更长。`-Os`标志会创建一个略大的WebAssembly文件，但执行时间较短。我们的应用程序很小，因此无论运行哪种优化，所需时间也都非常短。你可能会在创建一个大型Emscripten项目时使用`-Os`，因为它需要较长的编译时间。就我们的目的而言，我们不需要使用`-Os`。[清单9-3](#listing9-3)显示了如何使用`-Oz`标志优化我们的*collide.wasm*文件以减小其大小。'
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 9-3: Running `wasm-opt` to optimize the *collide.wasm* file for download
    size'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-3：运行`wasm-opt`以优化*collide.wasm*文件的下载大小
- en: When you run this optimization, the size of the WebAssembly file shrinks from
    709 bytes to 666 bytes. That’s only about a 6 percent reduction, but we didn’t
    have to do any work to get there. Typically, you’ll get better size reductions
    when you use this flag with a toolchain.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此优化时，WebAssembly文件的大小从709字节减少到666字节。减少了大约6%的大小，但我们没有做任何额外的工作来实现这个效果。通常，当你使用此标志和工具链时，会获得更好的大小减少效果。
- en: Optimizing for Execution Time
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 针对执行时间的优化
- en: 'When you’re writing a game, you’ll be more interested in improving the fps
    than the download time. There are three optimization flags: `-O1`, `-O2`, and
    `-O3`. Again, the O is a letter o, not a zero. The `-O3` flag provides the highest
    level of optimization but takes the longest to execute. The `-O1` flag executes
    in the shortest time but provides the least optimization. The `-O2` flag is somewhere
    in between the two. Because our app is so small there isn’t a significant difference
    between the time it takes to run `-O1` and `-O3`. In [Listing 9-4](#listing9-4),
    we use the `-O3` flag to get the most from our optimization of the *collide.wasm*
    file.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写游戏时，你会更关注提升帧率（fps）而不是下载时间。有三个优化标志：`-O1`、`-O2` 和 `-O3`。再说一遍，O是字母o，而不是数字零。`-O3`标志提供了最高级别的优化，但执行时间最长。`-O1`标志执行时间最短，但优化效果最差。`-O2`标志介于两者之间。由于我们的应用程序非常小，`-O1`和`-O3`的执行时间差异不大。在[清单9-4](#listing9-4)中，我们使用`-O3`标志来从我们的优化中获取最大收益，优化的是*collide.wasm*文件。
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 9-4: Using `wasm-opt` to optimize performance of the *collide.wasm*
    file'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 清单9-4：使用`wasm-opt`优化*collide.wasm*文件的性能
- en: Once you have the new version of the *collide.wasm* file, modify the *collide.html*
    file to run the optimized version. Now when we run it through a profiler, we can
    get an idea of the performance improvement. Profiling with Chrome shows the app
    now running at 35 fps ([Figure 9-19](#figure9-19)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了新的*collide.wasm*文件版本，修改*collide.html*文件以运行优化后的版本。现在，当我们通过分析器运行它时，可以了解性能的提升情况。在Chrome中进行分析，显示应用现在运行在35
    fps的帧率上（[图9-19](#figure9-19)）。
- en: '![f09019](Images/f09019.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![f09019](Images/f09019.png)'
- en: 'Figure 9-19: New fps in Chrome for the optimized *collide-3.wasm* file'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-19：优化后的*collide-3.wasm*文件在Chrome中的新帧率
- en: '[Figure 9-10](#figure9-10) showed that the original frame rate was 18 fps.
    Just running `wasm-opt` can double the frame rate of your application in Chrome.
    Let’s see what happens when we run our profiler in Firefox ([Figure 9-20](#figure9-20)).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-10](#figure9-10)显示了原始帧率为18 fps。仅仅运行`wasm-opt`就能使你的应用在Chrome中帧率翻倍。接下来，让我们看看在Firefox中运行分析器时会发生什么（[图9-20](#figure9-20)）。'
- en: '![f09020](Images/f09020.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![f09020](Images/f09020.png)'
- en: 'Figure 9-20: New fps in Firefox for the optimized *collide-3.wasm* file'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-20：优化后的*collide-3.wasm*文件在Firefox中的新帧率
- en: Looking back at [Figure 9-18](#figure9-18), we were only running at an average
    of 14 fps in our initial run, so the frame rate more than doubled in Firefox.
    In the next section, we’ll look at the disassembled optimized WAT code to see
    the kinds of optimizations `wasm-opt` made.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾[图 9-18](#figure9-18)，我们在最初的运行中只达到了平均 14 帧每秒，因此在 Firefox 中，帧率几乎翻倍。在接下来的章节中，我们将查看反汇编后的优化
    WAT 代码，看看 `wasm-opt` 做了哪些优化。
- en: Looking at Optimized WAT Code
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看优化后的 WAT 代码
- en: You should have the WebAssembly extension for VS Code installed (we did this
    in Chapter 1)*.* In Visual Studio, you can right-click a WebAssembly file and
    select Show WebAssembly to view the WAT for a given WebAssembly file. In [Listing
    9-5](#listing9-5), we use `wasm2wat` at the command line to convert the optimized
    *collide-3.wasm* file into a WAT file.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经安装了 VS Code 的 WebAssembly 扩展（我们在第一章中做了这一步）。在 Visual Studio 中，你可以右键点击一个
    WebAssembly 文件，选择“显示 WebAssembly”来查看给定 WebAssembly 文件的 WAT。在[清单 9-5](#listing9-5)中，我们使用命令行中的
    `wasm2wat` 将优化后的 *collide-3.wasm* 文件转换为 WAT 文件。
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 9-5: Run `wasm2wat` to disassemble *collide-3.wasm* to WAT.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 9-5：运行 `wasm2wat` 将 *collide-3.wasm* 反汇编为 WAT。
- en: Open *collide.wat* next to *collide-3.wat* in VS Code, and look at the updates
    `wasm-opt` made to the WebAssembly file, as shown in [Figure 9-21](#figure9-21).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 VS Code 中打开 *collide.wat* 和 *collide-3.wat*，查看 `wasm-opt` 对 WebAssembly
    文件所做的更新，如[图 9-21](#figure9-21)所示。
- en: In the optimized code, all the function and variable names are gone. I’ve added
    a few comments to help you follow along. You can quickly see that the optimization
    has reduced the number of functions from seven to three. The optimization achieved
    this by expanding many of the small functions into inline code. In one of the
    remaining functions, the optimization removed a variable. You might create two
    different variables when, technically, you need only one because it makes the
    code more straightforward to read. The optimizer can detect this and reduce the
    number of variables. Also notice that the optimizer replaces multiplication by
    powers of 2 with left shifts. For example, in the code in [Figure 9-21](#figure9-21),
    the optimizer has replaced a multiplication by 4 with a left shift of 2\. In the
    next section, we’ll take a closer look at how some of these strategies improve
    performance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化后的代码中，所有的函数和变量名都消失了。我添加了一些注释来帮助你跟进。你可以很快看到，优化将函数的数量从七个减少到三个。优化通过将许多小函数展开为内联代码实现了这一点。在剩下的函数之一中，优化移除了一个变量。你可能会创建两个不同的变量，而实际上只需要一个，因为这样可以使代码更易于阅读。优化器可以检测到这一点并减少变量的数量。还要注意，优化器将乘法运算替换为二的幂次左移。例如，在[图
    9-21](#figure9-21)中的代码，优化器将乘以 4 替换为了左移 2 位。在接下来的章节中，我们将更详细地探讨这些策略如何提升性能。
- en: '![f09021](Images/f09021.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![f09021](Images/f09021.png)'
- en: 'Figure 9-21: Comparing an optimized and an unoptimized version of *collide.wat*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-21：比较优化版本和未优化版本的 *collide.wat*
- en: Strategies for Improving Performance
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提升性能的策略
- en: Now we’ll look into some of the strategies you can use to improve your WebAssembly
    application’s performance. The optimizer uses some of these techniques, and you
    can code your application in such a way that you make the optimizer’s job easier.
    Sometimes you might want to look at the WAT code generated by the optimizer to
    obtain tips on ways you can improve code. Let’s look at a few common optimization
    techniques you can use with WAT.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看一些可以用来提升 WebAssembly 应用程序性能的策略。优化器使用了一些这些技术，你也可以通过编写代码来使优化器的工作变得更加简单。有时，你可能希望查看优化器生成的
    WAT 代码，从中获得改进代码的建议。让我们来看看你可以在 WAT 中使用的一些常见优化技术。
- en: Inlining Functions
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内联函数
- en: Calling a function has a tiny bit of overhead. That overhead is not typically
    a big problem unless the function is called thousands or millions of times a second.
    Inlining a function is the process of replacing a function call with an inline
    copy of the same code. Doing this removes the additional processing overhead required
    to make the function call but increases the size of the WebAssembly module, because
    it duplicates the code wherever the function was called. When we ran the optimizer
    on the *collide.wasm* module, it inlined four of the seven functions. Let’s look
    at a quick example of inlining a function. The following WAT code isn’t a part
    of an application; it’s just a demonstration. In [Listing 9-6](#listing9-6), we
    create a function that adds three numbers together and then create another function
    to call `$add_three` a few times.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个函数有一点点开销。除非函数每秒被调用成千上万次，否则这种开销通常不会成为大问题。内联函数是将函数调用替换为该函数相同代码的过程。这样做可以去除执行函数调用所需的额外处理开销，但会增加
    WebAssembly 模块的大小，因为它在每个调用该函数的地方都会复制代码。当我们对*collide.wasm*模块运行优化器时，它内联了七个函数中的四个。让我们看一个内联函数的简单示例。以下的
    WAT 代码并不是应用的一部分，它只是一个演示。在[Listing 9-6](#listing9-6)中，我们创建了一个将三个数字相加的函数，然后创建了另一个函数来多次调用`$add_three`。
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 9-6: Demonstration code for us to inline'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-6：用于内联的演示代码
- en: We’ll focus on inlining as the optimization for this section. To inline these
    functions, we cut and paste the contents of the function in every place where
    it’s called. In [Listing 9-7](#listing9-7), the grayed-out code is the original
    function call, and the code that follows is the inlined function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于内联作为本节的优化方法。为了内联这些函数，我们将函数的内容复制粘贴到每个调用它的地方。在[Listing 9-7](#listing9-7)中，灰色代码是原始的函数调用，后面的代码是内联的函数。
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 9-7: Example of hand-inlined code'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-7：手动内联代码示例
- en: Inlining the function calls might expose other optimization opportunities. For
    example, you can see that we’re adding `2` and later adding `13`. Because both
    of these values are constants, the code would perform better if we just added
    `15`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 内联函数调用可能会暴露其他优化机会。例如，你可以看到我们在添加`2`之后又添加了`13`。由于这两个值都是常量，如果我们直接添加`15`，代码的性能会更好。
- en: 'Let’s write a little module that could potentially be inlined, compile and
    optimize it, and then look at the code generated by `wasm-opt`. We’ll create a
    module with three functions: `$add_three`, `$square`, and `$inline_test`. Create
    a WAT file named *inline.wat* and add the code in [Listing 9-8](#listing9-8).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个可能会被内联的模块，编译并优化它，然后查看`wasm-opt`生成的代码。我们将创建一个包含三个函数的模块：`$add_three`、`$square`和`$inline_test`。创建一个名为*inline.wat*的
    WAT 文件，并在其中添加[Listing 9-8](#listing9-8)中的代码。
- en: '**inline.wat**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**inline.wat**'
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 9-8: We’ll use `wasm-opt` to inline this code'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-8：我们将使用`wasm-opt`来内联这段代码
- en: 'The `$add_three` function is the same function we inlined by hand in [Listing
    9-7](#listing9-7). The `$square` function multiplies the value on the top of the
    stack against itself, and the `$inline_test` function is the calling function.
    Let’s compile the `$inline_test` function using `wat2wasm`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`$add_three`函数是我们在[Listing 9-7](#listing9-7)中手动内联的相同函数。`$square`函数将栈顶的值与自身相乘，而`$inline_test`函数是调用函数。让我们使用`wat2wasm`编译`$inline_test`函数：'
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we can optimize it using `wasm-opt`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`wasm-opt`进行优化：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, let’s convert it back to WAT using `wasm2wat`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用`wasm2wat`将其转换回 WAT：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now we can open *inline-opt.wat* and see what our optimized code looks like
    ([Listing 9-9](#listing9-9)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以打开*inline-opt.wat*，查看我们的优化代码是什么样的（[Listing 9-9](#listing9-9)）。
- en: '**inline-opt.wat**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**inline-opt.wat**'
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 9-9: The optimized version of *inline.wat*, *inline-opt.wat*, inlines
    both functions.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 9-9：优化后的*inline.wat*版本，*inline-opt.wat*，内联了两个函数。
- en: The optimizer removed the two functions `$add_three` and `$square`, and placed
    that code inline in the `inline_test` function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器移除了两个函数`$add_three`和`$square`，并将这些代码内联到`inline_test`函数中。
- en: Multiply and Divide vs. Shift
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 乘法和除法与位移
- en: Chapter 8 showed how to shift integer bits to the right as a faster way to multiply
    by powers of 2\. For example, a shift left of 3 is the same as multiplying by
    2³, which is 8\. Similarly, shifting an integer to the right is the same as dividing
    by that power of 2\. For example, a right shift of 4 is the same as dividing by
    2⁴, which is 16\. Let’s see how `wasm-opt` deals with power-of-2 multiplication
    and division. Create a new WAT file named *pow2_mul.wat* and add the code in [Listing
    9-10](#listing9-10), which creates a module to multiply and divide by powers of
    2.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '**pow2_mul.wat**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 9-10: A function to multiply and divide by powers of 2'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Compile this code using `wat2wasm`, use `wasm-opt` to optimize the WebAssembly
    file, and then disassemble the WebAssembly file back into a WAT file using `wasm2wat`.
    Then open the optimized version of *pow2_mul.wat* in VS Code, as shown in [Listing
    9-11](#listing9-11).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '**pow2_mul_optimized.wat**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 9-11: Optimized version of the `pow2_mul` function from [Listing 9-10](#listing9-10)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the optimized code performs the division on the second parameter
    before performing the multiplication on the first parameter. When you multiply
    by a power-of-2 constant, `wasm-opt` will convert this into a left shift. However,
    `wasm-opt` doesn’t always replace a power-of-2 division with a right shift. Later
    in this chapter, we’ll spend some time running different versions of this code
    through *benchmark.js* to see how they perform. We’ll compare the optimized code
    generated by `wasm-opt` to code we optimize by hand to see if we can do better.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Combining Constants
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Often, optimizations will combine constants to improve performance. For example,
    say you have two constant offsets you need to add together. Your original code
    has *x* = 3 + 8, but this code would perform better if you just set *x* = 11 at
    the start. Cases like this aren’t always obvious to the human eye, but `wasm-opt`
    is efficient at hunting down these situations for you. As an example, create a
    WAT file named *combine_constants.wat* and add the code in [Listing 9-12](#listing9-12),
    which simply combines three constants.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '**combine_constants.wat**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 9-12: A function that adds three constants together'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the value returned by `$combine_constants` will always be 85\. The
    `wasm-opt` tool is smart enough to figure that out. When you run the code through
    `wat2wasm`, `wasm-opt`, and then `wasm2wat`, you’ll see the code in [Listing 9-13](#listing9-13).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '**combine_constants_optimized.wat**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 9-13: The addition of three constants is combined into a single constant.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The function in [Listing 9-13](#listing9-13) returns `85` 1 and doesn’t bother
    to perform the two additions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: DCE
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Dead Code Elimination (DCE)* is an optimization technique that removes any
    code not being called or exported by your module. This is a straightforward optimization
    that doesn’t improve the execution time but does reduce the size of the download.
    DCE happens no matter which optimization flag you use. Let’s look at a quick example.
    Open a new file named *dce_test.wat* and add the code in [Listing 9-14](#listing9-14),
    which creates a module with two functions that are never used.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '**dce_test.wat**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 9-14: This module has two unused functions.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The first two functions, `$dead_code_1` 1 and `$dead_code_2` 2, aren’t called
    and aren’t exported. Any optimization we run will remove these functions. Run
    `wat2wasm` to generate the code, `wasm-opt` with the `-O3` flag to optimize it,
    and `wasm2wat` to convert it back into a WAT file. Open that new file to view
    the code after the optimization has run, as shown in [Listing 9-15](#listing9-15).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**dce_test_optimized.wat**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 9-15: Two functions are removed by DCE.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The only function that remains is `"dce_test"`. Using DCE has reduced the size
    of the module from 79 bytes to 46 bytes.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the Collision Detection App with JavaScript
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve seen how our WebAssembly collision detection app performs. Let’s write
    that code in JavaScript relatively quickly and compare how it performs to the
    WebAssembly version. Create a new web page named *collidejs.html*. Begin by adding
    a header and a canvas element to the *collide.html* page and resaving it as *collidejs.html*,
    as shown in [Listing 9-16](#listing9-16).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '**collidejs.html (part 1 of 2)**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 9-16: HTML header and canvas element in *collidejs.html*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: This code is similar to the WebAssembly version of the app. The main difference
    will be in the `script` tag, shown in [Listing 9-17](#listing9-17). Add the following
    JavaScript in the `script` tag.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '**collidejs.html (part 2 of 2)**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 9-17: JavaScript version of our collision detection application'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: I won’t go into detail about the code in [Listing 9-17](#listing9-17) because
    its purpose is just to provide a comparison with the WebAssembly code in Chapter
    8. Now we can run *collidejs.html* in the Chrome and Firefox profilers to see
    how they perform. [Figure 9-22](#figure9-22) shows the frame rate for *collidejs.html*
    inside the Chrome profiler.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![f09022](Images/f09022.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-22: The frame rate of our JavaScript app running in the Chrome profiler'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Chrome ran the JavaScript version of the app at about 9 fps, slower than both
    the unoptimized WebAssembly version, which ran at about 18 fps in Chrome, and
    the optimized version, which ran at 35 fps. The optimized version of the WebAssembly
    code was almost four times as fast in Chrome.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at how our JavaScript performed in Firefox ([Figure 9-23](#figure9-23)).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![f09023](Images/f09023.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-23: The frame rate of our JavaScript app running in the Firefox profiler'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Firefox performed quite a bit better than Chrome for this application (almost
    twice as fast). It even managed to outperform the unoptimized version of the WebAssembly
    app on Firefox, which ran at around 14 fps. This was only a little more than half
    as fast as the optimized version of the WebAssembly app on Firefox, which ran
    at about 31 fps.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to compare your WebAssembly code with similar
    JavaScript code using the Firefox and Chrome profilers. You should now be able
    to use this knowledge to compare different versions of your application on different
    browsers to get a feel for the kind of code that is best done in WebAssembly and
    what is best to do in JavaScript.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Hand Optimizing WAT
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I spent some time hand optimizing my WebAssembly collider app and was able to
    improve my fps number even more. There were more changes than I can describe in
    this book. However, I want to point out the kinds of performance gains you might
    achieve if you want to take the time to optimize by hand. I was able to get the
    collider app to perform up to 36 fps in the Chrome profiler ([Figure 9-24](#figure9-24)).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![f09024](Images/f09024.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-24: Hand optimized collider app running in Chrome'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Firefox had an even higher frame rate of 52 fps ([Figure 9-25](#figure9-25)).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![f09025](Images/f09025.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-25: Hand optimized collider app running in Firefox'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: You can see the product of my hand optimization efforts at [https://wasmbook.com/collide.html](https://wasmbook.com/collide.html)and
    the WAT code at [https://wasmbook.com/collide.wat](https://wasmbook.com/collide.wat).
    I ran the Binaryen optimizer on my finely tuned code, and it actually slowed it
    down by a few fps. Binaryen is constantly improving their optimized output. Results
    may be different by the time you read this.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Logging Performance
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the simplest ways to log performance from a JavaScript app is by using
    the `Date` class and the `console.log` function. WebAssembly can’t write to the
    console without using JavaScript. For this reason, we’ll need to use JavaScript
    to log the performance of our WebAssembly and JavaScript code to the console.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the overhead involved in making many calls from our JavaScript
    into the WebAssembly module. We’ll create a WebAssembly module with a few small
    functions that we can call repeatedly from JavaScript. Create a file named *mod_and.wat*
    file and add the code in [Listing 9-18](#listing9-18).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '**mod_and.wat**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 9-18: Compare performance of remainder versus bitwise AND'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: There are two functions in this module, a `$mod` function that finds the remainder
    of a division by `1000` and a `$and` function that uses a bitwise AND mask. Compile
    the *mod_and.wat* file using `wat2wasm`, and optimize it using `wasm-opt`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to create a JavaScript function to run this WAT module and test
    it against the equivalent JavaScript code. Create a new file named *mod_and.js*
    and add the code in [Listing 9-19](#listing9-19).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '**mod_and.js**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 9-19: Recording the runtime with `Date.now` and `console.log`'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-19：使用`Date.now`和`console.log`记录运行时间
- en: Before running each block of code, we set a variable `start_time` to `Date.now()`.
    Doing so sets the `start_time` variable to the current time in milliseconds. When
    we complete the code, we log `Date.now``() - start_time`, which gives us the runtime
    of our test in milliseconds. We’ll do this for our WebAssembly module and our
    JavaScript code to compare the two.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行每个代码块之前，我们设置一个变量`start_time`为`Date.now()`。这样做将`start_time`变量设置为当前时间的毫秒数。完成代码后，我们记录`Date.now()
    - start_time`，这将给出我们测试的运行时间（毫秒）。我们会对WebAssembly模块和JavaScript代码执行这个操作，以便比较两者。
- en: 'Now that we have our *mod_and.js* function, we can run it using the following
    `node` command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了*mod_and.js*函数，可以使用以下`node`命令来运行它：
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[Listing 9-20](#listing9-20) shows the output after running *mod_and.js*.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-20](#listing9-20)显示了运行*mod_and.js*后的输出。'
- en: '[PRE24]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 9-20: Output from *mod_and.js*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-20：*mod_and.js*的输出
- en: The `mod` function took 29 milliseconds to run four million times. The `and`
    function took 23 milliseconds to run four million times. The JavaScript version
    only took 4 milliseconds to run four million times. So if WebAssembly is so fast,
    why did it take between five and seven times as long to run those functions? The
    problem is that calls between JavaScript and WebAssembly have some overhead. Calling
    a small function four million times also incurs the cost of that overhead four
    million times. Let’s rewrite our code to execute our functions a few million times
    from within the WebAssembly rather than from a loop in the JavaScript.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`mod`函数执行四百万次花费了29毫秒。`and`函数执行四百万次花费了23毫秒。JavaScript版本执行四百万次只花费了4毫秒。那么，如果WebAssembly这么快，为什么它的执行时间却是这些函数的五到七倍呢？问题在于JavaScript和WebAssembly之间的调用存在一些开销。调用一个小函数四百万次时，也会产生四百万次开销的成本。让我们重写代码，从WebAssembly内部执行这些函数，而不是从JavaScript的循环中调用它们。'
- en: First, we’ll rewrite our WebAssembly module to include the loop inside the module
    instead of inside the JavaScript. Create a new WAT file named *mod_and_loop.wat*
    and add the code in [Listing 9-21](#listing9-21).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将重写WebAssembly模块，将循环包含在模块内部，而不是在JavaScript内部。创建一个新的WAT文件，命名为*mod_and_loop.wat*，并添加[列表
    9-21](#listing9-21)中的代码。
- en: '**mod_and_loop.wat**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**mod_and_loop.wat**'
- en: '[PRE25]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 9-21: Looping version of the bitwise AND/modulo functions'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-21：按位与/取余函数的循环版本
- en: These functions do the same tasks as the functions in the original, but the
    program runs them 100 million times. We’ll need to change the JavaScript file
    to call these functions once and to run the JavaScript 100 million times. That
    way, we can compare the performance with the WebAssembly module, which we earlier
    changed to execute our function 100 million times. Create a new function named
    *mod_and_loop.js* and add the code in [Listing 9-22](#listing9-22).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数执行的任务与原始函数相同，但程序将它们执行1亿次。我们需要修改JavaScript文件，只调用这些函数一次，并让JavaScript执行1亿次。这样，我们就可以将性能与WebAssembly模块进行比较，后者已经修改为执行函数1亿次。创建一个名为*mod_and_loop.js*的新函数，并添加[列表
    9-22](#listing9-22)中的代码。
- en: '**mod_and_loop.js**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**mod_and_loop.js**'
- en: '[PRE26]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 9-22: JavaScript that runs the `and_loop`, `mod_loop`, and comparable
    JavaScript'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-22：运行`and_loop`、`mod_loop`和相应JavaScript代码的JavaScript
- en: We call the `mod_loop` and the `and_loop` functions, recording the time each
    loop took to execute. Next, we run our loop where we perform a modulo 100 million
    times and record how long that took. If we compile and optimize our WebAssembly
    module and then run *mod_and_loop.js* using `node`, we should see something like
    the output in [Listing 9-23](#listing9-23).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`mod_loop`和`and_loop`函数，记录每个循环执行所花的时间。接下来，我们运行一个循环，在其中执行100百万次取余操作，并记录所花费的时间。如果我们编译并优化WebAssembly模块，然后使用`node`运行*mod_and_loop.js*，我们应该看到类似[列表
    9-23](#listing9-23)中的输出。
- en: '[PRE27]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 9-23: Output from *mod_and_loop.js*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-23：*mod_and_loop.js*的输出
- en: Now the WebAssembly is 67 percent faster than the same JavaScript code. It was
    somewhat disappointing that the bitwise AND didn’t perform much better than a
    modulo, as I had hoped it would. However, we now know how to do the simplest performance
    test using `console.log` in conjunction with `Date.now()`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在WebAssembly比相同的JavaScript代码快了67%。虽然按位与操作的性能没有比取余操作好多少，这点让我有些失望，但至少我们现在知道如何使用`console.log`结合`Date.now()`进行最简单的性能测试了。
- en: More Sophisticated Testing with benchmark.js
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用benchmark.js进行更复杂的测试
- en: If you want to make your testing a bit more sophisticated than just using logs
    and `Date.now`, you can install a performance testing module, such as *benchmark.js*.
    Earlier in [Listing 9-10](#listing9-10), we created a WebAssembly function that
    multiplied by 16 and then divided by 8, and ran it through `wasm-opt` to see how
    Binaryen would optimize the code for us. The optimizer swapped the multiplication
    actions with a shift but didn’t swap in a shift for the divide. It also rearranged
    the division and the multiplication.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test several versions of this WebAssembly module, including the original
    and the version generated by the optimizer, to see whether it’s possible to outdo
    the optimizer with a bit of effort. We’ll use *benchmark.js* to test the performance
    of all of these functions. Create a new WAT file named *pow2_test.wat* and add
    the code in [Listing 9-24](#listing9-24).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '**pow2_test.wat (part 1 of 5)**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 9-24: The beginning of the module with the original function'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-24](#listing9-24) shows the original version of our power-of-2 test,
    where we multiplied by 16 and divided by 8\.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The next function, in [Listing 9-25](#listing9-25), runs the division before
    the multiplication. I wanted to test this because `wasm-opt` swapped the multiplication
    and division functions, and I was curious to know whether that had a positive
    effect on the function’s performance.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '**pow2_test.wat (part 2 of 5)**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 9-25: Swap the division and multiplication'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: The next function, in [Listing 9-26](#listing9-26), uses a shift for both power-of-2
    multiplication and division. We also use the order inserted by the optimizer,
    where the division happens before the multiplication.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '**pow2_test.wat (part 3 of 5)**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 9-26: Change the multiply and divide expressions to binary shifts'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Next, in [Listing 9-27](#listing9-27), we use a shift for both division and
    multiplication, but this time we don’t change the order of the division and multiplication
    from the original code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '**pow2_test.wat (part 4 of 5)**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 9-27: The original order with multiply before divide'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: This next function, in [Listing 9-28](#listing9-28), is the version of the code
    produced by `wasm-opt` with the `-O3` flag.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '**pow2_test.wat (part 5 of 5)**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 9-28: The `wasm-opt` optimized version of the function'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can compile this module with `wat2wasm`, but we should *not* optimize
    it, because we’re trying to test the WAT code as it is without modifications from
    the optimizer. Next, we need to create our *benchmark.js* code. First, we’ll need
    to install the *benchmark.js* module using `npm`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now we can write a JavaScript program to test the WebAssembly functions using
    *benchmark.js*. Let’s break this program into several chunks and walk through
    them a piece at a time. Add the code in [Listing 9-29](#listing9-29) to *benchmark_test.js*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '**benchmark_test.js**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 9-29: The first part of the *benchmark_test.js* JavaScript file'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: First, we require 1 the `benchmark` module, and then create a new `suite` 2
    object from that module. We require the `fs` 3 module and use that to load the
    WebAssembly module into a `byte` array. We then define a series of variables to
    hold the functions in the WebAssembly module. We log out a `rainbow` 4 color separator
    that displays `RUNNING BENCHMARK` to make it easier to spot where the benchmark
    begins as we scroll back up through our stats. If you’re like me, you might change
    the module as you benchmark it, in which case, it can be helpful to have a conspicuous
    place where the benchmarking begins.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 9-30](#listing9-30), we’ll add a function we can call to initialize
    and run the benchmark suite. Add the following function to *benchmark_test.js*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '**benchmark_test.js**'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 9-30: The `init_benchmark` function'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: We define the `init_benchmark()` 1 function, which calls `suite.add`2 from the
    benchmark module for each of the functions in our WebAssembly module. Using `suite.add`
    tells the benchmark suite to test that function and log the results with the string
    passed as the second parameter. The `suite.on` function sets an event callback
    for different events that occur during a benchmark test. The first call to `suite.on`
    3 sets the callback for each cycle, which will output the function we tested and
    the stats for that test. The next call to `suite.on` 4 sets the callback for the
    completion of the benchmark test, which will use the `filter` 5 method to `log`
    6 the fastest and slowest functions. We then filter on `'successful'` 7 to get
    an array of all the functions that ran successfully. We `sort` 8 that array by
    the `mean` (average) runtime for that cycle. That sorts the cycles from the fastest
    to the slowest runtime. We can then loop 9 through each of those cycles, printing
    them from fastest to slowest. At the end of this function, we `run` a the `suite`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: With the `init_benchmark` function defined, in [Listing 9-31](#listing9-31)
    we create the asynchronous IIFE to instantiate our WebAssembly module and call
    `init_benchmark`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '**benchmark_test.js**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 9-31: Asynchronous IIFE instantiates WebAssembly and runs *benchmark**.js**.*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we `instantiate` 1 our WebAssembly module and set all of the functions
    2 we’ll be calling from *benchmark.js*. We then run *benchmark.js* by calling
    `init_benchmark()` 3. Now we can run our application using `node` with the following
    command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[Figure 9-26](#figure9-26) shows the output.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![f09026](Images/f09026.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9-26: Output from *benchmark_test.js*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, the slowest of these functions was the `wasm-opt` optimized
    version: the original version and the `wasm-opt` optimized version executed in
    about the same time. The fastest run was the code where we replaced the `i32.mul`
    and `i32.div_u` operations with shifts, and reordered the calls in the way that
    the `wasm-opt` tool rearranged them. This illustrates that you can’t assume that
    `wasm-opt` (or any programmatic optimizer) will always give you the highest-performing
    code. Running performance tests on your application is always advisable.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Comparing WebAssembly and JavaScript with --print-bytecode
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll geek out on low-level bytecode. It’s fun and interesting
    to look at what the JavaScript JIT generates. It’s also fascinating to compare
    with WebAssembly and intriguing to think about how to improve performance. If
    this topic doesn’t interest you, feel free to skip ahead to the next section.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Let’s briefly look at how to make a better comparison between WebAssembly code
    and JavaScript. V8 compiles JavaScript into an IR bytecode, which looks a lot
    like an assembly language or WAT. IR uses registers and an accumulator but isn’t
    machine specific. We can use IR to compare the JavaScript code after it runs through
    the JIT compiler with our WebAssembly code. Because they’re both low-level bytecodes,
    it gives us a better *apples to apples* comparison to look at. But keep in mind
    that the JavaScript code will need to be parsed and compiled into this bytecode
    at runtime, whereas WebAssembly is compiled ahead of time.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a small JavaScript program and use the `node --print-bytecode`
    flag to look at the bytecode generated from that JavaScript. Create a JavaScript
    file named *print_bytecode.js* and add the code in [Listing 9-32](#listing9-32).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '**print_bytecode.js**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: // if we don't call this, the function is removed in dce check
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 9-32: The `bytecode_test` function that we’ll execute with the `--print-bytecode`
    flag'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: This `bytecode_test` function is similar to the code that we performance tested
    in [Listing 9-22](#listing9-22). It’s a simple `for`loop that takes the modulo
    of the `i` counter, stores it in `x`, and then returns `99`. It doesn’t really
    do anything useful, but I wanted to work with a function that is easy to understand,
    so we can compile it into bytecode.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: We then call the function in addition to defining it; otherwise, V8 will remove
    it as a part of DCE. We can then run the `node` command in [Listing 9-33](#listing9-33)
    to print the bytecode.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Listing 9-33: Run `node` with the `--print-bytecode` flag'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: We pass the `--print-bytecode` flag to `node` to instruct it to print the bytecode.
    We also pass in the `--print-bytecode-filter` flag, setting it to the name of
    our function to print that function’s bytecode. If we don’t include the filter
    flag, the output will be way more bytecode than we want to look at. Finally, we
    pass `node` the name of the JavaScript file. Run *print_bytecode.js* with the
    flags from [Listing 9-33](#listing9-33), and you should get the output in [Listing
    9-34](#listing9-34).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 9-34: Bytecode output from *print_bytecode.js*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: The right side of the output in [Listing 9-34](#listing9-34) has the opcodes
    for the IR. Here I’ve listed those opcodes and added WAT-style comments on the
    right side. Instead of a stack machine, the bytecode that the V8 engine generated
    is for a virtual register machine with an accumulator register. The *accumulator*
    is where this virtual machine performs its calculations. Take a quick look at
    the code in [Listing 9-35](#listing9-35), which V8 generated.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 9-35: Opcodes with an explanation after the *;;* characters'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The IR for V8 uses an accumulator. Accumulator machines have one general-purpose
    register where the accumulator does all of the math instead of doing it in the
    other registers. The opcodes with the letter `a` in them usually refer to the
    accumulator, and `r` usually refers to a register. For example, the first opcode
    after `StackCheck` is `LdaZero`, which loads (`Ld`) the accumulator (`a`) with
    0 (`Zero`). Then the line `Star` `r0` stores (`St`) the value in the accumulator
    (`a`) into a register (`r`) and then passes in `r0` to define that register. It
    does this because the IR can’t set `Register0` to a value of 0 directly; instead,
    it needs to load that value into the accumulator and then move the value in the
    accumulator into `Register0`. Later in the code, you see `LdaSmi.ExtraWide`. This
    loads (`Ld`) the accumulator (`a`) with a small integer (`Smi`) that uses all
    32 bits (`ExtraWide`). If you loaded a number that used 16 bits, it would have
    displayed `Wide` instead of `ExtraWide`, and 8 bits wouldn’t have anything following
    `LdaSmi`. The `TestLessThan` opcode compares the value in the register specified
    (`r1`) with the value in the accumulator. The line `JumpIfFalse` `[22]` checks
    whether the `TestLessThan` resulted in false, and if so, jumps 22 bytes forward.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: The `--print-bytecode` flag can be a useful tool to help performance tune your
    JavaScript. If you’re familiar with WAT or assembly, it’s not difficult to understand.
    It can also be useful in comparing your WAT code with JavaScript for performance
    tuning reasons in both parts of your WebAssembly application.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we discussed several tools for evaluating the performance of
    our WAT code. We also compared our code to the performance of equivalent JavaScript.
    Then we explored several strategies for improving the performance of our WebAssembly
    module.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the profiler in the Chrome web browser and discussed the Summary
    page and the JS Heap Memory section, which provided information about memory spikes
    and garbage collection. We also looked at the fps in our profile, which is an
    excellent way to determine the performance of a game or UI heavy application.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: We used the Firefox profiler to investigate our collision detection application.
    The Firefox profiler offers a few extra tools, including the Call Tree and the
    JS Flame Chart. We tracked down the WAT function that was called by using the
    `wasm-function[index]` listed in the profiler.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Next, we installed *Binaryen.js* and used the `wasm-opt` tool to optimize our
    WebAssembly module for either download size or peak performance. We also disassembled
    it back into WAT code, so we could view the changes the optimizer made.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: We then looked into a variety of strategies for improving the peak performance
    of our application, including inlining functions, replacing multiplication and
    division with bit-shifts, and combining constants. We discussed DCE, which the
    optimizer performs to remove any unused functions from our module.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: We created a JavaScript version of our application to compare the performance
    of JavaScript against that of the WebAssembly module.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: After using the profiler throughout most of this chapter, we looked at other
    methods for determining our module’s performance. Using `console.log` and `Date.now`
    is the simplest method of measuring performance in an application, and the testing
    suite *benchmark.js* provides more detailed information for evaluating the performance
    of different functions. Just for fun, we printed the V8 IR bytecode to evaluate
    JavaScript code further and compared it with WebAssembly. In the next chapter,
    you’ll learn about debugging the WebAssembly modules.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
