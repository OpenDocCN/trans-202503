- en: '2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ARITHMETIC AND OTHER NUMERICAL PARAPHERNALIA
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll take a look at the rich set of numerical data types that
    Racket provides. We’ll discover the expected integer and floating-point values,
    but we’ll also learn that Racket supports rational (or fractional) values along
    with complex numbers (don’t worry if you don’t know what complex numbers are;
    they are not heavily used in this text, but we take a brief look for those that
    may be interested).
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Booleans* are true and false values, and while they aren’t strictly numbers,
    they behave a bit like numbers in that they can be combined by various operators
    to produce other Boolean values. The discipline governing these operations is
    known as *Boolean algebra*. In Racket, Booleans are represented by the values
    `#t` and `#f`, true and false respectively. It’s also possible to use `#true`
    (or `true`) and `#false` (or `false`) as aliases for `#t` and `#f` respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we introduce specific Boolean operators, one important observation about
    Racket Boolean operators in general is that they typically treat any value that’s
    not literally `#f` as true. You’ll see some examples of this behavior below.
  prefs: []
  type: TYPE_NORMAL
- en: The first operator we’ll look at is `not`, which simply converts `#t` to `#f`
    and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `5` was converted to `#f`, meaning that it was originally treated
    as `#t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next Boolean operator we’ll look at is `and`, which returns true if all
    its arguments are true. Let’s look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You may be a bit puzzled by the last example (and rightfully so). Remember that
    Racket considers all non-false values as true, so 23 is in fact a valid return
    value. More important though is how `and` evaluates its arguments. What happens
    in reality is that `and` sequentially evaluates its arguments until it hits a
    `#f` value. If no `#f` value is encountered, it returns the value of its last
    argument, 23 in the example above. While this behavior seems a bit odd, it is
    consistent with how the `or` operator works, where, as we’ll see shortly, it can
    be quite useful in certain circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last Boolean operator we’ll look at is the `or` operator, which will return
    true if any of its arguments are true and `#f` otherwise. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Much like `and`, `or` sequentially evaluates its arguments. But in `or`’s case,
    the first *true* value is returned. In the example above, 45 is treated as true,
    so that’s the value returned. This behavior can be quite useful when one wants
    the first value that’s not `#f`.
  prefs: []
  type: TYPE_NORMAL
- en: Other less frequently used Boolean operators are `nand`, `nor`, and `xor`. Consult
    the Racket Documentation for details on these operators.
  prefs: []
  type: TYPE_NORMAL
- en: The Numerical Tower
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In mathematics there’s a hierarchy of number types. *Integers* are a subset
    of rational (or fractional) numbers. *Rational numbers* are a subset of real numbers
    (or floating-point values as they are approximated by computers). And *real numbers*
    are a subset of complex numbers. This hierarchy is known as the *numerical tower*
    in Racket.
  prefs: []
  type: TYPE_NORMAL
- en: '***Integers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In mathematics the set of integers is represented by the symbol ℤ. Racket integers
    consist of a sequence of digits from 0 to 9, optionally preceded by a plus or
    minus sign. Integers in Racket are said to be *exact*. What this means is that
    applying arithmetical operations to exact numbers will always produce an exact
    numerical result (in this case a number that’s still an integer). In many computer
    languages, once an operation produces a number of a certain size, the result will
    either be incorrect or it will be converted to an approximate value represented
    by a floating-point number. With Racket, numbers can get bigger and bigger until
    your computer literally runs out of memory and explodes. Here are some examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the last examples, division doesn’t result in a floating-point
    number but rather returns an *exact* value: a rational number (discussed in the
    next section).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to enter integers in number bases other than 10\. Racket understands
    *binary numbers* (integers prefixed by `#b`), *octal* numbers (integers prefixed
    by `#o`), and *hexadecimal* numbers (integers prefixed by `#x`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Non-decimal bases have somewhat specialized use cases, but one example is that
    HTML web pages typically express color values as hexadecimal numbers. Also, binary
    numbers are how computers store all values internally, so they can be useful for
    individuals studying basic computer science. Octal and hexadecimal values have
    a further advantage: binary numbers can easily be converted to octal since three
    binary digits equates to a single octal value and four binary digits equates to
    a single hexadecimal digit.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Rationals***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next up on the mathematical food chain are the rational numbers (or fractions),
    expressed by the mathematical symbol ℚ. Fractions in Racket consist of two positive
    integer values separated by a forward slash (no spaces allowed), optionally preceded
    by a plus or minus sign. Rational numbers are also an exact numeric type, and
    all operations permitted for integers are also valid for rational numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The numerator and denominator of a rational number can be obtained with the
    `numerator` and `denominator` functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '***Reals***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *real* number is a mathematical concept (specified by the symbol ℝ) that,
    in reality, does not exist in the world of computers. Real numbers such as *π*
    have an infinite decimal expansion that can only be approximated in a computer.
    Thus, we reach our first class of *inexact* numbers: floating-point numbers. Floating-point
    numbers in Racket are entered in the same way as they are in most programming
    languages and calculators. Here are some (unfortunately boring) examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to keep in mind that there are some subtle distinctions in the
    mathematical concept of certain number types and what they mean in a computing
    environment. For example a number entered as 1/10 is, as mentioned above, treated
    as an exact rational number since it can be represented as such in a computer
    (internally it’s stored as two binary integer values), but the value 0.1 is treated
    as an inexact floating-point value, an approximation of the real number value,
    since it cannot be represented internally a single binary value (at least not
    without using an infinite number of binary digits).
  prefs: []
  type: TYPE_NORMAL
- en: '***Complex Numbers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we use the term *complex* number it does not mean we are speaking of a
    *complicated* number, but rather a special type of number. If you’re not already
    familiar with this concept, there’s no harm in moving on to the next section,
    since complex numbers aren’t used in the remainder of the book (although I would
    encourage you to read up on this fascinating subject). This section is included
    as a reference for the brave souls who may make use of this information in their
    own projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complex numbers are entered almost exactly as they appear in any mathematical
    text, but there are some points to note. First, if the real component is omitted,
    the imaginary part must be preceded by a plus or minus sign. Second, there can
    be no spaces in the string used to define the number. And third, complex numbers
    must end in `i`. Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that complex numbers can be exact or inexact. We can test exactness using
    the `exact?` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To get at the components of a complex number, use `real-part` and `imag-part`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This concludes our look at the numerical tower and basic arithmetical operations
    on the various number types. In the next few sections we’ll look at comparison
    operators, what happens when different number types are added together (for example
    adding an integer to a floating-point number), and some useful mathematical functions.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric Comparison
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Racket supports the usual complement of numeric comparison operators. We can
    test if numbers are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'and compare their sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can also use these operators on multiple arguments, and Racket will ensure
    that the elements pair-wise satisfy the comparison operator. In the example below,
    this means that 1 < 2, 2 < 3, and 3 < 4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'But there’s no *not equals* operator, so to test if two numbers are not equal
    to each other, you would have to do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Combining Data Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you saw above, you can compare numbers of different types. But notice that
    we only performed arithmetic on exact numbers with exact numbers and vice versa.
    Here we’ll discuss the implications of mixing exact and inexact numbers. Mixing
    exact and inexact numbers won’t result in mass chaos (think *Ghostbusters* stream-crossing),
    but there are some fine points you should be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: 'First and foremost, when it comes to arithmetic operators (addition, subtraction,
    and so on), the rules are fairly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Mixing exact with exact will give an exact result.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing inexact with inexact will give an inexact result.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing exact with inexact (or vice versa) will give an inexact result.
  prefs: []
  type: TYPE_NORMAL
- en: No surprises here, but there are some nuanced exceptions to these rules, such
    as multiplying anything by zero gives exactly zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Trigonometric functions will generally always return an inexact result (but
    again, there are some reasonable exceptions; for example `exp 0` gives an exact
    1). You’ll see some of these functions later in the chapter. The square function,
    `sqr`, will return an exact result if given an exact number. Its square root counterpart,
    `sqrt`, will return an exact result if it’s given an exact number *and* the result
    is an exact number; otherwise, it will return an inexact number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of functions available to test exactness. Earlier you saw
    the function `exact?`, which returns `#t` if its argument is an exact number;
    otherwise it returns `#f`. Its counterpart is `inexact?`. It’s also possible to
    force an exact number to be inexact and vice versa using two built-in functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There’s a predicate to test for each of the numeric data types we have mentioned
    in this section, but they may not work exactly as you expect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: These predicates return a result that honors the mathematical meaning of the
    predicate. You may have expected `(complex? 70)` to return `#f`, but integers
    are complex numbers, just with a zero real component. Likewise, you may have expected
    `(integer? 70.0)` to return `#f` since it’s a floating-point number, but since
    the fractional part is 0, the number (while also real) is in fact an integer (but
    not an exact number). The number 1.5 is equivalent to 3/2, so Racket considers
    this to be a rational number (but again, inexact). The number type predicates
    (`integer?`, `rational?`, `real?`, and `complex?`) are aligned with the mathematical
    hierarchy (or numerical tower) as mentioned at the beginning of the section.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Aside from the normal arithmetical operators illustrated above, Racket provides
    the usual complement of mathematical functions that are standard fare in any programming
    language. A generous litany of examples follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that when possible, a function that has an exact argument will return an
    exact result.
  prefs: []
  type: TYPE_NORMAL
- en: There are of course many other functions available. Consult the Racket Documentation
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Infix Notation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we’ve seen, in Racket, mathematical operators are given before the operands:
    `(+ 1 2)`. Typical mathematical notation has the operator between the operands:
    1 + 2\. This is called *infix notation*. Racket natively allows a form of infix
    notation by using a period operator. Here are some examples.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This can be useful when we want to make explicit the relationship between certain
    operators, but it’s unwieldy for complex expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For complex mathematical expressions, Racket provides the `infix` package.
    This package can be imported with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `#lang` keyword allows us to define language extensions (in this case the
    `at-exp` allows us to use @-expressions, which we will see shortly). The `require
    infix` expression states that we want to use the *infix* library. Unfortunately,
    the `infix` package is not installed by default and must be installed from the
    Racket package manager (the package manager can be accessed through the DrRacket
    File menu) or the `raco` command line tool (if the executable for `raco` is not
    in your execution path, it can be launched directly from the Racket install folder).
    To install using `raco`, execute the following on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Also note that we’re using the language extension `at-exp`, which, while not
    entirely necessary, provides a nicer syntax to enter infix expressions. For example
    without `at-exp`, to compute 1 + 2 * 3, we would enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `at-exp` extension, we could enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: While this only saves a couple of keystrokes, it removes the annoying string
    delimiters and just looks a bit more natural.
  prefs: []
  type: TYPE_NORMAL
- en: Function calls are handled in a familiar way by using square brackets. For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There is even a special form for lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And there’s one for variable assignments (which use `:=`, equivalent to `set!`,
    so the variable must be bound first):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To further illustrate the capabilities of the `infix` package, below is a complete
    program containing a function called `quad`, which returns a list containing the
    roots of the quadratic equation
  prefs: []
  type: TYPE_NORMAL
- en: '*ax² + bx + c* = 0'
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll recall from your algebra class (you *do* remember, don’t you), these
    roots are given by
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/p039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: After compiling this, we can solve 2*x*² *-* 8*x* + 6 = 0 for *x*, by entering
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: or equivalently . . .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With these first two chapters under your belt, you should be thoroughly familiar
    with Racket’s basic data types. You should also be comfortable performing mathematical
    operations in Racket’s rich numerical environment. This should prepare you for
    the somewhat more interesting topics to follow where we will explore number theory,
    data analysis, logic programming, and more. But, next up is functional programming,
    where we get down to the nitty-gritty of actually creating programs.
  prefs: []
  type: TYPE_NORMAL
