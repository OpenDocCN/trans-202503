<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch9">&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch9">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_157" aria-label=" Page 157. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">AUTHORIZATION WITH OAUTH</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/Drop-image.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">Certain apps store data about users as part of a login workflow. There are many ways to implement this authentication and authorization, but one of the easiest is to use OAuth2 to piggyback on the existing accounts of well-known companies. <i>OAuth2</i>, or simply <i>OAuth</i>, is an open standard for access delegation, and you’ve probably encountered it if you’ve ever used an app’s “log in with Facebook, GitHub, or Google Account” feature.</p>&#13;
<p class="TX">The OAuth protocol essentially allows our web application to access another application’s login data without requiring the third party to share a user’s credentials with us. To do so, the user grants our application access rights to their third-party account through the creation of an access token. OAuth is the accepted standard for authorization-based access delegation, and Amazon, Google, Facebook, Microsoft, and GitHub all support OAuth workflows.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_158" aria-label=" Page 158. "/>This chapter will introduce you to the OAuth workflow and then explore the structure of the bearer tokens used for its access delegation, laying the foundation for implementing OAuth2 into your Food Finder application in <span class="Xref"><a href="part2.xhtml">Part II</a></span>. In <span class="Xref"><a href="#Exe9">Exercise 9</a> on page 168</span>, we won’t update our sample Next.js application with an OAuth flow but instead manually walk through the OAuth authorization process.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-58"/><samp class="SANS_Futura_Std_Bold_B_11">How OAuth Works</samp></h3>&#13;
<p class="TNI">Before we explore OAuth, you need to understand the differences between authentication and authorization. In short, we use authentication to verify the identity of a user, whereas authorization specifies the permissions that the authenticated user possesses and enforces those permissions. OAuth allows for that process to be delegated to a third party with which the user already has an account, which simplifies the login process for the user.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h4 class="H2" id="sec2"><span id="h2-127"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authentication vs. Authorization</samp></h4>&#13;
<p class="TNI">Every time an app receives a login request, it checks the user’s credentials before allowing access, a process called <i>authentication</i>. Usually, those credentials consist of a username and a password, but they could also be hardware tokens or involve biometric factors such as fingerprints or facial recognition. The application then verifies that the credentials match the ones stored in the database.</p>&#13;
<p class="TX">The simplest form of authentication is <i>single-factor authentication</i>, which requires only one factor, usually a password. Unfortunately, it is also the least secure method of implementing authentication. A more robust and recommended form is <i>multifactor authentication</i>, in which a user must supply at least two factors. These might be something the user <i>knows</i>, such as a password, as well as something the user <i>has</i>, such as a physical token, or something the user <i>is</i>, such as the owner of a fingerprint. You probably use multifactor authentication when you log in to PayPal or Google, both of which require you to supply your password and an additional one-time password (OTP).</p>&#13;
<p class="TX">The OTP is a code that is created based on a secret shared between you and the application when you register your account. Both actors regenerate the pair in short intervals. Yours may be generated by an authenticator app, like Google Authenticator, or received in a text message. The application at which you have the account (for example, PayPal or Google) generates its own OTP code and keeps it on the server. As soon as you send yours, the server verifies that the codes cryptographically match.</p>&#13;
<p class="TX">We perform authorization after we’ve authenticated a user. Broadly speaking, this involves looking at the user’s data and deciding whether they have the access rights needed to access a resource. A typical full-stack application can either handle this user data or enable users to log in without providing user data. There are benefits to the latter approach, as handling and storing user data can be inconvenient. It also comes with additional <span role="doc-pagebreak" epub:type="pagebreak" id="pg_159" aria-label=" Page 159. "/>responsibilities, such as the need to adhere to stricter privacy and data retention laws, and requires your users to create another account.</p>&#13;
<p class="TX">Suppose you provide users with the option to log in with an existing account through an authorization provider. In that case, you’ve removed an entry barrier. Also, you don’t need to worry about handling their data. If you need user data—for example, to bill your customers—you can use an OAuth workflow and save the data you receive from the provider, such as the user’s payment details, in your own database if necessary.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H2" id="sec3"><span id="h2-128"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Role of OAuth</samp></h4>&#13;
<p class="TNI">Every time a web application enables you to log in through a third-party provider such as Facebook, GitHub, or Google, it uses the OAuth authorization code flow behind the scenes. OAuth isn’t authentication; rather, it’s a way of authorizing the web application you use to perform actions or to access resources on your behalf. Common actions include posting to your Facebook feed and accessing data such as your name, profile picture, or email address. Consequently, each time you use an OAuth-based login function, the application asks for particular permissions and can use only those you grant to it.</p>&#13;
<p class="TX">To understand OAuth, you must understand its terminology. Each OAuth flow uses a set of RESTful APIs to authorize the <i>client</i> (an application) to get resources (such as the user’s profile information) from a <i>resource provider</i> (such as Facebook, GitHub, or Google) that has the protected resources the client wants to access. In addition, we call the server that provides the OAuth API endpoints the <i>authorization server</i>, and the party that owns the access rights (and, hence, has the ability to grant an application access to a resource) the <i>resource owner</i>. In most scenarios, the resource owner is the application’s end user.</p>&#13;
<p class="TX">To get the resource owner’s authorization, the client application sends its client credentials, the ID, the secret, and the user credentials to the authorization server, which usually is part of the same system as the resource provider. The authorization server authenticates the resource owner and handles the OAuth flow that results in granting them an <i>access token</i>, which allows the user to access the protected resources on the resource provider. Both the authorization server and the resource provider are two sets of APIs on the same system.</p>&#13;
<p class="TX">The <i>client ID</i> is a public identifier for the client app; you can make it public and store it in the code. Unlike the client ID, the <i>client secret</i> should be kept private; it is the app-specific password, and you should never store it in your code. Instead, handle it using Next.js’s environment files or your server’s environment variables.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h4 class="H2" id="sec4"><span id="h2-129"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Grant Types</samp></h4>&#13;
<p class="TNI">There are several variants of the OAuth flow. Each of these <i>grant types</i> covers a specific use case, but all result in the generation of an access token. OAuth specifies four grant types: the client credentials flow, the implicit <span role="doc-pagebreak" epub:type="pagebreak" id="pg_160" aria-label=" Page 160. "/>flow, the authorization code flow, and the resource owner password credentials flow.</p>&#13;
<p class="TX">The <i>client credentials flow</i> covers machine-to-machine communication; we use it when no actual end user authorization is necessary, as in the case of automated tasks that connect to an API. Here, the task itself is both the client and the resource owner. It knows the resource owner’s credentials, the client ID, and the client secret and passes these to the authorization server to receive an access token.</p>&#13;
<p class="TX">The most common grant type for full-stack web development is the <i>authorization code flow</i>. In this scenario, our web application is a client, and it makes two calls to two separate API endpoints. The first is to receive an authorization grant code, and the second is to exchange this authorization grant for an access token. <span class="Xref">“The Authorization Code Flow” on page 161</span> provides a deep dive into this process.</p>&#13;
<p class="TX">The last two grant types shouldn’t be used. The <i>implicit flow</i> is similar to the authorization code flow, but instead of making separate requests to receive the authorization grant and access token, the client receives the access token directly. This flow skips the authorization step, doesn’t include client authentication, and is deprecated. The <i>resource owner password credentials flow</i> should be avoided because it involves the end user passing their user credentials to the client and then the client sending these credentials to the OAuth server to exchange them for the access token. While this sounds straightforward, sending actual user credentials to the remote authorization server is an immense security risk.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h4 class="H2" id="sec5"><span id="h2-130"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Bearer Tokens</samp></h4>&#13;
<p class="TNI">After the client application initiates an OAuth flow, it receives a shared access token, most commonly a <i>bearer token</i> that is easy to implement. This access token replaces the user’s credentials; hence, anyone who has the token can access the data. To prevent security gaps caused by stolen tokens, a bearer token usually has a defined shelf life. Upon expiration, the token can be refreshed only with a valid <i>refresh token</i>. These are long-lived tokens that we use to generate new bearer tokens.</p>&#13;
<p class="TX">Refreshing the token can be done implicitly or explicitly, and there are multiple strategies for preventing stolen refresh tokens from compromising the OAuth access. For example, the OAuth provider can require a unique ID or the client secret to issue a new token. The provider usually rotates the refresh token each time a new bearer token is issued and accepts each refresh token only once. From our perspective as OAuth clients, the details of the refresh token are unimportant, as the OAuth provider handles this token.</p>&#13;
<p class="TX">The bearer token that contains the user session and authentication data is a <i>JSON Web Token (JWT)</i>. JWT is an open standard for securely transmitting data in a JSON object. Because JSON is fairly compact, JWTs can be sent as URL parameters, as part of the POST data, or even inside an HTTP header, all without impacting the application’s performance.</p>&#13;
<p class="TX">JWT tokens can be signed as well as encrypted, saving the application from needing to make an additional request to verify it or retrieve extra <span role="doc-pagebreak" epub:type="pagebreak" id="pg_161" aria-label=" Page 161. "/>data. <i>Encrypted tokens</i> hide the contained data from other parties. These aren’t very common in OAuth due to their additional overhead, so we can ignore them for now. <i>Signed tokens</i> guarantee the integrity of the contained data, because any modification to the token would change its signature. Thus, the application can trust the information stored in it.</p>&#13;
<p class="TX">The most common cryptographic algorithm for signing JWTs is <i>hash-based message authentication code (HMAC)</i> with the SHA-256 hash algorithm. An HMAC is a type of message authentication code (MAC). A MAC’s main feature is that it enables you to verify the authenticity of a message by calculating a checksum from the message. The checksum uses a mathematical function to produce a unique, reproducible value or data string based on the initial message. If the message changes, the checksum changes as well. This way, we can quickly verify the integrity of the data. For the JWT token, we use two checks: the authenticity check confirms that the actual sender sent the message, whereas the data integrity checks verify that the message’s content did not change.</p>&#13;
<p class="TX">Unlike other types of MACs, HMAC uses a cryptographic hash function and a secret key. You can freely choose the cryptographic hash function, but the strength of your HMAC implementation depends on the cryptographic strength of the selected function. JWTs commonly use the SHA-256 hash function, a fast and collision-resistant cryptographic function from the SHA-2 collection also used for authenticating Debian software packages and Bitcoin transactions. In cryptography, <i>collisions</i> occur when two different inputs result in the same output. The higher the possibility of a collision, the less we can trust the checksum of the hash function. If a collision is likely, our message could be replaced with a different one, but the hash function could indicate that it hasn’t changed. Therefore, we want collision-resistant cryptographic functions.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H1" id="sec6"><span id="h1-59"/><samp class="SANS_Futura_Std_Bold_B_11">The Authorization Code Flow</samp></h3>&#13;
<p class="TNI">To understand how an OAuth interaction takes place using the authorization code flow mentioned earlier, let’s return to our fictional weather service. Imagine that you want to grant weather stations the ability to write data to the application by using the API, but a station should be able to modify only its own ZIP code. You also want the application to display the weather stations’ locations and additional details about them. Additionally, you prefer not to deal with the maintenance of user accounts or to manually set up permissions for each station, so using OAuth is your best bet.</p>&#13;
<p class="TX">Let’s assume that each weather station already has a social media account for publishing weather updates. These accounts include typical user information and the stations’ ZIP codes. We could easily use the social media provider as an OAuth authorization provider to access this data. The stations would log in to the weather app using the social media provider, and the app would request access to the weather station’s user profile. We could then check the ZIP code stored in the OAuth session against the one in our dataset, provide the appropriate write access, and retrieve any other data we need.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_162" aria-label=" Page 162. "/>Only a few steps are necessary for implementing this authorization code flow. <a href="chapter9.xhtml#fig9-1">Figure 9-1</a> is a simplified description of these steps. Usually, developers use an SDK or a Node.js module to implement the steps and need to provide only a few properties, such as the client ID, client secret, and callback URL.</p>&#13;
&#13;
<figure class="IMG"><img class="img1" id="fig9-1" src="../images/Figure9-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 9-1: A simplified OAuth authorization grant flow</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To register our app as an OAuth client, we need to provide GitHub with a <i>callback URL</i> to our application, to which GitHub will redirect the user after the authorization request. This endpoint on our application receives the authorization grant. Recent OAuth implementations require the callback URL to use HTTPS as a way to protect the token from being intercepted.</p>&#13;
<p class="TX">Our app must use the resource owner’s credentials and the client credentials, an ID, and a secret to communicate with GitHub’s authorization server. The ID identifies the client, and the secret authenticates it. The app can then request the authorization to access specific resources, such as a weather station’s profile data. To do so, the weather station user needs to log in to GitHub’s authorization server. They’ll see a prompt that summarizes the requested access resources, such as read and write access to the profile or stream. If the user authorizes the requests with their user credentials, the OAuth client receives the authorization grant as a GET parameter in the callback URL, and the OAuth SDK we use in our application exchanges the authorization grant for an access token at the authorization server in the next step of the flow.</p>&#13;
<p class="TX">Here, the OAuth client uses the client credentials, which are the client ID and client secret, in combination with the previously received authorization grant to request an access token from the OAuth provider’s authorization server. It is part of the GitHub infrastructure, and to complete the authorization flow, the authorization server authenticates the identity and verifies that the grant is valid for this identity. Finally, the app receives the bearer token from here and stores it in the user session.</p>&#13;
<p class="TX">With the token and the user session received from the OAuth provider, our app can now act on the user’s behalf and access their protected <span role="doc-pagebreak" epub:type="pagebreak" id="pg_163" aria-label=" Page 163. "/>resources, such as the profile data from the resource server. To act on their behalf, we add the bearer token to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Authorization</samp> header in the HTTP requests; the OAuth provider checks our granted permission and verifies our identity with this token. To access the user’s data, we simply extract it from the session data and use it in our application’s code.</p>&#13;
<p class="TX">For the weather application, we could use the second option to query location-specific weather data from our database. We’d need to read the location property from the user’s session data and use that value as the ZIP code supplied to our API endpoint. In addition, we can access other properties, such as the description and the name or profile picture, to display them on the weather application’s status page for each station.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h3 class="H1" id="sec7"><span id="h1-60"/><samp class="SANS_Futura_Std_Bold_B_11">Creating a JWT Token</samp></h3>&#13;
<p class="TNI">Most bearer tokens are JWTs, and while the authorization server automatically issues them, it’s good to know what kind of information you can find in them. This section will walk you through the process of creating an example OAuth JWT for the weather service app. The JWT is a string made up of three sections divided by periods (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>): the header, the payload, and the signature. The first two sections are Base64-encoded JSON objects, whereas the signature is a checksum of the previous two.</p>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h4 class="H2" id="sec8"><span id="h2-131"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Header</samp></h4>&#13;
<p class="TNI">The first string we create is the <i>header</i>, which defines basic metadata such as the token’s type and the signatures used for the signing algorithm. <a href="chapter9.xhtml#Lis9-1">Listing 9-1</a> shows the creation of a simple header in JavaScript with the most essential metadata.</p>&#13;
<span id="Lis9-1"/>&#13;
<pre class="pre-174"><code>const headerObject = {&#13;
    "typ": "JWT",&#13;
    "alg": "HS256"&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 9-1: The JWT header for the OAuth2 weather service</span></p>&#13;
<p class="TX">We set the type of the weather service’s token to <samp class="SANS_TheSansMonoCd_W5Regular_11">JWT</samp> and specify that we use the HMAC-SHA-256 algorithm to calculate the signature later. Finally, we store the JSON object in a constant to use later.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h4 class="H2" id="sec9"><span id="h2-132"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Payload</samp></h4>&#13;
<p class="TNI">Next, we create the second string, the <i>payload</i>, which stores the token’s data. Each property of the payload is called a <i>claim</i>. In OAuth, the claims describe the user object and, usually, the session data. The JWT specification contains three types of claims: registered, public, and private.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h5 class="H3" id="sec10"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_164" aria-label=" Page 164. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Registered Claims</samp></h5>&#13;
<p class="TNI">There are seven registered claims, each three letters long. While not necessary in general JWTs, the <samp class="SANS_TheSansMonoCd_W5Regular_11">iss</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">auth</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> registered claims are required for OAuth JWTs.</p>&#13;
<p class="TX">The <i>issuer claim</i>, <samp class="SANS_TheSansMonoCd_W5Regular_11">iss</samp>, contains a unique identifier for the entity that issued the JWT. A good value might be the application’s URL, as shown in <a href="chapter9.xhtml#Lis9-2">Listing 9-2</a>.</p>&#13;
<span id="Lis9-2"/>&#13;
<pre class="pre-175"><code>{&#13;
    "iss": "https://www.usemodernfullstack.dev/&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 9-2: A registered issuer claim</span></p>&#13;
<p class="TX">The <i>subject claim</i>, <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, identifies the principal to which the JWT belongs. For an OAuth client authentication flow, the subject claim must be the client ID of the OAuth client, whereas for an OAuth authorization grant, the subject should identify the resource owner or should pseudonymously identify an anonymous user. We create a sample subject claim in <a href="chapter9.xhtml#Lis9-3">Listing 9-3</a>.</p>&#13;
<span id="Lis9-3"/>&#13;
<pre class="pre-176"><code>{&#13;
    "sub": "<var>THE_CLIENT_ID</var>"&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 9-3: A registered subject claim</span></p>&#13;
<p class="TX">The <i>audience claim</i>, <samp class="SANS_TheSansMonoCd_W5Regular_11">aud</samp>, identifies the token’s recipient. Its value could be the token endpoint URL on the authorization server or anything else that identifies the recipient, such as an application ID. See <a href="chapter9.xhtml#Lis9-4">Listing 9-4</a> for an example.</p>&#13;
<span id="Lis9-4"/>&#13;
<pre class="pre-177"><code>{&#13;
    "aud": "api://endpoint"&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 9-4: A registered audience claim</span></p>&#13;
<p class="TX">The <i>expiration claim</i>, <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>, identifies the time window during which the token is valid. After that period, the authorization server will reject the token and you’ll need to request a new one. An expiration claim’s value is a number whose date is defined in “seconds since the Unix Epoch,” a common format for timestamps. It is calculated by counting the number of seconds that have elapsed since January 1, 1970. <a href="chapter9.xhtml#Lis9-5">Listing 9-5</a> shows an example.</p>&#13;
<span id="Lis9-5"/>&#13;
<pre class="pre-178"><code>{&#13;
    "exp":  1134156400&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 9-5: A registered expiration claim</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_165" aria-label=" Page 165. "/>The <i>issued at claim</i>, <samp class="SANS_TheSansMonoCd_W5Regular_11">iat</samp>, is optional and identifies the time at which the authorization server issued the token. You can determine a token’s age from this claim, which is also defined in seconds since the Unix Epoch, as shown in <a href="chapter9.xhtml#Lis9-6">Listing 9-6</a>.</p>&#13;
<span id="Lis9-6"/>&#13;
<pre class="pre-179"><code>{&#13;
    "iat": 1134156200&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 9-6: A registered issued at claim</span></p>&#13;
<p class="TX">The <i>not before claim</i>, <samp class="SANS_TheSansMonoCd_W5Regular_11">nfb</samp>, is optional and identifies the time at which the authorization server should start accepting the token. The authorization server will reject every token with an <samp class="SANS_TheSansMonoCd_W5Regular_11">nfb</samp> claim in the future. We define it as a number in seconds since the Unix Epoch, as you can see in <a href="chapter9.xhtml#Lis9-7">Listing 9-7</a>.</p>&#13;
<span id="Lis9-7"/>&#13;
<pre class="pre-180"><code>{&#13;
    "nfb": 1134156100&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 9-7: A registered not before claim</span></p>&#13;
<p class="TX">The <i>JWT claim</i>, <samp class="SANS_TheSansMonoCd_W5Regular_11">jti</samp>, is optional and sets a unique ID for the token (see <a href="chapter9.xhtml#Lis9-8">Listing 9-8</a>).</p>&#13;
<span id="Lis9-8"/>&#13;
<pre class="pre-181"><code>{&#13;
    "jti": "b5f8f86f-82ab-451e-b391-bf6a07041787"&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 9-8: A registered JWT claim</span></p>&#13;
<p class="TX">The authorization server might keep a list of recent tokens and their expiration dates to check whether the token is being reused in a <i>replay attack</i>, which occurs when an attacker tries to access data by reusing a previously issued token.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h5 class="H3" id="sec11"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Public Claims</samp></h5>&#13;
<p class="TNI">A token’s issuer can define public claims for the purpose of adding an application-specific public API. Unlike private claims, these are custom properties defined for public access. The issuer should register these claims in the JWT Claims registry or use collision-resistant names with custom namespaces—for example, a UUID or the application’s name. Also, as public claims are meant for public consumption, they should never include private or sensitive information.</p>&#13;
<p class="TX">A public claim for the OAuth JWT of our fictional weather service might include the ZIP code to directly provide each station’s location data. By making the ZIP code a public claim, we won’t need to parse the user object and extract the ZIP code manually. Also, as the location is publicly available information on social media profiles, it’s not sensitive.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h5 class="H3" id="sec12"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_166" aria-label=" Page 166. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Private Claims</samp></h5>&#13;
<p class="TNI">Private claims are custom claims that are neither registered claims nor public claims. We can define them to our liking, and they can be specific to our application or use case. Even though they don’t need to be collision resistant, using a private namespace is recommended. Unlike public claims, private claims contain information specific to the application and are intended to be used only internally. Whereas the public claims store generic information such as the name, the private claims contain the application’s user ID and role. For example, we could define a private claim for the OAuth JWT of our fictional weather service to specify the type of service we are using.</p>&#13;
<p class="TX">Now that you understand the payload object’s possible properties, you can create a complete payload like the one in <a href="chapter9.xhtml#Lis9-9">Listing 9-9</a>, which specifies GitHub as the service.</p>&#13;
<span id="Lis9-9"/>&#13;
<pre class="pre-182"><code>const payloadObject = {&#13;
    "exp": 234133423,&#13;
    "weather_public_zip": "96815",&#13;
    "weather_private_type": "GitHub"&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 9-9: The JWT payload for the OAuth weather service</span></p>&#13;
<p class="TX">Again, we create a constant and store the object there. Our payload has three claims, each of a different type. It’s up to the publisher of the JWT token to decide which claims to include; for this example, we limit the size of the token to one of each type. The registered claim <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> sets the expiration date and time, <samp class="SANS_TheSansMonoCd_W5Regular_11">zip</samp> is a public claim, and <samp class="SANS_TheSansMonoCd_W5Regular_11">role</samp> is a private claim. Both use the custom namespace <samp class="SANS_TheSansMonoCd_W5Regular_11">weather</samp> to minimize the risk of a collision.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h4 class="H2" id="sec13"><span id="h2-133"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Signature</samp></h4>&#13;
<p class="TNI">With the header and payload in place, we create a JWT signature by using the algorithm specified in the header to calculate the checksum. We pass the header and payload as Base64-encoded strings and a custom secret to the checksum function. As an exercise, we’ll create the signature in TypeScript with the code from <a href="chapter9.xhtml#Lis9-10">Listing 9-10</a>. You’ll see that the secret is hardcoded for simplicity here. In production code, this secret should be stored in an environment variable.</p>&#13;
<p class="TX">Save the code as <i>index.ts</i> in a TypeScript project, or use <samp class="SANS_TheSansMonoCd_W5Regular_11">npx ts-node index.ts</samp> to run it locally. If you prefer, you can also use a TypeScript sandbox at <a href="https://codesandbox.io"><i>https://<wbr/>codesandbox<wbr/>.io</i></a> or <a href="https://stackblitz.com"><i>https://<wbr/>stackblitz<wbr/>.com</i></a> to run it. Generate a fresh secret (<i><a href="https://www.usemodernfullstack.dev/generate-secret">https://www.usemodernfullstack.dev/generate-secret</a></i>) and use it instead of the one in the listing to see how the token changes.</p>&#13;
<span id="Lis9-10"/>&#13;
<pre class="pre-183"><code>import {createHmac} from "crypto";&#13;
&#13;
const base64UrlEncode = (data: string): string =&gt; {&#13;
    return Buffer.from(data, "utf-8").toString("base64");&#13;
};&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_167" aria-label=" Page 167. "/>const headerObject = {&#13;
    typ: "JWT",&#13;
    alg: "HS256"&#13;
};&#13;
&#13;
const payloadObject = {&#13;
    exp: 234133423,&#13;
    weather_public_zip: "96815",&#13;
    weather_private_type: "GitHub"&#13;
};&#13;
&#13;
const createJWT = () =&gt; {&#13;
    const base64Header = base64UrlEncode(JSON.stringify(headerObject));&#13;
    const base64Payload = base64UrlEncode(JSON.stringify(payloadObject));&#13;
&#13;
    const secret = "59c4b48eac7e9ac37c046ba88964870d";&#13;
&#13;
    const signature: string = createHmac("sha256", secret)&#13;
        .update(`${base64Header}.${base64Payload}`)&#13;
        .digest("hex");&#13;
&#13;
        return [base64Header, base64Payload, signature].join(".");&#13;
};&#13;
&#13;
console.log(createJWT());&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 9-10: An</span> <span class="Futura_Std_Book_11">index.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file to calculate the JWT signature for the OAuth2 weather service</span></p>&#13;
<p class="TX">We use Node.js’s standard crypto module and then create a library for transforming the JSON objects into Base64-encoded strings via buffers. We pass the strings and the <samp class="SANS_TheSansMonoCd_W5Regular_11">secret</samp> to the crypto module’s <samp class="SANS_TheSansMonoCd_W5Regular_11">createHmac</samp> function to initialize the HMAC object with <samp class="SANS_TheSansMonoCd_W5Regular_11">sha256</samp> as the hashing algorithm, Then we feed the Base64-encoded header and payload string, separated by a period, to the HMAC object. Finally, we convert the result to a hexadecimal format.</p>&#13;
<p class="TX">To obtain the JWT string, we create an array containing the Base64-encoded strings from the header and payload objects, as well as the Base64-encoded signature. To convert the array into a string that uses a period to separate every part, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Array.join</samp> with a period as a separator and return the resulting JWT.</p>&#13;
<p class="TX">To generate the JWT, we run the script. The final JWT token logged to the console should look similar to the one in <a href="chapter9.xhtml#Lis9-11">Listing 9-11</a>.</p>&#13;
<span id="Lis9-11"/>&#13;
<pre class="pre-184"><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjIzNDEzMzQyMywid2VhdGhlcl9wdWJsa&#13;
WNfemlwIjoiOTY4MTUiLCJ3ZWF0aGVyX3ByaXZhdGVfdHlwZSI6IkdpdEh1YiJ9.f667c81749886e&#13;
e01831376a38fbdba4d7f59a14c14f3a60e1bbee977c993ac9&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 9-11: The final JWT token for the OAuth2 weather service</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_168" aria-label=" Page 168. "/>In the next section, we’ll use our new knowledge to walk through an actual OAuth flow.</p>&#13;
<p class="HeadProject"><span id="Exe9"/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 9: Access a Protected Resource</samp></p>&#13;
<p class="TNI">Now that you understand OAuth’s components and the theory behind the authorization code flow, let’s work with a practical example. We’ll try to access the protected resource hosted by an OAuth server at <i><a href="https://www.usemodernfullstack.dev/protected/resource">https://www.usemodernfullstack.dev/protected/resource</a></i>. Run the exercise’s cURL commands from your terminal to follow along.</p>&#13;
<p class="TX">First, attempt to access the protected resource without an access token by sending a GET request for it:</p>&#13;
&#13;
<pre class="pre-185"><code>$ <b>curl -i \</b>&#13;
<b>    -X GET 'https://www.usemodernfullstack.dev/protected/resource' \</b>&#13;
<b>    -H 'Accept: text/html'</b>&#13;
<var>--snip--</var>&#13;
HTTP/2 401&#13;
Content-Type: text/html; charset=utf-8&#13;
<var>--snip--</var>&#13;
&lt;h1&gt;Unauthorized request: no authentication given&lt;/h1&gt;&#13;
</code></pre>&#13;
<p class="TX">We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp> flag to output the headers, and when we search the response for the HTTP code, we see a <i>401</i> status code, which tells us that we’re not authorized to access the resource and must obtain an access token.</p>&#13;
<p class="TX">To get an access token, we’ll set up an OAuth client by creating a user account and registering it with the provider to receive a client ID and client secret. Then we’ll make a request to the <i>/oauth/authorize</i> endpoint, log in with the user’s credentials, and receive the authorization grant on our callback URL. Next, we’ll exchange the grant code for an access token on the <i>/oauth/access_token</i> endpoint. Finally, we’ll make the same request again, providing the access token in the header.</p>&#13;
<p class="TX">The callback URL can be any URL here, as we’re not sending any actual data to it. But for a real authorization grant flow, it needs to be an endpoint on your application. Usually, an OAuth SDK provides these, as it handles the response and tokens.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h4 class="H2" id="sec14"><span id="h2-134"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Setting Up the Client</samp></h4>&#13;
<p class="TNI">Before we start the OAuth flow, we need to create a user and register an OAuth client. Open <a href="https://www.usemodernfullstack.dev/register"><i>https://<wbr/>www<wbr/>.usemodernfullstack<wbr/>.dev<wbr/>/register</i></a> in your browser. On the form shown in <a href="chapter9.xhtml#fig9-2">Figure 9-2</a>, create a user account with a username and password of your choice.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_169" aria-label=" Page 169. "/>&#13;
&#13;
<figure class="IMG"><img class="img1" id="fig9-2" src="../images/Figure9-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 9-2: Creating a user account with the OAuth provider</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Then proceed to register a client by providing a callback URL (<a href="chapter9.xhtml#fig9-3">Figure 9-3</a>). This callback URL points to the OAuth callback endpoint on our application. Usually, the SDK or the OAuth provider supplies you with instructions on how to set this up.</p>&#13;
&#13;
<figure class="IMG"><img class="img1" id="fig9-3" src="../images/Figure9-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 9-3: Registering a client application with the OAuth server to receive the client credentials</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_170" aria-label=" Page 170. "/>The form is prefilled with a callback URL similar to a typical OAuth callback structure. Usually, you find them in the SDK’s documentation. Don’t worry that the URL <i>http://localhost:3000/oauth/callback</i> doesn’t exist on your application. For this exercise, we won’t send any actual data to it; instead, we’ll see that it’s part of the request and response flow when we go through the API calls. Click the button to move on to the next step, where you create the OAuth client. Make sure to write down your username, password, client ID, and client secret. You’ll need all of these for the next steps. Then click <b>Register Your OAuth Client</b> to complete the process.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H2" id="sec15"><span id="h2-135"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Logging In to Receive the Authorization Grant</samp></h4>&#13;
<p class="TNI">Now the user we registered must use their credentials to log in to the OAuth provider, allowing the client application to access their resources. We call the OAuth REST API endpoint <i>/oauth/authorize</i> and (as the resource owner) log in with our user credentials, which is the first step of the flow. The API response returns a redirect to the callback URL, which contains the authorization grant in the URL parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">code</samp>.</p>&#13;
<p class="TX">In a real application, the resource owner would click some “Log in with OAuth” button and enter their credentials, and the API calls would happen behind the scenes. But for the purposes of this exercise, we’ll perform all API requests manually. By using the raw API calls, we’ll see the actions that SDKs usually abstract. Call the REST endpoint directly with the following cURL command:</p>&#13;
&#13;
<pre class="pre-186"><code>$ <b>curl -i \</b>&#13;
<b>    -X POST 'https://www.usemodernfullstack.dev/oauth/authenticate' \</b>&#13;
<b>    -H 'Accept: text/html' \</b>&#13;
<b>    -H 'Content-Type: application/x-www-form-urlencoded' \</b>&#13;
<b>    -d "response_type</b><b>=code\</b>&#13;
<b>&amp;client_id=&lt;OAUTH_CLIENT_ID&gt;\</b>&#13;
<b>&amp;state=4nBjkh31\</b>&#13;
<b>&amp;scope=read\</b>&#13;
<b>&amp;redirect_uri=http://localhost:3000/oauth/callback\</b>&#13;
<b>&amp;username=&lt;OAUTH_USER&gt;\</b>&#13;
<b>&amp;password=&lt;OAUTH_PASSWORD&gt;"</b>&#13;
<var>--snip--</var>&#13;
HTTP/2 302&#13;
Content-Type: text/html; charset=utf-8&#13;
location: http://localhost:3000/oauth/callback?code=<b>&lt;AUTHORIZATION_GRANT&gt;</b>&amp;state=4nBjkh31&#13;
</code></pre>&#13;
<p class="TX">This POST request logs in to the OAuth provider. We set the URL to the <i>oauth/authenticate</i> endpoint, as well as our <samp class="SANS_TheSansMonoCd_W5Regular_11">Accept</samp> header and the appropriate <samp class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</samp> header, <samp class="SANS_TheSansMonoCd_W5Regular_11">application/x-www-form-urlencoded</samp>, for form data.</p>&#13;
<p class="TX">We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-d</samp> flag to send the POST data indicating that we’re looking for an authorization code. To split the POST data into readable chunks, we need to use double quotes (<samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp>) to wrap it and the backslash (<samp class="SANS_TheSansMonoCd_W5Regular_11">\</samp>) for line breaks. We add the client ID we received from the OAuth provider and the callback URL we discussed earlier. The <samp class="SANS_TheSansMonoCd_W5Regular_11">scope</samp> parameter specifies the permissions we’re asking for, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">state</samp> parameter <span role="doc-pagebreak" epub:type="pagebreak" id="pg_171" aria-label=" Page 171. "/>contains a unique random string that mitigates cross-site request forgery (CSRF) attacks. The OAuth provider should return this <samp class="SANS_TheSansMonoCd_W5Regular_11">state</samp> parameter along with the authorization code so that we can verify that its value hasn’t changed, proving that the response originated from the correct API and not from a third party. In addition, we send the user credentials we registered before.</p>&#13;
<p class="TX">The response headers show us that everything worked as expected. The OAuth API responds with a status code of <i>302</i> and redirects to the callback URL we provided. As you can see in the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp> header, the redirect to the callback URL contains the authorization grant in the <samp class="SANS_TheSansMonoCd_W5Regular_11">code</samp> parameter, as well as the <samp class="SANS_TheSansMonoCd_W5Regular_11">state</samp> parameter we sent. Unlike the state, which is just being reflected, the authorization grant is unique and depends on the request data.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h4 class="H2" id="sec16"><span id="h2-136"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using the Authorization Grant to Get the Access Token</samp></h4>&#13;
<p class="TNI">Next, we use the authorization grant to request an access token from the OAuth server. Copy the code you received in the preceding step and use it to request the bearer access token with the client credentials from the <i>/oauth/access_token</i> API endpoint:</p>&#13;
&#13;
<pre class="pre-187"><code>$ <b>curl -i \</b>&#13;
<b>    -X POST 'https://www.usemodernfullstack.dev/oauth/access_token' \</b>&#13;
<b>    -H 'Accept: text/html, application/json' \</b>&#13;
<b>    -H 'Content-Type: application/x-www-form-urlencoded' \</b>&#13;
<b>    -d "code=&lt;AUTHORIZATION_GRANT&gt;\</b>&#13;
<b>&amp;grant_type=authorization_code\</b>&#13;
<b>&amp;redirect_uri=http://localhost:3000/oauth/callback\</b>&#13;
<b>&amp;client_id=&lt;</b><b>OAUTH_CLIENT_ID&gt;\</b>&#13;
<b>&amp;client_secret=&lt;OAUTH_CLIENT_SECRET&gt;"</b>&#13;
<var>--snip--</var>&#13;
HTTP/2 200 OK&#13;
Content-Type: application/json; charset=utf-8&#13;
&#13;
{&#13;
    <b>"access_token":"9bd55e2acf046128a54b76eada1ea6e0f909ca53"</b>,&#13;
    "token_type":"Bearer",&#13;
    "expires_in":3599,&#13;
    "refresh_token":"79a22d2b37c635a6095f5548ca08ea632deae573",&#13;
    "scope":"read"&#13;
}&#13;
</code></pre>&#13;
<p class="TX">This POST request to the OAuth server uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Accept</samp> header to accept a JSON response and sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">Content-Type</samp> header to a value for POST form data. We send the form data itself with the <samp class="SANS_TheSansMonoCd_W5Regular_11">data-raw</samp> flag. The data contains the authorization grant we received in the <samp class="SANS_TheSansMonoCd_W5Regular_11">code</samp> parameter, a <samp class="SANS_TheSansMonoCd_W5Regular_11">grant_type</samp> parameter that tells the API endpoint to expect an authorization grant flow, and the same redirect URL as before. We also pass in the client ID and secret.</p>&#13;
<p class="TX">The response has an HTTP status code of <i>200</i>, which means the request succeeded. In the response body, we received the access token and additional details. Copy the access token’s value for the next step.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h4 class="H2" id="sec17"><span id="h2-137"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_172" aria-label=" Page 172. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using the Access Token to Get the Protected Resource</samp></h4>&#13;
<p class="TNI">We now have an access token from the OAuth server that we can use to retrieve the protected resource we couldn’t access at the beginning of this exercise. Use the same cURL command to request <i><a href="https://www.usemodernfullstack.dev/protected/resource">https://www.usemodernfullstack.dev/protected/resource</a></i>, and replace the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ACCESS_TOKEN</samp> placeholder with the access token:</p>&#13;
&#13;
<pre class="pre-188"><code>$<b> curl -i \</b>&#13;
<b>    -X GET 'https://www.usemodernfullstack.dev/protected/resource' \</b>&#13;
<b>    -H 'Accept: text/html' \</b>&#13;
<b>    -H 'Authorization: Bearer </b><b><var>&lt;ACCESS_TOKEN&gt;</var></b><b>'</b>&#13;
<var>--snip--</var>&#13;
<b>HTTP/2 200 OK</b>&#13;
Content-Type: text/html; charset=utf-8&#13;
<var>--snip--</var>&#13;
&lt;h1&gt;This page is secured.&lt;/h1&gt;&#13;
<var>--snip--</var>&#13;
</code></pre>&#13;
<p class="TX">We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Authorization</samp> header with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Bearer</samp> keyword and the access token we received from the authorization grant flow in the <samp class="SANS_TheSansMonoCd_W5Regular_11">access_token</samp> property. When we search for the HTTP status code, we see that instead of a code of <i>401</i>, we receive a code of <i>200</i>. On closer inspection, we also see that the response’s body contains the secured content.</p>&#13;
<p class="TX">We manually walked through all the necessary steps for receiving a working access token. This exercise is appropriate for educational purposes only; as mentioned earlier in this chapter, we usually use an SDK or a library such as <i>next-auth</i> to implement an OAuth flow.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h3 class="H1" id="sec18"><span id="h1-61"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">Authentication involves using credentials to authorize access, whereas authorization defines and grants access rights. This chapter covered implementing authorization with the OAuth2 protocol. You became familiar with the authorization grant flow, the most common OAuth flow used in full-stack web applications, and learned how to create JWTs. Then you practiced manually working with OAuth, getting and using the JWT bearer token, and applying the OAuth flow to your application from a bird’s-eye view.</p>&#13;
<p class="TX">You can find additional resources, tutorials, and specifications at <a href="https://oauth.net"><i>https://<wbr/>oauth<wbr/>.net</i></a>. The next chapter covers Docker, a containerization platform that decouples your development environment from your local machine.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>