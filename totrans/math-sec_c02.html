<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 2: Programming and Math Conventions</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:1ff3c234-c763-4a12-a0c7-4ddf7c732e40" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_13" title="13"/>2</span><br/>
<span class="ChapterTitle">Programming and Math Conventions</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">Now that you have an environment to work in, let’s discuss the programming language we’ll be using. This book assumes you have a basic familiarity with programming concepts such as loops, variables, conditionals, and functions, so this chapter isn’t meant to be a comprehensive introduction to Python. Rather, it’s intended to illustrate some finer points that will help you understand the examples in this book and in other tutorials. Of course, the programming in the book centers on implementing math concepts from research papers, so it’s equally important that we have a common understanding of the notation used in that type of material.</p>
<h2 id="h1-502567c02-0001">Syntactical Constructs</h2>
<p class="BodyFirst">Although this book isn’t meant to serve as an introduction to Python programming, there are some useful syntactical constructs you should be familiar with before diving in. It’s important to balance the use of these <span epub:type="pagebreak" id="Page_14" title="14"/>more advanced features to maintain the readability and understandability of your code. I’ve used the constructs described in this section throughout the book’s projects for code brevity. If you’re still learning Python, some of the syntax may seem daunting at first, but once you apply these constructs a few times in your own code you’ll wonder how you ever got anything done without them!</p>
<h3 id="h2-502567c02-0001">List Comprehensions</h3>
<p class="BodyFirst">Comprehension constructs come in handy whenever you need to create a list (or dictionary) of values by iterating over some code. The simplest use case is to apply a function to every element in a list. For example, suppose you have a list of strings, called <code>names</code>, that you want to convert to uppercase. You could use a loop similar to the following:</p>
<pre><code>names = ["bob","mike","tom","mary"]
names_2 = []
for n in names:
    names_2.append(n.upper())</code></pre>
<p>But there are a couple of downsides to this method. First, it requires two lists: one for inputs (<code>names</code>) and one for outputs (<code>names_2</code>). When you have very large lists of complex objects, copying the whole list in memory for a simple change like this is inefficient. You could add more code to overwrite names with the contents of <code>names_2</code> and then free up the memory used by <code>name_2</code> explicitly, but that’s a pain and makes the code messy. This leads us to the second problem: the code takes up more lines than necessary. In complex applications you may have hundreds of functions to maintain. Keeping your code concise saves you time when writing and modifying your code in large code bases. You could condense the whole process into a single line like so:</p>
<pre><code>names = [n.upper() for n in names]</code></pre>
<p>In a list comprehension, the first variable defines what will be stored in the resulting list. In this case <code>n</code> is a string we’re converting to uppercase, hence <code>n.upper</code>. We define the values for <code>n</code> using the <code>for</code> statement to its right, which iterates through the <code>names</code> list and selects each <code>n</code>. The resulting list is then assigned directly to the <code>names</code> variable, overwriting its previous value and freeing up the memory used by the loop automatically. We can add some conditional logic to the end of the statement to filter the results. For example, suppose we want to also filter the <code>names</code> list on whether the first letter of each string is <code>m</code>. Once again, you could write this as a loop with a block of code like the following:</p>
<pre><code>m_names_upper = []
names = ["bob","mike","tom","mary"]
for n in names:
    if n.startswith("m"):
        m_names_upper.append(n.upper())</code></pre>
<p><span epub:type="pagebreak" id="Page_15" title="15"/>Now within each iteration of the <code>for</code> loop we have a conditional statement to check if the string starts with <code>m</code> and, if so, it appends the uppercase version to the <code>m_names_upper</code> list. This method suffers from the same drawbacks as the previous loop example, though, and takes up even more space! This code can also be shortened to a single line with a list comprehension:</p>
<pre><code>m_names_upper = [n.upper() for n in names if n.startswith("m")]</code></pre>
<p>We’ve added some conditional logic to the end of the list comprehension statement to filter the results; again, we’ll add <code>n.upper</code> only if <code>n</code> starts with an <code>m</code>.</p>
<p>The two examples will produce the same output; it’s open for debate which is simpler or easier to explain, so the approach you choose will often be a matter of preference. Note that you can add an <code>else</code> condition to the list comprehension to control what happens in the event the <code>if</code> returns <code>False</code>. In cases where the conditional logic is <code>False</code>—for example, when a function expects two lists to be the same length so it can do some pairwise manipulation on the values—you might want to add a static value to your output list rather than excluding the element altogether. Let’s say we want to rename everyone whose name doesn’t start with <code>m</code> to <code>marcus</code>. With a traditional loop structure, this requires adding an <code>else</code> block after the <code>if</code> block to handle inserting the value. I’ll skip that, as we’ve all seen <code>else</code> blocks in Python (hopefully), and we’re discussing list comprehensions. Adding the additional <code>else</code> clause to a list comprehension changes the syntax so the <code>if...else</code> logic comes before the <code>for</code> loop logic, which looks like this:</p>
<pre><code>m_names = [n if n.startswith("m") else "marcus" for n in names]</code></pre>
<p>As you can see, the <code>if</code> statement moves directly after the variable to be stored, <code>n</code>. You then add the <code>else</code> condition, which defines the value to be added to the output list <code>m_names</code> in cases where the <code>if</code> statement is <code>False</code>. In this example, if a name starts with an <code>m</code>, it will be added to the output list; otherwise, the string literal <code>marcus</code> will be added instead. </p>
<p>There are plenty of more practical uses for list comprehensions, and you’ll see them sprinkled through the code in this book and other examples, so it’s best to become familiar with them and how they translate into more traditional looping code structures. It’s also important to understand the limitations of list comprehensions. If your conditional selection logic is fairly complex, you might want to consider abstracting it to its own function. You can then use the function in a list comprehension to apply it to each element (a method you’ll see used in this book as well). The only real limitations within the list comprehension itself are that you can apply only one conditional statement, and the output at the end of each iteration must be something that can be included in a Python list object.</p>
<h3 id="h2-502567c02-0002">Dictionary Comprehensions</h3>
<p class="BodyFirst">Dictionaries are one of the most prevalent data structures in Python. They are used for everything from simple key/value pairing up to handling <span epub:type="pagebreak" id="Page_16" title="16"/>complex, user-defined classes. Luckily they are also extremely easy to work with, and a lot of the concepts we just discussed for list comprehensions apply equally well to defining dictionary objects, though you’ll tend to run across fewer examples in the wild. As an illustration, consider the following code, which merges a list of keys with an accompanying list of values:</p>
<pre><code>keys = ['Red','Blue','Green','Yellow']
values = [1,2,3,4]
out = {}
for i in range(len(keys)):
    out[keys[i]] = values[i]</code></pre>
<p>Once again, the power of dictionary comprehension allows us to shorten this code block to a single line:</p>
<pre><code>out = {keys[i]: values[i] for i in range(len(keys))}</code></pre>
<p>You may notice there are only a few differences between the list comprehension and the dictionary comprehensions syntax. Python’s developers have done this to make them both easier to understand in relation to each other. If you understand list comprehensions, then you understand 90 percent of dictionary comprehensions. The two things to remember are: dictionaries are defined using braces <code>{}</code> instead of square brackets, and the left part before the <code>for</code> keyword expresses both a key and a value, separated by a colon. Here, we define our key as the <em>i</em>th value in the list called <code>keys</code>. We’re assigning the value for that key from the second list, <code>values</code>, using the same index, <em>i</em>. We then define a <code>for</code> statement that loops over the integer values between 0 and the length of the <code>keys</code> list using the <code>range</code> function. This is an example of a function that naively assumes both the <code>keys</code> and <code>values</code> lists are the same length. If <code>keys</code> is ever longer than <code>values</code>, this code will raise an error when it attempts to access a nonexistent index on <code>values</code>. </p>
<p>You can also use a function to define both the key variable and the value variable, like so:</p>
<pre><code>out = {keys[i].upper(): float(values[i]) for i in range(len(keys))}</code></pre>
<p>In this example we’ve changed the previous code so all the keys are converted to uppercase and all the values are cast to <code>float</code>. We could, of course, replace these functions with anything that suits our needs. As long as the result for each function can be used as a key or value in a regular Python dictionary, the function can be used. The same caveat applies to this conditional logic as with list comprehensions. If you need more complex logic, you should consider abstracting the key and value definition into its own function, like so:</p>
<pre><code>out = {k: v for k,v in my_logic(keys)}</code></pre>
<p><span epub:type="pagebreak" id="Page_17" title="17"/>Here the keys and values are being defined by the return value from the function call <code>my_logic(keys)</code>. It doesn’t matter what this function does; all that matters is that the function returns a list that contains tuples (or nested lists) that each contain two items. The first item in each tuple will be treated as the key <code>k</code>, and the second item as the corresponding value. And there’s the dirty little secret of dictionary comprehensions: they’re really just list comprehensions in disguise! You may have already realized this because the <code>range</code> function produces a list as well. This is a handy shortcut when you want to run a function on every item in a list and store the result as a dictionary that relates the item with the result of calling the function on that item.</p>
<h3 id="h2-502567c02-0003">Zipping and Unpacking</h3>
<p class="BodyFirst">Python’s built-in <code>zip</code> function returns an iterator of tuples, where the <em>i</em>th tuple contains the <em>i</em>th element from each argument passed in. Suppose you wanted to combine the previous list of names stored in <code>names</code> with the list of colors and numbers stored in <code>keys</code> and <code>values</code>, respectively. The <code>zip</code> function will allow you to efficiently generate these combinations as a list of tuples, again with a single line of code:</p>
<pre><code>a = zip(names, keys, values)
print(list(a))</code></pre>
<p>The variable <code>a</code> now holds a <code>zip</code> object that, when cast to a list, will contain triples like <code>("bob","Red",1)</code>. It’s important to pay attention to the order in which you pass the lists, as left-to-right processing is guaranteed. Also be aware that the iterator stops when the shortest-length input is exhausted. Unpacking is the reverse of the <code>zip</code> function, but it’s a behavior of Python rather than a function that you need to call. For example, you can unpack the three values that make up the first item in the <code>zip</code> object <code>a</code> like so:</p>
<pre><code>person, key, value = list(a)[0]</code></pre>
<p>This line of code takes the three values in the first tuple in <code>a</code> and assigns them to the three variables (left-to-right order) on the left side of the equal sign. You must have the same number of variables as items in the tuple, or the code will raise an exception. Zipping and unpacking are useful when you want to transport data around your application. Rather than defining multiple variables to hold the three output lists, we can apply the <code>zip</code> function to return a single <code>zip</code> object, which preserves the relationship between all three lists. You can then iterate over the results and unpack the values into distinct variables as needed.</p>
<p>The rest of the code you see will be pretty standard Python. I’ll point out the syntax for specific libraries as we come to use them in our projects. </p>
<p>Next, we’ll dive into the exciting world of math notation. As you’ll see, understanding the symbols used plays a crucial role in advanced mathematics. <span epub:type="pagebreak" id="Page_18" title="18"/>It provides a flexible form of shorthand that makes the formulas easier to remember. Unfortunately, as with programming, these symbols can take on multiple meanings. Mathematical notations often have a dual nature since they can signify both the math being performed and variables on which it’s being performed.</p>
<h2 id="h1-502567c02-0002">Mathematical Notation</h2>
<p class="BodyFirst">Mathematical notation is a tricky beast, especially when you intend to cover more than one field in a text. The reason is that a lot of mathematical symbols are <em>overloaded</em>, meaning they have many possible meanings, and to know which meaning applies, you need to look at the context. A perfect example of this is the Greek letter theta, θ. In machine learning literature, θ usually refers to the set of feature weights calculated for a set of data. This “hypothesis” function is commonly seen in the first weeks of machine learning, when linear regression models are covered.</p>
<figure class="graphic equation">
<img alt="" class="" src="image_fi/502567c02/m02001.png"/></figure>

<p>However, in geometry and trigonometry, θ is often used as a “degrees” variable—for example, in the Pythagorean theorem, as shown in <a href="#figure2-1" id="figureanchor2-1">Figure 2-1</a>.</p>
<figure>
<img alt="" class="" src="image_fi/502567c02/f02001.png"/>
<figcaption><p><a id="figure2-1">Figure 2-1</a>: The Pythagorean theorem using theta to represent an angle in degrees</p></figcaption>
</figure>
<p>Where possible, I stick to the notation used in the prevailing material on the subject. In cases where the notation becomes overloaded, I’ve included explanations of the intended meanings. </p>
<h3 id="h2-502567c02-0004">Boolean Notation </h3>
<p class="BodyFirst">One of the most often applied (and most often overlooked) concepts you’ll see in applied mathematics is Boolean algebra. A <em>Boolean</em> is a primitive data type that can hold only one of two possible values at any given moment. The value is determined by the <em>logical statement</em> that accompanies it. For example, we can ask if two numbers, <em>x</em> and <em>y</em>, are equal to each other. The answer to this question will always be yes or no, depending on the inputs. There will never be a case that produces a third answer. </p>
<p><span epub:type="pagebreak" id="Page_19" title="19"/>Boolean symbols are most often denoted in the form of a <em>truth table</em>. In the interest of saving space, I haven’t included any full truth tables in this book; you can find many excellent references for these tables online. We’ll focus instead on the symbols used to write the logical statements and how you can interpret them. <a href="#table2-1" id="tableanchor2-1">Table 2-1</a> covers each of the major Boolean algebra symbols and the intuitive meaning, with an example of the logic applied to a statement.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-1">Table 2-1</a>: Boolean Logic Examples</p></figcaption>
<table border="1" id="table-502567c02-0001">
<thead>
<tr>
<td><b>Notation</b></td>
<td><b>Meaning</b></td>
<td><b>Example</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>AND: <span class="math" title="A and B"><span class="mi">A</span><span class="mo"> ∧</span><span class="mi"> B</span></span></td>
<td>Both <em>A</em> and <em>B</em> must be <code>True</code> for the statement to be <code>True</code>. Algebraically, <em>A</em> × <em>B</em> or just <em>AB</em>.</td>
<td><em>Cats are mammals</em> AND <em>planes fly</em> is <code>True</code> since both statements are <code>True</code>. If either statement is <code>False</code>, the whole statement is <code>False</code> (equal to <code>0</code>).</td>
</tr>
<tr>
<td>OR: <span class="math" title="A or B "><span class="mi">A</span><span class="mo"> ∨</span><span class="mi"> B</span></span></td>
<td>If either <em>A</em> or <em>B</em> or both <em>A</em> and <em>B</em> are <code>True</code>, this statement is <code>True</code>. Algebraically, <em>A</em> + <em>B</em>.</td>
<td><em>Cats are dogs</em> OR <em>birds are cats</em> is <code>False</code> because neither <em>A</em> nor <em>B</em> is <code>True</code>. Changing either or both to <code>True</code> statements would change the result.</td>
</tr>
<tr>
<td>NOT: <span class="math" title="neg A,À "><span class="mo"> ¬</span><span class="mi"> A</span><span class="mi">, À</span></span></td>
<td>This statement is <code>True</code> when the statement <em>A</em> is <code>False</code>. It is an inverter that outputs the opposite of its input.</td>
<td>If <em>A</em> represents the statement <em>cats are fish</em>, this could be written as <em>NOT cats are fish</em>. <em>NOT cats are fish</em> is <code>True</code> because the statement <em>ca</em><em>ts are fish</em> is <code>False</code>.</td>
</tr>
<tr>
<td>XOR: <span class="math" title="A otimes B"><span class="mi">A</span><span class="mo"> ⊕</span><span class="mi"> B</span></span></td>
<td>If either <em>A</em> or <em>B</em> but NOT both <em>A</em> and <em>B</em> are <code>True</code>, this statement is <code>True</code>. Algebraically, <span class="math" title=" (A grave B) + (grave A B)"><span class="mo">( </span><span class="mi">AB̀</span><span class="mo">  )</span><span class="mo"> +</span><span class="mo"> (</span><span class="mi"> À</span><span class="mo"/><span class="mi">B</span> <span class="mo">)</span></span>.</td>
<td><em>The shirt is red</em> XOR <em>the shirt is blue</em> is <code>True</code> if the shirt is either red or blue, but not both red and blue.</td>
</tr>
</tbody>
</table>
</figure>
<p>These deceptively simple components can be used to describe the most arbitrarily complex systems known to humankind through the use of chained Boolean statements. It’s very important to be aware of the order of operations and placement of parentheses in Boolean expressions. Operator precedence is the same as in traditional algebra, with fewer functions. Any operations inside parentheses are handled first, followed by any AND conditions (multiplication), and finally, OR statements (addition). Negations are handled during the final step of the operation being negated, so they don’t need any special handling. Traditionally we evaluate multiple parentheses from left to right. </p>
<p>Most runtime environments, like Python’s interpreter, stop evaluating as soon as the truth of a statement can be determined. They won’t continue to check additional statements that can no longer change the result. For example, the logical statement</p>
<p class="MathEquation"><span class="math" title="(Cats fly and dogs bark)"><span class="mo">(</span><span class="mi"> Cats </span><span class="mi">fly</span><span class="mo"> ∧</span><span class="mi"> dogs</span><span class="mi"> bark</span><span class="mo"> )</span></span></p>
<p class="BodyContinued">will first check the <em>Cats fly</em> statement. Since this is <code>False</code>, the value of the second statement can’t impact the result of the AND statement. Python <span epub:type="pagebreak" id="Page_20" title="20"/>determines that the total statement is <code>False</code> without ever checking the <em>dogs bark</em> condition. To understand how Python parses more complex logical statements, let’s look at another example. The statement</p>
<p class="MathEquation"><span class="math" title="(Cats meow and dogs bark)  otimes (Fish swim and neg birds fly )"><span class="mo">(</span><span class="mi"> Cats </span><span class="mi">meow</span><span class="mo"> ∧</span><span class="mi"> dogs</span><span class="mi"> bark</span><span class="mo"> )</span><span class="mo"> ⊕</span><span class="mo"> (</span><span class="mi"> Fish</span><span class="mi"> swim</span><span class="mo"> ∧</span><span class="mo"> ¬</span><span class="mi">birds </span><span class="mi">fly</span><span class="mo"> )</span></span></p>
<p class="BodyContinued">is evaluated in the interpreter as follows. First the parentheses group</p>
<p class="MathEquation"><span class="math" title="(Cats meow and dogs bark)"><span class="mo">(</span><span class="mi"> Cats</span><span class="mi"> meow</span><span class="mo"> ∧</span><span class="mi"> dogs </span><span class="mi">bark</span><span class="mo"> )</span></span></p>
<p class="BodyContinued">is evaluated. It is <code>True</code>, because both statements it contains are <code>True</code> (cats do meow and dogs do bark). Since the second set of parentheses can still affect the outcome (a XOR operation always requires us to evaluate both sides),</p>
<p class="MathEquation"><span class="math" title="(Fish swim and neg birds fly )"><span class="mo">(</span><span class="mi"> Fish</span><span class="mi"> swim</span><span class="mo"> ∧</span><span class="mo"> ¬</span><span class="mi">birds </span><span class="mi">fly</span><span class="mo"> )</span></span></p>
<p class="BodyContinued">is evaluated next. The negation on <em>birds fly</em> makes this second statement <code>False</code> (<em>birds fly</em> is <code>True</code>, so <em>NOT birds fly</em> is <code>False</code>). Now we evaluate the XOR operation</p>
<p class="MathEquation"><span class="math" title=" (A grave B) + (grave A B)"><span class="mo">(</span><span class="mi"> AB̀</span><span class="mi"/><span class="mo"/><span class="mo">)</span><span class="mo"> +</span><span class="mo"> (</span><span class="mi"> À<span class="mo"/></span><span class="mi">B</span><span class="mo"> )</span></span></p>
<p class="BodyContinued">where <em>A</em> is the result of the first parentheses group, and <em>B</em> is the result of the second parentheses group. We can solve this easily by recursively applying the operator precedence.</p>
<p class="MathEquation"><span class="math" title=" (1 * grave 0) + (grave 1 * 0) = (1 * 1) + (0 * 0) = ( 1 + 0) = 1"><span class="mo">(</span><span class="mn"> 1</span><span class="mo"> × </span><span class="mn"> 0̀<span class="mo"/></span><span class="mo">)</span><span class="mo"> + </span><span class="mo">(</span><span class="mn"> 1̀<span class="mo"/></span><span class="mo"> × </span><span class="mn"> 0</span><span class="mo"> )</span><span class="mo"> = </span><span class="mo">(</span><span class="mn"> 1</span><span class="mo"> ×</span><span class="mn"> 1</span><span class="mo"> )</span><span class="mo"> + </span><span class="mo">(</span><span class="mn"> 0</span><span class="mo"> ×</span><span class="mn"> 0</span><span class="mo"> )</span><span class="mo"> = </span><span class="mo">(</span><span class="mn"> 1</span><span class="mo"> + </span><span class="mn">0</span><span class="mo"> )</span><span class="mo"> = </span><span class="mn">1</span></span></p>
<p>We interpret a <code>1</code> to mean the overall statement</p>
<p class="MathEquation"><span class="math" title="(Cats meow and dogs bark)  otimes (Fish swim and neg birds fly )"><span class="mo">(</span><span class="mi"> Cats</span><span class="mi"> meow</span><span class="mo"> ∧</span><span class="mi"> dogs</span><span class="mi"> bark</span><span class="mo"> )</span><span class="mo"> ⊕</span><span class="mo"> (</span><span class="mi"> Fish </span><span class="mi">swim</span><span class="mo"> ∧</span><span class="mo"> ¬</span><span class="mi">birds</span><span class="mi"> fly</span><span class="mo"> )</span></span></p>
<p class="BodyContinued">is <code>True</code>, which matches what we’d expect because XOR requires exactly one of the conditions to be <code>True</code> for the outcome to be <code>True</code>.</p>
<h3 id="h2-502567c02-0005">Set Notation</h3>
<p class="BodyFirst">In mathematics, we often want to denote groups of objects rather than individual objects. For example, we might say that all the students who go to a particular school make up a <em>set</em>. Each student can occur in the set only once. </p>
<p>We could denote the set of students <em>S</em>. (I’ll follow the convention of using a capitalized English variable name for sets, with a few exceptions.) This defines what items are, or are not, considered to be part of the set. This is often called a <em>membership rule</em>. Now that we have a definition of membership, we can denote what items <em>i</em> are in the set (<em>i</em> ∈ <em>S</em>) or, of course, not in the set (<em>i</em> ∉ <em>S</em>). In this example, <em>i</em> ∉ <em>S </em>is syntactically equivalent to saying, “All things that are not students at the defined school.” When dealing with multiple sets, we may be interested in which set contains an item (<em>S</em> ∋ <em>i</em>). Assuming we created a set for each school in a district, this would be equivalent to asking, “What school does a given student attend?” <a href="#table2-2" id="tableanchor2-2">Table 2-2</a> describes the symbols used throughout this text.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-2">Table 2-2</a>: Set Notation Examples<span epub:type="pagebreak" id="Page_21" title="21"/></p></figcaption>
<table border="1" id="table-502567c02-0002">
<thead>
<tr>
<td><b>Notation</b></td>
<td><b>Meaning</b></td>
<td><b>Example</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math" title="i in S"><span class="mi">i</span><span class="mo">  ∈</span><span class="mi"> S</span></span></td>
<td>Boolean: Item <em>i</em> in set <em>S</em>.</td>
<td>3 in the set of odd integers is <code>True</code>.<br/>
4 in the set of odd integers is <code>False</code>.</td>
</tr>
<tr>
<td><span class="math" title="i notin S"><span class="mi">i</span><span class="mo">  ∉</span><span class="mi"> S</span></span></td>
<td>Boolean: Item <em>i</em> not in set <em>S</em>.</td>
<td>3 not in the set of odd integers is <code>False</code>.<br/>
4 not in the set of odd numbers is <code>True</code>.</td>
</tr>
<tr>
<td><span class="math" title="S owns i"><span class="mi">S</span><span class="mo">  ∋</span><span class="mi"> i</span></span></td>
<td>Boolean: Set <em>S</em> contains item <em>i</em>.</td>
<td>Set of odd integers contains 7 is <code>True</code>.<br/>
Set of cars contains a bicycle is <code>False</code>.</td>
</tr>
<tr>
<td><span class="math" title="A intersection B"><span class="mi">A</span><span class="mo"> ∩</span><span class="mi"> B</span></span></td>
<td>Product: <span class="math" title="i in A  and i in B"><span class="mi">i</span><span class="mo"> ∈</span><span class="mi"> A</span><span class="mo"> ∧</span><span class="mi"> i</span><span class="mo"> ∈</span><span class="mi"> B</span></span>. All items in set <em>A</em> that are also in set <em>B</em>.</td>
<td>Will produce a set of all items that meet both <em>A</em> and <em>B</em>. If <em>A</em> is the set of all animals and <em>B</em> is the set of all mammals, a cat could be included in the product because it’s in both the set of animals and the set of mammals. </td>
</tr>
<tr>
<td><span class="math" title="A setminus B"><span class="mi">A</span><span class="mo"> \</span><span class="mi"> B</span></span></td>
<td>Product: <span class="math" title="(i in A neg  i in B) + (i in B neg  i in A)"><span class="mo">(</span><span class="mi"> i</span><span class="mo"> ∈</span><span class="mi"> A</span><span class="mo"> ¬</span><span class="mi"> i</span><span class="mo"> ∈</span><span class="mi"> B</span><span class="mo"> )</span><span class="mo"> +</span><span class="mo"> (</span><span class="mi"> i</span><span class="mo"> ∈</span><span class="mi"> B</span><span class="mo"> ¬</span><span class="mi"> i</span><span class="mo"> ∈</span><span class="mi"> A</span><span class="mo"> )</span></span>. All items in set <em>A</em> that are not in set <em>B</em> plus all items in set <em>B</em> that are not in set <em>A</em>.</td>
<td>All topics from security that do not involve medical tech, plus all topics from medical tech that do not involve security.</td>
</tr>
<tr>
<td><span class="math" title="A union B"><span class="mi">A</span><span class="mo"> ∪</span><span class="mi"> B</span></span></td>
<td>Product: <span class="math" title="i in A  or i in B"><span class="mi">i</span><span class="mo"> ∈</span><span class="mi"> A</span><span class="mo"> ∨</span><span class="mi"> i</span><span class="mo"> ∈</span><span class="mi"> B</span></span>. All items in set <em>A</em> or in set <em>B</em> or in both sets.</td>
<td>All places that are gas stations or grocery stores or both a gas station and a grocery store.</td>
</tr>
<tr>
<td><span class="math" title="p subset S, p subseteq S   "><span class="mi">p</span><span class="mo"> ⊂</span><span class="mi"> S</span><span class="mi">, </span><span class="mi">p</span><span class="mo"> ⊆</span><span class="mi"> S</span></span></td>
<td>Boolean: Items in subset <em>p</em> are all in the superset <em>S</em>. If <em>p</em> can contain all the members of <em>S</em>, we use<span class="math" title="&lt;?&gt; subseteq &lt;?&gt; "><span class="mo"> ⊆</span><span class="mi"/></span>.</td>
<td>A subset of door locks is from the superset of all security devices is <code>True</code>.</td>
</tr>
<tr>
<td><span class="math" title="p nsubset S"><span class="mi">p</span><span class="mo"> ⊄</span><span class="mi"> S</span></span></td>
<td>Boolean: One or more items in subset <em>p</em> is not in the superset <em>S</em>.</td>
<td>[Pear, Grape, Rock] is not a subset of foods is <code>True</code>. </td>
</tr>
<tr>
<td><span class="math" title="forall p in S F"><span class="mo"> ∀</span><span class="mi"> p</span><span class="mo"> ∈</span><span class="mi"> S </span><span class="mi">F</span></span></td>
<td>For all items <em>p</em> in <em>S</em>, apply function <em>F</em>.</td>
<td>For all the people in the room, say “hello.”</td>
</tr>
<tr>
<td><span class="GraphicInline"><img alt="m02002" src="image_fi/502567c02/m02002.png"/></span> or <span class="math" title="{C sub k} lsub n"><span class="msub"><span class="mi">n</span></span><span class="mi">C</span><span class="msub"><span class="mi">k</span></span></span></td>
<td>The number of unordered combinations of <em>k</em> elements drawn from a set of <em>n</em> elements. Read “from <em>n</em> choose <em>k</em>.”</td>
<td>From [Ron, Tom, Ann] choose two names: <span class="GraphicInline"><img alt="m02003" src="image_fi/502567c02/m02003.png"/></span></td>
</tr>
</tbody>
</table>
</figure>
<p>Finally, there are a few reserved sets that come up so frequently that they’ve been given standardized symbols throughout most of the literature. You can find these listed in <a href="#table2-3" id="tableanchor2-3">Table 2-3</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-3">Table 2-3</a>: Reserved Sets</p></figcaption>
<table border="1" id="table-502567c02-0003">
<thead>
<tr>
<td><b>Notation</b></td>
<td><b>Membership rule</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math" title="emptyset "><span class="mi">∅</span></span></td>
<td>An empty set. Often seen as a parameter in algorithms (breadth-first search, for example).</td>
</tr>
<tr>
<td><span class="math" title="setZ "><span class="mi">ℤ</span></span></td>
<td>Set of all integers (1, 2, 3, . . .) <span class="math" title="-infinity "><span class="mo"> −</span><span class="mi"> ∞</span></span> to <span class="math" title="infinity"><span class="mi">∞</span></span>. Can also be used for a subset of integers with a defined membership parameter (such as all multiples of 3).</td>
</tr>
<tr>
<td><span class="math" title="setR "><span class="mi">ℝ</span></span></td>
<td>Set of all real numbers (0.25, 1.0, 2.3, . . .) Often just 0.0–1.0 with a scaling factor.</td>
</tr>
</tbody>
</table>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" id="Page_22" title="22"/><h2><span class="NoteHead">Note</span></h2>
<p>	This is only one way of annotating sets. Another common method is known as <em>set generator notation (SGN)</em>. Python supports SGN syntax in a few different ways, the most common of which is the <code>range</code> function, which takes a starting point, a step size, and a maximum value and returns a set (technically a list) of integers between the starting point and the end point spaced out by the step size. The default starting point is 0 and the default step size is 1, so the only required parameter is the maximum value for the range. Calling <code>range(10)</code> will return the set of integers between 0 and 9. You’ll see this syntax used often in <code>for</code> loops. We’ll make extensive use of the set notation symbols defined in <a href="#table2-3">Table 2-3</a> while dealing with graph theory in the next chapters.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-502567c02-0006">Attribute Characters</h3>
<p class="BodyFirst">Special attribute symbols are another case where mathematicians love to overload the meanings of symbols. They’re used in formulas to denote special conditions for variables, function outputs, sets, and the like. They’re also used to distinguish related variables that may share a letter (which suggests that they’re related). For example, (<em>y</em> – <em>ŷ</em>) is often used to denote the difference between the actual and predicted values of some regression function. The variable <em>ŷ</em> holds the predicted value, and a difference closer to 0 denotes a more accurate prediction. This notation allows us to intuitively understand that the variables are related to each other, while distinguishing the one of particular interest with the attribute character.</p>
<p>When an attribute character is used in this text, it will be accompanied by a description of its intended meaning in that context.</p>
<h3 id="h2-502567c02-0007">Greek Letters and Functions</h3>
<p class="BodyFirst">Finally, let’s discuss the use of the Greek alphabet to denote different variables, functions, and so on. I mentioned one of these symbols already, theta (θ), and how its interpretation is context-driven. You’re probably already familiar with some of the others as well. Some will be used fairly consistently, such as pi (π), which will always denote half the circumference of a circle. Others, such as alpha (α), will be used more liberally. To maintain clarity, we’ll discuss the meaning of these symbols in the context of each formula that includes them. <a href="#table2-4" id="tableanchor2-4">Table 2-4</a> outlines some common functions that are also denoted using symbols for shorthand. </p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-4">Table 2-4</a>: Function Notation Examples</p></figcaption>
<table border="1" id="table-502567c02-0004">
<thead>
<tr>
<td><b>Name/symbol</b></td>
<td><b>Common interpretation</b></td>
<td><b>Example</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>ABS <span class="math" title="abs{A} "><span class="mo">|</span><span class="mi">A</span><span class="mo">|</span></span></td>
<td>Absolute value of <em>A</em>. Can also be the length of a vector or array (the number of items contained within the array).</td>
<td><span class="math" title="abs{[a,b,c]} = 3 "><span class="mo">|</span><span class="mo"> [ </span><span class="mi">a,b,c</span><span class="mo"> ] </span><span class="mo">| </span><span class="mo"> =</span><span class="mn"> 3</span></span> or <span class="math" title="abs{ 3 - 5 } = 2"><span class="mo">| </span><span class="mn">3 </span><span class="mo"> −</span><span class="mn"> 5 </span><span class="mo">| </span><span class="mo"> = </span><span class="mn"> 2</span></span></td>
</tr>
<tr>
<td>SUM <span class="GraphicInline"><img alt="m02004" src="image_fi/502567c02/m02004.png"/></span></td>
<td>Sum of performing a function <em>F</em> some number of times from <em>i</em> to <em>j</em>.</td>
<td><span class="GraphicInline"><img alt="m02005" src="image_fi/502567c02/m02005.png"/></span></td>
</tr>
<tr>
<td>PROD <span class="GraphicInline"><img alt="m02006" src="image_fi/502567c02/m02006.png"/></span></td>
<td>Product of performing a function <em>F</em> some number of times from <em>i</em> to <em>j</em>.</td>
<td><span class="GraphicInline"><img alt="m02007" src="image_fi/502567c02/m02007.png"/></span></td>
</tr>
</tbody>
</table>
</figure>
<h2 id="h1-502567c02-0003"><span epub:type="pagebreak" id="Page_23" title="23"/>Summary</h2>
<p class="BodyFirst">Learning to interpret the symbols and remembering how to apply them is the most daunting part of proof-of-concept engineering. From here on, the actual math we’ll be doing is quite simple. If you’ve completed an algebra course and know how to perform addition, subtraction, multiplication, and division, the coming projects will be no problem for you to understand.</p>
<p>In the next chapters, we’ll begin discussing the important fields of mathematical theory and building projects to prove their usefulness. Each theory chapter and the accompanying projects are meant to illustrate some of the theories security researchers can benefit from applying in their tool development immediately. They aren’t meant to be a comprehensive treatise on any one theory or any particular security topic. I hope that, by the end of the projects, you begin to see the vast number of ways in which programming applied mathematical concepts can impact your work in security and your daily life. </p>
</section>
</body>
</html>