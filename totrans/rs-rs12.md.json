["```\nstruct ArrayVec<T, const N: usize> {\n    values: [Option<T>; N],\n    len: usize,\n}\nimpl<T, const N: usize> ArrayVec<T, N> {\n    fn try_push(&mut self, t: T) -> Result<(), T> {\n        if self.len == N {\n            return Err(t);\n        }\n        self.values[self.len] = Some(t);\n        self.len += 1;\n        return Ok(());\n    }\n}\n```", "```\n// raw register address -- private submodule\nmod registers;\npub struct On;\npub struct Off;\npub struct Pair<R1, R2>(PhantomData<(R1, R2)>);\nimpl Pair<Off, Off> {\n    pub fn get() -> Option<Self> {\n static mut PAIR_TAKEN: bool = false;\n        if unsafe { PAIR_TAKEN } {\n            None\n        } else {\n // Ensure initial state is correct.\n            registers::off(\"r1\");\n            registers::off(\"r2\");\n            unsafe { PAIR_TAKEN = true };\n            Some(Pair(PhantomData))\n        }\n    }\n\n    pub fn first_on(self) -> Pair<On, Off> {\n        registers::set_on(\"r1\");\n        Pair(PhantomData)\n    }\n // .. and inverse for -> Pair<Off, On>\n}\nimpl Pair<On, Off> {\n    pub fn off(self) -> Pair<Off, Off> {\n        registers::set_off(\"r1\");\n        Pair(PhantomData)\n    }\n}\n// .. and inverse for Pair<Off, On>\n```"]