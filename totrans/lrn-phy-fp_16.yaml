- en: '14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '14'
- en: NEWTON’S SECOND LAW AND DIFFERENTIAL EQUATIONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿第二定律与微分方程
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common.jpg)'
- en: Isaac Newton accomplished a lot. Among the numerous physical and mathematical
    insights he left us are three numbered laws that bear his name. Newton’s second
    law is the most important of these; it provides a method for understanding the
    motion of an object if we know the forces that act on it. Newton’s third law is
    almost as significant; it’s a rule about how two objects interact. Newton’s first
    law, from a mathematical standpoint, is a corollary to Newton’s second law, so
    it seems the smallest of the three. But since Newton’s second law is sufficiently
    intuition shattering, it’s helpful to get our minds around something simpler before
    trying to grasp it. Newton’s first law serves well in this capacity; it makes
    a bold claim that seems obviously false.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 艾萨克·牛顿成就斐然。他为我们留下了众多物理和数学的深刻见解，其中有三条以他名字命名的定律。牛顿的第二定律是这三条定律中最重要的一条；它提供了一种理解物体运动的方法，只要我们知道作用在物体上的力。牛顿的第三定律几乎同样重要；它是关于两个物体如何相互作用的规则。从数学角度来看，牛顿的第一定律是牛顿第二定律的一个推论，因此它看起来是三条定律中最简单的一条。但由于牛顿的第二定律足够颠覆直觉，因此在试图理解它之前，先理解一些更简单的内容是很有帮助的。牛顿的第一定律在这方面非常有效；它提出了一个看似明显错误的大胆主张。
- en: In this chapter, we’ll discuss Newton’s first law and then turn our attention
    to Newton’s second law in one linear dimension, such as a horizontal line or a
    vertical line. We’ll show how to think about Newton’s second law in a sequence
    of settings of increasing complexity, organized by what the forces depend on.
    We’ll start with constant forces, the simplest situation, before moving on to
    forces that depend only on time. Then we’ll turn to forces that depend on the
    velocity of the particle they act on, followed by forces that depend on both time
    and velocity. The techniques for solving Newton’s second law change as the forces
    involved depend on different physical quantities. We’ll introduce the Euler method
    for solving a differential equation and explore a number of situations in which
    Newton’s second law is the central principle that allows us some traction in understanding
    the motion of an object.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论牛顿的第一定律，然后将注意力转向牛顿的第二定律，集中于一个线性维度，例如水平线或垂直线。我们将展示如何在逐渐增加复杂性的情境中思考牛顿的第二定律，按力的依赖性进行组织。我们将从常力开始，最简单的情形，然后转向仅依赖于时间的力。接着，我们将讨论依赖于粒子速度的力，然后是同时依赖于时间和速度的力。解决牛顿第二定律的方法会随着所涉及力依赖的物理量不同而变化。我们将介绍求解微分方程的欧拉方法，并探讨在牛顿第二定律是核心原理的多种情境中，这一原理帮助我们理解物体运动。
- en: Newton’s First Law
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 牛顿的第一定律
- en: 'Let’s return to the air track of [Chapter 4](ch04.xhtml). If you give the car
    a little push on the air track and then let it go, it will travel at a constant
    speed until it hits the end of the track. After we stop pushing the car, it continues
    to move at some speed even with no force applied in the direction of motion. This
    tendency for moving objects to keep moving is called *inertia*. The idea of inertia
    is relevant in the one-dimensional spatial setting of the air track, and it’s
    also relevant in the unconstrained three-dimensional spatial setting of the world
    in which we live. The idea is important enough to be enshrined in a principle
    of physics called *Newton’s first law*. Here are three versions:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到[第4章](ch04.xhtml)的气轨道。如果你在气轨道上轻推小车，然后松手，它会以恒定的速度行驶，直到碰到轨道的尽头。在我们停止推车后，它会继续以某种速度运动，即使在运动方向上没有施加任何力。这种物体持续运动的倾向被称为*惯性*。惯性的概念在气轨道这一一维空间中是相关的，也同样适用于我们生活的无约束三维空间。这个概念足够重要，以至于它被确立为物理学中的一个原则——*牛顿的第一定律*。以下是三种版本：
- en: '**Newton’s first law, Newton’s words [[15](bib.xhtml#bib15)]**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**牛顿的第一定律，牛顿的原话 [[15](bib.xhtml#bib15)]**'
- en: '*Every body perseveres in its state of being at rest or of moving uniformly
    straight forward, except insofar as it is compelled to change its state by forces
    impressed.*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*每个物体都保持其静止状态或匀速直线前进状态，除非受到外力的作用迫使其改变状态。*'
- en: '**Newton’s first law, poetic version**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**牛顿的第一定律，诗意版**'
- en: '*A body in motion stays in motion. A body at rest stays at rest.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个运动中的物体保持运动，一个静止的物体保持静止。*'
- en: '**Newton’s first law, modern version**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**牛顿的第一定律，现代版本**'
- en: '*In the absence of applied forces, an object maintains the same velocity.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*在没有外力作用的情况下，物体保持相同的速度。*'
- en: Recall that velocity is a vector, so maintaining the same velocity means keeping
    the same speed as well as the same direction. Since acceleration is change in
    velocity per unit of time, an equivalent way of expressing Newton’s first law
    is that in the absence of forces, an object experiences no acceleration.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，速度是一个向量，所以保持相同的速度意味着保持相同的速度和相同的方向。由于加速度是单位时间内速度的变化，牛顿第一定律的一个等效表述是：在没有外力作用的情况下，物体不会经历加速度。
- en: Notice that Newton’s first law makes no mention of forces that were applied
    *in the past*. The point is that if there are no forces acting *now*, the velocity
    will stay constant now. Any time there are no forces present, the velocity will
    stay constant.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到牛顿的第一定律并未提到*过去*施加的力。关键在于，如果现在没有施加任何力，物体的速度将保持不变。任何时候如果没有力作用，速度都会保持不变。
- en: Why does Newton’s first law seem obviously false? Because we’re stuck on the
    surface of the earth, a place that is rife with forces we might fail to consider,
    friction and air resistance not least among them. Things are a bit simpler out
    in space. We can imagine one astronaut tossing a small wrench to another at slow
    speed. The wrench just glides straight across the ship, perhaps rotating slowly
    about its center. That wrench is a great example of Newton’s first law.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么牛顿的第一定律看起来明显是错误的？因为我们被困在地球表面，这里充满了许多我们可能未曾考虑的力，其中摩擦力和空气阻力尤为重要。在太空中，事情则简单一些。我们可以想象一名宇航员将一个小扳手慢速抛给另一名宇航员。扳手就这样沿着飞船滑行，或许围绕它的中心慢慢旋转。这个扳手就是牛顿第一定律的一个很好的例子。
- en: Perhaps you’ve been in a car when the driver slams on the brakes so that books,
    papers, and toys go flying forward (with respect to the car’s seats). In my family,
    we celebrate these moments by shouting “Newton’s first law!” From a perspective
    outside the (decelerating) car, the books, papers, and toys are doing their best
    to travel in a straight line, at least for the short period of time before gravity
    and other objects put an end to their line-like motion.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你曾经在车里，当司机猛踩刹车时，书籍、纸张和玩具会飞向前方（相对于车座）。在我们家，我们会通过大喊“牛顿第一定律！”来庆祝这些时刻。从外部（减速中的）车的视角来看，书籍、纸张和玩具正尽力沿直线运动，至少在重力和其他物体阻止它们的直线运动之前，短暂的一段时间内是如此。
- en: Newton’s first law tells us that objects naturally go steady and straight. In
    practice, though, they don’t. Newton’s second law explains how and why.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿的第一定律告诉我们，物体自然会保持平稳并沿直线运动。然而，实际上它们并不会这样做。牛顿第二定律解释了如何以及为什么。
- en: Newton’s Second Law in One Dimension
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 牛顿第二定律在一维中的应用
- en: Newton’s first law tells us that when no forces are present, an object does
    not accelerate. Newton’s second law claims that acceleration is caused by forces.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿的第一定律告诉我们，当没有外力作用时，物体不会加速。牛顿第二定律则宣称加速度是由外力引起的。
- en: '**Newton’s second law, Newton’s words [[15](bib.xhtml#bib15)]**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**牛顿第二定律，牛顿的原话 [[15](bib.xhtml#bib15)]**'
- en: '*A change in motion is proportional to the motive force impressed and takes
    place along the straight line in which that force is impressed.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*运动的变化与施加的动力成正比，并沿着施加力的直线方向发生。*'
- en: '**Newton’s second law, poetic version**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**牛顿第二定律，诗意版本**'
- en: '*An object’s acceleration is directly proportional to the net force acting
    on the object and inversely proportional to its mass.*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*物体的加速度与作用在物体上的净外力成正比，与物体的质量成反比。*'
- en: Modern versions of Newton’s second law are expressed by Equation 14.1 for Newton’s
    second law in one dimension, and Equation 16.1 for Newton’s second law in three
    dimensions. In the remainder of this chapter, we’ll treat Newton’s second law
    in one dimension, which allows us to keep things simple by using numbers rather
    than vectors for velocity, acceleration, and force. In [Chapter 16](ch16.xhtml),
    we’ll treat Newton’s second law in full generality with vectors.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿第二定律的现代版本通过方程式14.1来表示一维的牛顿第二定律，方程式16.1来表示三维的牛顿第二定律。在本章的其余部分，我们将讨论牛顿的第二定律在一维中的应用，这样我们可以通过使用数字而非向量来简化速度、加速度和力的表示。在[第16章](ch16.xhtml)中，我们将全面讨论牛顿的第二定律，包括向量形式。
- en: To discuss force and mass in a quantitative way, we need units of measure. In
    the SI system, force is measured in Newtons (N). A 100-N force has a different
    effect on a golf ball than it has on a bowling ball. According to Newton, each
    object has a *mass*, which determines the readiness of an object to accelerate
    in response to a force. A large-mass object experiences small acceleration compared
    to a small-mass object exposed to the same force. The SI unit of mass is the kilogram
    (kg).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以定量的方式讨论力和质量，我们需要度量单位。在国际单位制（SI）中，力的单位是牛顿（N）。100N 的力对高尔夫球的作用与对保龄球的作用不同。根据牛顿的理论，每个物体都有一个*质量*，它决定了物体对力的加速度反应能力。相比于暴露于相同力的质量较小的物体，质量较大的物体会经历较小的加速度。质量的国际单位是千克（kg）。
- en: 'Newton’s second law expresses a relationship between the following three quantities:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿第二定律表达了以下三者之间的关系：
- en: The forces that act on an object
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用在物体上的力
- en: The mass of the object
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物体的质量
- en: The acceleration of the object
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物体的加速度
- en: Newton’s second law says that the acceleration of an object can be found by
    dividing the net force acting on the object by the mass of the object. The *net
    force* acting on an object is the sum of all the forces acting on the object.
    In one dimension, some forces may be negative and some may be positive.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿第二定律指出，物体的加速度可以通过将作用在物体上的净力除以物体的质量来求得。作用在物体上的*净力*是作用在物体上的所有力的合力。在一维空间中，某些力可能是负的，某些力可能是正的。
- en: 'Newton’s second law is usually written as *F*[net] = *ma*. Unlike the one-dimensional
    equations for velocity and acceleration (Equations 4.5 and 4.12), this equation
    is not an equality of functions. The acceleration of the object is only a function
    of time, but the net force generally depends on the time, the position of the
    object, and the velocity of the object. The net force at time *t* is *F*[net]
    (*t*, *x*(*t*), *v*(*t*)). A better way to write Newton’s second law is:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿第二定律通常写作*F*[net] = *ma*。与速度和加速度的一维方程（方程 4.5 和 4.12）不同，这个方程并不是函数的相等式。物体的加速度只是时间的函数，但净力通常依赖于时间、物体的位置和物体的速度。时刻
    *t* 的净力是*F*[net] (*t*, *x*(*t*), *v*(*t*)）。更好的方式来写牛顿第二定律是：
- en: '![Image](Images/208equ01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/208equ01.jpg)'
- en: There is a chicken-and-egg issue going on with Newton’s second law. We know
    from Equations 4.5 and 4.12 that *v* = *Dx* and *a* = *Dv*. If we know the function
    *a* (meaning we know its value at all times), we can find the function *v* given
    an initial velocity. (See Equation 6.1 and the corresponding function `velFromAcc`.)
    We can then go on and find the function *x* given an initial position. (See Equation
    6.5 and the corresponding function `posFromVel`.) But Newton’s second law is telling
    us that acceleration depends on the forces, which depend on the position and the
    velocity. To find the position of my object, it seems that I need to find the
    velocity, and for that I need the acceleration. However, the acceleration depends
    on both the position and the velocity.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿第二定律存在一个“先有鸡还是先有蛋”的问题。我们从方程 4.5 和 4.12 中知道，*v* = *Dx* 和 *a* = *Dv*。如果我们知道加速度函数*
    a *（意味着我们知道它在所有时刻的值），我们可以在已知初始速度的情况下求得速度函数。（参见方程 6.1 以及对应的函数 `velFromAcc`。）然后我们可以继续求得位置函数*
    x *（参见方程 6.5 以及对应的函数 `posFromVel`）。但是，牛顿第二定律告诉我们，加速度依赖于力，而力又依赖于位置和速度。为了找到物体的位置，似乎需要先找到速度，而要找到速度，又需要加速度。然而，加速度又依赖于位置和速度。
- en: There is a name for this particular kind of chicken-and-egg problem. Newton’s
    second law is an example of a *differential equation*. A differential equation
    is a relationship between derivatives of an unknown function, with the unknown
    function itself often regarded as the zeroth derivative. The unknown function
    in the case of Newton’s second law is usually either the position *x* or the velocity
    *v*. Velocity can be written as the first derivative of position (*v* = *Dx*),
    and acceleration can be written as the second derivative of position (*a* = *Dv*
    = *D*²*x*).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“先有鸡还是先有蛋”的问题有一个专门的名字。牛顿第二定律是一个*微分方程*的例子。微分方程是未知函数的导数之间的关系，通常未知函数本身被视为零阶导数。在牛顿第二定律的情况下，未知函数通常是位置
    *x* 或速度 *v*。速度可以写作位置的第一导数（*v* = *Dx*），加速度可以写作位置的第二导数（*a* = *Dv* = *D*²*x*）。
- en: Newton’s second law looks more like a differential equation if we write it in
    terms of an unknown position function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将牛顿第二定律写成未知位置函数的形式，它看起来更像一个微分方程。
- en: '![Image](Images/208equ02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/208equ02.jpg)'
- en: This is a second-order differential equation because it is a relationship between
    the position function *x*, its first derivative *Dx*, and its second derivative
    *D*²*x*. The relationship for a particular physical object depends on the function
    *F*[net], which depends on the nature of the forces acting on the object.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个二阶微分方程，因为它是位置函数*x*、其一阶导数*Dx*和二阶导数*D*²*x*之间的关系。特定物体的关系取决于合力*F*[net]，而合力又依赖于作用在物体上的力的性质。
- en: In simple situations, the net force on an object may not depend on time, position,
    and velocity, but rather only on zero, one, or two of these physical quantities.
    In these simple situations, Newton’s second law may appear as something simpler
    than a second-order differential equation. [Table 14-1](ch14.xhtml#ch14tab1) lists
    situations by the physical quantities that the forces depend on and gives the
    mathematical technique needed to solve Newton’s second law.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的情况下，物体上的合力可能不依赖于时间、位置和速度，而只依赖于这些物理量中的零个、一个或两个。在这些简单的情况下，牛顿第二定律可能表现为比二阶微分方程更简单的形式。[表14-1](ch14.xhtml#ch14tab1)按力所依赖的物理量列出了各种情况，并给出了求解牛顿第二定律所需的数学技巧。
- en: '**Table 14-1:** The Technique for Solving Newton’s Second Law, Based on Which
    Physical Quantities the Forces Depend On'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**表14-1：** 基于力依赖的物理量的牛顿第二定律求解技巧'
- en: '| **Forces depend only on** | **Solution technique** |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **力只依赖于** | **解决技巧** |'
- en: '| --- | --- |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Nothing | Algebra |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 无 | 代数 |'
- en: '| Time | Integration |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 时间 | 积分 |'
- en: '| Velocity | First-order differential equation |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 速度 | 一阶微分方程 |'
- en: '| Time and velocity | First-order differential equation |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 时间和速度 | 一阶微分方程 |'
- en: '| Time, position, and velocity | Second-order differential equation |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 时间、位置和速度 | 二阶微分方程 |'
- en: A net force that depends on nothing is a constant net force. Its value remains
    constant over time, independent of time, position, or velocity. In the next several
    sections, we’ll look at constant forces, forces that depend only on time, forces
    that depend only on velocity, and forces that depend on both time and velocity.
    This restriction allows us to limit our attention in this chapter to first-order
    differential equations. In [Chapter 15](ch15.xhtml), we’ll look at the more general
    case of one-dimensional motion in which the net force can depend on time, position,
    *and* velocity.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不依赖任何因素的合力是一个恒定的合力。它的大小在时间、位置或速度的变化下保持不变。在接下来的几节中，我们将讨论恒定力、只依赖于时间的力、只依赖于速度的力以及依赖于时间和速度的力。这种限制使我们能够在本章中将注意力集中在一阶微分方程上。在[第15章](ch15.xhtml)中，我们将研究更一般的情况，即合力可以依赖于时间、位置、*以及*速度的一维运动。
- en: Second Law with Constant Forces
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恒定力下的第二定律
- en: The simplest situation for Newton’s second law is when the net force is constant,
    independent of time, position, and velocity. Most problems in an introductory
    physics course are like this because they can be solved without differential equations
    and without a computer.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿第二定律的最简单情况是当合力是恒定的，与时间、位置和速度无关。大多数入门物理课程中的问题都属于这种情况，因为它们可以在没有微分方程和计算机的情况下解决。
- en: Let’s consider an example problem with constant forces.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来考虑一个常力的例子问题。
- en: '**Example 14.1.** Suppose we have a car with mass 0.1 kg on an air track. The
    car is initially moving east at a speed of 0.6 m/s. Starting at time *t* = 0,
    we apply to this car a constant force of 0.04 N to the east. At the same time,
    our friend applies to the same car a constant force of 0.08 N to the west. What
    will the subsequent motion of the car look like? In particular, how will the velocity
    and the position of the car change in time?'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**例14.1** 假设我们有一辆质量为0.1千克的车，在气轨上。车初速度为0.6米/秒，向东运动。从时间*t* = 0开始，我们对这辆车施加一个向东的恒定力0.04
    N。与此同时，我们的朋友对同一辆车施加一个向西的恒定力0.08 N。那么，这辆车接下来的运动将是什么样的？特别是，车的速度和位置将如何随时间变化？'
- en: '[Figure 14-1](ch14.xhtml#ch14fig1) shows the schematic diagram.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-1](ch14.xhtml#ch14fig1)展示了示意图。'
- en: '![Image](Images/209fig01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/209fig01.jpg)'
- en: '*Figure 14-1: Schematic diagram for Newton’s second law with constant forces*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-1：带有恒定力的牛顿第二定律示意图*'
- en: The constant net force ![Image](Images/210equ01.jpg) (superscript *c* for constant)
    acting on the object needs to be divided by the mass of the object to obtain the
    acceleration of the object. Because the net force is constant, the acceleration
    is also constant.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 恒定的净力 ![Image](Images/210equ01.jpg)（上标 *c* 表示常数）作用于物体，必须除以物体的质量，才能得到物体的加速度。由于净力是常数，加速度也为常数。
- en: '![Image](Images/210equ02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/210equ02.jpg)'
- en: We write *a*(*t*) rather than *a* for acceleration, not because acceleration
    changes with time, but because *a* is the acceleration function (type `R -> R`)
    and *a*(*t*) is the acceleration (type `R`). We then integrate acceleration to
    obtain the velocity.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写 *a*(*t*) 而不是 *a* 来表示加速度，并不是因为加速度随时间变化，而是因为 *a* 是加速度函数（类型为 `R -> R`），而 *a*(*t*)
    是加速度（类型为 `R`）。我们随后对加速度进行积分，以得到速度。
- en: '![Image](Images/210equ03.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/210equ03.jpg)'
- en: The integrator that produces velocity contains a real number (type `R`) as state.
    This type is shown below the integrator in [Figure 14-1](ch14.xhtml#ch14fig1).
    This integrator remembers the current velocity so that it can be updated using
    the acceleration.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 产生速度的积分器包含一个实数（类型为 `R`）作为状态。这个类型在 [图14-1](ch14.xhtml#ch14fig1) 中的积分器下方显示。这个积分器记住当前的速度，以便可以使用加速度来更新它。
- en: We then integrate the velocity to obtain the position.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们对速度进行积分，以获得位置。
- en: '![Image](Images/210equ04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/210equ04.jpg)'
- en: The wires of the diagram represent quantities that are continuously changing
    in time. Each wire in the diagram is labeled with a name and a type. For this
    diagram, all of the wire types are real numbers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的电线表示随时间持续变化的量。图中的每根电线都有一个名称和类型。在这个图中，所有的电线类型都是实数。
- en: Rectangular boxes represent purely functional constants and functions. In other
    words, they are constants and functions that do not contain any state, so that
    the output is a function only of the input. The circular integrators contain states
    that must be combined with the input to produce the output. The integrators are
    labeled with the type of state they contain, which is the same as the type of
    the output from the integrator.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形框表示纯粹的函数常量和函数。换句话说，它们是没有任何状态的常量和函数，因此输出仅取决于输入。圆形积分器包含必须与输入结合以产生输出的状态。积分器标注有其包含的状态类型，这与积分器的输出类型相同。
- en: Before we write Haskell code to solve Newton’s second law for constant forces,
    we are going to write a few lines of code that need to be at the top of the source
    code file we build throughout this chapter. The first line turns on warnings,
    which I recommend doing because the compiler will warn you of things that are
    legal but unusual enough that they may not be what you intended. The second line
    gives the code in this chapter the module name `Newton2`. If we want to use functions
    we write here in later chapters, we’ll refer to the current code using its module
    name. A module name is optional, but if you use one, it must match the filename;
    in this case, the filename should be *Newton2.hs*. The third line loads the `gnuplot`
    graphics library so that we can make a graph. Imports like this must occur before
    any function definitions or type signatures.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写 Haskell 代码以解决牛顿第二定律在恒定力作用下的问题之前，我们将编写几行代码，这些代码需要放在我们在本章中构建的源代码文件的顶部。第一行打开警告，我建议开启，因为编译器会警告你一些合法但足够不常见的情况，可能不是你想要的。第二行为本章中的代码指定模块名为
    `Newton2`。如果我们想在后续章节中使用这里编写的函数，我们将通过模块名引用当前代码。模块名是可选的，但如果使用，必须与文件名匹配；在这种情况下，文件名应为
    *Newton2.hs*。第三行加载 `gnuplot` 图形库，以便我们能够绘制图形。像这样的导入必须在任何函数定义或类型签名之前发生。
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Example 14.1 is typical of situations in which Newton’s second law applies.
    Given a mass, an initial velocity, and some forces, we are asked to produce velocity
    as a function of time. In the Haskell language, a solution to this example situation
    would be a (higher-order) function `velocityCF` (`CF` for constant forces) with
    the following type:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 14.1 是牛顿第二定律应用的典型情况。给定一个质量、初始速度和一些力，我们需要求出速度随时间的变化。在 Haskell 语言中，解决此问题的方案将是一个（高阶）函数
    `velocityCF`（`CF` 代表恒定力），其类型如下：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Recall that there are (at least) two ways to read this type signature. On one
    reading, `velocityCF` takes four inputs—mass, initial velocity, a list of forces,
    and a time—and produces as output a real number representing velocity. An alternative
    reading is that `velocityCF` takes three inputs—mass, initial velocity, and a
    list of forces—and produces as output a *function* for how velocity changes with
    time. If we wanted to emphasize the latter viewpoint, we could write
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，解读这个类型签名有（至少）两种方式。一种解读是，`velocityCF`接受四个输入——质量、初始速度、一个力的列表和时间——并输出一个表示速度的实数。另一种解读是，`velocityCF`接受三个输入——质量、初始速度和一个力的列表——并输出一个关于速度如何随时间变化的*函数*。如果我们想强调后者的观点，我们可以这样写：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: but it means the same thing as the original type signature.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但它与原始类型签名的含义是一样的。
- en: We used the types `Time`, `Mass`, `Velocity`, and `Force`. These are not built-in
    types in Haskell, so we’d better define what they mean. In one-dimensional mechanics,
    all of these quantities can be represented with real numbers, so we can write
    some type synonyms to define these types. Using a type synonym in which `R` stands
    for `Double`,
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了类型`Time`、`Mass`、`Velocity`和`Force`。这些在Haskell中不是内建类型，因此我们最好定义它们的含义。在一维力学中，所有这些量都可以用实数表示，因此我们可以写一些类型别名来定义这些类型。使用一个类型别名，其中`R`代表`Double`，
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'we can write type synonyms for all of the other types:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为所有其他类型写类型别名：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The definitions for types `Mass`, `Time`, and so on, need not appear before
    their use in a type signature. Haskell allows definitions of constants, functions,
    and types before or after their use.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 类型`Mass`、`Time`等的定义不必出现在它们在类型签名中的使用之前。Haskell允许在使用前或使用后定义常量、函数和类型。
- en: 'If we can write a function `velocityCF` with the type signature above, we will
    have solved not just Example 14.1, but all others like it. Our strategy in writing
    such a function is:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能写出一个类型签名如上的函数`velocityCF`，那么我们不仅解决了例子14.1的问题，还解决了所有类似的问题。我们写这样一个函数的策略是：
- en: Find the net force by adding all of the forces
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过加总所有的力来求得合力
- en: Find the acceleration using Newton’s second law (Equation 14.3)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用牛顿第二定律（方程14.3）求加速度
- en: Find the velocity from the acceleration (Equation 4.14 or 14.4)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过加速度求得速度（方程4.14或14.4）
- en: Here’s a definition for `velocityCF` that expresses these three steps and has
    the type we claimed earlier.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`velocityCF`的定义，它表达了这三步操作，并具有我们之前声明的类型。
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To write the function `velocityCF`, we begin by naming the three inputs: mass
    `m`, initial velocity `v0`, and list of forces `fs`. We then use a `let` construction
    to define three local names for net force, acceleration, and velocity. To find
    the net force, we sum up the forces in the list using the built-in `sum` function.
    To find the acceleration, we divide the net force on the object by the mass of
    the object, as Newton’s second law prescribes.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写`velocityCF`函数，我们首先命名三个输入：质量`m`、初始速度`v0`和力的列表`fs`。然后，我们使用`let`结构定义三个局部名称，分别代表合力、加速度和速度。为了求合力，我们使用内建的`sum`函数将列表中的所有力相加。为了求加速度，我们将物体的合力除以物体的质量，正如牛顿第二定律所规定的那样。
- en: The third equation in the `let` construction defines a local function `v` to
    represent the velocity function. We use Equation 4.14, one of the constant acceleration
    equations introduced in standard introductory physics textbooks, but we could
    just as easily have used Equation 14.4 in place of the second and third lines
    of the `let` construction. Notice that we have written the definition of `velocityCF`
    using the “three-input thinking” mentioned earlier. Exercise 14.1 asks you to
    rewrite the function using four-input thinking.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`结构中的第三个方程定义了一个局部函数`v`来表示速度函数。我们使用方程4.14，这是在标准入门物理教材中引入的常数加速度方程，但我们完全可以用方程14.4代替`let`结构的第二行和第三行。请注意，我们已经使用了之前提到的“三输入思维”来写`velocityCF`的定义。练习14.1要求你使用四输入思维重写这个函数。'
- en: We can write a function `positionCF` that produces a position function given
    mass, initial position, initial velocity, and a list of constant forces.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个函数`positionCF`，给定质量、初始位置、初始速度和常力列表，生成一个位置函数。
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we have used Equation 4.15 or 14.5\. Returning to Example 14.1, the velocity
    of the car as a function of time is
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了方程4.15或14.5。回到例子14.1，汽车的速度作为时间的函数是
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: because 0.1 kg is the mass of the car, 0.6 m/s is its initial velocity, and
    the square-bracketed list contains the forces in Newtons. We can ask for the type
    of this function in GHCi, and we can ask for values of the velocity at specific
    times.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因为0.1 kg是汽车的质量，0.6 m/s是其初速度，方括号中的列表包含了以牛顿为单位的力。我们可以在GHCi中查询这个函数的类型，也可以查询特定时间点的速度值。
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since we have the velocity function in hand, we can graph it. Let’s write the
    code to do so first. Most of the code below is for setting up a title, axis labels,
    and the name of the file we want produced. The interesting stuff is at the end,
    where we give a list of times at which to evaluate the function and the function
    itself.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了速度函数，我们可以绘制它的图形。首先让我们写出绘制图形的代码。下面的大部分代码用于设置标题、坐标轴标签和我们希望生成的文件名。最有趣的部分在最后，我们给出了在特定时间点评估函数的时间列表，以及函数本身。
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code produces the graph in [Figure 14-2](ch14.xhtml#ch14fig2).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成了[图14-2](ch14.xhtml#ch14fig2)中的图形。
- en: '![Image](Images/213fig01.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/213fig01.jpg)'
- en: '*Figure 14-2: Car velocity as a function of time in Example 14.1*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-2：示例14.1中汽车速度随时间的变化*'
- en: If you load this chapter’s module, `Newton2`, into GHCi and enter `carGraph`,
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在GHCi中加载本章的模块`Newton2`并输入`carGraph`，
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: you will not get any return value, but the function will produce a Portable
    Network Graphics (PNG) file named *CarVelocity.png* on your hard drive. Without
    the `PNG "CarVelocity.png"` option, the `carGraph` function would produce a graph
    on the screen.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会得到任何返回值，但该函数会在你的硬盘上生成一个名为*CarVelocity.png*的可移植网络图形（PNG）文件。如果没有`PNG "CarVelocity.png"`选项，`carGraph`函数会在屏幕上生成一个图形。
- en: Note that the negative acceleration in the graph in [Figure 14-2](ch14.xhtml#ch14fig2)
    (which exists over the entire time interval from *t* = 0 to *t* = 4 s) does not
    mean that the car is always slowing down. Rather, a negative acceleration means
    an acceleration to the west. The car slows down during the first 1.5 s as it is
    moving east but then begins to speed up as it moves west. When the acceleration
    and velocity of an object point in the same direction, the object speeds up. When
    the acceleration and velocity of an object point in opposite directions, the object
    slows down.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，图表中[图14-2](ch14.xhtml#ch14fig2)的负加速度（存在于从*t* = 0到*t* = 4秒的整个时间间隔内）并不意味着汽车一直在减速。相反，负加速度意味着加速度指向西方。汽车在前1.5秒内向东行驶时减速，但随后开始向西行驶时加速。当物体的加速度和速度方向一致时，物体加速；当物体的加速度和速度方向相反时，物体减速。
- en: With the functions `velocityCF` and `positionCF`, we have general-purpose ways
    of solving any Newton’s second law type problem in one spatial dimension with
    constant forces. Next we’ll consider forces that change in time.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数`velocityCF`和`positionCF`，我们有了处理任何牛顿第二定律问题的通用方法，适用于一维空间中具有恒定力的情况。接下来我们将考虑随时间变化的力。
- en: Second Law with Forces That Depend Only on Time
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅依赖于时间的力的第二定律
- en: The next situation for Newton’s second law is when the net force depends on
    time but not on position or velocity. [Figure 14-3](ch14.xhtml#ch14fig3) shows
    a schematic diagram for Newton’s second law with forces that depend only on time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿第二定律的下一个情况是当净力仅依赖于时间，而不依赖于位置或速度时。[图14-3](ch14.xhtml#ch14fig3)显示了牛顿第二定律的示意图，力仅依赖于时间。
- en: '![Image](Images/214fig01.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/214fig01.jpg)'
- en: '*Figure 14-3: Schematic diagram for Newton’s second law with forces that depend
    only on time*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-3：牛顿第二定律示意图，力仅依赖于时间*'
- en: The constant number 1 is fed into an integrator to produce a value for time.
    (The time changes at a rate of 1 second per second.) As usual, wires are labeled
    with names and types. Integrators are labeled with the type of state they hold.
    Time is fed into the net force function ![Image](Images/e0214-01.jpg) (superscript
    *t* for time-dependent), which produces net force as output. To obtain the acceleration
    of the object, we need to divide the net force acting on the object by the object’s
    mass.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 常数1被输入到积分器中，生成时间值。（时间以每秒1秒的速率变化。）如往常一样，电线标有名称和类型。积分器标注了它们所持有的状态类型。时间输入到净力函数中![Image](Images/e0214-01.jpg)（上标*t*表示时间相关），该函数输出净力。为了得到物体的加速度，我们需要将作用在物体上的净力除以物体的质量。
- en: '![Image](Images/214equ01.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/214equ01.jpg)'
- en: We then integrate the acceleration to obtain the velocity,
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后对加速度进行积分，以得到速度，
- en: '![Image](Images/215equ01.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/215equ01.jpg)'
- en: 'and we integrate the velocity to obtain the position:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后对速度进行积分，以得到位置：
- en: '![Image](Images/215equ02.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/215equ02.jpg)'
- en: The wires of the diagram represent quantities that are continuously changing
    in time. Rectangular boxes represent pure functions, whereas circular elements
    contain state.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的电线表示随时间连续变化的量。矩形框表示纯函数，而圆形元素包含状态。
- en: 'To solve Newton’s second law problems with forces that depend on time, we’d
    like a higher-order function that produces a velocity function, similar to `velocityCF`
    in the previous section. One difference is that now we need to provide a list
    of force *functions* rather than a list of numerical forces. We want a function
    `velocityFt` (the `Ft` suffix denotes that forces depend only on time) with the
    following type signature:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决依赖于时间的力问题，我们希望得到一个更高阶的函数，产生一个速度函数，类似于上一节中的 `velocityCF`。一个区别是，我们现在需要提供一个力
    *函数* 的列表，而不是一个数值力的列表。我们希望得到一个函数 `velocityFt`（`Ft` 后缀表示力仅依赖于时间），其类型签名如下：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Given the mass of our object, its initial velocity, and a list of force functions,
    we want to produce a velocity function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 给定我们物体的质量、初始速度和一个力函数列表，我们希望得到一个速度函数。
- en: 'Because we’re going to do numerical integration to get the velocity function,
    we’ll add one additional parameter to this type signature, namely the time step
    for numerical integration. Thus, we arrive at the following definition for `velocityFt`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将进行数值积分来得到速度函数，所以我们会在这个类型签名中增加一个额外的参数，即数值积分的时间步长。因此，我们得到了 `velocityFt` 的以下定义：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this definition, we begin by naming the inputs: `dt` for an integration
    time step, `m` for the mass of the object we are attending to, `v0` for the initial
    velocity of this object, and `fs` for a list of force functions. Note that the
    local variable for forces, `fs`, had type `[Force]` (or `[R]`) when used in `velocityCF`
    and `positionCF` for situations with constant forces, but it now has type `[Time
    ->` `Force]` (or `[R -> R]`) for situations with forces that depend on time.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个定义中，我们首先命名输入：`dt` 代表积分时间步长，`m` 代表我们关注的物体的质量，`v0` 代表该物体的初始速度，`fs` 代表一个力函数列表。请注意，`fs`
    这个局部变量在处理常力情况时，作为 `velocityCF` 和 `positionCF` 中使用时，其类型为 `[Force]`（或 `[R]`），但在处理依赖于时间的力时，其类型现在变为
    `[Time -> Force]`（或 `[R -> R]`）。
- en: We again use a `let` construction to define local functions, a net force function,
    and an acceleration function. The net force function adds together the forces
    provided in the list `fs`. We might have hoped we could use the same line of code
    we used in `velocityCF`, namely `fNet = sum fs`, to sum the forces. After all,
    `fs` is still a list. The trouble is that `sum` works only with types that are
    instances of `Num`, as you can see if you look at the type of `sum`. So while
    it is happy to add numbers (type `R`), it is not happy to add functions (type
    `R -> R`). Fortunately, we can evaluate the force functions at a time `t` introduced
    as an argument to `fNet` and then add the resulting numbers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用 `let` 结构来定义局部函数，一个是净力函数，一个是加速度函数。净力函数将 `fs` 列表中的所有力加在一起。我们可能希望能够像在 `velocityCF`
    中那样使用相同的一行代码，即 `fNet = sum fs` 来求和力。毕竟，`fs` 仍然是一个列表。问题是 `sum` 仅适用于 `Num` 的实例类型，如你查看
    `sum` 的类型所见。因此，它很乐意对数字（类型 `R`）进行求和，但对函数（类型 `R -> R`）则不行。幸运的是，我们可以在 `fNet` 的参数中引入时间
    `t`，对力函数进行评估，并将得到的数字加在一起。
- en: The acceleration function comes from Newton’s second law. Here, we might have
    hoped that we could divide the net force function by the mass to obtain the acceleration
    function, perhaps writing `a = fNet / m`. But recall that the division operator
    insists that it work with two values that have the same type and that this type
    be an instance of `Fractional`. The division operator does not want to work with
    functions. Again, we address this by evaluating the `fNet` function at the time
    `t` introduced as the argument to the acceleration function `a`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度函数来源于牛顿第二定律。在这里，我们可能希望通过将净力函数除以质量来获得加速度函数，或许写成 `a = fNet / m`。但是回想一下，除法运算符要求两个值的类型相同，并且该类型是
    `Fractional` 的实例。除法运算符不愿意与函数一起使用。我们通过对加速度函数 `a` 的时间参数 `t` 传入，来解决这个问题，再次评估 `fNet`
    函数。
- en: 'Finally, the velocity comes from taking an antiderivative of the acceleration
    function. We defined the functions `antiDerivative` and `integral` in [Chapter
    6](ch06.xhtml), but we’ll repeat their definitions here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，速度来自对加速度函数的反导数。我们在[第六章](ch06.xhtml)中定义了 `antiDerivative` 和 `integral` 函数，但我们将在这里重复它们的定义：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that `velocityFt dt m v0 fs` has type `R -> R` and is the velocity function
    for an object with mass `m`, initial velocity `v0`, and list of force functions
    `fs`. This velocity function is part of the solution to the mechanics problem.
    Another part of the solution is a position function. We can write a function `positionFt`
    that produces a position function given mass, initial position, initial velocity,
    and a list of force functions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`velocityFt dt m v0 fs` 的类型是 `R -> R`，它是一个描述物体质量为 `m`、初速度为 `v0`，并且受力函数列表为
    `fs` 的速度函数。这个速度函数是力学问题解的一部分。解的另一个部分是位置函数。我们可以写一个 `positionFt` 函数，通过给定质量、初始位置、初速度和力函数列表，生成位置函数。
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function works by taking an antiderivative of the velocity function, which
    we find using `velocityFt`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数通过对速度函数取反导数来工作，我们通过 `velocityFt` 找到这个速度函数。
- en: As an example of solving Newton’s second law with a time-dependent force, consider
    a child riding a bike. By working the pedals, the child arranges for the ground
    to apply a constant forward force of 10 N on the bike for 10 seconds, after which
    the child coasts for the next 10 seconds. Following the coasting, the child returns
    to the 10-N force for another 10 seconds, and so on, as illustrated in [Figure
    14-4](ch14.xhtml#ch14fig4).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 作为求解牛顿第二定律的一个示例，考虑一个骑自行车的孩子。通过踩踏板，孩子使地面在 10 秒内对自行车施加一个 10 N 的恒定前向力，然后孩子滑行 10
    秒。滑行结束后，孩子会恢复 10 N 的力，再持续 10 秒，如 [图 14-4](ch14.xhtml#ch14fig4) 所示。
- en: '![Image](Images/217fig01.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/217fig01.jpg)'
- en: '*Figure 14-4: Force as a function of time for a child on a bike*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-4：儿童骑车时力与时间的关系*'
- en: In this example, we’ll assume that air resistance is not important and that
    there is only one force on the bike.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们假设空气阻力不重要，并且自行车上只有一个力。
- en: 'Here is the equation for the time-dependent force of pedaling and coasting:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是踩踏和滑行的时间相关力的方程：
- en: '![Image](Images/217equ01.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/217equ01.jpg)'
- en: The force is either 0 N or 10 N, depending on where the time falls in a 20-second
    cycle. If the time falls in the first 10 seconds of the cycle, the force is 10
    N. If, on the other hand, the time falls in the last 10 seconds of the cycle,
    the force is 0 N.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 力的大小要么是 0 N，要么是 10 N，具体取决于时间在 20 秒周期中的位置。如果时间处于周期的前 10 秒，力是 10 N；如果时间处于周期的后
    10 秒，力是 0 N。
- en: 'Here is the time-dependent force of Equation 14.8 in Haskell:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Haskell 中方程 14.8 的时间相关力：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The local variable `tCycle` is the number of seconds for a full cycle. The variable
    `nComplete` uses the Prelude function `truncate` to calculate the number of complete
    cycles from the time `t`. The `truncate` function produces a type with type class
    `Integral` (recall `Integer` and `Int` are instances of `Integral`). We provide
    a local type signature to say that we want `nComplete` to have type `Int`. The
    local type signature is optional, but the compiler will give us a warning that
    it chose a default type if we don’t specify something. Remove the local type signature
    to see what the warning looks like. This is a mild warning. We don’t mind that
    the compiler chooses `Integer` instead of `Int`. You can feel free to ignore this
    warning and use the code without the type signature if you wish.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量 `tCycle` 是一个完整周期的秒数。变量 `nComplete` 使用 Prelude 函数 `truncate` 计算从时间 `t` 开始的完整周期数。`truncate`
    函数会生成一个类型为 `Integral` 的类型类（回忆一下，`Integer` 和 `Int` 都是 `Integral` 的实例）。我们提供了一个局部类型签名，表示我们希望
    `nComplete` 的类型为 `Int`。这个局部类型签名是可选的，但如果不指定类型，编译器会给我们一个默认类型的警告。去掉局部类型签名看看警告是什么样子的。这只是一个轻微的警告。如果编译器选择
    `Integer` 而不是 `Int`，我们也不介意。你可以选择忽略这个警告，并在没有类型签名的情况下使用代码。
- en: 'The `remainder` is the number of seconds, between 0 and 20, that have elapsed
    since the beginning of the most recent cycle. We want `remainder` to be a real
    number, so we must use `fromIntegral` to convert `nComplete :: Int` into a real
    number.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`remainder` 是自最近一个周期开始以来经过的秒数，范围在 0 到 20 之间。我们希望 `remainder` 是一个实数，因此必须使用 `fromIntegral`
    将 `nComplete :: Int` 转换为实数。'
- en: '[Figure 14-5](ch14.xhtml#ch14fig5) shows the position of the child as a function
    of time.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-5](ch14.xhtml#ch14fig5) 显示了儿童的位置与时间的关系。'
- en: '![Image](Images/218fig01.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/218fig01.jpg)'
- en: '*Figure 14-5: Position as a function of time for the child on a bike*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-5：儿童骑车时位置与时间的关系*'
- en: 'Here is the Haskell code that produced [Figure 14-5](ch14.xhtml#ch14fig5):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是生成 [图 14-5](ch14.xhtml#ch14fig5) 的 Haskell 代码：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The most interesting part of the code is the last line, where we specify the
    function we want plotted. This function, `positionFt 0.1 20 0 0 [pedalCoast]`,
    uses the `positionFt` function we developed earlier in the chapter with a time
    step of 0.1 s, a mass of 20 kg, 0s for initial position and initial velocity,
    and a list of forces that includes only the force of pedaling and coasting. All
    of the relevant physical information is included in the “name” of the function
    we are plotting.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中最有趣的部分是最后一行，在这里我们指定了要绘制的函数。这个函数`positionFt 0.1 20 0 0 [pedalCoast]`使用了我们在本章早些时候开发的`positionFt`函数，时间步长为0.1秒，质量为20千克，初始位置和初始速度均为0秒，力的列表中仅包括踩踏和滑行的力量。所有相关的物理信息都包含在我们绘制的函数的“名称”中。
- en: You can see from the graph in [Figure 14-5](ch14.xhtml#ch14fig5) that during
    the first 10 seconds, the child’s position curve is parabolic, as we’d expect
    from constant acceleration. From 10 to 20 seconds, the position shows constant
    velocity while the child is coasting. From 20 to 30 seconds, there is another
    period of acceleration in which the position curve is parabolic, followed by a
    second period of coasting.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从[图14-5](ch14.xhtml#ch14fig5)中的图表可以看出，在前10秒内，孩子的位置曲线呈抛物线形状，这符合恒定加速度的预期。从10秒到20秒，位置曲线表现为恒定速度，这时孩子正在滑行。从20秒到30秒，再次出现加速阶段，位置曲线呈抛物线形状，随后是第二次滑行阶段。
- en: With the functions `velocityFt` and `positionFt`, we have general-purpose ways
    of solving any Newton’s second law type problem in one spatial dimension with
    forces that depend only on time. We’re now ready to look at forces that depend
    on velocity, the most common of which is air resistance.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`velocityFt`和`positionFt`这两个函数，我们可以在一维空间中求解任何牛顿第二定律类型问题，且这些问题的力仅依赖于时间。现在，我们准备研究依赖于速度的力，其中最常见的就是空气阻力。
- en: Air Resistance
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空气阻力
- en: In this section, we’ll make a short diversion from our path of considering Newton’s
    second law in the presence of forces that depend on time, velocity, neither, or
    both to develop an expression for the force of air resistance on an object in
    one-dimensional motion. Air resistance is a force that depends only on velocity,
    and we’ll use it in the next several sections as we develop ways to solve Newton’s
    second law with forces that depend on velocity.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将短暂偏离原来的思路，考虑牛顿第二定律在时间、速度、两者或都不依赖的力的作用下，推导出空气阻力在一维运动中的作用力表达式。空气阻力是一个仅依赖于速度的力，在接下来的几个章节中，我们将使用它来发展求解牛顿第二定律的方式，这些方式涉及到依赖于速度的力。
- en: Introductory physics classes typically ignore air resistance or treat it very
    lightly, because the presence of air resistance turns Newton’s second law into
    a differential equation, which is considered beyond the scope of an introductory
    physics course. In this chapter and the next, we’ll develop numerical methods
    for solving differential equations, meaning that air resistance is not something
    we want to avoid; in fact, it showcases the power of our tools.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 物理入门课程通常忽略空气阻力，或者仅轻微处理它，因为空气阻力的存在使得牛顿第二定律转变为微分方程，这被认为超出了入门物理课程的范围。在本章及下章中，我们将开发求解微分方程的数值方法，这意味着空气阻力不是我们想要避免的东西；事实上，它展示了我们工具的强大能力。
- en: To develop a model of air resistance, let’s think of the interaction between
    an object and the air around it as a collision. Suppose the object is moving with
    velocity *v*. In this section, *v* represents the real-valued, one-dimensional
    velocity of the object (a quantity with type `R`) and not the velocity function
    or the speed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立空气阻力的模型，我们可以将物体与周围空气的相互作用看作一次碰撞。假设物体以速度*v*运动。在本节中，*v*代表物体的实数值一维速度（类型为`R`），而不是速度函数或速率。
- en: Let the cross-sectional area of the object be *A* and the density of air be
    *ρ*. We analyze the motion of the object over a small time interval *dt*. We assume
    that the initial velocity of the air is 0, and that the final velocity of the
    air is *v* (in other words, after the collision, the air is traveling at the same
    speed as the object).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 设物体的横截面积为*A*，空气密度为*ρ*。我们分析物体在一个小时间间隔*dt*内的运动。我们假设空气的初始速度为0，空气的最终速度为*v*（换句话说，碰撞后空气与物体以相同速度移动）。
- en: The distance the object travels in time *dt* is *v dt*. The volume of air swept
    out by the object in time *dt* is *Av dt*. The mass of air disturbed by the object
    in time *dt* is *ρAv dt*. The momentum imparted to the air by the object in time
    *dt* is the product of the mass of the air, *ρAv dt*, and the change in velocity
    of the air, which is *v*, as we assume that the air starts from rest and ends
    the short time interval with velocity *v*. The momentum imparted to the air is
    *ρAv*²*dt*. The force felt by the air is this change in momentum per unit time,
    or *ρAv*². The force felt by the object from the air is equal and opposite to
    this following Newton’s third law, which we will discuss in [Chapter 19](ch19.xhtml).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 物体在时间*dt*内移动的距离是*v dt*。物体在时间*dt*内扫过的空气体积是*Av dt*。物体在时间*dt*内扰动的空气质量是*ρAv dt*。物体在时间*dt*内传递给空气的动量是空气质量*ρAv
    dt*与空气速度变化*v*的乘积，假设空气从静止开始，并在短时间内以速度*v*结束。传递给空气的动量是*ρAv*²*dt*。空气受到的力是单位时间内动量变化，即*ρAv*²。根据牛顿第三定律，物体受到的来自空气的力与此相等且方向相反，我们将在[第19章](ch19.xhtml)讨论这个问题。
- en: Our derivation was really quite approximate because we don’t know that the air
    molecules really end up with velocity *v*, and we haven’t even tried to account
    for the forces of air molecules on each other as the air compresses. Nevertheless,
    the form of our result is quite useful and approximately correct. Objects with
    different shapes respond a bit differently though, so it is useful to introduce
    a *drag coefficient C* to account for these differences. The drag coefficient
    is a dimensionless constant that is a property of the object that is flying through
    the air. It is also conventional to include a factor of 1/2 so that the magnitude
    of the force of air resistance on the object is *CρA v*²/2\. This expression is
    never negative. We would prefer an expression in which the force is negative when
    the velocity is positive and positive when the velocity is negative. Our final
    expression for the one-dimensional force of air resistance is
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的推导实际上相当近似，因为我们并不知道空气分子是否最终以速度*v*结束，而且我们也没有尝试考虑空气分子之间的相互作用力，尤其是空气压缩时的力。然而，我们的结果形式是相当有用且近似正确的。不过，不同形状的物体响应略有不同，因此引入*阻力系数C*来考虑这些差异是有用的。阻力系数是一个无量纲常数，是物体飞行时穿越空气的一个特性。通常还会包括1/2的因子，使得物体所受的空气阻力的大小为*CρA
    v*²/2\。这个表达式从不为负。我们更希望有一个表达式，当速度为正时力为负，速度为负时力为正。我们得到的空气阻力一维力的最终表达式是
- en: '![Image](Images/220equ01.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/220equ01.jpg)'
- en: 'where the minus sign and the absolute value ensure that the force acts in a
    direction opposite the velocity. Air resistance is acting to slow the object.
    In Haskell, we’ll write Equation 14.9 for air resistance as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，负号和绝对值确保力的方向与速度相反。空气阻力作用于减速物体。在Haskell中，我们将空气阻力的方程14.9写作如下：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the mathematical notation of Equation 14.9, we’re treating *F*[air] as a
    function of one variable. The parameters *C*, *ρ*, and *A* are not listed explicitly
    as variables that *F*[air] depends on. Eliding parameters like this is standard
    practice in physics, but in some sense it’s an abuse of notation. In the Haskell
    notation, we must include all of the variables that the force of air resistance
    depends on. We list the three parameters first, before the `Velocity`, so that
    an expression like `fAir 1 1.225 0.6` is a fully legitimate function that takes
    only velocity as input. The function `fAir 1 1.225 0.6` has already chosen drag
    = 1, rho = 1.225, and area = 0.6.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在方程14.9的数学表示中，我们将*F*[air]视为一个单变量的函数。参数*C*、*ρ*和*A*并没有显式列出，作为*F*[air]依赖的变量。像这样省略参数是物理学中的标准做法，但从某种意义上讲，这也是一种符号滥用。在Haskell符号中，我们必须包括空气阻力所依赖的所有变量。我们首先列出这三个参数，再列出`Velocity`，这样表达式`fAir
    1 1.225 0.6`就是一个完全合法的函数，只接受速度作为输入。函数`fAir 1 1.225 0.6`已经选择了阻力=1，密度=1.225，面积=0.6。
- en: With this brief foray into air resistance, and particularly the development
    of Equation 14.9, we’re now ready to look at Newton’s second law in the case where
    forces on our object depend only on its velocity.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次简要的空气阻力探讨，尤其是方程14.9的发展，我们现在准备好探讨牛顿第二定律，考虑物体上的力仅依赖于其速度的情况。
- en: Second Law with Forces That Depend Only on Velocity
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只依赖于速度的力的第二定律
- en: The next situation for Newton’s second law is when the net force depends on
    velocity but not on time or position. What we really mean here is that the forces
    do not depend *explicitly* on time. Velocity is a function that depends on time,
    and forces are allowed to depend on the velocity in this section, so there is
    a sense in which the forces depend on time. The constraint in this section is
    that the forces can depend on time *only through the velocity*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿第二定律的下一个情况是净力依赖于速度，而不依赖于时间或位置。我们在这里的真正意思是力并不*显式地*依赖于时间。速度是一个依赖于时间的函数，而力在本节中可以依赖于速度，因此某种意义上力依赖于时间。本节的约束是力只能通过速度来依赖时间。
- en: The force functions may depend only on one variable, the velocity. We use ![Image](Images/e0221-01.jpg)
    to denote the *j*th force function of one variable that gives force when supplied
    with velocity and we use ![Image](Images/e0221-02.jpg) to denote the function
    of one variable that gives net force when supplied with velocity.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 力函数可能只依赖于一个变量，即速度。我们使用 ![Image](Images/e0221-01.jpg) 来表示一个变量的 *j* 号力函数，它在给定速度时提供力；我们使用
    ![Image](Images/e0221-02.jpg) 来表示一个变量的函数，它在给定速度时提供净力。
- en: '![Image](Images/221equ01.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/221equ01.jpg)'
- en: We use *v*[0] as a local variable for velocity (type `R`) rather than *v* in
    this section because we want *v* to stand for the velocity function of our object
    (type `R -> R`).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用 *v*[0] 作为速度的局部变量（类型 `R`），而不是 *v*，因为我们希望 *v* 代表物体的速度函数（类型 `R -> R`）。
- en: '[Figure 14-6](ch14.xhtml#ch14fig6) shows a schematic diagram for Newton’s second
    law with forces that depend only on velocity.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-6](ch14.xhtml#ch14fig6)展示了一个牛顿第二定律的示意图，其中力仅依赖于速度。'
- en: '![Image](Images/221fig01.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/221fig01.jpg)'
- en: '*Figure 14-6: Newton’s second law with forces that depend only on velocity*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-6：牛顿第二定律与仅依赖于速度的力*'
- en: This diagram, unlike previous diagrams, contains a loop. The velocity produced
    by the integrator of acceleration serves as the input to the net force function.
    The loop in the diagram indicates that Newton’s second law produces a differential
    equation. Because the loop contains one integrator, we get a first-order differential
    equation. A differential equation is a more difficult mathematical problem than
    a mere integral or antiderivative, as we had when forces depended only on time.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 该图与之前的图不同，包含了一个闭环。由加速度积分器产生的速度作为净力函数的输入。图中的闭环表明，牛顿第二定律产生了一个微分方程。由于闭环包含一个积分器，我们得到了一个一阶微分方程。微分方程比单纯的积分或反导数更难求解，正如当力只依赖于时间时的情况。
- en: 'Newton’s second law is given by the following equation:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿第二定律由以下方程给出：
- en: '![Image](Images/221equ02.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/221equ02.jpg)'
- en: The information this equation represents is the same as the information in the
    schematic diagram of [Figure 14-6](ch14.xhtml#ch14fig6). The equation describes
    how the rate of change of velocity depends on velocity itself through the forces
    that act on the object. The function `newtonSecondV`, presented next, is yet a
    third way to express Newton’s second law; this function returns the rate of change
    of velocity when given the current value of velocity along with the forces that
    act on the object.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 该方程所表示的信息与[图14-6](ch14.xhtml#ch14fig6)的示意图中的信息相同。该方程描述了速度的变化率如何通过作用在物体上的力依赖于速度本身。接下来的
    `newtonSecondV` 函数是表达牛顿第二定律的第三种方式；当给定当前的速度值和作用于物体的力时，该函数返回速度的变化率。
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can integrate the acceleration to obtain the velocity.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对加速度进行积分以获得速度。
- en: '![Image](Images/222equ01.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/222equ01.jpg)'
- en: Unlike the case with time-dependent forces, we cannot simply perform the integral
    here because the velocity function we are trying to find appears under the integral.
    How to proceed?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与时间依赖力的情况不同，在这里我们不能简单地进行积分，因为我们试图找到的速度函数出现在积分下方。该如何进行呢？
- en: To solve the differential equation, Equation 14.10, we will discretize time,
    which is something we have been doing with our numerical derivatives and integrals
    when we chose a time step. As long as our time step *Δt* is smaller than any important
    time scales in the situation we are addressing, the slope of the line connecting
    points (*t*, *v*(*t*)) and (*t* + Δ*t*, *v*(*t* + *Δt*)) will be approximately
    equal to the derivative of velocity at time *t*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解这个微分方程（方程 14.10），我们将对时间进行离散化，这实际上就是我们在选择时间步长时，所做的数值导数和积分处理。只要我们的时间步长*Δt*小于所处理问题中的任何重要时间尺度，连接点(*t*,
    *v*(*t*))和(*t* + Δ*t*, *v*(*t* + *Δt*))的直线的斜率就大致等于时间*t*时速度的导数。
- en: '![Image](Images/222equ02.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/222equ02.jpg)'
- en: Rearranging this equation leads to the *Euler method* for solving a first-order
    differential equation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 重新排列这个方程式可以得到求解一阶微分方程的*欧拉方法*。
- en: '![Image](Images/222equ03.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/222equ03.jpg)'
- en: The Euler method approximates the velocity at *t* + *Δ t* by the sum of the
    velocity at *t* and the product of the derivative at *t* with the time step *Δt*.
    The Euler method gives a way to find velocity at a later time from velocity at
    an earlier time if we know the derivative of velocity at the earlier time.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉方法通过将时间*t*的速度与导数在*t*时的乘积，再加上时间步长*Δt*，来近似计算*t* + *Δt*时的速度。欧拉方法提供了一种方法，可以从已知时刻的速度和导数，推算出稍后时刻的速度。
- en: '[Figure 14-7](ch14.xhtml#ch14fig7) pictorially describes the Euler method for
    solving Newton’s second law.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-7](ch14.xhtml#ch14fig7)以图示方式描述了欧拉方法解决牛顿第二定律的问题。'
- en: '![Image](Images/223fig01.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/223fig01.jpg)'
- en: '*Figure 14-7: Euler method for Newton’s second law in one dimension, for the
    special case in which net force depends only on velocity*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-7：在一维情况下，欧拉方法应用于牛顿第二定律，特殊情况为净力仅依赖于速度*'
- en: The diagram shows how data is acted on by pure functions to compute the velocity
    of the object at different times. Because the diagram employs only pure functions
    (functions that do nothing but return an output from inputs and unchanging global
    values), we refer to this as a *functional diagram*. Whereas the schematic diagram
    in [Figure 14-6](ch14.xhtml#ch14fig6) presents time as continuous, this diagram
    shows time as discrete. And whereas the schematic diagram has wires with values
    that are continuously changing in time, the functional diagram has wires with
    values that do not change. Different points in time have different wires in the
    functional diagram. While a schematic diagram may contain the stateful integrator
    from [Figure 6-5](ch06.xhtml#ch6fig5), a functional diagram uncoils and replaces
    the integrator with a discrete, functional model like the one in [Figure 6-7](ch06.xhtml#ch6fig7).
    We can see from [Figure 14-7](ch14.xhtml#ch14fig7) that the same set of computations
    occurs at each time step to produce a new velocity from an old velocity. We call
    the set of computations that occurs at each time step the *velocity-update function*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了数据如何通过纯函数作用来计算物体在不同时间的速度。因为该图仅使用纯函数（仅返回输出结果的函数，且不修改任何输入或全局值），我们称之为*函数图*。而[图
    14-6](ch14.xhtml#ch14fig6)中的示意图将时间表示为连续的，这个图则将时间表示为离散的。示意图中的电线值随时间连续变化，而函数图中的电线值保持不变。在函数图中，不同的时间点对应不同的电线。尽管示意图可能包含[图
    6-5](ch06.xhtml#ch6fig5)中的带状态积分器，但函数图则展开并用离散的函数模型替代积分器，如[图 6-7](ch06.xhtml#ch6fig7)所示。从[图
    14-7](ch14.xhtml#ch14fig7)中可以看出，每个时间步都会执行相同的一组计算，用新的速度值替换旧的速度值。我们称每个时间步执行的计算集合为*速度更新函数*。
- en: '[Figure 14-8](ch14.xhtml#ch14fig8) shows the velocity-update function, which
    is based on the application of the Euler method to one small time step.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-8](ch14.xhtml#ch14fig8)展示了速度更新函数，该函数是欧拉方法应用于一个小时间步长的结果。'
- en: '![Image](Images/224fig01.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/224fig01.jpg)'
- en: '*Figure 14-8: Velocity-update function used in the Euler method for solving
    Newton’s second law with forces that depend only on velocity*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-8：用于求解仅依赖于速度的牛顿第二定律的欧拉方法中的速度更新函数*'
- en: '[Figure 14-8](ch14.xhtml#ch14fig8) shows a functional diagram for velocity
    update, visually describing how velocity at *t* + Δ*t* is computed from velocity
    at *t* and the forces.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-8](ch14.xhtml#ch14fig8)展示了一个速度更新的函数图，直观地描述了如何从时间*t*的速度和力，计算出时间*t* + Δ*t*时的速度。'
- en: 'Here is the velocity-update equation showing how a new velocity is obtained
    from an old velocity:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是速度更新方程，展示了如何从旧的速度获得新的速度：
- en: '![Image](Images/224equ01.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/224equ01.jpg)'
- en: Lastly, we have the Haskell function `updateVelocity`, which advances the value
    of the velocity by one time step.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 Haskell 函数`updateVelocity`，它将速度的值推进一个时间步。
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The functional diagram in [Figure 14-8](ch14.xhtml#ch14fig8), the velocity-update
    equation (Equation 14.12), and the function `updateVelocity` express the same
    information in different forms, namely how to take one step in time with the Euler
    method.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-8](ch14.xhtml#ch14fig8)中的功能图、速度更新方程（方程 14.12）和函数`updateVelocity`以不同的形式表达相同的信息，即如何使用欧拉方法进行一步时间推进。'
- en: Now we want to write a function `velocityFv`, similar to `velocityCF` and `velocityFt`,
    but for the case of forces that depend on velocity. To think of `updateVelocity`
    as a function that takes `Velocity` as input and gives `Velocity` as output, we
    want to think of the time step, mass, and list of force functions as parameters.
    The function `updateVelocity dt m fs` has type `Velocity -> Velocity` and plays
    the role of the iterable function `f` in [Figure 6-4](ch06.xhtml#ch6fig4) on [page
    203](part02.xhtml#page_203).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想写一个函数`velocityFv`，类似于`velocityCF`和`velocityFt`，但用于依赖于速度的力的情况。将`updateVelocity`看作一个输入为`Velocity`，输出为`Velocity`的函数时，我们希望将时间步长、质量和力函数列表作为参数。函数`updateVelocity
    dt m fs`的类型是`Velocity -> Velocity`，它在[图 6-4](ch06.xhtml#ch6fig4)（第 203 页）中扮演着可迭代函数`f`的角色。
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We define a local variable `numSteps` to be the number of time steps we need
    to take to get as close as possible to the desired time `t`. We iterate the function
    `updateVelocity dt m fs`, starting at the initial velocity `v0`, and then select
    the single value of velocity from this infinite list that is closest to the desired
    time.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个局部变量`numSteps`，表示我们需要的时间步数，以尽可能接近目标时间`t`。我们从初始速度`v0`开始，迭代函数`updateVelocity
    dt m fs`，然后从这个无限列表中选择一个最接近目标时间的速度值。
- en: As an example of a situation with forces that depend only on velocity, let’s
    consider a bicycle rider heading north on a flat, level road. We’ll consider two
    forces in this situation. First, there is the northward force that the road exerts
    on the tires of the bicycle because the rider is working the pedals. Let us call
    this force *F*[rider] (it is directly produced by the road on the bike, but it
    is indirectly produced by the rider), and assume that this force is a constant
    100 N. Second, there is the southward force of air resistance that impedes the
    northward progress of the rider, especially when she is traveling quickly. We’ll
    use the expression for air resistance that we developed in the previous section
    with Equation 14.9\. The net force is
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个力只依赖于速度的情况示例，假设一位自行车骑行者在一条平坦的水平路面上朝北骑行。我们在这种情况下考虑两个力。首先，是路面施加在自行车轮胎上的北向力，因为骑行者正在踩踏板。我们将这个力称为*F*[rider]（它是路面直接施加在自行车上的，但间接是由骑行者产生的），并假设这个力为恒定的
    100 N。其次，是阻碍骑行者北向前进的南向空气阻力，特别是当她快速行驶时。我们将使用上一节中推导的空气阻力表达式和方程 14.9。净力是
- en: '![Image](Images/225equ01.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/225equ01.jpg)'
- en: Let’s take the mass of the bike plus rider to be *m* = 70 kg. We’ll choose a
    drag coefficient of *C* = 2, take the density of air to be *ρ* = 1.225 kg/m³,
    and approximate the cross-sectional area of bike and rider to be 0.6 m². Starting
    from rest, our mission is to find the velocity of the bike as a function of time.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 设自行车加骑行者的质量为*m* = 70 kg。我们选择拖拽系数*C* = 2，假设空气密度为*ρ* = 1.225 kg/m³，并将自行车和骑行者的横截面积近似为
    0.6 m²。从静止开始，我们的任务是找出自行车的速度随时间变化的函数。
- en: Before we use our Haskell functions to investigate the motion of the bike, we’re
    going to show how to use the Euler method by hand.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用 Haskell 函数来研究自行车的运动之前，我们将展示如何手动使用欧拉方法。
- en: Euler Method by Hand
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 手动欧拉方法
- en: Let’s use the Euler method by hand to compute the first several values of velocity
    for the bike. The purpose in doing this is to get a clear understanding of what
    is happening in the Euler method, so the code we write will be meaningful and
    not just a formal representation of some abstract vague process. We choose a time
    step of 0.5 s. Our mission is to complete the following table. We can fill in
    all of the time values because they are simply spaced at 0.5 s intervals. The
    initial velocity is 0, so we fill that in as well.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们手动使用欧拉方法计算自行车的前几个速度值。这样做的目的是为了清楚理解欧拉方法中发生的事情，这样我们编写的代码才有意义，而不仅仅是某个抽象模糊过程的形式化表示。我们选择时间步长为0.5秒。我们的任务是完成以下表格。我们可以填入所有的时间值，因为它们只是以0.5秒的间隔进行排列。初始速度为0，所以我们也填入了这一点。
- en: '| **t (s)** | **v(t) (m/s)** |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **t (s)** | **v(t) (m/s)** |'
- en: '| --- | --- |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0.0 | 0.0000 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 0.0 | 0.0000 |'
- en: '| 0.5 |  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 0.5 |  |'
- en: '| 1.0 |  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 1.0 |  |'
- en: '| 1.5 |  |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 1.5 |  |'
- en: We will complete the table by using Equation 14.12 to update the velocity over
    and over again. To compute the velocity at 0.5 s, we choose *t* = 0 in Equation
    14.12.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过反复使用方程14.12更新速度，来完成表格。为了计算0.5秒时的速度，我们选择*t* = 0代入方程14.12。
- en: '![Image](Images/226equ01.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/226equ01.jpg)'
- en: We update the table with
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用以下内容更新表格：
- en: '| **t (s)** | **v(t) (m/s)** |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **t (s)** | **v(t) (m/s)** |'
- en: '| --- | --- |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0.0 | 0.0000 |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 0.0 | 0.0000 |'
- en: '| 0.5 | 0.7143 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 0.5 | 0.7143 |'
- en: '| 1.0 |  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 1.0 |  |'
- en: '| 1.5 |  |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 1.5 |  |'
- en: 'and then we calculate *v*(1.0 s) using Equation 14.12 with *t* = 0.5 s:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用方程14.12计算*v*(1.0 s)，其中*t* = 0.5 s：
- en: '![Image](Images/226equ02.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/226equ02.jpg)'
- en: We add this to the appropriate row of the table and continue.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此添加到表格的相应行中并继续。
- en: '![Image](Images/226equ03.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/226equ03.jpg)'
- en: 'The completed table looks like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的表格如下所示：
- en: '| **t (s)** | **v(t) (m/s)** |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| **t (s)** | **v(t) (m/s)** |'
- en: '| --- | --- |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0.0 | 0.0000 |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 0.0 | 0.0000 |'
- en: '| 0.5 | 0.7143 |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 0.5 | 0.7143 |'
- en: '| 1.0 | 1.4259 |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 1.0 | 1.4259 |'
- en: '| 1.5 | 2.1295 |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 1.5 | 2.1295 |'
- en: Euler Method in Haskell
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Haskell中的欧拉方法
- en: 'Now we’ll use the `velocityFv` function to calculate velocity for the bike.
    Here is a velocity function for the bike with a time step of 1 s:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用`velocityFv`函数来计算自行车的速度。以下是一个自行车的速度函数，时间步长为1秒：
- en: '[PRE21]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The higher-order function `const` can be used to make a constant function. The
    function `const 100` takes one input, ignores it, and returns 100 as output. It
    is equivalent to the anonymous function `\_ -> 100`. We’re using it here to represent
    the constant force of 100 N.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数`const`可以用来创建常量函数。函数`const 100`接受一个输入，忽略它，并返回100作为输出。它等同于匿名函数`\_ -> 100`。我们在这里使用它来表示常量力100
    N。
- en: 'Notice the data that must be supplied to solve the bike problem. We provide
    the 70-kg mass, the 0 m/s initial velocity of the bike, and the two forces: `const
    100`, a constant force of 100 N, and `fAir 2 1.225 0.6`, which is the force of
    air resistance with a drag coefficient of 2, an air density of 1.225 kg/m³, and
    a cross-sectional area of 0.6 m².'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，解决自行车问题时必须提供的数据。我们提供了70公斤的质量、自行车的初始速度为0 m/s，以及两个力：`const 100`，一个100 N的常量力，和`fAir
    2 1.225 0.6`，这是一个空气阻力的力，具有2的阻力系数，1.225 kg/m³的空气密度和0.6 m²的横截面积。
- en: 'Here is the code to produce a graph of velocity versus time:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成速度与时间图表的代码：
- en: '[PRE22]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code plots the `bikeVelocity` function, including a title and axis labels,
    and makes a PNG file that can be included in another document. [Figure 14-9](ch14.xhtml#ch14fig9)
    contains the graph itself.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码绘制了`bikeVelocity`函数，包括标题和坐标轴标签，并生成一个PNG文件， 可以在其他文档中使用。[图14-9](ch14.xhtml#ch14fig9)包含了该图表。
- en: '![Image](Images/228fig01.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/228fig01.jpg)'
- en: '*Figure 14-9: Bike velocity as a function of time. The stair-stepping look
    can be fixed and is discussed in the text.*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-9：自行车速度随时间变化的图。台阶状的外观可以修复，并在文中讨论。*'
- en: 'A phenomenon occurs in [Figure 14-9](ch14.xhtml#ch14fig9) that does not occur
    in constant acceleration situations: the establishment of a terminal velocity.
    After 20 seconds or so, the forward force of the road (from the pedaling) matches
    the backward force of the air. At this point we have no net force (or a very small
    net force), and the velocity stays at the terminal velocity.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图14-9](ch14.xhtml#ch14fig9)中出现了一种现象，这在恒定加速度情况下不会发生：终端速度的建立。在大约20秒后，路面的前向力（来自踏车）与空气的反向力相匹配。此时我们没有净力（或者只有一个非常小的净力），速度保持在终端速度。
- en: Why the stair-stepping look to [Figure 14-9](ch14.xhtml#ch14fig9)? We used a
    time step of one second to do the calculation of the velocity function `bikeVelocity`,
    but then we asked the `plotFunc` function to give us a plot of that function every
    half a second. If we want a smooth plot, we have a couple of options. The simplest
    would be to ask for a plot with time values spaced at least one second apart.
    Alternatively, we could calculate the `bikeVelocity` function using a smaller
    time step. In any case, we shouldn’t ask for more resolution in the graph than
    we asked for in the function we are graphing.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么[图 14-9](ch14.xhtml#ch14fig9)看起来像台阶状？我们使用了一秒钟的时间步长来计算速度函数`bikeVelocity`，但接着我们要求`plotFunc`函数每半秒给出该函数的图形。如果我们想要平滑的图形，我们有几个选择。最简单的方式是要求时间值间隔至少一秒的图形。或者，我们可以使用更小的时间步长来计算`bikeVelocity`函数。无论如何，我们不应要求图表的分辨率超过我们在绘制函数时所要求的分辨率。
- en: With the functions `velocityFv` and `positionFv`, the latter of which you are
    asked to write in Exercise 14.4, we have general-purpose tools for solving any
    Newton’s second law type problem in one spatial dimension with forces that depend
    only on velocity. Before we turn to the case in which forces depend on both time
    and velocity, let’s take a moment to view what we’ve just done from a broader
    perspective.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`velocityFv`和`positionFv`这两个函数，其中后者是你在练习 14.4 中需要编写的，我们就有了通用工具来解决任何仅依赖于速度的单维度空间中的牛顿第二定律类型的问题。在我们转向力同时依赖时间和速度的情况之前，让我们先从更广泛的视角看一下我们刚才所做的事情。
- en: The State of a Physical System
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 物理系统的状态
- en: A fruitful way to structure our thinking about Newton’s second law, and also
    later about the Maxwell equations, revolves around the concept of the *state*
    of a physical system, which is the collection of information needed to say precisely
    what is going on with the system *at a particular instant of time*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 思考牛顿第二定律的一个富有成效的方式，以及后续的麦克斯韦方程，围绕着物理系统的*状态*这一概念展开，状态是指为了精确描述系统在*某一特定时刻*发生的情况所需的信息的集合。
- en: The state represents the current “state of affairs” of the system, containing
    enough information that future prediction can be based on the current state instead
    of past information about the system. The state evolves in time, changing according
    to some rule.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 状态代表系统当前的“事态”，包含足够的信息，使得未来的预测可以基于当前状态，而不是系统的过去信息。状态随时间变化，并根据某种规则改变。
- en: 'Given a physical system that we wish to understand, the state-based paradigm
    suggests the following conceptual division:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个我们希望理解的物理系统，基于状态的范式提出了以下概念性划分：
- en: What information is required to specify the state of the system?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要指定系统的状态，需要哪些信息？
- en: What is the state at some initial time?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在某个初始时刻，系统的状态是什么？
- en: By what rule does the state change with time?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 状态随时间变化的规则是什么？
- en: When we treated Newton’s second law with constant forces and forces that depend
    only on time, we did not use a state-based method because we did not need one.
    In those cases, we could use algebra or integration to find how the position and
    velocity of our object changed in time. When we looked at forces that depend on
    velocity, we had a schematic diagram with a loop that corresponded to a differential
    equation, shown in [Figure 14-6](ch14.xhtml#ch14fig6). The state-based method
    is particularly useful for differential equations.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理牛顿第二定律时，若力是常量或者仅依赖于时间时，我们没有使用基于状态的方法，因为我们不需要。在这些情况下，我们可以使用代数或积分来找出物体在时间上位置和速度的变化。当我们查看依赖于速度的力时，我们得到了一个与微分方程相对应的框图，如[图
    14-6](ch14.xhtml#ch14fig6)所示。基于状态的方法对于微分方程特别有用。
- en: There are three things to notice about [Figure 14-6](ch14.xhtml#ch14fig6) that
    relate to the state-based method. First, notice that there is one integrator in
    the loop and that this integrator holds the value of velocity as state. Second,
    notice that the differential equation, Equation 14.10, gives an expression for
    the rate of change of velocity. Lastly, notice that the forces depend on velocity.
    For these three reasons, in the case where forces depend only on velocity, the
    state of the object consists of the velocity of the object.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有三点需要注意与[图 14-6](ch14.xhtml#ch14fig6)相关的基于状态的方法。首先，注意回路中有一个积分器，且该积分器将速度作为状态值。其次，注意微分方程（方程
    14.10）给出了速度变化率的表达式。最后，注意力的大小依赖于速度。由于这三点，在力仅依赖于速度的情况下，物体的状态由物体的速度组成。
- en: In general, the answer to question 1 is a data type. The state of an object
    experiencing forces that depend only on the object’s velocity is a value of the
    data type `Velocity`. In the next section, where forces depend on time and velocity,
    the data type we will use for state is the pair `(Time,Velocity)`. As we consider
    more complex physical situations, the data type we use to hold the state of our
    physical system will contain more information.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，问题1的答案是一个数据类型。经历仅依赖于物体速度的力的物体的状态是`Velocity`数据类型的一个值。在接下来的章节中，当力依赖于时间和速度时，我们将使用数据类型`(Time,Velocity)`来表示状态。随着我们考虑更复杂的物理情境，我们用来表示物理系统状态的数据类型将包含更多的信息。
- en: Question 2 above is, in some sense, the smallest question. It may even be possible
    to do some analysis without an answer to question 2\. But if we wish to know properties
    of a system at a later time, then we wish to know the state at a later time, and
    this typically requires knowing the state at some earlier time. The answer to
    question 2 is a value of the data type from question 1.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 上述问题2在某种意义上是最小的问题。即使没有问题2的答案，也可能进行一些分析。但是，如果我们希望知道系统在某一未来时刻的性质，那么我们希望知道该时刻的状态，这通常需要知道某个早期时刻的状态。问题2的答案是问题1中数据类型的一个值。
- en: Question 3 requires a physical theory to answer. In the case of mechanics, Newton’s
    second law gives the rule by which the state changes in time.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 问题3需要物理理论来回答。在力学中，牛顿第二定律提供了描述状态随时间变化的规律。
- en: Let’s see how the state-based method applies in the case where the forces on
    an object depend only on time and the velocity of the object.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看基于状态的方法如何应用于力仅依赖于物体的时间和速度的情况。
- en: Second Law with Forces That Depend on Time and Velocity
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖于时间和速度的力的第二定律
- en: The next situation for Newton’s second law is when the forces depend on both
    time and velocity but not on position. The force functions depend on two variables,
    time and velocity. We use ![Image](Images/e0230-01.jpg) to denote the *j*th function
    of two variables that gives a force when supplied with time and velocity, and
    we use ![Image](Images/e0230-02.jpg) to denote the function of two variables that
    gives net force when supplied with time and velocity.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿第二定律的下一个情况是力依赖于时间和速度，但不依赖于位置。力的函数依赖于两个变量：时间和速度。我们用![Image](Images/e0230-01.jpg)表示当给定时间和速度时产生力的*第j*个函数，用![Image](Images/e0230-02.jpg)表示当给定时间和速度时产生合力的两个变量的函数。
- en: '![Image](Images/230equ01.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/230equ01.jpg)'
- en: '[Figure 14-10](ch14.xhtml#ch14fig10) shows a schematic diagram for Newton’s
    second law with forces that depend on time and velocity.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-10](ch14.xhtml#ch14fig10)展示了牛顿第二定律的示意图，其中的力依赖于时间和速度。'
- en: '![Image](Images/230fig01.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/230fig01.jpg)'
- en: '*Figure 14-10: Newton’s second law with forces that depend on time and velocity*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-10：牛顿第二定律，力依赖于时间和速度*'
- en: The schematic diagram contains a loop, so Newton’s second law is a differential
    equation, given in Equation 14.14.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 示意图包含一个回路，因此牛顿第二定律是一个微分方程，如方程14.14所示。
- en: '![Image](Images/230equ02.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/230equ02.jpg)'
- en: Notice that there is one integrator in the loop in [Figure 14-10](ch14.xhtml#ch14fig10),
    which holds the value of velocity as state. There is a way to solve this differential
    equation using only velocity as the state of the object. However, since the rate
    of change of velocity in Equation 14.14 depends on both time and velocity (because
    the forces depend on time and velocity), the state-based method is simpler to
    apply if we allow both time and velocity to be *state variables*. This is to say
    that the data type we will use for state is `(Time,Velocity)`. The difference
    between Equation 14.10, which expresses Newton’s second law with forces that depend
    only on velocity, and Equation 14.14, which expresses Newton’s second law with
    forces that depend on time and/or velocity, is simply that we need to know the
    current value of time in the latter case but not in the former. Including time
    in the state `(Time,Velocity)` is a simple way to gain convenient access to the
    current time.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在[图14-10](ch14.xhtml#ch14fig10)中的循环里有一个积分器，它保持着速度作为状态值。有一种方法可以仅使用速度作为物体的状态来求解这个微分方程。然而，由于方程14.14中的速度变化率同时依赖于时间和速度（因为力依赖于时间和速度），如果我们将时间和速度都作为*状态变量*，基于状态的方法会更容易应用。这就是说，我们将用于状态的数据类型是`(Time,Velocity)`。方程14.10表达的牛顿第二定律，力仅依赖于速度，而方程14.14表达的牛顿第二定律，力依赖于时间和/或速度，二者的区别在于，后者需要知道当前的时间值，而前者则不需要。在状态`(Time,Velocity)`中包含时间，是方便获取当前时间的一种简单方法。
- en: Which quantities deserve to be called state variables? Say I have a particle
    in space acted on by a known (time-independent) force law. The state variables
    are the position and velocity because we can calculate the position and velocity
    at the next time instant from them. Why is acceleration not a state variable?
    To use the terminology of earlier sections in this chapter, state variables are
    numbers that identify a particular solution to the differential equation—they
    are the initial values that convert integrals into antiderivatives. Time is usually
    not considered a state variable, but taking it as one makes it easier to think
    about time-dependent forces. Readers interested in a more in-depth discussion
    of state variables and their uses are encouraged to see [**[16](bib.xhtml#bib16)**]
    and [**[17](bib.xhtml#bib17)** ].
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些量应该被称为状态变量？假设我有一个粒子在空间中，受到已知（与时间无关）力法则的作用。状态变量是位置和速度，因为我们可以从这些变量计算出下一个时间点的位置和速度。为什么加速度不是状态变量？使用本章前面部分的术语，状态变量是用来确定微分方程特定解的数字——它们是将积分转化为反导数的初始值。时间通常不被视为状态变量，但将其视为状态变量可以更容易地思考时间依赖的力。对于有兴趣深入讨论状态变量及其用途的读者，建议参阅[**[16](bib.xhtml#bib16)**]和[**[17](bib.xhtml#bib17)**]。
- en: The Haskell function `newtonSecondTV`, shown below, expresses Newton’s second
    law in the case where forces depend on time and velocity.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示的Haskell函数`newtonSecondTV`表达了牛顿第二定律，其中力依赖于时间和速度。
- en: '[PRE23]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Given the mass of an object and a list of forces that act on the object, now
    expressed as functions of the state `(Time,Velocity)`, `newtonSecondTV` gives
    instructions for computing the time derivatives of the state variables from the
    state variables themselves. The return type `(R,R)` is meant to stand for time
    derivative of time, which is always the dimensionless number 1, and time derivative
    of velocity, which is acceleration. The acceleration is computed from Newton’s
    second law by finding the net force and dividing by the mass.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 给定物体的质量以及作用于物体的力列表，现在这些力被表示为状态`(Time,Velocity)`的函数，`newtonSecondTV`给出了从状态变量本身计算状态变量时间导数的指令。返回类型`(R,R)`表示时间的时间导数，它始终是无量纲的数字1，以及速度的时间导数，即加速度。加速度是通过牛顿第二定律计算的，方法是求出净力并除以质量。
- en: To solve Equation 14.14, we will discretize time and use the Euler method. We’ll
    continue to use Equation 14.11 for the Euler method. [Figure 14-11](ch14.xhtml#ch14fig11)
    pictorially describes the Euler method for solving Newton’s second law when forces
    depend on time and/or velocity.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决方程14.14，我们将离散化时间并使用欧拉方法。我们将继续使用方程14.11来进行欧拉方法。[图14-11](ch14.xhtml#ch14fig11)以图示形式描述了当力依赖于时间和/或速度时，使用欧拉方法解决牛顿第二定律的问题。
- en: '![Image](Images/232fig01.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/232fig01.jpg)'
- en: '*Figure 14-11: Euler method for Newton’s second law in one dimension, for the
    special case in which net force depends only on time and/or velocity*'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-11：欧拉方法在一维中解决牛顿第二定律的情况，针对净力仅依赖于时间和/或速度的特殊情况*'
- en: The diagram shows how functions act on the state variables at one point in time
    to compute the state variables at the next point in time. The same set of computations
    reoccurs at each time step to produce a new state from an old state. We call the
    set of computations that occurs at each time step the *state-update function*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图示展示了函数如何在某一时刻作用于状态变量，以计算下一个时刻的状态变量。相同的计算集合在每个时间步都会重复，以从旧的状态产生新的状态。我们称每个时间步发生的计算集合为*状态更新函数*。
- en: The state-update function is shown pictorially in [Figure 14-12](ch14.xhtml#ch14fig12).
    The figure shows a functional diagram for state update, visually describing how
    time and velocity at *t* + Δ*t* are computed from time and velocity at *t*, given
    the force functions.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 状态更新函数在[图14-12](ch14.xhtml#ch14fig12)中以图示方式展示。图示描述了如何根据力函数，从时刻*t*的时间和速度计算出时刻*t*
    + Δ*t*的时间和速度。
- en: '![Image](Images/232fig02.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/232fig02.jpg)'
- en: '*Figure 14-12: Euler method update for Newton’s second law with forces that
    depend only on time and velocity*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-12：欧拉法更新，适用于仅依赖于时间和速度的牛顿第二定律中的力*'
- en: 'Here are the state-update equations showing how the new state variables are
    obtained from the old state variables:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是状态更新方程，展示了如何从旧的状态变量获得新的状态变量：
- en: '![Image](Images/233equ01.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/233equ01.jpg)'
- en: 'Equations 14.15 and 14.16 are state-update equations for an object exposed
    to forces that depend on time and velocity. The state-update equations tell us
    how the state variables time and velocity must be updated to advance to the next
    time step. The time update in Equation 14.15 is easy: we just add *Δt* to the
    old time to get the new time. To update the velocity in Equation 14.16, we compute
    an acceleration, multiply by a time step to get a change in velocity, and add
    that change to the old velocity. Applying these state-update equations is how
    we carry out the Euler method for solving a differential equation. This state-update
    procedure is the main tool we will use to solve problems in Newtonian mechanics.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 方程14.15和14.16是适用于受到依赖于时间和速度的力作用的物体的状态更新方程。状态更新方程告诉我们如何更新状态变量时间和速度，以推进到下一个时间步。方程14.15中的时间更新很简单：我们只需将*Δt*加到旧时间上即可得到新时间。要更新方程14.16中的速度，我们需要计算加速度，将其与时间步相乘得到速度的变化，再将此变化加到旧的速度上。应用这些状态更新方程是我们用欧拉法解微分方程的方式。这一状态更新过程是我们解决牛顿力学问题的主要工具。
- en: The following Haskell function `updateTV`, named because it updates both time
    and velocity, advances the value of the state by one time step.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Haskell函数`updateTV`，因其同时更新时间和速度，所以命名为此，它将状态值推进一个时间步。
- en: '[PRE24]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The function `updateTV` takes a few parameters and produces a function with
    type `(Time,Velocity) -> (Time,Velocity)`. The third input of `updateTV`, named
    `fs` with type `[(Time,Velocity) -> Force]`, could have been an input with type
    `[Time -> Velocity -> Force]`; it’s a matter of style, and either choice will
    work just fine. Here I chose the former, as time and velocity are already paired
    in the function output.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`updateTV`接受几个参数，生成类型为`(Time,Velocity) -> (Time,Velocity)`的函数。`updateTV`的第三个输入，命名为`fs`，类型为`[(Time,Velocity)
    -> Force]`，本可以是类型为`[Time -> Velocity -> Force]`的输入；这只是风格问题，选择任何一个都能正常工作。这里我选择了前者，因为时间和速度已经在函数输出中配对。
- en: The time-velocity pair we are passing around in this function represents the
    state of the object to which we are applying Newton’s second law. The function
    `updateTV` is then an example of a state-update function. In an earlier section,
    when forces depended only on velocity, the velocity alone acted as state, and
    the function `updateVelocity` was the appropriate state-update function.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此函数中传递的时间-速度对表示的是我们应用牛顿第二定律的物体的状态。函数`updateTV`是一个状态更新函数的示例。在前面的章节中，当力只依赖于速度时，速度本身作为状态，而函数`updateVelocity`则是适当的状态更新函数。
- en: The functional diagram in [Figure 14-12](ch14.xhtml#ch14fig12), Equations 14.15
    and 14.16, and the function `updateTV` express the same information in different
    forms, namely how to take one step in time with the Euler method.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-12](ch14.xhtml#ch14fig12)、方程14.15和14.16以及函数`updateTV`以不同形式表达了相同的信息，即如何通过欧拉法在时间上迈出一步。'
- en: Depending on what we want to calculate, there are two things we might do with
    the `updateTV` function, corresponding to two types of representation of the time-velocity
    data. First, we may wish to produce a list of time-velocity pairs. Second, we
    may wish to produce velocity as a function of time. We’ll develop functions for
    these two purposes in the next two subsections.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们想要计算的内容，`updateTV`函数有两种使用方式，对应于时间-速度数据的两种表示方式。首先，我们可能希望生成一个时间-速度对的列表。其次，我们可能希望生成时间作为速度的函数。我们将在接下来的两个小节中为这两种目的开发函数。
- en: 'Method 1: Produce a List of States'
  id: totrans-279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法1：生成状态列表
- en: A list of time-velocity pairs can be regarded as a solution to a Newton’s second
    law problem with forces that depend on time and velocity because a time-velocity
    pair gives the state. The list of states contains a time-velocity pair for each
    time that has been probed by the Euler method in [Figure 14-11](ch14.xhtml#ch14fig11).
    The function `statesTV` produces a list of time-velocity pairs when given a time
    step, a mass, an initial state, and a list of force functions.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 时间-速度对的列表可以视为一个牛顿第二定律问题的解决方案，其中力依赖于时间和速度，因为时间-速度对给出了状态。状态列表包含了每个被欧拉方法探测的时间对应的时间-速度对，见[图14-11](ch14.xhtml#ch14fig11)。函数`statesTV`在给定时间步长、质量、初始状态和力函数列表时，产生一个时间-速度对的列表。
- en: '[PRE25]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We use `iterate` to achieve the repeated composition in [Figure 14-11](ch14.xhtml#ch14fig11).
    But which function do we want to iterate? It’s not simply `updateTV` because `updateTV`
    takes three parameters as input before the time-velocity pair. The function we
    iterate must have type `a -> a`, or in this case `(Time,Velocity) -> (Time,Velocity)`.
    The solution is to give `updateTV` its first three parameters to form the function
    we send to `iterate`. The function we want to iterate is `updateTV dt m fs`, starting
    with the initial time-velocity pair `tv0`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`iterate`来实现[图14-11](ch14.xhtml#ch14fig11)中的重复组合。但我们想要迭代哪个函数呢？它不只是`updateTV`，因为`updateTV`需要三个参数作为输入，才能得到时间-速度对。我们要迭代的函数必须是`a
    -> a`类型，或者在这个例子中是`(Time,Velocity) -> (Time,Velocity)`类型。解决方案是给`updateTV`提供它的前三个参数，形成我们传递给`iterate`的函数。我们想要迭代的函数是`updateTV
    dt m fs`，从初始的时间-速度对`tv0`开始。
- en: The function `statesTV` gives a general-purpose way of solving any Newton’s
    second law type problem in one spatial dimension with forces that depend only
    on time and velocity. By a solution, we mean an infinite list of states (time-velocity
    pairs) of the object, spaced one time step apart from each other.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`statesTV`提供了一种通用的方法来解决任何牛顿第二定律类型的问题，适用于单一空间维度且力仅依赖于时间和速度。所谓的解决方案是指一个无穷长的状态列表（时间-速度对），这些状态之间的时间步长间隔是均匀的。
- en: 'Method 2: Produce a Velocity Function'
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法2：生成速度函数
- en: Now we want to write a function, `velocityFtv`, that is similar to `velocityCF`,
    `velocityFt`, and `velocityFv`, but for the case of forces that depend on time
    and velocity. We’ll use the infinite list produced by `statesTV`, picking out
    the particular time-velocity pair that comes closest to our desired time and using
    the Prelude function `snd` to return the velocity, unpaired from the time.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想编写一个函数`velocityFtv`，它类似于`velocityCF`、`velocityFt`和`velocityFv`，但适用于力依赖于时间和速度的情况。我们将使用`statesTV`生成的无穷长列表，选出最接近我们期望时间的时间-速度对，并使用Prelude函数`snd`返回与时间分离的速度。
- en: '[PRE26]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With the functions `velocityFtv` and `positionFtv`, the latter of which you
    will be asked to write in Exercise 14.9, we have general-purpose ways of solving
    any Newton’s second law type problem in one spatial dimension with forces that
    depend only on time and velocity. Let’s now take a look at a situation that involves
    just such forces.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 通过函数`velocityFtv`和`positionFtv`，其中后者将在练习14.9中要求你编写，我们可以用通用的方法解决任何涉及时间和速度依赖的力的单一空间维度的牛顿第二定律问题。现在我们来看看一个涉及这种力的情况。
- en: 'Example: Pedaling and Coasting with Air Resistance'
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：骑行与风阻滑行
- en: As an example of a situation with forces that depend on time and velocity, let’s
    reconsider our child bicycle rider who is pedaling and coasting, but now in the
    presence of air resistance. We’ll consider two forces in this situation. First,
    there’s the time-dependent force *F*[pc](*t*) of pedaling from Equation 14.8\.
    Second, there’s the force of air resistance *F*[air](*v*[0]) that impedes the
    motion of the child, for which we’ll use Equation 14.9\. The net force is
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个依赖时间和速度的力的示例，让我们重新考虑我们的小孩自行车骑行者，他正在踩踏和滑行，但现在有了空气阻力。我们将考虑这种情况中的两个力。首先，存在来自方程14.8中描述的踩踏力
    *F*[pc](*t*)，这是一个时间相关的力。其次，存在空气阻力 *F*[air](*v*[0])，它阻碍孩子的运动，我们将使用方程14.9来描述这个力。净力是
- en: '![Image](Images/e0235-01.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/e0235-01.jpg)'
- en: The mass of the bike plus child is *m* = 20 kg. We’ll choose a drag coefficient
    of *C* = 2, take the density of air to be *ρ* = 1.225 kg/m³, and approximate the
    cross-sectional area of bike and rider to be 0.5 m². Starting from rest, our mission
    is to find the velocity of the bike as a function of time.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 自行车和孩子的总质量是*m* = 20 kg。我们选择拖曳系数*C* = 2，取空气密度*ρ* = 1.225 kg/m³，并将自行车和骑行者的横截面积近似为0.5
    m²。从静止开始，我们的任务是找到自行车速度随时间的变化函数。
- en: We update the velocity with Equation 14.16\. Before we use our Haskell functions
    to investigate the motion of the bike, we’ll show how to use the Euler method
    by hand.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用方程14.16来更新速度。在使用Haskell函数研究自行车运动之前，我们将展示如何手动使用欧拉方法。
- en: Euler Method by Hand
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 手动欧拉方法
- en: Let’s use the Euler method by hand to compute several values of velocity for
    the bike. Again, the purpose in doing the Euler method by hand is simply to get
    a clear picture of how the state variables get updated in the Euler method. We’ll
    pick a time step of 6 s, even though this is too big to get accurate results,
    as it is not small compared to relevant time scales, such as the 20-second cycle
    time. We choose a time step of 6 s so we can sample both pedaling and coasting
    over the first few time steps. Our mission is to complete the following table.
    We can fill in all of the time values because they are simply spaced at six-second
    intervals. The initial velocity is 0, so we’ll fill that in as well.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们手动使用欧拉方法来计算自行车的几个速度值。同样，手动进行欧拉方法的目的是清楚地了解在欧拉方法中如何更新状态变量。我们将选择6秒的时间步长，尽管这个时间步长对于获取准确结果来说太大，因为它相对于相关的时间尺度（如20秒的周期时间）并不小。我们选择6秒的时间步长是为了能够在前几个时间步长中同时采样踩踏和滑行。我们的任务是完成以下表格。我们可以填充所有的时间值，因为它们只是以六秒的间隔分布。初始速度是0，因此我们也将其填写。
- en: '| **t (s)** | **v(t) (m/s)** |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| **t (s)** | **v(t) (m/s)** |'
- en: '| --- | --- |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|     0 | 0.0000 |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '|     0 | 0.0000 |'
- en: '|     6 |  |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '|     6 |  |'
- en: '|   12 |  |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '|   12 |  |'
- en: '|   18 |  |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '|   18 |  |'
- en: The force of pedaling is either 10 N or 0 N, depending on the value of the time.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 踩踏的力要么是10 N，要么是0 N，取决于时间的值。
- en: '*F*[pc](0 s) = *F*[pc](6 s) = 10 N'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*F*[pc](0 s) = *F*[pc](6 s) = 10 N'
- en: '*F*[pc](12 s) = *F*[pc](18 s) = 0 N'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*F*[pc](12 s) = *F*[pc](18 s) = 0 N'
- en: 'Repeatedly applying Equation 14.16, we obtain the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 通过反复应用方程14.16，我们得到以下结果：
- en: '![Image](Images/236equ01.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/236equ01.jpg)'
- en: 'The completed table looks like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的表格如下所示：
- en: '| **t (s)** | **v(t) (m/s)** |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| **t (s)** | **v(t) (m/s)** |'
- en: '| --- | --- |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | 0.0000 |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0.0000 |'
- en: '| 6 | 3.0000 |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 3.0000 |'
- en: '| 12 | 4.3463 |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 4.3463 |'
- en: '| 18 | 0.8752 |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 0.8752 |'
- en: Let’s turn now to Haskell, using each of the two methods we discussed earlier.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向Haskell，使用我们之前讨论的两种方法。
- en: 'Method 1: Produce a List of States'
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法 1：生成状态列表
- en: Here we’ll use the function `statesTV` to produce an infinite list of velocity-time
    pairs called `pedalCoastAir` for the child on the bike.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用函数`statesTV`生成一个无限的速度-时间对列表，称为`pedalCoastAir`，用于描述孩子在自行车上的运动。
- en: '[PRE27]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice the data that must be supplied to solve this problem. We provide a 0.1-s
    time step, the 20-kg mass, an initial state consisting of 0 for the time and 0
    for the velocity, and the two forces, expressed here as anonymous functions. The
    function `pedalCoast` is a function only of time, so it cannot be listed directly
    as a force function because a force function for `statesTV` takes a time-velocity
    pair as input. The underscores are present because the pedaling function does
    not depend on the second item in the state, which happens to be velocity, and
    because air resistance does not depend on the first item in the state, which happens
    to be time.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意解决此问题所需提供的数据。我们提供了0.1秒的时间步长、20千克的质量、初始状态（时间为0，速度为0），以及以匿名函数形式表示的两个力。`pedalCoast`函数仅依赖于时间，因此不能直接列为力函数，因为`statesTV`的力函数需要时间-速度对作为输入。下划线的存在是因为蹬踏函数不依赖于状态中的第二项（即速度），而空气阻力也不依赖于状态中的第一项（即时间）。
- en: A list of pairs is something we can plot with the `plotPath` function from the
    `gnuplot` library, but we need to truncate the list to a finite list before plotting,
    or `plotPath` will hang while trying to finish calculating an infinite list. In
    `pedalCoastAirGraph` below, we use the `takeWhile` function to extract the states
    with times less than or equal to 100 seconds.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 一对对的列表是我们可以使用`gnuplot`库中的`plotPath`函数绘制的，但我们需要在绘图前截断列表为有限列表，否则`plotPath`会在尝试计算无限列表时挂起。在下面的`pedalCoastAirGraph`中，我们使用`takeWhile`函数提取时间小于或等于100秒的状态。
- en: '[PRE28]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code produces [Figure 14-13](ch14.xhtml#ch14fig13), which shows the velocity
    as a function of time for the child pedaling and coasting in the presence of air
    resistance.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成了[图14-13](ch14.xhtml#ch14fig13)，展示了孩子在空气阻力下蹬踏与滑行时，速度随时间变化的关系。
- en: '![Image](Images/237fig01.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/237fig01.jpg)'
- en: '*Figure 14-13: Pedaling and coasting with air resistance*'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-13：带有空气阻力的蹬踏与滑行*'
- en: As expected, the child’s speed increases during the pedaling intervals and decreases
    during the coasting intervals.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，孩子在蹬踏间隔期间速度增加，而在滑行间隔期间速度减小。
- en: 'Method 2: Produce a Velocity Function'
  id: totrans-324
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法二：生成速度函数
- en: Now let’s use the function `velocityFtv` to produce a velocity function for
    the child on the bike.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用函数`velocityFtv`为骑车的孩子生成一个速度函数。
- en: '[PRE29]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The data we give to `pedalCoastAir2` is the same data we gave to `pedalCoastAir`.
    Because `pedalCoastAir2` is a function `R -> R`, it can be plotted with the `plotFunc`
    function from the `gnuplot` package. It would produce the same graph as that in
    [Figure 14-13](ch14.xhtml#ch14fig13).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给`pedalCoastAir2`的数据与给`pedalCoastAir`的数据相同。由于`pedalCoastAir2`是一个`R -> R`函数，因此可以使用`gnuplot`包中的`plotFunc`函数进行绘图。它将生成与[图14-13](ch14.xhtml#ch14fig13)中相同的图形。
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter discussed Newton’s first law and introduced Newton’s second law
    in the context of one-dimensional motion. The chapter presented a sequence of
    increasingly sophisticated settings for Newton’s second law. Easiest among them
    is when the forces on an object are constant, that is, unchanging in time. Next
    is when the forces on an object depend only on time, in which case we can apply
    integration to find the velocity and the position of the object. Forces that depend
    on velocity, such as the air resistance introduced in this chapter, require that
    we solve a differential equation, which is a more complex task than integration.
    The chapter also introduced the Euler method for solving a first-order differential
    equation. The Euler method, along with Newton’s second law, provides a rule for
    updating the state of the object we are tracking, allowing us to predict its future
    motion. The choice of state variables, or physical quantities contained in the
    state, is determined by what the forces depend on. If forces depend only on velocity,
    then velocity alone can serve as the particle state. If forces depend on time
    and velocity, we use time and velocity as state variables.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了牛顿的第一定律，并在一维运动的背景下介绍了牛顿的第二定律。本章呈现了一系列越来越复杂的牛顿第二定律应用场景。其中最简单的是物体上的力是常量，即随时间不变。接下来是当物体上的力仅依赖于时间时，在这种情况下我们可以应用积分来找到物体的速度和位置。依赖于速度的力，比如本章介绍的空气阻力，要求我们解一个微分方程，这比积分更复杂。章节还介绍了欧拉方法来解一阶微分方程。欧拉方法与牛顿第二定律一起，为更新我们正在追踪的物体的状态提供了规则，使我们能够预测其未来的运动。状态变量或包含在状态中的物理量的选择由力的依赖关系决定。如果力仅依赖于速度，那么速度本身可以作为粒子的状态。如果力依赖于时间和速度，那么我们使用时间和速度作为状态变量。
- en: In the next chapter, we allow the forces to depend on position as well as time
    and velocity. This produces a second-order differential equation and requires
    that time, position, and velocity all be state variables.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们允许力依赖于位置以及时间和速度。这将产生一个二阶微分方程，并要求时间、位置和速度都作为状态变量。
- en: Exercises
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '**Exercise 14.1.** Write a function `velocityCF''` that does the same thing
    and has the same type signature as `velocityCF`, but in which the time `t :: Time`
    is listed explicitly on the left of the equal sign in the definition.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 14.1.** 编写一个函数`velocityCF''`，它与`velocityCF`做相同的事情并具有相同的类型签名，但在定义中，时间`t
    :: Time`显式列在等号的左侧。'
- en: '[PRE30]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Exercise 14.2.** Using the `positionCF` function, make a graph for the position
    of the car on the air track in Example 14.1 as a function of time. Assume the
    initial position of the car is – 1 m.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 14.2.** 使用`positionCF`函数，为示例14.1中的汽车在气轨上的位置画图，位置作为时间的函数。假设汽车的初始位置为-1米。'
- en: '**Exercise 14.3.** Write a function'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 14.3.** 编写一个函数'
- en: '[PRE31]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: that adds a list of functions to produce a function that represents the sum.
    Replace `undefined` with your code, and feel free to include one or two variables
    to the left of the equal sign in the definition. Using `sumF`, we could write
    the first line in the `let` construction of `velocityFt` as `fNet = sumF fs`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个函数列表，以生成一个表示总和的函数。用你的代码替换`undefined`，并可以在定义的等号左侧加入一个或两个变量。使用`sumF`，我们可以将`velocityFt`的`let`构造中的第一行写为`fNet
    = sumF fs`。
- en: '**Exercise 14.4.** Write a Haskell function'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 14.4.** 编写一个 Haskell 函数'
- en: '[PRE32]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: that returns a position function for a Newton’s second law situation in which
    the forces depend only on the velocity. Replace the `undefined` with your code,
    and feel free to include variables to the left of the equal sign in the definition.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个描述牛顿第二定律的位移函数，该定律中的力仅依赖于速度。用你的代码替换`undefined`，并可以在定义的等号左侧加入变量。
- en: '**Exercise 14.5.** Any Newton’s second law problem that can be solved with
    `velocityFv` can also be solved with `velocityFtv`. Rewrite the `bikeVelocity`
    function so that it uses `velocityFtv` instead of `velocityFv`.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 14.5.** 任何可以用`velocityFv`解决的牛顿第二定律问题，也可以用`velocityFtv`来解决。重写`bikeVelocity`函数，使其使用`velocityFtv`而不是`velocityFv`。'
- en: '**Exercise 14.6.** Doing the Euler method by hand on [page 225](ch14.xhtml#page_225),
    we found the velocity after 1.5 s to be *v*(1.5 s) = 2.1295 m/s. Use the `velocityFv`
    function to calculate this same number.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 14.6.** 手动使用欧拉方法计算[第225页](ch14.xhtml#page_225)的速度，我们发现1.5秒后的速度为*v*(1.5秒)
    = 2.1295米/秒。使用`velocityFv`函数来计算这个相同的数值。'
- en: '**Exercise 14.7.** Doing the Euler method by hand on [page 235](ch14.xhtml#page_235),
    we found the velocity after 18 s to be *v*(18 s) = 0.8752 m/s. Use `statesTV`
    or `velocityFtv` to calculate this same number.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 14.7.** 在 [第 235 页](ch14.xhtml#page_235)手工计算欧拉法时，我们发现 18 秒时的速度为 *v*(18
    s) = 0.8752 m/s。使用 `statesTV` 或 `velocityFtv` 来计算这个相同的结果。'
- en: '**Exercise 14.8.** Fix the stair-stepping issue in [Figure 14-9](ch14.xhtml#ch14fig9)
    so that a smooth plot appears.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 14.8.** 修复 [图 14-9](ch14.xhtml#ch14fig9) 中的阶梯效应，使图表显示平滑。'
- en: '**Exercise 14.9.** Write a Haskell function'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 14.9.** 编写一个 Haskell 函数'
- en: '[PRE33]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: that returns a position function for a Newton’s second law situation in which
    the forces depend only on time and velocity. Replace the `undefined` with your
    code, and feel free to include variables to the left of the equal sign in the
    definition.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回一个位置函数，适用于牛顿第二定律情形，其中力仅依赖于时间和速度。将 `undefined` 替换为你的代码，且可以自由在等号左侧的定义中包含变量。
- en: '**Exercise 14.10.** Produce a graph of position versus time for the situation
    in [Figure 14-13](ch14.xhtml#ch14fig13).'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 14.10.** 绘制 [图 14-13](ch14.xhtml#ch14fig13) 中情形的位移与时间的关系图。'
- en: '**Exercise 14.11.** To deepen our understanding of the Euler method, we’ll
    do a calculation by hand (using only a calculator and not the computer).'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 14.11.** 为了加深我们对欧拉法的理解，我们将手工进行一次计算（仅使用计算器，而不是计算机）。'
- en: Consider a 1-kg mass exposed to two forces. The first force is an oscillatory
    force, pushing first one way and then the other. With *t* in seconds, the force
    in Newtons is given by
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个受到两个力作用的 1 公斤物体。第一个力是一个振荡力，先一个方向推力，然后再反方向推力。用 *t* 表示秒，力的单位是牛顿，其表达式为
- en: '*F*[1](*t*) = 4 cos 2*t*'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '*F*[1](*t*) = 4 cos 2*t*'
- en: The second force is an air resistance force in Newtons, given by
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个力是一个空气阻力力，单位是牛顿，表达式为
- en: '*F*[2](*v*[0]) = –3*v*[0]'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '*F*[2](*v*[0]) = –3*v*[0]'
- en: where *v*[0] is the current velocity of the mass in meters per second.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *v*[0] 是当前质量的速度，以米每秒为单位。
- en: The net force is
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 净力是
- en: '![Image](Images/e0240-01.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/e0240-01.jpg)'
- en: Suppose the mass is initially moving 2 m/s so that
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 假设质量最初以 2 m/s 的速度运动，因此
- en: '*v*(0 s) = 2 m/s'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '*v*(0 s) = 2 m/s'
- en: Use the Euler method with a time step of Δ*t* = 0.1 s to approximate the value
    of *v*(0.3s). Keep at least four figures after the decimal point in your calculations.
    Show your calculations in a small table.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 使用欧拉法，时间步长 Δ*t* = 0.1 s，近似计算 *v*(0.3s) 的值。在计算中保留小数点后至少四位。将你的计算过程展示在一个小表格中。
- en: '**Exercise 14.12.** Write a Haskell function'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 14.12.** 编写一个 Haskell 函数'
- en: '[PRE34]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: that takes a time-velocity pair (*t*[0], *v*[0]) and returns an updated time-velocity
    pair (*t*[1], *v*[1]) for a single step of the Euler method for a 1-kg object
    experiencing a net force of
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个时间-速度对 (*t*[0], *v*[0])，并返回一个更新后的时间-速度对 (*t*[1], *v*[1])，适用于 1 公斤物体在欧拉法下进行单步计算的情形，假设其受到净力的作用。
- en: '![Image](Images/e0240-02.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/e0240-02.jpg)'
- en: Use a time step of Δ*t* = 0.1 s. Show how to use the function updateExample
    to calculate the value *v*(0.3 s) that you calculated by hand in Exercise 14.11.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 使用时间步长 Δ*t* = 0.1 s。展示如何使用函数 updateExample 计算你在习题 14.11 中手工计算的 *v*(0.3 s) 值。
- en: '**Exercise 14.13.** Consider a 1-kg object experiencing a net force'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 14.13.** 考虑一个 1 公斤物体，受净力作用'
- en: '![Image](Images/e0240-03.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/e0240-03.jpg)'
- en: 'where *α* = 1 N s/m, subject to the initial condition *v*(0 s) = 8 m/s. Use
    the Euler method to find the velocity of the object over the time interval 0 s
    ≤*t* ≤ 10 s. Plot velocity as a function of time to see what it looks like. Compare
    your results to the exact solution:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *α* = 1 N·s/m，初始条件是 *v*(0 s) = 8 m/s。使用欧拉法求解物体在时间区间 0 s ≤*t* ≤ 10 s 内的速度，并绘制速度与时间的关系图，观察结果。将结果与精确解进行比较：
- en: '![Image](Images/e0240-04.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/e0240-04.jpg)'
- en: Try out different time steps to see what happens when the time step gets too
    big.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试不同的时间步长，看看当时间步长过大时会发生什么。
- en: Find a time step that is small enough that the Euler solution and the exact
    solution nicely overlap on a plot. Find another time step that is big enough that
    you can see the difference between the Euler solution and the exact solution on
    a plot.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个足够小的时间步长，使得欧拉解和精确解在图表上能够很好地重合。找到另一个足够大的时间步长，使你可以在图表上看到欧拉解和精确解之间的差异。
- en: Make a nice plot (with title, axis labels, and so on) with these three solutions
    on a single graph (bad Euler, good Euler, and exact). Label the Euler results
    with the time step you used and label the exact result “Exact.”
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一个漂亮的图表（包括标题、坐标轴标签等），将这三种解法（坏的欧拉法、好的欧拉法和精确解）绘制在同一图表上。标记欧拉法的结果，并标出你使用的时间步长，将精确解标记为“Exact”。
- en: '**Exercise 14.14.** Consider the differential equation'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 14.14.** 考虑以下微分方程'
- en: '![Image](Images/241equ01.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/241equ01.jpg)'
- en: subject to the initial condition *v*(0) = 0\. This differential equation has
    no exact solution. Use the Euler method with a step size of Δ*t* = 0.01 to find
    *v*(*t*) over the interval 0 ≤*t* ≤ 3\. Make a nice plot of the resulting function
    and include the value *v*(3) to five significant figures.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 并且满足初始条件 *v*(0) = 0\。这个微分方程没有精确解。使用欧拉方法，步长为 Δ*t* = 0.01，计算区间 0 ≤ *t* ≤ 3 上的
    *v*(*t*)。绘制结果函数的图像，并将 *v*(3) 的值精确到五位有效数字。
- en: '**Exercise 14.15.** Each wire in a functional diagram can be labeled with a
    type. Label each wire in [Figure 14-11](ch14.xhtml#ch14fig11) with a type.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题 14.15.** 功能图中的每一根电线都可以标记一个类型。请为[图 14-11](ch14.xhtml#ch14fig11)中的每根电线标记类型。'
