- en: '14'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NEWTON’S SECOND LAW AND DIFFERENTIAL EQUATIONS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Isaac Newton accomplished a lot. Among the numerous physical and mathematical
    insights he left us are three numbered laws that bear his name. Newton’s second
    law is the most important of these; it provides a method for understanding the
    motion of an object if we know the forces that act on it. Newton’s third law is
    almost as significant; it’s a rule about how two objects interact. Newton’s first
    law, from a mathematical standpoint, is a corollary to Newton’s second law, so
    it seems the smallest of the three. But since Newton’s second law is sufficiently
    intuition shattering, it’s helpful to get our minds around something simpler before
    trying to grasp it. Newton’s first law serves well in this capacity; it makes
    a bold claim that seems obviously false.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll discuss Newton’s first law and then turn our attention
    to Newton’s second law in one linear dimension, such as a horizontal line or a
    vertical line. We’ll show how to think about Newton’s second law in a sequence
    of settings of increasing complexity, organized by what the forces depend on.
    We’ll start with constant forces, the simplest situation, before moving on to
    forces that depend only on time. Then we’ll turn to forces that depend on the
    velocity of the particle they act on, followed by forces that depend on both time
    and velocity. The techniques for solving Newton’s second law change as the forces
    involved depend on different physical quantities. We’ll introduce the Euler method
    for solving a differential equation and explore a number of situations in which
    Newton’s second law is the central principle that allows us some traction in understanding
    the motion of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Newton’s First Law
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s return to the air track of [Chapter 4](ch04.xhtml). If you give the car
    a little push on the air track and then let it go, it will travel at a constant
    speed until it hits the end of the track. After we stop pushing the car, it continues
    to move at some speed even with no force applied in the direction of motion. This
    tendency for moving objects to keep moving is called *inertia*. The idea of inertia
    is relevant in the one-dimensional spatial setting of the air track, and it’s
    also relevant in the unconstrained three-dimensional spatial setting of the world
    in which we live. The idea is important enough to be enshrined in a principle
    of physics called *Newton’s first law*. Here are three versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Newton’s first law, Newton’s words [[15](bib.xhtml#bib15)]**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Every body perseveres in its state of being at rest or of moving uniformly
    straight forward, except insofar as it is compelled to change its state by forces
    impressed.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Newton’s first law, poetic version**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A body in motion stays in motion. A body at rest stays at rest.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Newton’s first law, modern version**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the absence of applied forces, an object maintains the same velocity.*'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that velocity is a vector, so maintaining the same velocity means keeping
    the same speed as well as the same direction. Since acceleration is change in
    velocity per unit of time, an equivalent way of expressing Newton’s first law
    is that in the absence of forces, an object experiences no acceleration.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that Newton’s first law makes no mention of forces that were applied
    *in the past*. The point is that if there are no forces acting *now*, the velocity
    will stay constant now. Any time there are no forces present, the velocity will
    stay constant.
  prefs: []
  type: TYPE_NORMAL
- en: Why does Newton’s first law seem obviously false? Because we’re stuck on the
    surface of the earth, a place that is rife with forces we might fail to consider,
    friction and air resistance not least among them. Things are a bit simpler out
    in space. We can imagine one astronaut tossing a small wrench to another at slow
    speed. The wrench just glides straight across the ship, perhaps rotating slowly
    about its center. That wrench is a great example of Newton’s first law.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps you’ve been in a car when the driver slams on the brakes so that books,
    papers, and toys go flying forward (with respect to the car’s seats). In my family,
    we celebrate these moments by shouting “Newton’s first law!” From a perspective
    outside the (decelerating) car, the books, papers, and toys are doing their best
    to travel in a straight line, at least for the short period of time before gravity
    and other objects put an end to their line-like motion.
  prefs: []
  type: TYPE_NORMAL
- en: Newton’s first law tells us that objects naturally go steady and straight. In
    practice, though, they don’t. Newton’s second law explains how and why.
  prefs: []
  type: TYPE_NORMAL
- en: Newton’s Second Law in One Dimension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Newton’s first law tells us that when no forces are present, an object does
    not accelerate. Newton’s second law claims that acceleration is caused by forces.
  prefs: []
  type: TYPE_NORMAL
- en: '**Newton’s second law, Newton’s words [[15](bib.xhtml#bib15)]**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A change in motion is proportional to the motive force impressed and takes
    place along the straight line in which that force is impressed.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Newton’s second law, poetic version**'
  prefs: []
  type: TYPE_NORMAL
- en: '*An object’s acceleration is directly proportional to the net force acting
    on the object and inversely proportional to its mass.*'
  prefs: []
  type: TYPE_NORMAL
- en: Modern versions of Newton’s second law are expressed by Equation 14.1 for Newton’s
    second law in one dimension, and Equation 16.1 for Newton’s second law in three
    dimensions. In the remainder of this chapter, we’ll treat Newton’s second law
    in one dimension, which allows us to keep things simple by using numbers rather
    than vectors for velocity, acceleration, and force. In [Chapter 16](ch16.xhtml),
    we’ll treat Newton’s second law in full generality with vectors.
  prefs: []
  type: TYPE_NORMAL
- en: To discuss force and mass in a quantitative way, we need units of measure. In
    the SI system, force is measured in Newtons (N). A 100-N force has a different
    effect on a golf ball than it has on a bowling ball. According to Newton, each
    object has a *mass*, which determines the readiness of an object to accelerate
    in response to a force. A large-mass object experiences small acceleration compared
    to a small-mass object exposed to the same force. The SI unit of mass is the kilogram
    (kg).
  prefs: []
  type: TYPE_NORMAL
- en: 'Newton’s second law expresses a relationship between the following three quantities:'
  prefs: []
  type: TYPE_NORMAL
- en: The forces that act on an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mass of the object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The acceleration of the object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Newton’s second law says that the acceleration of an object can be found by
    dividing the net force acting on the object by the mass of the object. The *net
    force* acting on an object is the sum of all the forces acting on the object.
    In one dimension, some forces may be negative and some may be positive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Newton’s second law is usually written as *F*[net] = *ma*. Unlike the one-dimensional
    equations for velocity and acceleration (Equations 4.5 and 4.12), this equation
    is not an equality of functions. The acceleration of the object is only a function
    of time, but the net force generally depends on the time, the position of the
    object, and the velocity of the object. The net force at time *t* is *F*[net]
    (*t*, *x*(*t*), *v*(*t*)). A better way to write Newton’s second law is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/208equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is a chicken-and-egg issue going on with Newton’s second law. We know
    from Equations 4.5 and 4.12 that *v* = *Dx* and *a* = *Dv*. If we know the function
    *a* (meaning we know its value at all times), we can find the function *v* given
    an initial velocity. (See Equation 6.1 and the corresponding function `velFromAcc`.)
    We can then go on and find the function *x* given an initial position. (See Equation
    6.5 and the corresponding function `posFromVel`.) But Newton’s second law is telling
    us that acceleration depends on the forces, which depend on the position and the
    velocity. To find the position of my object, it seems that I need to find the
    velocity, and for that I need the acceleration. However, the acceleration depends
    on both the position and the velocity.
  prefs: []
  type: TYPE_NORMAL
- en: There is a name for this particular kind of chicken-and-egg problem. Newton’s
    second law is an example of a *differential equation*. A differential equation
    is a relationship between derivatives of an unknown function, with the unknown
    function itself often regarded as the zeroth derivative. The unknown function
    in the case of Newton’s second law is usually either the position *x* or the velocity
    *v*. Velocity can be written as the first derivative of position (*v* = *Dx*),
    and acceleration can be written as the second derivative of position (*a* = *Dv*
    = *D*²*x*).
  prefs: []
  type: TYPE_NORMAL
- en: Newton’s second law looks more like a differential equation if we write it in
    terms of an unknown position function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/208equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a second-order differential equation because it is a relationship between
    the position function *x*, its first derivative *Dx*, and its second derivative
    *D*²*x*. The relationship for a particular physical object depends on the function
    *F*[net], which depends on the nature of the forces acting on the object.
  prefs: []
  type: TYPE_NORMAL
- en: In simple situations, the net force on an object may not depend on time, position,
    and velocity, but rather only on zero, one, or two of these physical quantities.
    In these simple situations, Newton’s second law may appear as something simpler
    than a second-order differential equation. [Table 14-1](ch14.xhtml#ch14tab1) lists
    situations by the physical quantities that the forces depend on and gives the
    mathematical technique needed to solve Newton’s second law.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 14-1:** The Technique for Solving Newton’s Second Law, Based on Which
    Physical Quantities the Forces Depend On'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Forces depend only on** | **Solution technique** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Nothing | Algebra |'
  prefs: []
  type: TYPE_TB
- en: '| Time | Integration |'
  prefs: []
  type: TYPE_TB
- en: '| Velocity | First-order differential equation |'
  prefs: []
  type: TYPE_TB
- en: '| Time and velocity | First-order differential equation |'
  prefs: []
  type: TYPE_TB
- en: '| Time, position, and velocity | Second-order differential equation |'
  prefs: []
  type: TYPE_TB
- en: A net force that depends on nothing is a constant net force. Its value remains
    constant over time, independent of time, position, or velocity. In the next several
    sections, we’ll look at constant forces, forces that depend only on time, forces
    that depend only on velocity, and forces that depend on both time and velocity.
    This restriction allows us to limit our attention in this chapter to first-order
    differential equations. In [Chapter 15](ch15.xhtml), we’ll look at the more general
    case of one-dimensional motion in which the net force can depend on time, position,
    *and* velocity.
  prefs: []
  type: TYPE_NORMAL
- en: Second Law with Constant Forces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest situation for Newton’s second law is when the net force is constant,
    independent of time, position, and velocity. Most problems in an introductory
    physics course are like this because they can be solved without differential equations
    and without a computer.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider an example problem with constant forces.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 14.1.** Suppose we have a car with mass 0.1 kg on an air track. The
    car is initially moving east at a speed of 0.6 m/s. Starting at time *t* = 0,
    we apply to this car a constant force of 0.04 N to the east. At the same time,
    our friend applies to the same car a constant force of 0.08 N to the west. What
    will the subsequent motion of the car look like? In particular, how will the velocity
    and the position of the car change in time?'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-1](ch14.xhtml#ch14fig1) shows the schematic diagram.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/209fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: Schematic diagram for Newton’s second law with constant forces*'
  prefs: []
  type: TYPE_NORMAL
- en: The constant net force ![Image](Images/210equ01.jpg) (superscript *c* for constant)
    acting on the object needs to be divided by the mass of the object to obtain the
    acceleration of the object. Because the net force is constant, the acceleration
    is also constant.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/210equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We write *a*(*t*) rather than *a* for acceleration, not because acceleration
    changes with time, but because *a* is the acceleration function (type `R -> R`)
    and *a*(*t*) is the acceleration (type `R`). We then integrate acceleration to
    obtain the velocity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/210equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The integrator that produces velocity contains a real number (type `R`) as state.
    This type is shown below the integrator in [Figure 14-1](ch14.xhtml#ch14fig1).
    This integrator remembers the current velocity so that it can be updated using
    the acceleration.
  prefs: []
  type: TYPE_NORMAL
- en: We then integrate the velocity to obtain the position.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/210equ04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The wires of the diagram represent quantities that are continuously changing
    in time. Each wire in the diagram is labeled with a name and a type. For this
    diagram, all of the wire types are real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Rectangular boxes represent purely functional constants and functions. In other
    words, they are constants and functions that do not contain any state, so that
    the output is a function only of the input. The circular integrators contain states
    that must be combined with the input to produce the output. The integrators are
    labeled with the type of state they contain, which is the same as the type of
    the output from the integrator.
  prefs: []
  type: TYPE_NORMAL
- en: Before we write Haskell code to solve Newton’s second law for constant forces,
    we are going to write a few lines of code that need to be at the top of the source
    code file we build throughout this chapter. The first line turns on warnings,
    which I recommend doing because the compiler will warn you of things that are
    legal but unusual enough that they may not be what you intended. The second line
    gives the code in this chapter the module name `Newton2`. If we want to use functions
    we write here in later chapters, we’ll refer to the current code using its module
    name. A module name is optional, but if you use one, it must match the filename;
    in this case, the filename should be *Newton2.hs*. The third line loads the `gnuplot`
    graphics library so that we can make a graph. Imports like this must occur before
    any function definitions or type signatures.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Example 14.1 is typical of situations in which Newton’s second law applies.
    Given a mass, an initial velocity, and some forces, we are asked to produce velocity
    as a function of time. In the Haskell language, a solution to this example situation
    would be a (higher-order) function `velocityCF` (`CF` for constant forces) with
    the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Recall that there are (at least) two ways to read this type signature. On one
    reading, `velocityCF` takes four inputs—mass, initial velocity, a list of forces,
    and a time—and produces as output a real number representing velocity. An alternative
    reading is that `velocityCF` takes three inputs—mass, initial velocity, and a
    list of forces—and produces as output a *function* for how velocity changes with
    time. If we wanted to emphasize the latter viewpoint, we could write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: but it means the same thing as the original type signature.
  prefs: []
  type: TYPE_NORMAL
- en: We used the types `Time`, `Mass`, `Velocity`, and `Force`. These are not built-in
    types in Haskell, so we’d better define what they mean. In one-dimensional mechanics,
    all of these quantities can be represented with real numbers, so we can write
    some type synonyms to define these types. Using a type synonym in which `R` stands
    for `Double`,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'we can write type synonyms for all of the other types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The definitions for types `Mass`, `Time`, and so on, need not appear before
    their use in a type signature. Haskell allows definitions of constants, functions,
    and types before or after their use.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we can write a function `velocityCF` with the type signature above, we will
    have solved not just Example 14.1, but all others like it. Our strategy in writing
    such a function is:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the net force by adding all of the forces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the acceleration using Newton’s second law (Equation 14.3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the velocity from the acceleration (Equation 4.14 or 14.4)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here’s a definition for `velocityCF` that expresses these three steps and has
    the type we claimed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To write the function `velocityCF`, we begin by naming the three inputs: mass
    `m`, initial velocity `v0`, and list of forces `fs`. We then use a `let` construction
    to define three local names for net force, acceleration, and velocity. To find
    the net force, we sum up the forces in the list using the built-in `sum` function.
    To find the acceleration, we divide the net force on the object by the mass of
    the object, as Newton’s second law prescribes.'
  prefs: []
  type: TYPE_NORMAL
- en: The third equation in the `let` construction defines a local function `v` to
    represent the velocity function. We use Equation 4.14, one of the constant acceleration
    equations introduced in standard introductory physics textbooks, but we could
    just as easily have used Equation 14.4 in place of the second and third lines
    of the `let` construction. Notice that we have written the definition of `velocityCF`
    using the “three-input thinking” mentioned earlier. Exercise 14.1 asks you to
    rewrite the function using four-input thinking.
  prefs: []
  type: TYPE_NORMAL
- en: We can write a function `positionCF` that produces a position function given
    mass, initial position, initial velocity, and a list of constant forces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have used Equation 4.15 or 14.5\. Returning to Example 14.1, the velocity
    of the car as a function of time is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: because 0.1 kg is the mass of the car, 0.6 m/s is its initial velocity, and
    the square-bracketed list contains the forces in Newtons. We can ask for the type
    of this function in GHCi, and we can ask for values of the velocity at specific
    times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since we have the velocity function in hand, we can graph it. Let’s write the
    code to do so first. Most of the code below is for setting up a title, axis labels,
    and the name of the file we want produced. The interesting stuff is at the end,
    where we give a list of times at which to evaluate the function and the function
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This code produces the graph in [Figure 14-2](ch14.xhtml#ch14fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/213fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Car velocity as a function of time in Example 14.1*'
  prefs: []
  type: TYPE_NORMAL
- en: If you load this chapter’s module, `Newton2`, into GHCi and enter `carGraph`,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: you will not get any return value, but the function will produce a Portable
    Network Graphics (PNG) file named *CarVelocity.png* on your hard drive. Without
    the `PNG "CarVelocity.png"` option, the `carGraph` function would produce a graph
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the negative acceleration in the graph in [Figure 14-2](ch14.xhtml#ch14fig2)
    (which exists over the entire time interval from *t* = 0 to *t* = 4 s) does not
    mean that the car is always slowing down. Rather, a negative acceleration means
    an acceleration to the west. The car slows down during the first 1.5 s as it is
    moving east but then begins to speed up as it moves west. When the acceleration
    and velocity of an object point in the same direction, the object speeds up. When
    the acceleration and velocity of an object point in opposite directions, the object
    slows down.
  prefs: []
  type: TYPE_NORMAL
- en: With the functions `velocityCF` and `positionCF`, we have general-purpose ways
    of solving any Newton’s second law type problem in one spatial dimension with
    constant forces. Next we’ll consider forces that change in time.
  prefs: []
  type: TYPE_NORMAL
- en: Second Law with Forces That Depend Only on Time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next situation for Newton’s second law is when the net force depends on
    time but not on position or velocity. [Figure 14-3](ch14.xhtml#ch14fig3) shows
    a schematic diagram for Newton’s second law with forces that depend only on time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/214fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: Schematic diagram for Newton’s second law with forces that depend
    only on time*'
  prefs: []
  type: TYPE_NORMAL
- en: The constant number 1 is fed into an integrator to produce a value for time.
    (The time changes at a rate of 1 second per second.) As usual, wires are labeled
    with names and types. Integrators are labeled with the type of state they hold.
    Time is fed into the net force function ![Image](Images/e0214-01.jpg) (superscript
    *t* for time-dependent), which produces net force as output. To obtain the acceleration
    of the object, we need to divide the net force acting on the object by the object’s
    mass.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/214equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We then integrate the acceleration to obtain the velocity,
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/215equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'and we integrate the velocity to obtain the position:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/215equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The wires of the diagram represent quantities that are continuously changing
    in time. Rectangular boxes represent pure functions, whereas circular elements
    contain state.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve Newton’s second law problems with forces that depend on time, we’d
    like a higher-order function that produces a velocity function, similar to `velocityCF`
    in the previous section. One difference is that now we need to provide a list
    of force *functions* rather than a list of numerical forces. We want a function
    `velocityFt` (the `Ft` suffix denotes that forces depend only on time) with the
    following type signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Given the mass of our object, its initial velocity, and a list of force functions,
    we want to produce a velocity function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we’re going to do numerical integration to get the velocity function,
    we’ll add one additional parameter to this type signature, namely the time step
    for numerical integration. Thus, we arrive at the following definition for `velocityFt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this definition, we begin by naming the inputs: `dt` for an integration
    time step, `m` for the mass of the object we are attending to, `v0` for the initial
    velocity of this object, and `fs` for a list of force functions. Note that the
    local variable for forces, `fs`, had type `[Force]` (or `[R]`) when used in `velocityCF`
    and `positionCF` for situations with constant forces, but it now has type `[Time
    ->` `Force]` (or `[R -> R]`) for situations with forces that depend on time.'
  prefs: []
  type: TYPE_NORMAL
- en: We again use a `let` construction to define local functions, a net force function,
    and an acceleration function. The net force function adds together the forces
    provided in the list `fs`. We might have hoped we could use the same line of code
    we used in `velocityCF`, namely `fNet = sum fs`, to sum the forces. After all,
    `fs` is still a list. The trouble is that `sum` works only with types that are
    instances of `Num`, as you can see if you look at the type of `sum`. So while
    it is happy to add numbers (type `R`), it is not happy to add functions (type
    `R -> R`). Fortunately, we can evaluate the force functions at a time `t` introduced
    as an argument to `fNet` and then add the resulting numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The acceleration function comes from Newton’s second law. Here, we might have
    hoped that we could divide the net force function by the mass to obtain the acceleration
    function, perhaps writing `a = fNet / m`. But recall that the division operator
    insists that it work with two values that have the same type and that this type
    be an instance of `Fractional`. The division operator does not want to work with
    functions. Again, we address this by evaluating the `fNet` function at the time
    `t` introduced as the argument to the acceleration function `a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the velocity comes from taking an antiderivative of the acceleration
    function. We defined the functions `antiDerivative` and `integral` in [Chapter
    6](ch06.xhtml), but we’ll repeat their definitions here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that `velocityFt dt m v0 fs` has type `R -> R` and is the velocity function
    for an object with mass `m`, initial velocity `v0`, and list of force functions
    `fs`. This velocity function is part of the solution to the mechanics problem.
    Another part of the solution is a position function. We can write a function `positionFt`
    that produces a position function given mass, initial position, initial velocity,
    and a list of force functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This function works by taking an antiderivative of the velocity function, which
    we find using `velocityFt`.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of solving Newton’s second law with a time-dependent force, consider
    a child riding a bike. By working the pedals, the child arranges for the ground
    to apply a constant forward force of 10 N on the bike for 10 seconds, after which
    the child coasts for the next 10 seconds. Following the coasting, the child returns
    to the 10-N force for another 10 seconds, and so on, as illustrated in [Figure
    14-4](ch14.xhtml#ch14fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/217fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Force as a function of time for a child on a bike*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we’ll assume that air resistance is not important and that
    there is only one force on the bike.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the equation for the time-dependent force of pedaling and coasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/217equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The force is either 0 N or 10 N, depending on where the time falls in a 20-second
    cycle. If the time falls in the first 10 seconds of the cycle, the force is 10
    N. If, on the other hand, the time falls in the last 10 seconds of the cycle,
    the force is 0 N.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the time-dependent force of Equation 14.8 in Haskell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The local variable `tCycle` is the number of seconds for a full cycle. The variable
    `nComplete` uses the Prelude function `truncate` to calculate the number of complete
    cycles from the time `t`. The `truncate` function produces a type with type class
    `Integral` (recall `Integer` and `Int` are instances of `Integral`). We provide
    a local type signature to say that we want `nComplete` to have type `Int`. The
    local type signature is optional, but the compiler will give us a warning that
    it chose a default type if we don’t specify something. Remove the local type signature
    to see what the warning looks like. This is a mild warning. We don’t mind that
    the compiler chooses `Integer` instead of `Int`. You can feel free to ignore this
    warning and use the code without the type signature if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `remainder` is the number of seconds, between 0 and 20, that have elapsed
    since the beginning of the most recent cycle. We want `remainder` to be a real
    number, so we must use `fromIntegral` to convert `nComplete :: Int` into a real
    number.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-5](ch14.xhtml#ch14fig5) shows the position of the child as a function
    of time.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/218fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: Position as a function of time for the child on a bike*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the Haskell code that produced [Figure 14-5](ch14.xhtml#ch14fig5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The most interesting part of the code is the last line, where we specify the
    function we want plotted. This function, `positionFt 0.1 20 0 0 [pedalCoast]`,
    uses the `positionFt` function we developed earlier in the chapter with a time
    step of 0.1 s, a mass of 20 kg, 0s for initial position and initial velocity,
    and a list of forces that includes only the force of pedaling and coasting. All
    of the relevant physical information is included in the “name” of the function
    we are plotting.
  prefs: []
  type: TYPE_NORMAL
- en: You can see from the graph in [Figure 14-5](ch14.xhtml#ch14fig5) that during
    the first 10 seconds, the child’s position curve is parabolic, as we’d expect
    from constant acceleration. From 10 to 20 seconds, the position shows constant
    velocity while the child is coasting. From 20 to 30 seconds, there is another
    period of acceleration in which the position curve is parabolic, followed by a
    second period of coasting.
  prefs: []
  type: TYPE_NORMAL
- en: With the functions `velocityFt` and `positionFt`, we have general-purpose ways
    of solving any Newton’s second law type problem in one spatial dimension with
    forces that depend only on time. We’re now ready to look at forces that depend
    on velocity, the most common of which is air resistance.
  prefs: []
  type: TYPE_NORMAL
- en: Air Resistance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll make a short diversion from our path of considering Newton’s
    second law in the presence of forces that depend on time, velocity, neither, or
    both to develop an expression for the force of air resistance on an object in
    one-dimensional motion. Air resistance is a force that depends only on velocity,
    and we’ll use it in the next several sections as we develop ways to solve Newton’s
    second law with forces that depend on velocity.
  prefs: []
  type: TYPE_NORMAL
- en: Introductory physics classes typically ignore air resistance or treat it very
    lightly, because the presence of air resistance turns Newton’s second law into
    a differential equation, which is considered beyond the scope of an introductory
    physics course. In this chapter and the next, we’ll develop numerical methods
    for solving differential equations, meaning that air resistance is not something
    we want to avoid; in fact, it showcases the power of our tools.
  prefs: []
  type: TYPE_NORMAL
- en: To develop a model of air resistance, let’s think of the interaction between
    an object and the air around it as a collision. Suppose the object is moving with
    velocity *v*. In this section, *v* represents the real-valued, one-dimensional
    velocity of the object (a quantity with type `R`) and not the velocity function
    or the speed.
  prefs: []
  type: TYPE_NORMAL
- en: Let the cross-sectional area of the object be *A* and the density of air be
    *ρ*. We analyze the motion of the object over a small time interval *dt*. We assume
    that the initial velocity of the air is 0, and that the final velocity of the
    air is *v* (in other words, after the collision, the air is traveling at the same
    speed as the object).
  prefs: []
  type: TYPE_NORMAL
- en: The distance the object travels in time *dt* is *v dt*. The volume of air swept
    out by the object in time *dt* is *Av dt*. The mass of air disturbed by the object
    in time *dt* is *ρAv dt*. The momentum imparted to the air by the object in time
    *dt* is the product of the mass of the air, *ρAv dt*, and the change in velocity
    of the air, which is *v*, as we assume that the air starts from rest and ends
    the short time interval with velocity *v*. The momentum imparted to the air is
    *ρAv*²*dt*. The force felt by the air is this change in momentum per unit time,
    or *ρAv*². The force felt by the object from the air is equal and opposite to
    this following Newton’s third law, which we will discuss in [Chapter 19](ch19.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Our derivation was really quite approximate because we don’t know that the air
    molecules really end up with velocity *v*, and we haven’t even tried to account
    for the forces of air molecules on each other as the air compresses. Nevertheless,
    the form of our result is quite useful and approximately correct. Objects with
    different shapes respond a bit differently though, so it is useful to introduce
    a *drag coefficient C* to account for these differences. The drag coefficient
    is a dimensionless constant that is a property of the object that is flying through
    the air. It is also conventional to include a factor of 1/2 so that the magnitude
    of the force of air resistance on the object is *CρA v*²/2\. This expression is
    never negative. We would prefer an expression in which the force is negative when
    the velocity is positive and positive when the velocity is negative. Our final
    expression for the one-dimensional force of air resistance is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/220equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'where the minus sign and the absolute value ensure that the force acts in a
    direction opposite the velocity. Air resistance is acting to slow the object.
    In Haskell, we’ll write Equation 14.9 for air resistance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the mathematical notation of Equation 14.9, we’re treating *F*[air] as a
    function of one variable. The parameters *C*, *ρ*, and *A* are not listed explicitly
    as variables that *F*[air] depends on. Eliding parameters like this is standard
    practice in physics, but in some sense it’s an abuse of notation. In the Haskell
    notation, we must include all of the variables that the force of air resistance
    depends on. We list the three parameters first, before the `Velocity`, so that
    an expression like `fAir 1 1.225 0.6` is a fully legitimate function that takes
    only velocity as input. The function `fAir 1 1.225 0.6` has already chosen drag
    = 1, rho = 1.225, and area = 0.6.
  prefs: []
  type: TYPE_NORMAL
- en: With this brief foray into air resistance, and particularly the development
    of Equation 14.9, we’re now ready to look at Newton’s second law in the case where
    forces on our object depend only on its velocity.
  prefs: []
  type: TYPE_NORMAL
- en: Second Law with Forces That Depend Only on Velocity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next situation for Newton’s second law is when the net force depends on
    velocity but not on time or position. What we really mean here is that the forces
    do not depend *explicitly* on time. Velocity is a function that depends on time,
    and forces are allowed to depend on the velocity in this section, so there is
    a sense in which the forces depend on time. The constraint in this section is
    that the forces can depend on time *only through the velocity*.
  prefs: []
  type: TYPE_NORMAL
- en: The force functions may depend only on one variable, the velocity. We use ![Image](Images/e0221-01.jpg)
    to denote the *j*th force function of one variable that gives force when supplied
    with velocity and we use ![Image](Images/e0221-02.jpg) to denote the function
    of one variable that gives net force when supplied with velocity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/221equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We use *v*[0] as a local variable for velocity (type `R`) rather than *v* in
    this section because we want *v* to stand for the velocity function of our object
    (type `R -> R`).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-6](ch14.xhtml#ch14fig6) shows a schematic diagram for Newton’s second
    law with forces that depend only on velocity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/221fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: Newton’s second law with forces that depend only on velocity*'
  prefs: []
  type: TYPE_NORMAL
- en: This diagram, unlike previous diagrams, contains a loop. The velocity produced
    by the integrator of acceleration serves as the input to the net force function.
    The loop in the diagram indicates that Newton’s second law produces a differential
    equation. Because the loop contains one integrator, we get a first-order differential
    equation. A differential equation is a more difficult mathematical problem than
    a mere integral or antiderivative, as we had when forces depended only on time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Newton’s second law is given by the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/221equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The information this equation represents is the same as the information in the
    schematic diagram of [Figure 14-6](ch14.xhtml#ch14fig6). The equation describes
    how the rate of change of velocity depends on velocity itself through the forces
    that act on the object. The function `newtonSecondV`, presented next, is yet a
    third way to express Newton’s second law; this function returns the rate of change
    of velocity when given the current value of velocity along with the forces that
    act on the object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can integrate the acceleration to obtain the velocity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/222equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Unlike the case with time-dependent forces, we cannot simply perform the integral
    here because the velocity function we are trying to find appears under the integral.
    How to proceed?
  prefs: []
  type: TYPE_NORMAL
- en: To solve the differential equation, Equation 14.10, we will discretize time,
    which is something we have been doing with our numerical derivatives and integrals
    when we chose a time step. As long as our time step *Δt* is smaller than any important
    time scales in the situation we are addressing, the slope of the line connecting
    points (*t*, *v*(*t*)) and (*t* + Δ*t*, *v*(*t* + *Δt*)) will be approximately
    equal to the derivative of velocity at time *t*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/222equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rearranging this equation leads to the *Euler method* for solving a first-order
    differential equation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/222equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Euler method approximates the velocity at *t* + *Δ t* by the sum of the
    velocity at *t* and the product of the derivative at *t* with the time step *Δt*.
    The Euler method gives a way to find velocity at a later time from velocity at
    an earlier time if we know the derivative of velocity at the earlier time.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-7](ch14.xhtml#ch14fig7) pictorially describes the Euler method for
    solving Newton’s second law.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/223fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-7: Euler method for Newton’s second law in one dimension, for the
    special case in which net force depends only on velocity*'
  prefs: []
  type: TYPE_NORMAL
- en: The diagram shows how data is acted on by pure functions to compute the velocity
    of the object at different times. Because the diagram employs only pure functions
    (functions that do nothing but return an output from inputs and unchanging global
    values), we refer to this as a *functional diagram*. Whereas the schematic diagram
    in [Figure 14-6](ch14.xhtml#ch14fig6) presents time as continuous, this diagram
    shows time as discrete. And whereas the schematic diagram has wires with values
    that are continuously changing in time, the functional diagram has wires with
    values that do not change. Different points in time have different wires in the
    functional diagram. While a schematic diagram may contain the stateful integrator
    from [Figure 6-5](ch06.xhtml#ch6fig5), a functional diagram uncoils and replaces
    the integrator with a discrete, functional model like the one in [Figure 6-7](ch06.xhtml#ch6fig7).
    We can see from [Figure 14-7](ch14.xhtml#ch14fig7) that the same set of computations
    occurs at each time step to produce a new velocity from an old velocity. We call
    the set of computations that occurs at each time step the *velocity-update function*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-8](ch14.xhtml#ch14fig8) shows the velocity-update function, which
    is based on the application of the Euler method to one small time step.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/224fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-8: Velocity-update function used in the Euler method for solving
    Newton’s second law with forces that depend only on velocity*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-8](ch14.xhtml#ch14fig8) shows a functional diagram for velocity
    update, visually describing how velocity at *t* + Δ*t* is computed from velocity
    at *t* and the forces.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the velocity-update equation showing how a new velocity is obtained
    from an old velocity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/224equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Lastly, we have the Haskell function `updateVelocity`, which advances the value
    of the velocity by one time step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The functional diagram in [Figure 14-8](ch14.xhtml#ch14fig8), the velocity-update
    equation (Equation 14.12), and the function `updateVelocity` express the same
    information in different forms, namely how to take one step in time with the Euler
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Now we want to write a function `velocityFv`, similar to `velocityCF` and `velocityFt`,
    but for the case of forces that depend on velocity. To think of `updateVelocity`
    as a function that takes `Velocity` as input and gives `Velocity` as output, we
    want to think of the time step, mass, and list of force functions as parameters.
    The function `updateVelocity dt m fs` has type `Velocity -> Velocity` and plays
    the role of the iterable function `f` in [Figure 6-4](ch06.xhtml#ch6fig4) on [page
    203](part02.xhtml#page_203).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We define a local variable `numSteps` to be the number of time steps we need
    to take to get as close as possible to the desired time `t`. We iterate the function
    `updateVelocity dt m fs`, starting at the initial velocity `v0`, and then select
    the single value of velocity from this infinite list that is closest to the desired
    time.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of a situation with forces that depend only on velocity, let’s
    consider a bicycle rider heading north on a flat, level road. We’ll consider two
    forces in this situation. First, there is the northward force that the road exerts
    on the tires of the bicycle because the rider is working the pedals. Let us call
    this force *F*[rider] (it is directly produced by the road on the bike, but it
    is indirectly produced by the rider), and assume that this force is a constant
    100 N. Second, there is the southward force of air resistance that impedes the
    northward progress of the rider, especially when she is traveling quickly. We’ll
    use the expression for air resistance that we developed in the previous section
    with Equation 14.9\. The net force is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/225equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s take the mass of the bike plus rider to be *m* = 70 kg. We’ll choose a
    drag coefficient of *C* = 2, take the density of air to be *ρ* = 1.225 kg/m³,
    and approximate the cross-sectional area of bike and rider to be 0.6 m². Starting
    from rest, our mission is to find the velocity of the bike as a function of time.
  prefs: []
  type: TYPE_NORMAL
- en: Before we use our Haskell functions to investigate the motion of the bike, we’re
    going to show how to use the Euler method by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Euler Method by Hand
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s use the Euler method by hand to compute the first several values of velocity
    for the bike. The purpose in doing this is to get a clear understanding of what
    is happening in the Euler method, so the code we write will be meaningful and
    not just a formal representation of some abstract vague process. We choose a time
    step of 0.5 s. Our mission is to complete the following table. We can fill in
    all of the time values because they are simply spaced at 0.5 s intervals. The
    initial velocity is 0, so we fill that in as well.
  prefs: []
  type: TYPE_NORMAL
- en: '| **t (s)** | **v(t) (m/s)** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0.0 | 0.0000 |'
  prefs: []
  type: TYPE_TB
- en: '| 0.5 |  |'
  prefs: []
  type: TYPE_TB
- en: '| 1.0 |  |'
  prefs: []
  type: TYPE_TB
- en: '| 1.5 |  |'
  prefs: []
  type: TYPE_TB
- en: We will complete the table by using Equation 14.12 to update the velocity over
    and over again. To compute the velocity at 0.5 s, we choose *t* = 0 in Equation
    14.12.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/226equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We update the table with
  prefs: []
  type: TYPE_NORMAL
- en: '| **t (s)** | **v(t) (m/s)** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0.0 | 0.0000 |'
  prefs: []
  type: TYPE_TB
- en: '| 0.5 | 0.7143 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.0 |  |'
  prefs: []
  type: TYPE_TB
- en: '| 1.5 |  |'
  prefs: []
  type: TYPE_TB
- en: 'and then we calculate *v*(1.0 s) using Equation 14.12 with *t* = 0.5 s:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/226equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We add this to the appropriate row of the table and continue.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/226equ03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The completed table looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **t (s)** | **v(t) (m/s)** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0.0 | 0.0000 |'
  prefs: []
  type: TYPE_TB
- en: '| 0.5 | 0.7143 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.0 | 1.4259 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.5 | 2.1295 |'
  prefs: []
  type: TYPE_TB
- en: Euler Method in Haskell
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’ll use the `velocityFv` function to calculate velocity for the bike.
    Here is a velocity function for the bike with a time step of 1 s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The higher-order function `const` can be used to make a constant function. The
    function `const 100` takes one input, ignores it, and returns 100 as output. It
    is equivalent to the anonymous function `\_ -> 100`. We’re using it here to represent
    the constant force of 100 N.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the data that must be supplied to solve the bike problem. We provide
    the 70-kg mass, the 0 m/s initial velocity of the bike, and the two forces: `const
    100`, a constant force of 100 N, and `fAir 2 1.225 0.6`, which is the force of
    air resistance with a drag coefficient of 2, an air density of 1.225 kg/m³, and
    a cross-sectional area of 0.6 m².'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code to produce a graph of velocity versus time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The code plots the `bikeVelocity` function, including a title and axis labels,
    and makes a PNG file that can be included in another document. [Figure 14-9](ch14.xhtml#ch14fig9)
    contains the graph itself.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/228fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-9: Bike velocity as a function of time. The stair-stepping look
    can be fixed and is discussed in the text.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A phenomenon occurs in [Figure 14-9](ch14.xhtml#ch14fig9) that does not occur
    in constant acceleration situations: the establishment of a terminal velocity.
    After 20 seconds or so, the forward force of the road (from the pedaling) matches
    the backward force of the air. At this point we have no net force (or a very small
    net force), and the velocity stays at the terminal velocity.'
  prefs: []
  type: TYPE_NORMAL
- en: Why the stair-stepping look to [Figure 14-9](ch14.xhtml#ch14fig9)? We used a
    time step of one second to do the calculation of the velocity function `bikeVelocity`,
    but then we asked the `plotFunc` function to give us a plot of that function every
    half a second. If we want a smooth plot, we have a couple of options. The simplest
    would be to ask for a plot with time values spaced at least one second apart.
    Alternatively, we could calculate the `bikeVelocity` function using a smaller
    time step. In any case, we shouldn’t ask for more resolution in the graph than
    we asked for in the function we are graphing.
  prefs: []
  type: TYPE_NORMAL
- en: With the functions `velocityFv` and `positionFv`, the latter of which you are
    asked to write in Exercise 14.4, we have general-purpose tools for solving any
    Newton’s second law type problem in one spatial dimension with forces that depend
    only on velocity. Before we turn to the case in which forces depend on both time
    and velocity, let’s take a moment to view what we’ve just done from a broader
    perspective.
  prefs: []
  type: TYPE_NORMAL
- en: The State of a Physical System
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A fruitful way to structure our thinking about Newton’s second law, and also
    later about the Maxwell equations, revolves around the concept of the *state*
    of a physical system, which is the collection of information needed to say precisely
    what is going on with the system *at a particular instant of time*.
  prefs: []
  type: TYPE_NORMAL
- en: The state represents the current “state of affairs” of the system, containing
    enough information that future prediction can be based on the current state instead
    of past information about the system. The state evolves in time, changing according
    to some rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a physical system that we wish to understand, the state-based paradigm
    suggests the following conceptual division:'
  prefs: []
  type: TYPE_NORMAL
- en: What information is required to specify the state of the system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the state at some initial time?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By what rule does the state change with time?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we treated Newton’s second law with constant forces and forces that depend
    only on time, we did not use a state-based method because we did not need one.
    In those cases, we could use algebra or integration to find how the position and
    velocity of our object changed in time. When we looked at forces that depend on
    velocity, we had a schematic diagram with a loop that corresponded to a differential
    equation, shown in [Figure 14-6](ch14.xhtml#ch14fig6). The state-based method
    is particularly useful for differential equations.
  prefs: []
  type: TYPE_NORMAL
- en: There are three things to notice about [Figure 14-6](ch14.xhtml#ch14fig6) that
    relate to the state-based method. First, notice that there is one integrator in
    the loop and that this integrator holds the value of velocity as state. Second,
    notice that the differential equation, Equation 14.10, gives an expression for
    the rate of change of velocity. Lastly, notice that the forces depend on velocity.
    For these three reasons, in the case where forces depend only on velocity, the
    state of the object consists of the velocity of the object.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the answer to question 1 is a data type. The state of an object
    experiencing forces that depend only on the object’s velocity is a value of the
    data type `Velocity`. In the next section, where forces depend on time and velocity,
    the data type we will use for state is the pair `(Time,Velocity)`. As we consider
    more complex physical situations, the data type we use to hold the state of our
    physical system will contain more information.
  prefs: []
  type: TYPE_NORMAL
- en: Question 2 above is, in some sense, the smallest question. It may even be possible
    to do some analysis without an answer to question 2\. But if we wish to know properties
    of a system at a later time, then we wish to know the state at a later time, and
    this typically requires knowing the state at some earlier time. The answer to
    question 2 is a value of the data type from question 1.
  prefs: []
  type: TYPE_NORMAL
- en: Question 3 requires a physical theory to answer. In the case of mechanics, Newton’s
    second law gives the rule by which the state changes in time.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how the state-based method applies in the case where the forces on
    an object depend only on time and the velocity of the object.
  prefs: []
  type: TYPE_NORMAL
- en: Second Law with Forces That Depend on Time and Velocity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next situation for Newton’s second law is when the forces depend on both
    time and velocity but not on position. The force functions depend on two variables,
    time and velocity. We use ![Image](Images/e0230-01.jpg) to denote the *j*th function
    of two variables that gives a force when supplied with time and velocity, and
    we use ![Image](Images/e0230-02.jpg) to denote the function of two variables that
    gives net force when supplied with time and velocity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/230equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 14-10](ch14.xhtml#ch14fig10) shows a schematic diagram for Newton’s
    second law with forces that depend on time and velocity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/230fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-10: Newton’s second law with forces that depend on time and velocity*'
  prefs: []
  type: TYPE_NORMAL
- en: The schematic diagram contains a loop, so Newton’s second law is a differential
    equation, given in Equation 14.14.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/230equ02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that there is one integrator in the loop in [Figure 14-10](ch14.xhtml#ch14fig10),
    which holds the value of velocity as state. There is a way to solve this differential
    equation using only velocity as the state of the object. However, since the rate
    of change of velocity in Equation 14.14 depends on both time and velocity (because
    the forces depend on time and velocity), the state-based method is simpler to
    apply if we allow both time and velocity to be *state variables*. This is to say
    that the data type we will use for state is `(Time,Velocity)`. The difference
    between Equation 14.10, which expresses Newton’s second law with forces that depend
    only on velocity, and Equation 14.14, which expresses Newton’s second law with
    forces that depend on time and/or velocity, is simply that we need to know the
    current value of time in the latter case but not in the former. Including time
    in the state `(Time,Velocity)` is a simple way to gain convenient access to the
    current time.
  prefs: []
  type: TYPE_NORMAL
- en: Which quantities deserve to be called state variables? Say I have a particle
    in space acted on by a known (time-independent) force law. The state variables
    are the position and velocity because we can calculate the position and velocity
    at the next time instant from them. Why is acceleration not a state variable?
    To use the terminology of earlier sections in this chapter, state variables are
    numbers that identify a particular solution to the differential equation—they
    are the initial values that convert integrals into antiderivatives. Time is usually
    not considered a state variable, but taking it as one makes it easier to think
    about time-dependent forces. Readers interested in a more in-depth discussion
    of state variables and their uses are encouraged to see [**[16](bib.xhtml#bib16)**]
    and [**[17](bib.xhtml#bib17)** ].
  prefs: []
  type: TYPE_NORMAL
- en: The Haskell function `newtonSecondTV`, shown below, expresses Newton’s second
    law in the case where forces depend on time and velocity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Given the mass of an object and a list of forces that act on the object, now
    expressed as functions of the state `(Time,Velocity)`, `newtonSecondTV` gives
    instructions for computing the time derivatives of the state variables from the
    state variables themselves. The return type `(R,R)` is meant to stand for time
    derivative of time, which is always the dimensionless number 1, and time derivative
    of velocity, which is acceleration. The acceleration is computed from Newton’s
    second law by finding the net force and dividing by the mass.
  prefs: []
  type: TYPE_NORMAL
- en: To solve Equation 14.14, we will discretize time and use the Euler method. We’ll
    continue to use Equation 14.11 for the Euler method. [Figure 14-11](ch14.xhtml#ch14fig11)
    pictorially describes the Euler method for solving Newton’s second law when forces
    depend on time and/or velocity.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/232fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-11: Euler method for Newton’s second law in one dimension, for the
    special case in which net force depends only on time and/or velocity*'
  prefs: []
  type: TYPE_NORMAL
- en: The diagram shows how functions act on the state variables at one point in time
    to compute the state variables at the next point in time. The same set of computations
    reoccurs at each time step to produce a new state from an old state. We call the
    set of computations that occurs at each time step the *state-update function*.
  prefs: []
  type: TYPE_NORMAL
- en: The state-update function is shown pictorially in [Figure 14-12](ch14.xhtml#ch14fig12).
    The figure shows a functional diagram for state update, visually describing how
    time and velocity at *t* + Δ*t* are computed from time and velocity at *t*, given
    the force functions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/232fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-12: Euler method update for Newton’s second law with forces that
    depend only on time and velocity*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the state-update equations showing how the new state variables are
    obtained from the old state variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/233equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Equations 14.15 and 14.16 are state-update equations for an object exposed
    to forces that depend on time and velocity. The state-update equations tell us
    how the state variables time and velocity must be updated to advance to the next
    time step. The time update in Equation 14.15 is easy: we just add *Δt* to the
    old time to get the new time. To update the velocity in Equation 14.16, we compute
    an acceleration, multiply by a time step to get a change in velocity, and add
    that change to the old velocity. Applying these state-update equations is how
    we carry out the Euler method for solving a differential equation. This state-update
    procedure is the main tool we will use to solve problems in Newtonian mechanics.'
  prefs: []
  type: TYPE_NORMAL
- en: The following Haskell function `updateTV`, named because it updates both time
    and velocity, advances the value of the state by one time step.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The function `updateTV` takes a few parameters and produces a function with
    type `(Time,Velocity) -> (Time,Velocity)`. The third input of `updateTV`, named
    `fs` with type `[(Time,Velocity) -> Force]`, could have been an input with type
    `[Time -> Velocity -> Force]`; it’s a matter of style, and either choice will
    work just fine. Here I chose the former, as time and velocity are already paired
    in the function output.
  prefs: []
  type: TYPE_NORMAL
- en: The time-velocity pair we are passing around in this function represents the
    state of the object to which we are applying Newton’s second law. The function
    `updateTV` is then an example of a state-update function. In an earlier section,
    when forces depended only on velocity, the velocity alone acted as state, and
    the function `updateVelocity` was the appropriate state-update function.
  prefs: []
  type: TYPE_NORMAL
- en: The functional diagram in [Figure 14-12](ch14.xhtml#ch14fig12), Equations 14.15
    and 14.16, and the function `updateTV` express the same information in different
    forms, namely how to take one step in time with the Euler method.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on what we want to calculate, there are two things we might do with
    the `updateTV` function, corresponding to two types of representation of the time-velocity
    data. First, we may wish to produce a list of time-velocity pairs. Second, we
    may wish to produce velocity as a function of time. We’ll develop functions for
    these two purposes in the next two subsections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Method 1: Produce a List of States'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A list of time-velocity pairs can be regarded as a solution to a Newton’s second
    law problem with forces that depend on time and velocity because a time-velocity
    pair gives the state. The list of states contains a time-velocity pair for each
    time that has been probed by the Euler method in [Figure 14-11](ch14.xhtml#ch14fig11).
    The function `statesTV` produces a list of time-velocity pairs when given a time
    step, a mass, an initial state, and a list of force functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We use `iterate` to achieve the repeated composition in [Figure 14-11](ch14.xhtml#ch14fig11).
    But which function do we want to iterate? It’s not simply `updateTV` because `updateTV`
    takes three parameters as input before the time-velocity pair. The function we
    iterate must have type `a -> a`, or in this case `(Time,Velocity) -> (Time,Velocity)`.
    The solution is to give `updateTV` its first three parameters to form the function
    we send to `iterate`. The function we want to iterate is `updateTV dt m fs`, starting
    with the initial time-velocity pair `tv0`.
  prefs: []
  type: TYPE_NORMAL
- en: The function `statesTV` gives a general-purpose way of solving any Newton’s
    second law type problem in one spatial dimension with forces that depend only
    on time and velocity. By a solution, we mean an infinite list of states (time-velocity
    pairs) of the object, spaced one time step apart from each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Method 2: Produce a Velocity Function'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we want to write a function, `velocityFtv`, that is similar to `velocityCF`,
    `velocityFt`, and `velocityFv`, but for the case of forces that depend on time
    and velocity. We’ll use the infinite list produced by `statesTV`, picking out
    the particular time-velocity pair that comes closest to our desired time and using
    the Prelude function `snd` to return the velocity, unpaired from the time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With the functions `velocityFtv` and `positionFtv`, the latter of which you
    will be asked to write in Exercise 14.9, we have general-purpose ways of solving
    any Newton’s second law type problem in one spatial dimension with forces that
    depend only on time and velocity. Let’s now take a look at a situation that involves
    just such forces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Pedaling and Coasting with Air Resistance'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an example of a situation with forces that depend on time and velocity, let’s
    reconsider our child bicycle rider who is pedaling and coasting, but now in the
    presence of air resistance. We’ll consider two forces in this situation. First,
    there’s the time-dependent force *F*[pc](*t*) of pedaling from Equation 14.8\.
    Second, there’s the force of air resistance *F*[air](*v*[0]) that impedes the
    motion of the child, for which we’ll use Equation 14.9\. The net force is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/e0235-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The mass of the bike plus child is *m* = 20 kg. We’ll choose a drag coefficient
    of *C* = 2, take the density of air to be *ρ* = 1.225 kg/m³, and approximate the
    cross-sectional area of bike and rider to be 0.5 m². Starting from rest, our mission
    is to find the velocity of the bike as a function of time.
  prefs: []
  type: TYPE_NORMAL
- en: We update the velocity with Equation 14.16\. Before we use our Haskell functions
    to investigate the motion of the bike, we’ll show how to use the Euler method
    by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Euler Method by Hand
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s use the Euler method by hand to compute several values of velocity for
    the bike. Again, the purpose in doing the Euler method by hand is simply to get
    a clear picture of how the state variables get updated in the Euler method. We’ll
    pick a time step of 6 s, even though this is too big to get accurate results,
    as it is not small compared to relevant time scales, such as the 20-second cycle
    time. We choose a time step of 6 s so we can sample both pedaling and coasting
    over the first few time steps. Our mission is to complete the following table.
    We can fill in all of the time values because they are simply spaced at six-second
    intervals. The initial velocity is 0, so we’ll fill that in as well.
  prefs: []
  type: TYPE_NORMAL
- en: '| **t (s)** | **v(t) (m/s)** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|     0 | 0.0000 |'
  prefs: []
  type: TYPE_TB
- en: '|     6 |  |'
  prefs: []
  type: TYPE_TB
- en: '|   12 |  |'
  prefs: []
  type: TYPE_TB
- en: '|   18 |  |'
  prefs: []
  type: TYPE_TB
- en: The force of pedaling is either 10 N or 0 N, depending on the value of the time.
  prefs: []
  type: TYPE_NORMAL
- en: '*F*[pc](0 s) = *F*[pc](6 s) = 10 N'
  prefs: []
  type: TYPE_NORMAL
- en: '*F*[pc](12 s) = *F*[pc](18 s) = 0 N'
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeatedly applying Equation 14.16, we obtain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/236equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The completed table looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **t (s)** | **v(t) (m/s)** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0.0000 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 3.0000 |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | 4.3463 |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | 0.8752 |'
  prefs: []
  type: TYPE_TB
- en: Let’s turn now to Haskell, using each of the two methods we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Method 1: Produce a List of States'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here we’ll use the function `statesTV` to produce an infinite list of velocity-time
    pairs called `pedalCoastAir` for the child on the bike.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Notice the data that must be supplied to solve this problem. We provide a 0.1-s
    time step, the 20-kg mass, an initial state consisting of 0 for the time and 0
    for the velocity, and the two forces, expressed here as anonymous functions. The
    function `pedalCoast` is a function only of time, so it cannot be listed directly
    as a force function because a force function for `statesTV` takes a time-velocity
    pair as input. The underscores are present because the pedaling function does
    not depend on the second item in the state, which happens to be velocity, and
    because air resistance does not depend on the first item in the state, which happens
    to be time.
  prefs: []
  type: TYPE_NORMAL
- en: A list of pairs is something we can plot with the `plotPath` function from the
    `gnuplot` library, but we need to truncate the list to a finite list before plotting,
    or `plotPath` will hang while trying to finish calculating an infinite list. In
    `pedalCoastAirGraph` below, we use the `takeWhile` function to extract the states
    with times less than or equal to 100 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This code produces [Figure 14-13](ch14.xhtml#ch14fig13), which shows the velocity
    as a function of time for the child pedaling and coasting in the presence of air
    resistance.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/237fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-13: Pedaling and coasting with air resistance*'
  prefs: []
  type: TYPE_NORMAL
- en: As expected, the child’s speed increases during the pedaling intervals and decreases
    during the coasting intervals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Method 2: Produce a Velocity Function'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s use the function `velocityFtv` to produce a velocity function for
    the child on the bike.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The data we give to `pedalCoastAir2` is the same data we gave to `pedalCoastAir`.
    Because `pedalCoastAir2` is a function `R -> R`, it can be plotted with the `plotFunc`
    function from the `gnuplot` package. It would produce the same graph as that in
    [Figure 14-13](ch14.xhtml#ch14fig13).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter discussed Newton’s first law and introduced Newton’s second law
    in the context of one-dimensional motion. The chapter presented a sequence of
    increasingly sophisticated settings for Newton’s second law. Easiest among them
    is when the forces on an object are constant, that is, unchanging in time. Next
    is when the forces on an object depend only on time, in which case we can apply
    integration to find the velocity and the position of the object. Forces that depend
    on velocity, such as the air resistance introduced in this chapter, require that
    we solve a differential equation, which is a more complex task than integration.
    The chapter also introduced the Euler method for solving a first-order differential
    equation. The Euler method, along with Newton’s second law, provides a rule for
    updating the state of the object we are tracking, allowing us to predict its future
    motion. The choice of state variables, or physical quantities contained in the
    state, is determined by what the forces depend on. If forces depend only on velocity,
    then velocity alone can serve as the particle state. If forces depend on time
    and velocity, we use time and velocity as state variables.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we allow the forces to depend on position as well as time
    and velocity. This produces a second-order differential equation and requires
    that time, position, and velocity all be state variables.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 14.1.** Write a function `velocityCF''` that does the same thing
    and has the same type signature as `velocityCF`, but in which the time `t :: Time`
    is listed explicitly on the left of the equal sign in the definition.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Exercise 14.2.** Using the `positionCF` function, make a graph for the position
    of the car on the air track in Example 14.1 as a function of time. Assume the
    initial position of the car is – 1 m.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 14.3.** Write a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: that adds a list of functions to produce a function that represents the sum.
    Replace `undefined` with your code, and feel free to include one or two variables
    to the left of the equal sign in the definition. Using `sumF`, we could write
    the first line in the `let` construction of `velocityFt` as `fNet = sumF fs`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 14.4.** Write a Haskell function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: that returns a position function for a Newton’s second law situation in which
    the forces depend only on the velocity. Replace the `undefined` with your code,
    and feel free to include variables to the left of the equal sign in the definition.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 14.5.** Any Newton’s second law problem that can be solved with
    `velocityFv` can also be solved with `velocityFtv`. Rewrite the `bikeVelocity`
    function so that it uses `velocityFtv` instead of `velocityFv`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 14.6.** Doing the Euler method by hand on [page 225](ch14.xhtml#page_225),
    we found the velocity after 1.5 s to be *v*(1.5 s) = 2.1295 m/s. Use the `velocityFv`
    function to calculate this same number.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 14.7.** Doing the Euler method by hand on [page 235](ch14.xhtml#page_235),
    we found the velocity after 18 s to be *v*(18 s) = 0.8752 m/s. Use `statesTV`
    or `velocityFtv` to calculate this same number.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 14.8.** Fix the stair-stepping issue in [Figure 14-9](ch14.xhtml#ch14fig9)
    so that a smooth plot appears.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 14.9.** Write a Haskell function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: that returns a position function for a Newton’s second law situation in which
    the forces depend only on time and velocity. Replace the `undefined` with your
    code, and feel free to include variables to the left of the equal sign in the
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 14.10.** Produce a graph of position versus time for the situation
    in [Figure 14-13](ch14.xhtml#ch14fig13).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 14.11.** To deepen our understanding of the Euler method, we’ll
    do a calculation by hand (using only a calculator and not the computer).'
  prefs: []
  type: TYPE_NORMAL
- en: Consider a 1-kg mass exposed to two forces. The first force is an oscillatory
    force, pushing first one way and then the other. With *t* in seconds, the force
    in Newtons is given by
  prefs: []
  type: TYPE_NORMAL
- en: '*F*[1](*t*) = 4 cos 2*t*'
  prefs: []
  type: TYPE_NORMAL
- en: The second force is an air resistance force in Newtons, given by
  prefs: []
  type: TYPE_NORMAL
- en: '*F*[2](*v*[0]) = –3*v*[0]'
  prefs: []
  type: TYPE_NORMAL
- en: where *v*[0] is the current velocity of the mass in meters per second.
  prefs: []
  type: TYPE_NORMAL
- en: The net force is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/e0240-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Suppose the mass is initially moving 2 m/s so that
  prefs: []
  type: TYPE_NORMAL
- en: '*v*(0 s) = 2 m/s'
  prefs: []
  type: TYPE_NORMAL
- en: Use the Euler method with a time step of Δ*t* = 0.1 s to approximate the value
    of *v*(0.3s). Keep at least four figures after the decimal point in your calculations.
    Show your calculations in a small table.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 14.12.** Write a Haskell function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: that takes a time-velocity pair (*t*[0], *v*[0]) and returns an updated time-velocity
    pair (*t*[1], *v*[1]) for a single step of the Euler method for a 1-kg object
    experiencing a net force of
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/e0240-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Use a time step of Δ*t* = 0.1 s. Show how to use the function updateExample
    to calculate the value *v*(0.3 s) that you calculated by hand in Exercise 14.11.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 14.13.** Consider a 1-kg object experiencing a net force'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/e0240-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'where *α* = 1 N s/m, subject to the initial condition *v*(0 s) = 8 m/s. Use
    the Euler method to find the velocity of the object over the time interval 0 s
    ≤*t* ≤ 10 s. Plot velocity as a function of time to see what it looks like. Compare
    your results to the exact solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/e0240-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Try out different time steps to see what happens when the time step gets too
    big.
  prefs: []
  type: TYPE_NORMAL
- en: Find a time step that is small enough that the Euler solution and the exact
    solution nicely overlap on a plot. Find another time step that is big enough that
    you can see the difference between the Euler solution and the exact solution on
    a plot.
  prefs: []
  type: TYPE_NORMAL
- en: Make a nice plot (with title, axis labels, and so on) with these three solutions
    on a single graph (bad Euler, good Euler, and exact). Label the Euler results
    with the time step you used and label the exact result “Exact.”
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 14.14.** Consider the differential equation'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/241equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: subject to the initial condition *v*(0) = 0\. This differential equation has
    no exact solution. Use the Euler method with a step size of Δ*t* = 0.01 to find
    *v*(*t*) over the interval 0 ≤*t* ≤ 3\. Make a nice plot of the resulting function
    and include the value *v*(3) to five significant figures.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 14.15.** Each wire in a functional diagram can be labeled with a
    type. Label each wire in [Figure 14-11](ch14.xhtml#ch14fig11) with a type.'
  prefs: []
  type: TYPE_NORMAL
