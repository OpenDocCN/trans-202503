<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="87" id="Page_87"/>5</span><br/>
<span class="ChapterTitle">Strings in WebAssembly</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="190" height="190"/>
</figure>
<p class="ChapterIntro">This chapter discusses how to handle strings in WAT because WebAssembly doesn’t have a built-in string data type as high-level languages do. To represent string data in WebAssembly, you must set linear memory to ASCII or Unicode character values. You need to know where you’re setting your data in linear memory and how many bytes the string will use.</p>
<p>In this chapter, we’ll look at the ASCII and Unicode character formats before we explore the relationship between string objects and how to store them in linear memory. You’ll learn how JavaScript can retrieve the strings from linear memory and output them to the command line. Once you know how to pass string data from WebAssembly to JavaScript, we’ll cover two popular methods for string management: null-terminated strings and length-prefixed strings, discussing the pros and cons of each technique. You’ll learn how to copy a string from one location in linear memory to <span epub:type="pagebreak" title="88" id="Page_88"/>another using a byte-by-byte copy and a 64-bit copy. Then you’ll convert integer data into number strings in decimal, hexadecimal, and binary formats.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	For the most part, you don’t need to choose a specific address in linear memory to store your strings, as long as it falls within the number of pages you allocated. Unless otherwise mentioned, you can assume that a memory address was chosen arbitrarily.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501737c05-0001">ASCII and Unicode</h2>
<p class="BodyFirst">When working with strings in WebAssembly, you need to know which character set you’re using, because different sets look different in linear memory. <em>American Standard Code for Information Interchange (ASCII)</em> is a 7-bit character encoding system that supports up to 128 characters with an 8th bit that might be used for error checking or is simply set to 0. The ASCII character set works well if your code is only supporting the English language. </p>
<p><em>Unicode Transformation Format (UTF)</em> comes in 7-bit, 8-bit, 16-bit, and 32-bit flavors, which are called UTF-7, UTF-8, UTF-16, and UTF-32. UTF-7 and ASCII are identical. UTF-8 incorporates UTF-7 and allows for some additional Latin, Middle Eastern, and Asian characters by creating a flexible length format that allows for additional bytes when the starting byte of the format falls outside of the ASCII character set. UTF-16 is also a flexible length character set where most characters take up two bytes. Because some codes expand the number of bytes a character uses to four, UTF-16 supports more than 1.1 million characters. UTF-32 is a fixed 32-bit character set that supports more than 4 billion characters. In this book, we’ll work exclusively with the ASCII/UTF-7 character set because it’s simple to read and understand. </p>
<h2 id="h1-501737c05-0002">Strings in Linear Memory</h2>
<p class="BodyFirst">The only way to pass a string from WebAssembly to JavaScript is to create an array of character data inside a memory <code>buffer</code> object like we did in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span> with the hello world app. You can then pass a 32-bit integer into JavaScript that represents the location of that character data in the memory buffer. The only problem with this scheme is that it doesn’t tell JavaScript where the data ends. The C language manages this by using a null-terminating byte: a byte with a value of 0 (not a character 0) tells the program that the string ends in the previous byte. We’ll look at three ways to pass strings between WAT and JavaScript, including null-termination, and then look at how to copy strings.</p>
<h3 id="h2-501737c05-0001">Passing the String Length to JavaScript</h3>
<p class="BodyFirst">The most obvious way to work with strings is to pass a string position and a string length to JavaScript so JavaScript can extract the string from linear <span epub:type="pagebreak" title="89" id="Page_89"/>memory and can know when it ends. Create a new WAT file named <em>strings.wat</em> and add the code in <a href="#listing5-1" id="listinganchor5-1">Listing 5-1</a>.</p>
<p class="CodeLabel"><b>strings.wat(part 1 of 11)</b></p>
<pre><code>(module
<span class="LiteralGray">;; Imported JavaScript function (below) takes position and length</span>
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (import "env" "str_pos_len" (func $str_pos_len (param i32 i32)))
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (import "env" "buffer"   (memory 1))
<span class="LiteralGray">;; 30 character string</span>
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> (data (i32.const 256) "Know the length of this string")
<span class="LiteralGray">;; 35 characters</span>
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> (data (i32.const 384) "Also know the length of this string")

<span class="CodeAnnotationCode" aria-label="annotation5">5</span> (func (export "main")
<span class="LiteralGray">;; length of the first string is 30 characters</span>
 <span class="CodeAnnotationCode" aria-label="annotation6">6</span> (call $str_pos_len (i32.const 256) (i32.const 30))
<span class="LiteralGray">;; length of the second string is 35 characters</span>
 <span class="CodeAnnotationCode" aria-label="annotation7">7</span> (call $str_pos_len (i32.const 384) (i32.const 35))
 )
)</code></pre>
<p class="CodeListingCaption"><a id="listing5-1">Listing 5-1</a>: Passing strings from WebAssembly to JavaScript</p>
<p>This module imports a JavaScript function we’ll create called <code>"str_pos_len"</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, which finds a string in the memory buffer using a combination of the string’s position and its location in linear memory. We also need to import a memory buffer we’ll declare in JavaScript <span class="CodeAnnotation" aria-label="annotation2">2</span>.</p>
<p>Next, we define two strings in memory: <code>"Know the length of this string"</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> and <code>"Also know the length of this string"</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>. The two strings specify that we need to know the length of those strings because they’re just character arrays in linear memory and we need to indicate where they begin and end. The first string has 30 characters and the second has 35. Later, in the <code>"main"</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> function, we call <code>$str_pos_len</code> twice. The first time <span class="CodeAnnotation" aria-label="annotation6">6</span>, we pass in the position of the first string in memory <code>(i32.const</code><code> 256)</code> followed by the length of that string <code>(i32.const 30)</code>. This tells the JavaScript we’ll write in a moment to extract 30 bytes starting at memory position 256 into a string and display it to the console. The second time we call <code>$str_pos_len</code> <span class="CodeAnnotation" aria-label="annotation7">7</span>, we pass in the position of the second string in memory <code>(i32.const 384)</code> followed by the length of that string <code>(i32.const</code><code> 35)</code>. The JavaScript then displays the second string to the console. Compile the WebAssembly module using the command in <a href="#listing5-2" id="listinganchor5-2">Listing 5-2</a>.</p>
<pre><code>wat2wasm strings.wat</code></pre>
<p class="CodeListingCaption"><a id="listing5-2">Listing 5-2</a>: Compiling <em>strings.wat</em></p>
<p>Once you’ve compiled your WebAssembly module, create a JavaScript file named <em>strings.js</em> and enter the code in <a href="#listing5-3" id="listinganchor5-3">Listing 5-3</a>.</p>
<p class="CodeLabel"><b>strings.js(part 1 of 3)</b></p>
<pre><code>const fs = require('fs');
const bytes = fs.readFileSync(__dirname + '/strings.wasm');

let memory = new WebAssembly.Memory( {initial: 1 });

<span epub:type="pagebreak" title="90" id="Page_90"/>let importObject = {
  env: {
    buffer: memory,
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> str_pos_len: function(str_pos, str_len) {
    <span class="CodeAnnotationCode" aria-label="annotation2">2</span> const bytes = new Uint8Array( memory.buffer,
                                    str_pos, str_len );
    <span class="CodeAnnotationCode" aria-label="annotation3">3</span> const log_string = new TextDecoder('utf8').decode(bytes);
      <span class="CodeAnnotationCode" aria-label="annotation4">4</span> console.log(log_string);
    }
  }
};

( async () =&gt; {
  let obj = await WebAssembly.instantiate( new Uint8Array(bytes),
                                           importObject );

  let main = obj.instance.exports.main;

  main();
})();</code></pre>
<p class="CodeListingCaption"><a id="listing5-3">Listing 5-3</a>: JavaScript that calls the WebAssembly string function</p>
<p>Inside the <code>importObject </code>we define <code>str_pos_len</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, which takes the position of the string in memory and its length. It uses the position of the length to retrieve an array of bytes <span class="CodeAnnotation" aria-label="annotation2">2</span> of the length provided. We use a <code>TextDecoder</code> to convert that byte array into a string <span class="CodeAnnotation" aria-label="annotation3">3</span>. Then we call <code>console.log</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> to display the string. When you run the JavaScript, you should see the message in <a href="#listing5-4" id="listinganchor5-4">Listing 5-4</a>.</p>
<pre><code>Know the length of this string
Also know the length of this string</code></pre>
<p class="CodeListingCaption"><a id="listing5-4">Listing 5-4</a>: String length output</p>
<p>Next, we’ll discuss null-terminated strings, which is a method for tracking string length that languages such as C/C++ use.</p>
<h3 id="h2-501737c05-0002">Null-Terminated Strings</h3>
<p class="BodyFirst">The second method of passing strings is <em>null-terminated</em><em> </em>(or <em>zero-terminated</em>) strings. Null-termination is a method for defining string length used by the C programming language. In a null-terminated string, you place a value of 0 as the last character in the array. The benefit of null-terminated strings is that you don’t have to know the string’s length as you’re using it. The downside is that this requires more computation when processing strings because your program needs to take the time to locate the terminating null byte. Let’s open the <em>strings.wat</em> file and add the code in <a href="#listing5-5" id="listinganchor5-5">Listing 5-5</a> for our null-terminated strings. First, we need to add an import of a <code>null_str</code> function that we’ll define later in the JavaScript.</p>
<span epub:type="pagebreak" title="91" id="Page_91"/>
<p class="CodeLabel"><b>strings.wat(part 2 of 11)</b></p>
<pre><code>(module
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (import "env" "str_pos_len" (func $str_pos_len (param i32 i32)))
<span class="LiteralGray">;; add line below</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (import "env" "null_str" (func $null_str (param i32)))
...</code></pre>
<p class="CodeListingCaption"><a id="listing5-5">Listing 5-5</a>: Modifying <em>strings.wat</em> from <a href="#listing5-1">Listing 5-1</a> to import the <code>null_str</code> function</p>
<p>Notice that unlike <code>str_pos_len</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, the <code>null_str</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> function only requires one <code>i32</code> parameter, because the code working with it only needs to know where the string begins in linear memory. It’s up to the code to figure out where that null byte is located to manipulate it.</p>
<p>Next, between the <code>import</code> statement that defines the buffer and the <code>(data</code><code>)</code> expression that defines the earlier strings, in <a href="#listing5-6" id="listinganchor5-6">Listing 5-6</a> we add two more data expressions that define null-terminated strings.</p>
<p class="CodeLabel"><b>strings.wat(part 3 of 11)</b></p>
<pre><code>...
  (import "env" "buffer" (memory 1))
<span class="LiteralGray">;; add the two lines below</span>
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (data (i32.const 0) "null-terminating string\00")
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (data (i32.const 128) "another null-terminating string\00")

  (data (i32.const 256) "Know the length of this string")
...</code></pre>
<p class="CodeListingCaption"><a id="listing5-6">Listing 5-6</a>: Modifying <em>strings.wat </em>from <a href="#listing5-1">Listing 5-1</a> to add null-terminated string data</p>
<p>The first data defines the string <code>"null terminating string\00"</code><span class="CodeAnnotation" aria-label="annotation1">1</span>. Notice the last three characters <code>\00</code>. The <code>\</code> character is the escape character in WAT. If you follow an escape character with two hexadecimal digits, it defines a numeric byte with the value you specify. That means that <code>\00</code> represents a single byte with a value of <code>0</code>. The second data expression creates the string <code>"another null terminating string\00"</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, which is also null-terminated and ending with <code>\00</code>.</p>
<p>In <a href="#listing5-7" id="listinganchor5-7">Listing 5-7</a>, we add two lines in the beginning of the <code>main</code> function to call the imported <code>$null_str</code> JavaScript function, passing it the location in linear memory of the null-terminated strings.</p>
<p class="CodeLabel"><b>strings.wat (part 4 of 11)</b></p>
<pre><code>...
(func (export "main")
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (call $null_str (i32.const 0))<b>  </b> <span class="LiteralGray">;; add this line</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (call $null_str (i32.const 128)) <span class="LiteralGray">;; add this line</span>

    (call $str_pos_len (i32.const 256) (i32.const 30))
...</code></pre>
<p class="CodeListingCaption"><a id="listing5-7">Listing 5-7</a>: Modifying <em>strings.wat</em> from <a href="#listing5-1">Listing 5-1</a> to call the <code>null_str</code> function</p>
<p>We pass in a value of <code>0</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, which is the location in memory where we defined the string <code>"null terminating string\00"</code>. Then we pass in the value <code>128</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, where we defined the string <code>"another null terminating string\00"</code>.</p>
<p><span epub:type="pagebreak" title="92" id="Page_92"/>Once you’ve made those changes in your WAT file, open <em>strings.js</em> to add some more code. First, add a new function to the <code>env</code> object nested in <code>importObject</code>, as shown in <a href="#listing5-8" id="listinganchor5-8">Listing 5-8</a>.</p>
<p class="CodeLabel"><b>strings.js (part 2 of 3)</b></p>
<pre><code>...
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> const max_mem = 65535;<b> </b><span class="LiteralGray">// add this line</span>

  let importObject = {
  env: {
    buffer: memory,
    <span class="LiteralGray">// add the null_str function to the importObject here</span>
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> null_str: function(str_pos)<b> { </b><span class="LiteralGray">// add this function</span>
    <span class="CodeAnnotationCode" aria-label="annotation3">3</span> let bytes = new Uint8Array( memory.buffer,
                                  str_pos, max_mem-str_pos );
      
    <span class="CodeAnnotationCode" aria-label="annotation4">4</span> let log_string = new TextDecoder('utf8').decode(bytes);
    <span class="CodeAnnotationCode" aria-label="annotation5">5</span> log_string = log_string.split("\0")[0];
    <span class="CodeAnnotationCode" aria-label="annotation6">6</span> console.log(log_string);
    }, <span class="LiteralGray">// end of function</span>
    str_pos_len: function(str_pos, str_len) {
...</code></pre>
<p class="CodeListingCaption"><a id="listing5-8">Listing 5-8</a>: The <code>null_str</code> function added to <code>importObject</code> in <em>strings.js</em> from <a href="#listing5-3">Listing 5-3</a></p>
<p>The code starts by defining the maximum possible length of the string in the variable <code>max_mem</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. To find the string that’s null terminated, we decode a chunk of linear memory with the maximum string length into one long string, and then use JavaScript’s split function to get the null-terminated string. Inside the <code>env</code> object, we add another function called <code>null_str</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> that takes a single <code>str_pos</code> parameter. JavaScript then needs to extract an array of bytes from the memory buffer starting at the position specified by the <code>str_pos</code> parameter passed into the function. We cannot search through the memory buffer until we convert it into a string. But before converting it to a string, we need to convert it into an array of bytes <span class="CodeAnnotation" aria-label="annotation3">3</span>. Then we create a <code>TextDecoder</code> object to decode those bytes into one long string <span class="CodeAnnotation" aria-label="annotation4">4</span>.</p>
<p>We split the string into an array using the null byte <code>"\0"</code> <span class="CodeAnnotation" aria-label="annotation5">5</span>. Splitting on the null byte creates an array of strings that terminate in the null byte. Only the first item in the array is an actual string we defined. We’re using the split as a quick and dirty way to take the string out of linear memory. We then set <code>log_string</code> to the first string in the array. We call the JavaScript <code>console.log</code> function <span class="CodeAnnotation" aria-label="annotation6">6</span>, passing it <code>log_string</code> to display that string to the console. Because we’re calling it with two different strings from WebAssembly, we should now have the four messages in <a href="#listing5-9" id="listinganchor5-9">Listing 5-9</a> logged to the console.</p>
<pre><code>null-terminating string
another null-terminating string
Know the length of this string
Also know the length of this string</code></pre>
<p class="CodeListingCaption"><a id="listing5-9">Listing 5-9</a>: Output from null-terminating strings</p>
<h3 id="h2-501737c05-0003"><span epub:type="pagebreak" title="93" id="Page_93"/>Length-Prefixed Strings</h3>
<p class="BodyFirst">A third way to store a string in memory is to include the length of the string at the beginning of the string data. A string created with this method is called a <em>length-prefixed string</em> and can improve processing performance. The way we’re prefixing limits the strings to a maximum length of 255 because a single byte of data can only hold a number between 0 and 255.</p>

<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<p class="BoxBodyFirst">You could encode the length in two bytes of data, which would allow strings of more than 65,000 characters. Just keep in mind that you must arrange the bytes in little-endian order. If you want to use a 16-bit number to encode the length, you must put the low-order byte ahead of the high-order byte. For example, if you want your string to have a length of 1024 (0400 in hex), you would need to encode it in little-endian order. Because little-endian byte order is flipped, in the string it would need to be encoded as \00\04. To make matters even more complicated, JavaScript doesn’t always use little-endian. In JavaScript, you need to check whether you’re dealing with big-endian or little-endian.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Let’s start by modifying the current <em>strings.wat</em> file, as shown in <a href="#listing5-10" id="listinganchor5-10">Listing 5-10</a>, to add a new import line for the <code>len_prefix</code> function we’ll define later in the JavaScript.</p>
<p class="CodeLabel"><b>strings.wat (part 5 of 11)</b></p>
<pre><code>(module
  (import "env" "str_pos_len" (func $str_pos_len (param i32 i32)))
  (import "env" "null_str" (func $null_str (param i32)))
<span class="LiteralGray">  ;; add the line below</span>
<span class="CodeAnnotationCode" aria-label="annotation1">1</span><b> </b>(import "env" "len_prefix" (func $len_prefix (param i32)))
...</code></pre>
<p class="CodeListingCaption"><a id="listing5-10">Listing 5-10</a>: Modifying <em>strings.wat</em> from <a href="#listing5-1">Listing 5-1</a> to add the <code>len_prefix</code> function import</p>
<p>The <code>len_prefix</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> function will take the first byte of the string to find the length. </p>
<p>Next, we add two new strings that begin with a hexadecimal number indicating their length. Add the code in <a href="#listing5-11" id="listinganchor5-11">Listing 5-11</a> to <em>strings.wat</em>.</p>
<p class="CodeLabel"><b>strings.wat (part 6 of 11)</b></p>
<pre><code>...
  (data (i32.const 384) "Also know the length of this string")

  <span class="LiteralGray">;; add the next four lines.  Two data elements and two comments</span>
<span class="LiteralGray">  ;; length is 22 in decimal, which is 16 in hex</span>
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (data (i32.const 512) "\16length-prefixed string")
<span class="LiteralGray">  ;; length is 30 in decimal, which is 1e in hex</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (data (i32.const 640) "\1eanother length-prefixed string")

<span epub:type="pagebreak" title="94" id="Page_94"/>  (func (export "main")
...</code></pre>
<p class="CodeListingCaption"><a id="listing5-11">Listing 5-11</a>: Modifying <em>strings.wat</em> from <a href="#listing5-1">Listing 5-1</a> to add length-prefixed string data</p>
<p>The first string, <code>"\16length-prefixed string"</code>, has 22 characters, so we prefix it with <code>\16</code> because 22 in decimal is 16 in hexadecimal <span class="CodeAnnotation" aria-label="annotation1">1</span>. The second string, <code>"\1eanother length-prefixed string"</code>, is 30 characters long, so we prefix it with a hexadecimal <code>\1e</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>.</p>
<p>Next, we need to add two calls to the imported <code>$len_prefix</code> function with the two memory locations where we just created the strings. The <code>"main"</code> function should now look like the code in <a href="#listing5-12" id="listinganchor5-12">Listing 5-12</a>.</p>
<p class="CodeLabel"><b>strings.wat (part 7 of 11)</b></p>
<pre><code>...
  (func (export "main")
    (call $null_str (i32.const 0))
    (call $null_str (i32.const 128))

    (call $str_pos_len (i32.const 256) (i32.const 30))
    (call $str_pos_len (i32.const 384) (i32.const 35))

  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> (call $len_prefix (i32.const 512))    <span class="LiteralGray">;; add this line</span>
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> (call $len_prefix (i32.const 640))    <span class="LiteralGray">;; add this line</span>

 )
...</code></pre>
<p class="CodeListingCaption"><a id="listing5-12">Listing 5-12</a>: Modifying <em>strings.wat</em> from <a href="#listing5-1">Listing 5-1</a> to add calls to the <code>$len_prefix</code> function</p>
<p>The first call to <code>$len_prefix</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> passes it the location of the data string <code>"\16length-prefixed string"</code> at memory location <code>512</code>. The second call <span class="CodeAnnotation" aria-label="annotation2">2</span> passes the location of the second length-prefixed string <code>"\1eanother length-prefixed string"</code> at memory location <code>640</code>. </p>
<p>Before we can run this, we need to add a new function to our JavaScript <code>importObject</code>. Open <em>strings.js</em> and add the <code>len_prefix</code> function to the <code>importObject</code>, as shown in <a href="#listing5-13" id="listinganchor5-13">Listing 5-13</a>.</p>
<p class="CodeLabel"><b>strings.js (part 3 of 3)</b></p>
<pre><code>...
let importObject = {
  env: {
    buffer: memory,
    null_str: function (str_pos) {
      let bytes = new Uint8Array(memory.buffer, str_pos,
                                 max_mem - str_pos);

      let log_string = new TextDecoder('utf8').decode(bytes);
      log_string = log_string.split("\0")[0];
      console.log(log_string);
    }, <span class="LiteralGray">// end null_str function    </span>
    str_pos_len: function (str_pos, str_len) {
      const bytes = new Uint8Array(memory.buffer,
        str_pos, str_len);
      const log_string = new TextDecoder('utf8').decode(bytes);
      console.log(log_string);
<span epub:type="pagebreak" title="95" id="Page_95"/>    },
<b>  </b><span class="CodeAnnotationCode" aria-label="annotation1">1</span> len_prefix: function (str_pos) {
    <span class="CodeAnnotationCode" aria-label="annotation2">2</span> const str_len = new Uint8Array(memory.buffer, str_pos, 1)[0];
    <span class="CodeAnnotationCode" aria-label="annotation3">3</span> const bytes = new Uint8Array(memory.buffer,
                                   str_pos + 1, str_len);
    <span class="CodeAnnotationCode" aria-label="annotation4">4</span> const log_string = new TextDecoder('utf8').decode(bytes);
      console.log(log_string);
    }
  }
};
...</code></pre>
<p class="CodeListingCaption"><a id="listing5-13">Listing 5-13</a>: Add the <code>len_prefix</code> function to <code>importObject</code> in <em>strings.js</em> from <a href="#listing5-3">Listing 5-3</a></p>
<p>The new <code>len_prefix</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> function takes in a string position and then takes the first byte from the position as a number in the constant <code>str_len</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>. It uses the value in <code>str_len</code> to copy the proper number of <code>bytes</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> from linear memory so it can decode them into the <code>log_string</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> it will log to the console.</p>
<p>Now that we have our WAT and JavaScript, we can compile the WAT module using <code>wat2wasm</code>, as shown in <a href="#listing5-14" id="listinganchor5-14">Listing 5-14</a>.</p>
<pre><code>wat2wasm strings.wat</code></pre>
<p class="CodeListingCaption"><a id="listing5-14">Listing 5-14</a>: Compile <em>strings.wat</em></p>
<p>Then we can run our JavaScript file using <code>node</code>, as shown in <a href="#listing5-15" id="listinganchor5-15">Listing 5-15</a>.</p>
<pre><code>node strings.js</code></pre>
<p class="CodeListingCaption"><a id="listing5-15">Listing 5-15</a>: Run <em>strings.js</em> using <code>node</code></p>
<p>You should see the output in <a href="#listing5-16" id="listinganchor5-16">Listing 5-16</a>.</p>
<pre><code>null-terminating string
another null-terminating string
Know the length of this string
Also know the length of this string
length-prefixed string
another length-prefixed string</code></pre>
<p class="CodeListingCaption"><a id="listing5-16">Listing 5-16</a>: Output from <em>strings.js</em></p>
<p>In the next section, you’ll learn how to copy strings using WAT.</p>
<h3 id="h2-501737c05-0004">Copying Strings</h3>
<p class="BodyFirst">The simplest way to copy a string from one location in linear memory to another is to loop over every byte of data, load it, and then store it in the new location. However, this method is slow. A more efficient method is to copy the strings eight bytes at a time using 64-bit integer loads and stores. Unfortunately, not all strings are multiples of eight bytes. To cover all cases as efficiently as possible, we’ll need a combination of a byte-by-byte copy and a faster 64-bit copy. </p>
<h4 id="h3-501737c05-0001"><span epub:type="pagebreak" title="96" id="Page_96"/>Byte-by-Byte Copy</h4>
<p class="BodyFirst">We’ll first write a function that does a slower byte-by-byte copy: it takes as parameters a source memory location, a destination memory location, and the length of the string we want to copy.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	On some platforms, performance of a function like this might suffer if the strings don’t have the proper byte alignment. Some hardware architectures require that you load and store data to and from addresses that are multiples of the bus size. For example, sometimes a processor with a 32-bit bus can only read from addresses that are multiples of four (4 bytes = 32 bits).  </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Let’s continue to add code to our <em>strings.wat </em>file. In <a href="#listing5-17" id="listinganchor5-17">Listing 5-17</a>, we add the function <code>$byte_copy</code> to the <em>strings.wat</em> file.</p>
<p class="CodeLabel"><b>strings.wat (part 8 of 11)</b></p>
<pre><code>...
(func $byte_copy
  (param $source i32) (param $dest i32) (param $len i32)
  (local $last_source_byte i32)

<span class="CodeAnnotationCode" aria-label="annotation1">1</span> local.get $source
  local.get $len
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> i32.add   <span class="LiteralGray">;; $source + $len</span>

  local.set $last_source_byte         <span class="LiteralGray">;; $last_source_byte = $source + $len</span>

  (loop $copy_loop (block $break
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> local.get $dest    <span class="LiteralGray">;; push $dest on stack for use in i32.store8 call</span>
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> (i32.load8_u (local.get $source)) <span class="LiteralGray">;; load a single byte from $source</span>
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> i32.store8                        <span class="LiteralGray">;; store a single byte in $dest</span>

  <span class="CodeAnnotationCode" aria-label="annotation6">6</span> local.get $dest
    i32.const 1
    i32.add
  <span class="CodeAnnotationCode" aria-label="annotation7">7</span> local.set $dest                   <span class="LiteralGray">;; $dest = $dest + 1</span>

    local.get $source
    i32.const 1
    i32.add
  <span class="CodeAnnotationCode" aria-label="annotation8">8</span> local.tee $source                 <span class="LiteralGray">;; $source = $source + 1</span>

    local.get $last_source_byte
    i32.eq
    br_if $break
    br $copy_loop
  ))<span class="LiteralGray"> ;; end $copy_loop</span>
)
...</code></pre>
<p class="CodeListingCaption"><a id="listing5-17">Listing 5-17</a>: A slow byte-by-byte method of copying strings added to <em>strings.wat</em> (<a href="#listing5-1">Listing 5-1</a>)</p>
<p>This <code>$byte_copy</code> function copies the block of memory from <code>$source</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> to <code>$source</code> + <code>$len</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> into the memory location <code>$dest</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> to <code>$dest</code> + <code>len</code> one byte at a time. This loop loads a byte from <code>$source</code> using the <code>(i32.load8_u</code><code>)</code> <span epub:type="pagebreak" title="97" id="Page_97"/>expression <span class="CodeAnnotation" aria-label="annotation4">4</span>. It then stores that byte in the <code>$dest</code> location using the <code>i32.store8</code> command <span class="CodeAnnotation" aria-label="annotation5">5</span>. Then we increment the destination location <span class="CodeAnnotation" aria-label="annotation6">6</span> in the <code>$dest</code> variable <span class="CodeAnnotation" aria-label="annotation7">7</span> and we increment the <code>$source</code> <span class="CodeAnnotation" aria-label="annotation8">8</span> variable to make those variables point to the next bytes in memory.</p>
<h4 id="h3-501737c05-0002">64-Bit Copy</h4>
<p class="BodyFirst">Copying a string byte-by-byte is slower than it needs to be, whereas a 64-bit integer is eight bytes long, and copying eight bytes at a time is significantly faster than copying a single byte at a time. We’ll write another function similar to <code>$byte_copy</code> that copies the data significantly faster by doing it eight bytes at a time. Unfortunately, not all strings have lengths that are multiples of eight. If a string has a length of 43 characters, we can copy the first 40 bytes using five separate eight-byte copies, but for the last three bytes, we’ll need to go back to the byte-by-byte copy method.</p>
<p>It’s important to note that these byte copies don’t prevent out of bounds memory access. The code will attempt to copy data to or from somewhere it shouldn’t. However, if you try to access data outside the bounds of linear memory, the WebAssembly security model will cause the read or write to fail, halting the code’s execution. As stated earlier, these functions weren’t intended to be general purpose, but instead are for demonstrating the different ways you can copy strings.</p>
<p>Add the 64-bit copy function <code>$byte_copy_i64</code> in <a href="#listing5-18" id="listinganchor5-18">Listing 5-18</a> to your <em>strings.wat</em> file.</p>
<p class="CodeLabel"><b>strings.wat (part 9 of 11)</b></p>
<pre><code>...
<span class="LiteralGray">;; add this block of code to the <var>strings.wat </var>file</span>
(func $byte_copy_i64
  (param $source i32) (param $dest i32) (param $len i32)
  (local $last_source_byte i32)

  local.get $source
  local.get $len
  i32.add

  local.set $last_source_byte

<b>  </b><b>(loop $copy_loop (block $break</b>
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> (i64.store (local.get $dest) (i64.load (local.get $source)))

<b>    </b>local.get $dest
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> i32.const 8
    i32.add
    local.set $dest<b>             </b><span class="LiteralGray">;; $dest = $dest + 8</span>

<b>    </b>local.get $source
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> i32.const 8
    i32.add
    local.tee $source<b>           </b><span class="LiteralGray">;; $source = $source + 8</span>

    local.get $last_source_byte
    i32.ge_u
<span epub:type="pagebreak" title="98" id="Page_98"/>    br_if $break
    br $copy_loop
  ))<b> </b><span class="LiteralGray">;; end $copy_loop</span>
)
...</code></pre>
<p class="CodeListingCaption"><a id="listing5-18">Listing 5-18</a>: A faster method of copying strings added to <em>strings.wat</em> (<a href="#listing5-2">Listing 5-2</a>)</p>
<p>The load and store functions are <code>(i64.load</code><code>)</code> and <code>(i64.store</code><code>)</code><span class="CodeAnnotation" aria-label="annotation1">1</span>, which load and store 64 bits (8 bytes) at a time. This method runs four to five times faster than loading and storing a single byte at a time (on x64 architecture). The other significant difference is that <code>$dest</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> and <code>$source</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> are incremented by <code>8</code> instead of <code>1</code>.</p>
<h4 id="h3-501737c05-0003">Combination Copy Function</h4>
<p class="BodyFirst">As mentioned earlier, not all strings are multiples of eight. Therefore, we’ll define a new, improved function in <a href="#listing5-19" id="listinganchor5-19">Listing 5-19</a> that copies eight bytes at a time using the <code>$byte_copy_i64</code> function and then copies the remaining bytes using <code>$byte_copy</code>, which copies a single byte at a time.</p>
<p class="CodeLabel"><b>strings.wat (part 10 of 11)</b></p>
<pre><code>...
(func $string_copy
  (param $source i32) (param $dest i32) (param $len i32)
  (local $start_source_byte i32)
  (local $start_dest_byte   i32)
  (local $singles           i32)
  (local $len_less_singles  i32)

  local.get $len
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> local.set $len_less_singles  <span class="LiteralGray">;; value without singles</span>

  local.get $len
  i32.const 7                  <span class="LiteralGray">;; 7 = 0111 in binary</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> i32.and
  local.tee $singles           <span class="LiteralGray">;; set $singles to last 3 bits of length</span>

<span class="CodeAnnotationCode" aria-label="annotation3">3</span> if                           <span class="LiteralGray">;; if the last 3 bits of $len is not 000</span>
    local.get $len
    local.get $singles
    i32.sub
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> local.tee $len_less_singles  <span class="LiteralGray">;; $len_less_singles = $len - $singles</span>

    local.get $source
    i32.add
    <span class="LiteralGray">;; $start_source_byte=$source+$len_less_singles</span>
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> local.set $start_source_byte

    local.get $len_less_singles
    local.get $dest
    i32.add
  <span class="CodeAnnotationCode" aria-label="annotation6">6</span> local.set $start_dest_byte  <span class="LiteralGray">;; $start_dest_byte=$dest+$len_less_singles</span>

  <span class="CodeAnnotationCode" aria-label="annotation7">7</span> (call $byte_copy (local.get $start_source_byte)
<span epub:type="pagebreak" title="99" id="Page_99"/>        (local.get $start_dest_byte)(local.get $singles))
  end

  local.get $len
<span class="CodeAnnotationCode" aria-label="annotation8">8</span> i32.const 0xff_ff_ff_f8 <span class="LiteralGray">;; all bits are 1 except the last three which are 0</span>
<span class="CodeAnnotationCode" aria-label="annotation9">9</span> i32.and                 <span class="LiteralGray">;; set the last three bits of the length to 0</span>
  local.set $len
<span class="CodeAnnotationCode" aria-label="annotationa">a</span> (call $byte_copy_i64 (local.get $source) (local.get $dest) (local.get $len))
)
...</code></pre>
<p class="CodeListingCaption"><a id="listing5-19">Listing 5-19</a>: Copy eight bytes at a time when possible and a single byte at a time when not.</p>
<p>As stated earlier, the <code>$string_copy</code> function must combine the eight-byte and single-byte copy functions to copy the string as quickly as possible. The <code>$len</code> parameter is the entire length of the string in bytes. The local variable <code>$len_less_singles</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> is the number of bytes that can be copied with the 64-bit copy. We get this number by masking off the last three bits. The <code>$singles</code> variable is the remaining three bits that aren’t in the multiples of eight and is set by performing a bitwise <code>(i32.and</code><code>)</code> expression <span class="CodeAnnotation" aria-label="annotation2">2</span> (hurray for bit masking) between <code>$len</code> and <code>7</code> (binary 111). The last three bits of the length indicate the number of remaining bytes if we used an eight-byte copy for the majority of the bytes. As an example, using an <code>i32.and</code> expression on the <code>$len</code> of <code>190</code> and <code>7</code> looks like <a href="#figure5-1" id="figureanchor5-1">Figure 5-1</a>.</p>
<figure>
<img src="Images/f05001.png" alt="f05001" width="687" height="595"/>
<figcaption><p><a id="figure5-1">Figure 5-1</a>: Using binary AND to mask out all but the last three bits</p></figcaption></figure>
<p><span epub:type="pagebreak" title="100" id="Page_100"/>As you can see, calling <code>i32.and</code> passing the values 190 and 7 results in the binary 110, which is 6 in decimal. The <code>i32.and</code> expression sets all but the last three bits of our <code>$len</code> parameter to 0.</p>
<p>If the number of <code>$singles</code> isn’t zero <span class="CodeAnnotation" aria-label="annotation3">3</span>, the code first copies the individual bytes that cannot be copied using the 64-bit copy. The <code>if</code> block sets <code>$len_less_singles</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> to <code>$len</code> - <code>$singles</code>: that is the number of bytes that must be copied individually. The local variable <code>$start_source_byte</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> is set to <code>$source+$len_less_singles</code>, setting it to the starting byte of the byte-by-byte copy <span class="CodeAnnotation" aria-label="annotation7">7</span>.</p>
<p>Then the variable <code>$start_dest_byte</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> is set to <code>$dest+$len_less_singles</code>, which sets it to the destination location for the byte-by-byte copy. The branch then calls <code>$byte_copy</code> to copy those remaining single bytes.</p>
<p>After the <code>if</code> block, the code must copy the bytes that it can with the 64-bit copy function <code>(call</code><code> $byte_copy_i64)</code><span class="CodeAnnotation" aria-label="annotationa">a</span>. We determine the number of bytes to copy with this function by using a bitwise <code>(i32.and</code><code>) </code><span class="CodeAnnotation" aria-label="annotation9">9</span> expression of the length in <code>$len</code> with the 32-bit constant value <code>0xff_ff_ff_f8</code> <span class="CodeAnnotation" aria-label="annotation8">8</span>. The value <code>0xff_ff_ff_f8</code> in binary is all 1s except the last three bits, which are set to 0. Using the bitwise AND zeros out the last three bits of the length, which makes the length a multiple of eight.</p>
<p>Now that we have a string copy function, let’s change the <code>main</code> function to test it. Change the <code>main</code> function so it contains only the code in <a href="#listing5-20" id="listinganchor5-20">Listing 5-20</a>.</p>
<p class="CodeLabel"><b>strings.wat (part 11 of 11)</b></p>
<pre><code>...
(func (export "main")
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> (call $str_pos_len (i32.const 256) (i32.const 30))
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> (call $str_pos_len (i32.const 384) (i32.const 35))

  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> (call $string_copy
        (i32.const 256) (i32.const 384) (i32.const 30))

  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> (call $str_pos_len (i32.const 384) (i32.const 35))
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> (call $str_pos_len (i32.const 384) (i32.const 30))
  )</code></pre>
<p class="CodeListingCaption"><a id="listing5-20">Listing 5-20</a>: New version of the <code>main</code> function for <em>strings.wat</em> (<a href="#listing5-2">Listing 5-2</a>)</p>
<p>We removed the code that printed the null-terminated strings and the length-prefixed strings to the console. We keep the two lines that print the string at linear memory location <code>256</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, <code>"Know the length of this string"</code>, and the string at memory location <code>384</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, <code>"Also know the length of this string"</code>. Leaving these lines in will print the original value for the strings to the console before the copy.</p>
<p>The call to <code>$string_copy</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> copies 30 bytes from the first string to the second string. Then we print the second string location with the original string length. This will print <code>"Know the length of this stringtring"</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> to the console, which looks wrong because it ends with the word <code>stringtring</code>. The reason the last word doesn’t end with <code>string</code> and has an additional five characters is that we needed to change the length to that of the string we copied from. If we’d been copying a null-terminated string or a length-prefixed string, this wouldn’t have been a problem, because the null-byte or prefix <span epub:type="pagebreak" title="101" id="Page_101"/>would keep track of the length for us: but in this case, we need to know that the new length is <code>30</code>. </p>
<p>When we call <code>$str_pos_len</code> passing in <code>384</code> as the index and <code>30</code> as the length <span class="CodeAnnotation" aria-label="annotation5">5</span>, it will properly print <code>"Know the length of this string"</code> to the console. We can recompile <em>strings.wat</em> using the command in <a href="#listing5-21" id="listinganchor5-21">Listing 5-21</a>.</p>
<pre><code>wat2wasm strings.wat</code></pre>
<p class="CodeListingCaption"><a id="listing5-21">Listing 5-21</a>: Compiling <em>strings.wat</em></p>
<p>Run <em>strings.js</em> from the command line to see the output in <a href="#listing5-22" id="listinganchor5-22">Listing 5-22</a>.</p>
<pre><code>Know the length of this string
Also know the length of this string
Know the length of this stringtring
Know the length of this string</code></pre>
<p class="CodeListingCaption"><a id="listing5-22">Listing 5-22</a>: Output from <em>strings.js</em> after adding a call to <code>$string_copy</code><code/></p>
<p>In the next section, you’ll learn how to turn numbers into strings.</p>
<h3 id="h2-501737c05-0005">Creating Number Strings</h3>
<p class="BodyFirst">When you’re working with strings, converting numeric data into string data is frequently required. High-level languages like JavaScript have functions that can do this for you, but in WAT you’ll need to build your own functions. Let’s look at what it takes to create strings from numbers in decimal, hexadecimal, and binary.</p>
<p>Create a WAT file named <em>number_string.wat</em> and add the code in <a href="#listing5-23" id="listinganchor5-23">Listing 5-23</a> to the beginning of the file.</p>
<p class="CodeLabel"><b>number_string.wat (part 1 of 7)</b></p>
<pre><code>(module
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (import "env" "print_string" (func $print_string (param i32 i32)))
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (import "env" "buffer" (memory 1))

<span class="CodeAnnotationCode" aria-label="annotation3">3</span> (data (i32.const 128) "0123456789ABCDEF")

<span class="CodeAnnotationCode" aria-label="annotation4">4</span> (data (i32.const 256) "               0")
<span class="CodeAnnotationCode" aria-label="annotation5">5</span> (global $dec_string_len  i32 (i32.const 16))
...</code></pre>
<p class="CodeListingCaption"><a id="listing5-23">Listing 5-23</a>: Imported objects and data in the WebAssembly module</p>
<p>The beginning of this module imports a <code>$print_string</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> function and one page of linear memory <span class="CodeAnnotation" aria-label="annotation2">2</span> from JavaScript. Next, we define a <code>data</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> element with an array of characters that contains every hexadecimal character. Then we define a data element that will hold our string <code>data</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>, followed by the length of that <code>data</code> string <span class="CodeAnnotation" aria-label="annotation5">5</span>.</p>
<p>In the next few listings, we define three functions that create number strings in three different formats. We use the first of these functions, <code>$set_dec_string</code>, to set the <code>$dec_string</code> linear memory area.</p>
<p><a href="#listing5-24" id="listinganchor5-24">Listing 5-24</a> contains the code that turns an integer into a decimal string. The code can be a bit challenging to follow, so I’ll give you an <span epub:type="pagebreak" title="102" id="Page_102"/>overview before showing the code. At a high level, when we assemble a string from a number, we need to look at the number one digit at a time and add the character form of that digit to our string. Let’s say the number we’re looking at is 9876. In the 1s place is the digit 6. We can find this digit by dividing the full number by 10 and using the remainder (called a <em>modulo</em>). In WAT, that code would be the type <code>i32.rem_u</code> (<code>rem</code> for remainder). Next, you use the character form of the number 6 and add it to your string. Other digits need to move along as if on a conveyor belt (illustrated in <a href="#figure5-2" id="figureanchor5-2">Figure 5-2</a>). The way you do this in code is to divide by 10. Because this divide is on an integer, you don’t get a fractional number, and the 6 is simply thrown away. You then use the remainder to get the next digit (7) and add that to the string. You continue on until all the digits are gone. <a href="#listing5-24">Listing 5-24</a> shows the source code for the <code>$set_dec_string</code> function.</p>
<p class="CodeLabel"><b>number_string.wat (part 2 of 7)</b></p>
<pre><code>...
(func $set_dec_string (param $num i32) (param $string_len i32)
  (local $index      i32)
  (local $digit_char  i32)
  (local $digit_val   i32)

  local.get $string_len
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> local.set $index    <span class="LiteralGray">;; set $index to the string length</span>

  local.get $num
  i32.eqz             <span class="LiteralGray">;; is $num is equal to zero</span>
  if                  <span class="LiteralGray">;; if the number is 0, I don't want all spaces</span>
    local.get $index
    i32.const 1
    i32.sub
    local.set $index  <span class="LiteralGray">;; $index--</span>

    <span class="LiteralGray">;; store ascii '0' to memory location 256 + $index</span>
    (i32.store8 offset=256 (local.get $index) (i32.const 48))
  end

  (loop $digit_loop (block $break <span class="LiteralGray">;; loop converts number to a string</span>
    local.get $index  <span class="LiteralGray">;; set $index to end of string, decrement to 0</span>
    i32.eqz           <span class="LiteralGray">;; is the $index 0?</span>
    br_if $break      <span class="LiteralGray">;; if so break out of loop</span>

    local.get $num
    i32.const 10
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> i32.rem_u         <span class="LiteralGray">;; decimal digit is remainder of divide by 10</span>

  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> local.set $digit_val<span class="LiteralGray"> ;; replaces call above</span>
    local.get $num
    i32.eqz              <span class="LiteralGray">;; check to see if the $num is now 0</span>
    if
      i32.const 32          <span class="LiteralGray"> ;; 32 is ascii space character</span>
      local.set $digit_char  <span class="LiteralGray">;; if $num is 0, left pad spaces</span>
    else
    <span class="CodeAnnotationCode" aria-label="annotation4">4</span> (i32.load8_u offset=128 (local.get $digit_val))
      local.set $digit_char  <span class="LiteralGray">;; set $digit_char to ascii digit</span>
<span epub:type="pagebreak" title="103" id="Page_103"/>    end  

    local.get $index
    i32.const 1
    i32.sub
    local.set $index
    <span class="LiteralGray">;; store ascii digit in 256 + $index</span>
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> (i32.store8 offset=256
      (local.get $index) (local.get $digit_char))  

    local.get $num
    i32.const 10
    i32.div_u
  <span class="CodeAnnotationCode" aria-label="annotation6">6</span> local.set $num     <span class="LiteralGray">;; remove last decimal digit, dividing by 10</span>

    br $digit_loop     <span class="LiteralGray">;; loop</span>
  ))<span class="LiteralGray"> ;; end of $block and $loop</span>
)</code></pre>
<p class="CodeListingCaption"><a id="listing5-24">Listing 5-24</a>: A WebAssembly function that creates a decimal string from an integer</p>
<p>We start the function with <code>$index</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, a variable that points to the last byte in <code>$dec_string</code>. We set the values of this string from right to left, so the <code>$index</code> variable needs to be decremented every pass through the loop. Each pass through the loop, the number value set in <code>$dec_string</code> is the final base-10 digit. To get this value, we divide the <code>$num</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> value by <code>10</code> and get the remainder <span class="CodeAnnotation" aria-label="annotation2">2</span> with modulo 10. This value is stored in the local variable <code>$digit_val</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> so we can later use it to set an ASCII character in the <code>$dec_string</code> data. We use <code>$digit_val</code> as an offset into the <code>$digit_char</code> string to load a character with <code>i32.load8_u</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>. That character is then written to an address that is <code>$dec_string+$index</code> using <code>i32.store8</code> <span class="CodeAnnotation" aria-label="annotation5">5</span>. <a href="#figure5-2">Figure 5-2</a> illustrates the process.</p>
<figure>
<img src="Images/f05002.png" alt="f05002" width="675" height="421"/>
<figcaption><p><a id="figure5-2">Figure 5-2</a>: Look at digits one at a time and append characters one at a time.</p></figcaption></figure>
<p><span epub:type="pagebreak" title="104" id="Page_104"/>Now that we have the function that does most of the work in our WebAssembly module, let’s add a function to export to the JavaScript, as shown in <a href="#listing5-25" id="listinganchor5-25">Listing 5-25</a>.</p>
<p class="CodeLabel"><b>number_string.wat (part 3 of 7)</b></p>
<pre><code>...
  (func (export "to_string") (param $num i32)
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> (call $set_dec_string
      (local.get $num) (global.get $dec_string_len))
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> (call $print_string
      (i32.const 256) (global.get $dec_string_len))
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing5-25">Listing 5-25</a>: The <code>to_string</code> function</p>
<p>The function is very simple. It calls <code>$set_dec_string</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> passing in the number we want to convert to a string and the length of the string we want including the left padding. It then calls the JavaScript <code>print_string</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> function passing in the location of the string we created in linear memory <code>(i32.const</code><code> 256)</code> and the length of that string. </p>
<p>Now that we’ve completed the <em>number_string.wat</em> file, we can compile it using <code>wat2wasm</code> in <a href="#listing5-26" id="listinganchor5-26">Listing 5-26</a>.</p>
<pre><code>wat2wasm number_string.wat</code></pre>
<p class="CodeListingCaption"><a id="listing5-26">Listing 5-26</a>: Compiling <em>number_string.wat</em></p>
<p>Next, we need to write the JavaScript that will run our WebAssembly module. Create a file named <em>number_string.js</em> and add the code in <a href="#listing5-27" id="listinganchor5-27">Listing 5-27</a>.</p>
<p class="CodeLabel"><b>number_string.js</b></p>
<pre><code>  const fs = require('fs');
  const bytes = fs.readFileSync(__dirname + '/number_string.wasm');
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> const value = parseInt(process.argv[2]);
  let memory = new WebAssembly.Memory({ initial: 1 });

  (async () =&gt; {
    const obj =
      await WebAssembly.instantiate(new Uint8Array(bytes), {
        env: {
          buffer: memory,
        <span class="CodeAnnotationCode" aria-label="annotation2">2</span> print_string: function (str_pos, str_len) {
            const bytes = new Uint8Array(memory.buffer,
              str_pos, str_len);
            const log_string = new TextDecoder('utf8').decode(bytes);
            <span class="LiteralGray">// log_string is left padded.  </span>
          <span class="CodeAnnotationCode" aria-label="annotation3">3</span> console.log(`&gt;${log_string}!`);
          }
        }
      });
      obj.instance.exports.to_string(value);
  })();</code></pre>
<p class="CodeListingCaption"><a id="listing5-27">Listing 5-27</a>: The JavaScript that calls the WebAssembly module to convert the number to a string</p>
<p><span epub:type="pagebreak" title="105" id="Page_105"/>The JavaScript code loads the WebAssembly module and takes an additional argument <span class="CodeAnnotation" aria-label="annotation1">1</span> that we’ll convert into a number string and left pads the string up to 16 characters. The WebAssembly module will call the <code>print_string </code><span class="CodeAnnotation" aria-label="annotation2">2</span><code> </code>JavaScript function, which writes the string to the console, appending a <code>&gt;</code> character to the beginning of the string and a <code>!</code> character to the end. We place these extra characters into the <code>console.log</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> output to show where the string coming from the WebAssembly module begins and ends. You can run the JavaScript using the <code>node</code> command in <a href="#listing5-28" id="listinganchor5-28">Listing 5-28</a>.</p>
<pre><code>node number_string.js 1229</code></pre>
<p class="CodeListingCaption"><a id="listing5-28">Listing 5-28</a>: Use <code>node</code> to call the <em>number_string.js</em> file, passing in <code>1229</code>.</p>
<p>The result is that the number <code>1229</code> is converted to a string, and the output in <a href="#listing5-29" id="listinganchor5-29">Listing 5-29</a> is logged to the console.</p>
<pre><code>&gt;            1229!</code></pre>
<p class="CodeListingCaption"><a id="listing5-29">Listing 5-29</a>: The number <code>1229</code> is left padded to 16 characters, beginning with <code>&gt;</code> and ending with <code>!</code>.</p>
<p>In the next section, we’ll use similar techniques to create a hexadecimal string.</p>
<h3 id="h2-501737c05-0006">Setting a Hexadecimal String</h3>
<p class="BodyFirst">Converting an integer to a hexadecimal string is very similar to converting an integer to a decimal number, as we did in the preceding section. We use a bit mask to look at specific hex digits and a shift to remove the digit, similar to our decimal conveyor belt (see <a href="#figure5-2">Figure 5-2</a>). </p>
<p>Recall from <span class="xref" itemid="xref_target_Chapter 4">Chapter 4</span> that four bits of data is called a nibble and a hexadecimal digit corresponds to one nibble of data. At a high level, the code needs to look at the integer one nibble at a time as one hexadecimal digit. We look at the lowest order nibble, also the lowest order hex digit, and then add that digit to the string. Rather than finding the remainder, we use a mask to only look at the last digit. Instead of dividing by 10, we remove the last hex digit by shifting off four bits (one nibble).</p>
<p>In hexadecimal, each digit represents a number from 0 to 15 instead of 0 to 9, so each digit in hex must be one of the following: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F where the value of A = 10, B = 11, C = 12, D = 13, E = 14, and F = 15. We often use hexadecimal as an alternative to binary numbers, which can get extremely long to represent; for example, the number 233 in decimal is 11101001 in binary. We can shorten 233 in the binary form into the hexadecimal E9 because 1110 is 14 or E in hex, and 1001 is 9 in both decimal and hex.</p>
<p>We mask E9 (binary 1110 1001) using <code>(i32.and</code><code>)</code> with a value of binary 0000 1111 (0F) to find the least significant nibble. Using <code>i32.and</code> in that way results in E9 masked into 09, as shown in <a href="#figure5-3" id="figureanchor5-3">Figure 5-3</a>. </p>
<span epub:type="pagebreak" title="106" id="Page_106"/><figure>
<img src="Images/f05003.png" alt="f05003" width="675" height="850"/>
<figcaption><p><a id="figure5-3">Figure 5-3</a>: E9 byte masked to 09 with a mask of 0F (0000 1111)</p></figcaption></figure>
<p>We use a combination of a bit shift and an AND mask to convert the integer data into a hexadecimal string. Here, we create a hexadecimal version of the <code>$set_dec_string</code> function called <code>$set_hex_string</code>. This function sets a hexadecimal string based on a number passed into it. We can make this loop simpler than the loop in <code>$set_dec_string</code> because we can use simple bit manipulation to find the offset into <code>$digits</code>. The end of the function adds the extra ASCII characters <code>0x</code> to indicate that the display string is in a hexadecimal format. <a href="#listing5-30" id="listinganchor5-30">Listing 5-30</a> shows what the <code>$set_hex_string</code> function looks like.</p>
<span epub:type="pagebreak" title="107" id="Page_107"/>
<p class="CodeLabel"><b>number_string.wat (part 4 of 7)</b></p>
<pre><code>...
<span class="LiteralGray">;; add this code before the $set_dec_string function</span>
  (global $hex_string_len  i32 (i32.const 16)) <span class="LiteralGray">;; hex character count</span>
  (data (i32.const 384) "             0x0")    <span class="LiteralGray">;; hex string data</span>

  (func $set_hex_string (param $num i32) (param $string_len i32)
    (local $index       i32)
    (local $digit_char  i32)
    (local $digit_val   i32)
    (local $x_pos       i32)

    global.get $hex_string_len
    local.set $index <span class="LiteralGray">;; set the index to the number of hex characters</span>

    (loop $digit_loop (block $break
      local.get $index
      i32.eqz    
      br_if $break

      local.get $num
      i32.const 0xf <span class="LiteralGray">;; last 4 bits are 1</span>
    <span class="CodeAnnotationCode" aria-label="annotation1">1</span> i32.and       <span class="LiteralGray">;; the offset into $digits is in the last 4 bits of number</span>

    <span class="CodeAnnotationCode" aria-label="annotation2">2</span> local.set $digit_val  <span class="LiteralGray">;; the digit value is the last 4 bits</span>
      local.get $num
      i32.eqz
    <span class="CodeAnnotationCode" aria-label="annotation3">3</span> if                    <span class="LiteralGray">;; if $num == 0</span>
        local.get $x_pos
        i32.eqz
        if
          local.get $index
        <span class="CodeAnnotationCode" aria-label="annotation4">4</span> local.set $x_pos  <span class="LiteralGray">;; position of 'x' in the "0x" hex prefix</span>
        else
          i32.const 32      <span class="LiteralGray">;; 32 is ascii space character</span>
          local.set $digit_char
        end
      else
        <span class="LiteralGray">;; load character from 128 + $digit_val</span>
      <span class="CodeAnnotationCode" aria-label="annotation5">5</span> (i32.load8_u offset=128 (local.get $digit_val))
        local.set $digit_char
      end  

      local.get $index
      i32.const 1
      i32.sub
    <span class="CodeAnnotationCode" aria-label="annotation6">6</span> local.tee $index  <span class="LiteralGray">;; $index = $index - 1</span>
      local.get $digit_char

      <span class="LiteralGray">;; store $digit_char at location 384+$index</span>
    <span class="CodeAnnotationCode" aria-label="annotation7">7</span> i32.store8 offset=384

<span epub:type="pagebreak" title="108" id="Page_108"/>      local.get $num
      i32.const 4
    <span class="CodeAnnotationCode" aria-label="annotation8">8</span> i32.shr_u            <span class="LiteralGray">;; shifts 1 hexadecimal digit off $num</span>
      local.set $num

      br $digit_loop
    ))

    local.get $x_pos
    i32.const 1
    i32.sub

    i32.const 120          <span class="LiteralGray">;; ascii x</span>
  <span class="CodeAnnotationCode" aria-label="annotation9">9</span> i32.store8 offset=384  <span class="LiteralGray">;; store 'x' in string</span>

    local.get $x_pos
    i32.const 2
    i32.sub

    i32.const 48           <span class="LiteralGray">;; ascii '0'</span>
  <span class="CodeAnnotationCode" aria-label="annotationa">a</span> i32.store8 offset=384  <span class="LiteralGray">;; store "0x" at front of string</span>
  ) <span class="LiteralGray">;; end $set_hex_string</span>
...</code></pre>
<p class="CodeListingCaption"><a id="listing5-30">Listing 5-30</a>: Create a hexadecimal string from an integer. Add this before the <code>$set_dec_string</code> function.</p>
<p>In the <code>$set_dec_string</code> function, we use a modulo 10 to find each digit, and then shift that digit off by dividing it by 10. Instead of finding a remainder, the <code>$set_hex_string</code> function can use <code>i32.and</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> to mask all but the last four bits of <code>$num</code>. The value of that nibble is a single hexadecimal digit and is used to set <code>$digit_val</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>.</p>
<p>If all remaining digits are <code>0</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, we set the position to put the hexadecimal string prefix of <code>0x</code> in the local variable <code>$x_pos</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>. Otherwise, if any remaining digits are <code>1</code> or greater, we use the value in <code>$digit_val</code> to load <span class="CodeAnnotation" aria-label="annotation5">5</span> an ASCII value for that hexadecimal digit from the <code>$digits</code> string and store it into <code>$digit_char</code>. Then we decrement <code>$offset</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> and use that value to store the character in <code>$digit_char</code> into the <code>$hex_string</code> data <span class="CodeAnnotation" aria-label="annotation7">7</span>.</p>
<p>The loop then shifts off one hexadecimal digit (four bits) using <code>i32.shr_u</code> <span class="CodeAnnotation" aria-label="annotation8">8</span>, which shifts bits to the right. The last task this function does is append the <code>0x</code> prefix to the string by using the value we set earlier in <code>$x_pos</code> as an offset and storing an ASCII <code>x</code> character in that position <span class="CodeAnnotation" aria-label="annotation9">9</span>. It then decrements the <code>$x_pos</code> position and stores the ASCII <code>0</code> <span class="CodeAnnotation" aria-label="annotationa">a</span>. The process looks a bit like <a href="#figure5-4" id="figureanchor5-4">Figure 5-4</a>.</p>
<span epub:type="pagebreak" title="109" id="Page_109"/><figure>
<img src="Images/f05004.png" alt="f05004" width="675" height="402"/>
<figcaption><p><a id="figure5-4">Figure 5-4</a>: Creating a hexadecimal string from an integer</p></figcaption></figure>
<p>After adding the <code>$set_hex_string</code> function, we need to update the <code>to_string</code> function to call <code>$set_hex_string</code> and print the resulting string to the console. Update the <code>to_string</code> function to look like the code in <a href="#listing5-31" id="listinganchor5-31">Listing 5-31</a>.</p>
<p class="CodeLabel"><b>number_string.wat (part 5 of 7)</b></p>
<pre><code>...
  (func (export "to_string") (param $num i32)
    (call $set_dec_string
      (local.get $num) (global.get $dec_string_len))
    (call $print_string (i32.const 256) (global.get $dec_string_len))

  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> (call $set_hex_string (local.get $num)
      (global.get $hex_string_len))
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> (call $print_string (i32.const 384) (global.get $hex_string_len))
  )  
)</code></pre>
<p class="CodeListingCaption"><a id="listing5-31">Listing 5-31</a>: Update to the <code>to_string</code> function calling <code>$set_hex_string</code> and <code>$print_string</code></p>
<p>These two new statements call <code>$set_hex_string</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> to set the hexadecimal string in linear memory. We then call <code>$print_string</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> passing in the memory location of the hexadecimal string <code>(i32.const</code><code> 384)</code> and the length of the string. No changes to the JavaScript file are necessary. All we need to do is recompile our WAT file, as shown in <a href="#listing5-32" id="listinganchor5-32">Listing 5-32</a>.</p>
<pre><code>wat2wasm number_string.wat</code></pre>
<p class="CodeListingCaption"><a id="listing5-32">Listing 5-32</a>: Compiling <em>number_string.wat</em> with <code>wat2wasm</code></p>
<p><span epub:type="pagebreak" title="110" id="Page_110"/>Once you’ve recompiled the WebAssembly module, you can run the <em>number_string.js</em> file using <code>node</code>, as shown in <a href="#listing5-33" id="listinganchor5-33">Listing 5-33</a>.</p>
<pre><code>node number_string.js 2049</code></pre>
<p class="CodeListingCaption"><a id="listing5-33">Listing 5-33</a>: Running <em>number_string.js</em> passing in the value <code>2049</code></p>
<p><a href="#listing5-34" id="listinganchor5-34">Listing 5-34</a> shows the output.</p>
<pre><code>&gt;            2049!
&gt;           0x801!</code></pre>
<p class="CodeListingCaption"><a id="listing5-34">Listing 5-34</a>: The second line is the output of the hexadecimal string conversion.</p>
<p>In the next section, we’ll add a function to generate a string of binary digits from a 32-bit integer.</p>
<h3 id="h2-501737c05-0007">Setting a Binary String</h3>
<p class="BodyFirst">The final format we’ll cover is converting an integer to a string that represents the binary data. It’s best to get an intuitive sense for binary numbers when you’re working with low-level code. Having a better conceptual grasp on the numbers can sometimes help you create improvements in your code’s performance by using bit manipulation as an alternative to decimal math. Computers work with binary, even if your code is working with decimal. Understanding what the computer is doing is often helpful when you’re trying to improve your code’s performance.</p>
<p>We’ll create the <code>$set_bin_string</code> function, which uses a double loop to separate every 4-bit nibble with a space character to make it more readable. We’ll use <code>(i32.and</code><code>)</code> against the number <code>1</code> to see whether the last bit is a <code>1</code> or a <code>0</code>, and then shift a single bit off the number every pass through the inner loop of the function. <a href="#listing5-35" id="listinganchor5-35">Listing 5-35</a> shows what the code looks like.</p>
<p class="CodeLabel"><b>number_string.wat (part 6 of 7)</b></p>
<pre><code>...
<span class="LiteralGray">;; add this code before the $set_hex_string function</span>
(global $bin_string_len  i32 (i32.const 40))
(data (i32.const 512) " 0000 0000 0000 0000 0000 0000 0000 0000")

(func $set_bin_string (param $num i32) (param $string_len i32)
  (local $index i32)
  (local $loops_remaining i32)
  (local $nibble_bits i32)

  global.get $bin_string_len
  local.set $index

<span class="CodeAnnotationCode" aria-label="annotation1">1</span> i32.const 8  <span class="LiteralGray">;; there are 8 nibbles in 32 bits (32/4 = 8)</span>
  local.set $loops_remaining  <span class="LiteralGray">;; outer loop separates nibbles</span>

<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (loop $bin_loop (block $outer_break  <span class="LiteralGray">;; outer loop for spaces</span>
    local.get $index  
    i32.eqz
<span epub:type="pagebreak" title="111" id="Page_111"/>    br_if $outer_break        <span class="LiteralGray">;; stop looping when $index is 0</span>

    i32.const 4
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> local.set $nibble_bits    <span class="LiteralGray">;; 4 bits in each nibble</span>

  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> (loop $nibble_loop (block $nibble_break <span class="LiteralGray">;; inner loop for digits</span>
      local.get $index  
      i32.const 1
      i32.sub
      local.set $index        <span class="LiteralGray">;; decrement $index</span>

      local.get $num
      i32.const 1
    <span class="CodeAnnotationCode" aria-label="annotation5">5</span> i32.and   <span class="LiteralGray">;; i32.and 1 results in 1 if last bit is 1 else 0</span>
      if    <span class="LiteralGray">    ;; if the last bit is a 1</span>
        local.get $index
        i32.const 49       <span class="LiteralGray">    ;; ascii '1' is 49</span>
      <span class="CodeAnnotationCode" aria-label="annotation6">6</span> i32.store8 offset=512  <span class="LiteralGray">;; store '1' at 512 + $index</span>

      else                     <span class="LiteralGray">;; else executes if last bit was 0</span>
        local.get $index
        i32.const 48           <span class="LiteralGray">;; ascii '0' is 48</span>
      <span class="CodeAnnotationCode" aria-label="annotation7">7</span> i32.store8 offset=512  <span class="LiteralGray">;; store '0' at 512 + $index</span>
      end

      local.get $num
      i32.const 1
    <span class="CodeAnnotationCode" aria-label="annotation8">8</span> i32.shr_u                <span class="LiteralGray">;; $num shifted right 1 bit</span>
      local.set $num        <span class="LiteralGray">   ;; shift off the last bit of $num</span>

      local.get $nibble_bits
      i32.const 1
      i32.sub
      local.tee $nibble_bits   <span class="LiteralGray">;; decrement $nibble_bits</span>
      i32.eqz                  <span class="LiteralGray">;; $nibble_bits == 0</span>
    <span class="CodeAnnotationCode" aria-label="annotation9">9</span> br_if $nibble_break      <span class="LiteralGray">;; break when $nibble_bits == 0</span>

      br $nibble_loop
    )) <span class="LiteralGray">;; end $nibble_loop</span>

    local.get $index  
    i32.const 1
    i32.sub
    local.tee $index           <span class="LiteralGray">;; decrement $index</span>
    i32.const 32               <span class="LiteralGray">;; ascii space</span>
  <span class="CodeAnnotationCode" aria-label="annotationa">a</span> i32.store8 offset=512      <span class="LiteralGray">;; store ascii space at 512+$index</span>

    br $bin_loop
  ))<span class="LiteralGray"> ;; end $bin_loop</span>
)
...</code></pre>
<p class="CodeListingCaption"><a id="listing5-35">Listing 5-35</a>: Create a binary string from an integer. Add this code before the <code>$set_hex_string</code> function.</p>
<p><span epub:type="pagebreak" title="112" id="Page_112"/>The <code>$set_bin_string</code> function has two loops. The outer loop puts a space between each of the nibbles. Because we are working with 32-bit numbers in this code, there are eight nibbles <span class="CodeAnnotation" aria-label="annotation1">1</span> that we need to loop over. We label the outer loop <code>$bin_loop</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, and the block we break from is called <code>$outer_break</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>.</p>
<p>Before the inner loop, we need to set the local variable <code>$nibble_bits</code> to <code>4</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>. The code loops over four bits for each nibble in the inner loop. Inside the inner loop <code>$nibble_loop</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>, we place a <code>$nibble_block</code> block that can break out of the inner loop <span class="CodeAnnotation" aria-label="annotation4">4</span>. Inside <code>$nibble_loop</code>, we use an <code>(i32.and</code><code>)</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> expression along with an <code>if</code>/<code>else</code> statement to determine whether the last bit in the <code>$num</code> variable is <code>1</code> or <code>0</code>. If it’s <code>1</code>, we use an <code>i32.store8</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> statement to store an ASCII <code>1</code> in the linear memory address <code>$index</code> + <code>512</code>. If it isn’t <code>1</code>, we store an ASCII <code>0</code> in that location <span class="CodeAnnotation" aria-label="annotation7">7</span>.</p>
<p>Next, we need to shift that bit off for the next pass through the loop. As we did in the <code>$set_hex_string</code> function, we’re using a <code>(i32.shr_u</code><code>)</code> <span class="CodeAnnotation" aria-label="annotation8">8</span> expression for this shifting, but this time we’re shifting off a single bit instead of four bits. After looping through the <code>$nibble</code> loop four times, we break <span class="CodeAnnotation" aria-label="annotation9">9</span> out of it and store an ASCII space character at the linear memory position <code>$offset</code> + <code>$bin_string</code> <span class="CodeAnnotation" aria-label="annotationa">a</span>.</p>
<p>Now we can call <code>$set_bin_string</code> to print the value of our string from the <code>to_string</code> function. Update the <code>to_string</code> function with the code in <a href="#listing5-36" id="listinganchor5-36">Listing 5-36</a>.</p>
<p class="CodeLabel"><b>number_string.wat (part 7 of 7)</b></p>
<pre><code>...
(func (export "to_string") (param $num i32)
  (call $set_dec_string
    (local.get $num) (global.get $dec_string_len))
  (call $print_string (i32.const 256) (global.get $dec_string_len))
  (call $set_hex_string
    (local.get $num) (global.get $hex_string_len))
  (call $print_string (i32.const 384) (global.get $hex_string_len))
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> (call $set_bin_string
    (local.get $num) (global.get $bin_string_len))
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> (call $print_string (i32.const 512) (global.get $bin_string_len))
  )  
)</code></pre>
<p class="CodeListingCaption"><a id="listing5-36">Listing 5-36</a>: Adding <code>$set_bin_string</code> to the <code>to_string</code> function</p>
<p>The first of the two <code>call</code> statements we just added (<code>call $set_bin_string</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>) sets the binary string using the function defined in <a href="#listing5-35">Listing 5-35</a>. The second <code>call</code> statement (<code>call $print_string</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>) prints the binary string to the console. Now let’s recompile the WebAssembly module, as shown in <a href="#listing5-37" id="listinganchor5-37">Listing 5-37</a>.</p>
<pre><code>wat2wasm number_string.wat</code></pre>
<p class="CodeListingCaption"><a id="listing5-37">Listing 5-37</a>: Recompiling <em>number_string.wat</em> with the binary string function</p>
<p><span epub:type="pagebreak" title="113" id="Page_113"/>We can now run the <em>number_string.js</em> file using the <code>node</code> command in <a href="#listing5-38" id="listinganchor5-38">Listing 5-38</a>.</p>
<pre><code>node number_string.js 4103</code></pre>
<p class="CodeListingCaption"><a id="listing5-38">Listing 5-38</a>: Running <em>number_string.js</em> with the binary string WebAssembly module</p>
<p>The output in <a href="#listing5-39" id="listinganchor5-39">Listing 5-39</a> will be logged to the console.</p>
<pre><code>&gt;            4103!
&gt;          0x1007!
&gt; 0000 0000 0000 0000 0001 0000 0000 0111!</code></pre>
<p class="CodeListingCaption"><a id="listing5-39">Listing 5-39</a>: The binary string logged to the console</p>
<h2 id="h1-501737c05-0003">Summary</h2>
<p class="BodyFirst">This chapter focused on how to work with strings in WAT. You learned about the ASCII and Unicode character formats. You stored string objects in linear memory and learned how to use JavaScript to retrieve the strings and output them to the command line. We covered how to pass string data from WebAssembly to JavaScript and examined two popular methods for string management, null-terminated strings and length-prefixed strings. You copied a string from one location in linear memory to another, using a byte-by-byte copy and a 64-bit copy. Then we explored how to convert integer data into number strings in decimal, hexadecimal, and binary format. In the next chapter, we’ll focus on using linear memory in WAT.</p>
</section>
</div></body></html>