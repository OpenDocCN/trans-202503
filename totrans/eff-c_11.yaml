- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">DEBUGGING,
    TESTING, AND ANALYSIS</samp>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">调试、测试和分析</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: This final chapter describes tools and techniques for producing correct, effective,
    safe, secure, and robust programs, including static (compile-time) and runtime
    assertions, debugging, testing, static analysis, and dynamic analysis. The chapter
    also discusses which compiler flags are recommended for use in different phases
    of the software development process.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了用于生成正确、有效、安全、可靠和强健程序的工具和技术，包括静态（编译时）和运行时断言、调试、测试、静态分析和动态分析。章节还讨论了在软件开发过程中不同阶段推荐使用的编译器标志。
- en: This chapter marks a transition point from learning to program in C to professional
    C programming. Programming in C is relatively easy, but mastering C programming
    is a lifetime endeavor. Modern C programming requires a disciplined approach to
    develop and deploy safe, secure, and performant systems.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章标志着从学习C语言编程到专业C语言编程的过渡。用C语言编程相对容易，但精通C语言编程是一个终生的事业。现代C语言编程要求采用有纪律的方法来开发和部署安全、可靠且高效的系统。
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">Assertions</samp>'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '## <samp class="SANS_Futura_Std_Bold_B_11">断言</samp>'
- en: An *assertion* is a function with a Boolean value, known as a *predicate*, which
    expresses a logical proposition about a program. You use an assertion to verify
    that a specific assumption you made during the implementation of your program
    remains valid. C supports static assertions that can be checked at compile time
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> and runtime
    assertions that are checked during program execution using <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> macro is defined
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11"><assert.h></samp> header.
    In C23, <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> is
    a keyword. In C11, <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>
    was provided as a macro in <samp class="SANS_TheSansMonoCd_W5Regular_11"><assert.h></samp>.
    Prior to that, C did not have static assertions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*断言*是一个具有布尔值的函数，称为*谓词*，它表达了关于程序的逻辑命题。你使用断言来验证在实现程序时所做的特定假设是否保持有效。C语言支持静态断言，可以在编译时使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>进行检查，也支持运行时断言，这些断言在程序执行过程中通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>进行检查。<samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>宏定义在<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><assert.h></samp>头文件中。在C23中，<samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>成为了一个关键字。在C11中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>作为一个宏定义在<samp class="SANS_TheSansMonoCd_W5Regular_11"><assert.h></samp>头文件中。在此之前，C语言没有静态断言。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Static Assertions</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">静态断言</samp>
- en: '*Static assertions* can be expressed using the <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>
    keyword as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态断言*可以使用<samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>关键字表示，如下所示：'
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since C23, <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>
    also accepts a single-argument form:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 自C23以来，<samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>还接受单一参数形式：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If the value of the integer constant expression is not equal to 0, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> declaration has no
    effect. If the integer constant expression is equal to 0, the compiler will produce
    a diagnostic message with the text of the string literal, if present.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果整数常量表达式的值不等于0，则<samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>声明没有效果。如果整数常量表达式等于0，则编译器将生成一条诊断信息，并显示字符串文字的文本（如果存在的话）。
- en: You can use static assertions to validate assumptions at compile time, such
    as specific implementation-defined behaviors. Any change in implementation-defined
    behavior will then be diagnosed at compilation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用静态断言在编译时验证假设，例如特定的实现定义行为。任何实现定义行为的变化将在编译时被诊断出来。
- en: Let’s look at three examples of using static assertions. First, in [Listing
    11-1](chapter11.xhtml#Lis11-1), we use <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>
    to verify that <samp class="SANS_TheSansMonoCd_W5Regular_11">struct packed</samp>
    has no padding bytes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看三个使用静态断言的例子。首先，在[示例11-1](chapter11.xhtml#Lis11-1)中，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>来验证<samp
    class="SANS_TheSansMonoCd_W5Regular_11">struct packed</samp>没有填充字节。
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-1: Asserting the
    absence of padding bytes</samp>'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例11-1：断言无填充字节</samp>
- en: The predicate for the static assertion in this example tests that the size of
    the packed structure is the same as the combined size of its <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">char *</samp> members. For example,
    on x86-32, both <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char *</samp> are 4 bytes, and the structure
    is not padded, but on x86-64, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    is 4 bytes, <samp class="SANS_TheSansMonoCd_W5Regular_11">char *</samp> is 8 bytes,
    and the compiler adds 4 padding bytes between the two fields.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的静态断言谓词测试了打包结构的大小是否与其<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char *</samp>成员的组合大小相同。例如，在x86-32架构上，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">char
    *</samp>都是4字节，结构体没有填充；而在x86-64架构上，<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>是4字节，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">char *</samp>是8字节，编译器会在这两个字段之间添加4字节的填充。
- en: A good use of static assertions is to document all your assumptions concerning
    implementation-defined behavior. This will prevent the code from compiling when
    porting to another implementation where those assumptions are invalid.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 静态断言的一个好用例是记录所有与实现相关的假设行为。这将防止代码在移植到其他实现时编译失败，特别是当这些假设在新环境中无效时。
- en: Because a static assertion is a declaration, it can appear at file scope, immediately
    following the definition of the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    whose property it asserts.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于静态断言是一个声明，它可以出现在文件作用域中，紧跟其后的是它所验证的<samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>的定义。
- en: For the second example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">clear_stdin</samp>
    function, shown in [Listing 11-2](chapter11.xhtml#Lis11-2), calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>
    function to read characters from <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>
    until the end of the file is reached.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个例子，<samp class="SANS_TheSansMonoCd_W5Regular_11">clear_stdin</samp>函数，如[示例11-2](chapter11.xhtml#Lis11-2)所示，调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>函数从<samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>读取字符，直到文件末尾。
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-2: Using</samp>
    <samp class="I">static_assert</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    verify integer sizes</samp>'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例11-2：使用</samp> <samp class="I">static_assert</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">验证整数大小</samp>
- en: Each character is obtained as an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> converted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    It’s common practice to compare the character returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>
    function with <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>, often
    in a <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> loop, to
    determine when all the available characters have been read. For this function
    loop to work correctly, the terminating condition must be able to differentiate
    between a character and <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>.
    However, the C standard allows for <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to have
    the same range, meaning that on some implementations, this test for <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    could return false positives, in which case the <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp>
    loop may terminate early. Because this is an unusual condition, you can use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> to validate that
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> loop can properly
    distinguish between valid characters and <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字符作为一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>
    被转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 获取。通常做法是将 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp> 函数返回的字符与 <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    进行比较，通常是在一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> 循环中，用于判断是否已读取所有可用字符。为了使该函数循环正常工作，终止条件必须能够区分字符和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>。然而，C 标准允许 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 拥有相同的范围，这意味着在某些实现中，这个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp> 测试可能会返回假阳性，在这种情况下，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> 循环可能会过早终止。由于这是一个不常见的情况，你可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> 来验证 <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp>
    循环是否能正确区分有效字符和 <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>。
- en: In this example, the static assertion verifies that <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(unsigned
    char) < sizeof(int)</samp>. The static assertion is placed near the code that
    depends on this assumption being true so that you can easily locate the code that
    will need to be repaired if the assumption is violated. Because static assertions
    are evaluated at compile time, placing them within executable code has no impact
    on the runtime efficiency of the program. See the CERT C rule FIO34-C, “Distinguish
    between characters read from a file and <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">WEOF</samp>,” for more information
    on this topic.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，静态断言验证了 `<samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(unsigned
    char) < sizeof(int)</samp>`。静态断言被放置在依赖于该假设为真的代码附近，这样可以方便地定位如果假设被违反时需要修复的代码。由于静态断言在编译时进行评估，因此将其放入可执行代码中对程序的运行时效率没有影响。有关此主题的更多信息，请参见
    CERT C 规则 FIO34-C，“区分从文件读取的字符与 <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">WEOF</samp>”。
- en: Finally, in [Listing 11-3](chapter11.xhtml#Lis11-3), we use <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>
    to perform compile-time bounds checking.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 [清单 11-3](chapter11.xhtml#Lis11-3) 中，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>
    执行编译时边界检查。
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-3: Using</samp>
    <samp class="I">static_assert</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    perform bounds checking</samp>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-3：使用</samp> <samp class="I">static_assert</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">执行边界检查</samp>
- en: This code snippet uses <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    to copy a constant string <samp class="SANS_TheSansMonoCd_W5Regular_11">prefix</samp>
    to a statically allocated array <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>.
    The static assertion ensures that <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>
    has sufficient space to store at least one additional character for an error code
    following the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码片段使用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>` 将常量字符串
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">prefix</samp>` 复制到静态分配的数组 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">str</samp>`。静态断言确保 `<samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>`
    有足够的空间至少存储一个额外字符，以便在调用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>`
    后存储错误代码。
- en: 'This assumption may become invalid if a developer, for example, reduced <samp
    class="SANS_TheSansMonoCd_W5Regular_11">size</samp> or changed the prefix string
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">"Error Number: "</samp> during
    maintenance. Having added the static assertion, the maintainer would now be warned
    about the problem.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '如果开发人员在维护过程中减小了 `<samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>`
    或将前缀字符串改为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">"Error Number: "</samp>`，该假设可能会变得无效。添加了静态断言后，维护人员将收到有关该问题的警告。'
- en: Remember that the string literal is a message for the developer or maintainer
    and not an end user of the system. It’s intended to provide information useful
    for debugging.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，字符串文字是为开发人员或维护人员提供的消息，而不是系统的最终用户。它旨在提供有助于调试的信息。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Runtime Assertions</samp>
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">运行时断言</samp>
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> macro injects
    runtime diagnostic tests into programs. It’s defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11"><assert.h></samp>
    header file and takes a scalar expression as a single argument:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>` 宏将运行时诊断测试注入到程序中。它在
    `<samp class="SANS_TheSansMonoCd_W5Regular_11"><assert.h></samp>` 头文件中定义，并接受一个标量表达式作为唯一参数：'
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> macro is implementation
    defined. If the scalar expression is equal to 0, the macro expansion typically
    writes information about the failing call (including the argument text, the name
    of the source file <samp class="SANS_TheSansMonoCd_W5Regular_11">__FILE__</samp>,
    the source line number <samp class="SANS_TheSansMonoCd_W5Regular_11">__LINE__</samp>,
    and the name of the enclosing function <samp class="SANS_TheSansMonoCd_W5Regular_11">__func__</samp>)
    to the standard error stream <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>.
    After writing this information to <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> macro calls the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">abort</samp> function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>` 宏是由实现定义的。如果标量表达式等于
    0，宏展开通常会将失败调用的信息（包括参数文本、源文件名 `<samp class="SANS_TheSansMonoCd_W5Regular_11">__FILE__</samp>`、源行号
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">__LINE__</samp>`，以及封闭函数的名称 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">__func__</samp>`）写入标准错误流 `<samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>`。写入该信息后，`<samp
    class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>` 宏会调用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">abort</samp>`
    函数。'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">dup_string</samp> function
    shown in [Listing 11-4](chapter11.xhtml#Lis11-4) uses runtime assertions to check
    that the <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> argument is
    less than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">LIMIT</samp>
    and that <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> is not a null
    pointer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 11-4](chapter11.xhtml#Lis11-4) 中显示的 `<samp class="SANS_TheSansMonoCd_W5Regular_11">dup_string</samp>`
    函数使用运行时断言来检查 `<samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp>` 参数是否小于或等于
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">LIMIT</samp>`，并且 `<samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>`
    不是空指针。
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-4: Using</samp>
    <samp class="I">assert</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    verify program conditions</samp>'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 11-4：使用</samp> <samp class="I">assert</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">来验证程序条件</samp>
- en: 'The messages from these assertions might take the following form:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些断言的消息可能会呈现以下形式：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The implicit assumption is that the caller validates arguments before calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dup_string</samp> so that the function
    is never called with invalid arguments. The runtime assertions are then used to
    validate this assumption during the development and test phases.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式假设是调用者在调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">dup_string</samp>
    之前验证参数，以确保函数永远不会以无效参数被调用。然后，在开发和测试阶段使用运行时断言来验证这个假设。
- en: The assertion’s predicate expression is often reported in a failed assertion
    message, which allows you to use <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    on a string literal with the assertion predicate to generate additional debugging
    information when an assertion fails. Doing so is always safe because string literals
    in C can never have a null pointer value. For example, we can rewrite the assertions
    in [Listing 11-4](chapter11.xhtml#Lis11-4) to have the same functionality but
    provide additional context when the assertion fails, as shown in [Listing 11-5](chapter11.xhtml#Lis11-5).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 断言的谓词表达式通常会在断言失败时的错误消息中报告，这使得你可以在断言失败时，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    将字符串字面量与断言谓词结合，生成额外的调试信息。这样做总是安全的，因为 C 中的字符串字面量永远不会有空指针值。例如，我们可以将 [清单 11-4](chapter11.xhtml#Lis11-4)
    中的断言重写为具有相同功能，但在断言失败时提供额外的上下文，如 [清单 11-5](chapter11.xhtml#Lis11-5) 所示。
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-5: Using</samp>
    <samp class="I">assert</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">with
    additional contextual information</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-5：使用</samp> <samp class="I">assert</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">并附加额外的上下文信息</samp>
- en: 'You should disable assertions before code is deployed by defining the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NDEBUG</samp> macro (typically as a flag
    passed to the compiler). If <samp class="SANS_TheSansMonoCd_W5Regular_11">NDEBUG</samp>
    is defined as a macro name at the point in the source file where <samp class="SANS_TheSansMonoCd_W5Regular_11"><assert.h></samp>
    is included, the <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> macro
    is defined as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码部署之前，应该通过定义 <samp class="SANS_TheSansMonoCd_W5Regular_11">NDEBUG</samp> 宏来禁用断言（通常作为传递给编译器的标志）。如果在源文件中
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><assert.h></samp> 包含的地方定义了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NDEBUG</samp> 宏名称，则 <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>
    宏被定义如下：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The reason the macro does not expand empty is because if it did, then code such
    as
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 宏之所以不会扩展为空，是因为如果它这样做，像这样的代码就会编译失败：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: would compile in release mode but not in debug mode. The reason it expands to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">((void) 0)</samp> rather than just
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> is to prevent warnings
    about statements with no effect. The <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>
    macro is redefined according to the current state of <samp class="SANS_TheSansMonoCd_W5Regular_11">NDEBUG</samp>
    each time that <samp class="SANS_TheSansMonoCd_W5Regular_11"><assert.h></samp>
    is included.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在发布模式下会编译，但在调试模式下不会编译。它扩展为 <samp class="SANS_TheSansMonoCd_W5Regular_11">((void)
    0)</samp> 而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，目的是防止出现没有效果的语句警告。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> 宏会根据每次包含 <samp class="SANS_TheSansMonoCd_W5Regular_11"><assert.h></samp>
    时的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NDEBUG</samp> 当前状态进行重新定义。
- en: 'Use static assertions to check assumptions that can be checked at compile time,
    and use runtime assertions to detect invalid assumptions during testing. Because
    runtime assertions are typically disabled before deployment, avoid using them
    to check for conditions that can come up during normal operations, such as the
    following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态断言来检查在编译时可以检查的假设，使用运行时断言来检测在测试期间无效的假设。因为运行时断言通常在部署之前被禁用，所以避免使用它们来检查正常操作中可能出现的条件，例如以下情况：
- en: Invalid input
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效输入
- en: Errors opening, reading, or writing streams
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开、读取或写入流时出错
- en: Out-of-memory conditions from dynamic allocation functions
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态分配函数中的内存不足情况
- en: System call errors
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统调用错误
- en: Invalid permissions
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效权限
- en: You should instead implement these checks as normal error-checking code that’s
    always included in the executable. Assertions should be used only to validate
    preconditions, postconditions, and invariants designed into the code (programming
    errors).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该改为将这些检查实现为正常的错误检查代码，这些代码始终包含在可执行文件中。断言应该仅用于验证代码中设计的前置条件、后置条件和不变式（编程错误）。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Compiler Settings and Flags</samp>
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">编译器设置和标志</samp>
- en: Compilers typically don’t enable optimization or security hardening by default.
    Instead, you can enable optimization, error detection, and security hardening
    using build flags (Weimer 2018). I recommend specific flags for GCC, Clang, and
    Visual C++ in the next section, after first describing how and why you might want
    to use them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通常默认不启用优化或安全加固。相反，你可以通过构建标志启用优化、错误检测和安全加固（Weimer 2018）。在下一节中，我将推荐GCC、Clang和Visual
    C++的特定标志，首先介绍如何以及为什么你可能需要使用它们。
- en: Select your build flags based on what you’re trying to accomplish. Distinct
    phases of software development call for different compiler and linker configurations.
    Some flags, such as the warnings, will be common to all phases. Other flags, such
    as the debug or the optimization level, are specific to each phase.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你想要实现的目标选择你的构建标志。软件开发的不同阶段需要不同的编译器和链接器配置。某些标志，例如警告，适用于所有阶段。其他标志，例如调试或优化级别，则特定于每个阶段。
- en: '**Build** The goal of the build phase is to take full advantage of compiler
    analysis to eliminate defects before debugging. Dealing with numerous diagnostics
    at this stage can seem bothersome but is much better than having to find these
    problems through debugging and testing, or not finding them until after the code
    has shipped. During the build phase, you should use compiler options that maximize
    diagnostics to help you eliminate as many defects as possible.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建** 构建阶段的目标是充分利用编译器分析，在调试之前消除缺陷。在此阶段处理众多诊断信息可能会让人觉得烦琐，但比起通过调试和测试来发现这些问题，或等到代码发布后才发现问题，要好得多。在构建阶段，你应该使用能最大化诊断信息的编译器选项，以帮助你尽可能多地消除缺陷。'
- en: '**Debug** During debugging, you’re typically trying to determine why your code
    isn’t working. To best accomplish this, use a set of compiler flags that includes
    debug information, allows assertions to be useful, and enables a quick turnaround
    time for the inevitable edit-compile-debug cycle.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试** 在调试过程中，你通常是想确定代码为什么不工作。为了最好地完成这一任务，请使用一组包含调试信息、允许断言发挥作用并能快速进行编译-调试循环的编译器标志。'
- en: '**Test** You may want to retain debug information and leave assertions enabled
    during testing to assist in identifying the root cause of any problems that are
    discovered. Runtime instrumentation can be injected to help detect errors.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试** 在测试过程中，你可能希望保留调试信息并保持断言启用，以帮助识别发现的任何问题的根本原因。可以注入运行时插装来帮助检测错误。'
- en: '**Profile-Guided Optimization** This configuration defines compiler and linker
    flags that control how the compiler adds runtime instrumentation to the code it
    normally generates. One purpose of instrumentation is to collect profiling statistics,
    which can be used to find program hot spots for profile-guided optimizations.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置引导优化** 此配置定义了控制编译器如何向其正常生成的代码添加运行时插装的编译器和链接器标志。插装的一个目的是收集性能分析统计数据，这些数据可以用来找到程序的热点，从而进行配置引导优化。'
- en: '**Release** The final phase is to build the code for deployment to its operational
    environment. Before deploying the system, make sure you thoroughly test your release
    configuration, because using a different set of compilation flags can trigger
    new defects, for example, from latent undefined behaviors or timing effects caused
    by optimization.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**发布** 最后阶段是将代码构建到部署到操作环境的版本。在部署系统之前，确保彻底测试你的发布配置，因为使用不同的编译标志集可能会引发新的缺陷，例如由优化引起的潜在未定义行为或时序效应。'
- en: I’ll now cover some specific compiler and linker flags you might want to use
    for your compiler and software development phase.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将介绍一些你可能希望在编译器和软件开发阶段使用的特定编译器和链接器标志。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GCC and Clang Flags</samp>
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GCC和Clang标志</samp>
- en: '[Table 11-1](chapter11.xhtml#tab11-1) lists recommended compiler and linker
    options (aka *flags*) for both GCC and Clang. You can find documentation for compiler
    and linker options in the GCC manual (*[https://<wbr>gcc<wbr>.gnu<wbr>.org<wbr>/onlinedocs<wbr>/gcc<wbr>/Invoking<wbr>-GCC<wbr>.html](https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html)*)
    and the Clang Compiler User’s Manual (*[https://<wbr>clang<wbr>.llvm<wbr>.org<wbr>/docs<wbr>/UsersManual<wbr>.html#command<wbr>-line<wbr>-options](https://clang.llvm.org/docs/UsersManual.html#command-line-options)*).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 11-1](chapter11.xhtml#tab11-1)列出了 GCC 和 Clang 的推荐编译器和链接器选项（即*标志*）。你可以在 GCC
    手册中找到编译器和链接器选项的文档（*[https://<wbr>gcc<wbr>.gnu<wbr>.org<wbr>/onlinedocs<wbr>/gcc<wbr>/Invoking<wbr>-GCC<wbr>.html](https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html)*)
    和 Clang 编译器用户手册中（*[https://<wbr>clang<wbr>.llvm<wbr>.org<wbr>/docs<wbr>/UsersManual<wbr>.html#command<wbr>-line<wbr>-options](https://clang.llvm.org/docs/UsersManual.html#command-line-options)*）。'
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 11-1:</samp> <samp class="SANS_Futura_Std_Book_11">Recommended
    Compiler and Linker Flags for GCC and Clang</samp>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 11-1：</samp> <samp class="SANS_Futura_Std_Book_11">GCC
    和 Clang 的推荐编译器和链接器标志</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Flag</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Purpose</samp>
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">标志</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">用途</samp>
    |'
- en: '| --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE=2</samp>
    | <samp class="SANS_Futura_Std_Book_11">Detect buffer overflows</samp> |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE=2</samp>
    | <samp class="SANS_Futura_Std_Book_11">检测缓冲区溢出</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fpie -Wl,-pie</samp> | <samp
    class="SANS_Futura_Std_Book_11">Required for address space layout randomization</samp>
    |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fpie -Wl,-pie</samp> | <samp
    class="SANS_Futura_Std_Book_11">地址空间布局随机化所需</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fpic -shared</samp> | <samp
    class="SANS_Futura_Std_Book_11">Disable text relocations for shared libraries</samp>
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fpic -shared</samp> | <samp
    class="SANS_Futura_Std_Book_11">禁用共享库的文本重定位</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-g3</samp> | <samp class="SANS_Futura_Std_Book_11">Generate
    abundant debugging information</samp> |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-g3</samp> | <samp class="SANS_Futura_Std_Book_11">生成大量调试信息</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-O2</samp> | <samp class="SANS_Futura_Std_Book_11">Optimize
    your code for speed/space efficiency</samp> |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-O2</samp> | <samp class="SANS_Futura_Std_Book_11">优化代码以提高速度/空间效率</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp> | <samp class="SANS_Futura_Std_Book_11">Turn
    on recommended compiler warnings</samp> |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp> | <samp class="SANS_Futura_Std_Book_11">启用推荐的编译器警告</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp> | <samp class="SANS_Futura_Std_Book_11">Turn
    on even more recommended compiler warnings</samp> |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp> | <samp class="SANS_Futura_Std_Book_11">启用更多推荐的编译器警告</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-Werror</samp> | <samp class="SANS_Futura_Std_Book_11">Turn
    warnings into errors</samp> |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-Werror</samp> | <samp class="SANS_Futura_Std_Book_11">将警告转换为错误</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=c23</samp> | <samp class="SANS_Futura_Std_Book_11">Specify
    the language standard</samp> |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=c23</samp> | <samp class="SANS_Futura_Std_Book_11">指定语言标准</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-pedantic</samp> | <samp class="SANS_Futura_Std_Book_11">Issue
    warnings demanded by strict conformance to the standard</samp> |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-pedantic</samp> | <samp class="SANS_Futura_Std_Book_11">发出严格遵守标准所要求的警告</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wconversion</samp> | <samp
    class="SANS_Futura_Std_Book_11">Warn for implicit conversions that may alter a
    value</samp> |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wconversion</samp> | <samp
    class="SANS_Futura_Std_Book_11">警告可能改变值的隐式转换</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wl,-z,noexecstack</samp> |
    <samp class="SANS_Futura_Std_Book_11">Mark the stack segments as nonexecutable</samp>
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wl,-z,noexecstack</samp> |
    <samp class="SANS_Futura_Std_Book_11">标记栈段为不可执行</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fstack-protector-strong</samp>
    | <samp class="SANS_Futura_Std_Book_11">Add stack protection to functions</samp>
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fstack-protector-strong</samp>
    | <samp class="SANS_Futura_Std_Book_11">为函数添加栈保护</samp> |'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-O</samp>
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-O</samp>
- en: The uppercase letter <samp class="SANS_TheSansMonoCd_W5Regular_11">-O</samp>
    flag controls *compiler optimization*. Most optimizations are completely disabled
    at optimization level 0 (<samp class="SANS_TheSansMonoCd_W5Regular_11">-O0</samp>).
    This is the default when no optimization level has been set by a command line
    option. Similarly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Og</samp>
    flag suppresses optimization passes that may hinder the debugging experience.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 大写字母 <samp class="SANS_TheSansMonoCd_W5Regular_11">-O</samp> 标志控制 *编译器优化*。在优化级别
    0（<samp class="SANS_TheSansMonoCd_W5Regular_11">-O0</samp>）下，大多数优化都被完全禁用。这是当没有通过命令行选项设置优化级别时的默认值。同样，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-Og</samp> 标志会抑制那些可能妨碍调试体验的优化过程。
- en: Many diagnostics are issued by GCC only at higher optimization levels, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">-02</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">-Os</samp>.
    To ensure that issues are identified during development, use the same (higher)
    optimization level you plan to adopt in production during the compilation and
    analysis phase. Clang, on the other hand, does not require the optimizer to issue
    diagnostics. As a result, Clang can be run with optimizations disabled during
    the compilation/analysis and debug phases.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 许多诊断仅在更高的优化级别下由 GCC 发出，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">-02</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">-Os</samp>。为了确保在开发期间能够识别问题，请在编译和分析阶段使用与计划在生产中采用的相同（更高的）优化级别。另一方面，Clang
    不需要优化器发出诊断。因此，Clang 可以在编译/分析和调试阶段禁用优化来运行。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Os</samp> compiler option
    optimizes for size, enabling all <samp class="SANS_TheSansMonoCd_W5Regular_11">-O2</samp>
    optimizations except those that often increase code size. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Oz</samp>
    compiler option optimizes aggressively for size rather than speed, which may increase
    the number of instructions executed if those instructions require fewer bytes
    to encode. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Oz</samp> option
    behaves similarly to <samp class="SANS_TheSansMonoCd_W5Regular_11">-Os</samp>,
    and it may be used in Clang but only in conjunction with <samp class="SANS_TheSansMonoCd_W5Regular_11">-mno-outline</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Oz</samp> compiler option may
    be used in GCC versions 12.1 or greater.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-Os</samp> 编译器选项优化程序大小，启用所有 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-O2</samp> 优化，除了那些通常会增加代码大小的优化。<samp class="SANS_TheSansMonoCd_W5Regular_11">-Oz</samp>
    编译器选项则更加激进地优化程序大小，而不是速度，这可能会增加执行的指令数，尤其是当这些指令需要更少的字节来编码时。<samp class="SANS_TheSansMonoCd_W5Regular_11">-Oz</samp>
    选项的行为类似于 <samp class="SANS_TheSansMonoCd_W5Regular_11">-Os</samp>，并且可以在 Clang
    中使用，但仅与 <samp class="SANS_TheSansMonoCd_W5Regular_11">-mno-outline</samp> 一起使用。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-Oz</samp> 编译器选项可以在 GCC 12.1 或更高版本中使用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-glevel</samp>
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-glevel</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-g</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">level</samp>
    flag produces debugging information in the operating system’s native format. You
    can specify how much information to produce by setting the debug <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">level</samp>.
    The default level is <samp class="SANS_TheSansMonoCd_W5Regular_11">-g2</samp>.
    Level 3 (<samp class="SANS_TheSansMonoCd_W5Regular_11">-g3</samp>) includes extra
    information, such as all the macro definitions present in the program. Level 3
    also allows you to expand macros in debuggers that support the capability.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-g</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">level</samp>
    标志生成操作系统本地格式的调试信息。你可以通过设置调试 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">level</samp>
    来指定生成多少信息。默认级别是 <samp class="SANS_TheSansMonoCd_W5Regular_11">-g2</samp>。级别 3（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-g3</samp>）包括额外的信息，例如程序中所有宏定义。级别 3 还允许你在支持此功能的调试器中展开宏。
- en: Different settings are appropriate for debugging. Optimization levels should
    be low or disabled so that the machine instructions correspond closely to the
    source code. Symbols should also be included to assist in debugging. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-O0 -g3</samp> compiler flags are a good
    default, although other options are acceptable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于调试，应该使用不同的设置。优化级别应保持较低或禁用，以便机器指令能够与源代码紧密对应。还应包含符号来帮助调试。<samp class="SANS_TheSansMonoCd_W5Regular_11">-O0
    -g3</samp> 编译器标志是一个不错的默认值，尽管其他选项也可以接受。
- en: 'Consider the following program:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下程序：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Og</samp> compiler option
    affects only the optimization level without enabling debug symbols:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-Og</samp>编译器选项仅影响优化级别，而不启用调试符号：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Compiling with <samp class="SANS_TheSansMonoCd_W5Regular_11">-Og -g</samp>
    provides some symbols:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用<samp class="SANS_TheSansMonoCd_W5Regular_11">-Og -g</samp>编译会提供一些符号：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Compiling with <samp class="SANS_TheSansMonoCd_W5Regular_11">-Og -g3</samp>
    adds more symbols:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用<samp class="SANS_TheSansMonoCd_W5Regular_11">-Og -g3</samp>编译会添加更多符号：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-g3</samp> option causes debugging
    information to be generated in the operating system’s native format, but the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-ggdb3</samp> option tells GCC to use
    the most expressive format available for use by the GNU Project debugger (GDB).
    As a result, if you are only debugging with GDB, <samp class="SANS_TheSansMonoCd_W5Regular_11">-Og
    -ggdb3</samp> is also a good choice of options.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-g3</samp>选项会生成操作系统本地格式的调试信息，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-ggdb3</samp>选项则指示GCC使用GNU项目调试器（GDB）可用的最具表达力的格式。因此，如果你仅使用GDB进行调试，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-Og -ggdb3</samp>也是一个不错的选择。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-O0 -g3</samp> options are
    recommended for the standard edit-compile-debug cycle.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-O0 -g3</samp>选项推荐用于标准的编辑-编译-调试周期。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-Wall and -Wextra</samp>
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-Wall 和 -Wextra</samp>
- en: 'Compilers typically enable by default only the most conservatively correct
    diagnostic messages. Additional diagnostics can be enabled to check source code
    more aggressively for issues. Use the following flags to enable additional diagnostic
    messages when compiling code with GCC and Clang: <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp>.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通常默认只启用最保守的正确诊断信息。可以启用额外的诊断信息，以便更积极地检查源代码中的问题。使用以下标志，可以在用GCC和Clang编译代码时启用额外的诊断信息：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp>。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp>
    compiler flags enable predefined sets of compile-time warnings. The warnings in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp> set are generally
    easy to avoid or eliminate by modifying the diagnosed code. The warnings in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp> set either are situational
    or indicate problematic constructs that are harder to avoid and, in some cases,
    may be necessary.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp>编译器标志启用预定义的编译时警告集。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp>集中的警告通常可以通过修改代码来轻松避免或消除。而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp>集中的警告要么是情境性的，要么是指示更难避免的问题构造，在某些情况下可能是必要的。
- en: 'Despite their names, the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp> options do not
    enable all possible warning diagnostics; they enable only a predefined subset.
    For a complete list of specific warnings enabled by the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp> compiler flags,
    on GCC run:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名称如此，<samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp>选项并不会启用所有可能的警告诊断；它们只启用预定义的子集。要查看由<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp>编译器标志启用的完整特定警告列表，请在GCC中运行：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Alternatively, you can consult the documentation for GCC warning options and
    Clang diagnostic flags.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以查阅GCC警告选项和Clang诊断标志的文档。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-Wconversion</samp>
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-Wconversion</samp>
- en: 'Data type conversions can alter data values in unexpected ways. Memory safety
    violations may result from adding or subtracting these values from a pointer.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wconversion</samp> compiler
    option warns about:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型转换可能以意想不到的方式改变数据值。从指针中加减这些值可能会导致内存安全问题。<samp class="SANS_TheSansMonoCd_W5Regular_11">-Wconversion</samp>编译器选项会发出警告：
- en: Implicit conversions that may alter a value, including conversions between floating-point
    and integer values
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会改变值的隐式转换，包括浮点数与整数值之间的转换
- en: 'Conversions between signed and unsigned integers, for example:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有符号和无符号整数之间的转换，例如：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Conversions to smaller types
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换为较小的类型
- en: Warnings about conversions between signed and unsigned integers can be disabled
    by using <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wno-sign-conversion</samp>,
    but they’re often useful in finding certain classes of defects and security vulnerabilities.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wconversion</samp> command
    line option should remain enabled.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 关于有符号和无符号整数之间转换的警告可以通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wno-sign-conversion</samp>
    来禁用，但这些警告通常有助于发现某些类型的缺陷和安全漏洞。<samp class="SANS_TheSansMonoCd_W5Regular_11">-Wconversion</samp>
    命令行选项应保持启用状态。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-Werror</samp>
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-Werror</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Werror</samp> flag turns
    all warnings into errors, requiring you to address them before you can begin debugging.
    This flag simply encourages good programming discipline.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-Werror</samp> 标志将所有警告转化为错误，要求您在开始调试之前解决它们。此标志简单地鼓励良好的编程规范。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-std=</samp>
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-std=</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=</samp> flag can be used
    to specify the language standard as <samp class="SANS_TheSansMonoCd_W5Regular_11">c89</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c90</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">c99</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c11</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">c17</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">c23</samp> (you may need to specify
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=c2x</samp> when using an older
    compiler). If no C language dialect options are given, the default for GCC 13
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=gnu17</samp>, which provides
    extensions to the C language that, on rare occasions, conflict with the C standard.
    For portability, specify the standard you’re using. For access to new language
    features, specify a recent standard. A good choice if you are reading this second
    edition of *Effective C* is <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=c23</samp>.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=</samp> 标志可用于指定语言标准为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">c89</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">c90</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">c99</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">c11</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">c17</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">c23</samp>（如果使用较旧的编译器，可能需要指定
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=c2x</samp>）。如果没有指定 C 语言方言选项，GCC
    13 的默认值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=gnu17</samp>，它为 C
    语言提供了一些扩展，这些扩展在极少数情况下可能与 C 标准发生冲突。为了提高可移植性，请指定您使用的标准。为了访问新语言功能，请指定最近的标准。如果您正在阅读
    *Effective C* 的第二版，一个不错的选择是 <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=c23</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-pedantic</samp>
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-pedantic</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-pedantic</samp> flag issues
    warnings when code deviates from strict conformance to the standard. This flag
    is typically used in conjunction with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=</samp>
    flag to improve the code’s portability.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-pedantic</samp> 标志会在代码偏离严格符合标准时发出警告。此标志通常与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=</samp> 标志一起使用，以提高代码的可移植性。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-D_FORTIFY_SOURCE=2</samp>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-D_FORTIFY_SOURCE=2</samp>'
- en: The _<samp class="SANS_TheSansMonoCd_W5Regular_11">FORTIFY_SOURCE</samp> macro
    provides lightweight support for detecting buffer overflows in functions that
    perform operations on memory and strings. This macro can’t detect all types of
    buffer overflows, but compiling your source with <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE=2</samp>
    provides an extra level of validation for functions that copy memory and are a
    potential source of buffer overflows such as <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sprintf</samp>.
    Some of the checks can be performed at compile time and result in diagnostics;
    others occur at runtime and can result in a runtime error.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">_FORTIFY_SOURCE</samp> 宏为检测对内存和字符串进行操作的函数中的缓冲区溢出提供了轻量级支持。该宏无法检测所有类型的缓冲区溢出，但通过使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE=2</samp> 编译源代码，可以为那些复制内存并可能导致缓冲区溢出的函数（例如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">sprintf</samp>）提供额外的验证。一些检查可以在编译时执行并生成诊断信息；其他检查则在运行时执行，并可能导致运行时错误。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">_FORTIFY_SOURCE</samp> macro
    requires optimizations to be enabled. Consequently, it must be disabled for unoptimized
    debug builds.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">_FORTIFY_SOURCE</samp> 宏要求启用优化。因此，它必须在未优化的调试构建中禁用。
- en: To overwrite a predefined <samp class="SANS_TheSansMonoCd_W5Regular_11">_FORTIFY_SOURCE</samp>
    value, turn it off with <samp class="SANS_TheSansMonoCd_W5Regular_11">-U_FORTIFY
    _SOURCE</samp> and on again with <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE=2</samp>.
    This will eliminate the warning that macros are being redefined.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖预定义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">_FORTIFY_SOURCE</samp>
    值，首先使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">-U_FORTIFY_SOURCE</samp>
    关闭它，然后用 <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE=2</samp>
    再次启用。这将消除宏被重新定义的警告。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">_FORTIFY_SOURCE=3</samp> macro
    has improved compiler checks for buffer overflows since version 12 of GCC and
    version 2.34 of the GNU C Library (glibc). The <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE={1,2,3}</samp>
    macro for glibc relies heavily on GCC-specific implementation details. Clang implements
    its own style of fortified function calls.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 自 GCC 12 版本和 GNU C 库（glibc）2.34 版本起，<samp class="SANS_TheSansMonoCd_W5Regular_11">_FORTIFY_SOURCE=3</samp>
    宏提供了改进的编译器检查，用于检测缓冲区溢出。glibc 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE={1,2,3}</samp>
    宏在很大程度上依赖于 GCC 特定的实现细节。Clang 实现了自己风格的强化函数调用。
- en: Specify either <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE=2</samp>
    (recommended) or <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE=1</samp>
    for analysis, testing, and production builds using Clang and GCC versions prior
    to 12.0 and <samp class="SANS_TheSansMonoCd_W5Regular_11">_FORTIFY_SOURCE=3</samp>
    for GCC version 12.0 and later.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 Clang 和 GCC 版本低于 12.0 的分析、测试和生产构建，请指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE=2</samp>（推荐）或
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE=1</samp>，对于 GCC
    12.0 及更高版本，请使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">_FORTIFY_SOURCE=3</samp>。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-fpie -Wl, -pie, and -fpic
    -shared</samp>
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-fpie -Wl, -pie, 和 -fpic -shared</samp>
- en: '*Address space layout randomization (ASLR)* is a security mechanism that randomizes
    the process’s memory space to prevent attackers from predicting the location of
    the code they’re trying to execute. You can learn more about ASLR and other security
    mitigations in *Secure Coding in C and C++* (Seacord 2013).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*地址空间布局随机化（ASLR）* 是一种安全机制，通过随机化进程的内存空间来防止攻击者预测他们试图执行的代码的位置。你可以在 *《C 和 C++ 安全编码》*（Seacord
    2013）中了解更多关于 ASLR 和其他安全缓解措施的信息。'
- en: You must specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">-fpie -Wl,</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-pie</samp> flags to create
    position-independent executable programs and make it possible to enable ASLR for
    your main program (executable). However, while code emitted for your main program
    with these options is position independent, it does use some relocations that
    cannot be used in shared libraries (dynamic shared objects). For those, use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-fpic</samp> and link with <samp class="SANS_TheSansMonoCd_W5Regular_11">-shared</samp>
    to avoid text relocations on architectures that support position-dependent shared
    libraries. Dynamic shared objects are always position independent and therefore
    support ASLR.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 必须指定 <samp class="SANS_TheSansMonoCd_W5Regular_11">-fpie -Wl,</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-pie</samp> 标志来创建位置无关的可执行程序，并使得能够为主程序（可执行文件）启用
    ASLR。然而，尽管这些选项生成的主程序代码是位置无关的，但它使用了一些在共享库（动态共享对象）中不能使用的重定位。对于这些，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">-fpic</samp>
    并使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">-shared</samp> 进行链接，以避免在支持位置相关共享库的架构上进行文本重定位。动态共享对象始终是位置无关的，因此支持
    ASLR。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-Wl,-z,noexecstack</samp>
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-Wl,-z,noexecstack</samp>
- en: Several operating systems, including OpenBSD, Windows, Linux, and macOS, enforce
    reduced privileges in the kernel to prevent any part of the process address space
    from being both writable and executable. This policy is called W^X.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 包括 OpenBSD、Windows、Linux 和 macOS 在内的多个操作系统，在内核中强制执行减少权限，以防止进程地址空间的任何部分同时具有可写和可执行权限。这一政策称为
    W^X。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wl,-z,noexecstack</samp>
    linker option tells the linker to mark the stack segments as nonexecutable, which
    enables the operating system (OS) to configure memory access rights when the program
    executable is loaded into memory.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wl,-z,noexecstack</samp> 链接器选项告诉链接器将栈段标记为不可执行，这使得操作系统（OS）在加载程序可执行文件到内存时能够配置内存访问权限。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-fstack-protector-strong</samp>
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-fstack-protector-strong</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-fstack-protector-strong</samp>
    option protects applications from the most common forms of stack buffer overflow
    exploits by adding a stack canary. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-fstack-protector</samp>
    option is often viewed as insufficient and the <samp class="SANS_TheSansMonoCd_W5Regular_11">-fstack-protector-all</samp>
    option as excessive. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-fstack-protector-strong</samp>
    option was introduced as a compromise between these two extremes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">-fstack-protector-strong</samp>
    选项通过添加栈金丝雀，保护应用程序免受最常见的栈缓冲区溢出攻击。<samp class="SANS_TheSansMonoCd_W5Regular_11">-fstack-protector</samp>
    选项通常被认为不足，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">-fstack-protector-all</samp>
    选项则被认为过度。<samp class="SANS_TheSansMonoCd_W5Regular_11">-fstack-protector-strong</samp>
    选项作为这两者之间的折衷方案被引入。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Visual C++ Options</samp>
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Visual C++ 选项</samp>
- en: Visual C++ provides a wide assortment of compiler options, many of which are
    similar to the options available for GCC and Clang. One obvious difference is
    that Visual C++ generally uses the forward slash (<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>)
    character instead of a hyphen (<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>)
    to indicate a flag. [Table 11-2](chapter11.xhtml#tab11-2) lists recommended compiler
    and linker flags for Visual C++. (For more information on Visual C++ options,
    see *[https://<wbr>docs<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/cpp<wbr>/build<wbr>/reference<wbr>/compiler<wbr>-options<wbr>-listed<wbr>-by<wbr>-category](https://docs.microsoft.com/en-us/cpp/build/reference/compiler-options-listed-by-category)*.)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Visual C++ 提供了种类繁多的编译器选项，其中许多选项与 GCC 和 Clang 的选项类似。一个显著的区别是，Visual C++ 通常使用斜杠（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">/</samp>）字符而不是连字符（<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>）来表示标志。[表
    11-2](chapter11.xhtml#tab11-2) 列出了 Visual C++ 的推荐编译器和链接器标志。（有关 Visual C++ 选项的更多信息，请参阅
    *[https://<wbr>docs<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/cpp<wbr>/build<wbr>/reference<wbr>/compiler<wbr>-options<wbr>-listed<wbr>-by<wbr>-category](https://docs.microsoft.com/en-us/cpp/build/reference/compiler-options-listed-by-category)*.)
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 11-2:</samp> <samp class="SANS_Futura_Std_Book_11">Recommended
    Compiler Flags for Visual C++</samp>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 11-2：</samp> <samp class="SANS_Futura_Std_Book_11">Visual
    C++ 推荐的编译器标志</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Flag</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Purpose</samp>
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">标志</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">目的</samp>
    |'
- en: '| --- | --- |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/guard:cf</samp> | <samp class="SANS_Futura_Std_Book_11">Add
    control flow guard security checks</samp> |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/guard:cf</samp> | <samp class="SANS_Futura_Std_Book_11">添加控制流保护安全检查</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/analyze</samp> | <samp class="SANS_Futura_Std_Book_11">Enable
    static analysis</samp> |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/analyze</samp> | <samp class="SANS_Futura_Std_Book_11">启用静态分析</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/sdl</samp> | <samp class="SANS_Futura_Std_Book_11">Enable
    security features</samp> |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/sdl</samp> | <samp class="SANS_Futura_Std_Book_11">启用安全功能</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/permissive-</samp> | <samp
    class="SANS_Futura_Std_Book_11">Specify standards conformance mode to the compiler</samp>
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/permissive-</samp> | <samp
    class="SANS_Futura_Std_Book_11">指定编译器的标准符合模式</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/O2</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    optimization to level 2</samp> |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/O2</samp> | <samp class="SANS_Futura_Std_Book_11">将优化级别设置为
    2</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/W4</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    compiler warnings to level 4</samp> |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/W4</samp> | <samp class="SANS_Futura_Std_Book_11">将编译器警告设置为级别
    4</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/WX</samp> | <samp class="SANS_Futura_Std_Book_11">Turn
    warnings into errors</samp> |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/WX</samp> | <samp class="SANS_Futura_Std_Book_11">将警告视为错误</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/std:clatest</samp> | <samp
    class="SANS_Futura_Std_Book_11">Select the latest/greatest language version</samp>
    |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/std:clatest</samp> | <samp
    class="SANS_Futura_Std_Book_11">选择最新/最强的语言版本</samp> |'
- en: Several of these options are similar to options provided by the GCC and Clang
    compilers. The <samp class="SANS_TheSansMonoCd_W5Regular_11">/O2</samp> optimization
    level is appropriate for deployed code, while <samp class="SANS_TheSansMonoCd_W5Regular_11">/Od</samp>
    disables optimization to speed compilation and simplify debugging. The <samp class="SANS_TheSansMonoCd_W5Regular_11">/W4</samp>
    warning level is appropriate for new code, as it’s roughly equivalent to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp> in GCC and Clang. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">/Wall</samp> option in Visual C++ isn’t
    recommended because it produces a high number of false positives. The <samp class="SANS_TheSansMonoCd_W5Regular_11">/WX</samp>
    option turns warnings into errors and is equivalent to the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Werror</samp>
    flag in GCC and Clang. I cover the remaining flags in further detail in the following
    sections.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项中的几个类似于 GCC 和 Clang 编译器提供的选项。<samp class="SANS_TheSansMonoCd_W5Regular_11">/O2</samp>优化级别适用于部署代码，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">/Od</samp>禁用优化，以加速编译并简化调试。<samp class="SANS_TheSansMonoCd_W5Regular_11">/W4</samp>警告级别适用于新代码，因为它大致相当于
    GCC 和 Clang 中的<samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp>。Visual
    C++ 中的<samp class="SANS_TheSansMonoCd_W5Regular_11">/Wall</samp>选项不推荐使用，因为它会产生大量假阳性。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">/WX</samp>选项将警告转换为错误，相当于 GCC 和 Clang 中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-Werror</samp>标志。我将在接下来的部分中详细介绍其余的标志。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">/guard:cf</samp>
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">/guard:cf</samp>
- en: When you specify the *control flow guard (CFG)* option, the compiler and linker
    insert extra runtime security checks to detect attempts to compromise your code.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">/guard:cf</samp> option must
    be passed to both the compiler and the linker.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当你指定*控制流保护（CFG）*选项时，编译器和链接器会插入额外的运行时安全检查，以检测是否存在危害代码的尝试。<samp class="SANS_TheSansMonoCd_W5Regular_11">/guard:cf</samp>选项必须同时传递给编译器和链接器。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">/analyze</samp>
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">/analyze</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">/analyze</samp> flag enables
    static analysis, which provides information about possible defects in your code.
    I discuss static analysis in more detail in “Static Analysis” on [page 251](#pg_251).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">/analyze</samp> 标志启用静态分析，它提供有关代码中可能存在缺陷的信息。我在《静态分析》一节中详细讨论了静态分析，见
    [第 251 页](#pg_251)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">/sdl</samp>
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">/sdl</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">/sdl</samp> flag enables additional
    security features, including treating extra security-relevant warnings as errors
    and additional secure code-generation features. It also enables other security
    features from the Microsoft *Security Development Lifecycle (SDL)*. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">/sdl</samp> flag should be used in all
    production builds where security is a concern.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">/sdl</samp> 标志启用额外的安全特性，包括将额外的安全相关警告视为错误，并启用其他安全代码生成特性。它还启用了来自
    Microsoft *安全开发生命周期 (SDL)* 的其他安全功能。在所有涉及安全的生产构建中，都应该使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">/sdl</samp>
    标志。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">/permissive-</samp>
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">/permissive-</samp>
- en: You can use <samp class="SANS_TheSansMonoCd_W5Regular_11">/permissive-</samp>
    to help identify and fix conformance issues in your code, thereby improving your
    code’s correctness and portability. This option disables permissive behaviors
    and sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">/Zc</samp> compiler
    options for strict conformance. In the integrated development environment (IDE),
    this option also underlines nonconforming code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">/permissive-</samp> 来帮助识别并修复代码中的合规性问题，从而提高代码的正确性和可移植性。这个选项禁用了宽松行为，并设置了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">/Zc</samp> 编译器选项以严格遵守规范。在集成开发环境（IDE）中，这个选项还会下划线标出不符合规范的代码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">/std:clatest</samp>
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">/std:clatest</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">/std:clatest</samp> option
    enables all currently implemented compiler and standard library features proposed
    for C23\. There is no <samp class="SANS_TheSansMonoCd_W5Regular_11">/std:c23</samp>
    at the time of writing, but once one becomes available, you can use it to build
    C23 code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">/std:clatest</samp> 选项启用了所有当前实施的、为
    C23 提出的编译器和标准库特性。在写作时，尚未提供 <samp class="SANS_TheSansMonoCd_W5Regular_11">/std:c23</samp>，但一旦可用，你就可以使用它来构建
    C23 代码。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Debugging</samp>
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">调试</samp>
- en: I’ve been programming professionally for 42 years. Once or maybe twice during
    that time, I’ve written a program that compiled and ran correctly on the first
    try. For all the other times, there is debugging.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我从事专业编程工作已经42年了。在这段时间里，也许只有一两次，我写的程序在第一次尝试时就成功编译并运行了。对于所有其他情况，都会涉及调试。
- en: Let’s debug a faulty program. The program shown in [Listing 11-6](chapter11.xhtml#Lis11-6)
    is an early version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp>
    function. We reviewed a finished version of this program in [Chapter 7](chapter7.xhtml),
    but this version is not yet ready to deploy.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调试一个有问题的程序。示例中展示的程序是 <samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp>
    函数的早期版本。我们在[第 7 章](chapter7.xhtml)中回顾了这个程序的最终版本，但这个版本尚未准备好部署。
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-6: Printing an error</samp>'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 11-6：打印错误</samp>
- en: 'When we run this program as shown, it outputs my name as expected:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按照示例运行这个程序时，它会按预期输出我的名字：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, we also want to ensure that this program, which uses a fixed-size
    array for <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>, properly
    handles the case where the full name is larger than the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    array. To test this, we can change the size of the array to a too-small value:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还希望确保这个程序能够正确处理使用固定大小数组来存储 <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    的情况，特别是当完整的名字超过 <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> 数组的大小时。为了测试这一点，我们可以将数组的大小更改为一个过小的值：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, when we run the program, we learn we have a problem but not much more
    than that:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行程序时，我们得知程序有问题，但没有更多信息：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Instead of adding print statements, we’ll take the plunge and debug this program
    using Visual Studio Code on Linux. Just running this program in the debugger,
    as shown in [Figure 11-1](chapter11.xhtml#fig11-1), provides us with some information
    that we didn’t previously have.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会通过添加打印语句来调试，而是决定在 Linux 上使用 Visual Studio Code 调试这个程序。只需在调试器中运行程序，如 [图 11-1](chapter11.xhtml#fig11-1)
    所示，就能获得一些我们之前没有的信息。
- en: '![](../images/f11001.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/f11001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-1: Debugging a program
    in Visual Studio Code</samp>'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-1：在 Visual Studio Code
    中调试程序</samp>
- en: We can see from the CALL STACK pane that we are crashing in the <samp class="SANS_TheSansMonoCd_W5Regular_11">__memmove_avx_unaligned_erms</samp>
    function in libc.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从调用栈面板中我们可以看到，程序在 libc 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">__memmove_avx_unaligned_erms</samp>
    函数崩溃。
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can also see that the segmentation fault is occurring on the line with the
    call to <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>. There isn’t
    much else going on in this line, so it’s reasonable to surmise that this function
    is a <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> helper function.
    It’s seldom the case that the bug is in the implementation of the library function,
    so we’ll assume for now that we’re passing an invalid set of arguments.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到，段错误发生在调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    的那一行。由于这一行没有其他复杂的操作，所以可以合理推测这是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    辅助函数。通常情况下，库函数的实现并不是 bug 的根源，所以我们暂时假设是传递了一组无效的参数。
- en: 'Before looking at the arguments, let’s review the description of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function from the C23 standard:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看参数之前，让我们回顾一下 C23 标准中关于 <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    函数的描述：
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">#include <string.h></samp>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">#include <string.h></samp>
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">void *memccpy(void * restrict
    s1, const void * restrict s2, int c, size_t n);</samp>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">void *memccpy(void * restrict
    s1, const void * restrict s2, int c, size_t n);</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function copies
    characters from the object pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">s2</samp>
    into the object pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">s1</samp>,
    stopping after the first occurrence of character <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    (converted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>)
    is copied or after <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> characters
    are copied, whichever comes first. If copying takes place between objects that
    overlap, the behavior is undefined.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> 函数将从 <samp class="SANS_TheSansMonoCd_W5Regular_11">s2</samp>
    指向的对象中复制字符到 <samp class="SANS_TheSansMonoCd_W5Regular_11">s1</samp> 指向的对象中，复制过程在遇到第一个字符
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>（转为 <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp>）时停止，或者在复制了 <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>
    个字符后停止，以先到者为准。如果复制发生在重叠的对象之间，行为是未定义的。
- en: 'From the Variables pane in the debugger, we can see that the <samp class="SANS_TheSansMonoCd_W5Regular_11">part</samp>
    we are adding looks correct:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从调试器中的变量面板来看，我们可以看到我们添加的 <samp class="SANS_TheSansMonoCd_W5Regular_11">part</samp>
    看起来是正确的：
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> alias to the start
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> also has an expected
    value:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> 作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    的别名也有一个预期的值：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>,
    however, seems odd, as it has the same value as an <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    (–1):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存储在 <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> 中的值似乎有些奇怪，因为它的值与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>（–1）相同：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> parameter is
    a character pointer that is assigned the return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>.
    So once again, let’s check the standard to see what this function returns:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> 参数是一个字符指针，它被分配了来自
    <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> 的返回值。所以我们再一次查阅标准，看看这个函数返回了什么：
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function returns
    a pointer to the character after the copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">s1</samp>, or a null pointer
    if <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> was not found in the
    first <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> characters of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">s2</samp>.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>函数返回一个指向<samp class="SANS_TheSansMonoCd_W5Regular_11">s1</samp>中复制的字符后一个字符的指针，或者如果在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">s2</samp>的前<samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp>个字符中未找到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">c</samp>，则返回空指针。
- en: According to the C standard, this function can return only a null pointer or
    a pointer to a character in <samp class="SANS_TheSansMonoCd_W5Regular_11">s1</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>, in this program).
    The storage for <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> begins
    at <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7fffffffdcde</samp> and extends
    for only 10 bytes, so neither of these explain the <samp class="SANS_TheSansMonoCd_W5Regular_11">0xffffffffffffffff</samp>
    value, so the mystery deepens.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 根据C标准，该函数只能返回空指针或指向<samp class="SANS_TheSansMonoCd_W5Regular_11">s1</samp>中的某个字符的指针（在本程序中为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>）。<samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>的存储空间从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x7fffffffdcde</samp>开始，且仅延伸10个字节，因此这些都无法解释<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0xffffffffffffffff</samp>的值，谜团加深了。
- en: It’s time to examine the behavior of the <samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp>
    function more closely. We’ll set a breakpoint on line 12 near the beginning of
    the function and start debugging. The buttons along the left of the title bar
    allow you to continue, step over, step into, step out, restart, and stop debugging.
    Starting from line 12, we can single-step through the program by clicking the
    Step Over button. The <samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp>
    function loops several times, so you’ll have to step through a few iterations
    of the loop, watching the values in the VARIABLES pane. If you do this carefully,
    you’ll eventually see that <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>
    is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">0xffffffffffffffff</samp>
    on line 18 following the call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    function, as shown in [Figure 11-2](chapter11.xhtml#fig11-2). This isn’t detected
    by the null pointer test, and the segmentation fault occurs on the next iteration.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候更仔细地检查<samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp>函数的行为了。我们将在函数开始处的第12行设置一个断点，并开始调试。标题栏左侧的按钮允许你继续、跳过、逐步进入、逐步退出、重新启动和停止调试。从第12行开始，我们可以通过点击“跳过”按钮逐步执行程序。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp>函数会循环执行多次，因此你需要逐步执行几次循环，观察VARIABLES窗格中的值。如果你小心操作，最终会看到在调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>函数后，第18行的<samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>被设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0xffffffffffffffff</samp>，如[图11-2](chapter11.xhtml#fig11-2)所示。这不会被空指针测试检测到，且在下一次迭代时发生了段错误。
- en: It was here that I had my eureka moment. The <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    function returns a null pointer to indicate that <samp class="SANS_TheSansMonoCd_W5Regular_11">'\0'</samp>
    was not found in the first <samp class="SANS_TheSansMonoCd_W5Regular_11">buff_length
    - offset</samp> characters of <samp class="SANS_TheSansMonoCd_W5Regular_11">part</samp>.
    However, we are subtracting 1 from the value returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    so that <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> points to the
    first occurrence of <samp class="SANS_TheSansMonoCd_W5Regular_11">'\0'</samp>
    rather than just after it. This works when the character is found, but when it
    isn’t found, we subtract 1 from a null pointer, which is technically undefined
    behavior in C. On this implementation, the null pointer is represented by a 0
    value. Subtracting 1 from 0 wraps around and produces the <samp class="SANS_TheSansMonoCd_W5Regular_11">0xffffffffffffffff</samp>
    value for <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> before we
    can test it. Consequently, the error condition is not detected, and the subsequent
    call to <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> results in
    the segmentation fault.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 就在这里，我有了灵感时刻。<samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>函数返回一个空指针，表示在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">buff_length - offset</samp>个字符内没有找到<сamp
    class="SANS_TheSansMonoCd_W5Regular_11">'\0'</samp>。然而，我们从<сamp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>返回的值中减去1，这样<сamp
    class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>就指向<сamp class="SANS_TheSansMonoCd_W5Regular_11">'\0'</samp>第一次出现的位置，而不是它之后的位置。当字符被找到时，这种方式是可行的，但如果没有找到字符，我们就从空指针减去1，这在C语言中是技术上未定义的行为。在这个实现中，空指针由值0表示。将1从0中减去会导致值环绕并产生<сamp
    class="SANS_TheSansMonoCd_W5Regular_11">0xffffffffffffffff</samp>，然后才会对<сamp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>进行测试。因此，错误条件未被检测到，随后的<сamp
    class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>调用导致了段错误。
- en: '![](../images/f11002.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/f11002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-2: An interesting
    program state</samp>'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-2：一个有趣的程序状态</samp>
- en: Now that we have discovered the root cause, the bug can be repaired by moving
    the minus-one subtraction after the null pointer check, which results in the final
    version of the program shown in [Chapter 7](chapter7.xhtml).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经发现了根本原因，修复bug的方法是将减去1的操作移动到空指针检查之后，这样就得到了在[第7章](chapter7.xhtml)中展示的程序的最终版本。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Unit Testing</samp>
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">单元测试</samp>
- en: Testing increases your confidence that your code is defect free. *Unit tests*
    are small programs that exercise your code. *Unit testing* is a process that validates
    that each unit of the software performs as designed. A *unit* is the smallest
    testable part of any software; in C, this is typically an individual function
    or data abstraction.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以增强你对代码无缺陷的信心。*单元测试*是执行你代码的小程序。*单元测试*是一个验证软件每个单元按设计执行的过程。*单元*是任何软件中最小的可测试部分；在C语言中，通常是一个独立的函数或数据抽象。
- en: 'You can write simple tests that resemble normal application code (see [Listing
    11-7](chapter11.xhtml#Lis11-7), for example), but it can be beneficial to use
    a *unit-testing framework*. Several unit-testing frameworks are available, including
    Google Test, CUnit, CppUnit, Unity, and others. We’ll examine the most popular
    of these, based on a recent survey of the C development ecosystem by JetBrains
    (*[https://<wbr>www<wbr>.jetbrains<wbr>.com<wbr>/lp<wbr>/devecosystem<wbr>-2023<wbr>/c<wbr>/](https://www.jetbrains.com/lp/devecosystem-2023/c/)*):
    Google Test.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写简单的测试，类似于普通应用程序代码（例如，参见[列表11-7](chapter11.xhtml#Lis11-7)），但使用*单元测试框架*可能更有益。有几种单元测试框架可供选择，包括Google
    Test、CUnit、CppUnit、Unity等。我们将根据JetBrains最近对C开发生态系统的调查（* [https://www.jetbrains.com/lp/devecosystem-2023/c/](https://www.jetbrains.com/lp/devecosystem-2023/c/)*）来研究其中最受欢迎的框架：Google
    Test。
- en: Google Test works for Linux, Windows, and macOS. Tests are written in C++, so
    you get to learn another (related) programming language for testing purposes.
    CUnit and Unity are good alternatives if you want to restrict your testing to
    pure C.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Google Test适用于Linux、Windows和macOS。测试是用C++编写的，因此你可以学习另一种（相关的）编程语言来进行测试。如果你希望将测试限制在纯C语言中，CUnit和Unity是不错的替代选择。
- en: In Google Test, you write assertions to verify the tested code’s behavior. Google
    Test assertions, which are function-like macros, are the real language of the
    tests. If a test crashes or has a failed assertion, it fails; otherwise, it succeeds.
    An assertion’s result can be success, nonfatal failure, or fatal failure. If a
    fatal failure occurs, the current function is aborted; otherwise, the program
    continues normally.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Google Test 中，你编写断言以验证被测试代码的行为。Google Test 的断言是类似函数的宏，它们是测试的实际语言。如果一个测试崩溃或断言失败，它就失败；否则，它就成功。断言的结果可以是成功、非致命失败或致命失败。如果发生致命失败，当前函数将被中止；否则，程序将继续正常运行。
- en: We’ll use Google Test on Ubuntu Linux. To install it, follow the directions
    from the Google Test GitHub page at *[https://<wbr>github<wbr>.com<wbr>/google<wbr>/googletest<wbr>/tree<wbr>/main<wbr>/googletest](https://github.com/google/googletest/tree/main/googletest)*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Ubuntu Linux 上使用 Google Test。要安装它，请按照 Google Test GitHub 页面上的说明进行操作，地址是
    *[https://<wbr>github<wbr>.com<wbr>/google<wbr>/googletest<wbr>/tree<wbr>/main<wbr>/googletest](https://github.com/google/googletest/tree/main/googletest)*。
- en: Once Google Test is installed, we’ll set up a unit test for the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp>
    function shown in [Listing 11-7](chapter11.xhtml#Lis11-7). This function returns
    an error message string corresponding to the error number passed in as an argument.
    You’ll need to include the headers that declare the <samp class="SANS_TheSansMonoCd_W5Regular_11">errno_t</samp>
    type and the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerrorlen_s</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> functions.
    Save it in a file named *error.c* so that the build instructions described later
    in this section will work properly.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Google Test，我们将为 [列表 11-7](chapter11.xhtml#Lis11-7) 中展示的 <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp>
    函数设置单元测试。该函数返回与传递的错误编号相对应的错误消息字符串。你需要包含声明 <samp class="SANS_TheSansMonoCd_W5Regular_11">errno_t</samp>
    类型以及 <samp class="SANS_TheSansMonoCd_W5Regular_11">strerrorlen_s</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> 函数的头文件。将其保存为名为 *error.c*
    的文件，以便后面本节中描述的构建说明能够正常工作。
- en: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">error.c</samp>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">error.c</samp>
- en: '[PRE25]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-7: The</samp> <samp
    class="I">get_error</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 11-7：The</samp> <samp class="I">get_error</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数</samp>
- en: This function calls both the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerrorlen_s</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> functions
    defined in the normative but optional Annex K, “Bounds-checking interfaces” (described
    in [Chapter 7](chapter7.xhtml)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数调用了在规范但可选的附录 K 中定义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">strerrorlen_s</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> 函数，附录 K 介绍了“边界检查接口”（在
    [第 7 章](chapter7.xhtml) 中描述）。
- en: Unfortunately, neither GCC nor Clang implements Annex K, so instead we’ll use
    the Safeclib implementation developed by Reini Urban and available from GitHub
    (*[https://<wbr>github<wbr>.com<wbr>/rurban<wbr>/safeclib](https://github.com/rurban/safeclib)*).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，GCC 和 Clang 都没有实现附录 K，因此我们将使用 Reini Urban 开发的 Safeclib 实现，该实现可以从 GitHub
    上获取 (*[https://<wbr>github<wbr>.com<wbr>/rurban<wbr>/safeclib](https://github.com/rurban/safeclib)*)。
- en: 'You can install <samp class="SANS_TheSansMonoCd_W5Regular_11">libsafec-dev</samp>
    on Ubuntu with the following command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令在 Ubuntu 上安装 <samp class="SANS_TheSansMonoCd_W5Regular_11">libsafec-dev</samp>：
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Listing 11-8](chapter11.xhtml#Lis11-8) contains a unit test suite for the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp> function named
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetErrorTest</samp>. A *test suite*
    is a set of test cases to be executed in a specific test cycle. The <samp class="SANS_TheSansMonoCd_W5Regular_11">GetErrorTest</samp>
    suite consists of two test cases: <samp class="SANS_TheSansMonoCd_W5Regular_11">KnownError</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">UnknownError</samp>. A *test
    case* is a set of preconditions, inputs, actions (where applicable), expected
    results, and postconditions, developed based on test conditions (*[https://<wbr>glossary<wbr>.istqb<wbr>.org](https://glossary.istqb.org)*).
    Save this code in a file named *tests.cc*.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-8](chapter11.xhtml#Lis11-8) 包含了一个名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetErrorTest</samp>
    的 <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp> 函数的单元测试套件。*测试套件*
    是一组将在特定测试周期中执行的测试用例。<samp class="SANS_TheSansMonoCd_W5Regular_11">GetErrorTest</samp>
    套件包含两个测试用例：<samp class="SANS_TheSansMonoCd_W5Regular_11">KnownError</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">UnknownError</samp>。*测试用例* 是一组预置条件、输入、操作（如适用）、预期结果和后置条件，这些都是根据测试条件（*
    [https://<wbr>glossary<wbr>.istqb<wbr>.org](https://glossary.istqb.org) *）开发的。将此代码保存在名为
    *tests.cc* 的文件中。'
- en: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">tests.cc</samp>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">tests.cc</samp>
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-8: Unit tests for
    the</samp> <samp class="I">get_error</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 11-8：get_error</samp> <samp
    class="I">函数</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">的单元测试</samp>
- en: 'Most of the C++ code is boilerplate and can be copied without modification,
    including, for example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function, which invokes the function-like macro <samp class="SANS_TheSansMonoCd_W5Regular_11">RUN_ALL_TESTS</samp>
    to execute your tests. The two parts that aren’t boilerplate are the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern
    "C"</samp> declaration ❶ and the tests ❷. The <samp class="SANS_TheSansMonoCd_W5Regular_11">extern
    "C"</samp> declaration changes the linkage requirements so that the C++ compiler
    linker doesn’t mangle the function name, as it is wont to do. You need to add
    a similar declaration for each function being tested, or you can simply include
    the C header file within an <samp class="SANS_TheSansMonoCd_W5Regular_11">extern
    "C"</samp> block as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分 C++ 代码是模板代码，可以直接复制而无需修改，例如 <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    函数，它调用类似宏的 <samp class="SANS_TheSansMonoCd_W5Regular_11">RUN_ALL_TESTS</samp>
    来执行测试。唯一不属于模板代码的部分是 <samp class="SANS_TheSansMonoCd_W5Regular_11">extern "C"</samp>
    声明 ❶ 和测试 ❷。<samp class="SANS_TheSansMonoCd_W5Regular_11">extern "C"</samp> 声明改变了链接要求，避免
    C++ 编译器链接器对函数名进行“修饰”，因为它通常会这样做。您需要为每个正在测试的函数添加类似声明，或者您可以像下面这样在 <samp class="SANS_TheSansMonoCd_W5Regular_11">extern
    "C"</samp> 块内简单地包含 C 头文件：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: An <samp class="SANS_TheSansMonoCd_W5Regular_11">extern "C"</samp> declaration
    is necessary only when compiling with C but linking with C++.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在使用 C 编译并链接 C++ 时，才需要声明 <samp class="SANS_TheSansMonoCd_W5Regular_11">extern
    "C"</samp>。
- en: Both test cases are specified using the <samp class="SANS_TheSansMonoCd_W5Regular_11">TEST</samp>
    macro, which takes two arguments. The first argument is the name of the test suite,
    and the second argument is the name of the test case.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 两个测试用例是使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">TEST</samp> 宏指定的，该宏接受两个参数。第一个参数是测试套件的名称，第二个参数是测试用例的名称。
- en: Insert Google Test assertions, along with any additional C++ statements you
    wish to include, in the function body. In [Listing 11-8](chapter11.xhtml#Lis11-8),
    we used the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXPECT _STREQ</samp>
    assertion, which verifies that two strings have the same content. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    function returns a locale-specific message string, which can vary between implementations.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内插入 Google Test 断言，以及您希望包含的任何其他 C++ 语句。在 [示例 11-8](chapter11.xhtml#Lis11-8)
    中，我们使用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">EXPECT _STREQ</samp> 断言，它验证两个字符串的内容是否相同。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> 函数返回一个特定于区域设置的消息字符串，这在不同实现之间可能有所不同。
- en: We used the assertion on several error numbers to verify that the function is
    returning the correct string for each error number. The <samp class="SANS_TheSansMonoCd_W5Regular_11">EXPECT_STREQ</samp>
    assertion is a nonfatal assertion because testing can continue even when this
    specific assertion fails. This is typically preferable to fatal assertions, as
    it lets you detect and fix multiple bugs in a single run-edit-compile cycle. If
    it’s not possible to continue testing after an initial failure (because a subsequent
    operation relies on a previous result, for example), you can use the fatal <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ASSERT_STREQ</samp> assertion.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了对多个错误号的断言来验证函数是否为每个错误号返回正确的字符串。<samp class="SANS_TheSansMonoCd_W5Regular_11">EXPECT_STREQ</samp>断言是一个非致命断言，因为即使该特定断言失败，测试仍然可以继续。这通常比致命断言更可取，因为它允许您在单次运行-编辑-编译周期中检测并修复多个错误。如果在初始失败后无法继续测试（例如，后续操作依赖于之前的结果），可以使用致命的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ASSERT_STREQ</samp>断言。
- en: '[Listing 11-9](chapter11.xhtml#Lis11-9) shows a simple *CMakeLists.txt* file
    that can be used to build the tests. This file assumes that the C functions we’re
    testing can be found in the *error.c* file and that the implementations of the
    Annex K functions are provided by the <samp class="SANS_TheSansMonoCd_W5Regular_11">safec</samp>
    library.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-9](chapter11.xhtml#Lis11-9)展示了一个简单的*CMakeLists.txt*文件，可以用于构建测试。这个文件假设我们正在测试的C函数可以在*error.c*文件中找到，并且附录K函数的实现由<samp
    class="SANS_TheSansMonoCd_W5Regular_11">safec</samp>库提供。'
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-9: The</samp> <samp
    class="SANS_Futura_Std_Book_11">CMakeLists.txt</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file</samp>'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-9：The</samp> <samp class="SANS_Futura_Std_Book_11">CMakeLists.txt</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">文件</samp>
- en: If you prefer to install <samp class="SANS_TheSansMonoCd_W5Regular_11">libsafec-dev</samp>
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">apt install</samp> command,
    remove the lines specific to installing <samp class="SANS_TheSansMonoCd_W5Regular_11">libsafec</samp>.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢通过<code class="SANS_TheSansMonoCd_W5Regular_11">apt install</code>命令安装<samp
    class="SANS_TheSansMonoCd_W5Regular_11">libsafec-dev</samp>，请删除特定于安装<samp class="SANS_TheSansMonoCd_W5Regular_11">libsafec</samp>的行。
- en: 'Build and run the tests using the following sequence of commands:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令序列来构建和运行测试：
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The test case tests for several error numbers from <samp class="SANS_TheSansMonoCd_W5Regular_11"><errno.h></samp>.
    How many of these should be tested depends on what you’re trying to accomplish.
    Ideally, the tests should be comprehensive, which would mean adding an assertion
    for every error number in <samp class="SANS_TheSansMonoCd_W5Regular_11"><errno.h></samp>.
    This can become tiresome, however; once you have established that your code is
    working, you’re mostly just testing that the underlying C standard library functions
    you’re using are implemented correctly. Instead, we could test the error numbers
    we’re likely going to retrieve, but doing so can again become tiresome because
    we’d have to identify all the functions called in the program and which error
    codes they may return. We opted to implement a few spot checks for several randomly
    selected error numbers from different locations in the list.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例测试了来自<samp class="SANS_TheSansMonoCd_W5Regular_11"><errno.h></samp>的多个错误号。需要测试多少个错误号取决于你想要达成的目标。理想情况下，测试应该是全面的，这意味着需要为<samp
    class="SANS_TheSansMonoCd_W5Regular_11"><errno.h></samp>中的每个错误号添加断言。然而，这样做可能会很繁琐；一旦你确定代码工作正常，实际上你只是在测试你使用的底层C标准库函数是否正确实现。不过，我们也可以测试我们可能会检索到的错误号，但这样做同样会变得繁琐，因为我们需要识别程序中调用的所有函数及其可能返回的错误码。我们选择实现一些针对从列表中不同位置随机选取的错误号的抽查。
- en: '[Listing 11-10](chapter11.xhtml#Lis11-10) shows the result of running this
    test.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-10](chapter11.xhtml#Lis11-10)展示了运行此测试的结果。'
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-10: An unsuccessful
    test run</samp>'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-10：一次不成功的测试运行</samp>
- en: 'From the test output, you can see that two tests were executed from one test
    suite. The <samp class="SANS_TheSansMonoCd_W5Regular_11">KnownError</samp> test
    case passed, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">UnknownError</samp>
    test case failed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">UnknownError</samp>
    test failed because the following assertion returned false:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试输出可以看出，来自同一测试套件的两个测试已执行。<samp class="SANS_TheSansMonoCd_W5Regular_11">KnownError</samp>
    测试用例通过，而 <samp class="SANS_TheSansMonoCd_W5Regular_11">UnknownError</samp> 测试用例失败。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">UnknownError</samp> 测试失败的原因是以下断言返回了假：
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The test assumed that the error path in the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp>
    function would execute and return the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"unknown
    error"</samp>). Instead, the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    function returned the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"Unknown
    error -1"</samp>. Examining the source code for the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    function (at *[https://<wbr>github<wbr>.com<wbr>/rurban<wbr>/safeclib<wbr>/blob<wbr>/master<wbr>/src<wbr>/str<wbr>/strerror<wbr>_s<wbr>.c](https://github.com/rurban/safeclib/blob/master/src/str/strerror_s.c)*),
    we can see that the function does return error codes. Consequently, it’s clear
    that the function doesn’t treat an unknown error number as an error. Checking
    the C standard, we see that “<samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    shall map any value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    to a message,” so the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    function is implemented correctly, but our assumptions about how it behaved were
    incorrect.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 测试假设在 <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp> 函数中的错误路径会执行并返回字符串
    <samp class="SANS_TheSansMonoCd_W5Regular_11">"unknown error"</samp>)。然而，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> 函数返回了字符串 <samp class="SANS_TheSansMonoCd_W5Regular_11">"Unknown
    error -1"</samp>。通过检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    函数的源代码（位于 *[https://<wbr>github<wbr>.com<wbr>/rurban<wbr>/safeclib<wbr>/blob<wbr>/master<wbr>/src<wbr>/str<wbr>/strerror<wbr>_s<wbr>.c](https://github.com/rurban/safeclib/blob/master/src/str/strerror_s.c)*），我们可以看到该函数确实会返回错误代码。因此，很明显，该函数并没有将未知的错误号视为错误。检查
    C 标准后，我们发现“<samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> 应该将任何类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 的值映射为一条消息，”因此，<samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    函数的实现是正确的，但我们对其行为的假设是错误的。
- en: 'There is a defect in the implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp>
    function in that it indicates “unknown error” when the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    function fails, but according to the standard:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp> 函数的实现存在缺陷，因为当
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> 函数失败时，它会指示“unknown
    error”，但根据标准：
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> function
    returns zero if the length of the desired string was less than <samp class="SANS_TheSansMonoCd_W5Regular_11">maxsize</samp>
    and there was no runtime-constraint violation. Otherwise, the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    function returns a nonzero value.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> 函数会在期望字符串的长度小于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">maxsize</samp> 且没有运行时约束违例的情况下返回零。否则，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> 函数将返回非零值。
- en: Consequently, if the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    function returns a nonzero value, a serious error has occurred that’s bad enough
    to reconsider the design of this function. Instead of returning a string on an
    error condition, it should probably return a null pointer or otherwise handle
    the error in a manner consistent with the overall error handling strategy for
    your system. [Listing 11-11](chapter11.xhtml#Lis11-11) updates the function to
    return a null pointer value.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> 函数返回非零值，表示发生了严重错误，足以需要重新考虑该函数的设计。它不应该在错误条件下返回字符串，而应该返回空指针或以其他方式处理错误，以便与系统的整体错误处理策略一致。[列表
    11-11](chapter11.xhtml#Lis11-11) 更新了该函数，使其返回空指针值。
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-11: The</samp> <samp
    class="I">get_error</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 11-11：The</samp> <samp class="I">get_error</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数</samp>
- en: 'We need to repair the test to check for the correct string returned by <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_error(-1)</samp>:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修复测试，检查<samp class="SANS_TheSansMonoCd_W5Regular_11">get_error(-1)</samp>返回的正确字符串：
- en: '[PRE34]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After making this change, rebuilding, and rerunning the tests, we can see that
    both test cases succeeded as shown in [Listing 11-12](chapter11.xhtml#Lis11-12).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出此更改后，重新构建并重新运行测试，我们可以看到，如[清单 11-12](chapter11.xhtml#Lis11-12)所示，两个测试用例均成功。
- en: '[PRE35]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-12: A successful
    test run</samp>'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-12: 成功的测试运行</samp>'
- en: In addition to discovering a design error, we also discovered that our tests
    are incomplete, as we failed to test the error case. We should add further tests
    to ensure that error cases are handled correctly. Adding these tests is left as
    an exercise for the reader.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 除了发现设计错误，我们还发现我们的测试不完整，因为我们未能测试错误情况。我们应该添加更多的测试，以确保错误情况能够正确处理。添加这些测试留给读者作为练习。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Static Analysis</samp>
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">静态分析</samp>
- en: '*Static analysis* includes any process for assessing code without executing
    it (ISO/IEC TS 17961:2013) to provide information about possible software defects.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态分析*包括任何无需执行代码的评估过程（ISO/IEC TS 17961:2013），用于提供关于可能的软件缺陷的信息。'
- en: Static analysis has practical limitations, as the correctness of software is
    computationally undecidable. For example, the halting theorem of computer science
    states that there are programs whose exact control flow cannot be determined statically.
    As a result, any property dependent on control flow—such as halting—may not be
    decidable for some programs. Consequently, static analysis may fail to report
    flaws or may report flaws where they don’t exist.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析有实际的局限性，因为软件的正确性在计算上是不可判定的。例如，计算机科学中的停机定理指出，存在一些程序，其精确的控制流无法静态确定。因此，任何依赖于控制流的属性——比如停机——对某些程序可能是不可判定的。因此，静态分析可能无法报告缺陷，或者可能会报告不存在的缺陷。
- en: A failure to report a real flaw in the code is known as a *false negative*.
    False negatives are serious analysis errors, as they may leave you with a false
    sense of security. Most tools err on the side of caution and, as a result, generate
    false positives. A *false positive* is a test result that incorrectly indicates
    that a flaw is present. Tools might report some high-risk flaws and miss other
    flaws as an unintended consequence of trying not to overwhelm the user with false
    positives. False positives can also occur when the code is too complex to completely
    analyze. The use of function pointers and libraries can make false positives more
    likely.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 未能报告代码中的实际缺陷称为*假阴性*。假阴性是严重的分析错误，因为它们可能让你产生一种虚假的安全感。大多数工具倾向于谨慎行事，因此会生成假阳性。*假阳性*是指测试结果错误地表明存在缺陷。工具可能会报告一些高风险缺陷，同时忽略其他缺陷，这是为了避免用假阳性信息淹没用户。假阳性也可能出现在代码过于复杂，无法完全分析的情况下。函数指针和库的使用会使假阳性更容易发生。
- en: Ideally, tools are both complete and sound in their analysis. An analyzer is
    considered *sound* if it cannot give a false-negative result. An analyzer is considered
    *complete* if it cannot issue false positives. The possibilities for a given rule
    are outlined in [Figure 11-3](chapter11.xhtml#fig11-3).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，工具的分析既要完备又要可靠。如果分析工具无法给出假阴性结果，则被认为是*可靠*的。如果分析工具无法发出假阳性结果，则被认为是*完备*的。给定规则的可能性在[图
    11-3](chapter11.xhtml#fig11-3)中进行了概述。
- en: '![](../images/f11003.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/f11003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-3: Completeness and
    soundness</samp>'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 11-3: 完备性与可靠性</samp>'
- en: Compilers perform limited analysis, providing diagnostics about highly localized
    issues in code that don’t require much reasoning. For example, when comparing
    a signed value to an unsigned value, the compiler may issue a diagnostic about
    a type mismatch because it doesn’t require additional information to identify
    the error. As mentioned earlier in this chapter, there are numerous compiler flags,
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">/W4</samp> for Visual C++
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp> for GCC and Clang,
    that control compiler diagnostics.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器执行有限的分析，提供关于代码中不需要过多推理的高度局部化问题的诊断信息。例如，当将一个有符号值与一个无符号值进行比较时，编译器可能会发出关于类型不匹配的诊断，因为它不需要额外的信息来识别错误。如本章前面所提到的，有许多编译器标志，例如
    Visual C++ 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">/W4</samp> 和 GCC 及
    Clang 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp>，它们用于控制编译器的诊断信息。
- en: Compilers generally provide high-quality diagnostics, and you shouldn’t ignore
    them. Always try to understand the reason for the warning and rewrite the code
    to eliminate the error, rather than simply quieting warnings by adding type casts
    or making arbitrary changes until the warning goes away. See the CERT C rule MSC00-C,
    “Compile cleanly at high warning levels,” for more information on this topic.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通常提供高质量的诊断信息，您不应该忽视它们。始终尽量理解警告的原因，并重新编写代码以消除错误，而不是通过添加类型转换或随意修改代码直到警告消失来简单地抑制警告。有关此主题的更多信息，请参见CERT
    C规则MSC00-C，“在高警告级别下干净编译”。
- en: Once you’ve addressed compiler warnings in your code, you can use a separate
    static analyzer to identify additional flaws. Static analyzers will diagnose more
    complex defects by evaluating the expressions in your program, performing in-depth
    control and data flow analysis, and reasoning about the possible ranges of values
    and control flow paths taken.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解决了代码中的编译器警告，您可以使用单独的静态分析器来识别其他缺陷。静态分析器通过评估程序中的表达式、执行深入的控制流和数据流分析，以及推理可能的值范围和控制流路径，从而诊断出更复杂的缺陷。
- en: Having a tool locate and identify specific errors in your program is much, much
    easier than hours of testing and debugging, and it’s much less costly than deploying
    defective code. A wide variety of free and commercial static analysis tools are
    available. For example, Visual C++ has incorporated a static analyzer that you
    can invoke with the <samp class="SANS_TheSansMonoCd_W5Regular_11">/analyze</samp>
    flag. Visual C++ analysis allows you to specify which rule sets (such as recommended,
    security, or internationalization) you would like to run or whether to run them
    all. For more information on Visual C++’s static code analysis, see Microsoft’s
    website at *[https://<wbr>learn<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/visualstudio<wbr>/code<wbr>-quality](https://learn.microsoft.com/en-us/visualstudio/code-quality)*.
    Similarly, Clang has incorporated a static analyzer that can be run as a stand-alone
    tool or within Xcode (*[https://<wbr>clang<wbr>-analyzer<wbr>.llvm<wbr>.org](https://clang-analyzer.llvm.org)*).
    Beginning with version 10, GCC has introduced static analysis that’s enabled through
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">-fanalyzer</samp> option. Commercial
    tools also exist, such as CodeQL from GitHub, TrustInSoft Analyzer, SonarQube
    from SonarSource, Coverity from Synopsys, LDRA Testbed, Helix QAC from Perforce,
    and others.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工具定位并识别程序中的特定错误，比进行数小时的测试和调试要容易得多，成本也远低于部署有缺陷的代码。有许多免费的和商业的静态分析工具可供选择。例如，Visual
    C++ 集成了一个静态分析器，您可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">/analyze</samp>
    标志调用。Visual C++ 分析允许您指定要运行的规则集（例如推荐、安全或国际化规则集），或者是否运行所有规则集。有关 Visual C++ 静态代码分析的更多信息，请访问
    Microsoft 的网站 *[https://<wbr>learn<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/visualstudio<wbr>/code<wbr>-quality](https://learn.microsoft.com/en-us/visualstudio/code-quality)*。类似地，Clang
    集成了一个静态分析器，可以作为独立工具或在 Xcode 中运行 (*[https://<wbr>clang<wbr>-analyzer<wbr>.llvm<wbr>.org](https://clang-analyzer.llvm.org)*)。从版本
    10 开始，GCC 引入了通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">-fanalyzer</samp>
    选项启用的静态分析功能。也有商业工具，如 GitHub 的 CodeQL、TrustInSoft Analyzer、SonarSource 的 SonarQube、Synopsys
    的 Coverity、LDRA Testbed、Perforce 的 Helix QAC 等。
- en: Many static analysis tools have nonoverlapping capabilities, so it may make
    sense to use more than one.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 许多静态分析工具具有互不重叠的功能，因此使用多个工具可能是有意义的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Dynamic Analysis</samp>
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">动态分析</samp>
- en: '*Dynamic analysis* is the process of evaluating a system or component during
    execution. It’s also referred to as *runtime analysis*, among other similar names.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态分析*是评估系统或组件在执行过程中表现的过程。它也被称为*运行时分析*，以及其他类似的名称。'
- en: A common approach to dynamic analysis is to *instrument* the code—for example,
    by enabling compile-time flags that inject extra instructions into the executable—and
    then run the instrumented executable. The debug memory allocation library <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> described in [Chapter 6](chapter6.xhtml)
    takes a similar approach. The <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>
    library provides replacement memory management routines with runtime-configurable
    debugging facilities. You can control the behavior of these routines by using
    a command line utility (also called <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>)
    to detect memory leaks and to discover and report defects such as writing outside
    the bounds of an object and using a pointer after it’s been freed.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析的常见方法是*插桩*代码——例如，通过启用编译时标志，将额外的指令注入到可执行文件中——然后运行插桩后的可执行文件。第[6章](chapter6.xhtml)中描述的调试内存分配库
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> 采用了类似的方法。<samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>
    库提供了替代内存管理例程，并带有运行时可配置的调试功能。你可以通过使用命令行工具（也称为 <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>）来控制这些例程的行为，检测内存泄漏，并发现和报告缺陷，例如越界写入或在释放内存后继续使用指针。
- en: The advantage of dynamic analysis is that it has a low false-positive rate,
    so if one of these tools flags a problem, fix it!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析的优点是它具有较低的误报率，因此如果这些工具标记了问题，就应该修复它！
- en: A drawback of dynamic analysis is that it requires sufficient code coverage.
    If a defective code path is not exercised during the testing process, the defect
    won’t be found. Another drawback is that the instrumentation may change other
    aspects of the program in undesirable ways, such as adding performance overhead
    or increasing the binary size. Unlike other dynamic analysis tools, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FORTIFY_SOURCE</samp> macro mentioned
    earlier in this chapter provides lightweight support for detecting buffer overflows
    so that it can be enabled in a production build with no noticeable impacts on
    performance.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析的一个缺点是，它需要足够的代码覆盖率。如果在测试过程中没有执行到有缺陷的代码路径，那么缺陷就不会被发现。另一个缺点是，插桩可能会以不希望的方式改变程序的其他方面，例如增加性能开销或增加二进制文件的大小。与其他动态分析工具不同，本章前面提到的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">FORTIFY_SOURCE</samp> 宏提供了轻量级的缓冲区溢出检测支持，因此可以在生产构建中启用，而不会对性能产生明显影响。
- en: <samp class="SANS_Futura_Std_Bold_B_11">AddressSanitizer</samp>
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">AddressSanitizer</samp>
- en: AddressSanitizer (ASan, *[https://<wbr>github<wbr>.com<wbr>/google<wbr>/sanitizers<wbr>/wiki<wbr>/AddressSanitizer](https://github.com/google/sanitizers/wiki/AddressSanitizer)*)
    is an example of an effective dynamic analysis tool that is available (for free)
    for several compilers. Several related sanitizers exist, including ThreadSanitizer,
    MemorySanitizer, Hardware-Assisted AddressSanitizer, and UndefinedBehaviorSanitizer.
    Many other dynamic analysis tools are available, both commercial and free. For
    more information on sanitizers, see *[https://<wbr>github<wbr>.com<wbr>/google<wbr>/sanitizers](https://github.com/google/sanitizers)*.
    I’ll demonstrate the value of these tools by discussing AddressSanitizer in some
    detail.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: AddressSanitizer (ASan, *[https://<wbr>github<wbr>.com<wbr>/google<wbr>/sanitizers<wbr>/wiki<wbr>/AddressSanitizer](https://github.com/google/sanitizers/wiki/AddressSanitizer)*)
    是一个有效的动态分析工具的示例，可供多个编译器（免费）使用。还有几个相关的清理工具，包括 ThreadSanitizer、MemorySanitizer、硬件加速的
    AddressSanitizer 和 UndefinedBehaviorSanitizer。还有许多其他动态分析工具，包括商业工具和免费工具。如需更多关于清理工具的信息，请参见
    *[https://<wbr>github<wbr>.com<wbr>/google<wbr>/sanitizers](https://github.com/google/sanitizers)*。我将通过详细讨论
    AddressSanitizer 来展示这些工具的价值。
- en: ASan is a dynamic memory error detector for C and C++ programs. It’s incorporated
    into LLVM version 3.1 and GCC version 4.8, as well as later versions of these
    compilers. ASan is also available starting with Visual Studio 2019.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ASan 是一个用于 C 和 C++ 程序的动态内存错误检测器。它被集成进 LLVM 版本 3.1 和 GCC 版本 4.8，以及这些编译器的后续版本中。从
    Visual Studio 2019 开始，ASan 也可以使用。
- en: 'This dynamic analysis tool can find a variety of memory errors, including the
    following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动态分析工具可以发现各种内存错误，包括以下几种：
- en: Use after free (dangling pointer dereference)
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放后使用（悬空指针解引用）
- en: Heap, stack, and global buffer overflow
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆、栈和全局缓冲区溢出
- en: Use after return
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回后使用
- en: Use after scope
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超出作用域使用
- en: Initialization order bugs
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化顺序错误
- en: Memory leaks
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存泄漏
- en: To demonstrate ASan’s usefulness, we’ll start by replacing the <samp class="SANS_TheSansMonoCd_W5Regular_11">get
    _error</samp> function from [Listing 11-7](chapter11.xhtml#Lis11-7) with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp> function shown in [Listing
    11-13](chapter11.xhtml#Lis11-13).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 ASan 的有效性，我们将通过将 [列表 11-7](chapter11.xhtml#Lis11-7) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp>
    函数替换为 [列表 11-13](chapter11.xhtml#Lis11-13) 中显示的 <samp class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp>
    函数来开始。
- en: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">error.c</samp>
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">error.c</samp>
- en: '[PRE36]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-13: The</samp> <samp
    class="I">print_error</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 11-13：The</samp> <samp class="I">print_error</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数</samp>
- en: We’ll also replace the unit test suite for the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp>
    function with the unit test suite for the <samp class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp>
    function shown in [Listing 11-14](chapter11.xhtml#Lis11-14).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将用 [列表 11-14](chapter11.xhtml#Lis11-14) 中显示的 <samp class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp>
    函数的单元测试套件，替换 <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp> 函数的单元测试套件。
- en: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">tests.cc</samp>
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">tests.cc</samp>
- en: '[PRE37]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-14: The</samp> <samp
    class="I">PrintTests</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">test
    suite</samp>'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 11-14：The</samp> <samp class="I">PrintTests</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">测试套件</samp>
- en: This Google Test code defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">PrintTests</samp>
    test suite that contains a single test case, <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroReturn</samp>.
    This test case uses the nonfatal <samp class="SANS_TheSansMonoCd_W5Regular_11">EXPECT_EQ</samp>
    assertion to test for a return value of 0 from several calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp>
    function to print some randomly selected error numbers. Next, we need to build
    and run this code on Ubuntu Linux.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 Google Test 代码定义了一个包含单个测试用例 <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroReturn</samp>
    的 <samp class="SANS_TheSansMonoCd_W5Regular_11">PrintTests</samp> 测试套件。该测试用例使用非致命的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EXPECT_EQ</samp> 断言，测试通过多次调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp> 函数来打印一些随机选择的错误编号，返回值应为
    0。接下来，我们需要在 Ubuntu Linux 上构建并运行此代码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Tests</samp>
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">运行测试</samp>
- en: Running the revised tests from [Listing 11-14](chapter11.xhtml#Lis11-14) produces
    the positive results shown in [Listing 11-15](chapter11.xhtml#Lis11-15).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [列表 11-14](chapter11.xhtml#Lis11-14) 运行修改后的测试，得到的正面结果如 [列表 11-15](chapter11.xhtml#Lis11-15)
    所示。
- en: '[PRE38]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-15: A test run of
    the</samp> <samp class="I">PrintTests</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">test
    suite</samp>'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 11-15：The</samp> <samp class="I">PrintTests</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">测试套件的测试运行</samp>
- en: An inexperienced tester may look at these results and mistakenly think, “Hey,
    this code is working!” However, you should take additional steps to improve your
    confidence that your code is free from defects. Now that we have a working test
    harness in place, it’s time to instrument the code.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经验不足的测试人员可能会看这些结果，并错误地认为，“嘿，这段代码工作正常！”然而，你应该采取额外步骤来提高对代码没有缺陷的信心。现在我们已经有了一个工作的测试框架，是时候对代码进行插桩了。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Instrumenting the
    Code</samp>
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码插桩</samp>
- en: You can instrument your code by using ASan to compile and link your program
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-fsanitize=address</samp>
    flag. [Table 11-3](chapter11.xhtml#tab11-3) shows some compiler flags that are
    commonly used with ASan.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 ASan 将代码插桩，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">-fsanitize=address</samp>
    标志编译和链接程序。[表 11-3](chapter11.xhtml#tab11-3) 显示了一些常用的 ASan 编译器标志。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 11-3:</samp> <samp class="SANS_Futura_Std_Book_11">Compiler
    and Linker Flags Commonly Used with AddressSanitizer</samp>
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 11-3：</samp> <samp class="SANS_Futura_Std_Book_11">与
    AddressSanitizer 常用的编译器和链接器标志</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Flag</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Purpose</samp>
    |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">标志</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">目的</samp>
    |'
- en: '| --- | --- |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fsanitize=address</samp> |
    <samp class="SANS_Futura_Std_Book_11">Enable AddressSanitizer (must be passed
    to both the compiler and the linker)</samp> |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fsanitize=address</samp> |
    <samp class="SANS_Futura_Std_Book_11">启用 AddressSanitizer（必须传递给编译器和链接器）</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-g3</samp> | <samp class="SANS_Futura_Std_Book_11">Get
    symbolic debugging information</samp> |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-g3</samp> | <samp class="SANS_Futura_Std_Book_11">获取符号调试信息</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fno-omit-frame-pointer</samp>
    | <samp class="SANS_Futura_Std_Book_11">Leave frame pointers to get more informative
    stack traces in error messages</samp> |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fno-omit-frame-pointer</samp>
    | <samp class="SANS_Futura_Std_Book_11">保留帧指针，以便在错误信息中获取更有信息量的堆栈跟踪</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fsanitize-blacklist=path</samp>
    | <samp class="SANS_Futura_Std_Book_11">Pass a blacklist file</samp> |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fsanitize-blacklist=path</samp>
    | <samp class="SANS_Futura_Std_Book_11">传递一个黑名单文件</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fno-common</samp> | <samp
    class="SANS_Futura_Std_Book_11">Do not treat global variables as common variables
    (allows ASan to instrument them)</samp> |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fno-common</samp> | <samp
    class="SANS_Futura_Std_Book_11">不将全局变量视为公共变量（允许 ASan 对它们进行插桩）</samp> |'
- en: 'Select the compiler and linker flags you want to use from [Table 11-3](chapter11.xhtml#tab11-3)
    and add them to your *CMakeLists.txt* file using the <samp class="SANS_TheSansMonoCd_W5Regular_11">add_compile_options</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">add_link_options</samp> commands:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 从[表 11-3](chapter11.xhtml#tab11-3)中选择你想使用的编译器和链接器标志，并通过<samp class="SANS_TheSansMonoCd_W5Regular_11">add_compile_options</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">add_link_options</samp>命令将它们添加到你的*CMakeLists.txt*文件中：
- en: '[PRE39]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Do not enable sanitization in the build phase because the inserted runtime instrumentation
    can cause false positives.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在构建阶段启用 sanitization，因为插入的运行时插桩可能会导致假阳性。
- en: As previously mentioned, AddressSanitizer works with Clang, GCC, and Visual
    C++. (See *[https://<wbr>devblogs<wbr>.microsoft<wbr>.com<wbr>/cppblog<wbr>/addresssanitizer<wbr>-asan<wbr>-for<wbr>-windows<wbr>-with<wbr>-msvc](https://devblogs.microsoft.com/cppblog/addresssanitizer-asan-for-windows-with-msvc)*
    for more information on ASan support.)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，AddressSanitizer 可与 Clang、GCC 和 Visual C++ 一起使用。（有关 ASan 支持的更多信息，请参见 *[https://<wbr>devblogs<wbr>.microsoft<wbr>.com<wbr>/cppblog<wbr>/addresssanitizer<wbr>-asan<wbr>-for<wbr>-windows<wbr>-with<wbr>-msvc](https://devblogs.microsoft.com/cppblog/addresssanitizer-asan-for-windows-with-msvc)*。）
- en: 'Depending on which version of which compiler you’re using, you may also need
    to define the following environment variables:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的编译器版本，你可能还需要定义以下环境变量：
- en: '[PRE40]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Try rebuilding and rerunning your tests with these environmental variables set.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在设置了这些环境变量的情况下重新构建并重新运行你的测试。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Instrumented
    Tests</samp>
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">运行插桩测试</samp>
- en: The unit test suite you wrote using Google Test should continue to pass but
    will also exercise your code, allowing AddressSanitizer to detect additional problems.
    You should now see the additional output in [Listing 11-16](chapter11.xhtml#Lis11-16)
    from running <samp class="SANS_TheSansMonoCd_W7Bold_B_11">./build/tests</samp>.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 Google Test 编写的单元测试套件应继续通过测试，但也将执行你的代码，从而允许 AddressSanitizer 检测到额外的问题。你现在应该能在[清单
    11-16](chapter11.xhtml#Lis11-16)中看到来自运行<samp class="SANS_TheSansMonoCd_W7Bold_B_11">./build/tests</samp>的额外输出。
- en: '[PRE41]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-16: An instrumented
    test run of</samp> <samp class="I">PrintTests</samp>'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 11-16：一个插桩测试运行结果，来自</samp>
    <samp class="I">PrintTests</samp>
- en: '[Listing 11-16](chapter11.xhtml#Lis11-16) shows only the first finding of several
    that are produced. Most of this stack trace is redacted because it is from the
    test infrastructure itself and is uninteresting because it doesn’t help locate
    the defects.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-16](chapter11.xhtml#Lis11-16)仅显示了多个结果中的第一个。大部分堆栈跟踪被编辑掉，因为它来自测试基础设施本身，并且没有帮助定位缺陷，因此不感兴趣。'
- en: 'AddressSanitizer’s <samp class="SANS_TheSansMonoCd_W5Regular_11">LeakSanitizer</samp>
    component has “detected memory leaks” and informs us that this is a direct leak
    of 31 bytes from one object. The stack trace identifies the filename and line
    number related to the diagnostic:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: AddressSanitizer 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">LeakSanitizer</samp>
    组件“检测到内存泄漏”，并告诉我们这是一个直接从一个对象中泄漏的 31 字节。堆栈跟踪标识了与诊断相关的文件名和行号：
- en: '[PRE42]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This line of code contains the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp> function:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码包含了对 <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 的调用，它出现在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp> 函数中：
- en: '[PRE43]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is an obvious error; the return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    is assigned to an automatic variable defined within the scope of the <samp class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp>
    function and never freed. We lose the opportunity to free this allocated memory
    after the function returns, and the lifetime of the object holding the pointer
    to the allocated memory ends. To fix this problem, add a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">free(msg)</samp>
    after the allocated storage is no longer required but before the function returns.
    Rerun the tests and repair any additional defects until you’re satisfied with
    the quality of your program.  ## <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '这是一个明显的错误；<samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp> 的返回值被赋值给了一个在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp> 函数作用域内定义的自动变量，并且没有被释放。我们失去了在函数返回后释放这块已分配内存的机会，而持有指向已分配内存的指针的对象的生命周期也结束了。要解决这个问题，应该在不再需要已分配的存储但在函数返回之前，添加对
    <samp class="SANS_TheSansMonoCd_W5Regular_11">free(msg)</samp> 的调用。重新运行测试并修复任何额外的缺陷，直到你对程序的质量感到满意。
    ## <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>'
- en: In this chapter, you learned about static and runtime assertions and were introduced
    to some of the more important and recommended compiler flags for GCC, Clang, and
    Visual C++. You also learned how to debug, test, and analyze your code by using
    both static and dynamic analysis.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了静态和运行时断言，并介绍了一些更重要且推荐的 GCC、Clang 和 Visual C++ 编译器标志。你还学习了如何通过静态和动态分析调试、测试和分析你的代码。
- en: 'These are the important last lessons in this book, because you’ll find you
    spend a considerable amount of time as a professional C programmer debugging and
    analyzing your code. I posted the following on social media a while back, and
    it summarizes my (and other C programmers) relationship with the C programming
    language:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是本书中的重要最后一课，因为你会发现，作为一个专业的 C 程序员，你会花费相当多的时间调试和分析你的代码。我之前在社交媒体上发布过以下内容，它总结了我（以及其他
    C 程序员）与 C 编程语言的关系：
- en: 'Language I dislike: C'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我不喜欢的语言：C
- en: 'Language I begrudgingly respect: C'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我勉强尊重的语言：C
- en: 'Language I think is overrated: C'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我认为被高估的语言：C
- en: 'Language I think is underrated: C'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我认为被低估的语言：C
- en: 'Language I like: C'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我喜欢的语言：C
- en: <samp class="SANS_Futura_Std_Bold_B_11">Future Directions</samp>
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">未来方向</samp>
- en: With C23 complete, the committee can turn its attention to the next revision
    of the C programming language, C2Y. This will likely be published in 2029\. While
    that may seem like a long time, it’s roughly half the time previous C standard
    editions required.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 C23 的完成，委员会可以将注意力转向 C 编程语言的下一个修订版 C2Y。预计将在 2029 年发布。虽然这看起来时间很长，但实际上是之前 C
    标准版本所需时间的大约一半。
- en: The C committee has already approved a new charter to document our principles
    (Seacord et al. 2024). While the committee is dedicated to maintaining the traditional
    spirit of C, there will be a renewed focus on security and safety. For C2Y, we’ll
    likely improve automatic type inference, expand <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    support, and potentially adopt lambdas and other features from C++. We’re also
    working on a novel <samp class="SANS_TheSansMonoCd_W5Regular_11">defer</samp>
    feature for error handling and resource management. The C floating-point group
    will continue its work to update to IEEE 754:2019\. A technical specification
    for a provenance-aware memory object model for C (ISO/IEC CD TS 6010:2024) should
    be published soon and hopefully incorporated into C2Y.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: C委员会已经批准了一份新的章程，用以记录我们的原则（Seacord等，2024）。虽然委员会致力于保持C语言的传统精神，但将会更加关注安全性和可靠性。对于C2Y，我们可能会改进自动类型推断，扩展<samp
    class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>的支持，并有可能采纳来自C++的lambda表达式和其他特性。我们还在开发一种新的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">defer</samp>特性，用于错误处理和资源管理。C浮点数小组将继续更新IEEE
    754:2019标准的相关工作。有关C语言的一个面向溯源的内存对象模型的技术规范（ISO/IEC CD TS 6010:2024）应该很快发布，并希望能被纳入C2Y版本。
