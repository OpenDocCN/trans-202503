- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp> <samp class="SANS_Dogma_OT_Bold_B_11">DEBUGGING,
    TESTING, AND ANALYSIS</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This final chapter describes tools and techniques for producing correct, effective,
    safe, secure, and robust programs, including static (compile-time) and runtime
    assertions, debugging, testing, static analysis, and dynamic analysis. The chapter
    also discusses which compiler flags are recommended for use in different phases
    of the software development process.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter marks a transition point from learning to program in C to professional
    C programming. Programming in C is relatively easy, but mastering C programming
    is a lifetime endeavor. Modern C programming requires a disciplined approach to
    develop and deploy safe, secure, and performant systems.
  prefs: []
  type: TYPE_NORMAL
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">Assertions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: An *assertion* is a function with a Boolean value, known as a *predicate*, which
    expresses a logical proposition about a program. You use an assertion to verify
    that a specific assumption you made during the implementation of your program
    remains valid. C supports static assertions that can be checked at compile time
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> and runtime
    assertions that are checked during program execution using <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> macro is defined
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11"><assert.h></samp> header.
    In C23, <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> is
    a keyword. In C11, <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>
    was provided as a macro in <samp class="SANS_TheSansMonoCd_W5Regular_11"><assert.h></samp>.
    Prior to that, C did not have static assertions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Static Assertions</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Static assertions* can be expressed using the <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>
    keyword as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Since C23, <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>
    also accepts a single-argument form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If the value of the integer constant expression is not equal to 0, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> declaration has no
    effect. If the integer constant expression is equal to 0, the compiler will produce
    a diagnostic message with the text of the string literal, if present.
  prefs: []
  type: TYPE_NORMAL
- en: You can use static assertions to validate assumptions at compile time, such
    as specific implementation-defined behaviors. Any change in implementation-defined
    behavior will then be diagnosed at compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at three examples of using static assertions. First, in [Listing
    11-1](chapter11.xhtml#Lis11-1), we use <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>
    to verify that <samp class="SANS_TheSansMonoCd_W5Regular_11">struct packed</samp>
    has no padding bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-1: Asserting the
    absence of padding bytes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The predicate for the static assertion in this example tests that the size of
    the packed structure is the same as the combined size of its <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">char *</samp> members. For example,
    on x86-32, both <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">char *</samp> are 4 bytes, and the structure
    is not padded, but on x86-64, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    is 4 bytes, <samp class="SANS_TheSansMonoCd_W5Regular_11">char *</samp> is 8 bytes,
    and the compiler adds 4 padding bytes between the two fields.
  prefs: []
  type: TYPE_NORMAL
- en: A good use of static assertions is to document all your assumptions concerning
    implementation-defined behavior. This will prevent the code from compiling when
    porting to another implementation where those assumptions are invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Because a static assertion is a declaration, it can appear at file scope, immediately
    following the definition of the <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    whose property it asserts.
  prefs: []
  type: TYPE_NORMAL
- en: For the second example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">clear_stdin</samp>
    function, shown in [Listing 11-2](chapter11.xhtml#Lis11-2), calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>
    function to read characters from <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp>
    until the end of the file is reached.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-2: Using</samp>
    <samp class="I">static_assert</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    verify integer sizes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Each character is obtained as an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> converted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    It’s common practice to compare the character returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">getchar</samp>
    function with <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>, often
    in a <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> loop, to
    determine when all the available characters have been read. For this function
    loop to work correctly, the terminating condition must be able to differentiate
    between a character and <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>.
    However, the C standard allows for <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned
    char</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to have
    the same range, meaning that on some implementations, this test for <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    could return false positives, in which case the <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp>
    loop may terminate early. Because this is an unusual condition, you can use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp> to validate that
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> loop can properly
    distinguish between valid characters and <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the static assertion verifies that <samp class="SANS_TheSansMonoCd_W5Regular_11">sizeof(unsigned
    char) < sizeof(int)</samp>. The static assertion is placed near the code that
    depends on this assumption being true so that you can easily locate the code that
    will need to be repaired if the assumption is violated. Because static assertions
    are evaluated at compile time, placing them within executable code has no impact
    on the runtime efficiency of the program. See the CERT C rule FIO34-C, “Distinguish
    between characters read from a file and <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">WEOF</samp>,” for more information
    on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in [Listing 11-3](chapter11.xhtml#Lis11-3), we use <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>
    to perform compile-time bounds checking.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-3: Using</samp>
    <samp class="I">static_assert</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    perform bounds checking</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This code snippet uses <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>
    to copy a constant string <samp class="SANS_TheSansMonoCd_W5Regular_11">prefix</samp>
    to a statically allocated array <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>.
    The static assertion ensures that <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp>
    has sufficient space to store at least one additional character for an error code
    following the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'This assumption may become invalid if a developer, for example, reduced <samp
    class="SANS_TheSansMonoCd_W5Regular_11">size</samp> or changed the prefix string
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">"Error Number: "</samp> during
    maintenance. Having added the static assertion, the maintainer would now be warned
    about the problem.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the string literal is a message for the developer or maintainer
    and not an end user of the system. It’s intended to provide information useful
    for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Runtime Assertions</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> macro injects
    runtime diagnostic tests into programs. It’s defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11"><assert.h></samp>
    header file and takes a scalar expression as a single argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> macro is implementation
    defined. If the scalar expression is equal to 0, the macro expansion typically
    writes information about the failing call (including the argument text, the name
    of the source file <samp class="SANS_TheSansMonoCd_W5Regular_11">__FILE__</samp>,
    the source line number <samp class="SANS_TheSansMonoCd_W5Regular_11">__LINE__</samp>,
    and the name of the enclosing function <samp class="SANS_TheSansMonoCd_W5Regular_11">__func__</samp>)
    to the standard error stream <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>.
    After writing this information to <samp class="SANS_TheSansMonoCd_W5Regular_11">stderr</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> macro calls the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">abort</samp> function.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">dup_string</samp> function
    shown in [Listing 11-4](chapter11.xhtml#Lis11-4) uses runtime assertions to check
    that the <samp class="SANS_TheSansMonoCd_W5Regular_11">size</samp> argument is
    less than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">LIMIT</samp>
    and that <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> is not a null
    pointer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-4: Using</samp>
    <samp class="I">assert</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to
    verify program conditions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The messages from these assertions might take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The implicit assumption is that the caller validates arguments before calling
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dup_string</samp> so that the function
    is never called with invalid arguments. The runtime assertions are then used to
    validate this assumption during the development and test phases.
  prefs: []
  type: TYPE_NORMAL
- en: The assertion’s predicate expression is often reported in a failed assertion
    message, which allows you to use <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>
    on a string literal with the assertion predicate to generate additional debugging
    information when an assertion fails. Doing so is always safe because string literals
    in C can never have a null pointer value. For example, we can rewrite the assertions
    in [Listing 11-4](chapter11.xhtml#Lis11-4) to have the same functionality but
    provide additional context when the assertion fails, as shown in [Listing 11-5](chapter11.xhtml#Lis11-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-5: Using</samp>
    <samp class="I">assert</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">with
    additional contextual information</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should disable assertions before code is deployed by defining the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NDEBUG</samp> macro (typically as a flag
    passed to the compiler). If <samp class="SANS_TheSansMonoCd_W5Regular_11">NDEBUG</samp>
    is defined as a macro name at the point in the source file where <samp class="SANS_TheSansMonoCd_W5Regular_11"><assert.h></samp>
    is included, the <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> macro
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The reason the macro does not expand empty is because if it did, then code such
    as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: would compile in release mode but not in debug mode. The reason it expands to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">((void) 0)</samp> rather than just
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> is to prevent warnings
    about statements with no effect. The <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>
    macro is redefined according to the current state of <samp class="SANS_TheSansMonoCd_W5Regular_11">NDEBUG</samp>
    each time that <samp class="SANS_TheSansMonoCd_W5Regular_11"><assert.h></samp>
    is included.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use static assertions to check assumptions that can be checked at compile time,
    and use runtime assertions to detect invalid assumptions during testing. Because
    runtime assertions are typically disabled before deployment, avoid using them
    to check for conditions that can come up during normal operations, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Invalid input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors opening, reading, or writing streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out-of-memory conditions from dynamic allocation functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System call errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invalid permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should instead implement these checks as normal error-checking code that’s
    always included in the executable. Assertions should be used only to validate
    preconditions, postconditions, and invariants designed into the code (programming
    errors).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Compiler Settings and Flags</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compilers typically don’t enable optimization or security hardening by default.
    Instead, you can enable optimization, error detection, and security hardening
    using build flags (Weimer 2018). I recommend specific flags for GCC, Clang, and
    Visual C++ in the next section, after first describing how and why you might want
    to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Select your build flags based on what you’re trying to accomplish. Distinct
    phases of software development call for different compiler and linker configurations.
    Some flags, such as the warnings, will be common to all phases. Other flags, such
    as the debug or the optimization level, are specific to each phase.
  prefs: []
  type: TYPE_NORMAL
- en: '**Build** The goal of the build phase is to take full advantage of compiler
    analysis to eliminate defects before debugging. Dealing with numerous diagnostics
    at this stage can seem bothersome but is much better than having to find these
    problems through debugging and testing, or not finding them until after the code
    has shipped. During the build phase, you should use compiler options that maximize
    diagnostics to help you eliminate as many defects as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Debug** During debugging, you’re typically trying to determine why your code
    isn’t working. To best accomplish this, use a set of compiler flags that includes
    debug information, allows assertions to be useful, and enables a quick turnaround
    time for the inevitable edit-compile-debug cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test** You may want to retain debug information and leave assertions enabled
    during testing to assist in identifying the root cause of any problems that are
    discovered. Runtime instrumentation can be injected to help detect errors.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Profile-Guided Optimization** This configuration defines compiler and linker
    flags that control how the compiler adds runtime instrumentation to the code it
    normally generates. One purpose of instrumentation is to collect profiling statistics,
    which can be used to find program hot spots for profile-guided optimizations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Release** The final phase is to build the code for deployment to its operational
    environment. Before deploying the system, make sure you thoroughly test your release
    configuration, because using a different set of compilation flags can trigger
    new defects, for example, from latent undefined behaviors or timing effects caused
    by optimization.'
  prefs: []
  type: TYPE_NORMAL
- en: I’ll now cover some specific compiler and linker flags you might want to use
    for your compiler and software development phase.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GCC and Clang Flags</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Table 11-1](chapter11.xhtml#tab11-1) lists recommended compiler and linker
    options (aka *flags*) for both GCC and Clang. You can find documentation for compiler
    and linker options in the GCC manual (*[https://<wbr>gcc<wbr>.gnu<wbr>.org<wbr>/onlinedocs<wbr>/gcc<wbr>/Invoking<wbr>-GCC<wbr>.html](https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html)*)
    and the Clang Compiler User’s Manual (*[https://<wbr>clang<wbr>.llvm<wbr>.org<wbr>/docs<wbr>/UsersManual<wbr>.html#command<wbr>-line<wbr>-options](https://clang.llvm.org/docs/UsersManual.html#command-line-options)*).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 11-1:</samp> <samp class="SANS_Futura_Std_Book_11">Recommended
    Compiler and Linker Flags for GCC and Clang</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Flag</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Purpose</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE=2</samp>
    | <samp class="SANS_Futura_Std_Book_11">Detect buffer overflows</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fpie -Wl,-pie</samp> | <samp
    class="SANS_Futura_Std_Book_11">Required for address space layout randomization</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fpic -shared</samp> | <samp
    class="SANS_Futura_Std_Book_11">Disable text relocations for shared libraries</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-g3</samp> | <samp class="SANS_Futura_Std_Book_11">Generate
    abundant debugging information</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-O2</samp> | <samp class="SANS_Futura_Std_Book_11">Optimize
    your code for speed/space efficiency</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp> | <samp class="SANS_Futura_Std_Book_11">Turn
    on recommended compiler warnings</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp> | <samp class="SANS_Futura_Std_Book_11">Turn
    on even more recommended compiler warnings</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-Werror</samp> | <samp class="SANS_Futura_Std_Book_11">Turn
    warnings into errors</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=c23</samp> | <samp class="SANS_Futura_Std_Book_11">Specify
    the language standard</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-pedantic</samp> | <samp class="SANS_Futura_Std_Book_11">Issue
    warnings demanded by strict conformance to the standard</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wconversion</samp> | <samp
    class="SANS_Futura_Std_Book_11">Warn for implicit conversions that may alter a
    value</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wl,-z,noexecstack</samp> |
    <samp class="SANS_Futura_Std_Book_11">Mark the stack segments as nonexecutable</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fstack-protector-strong</samp>
    | <samp class="SANS_Futura_Std_Book_11">Add stack protection to functions</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-O</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The uppercase letter <samp class="SANS_TheSansMonoCd_W5Regular_11">-O</samp>
    flag controls *compiler optimization*. Most optimizations are completely disabled
    at optimization level 0 (<samp class="SANS_TheSansMonoCd_W5Regular_11">-O0</samp>).
    This is the default when no optimization level has been set by a command line
    option. Similarly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Og</samp>
    flag suppresses optimization passes that may hinder the debugging experience.
  prefs: []
  type: TYPE_NORMAL
- en: Many diagnostics are issued by GCC only at higher optimization levels, such
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">-02</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">-Os</samp>.
    To ensure that issues are identified during development, use the same (higher)
    optimization level you plan to adopt in production during the compilation and
    analysis phase. Clang, on the other hand, does not require the optimizer to issue
    diagnostics. As a result, Clang can be run with optimizations disabled during
    the compilation/analysis and debug phases.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Os</samp> compiler option
    optimizes for size, enabling all <samp class="SANS_TheSansMonoCd_W5Regular_11">-O2</samp>
    optimizations except those that often increase code size. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Oz</samp>
    compiler option optimizes aggressively for size rather than speed, which may increase
    the number of instructions executed if those instructions require fewer bytes
    to encode. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Oz</samp> option
    behaves similarly to <samp class="SANS_TheSansMonoCd_W5Regular_11">-Os</samp>,
    and it may be used in Clang but only in conjunction with <samp class="SANS_TheSansMonoCd_W5Regular_11">-mno-outline</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Oz</samp> compiler option may
    be used in GCC versions 12.1 or greater.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-glevel</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-g</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">level</samp>
    flag produces debugging information in the operating system’s native format. You
    can specify how much information to produce by setting the debug <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">level</samp>.
    The default level is <samp class="SANS_TheSansMonoCd_W5Regular_11">-g2</samp>.
    Level 3 (<samp class="SANS_TheSansMonoCd_W5Regular_11">-g3</samp>) includes extra
    information, such as all the macro definitions present in the program. Level 3
    also allows you to expand macros in debuggers that support the capability.
  prefs: []
  type: TYPE_NORMAL
- en: Different settings are appropriate for debugging. Optimization levels should
    be low or disabled so that the machine instructions correspond closely to the
    source code. Symbols should also be included to assist in debugging. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-O0 -g3</samp> compiler flags are a good
    default, although other options are acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Og</samp> compiler option
    affects only the optimization level without enabling debug symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling with <samp class="SANS_TheSansMonoCd_W5Regular_11">-Og -g</samp>
    provides some symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling with <samp class="SANS_TheSansMonoCd_W5Regular_11">-Og -g3</samp>
    adds more symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-g3</samp> option causes debugging
    information to be generated in the operating system’s native format, but the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-ggdb3</samp> option tells GCC to use
    the most expressive format available for use by the GNU Project debugger (GDB).
    As a result, if you are only debugging with GDB, <samp class="SANS_TheSansMonoCd_W5Regular_11">-Og
    -ggdb3</samp> is also a good choice of options.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-O0 -g3</samp> options are
    recommended for the standard edit-compile-debug cycle.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-Wall and -Wextra</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Compilers typically enable by default only the most conservatively correct
    diagnostic messages. Additional diagnostics can be enabled to check source code
    more aggressively for issues. Use the following flags to enable additional diagnostic
    messages when compiling code with GCC and Clang: <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp>
    compiler flags enable predefined sets of compile-time warnings. The warnings in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp> set are generally
    easy to avoid or eliminate by modifying the diagnosed code. The warnings in the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp> set either are situational
    or indicate problematic constructs that are harder to avoid and, in some cases,
    may be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite their names, the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp> options do not
    enable all possible warning diagnostics; they enable only a predefined subset.
    For a complete list of specific warnings enabled by the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wextra</samp> compiler flags,
    on GCC run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can consult the documentation for GCC warning options and
    Clang diagnostic flags.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-Wconversion</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Data type conversions can alter data values in unexpected ways. Memory safety
    violations may result from adding or subtracting these values from a pointer.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wconversion</samp> compiler
    option warns about:'
  prefs: []
  type: TYPE_NORMAL
- en: Implicit conversions that may alter a value, including conversions between floating-point
    and integer values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conversions between signed and unsigned integers, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Conversions to smaller types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warnings about conversions between signed and unsigned integers can be disabled
    by using <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wno-sign-conversion</samp>,
    but they’re often useful in finding certain classes of defects and security vulnerabilities.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wconversion</samp> command
    line option should remain enabled.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-Werror</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Werror</samp> flag turns
    all warnings into errors, requiring you to address them before you can begin debugging.
    This flag simply encourages good programming discipline.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-std=</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=</samp> flag can be used
    to specify the language standard as <samp class="SANS_TheSansMonoCd_W5Regular_11">c89</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c90</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">c99</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c11</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">c17</samp>,
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">c23</samp> (you may need to specify
    <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=c2x</samp> when using an older
    compiler). If no C language dialect options are given, the default for GCC 13
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=gnu17</samp>, which provides
    extensions to the C language that, on rare occasions, conflict with the C standard.
    For portability, specify the standard you’re using. For access to new language
    features, specify a recent standard. A good choice if you are reading this second
    edition of *Effective C* is <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=c23</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-pedantic</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-pedantic</samp> flag issues
    warnings when code deviates from strict conformance to the standard. This flag
    is typically used in conjunction with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-std=</samp>
    flag to improve the code’s portability.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-D_FORTIFY_SOURCE=2</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The _<samp class="SANS_TheSansMonoCd_W5Regular_11">FORTIFY_SOURCE</samp> macro
    provides lightweight support for detecting buffer overflows in functions that
    perform operations on memory and strings. This macro can’t detect all types of
    buffer overflows, but compiling your source with <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE=2</samp>
    provides an extra level of validation for functions that copy memory and are a
    potential source of buffer overflows such as <samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">strcpy</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">strcat</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sprintf</samp>.
    Some of the checks can be performed at compile time and result in diagnostics;
    others occur at runtime and can result in a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">_FORTIFY_SOURCE</samp> macro
    requires optimizations to be enabled. Consequently, it must be disabled for unoptimized
    debug builds.
  prefs: []
  type: TYPE_NORMAL
- en: To overwrite a predefined <samp class="SANS_TheSansMonoCd_W5Regular_11">_FORTIFY_SOURCE</samp>
    value, turn it off with <samp class="SANS_TheSansMonoCd_W5Regular_11">-U_FORTIFY
    _SOURCE</samp> and on again with <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE=2</samp>.
    This will eliminate the warning that macros are being redefined.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">_FORTIFY_SOURCE=3</samp> macro
    has improved compiler checks for buffer overflows since version 12 of GCC and
    version 2.34 of the GNU C Library (glibc). The <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE={1,2,3}</samp>
    macro for glibc relies heavily on GCC-specific implementation details. Clang implements
    its own style of fortified function calls.
  prefs: []
  type: TYPE_NORMAL
- en: Specify either <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE=2</samp>
    (recommended) or <samp class="SANS_TheSansMonoCd_W5Regular_11">-D_FORTIFY_SOURCE=1</samp>
    for analysis, testing, and production builds using Clang and GCC versions prior
    to 12.0 and <samp class="SANS_TheSansMonoCd_W5Regular_11">_FORTIFY_SOURCE=3</samp>
    for GCC version 12.0 and later.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-fpie -Wl, -pie, and -fpic
    -shared</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Address space layout randomization (ASLR)* is a security mechanism that randomizes
    the process’s memory space to prevent attackers from predicting the location of
    the code they’re trying to execute. You can learn more about ASLR and other security
    mitigations in *Secure Coding in C and C++* (Seacord 2013).'
  prefs: []
  type: TYPE_NORMAL
- en: You must specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">-fpie -Wl,</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-pie</samp> flags to create
    position-independent executable programs and make it possible to enable ASLR for
    your main program (executable). However, while code emitted for your main program
    with these options is position independent, it does use some relocations that
    cannot be used in shared libraries (dynamic shared objects). For those, use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-fpic</samp> and link with <samp class="SANS_TheSansMonoCd_W5Regular_11">-shared</samp>
    to avoid text relocations on architectures that support position-dependent shared
    libraries. Dynamic shared objects are always position independent and therefore
    support ASLR.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-Wl,-z,noexecstack</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Several operating systems, including OpenBSD, Windows, Linux, and macOS, enforce
    reduced privileges in the kernel to prevent any part of the process address space
    from being both writable and executable. This policy is called W^X.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wl,-z,noexecstack</samp>
    linker option tells the linker to mark the stack segments as nonexecutable, which
    enables the operating system (OS) to configure memory access rights when the program
    executable is loaded into memory.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">-fstack-protector-strong</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">-fstack-protector-strong</samp>
    option protects applications from the most common forms of stack buffer overflow
    exploits by adding a stack canary. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-fstack-protector</samp>
    option is often viewed as insufficient and the <samp class="SANS_TheSansMonoCd_W5Regular_11">-fstack-protector-all</samp>
    option as excessive. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-fstack-protector-strong</samp>
    option was introduced as a compromise between these two extremes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Visual C++ Options</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Visual C++ provides a wide assortment of compiler options, many of which are
    similar to the options available for GCC and Clang. One obvious difference is
    that Visual C++ generally uses the forward slash (<samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>)
    character instead of a hyphen (<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>)
    to indicate a flag. [Table 11-2](chapter11.xhtml#tab11-2) lists recommended compiler
    and linker flags for Visual C++. (For more information on Visual C++ options,
    see *[https://<wbr>docs<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/cpp<wbr>/build<wbr>/reference<wbr>/compiler<wbr>-options<wbr>-listed<wbr>-by<wbr>-category](https://docs.microsoft.com/en-us/cpp/build/reference/compiler-options-listed-by-category)*.)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 11-2:</samp> <samp class="SANS_Futura_Std_Book_11">Recommended
    Compiler Flags for Visual C++</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Flag</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Purpose</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/guard:cf</samp> | <samp class="SANS_Futura_Std_Book_11">Add
    control flow guard security checks</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/analyze</samp> | <samp class="SANS_Futura_Std_Book_11">Enable
    static analysis</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/sdl</samp> | <samp class="SANS_Futura_Std_Book_11">Enable
    security features</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/permissive-</samp> | <samp
    class="SANS_Futura_Std_Book_11">Specify standards conformance mode to the compiler</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/O2</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    optimization to level 2</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/W4</samp> | <samp class="SANS_Futura_Std_Book_11">Set
    compiler warnings to level 4</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/WX</samp> | <samp class="SANS_Futura_Std_Book_11">Turn
    warnings into errors</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/std:clatest</samp> | <samp
    class="SANS_Futura_Std_Book_11">Select the latest/greatest language version</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: Several of these options are similar to options provided by the GCC and Clang
    compilers. The <samp class="SANS_TheSansMonoCd_W5Regular_11">/O2</samp> optimization
    level is appropriate for deployed code, while <samp class="SANS_TheSansMonoCd_W5Regular_11">/Od</samp>
    disables optimization to speed compilation and simplify debugging. The <samp class="SANS_TheSansMonoCd_W5Regular_11">/W4</samp>
    warning level is appropriate for new code, as it’s roughly equivalent to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp> in GCC and Clang. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">/Wall</samp> option in Visual C++ isn’t
    recommended because it produces a high number of false positives. The <samp class="SANS_TheSansMonoCd_W5Regular_11">/WX</samp>
    option turns warnings into errors and is equivalent to the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Werror</samp>
    flag in GCC and Clang. I cover the remaining flags in further detail in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">/guard:cf</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you specify the *control flow guard (CFG)* option, the compiler and linker
    insert extra runtime security checks to detect attempts to compromise your code.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">/guard:cf</samp> option must
    be passed to both the compiler and the linker.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">/analyze</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">/analyze</samp> flag enables
    static analysis, which provides information about possible defects in your code.
    I discuss static analysis in more detail in “Static Analysis” on [page 251](#pg_251).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">/sdl</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">/sdl</samp> flag enables additional
    security features, including treating extra security-relevant warnings as errors
    and additional secure code-generation features. It also enables other security
    features from the Microsoft *Security Development Lifecycle (SDL)*. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">/sdl</samp> flag should be used in all
    production builds where security is a concern.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">/permissive-</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can use <samp class="SANS_TheSansMonoCd_W5Regular_11">/permissive-</samp>
    to help identify and fix conformance issues in your code, thereby improving your
    code’s correctness and portability. This option disables permissive behaviors
    and sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">/Zc</samp> compiler
    options for strict conformance. In the integrated development environment (IDE),
    this option also underlines nonconforming code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">/std:clatest</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">/std:clatest</samp> option
    enables all currently implemented compiler and standard library features proposed
    for C23\. There is no <samp class="SANS_TheSansMonoCd_W5Regular_11">/std:c23</samp>
    at the time of writing, but once one becomes available, you can use it to build
    C23 code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Debugging</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ve been programming professionally for 42 years. Once or maybe twice during
    that time, I’ve written a program that compiled and ran correctly on the first
    try. For all the other times, there is debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s debug a faulty program. The program shown in [Listing 11-6](chapter11.xhtml#Lis11-6)
    is an early version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp>
    function. We reviewed a finished version of this program in [Chapter 7](chapter7.xhtml),
    but this version is not yet ready to deploy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-6: Printing an error</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this program as shown, it outputs my name as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we also want to ensure that this program, which uses a fixed-size
    array for <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>, properly
    handles the case where the full name is larger than the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    array. To test this, we can change the size of the array to a too-small value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run the program, we learn we have a problem but not much more
    than that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Instead of adding print statements, we’ll take the plunge and debug this program
    using Visual Studio Code on Linux. Just running this program in the debugger,
    as shown in [Figure 11-1](chapter11.xhtml#fig11-1), provides us with some information
    that we didn’t previously have.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f11001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-1: Debugging a program
    in Visual Studio Code</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can see from the CALL STACK pane that we are crashing in the <samp class="SANS_TheSansMonoCd_W5Regular_11">__memmove_avx_unaligned_erms</samp>
    function in libc.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can also see that the segmentation fault is occurring on the line with the
    call to <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>. There isn’t
    much else going on in this line, so it’s reasonable to surmise that this function
    is a <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> helper function.
    It’s seldom the case that the bug is in the implementation of the library function,
    so we’ll assume for now that we’re passing an invalid set of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before looking at the arguments, let’s review the description of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function from the C23 standard:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">#include <string.h></samp>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">void *memccpy(void * restrict
    s1, const void * restrict s2, int c, size_t n);</samp>
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function copies
    characters from the object pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">s2</samp>
    into the object pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">s1</samp>,
    stopping after the first occurrence of character <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    (converted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>)
    is copied or after <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> characters
    are copied, whichever comes first. If copying takes place between objects that
    overlap, the behavior is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Variables pane in the debugger, we can see that the <samp class="SANS_TheSansMonoCd_W5Regular_11">part</samp>
    we are adding looks correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> alias to the start
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> also has an expected
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>,
    however, seems odd, as it has the same value as an <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    (–1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> parameter is
    a character pointer that is assigned the return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>.
    So once again, let’s check the standard to see what this function returns:'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> function returns
    a pointer to the character after the copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">s1</samp>, or a null pointer
    if <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> was not found in the
    first <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> characters of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">s2</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: According to the C standard, this function can return only a null pointer or
    a pointer to a character in <samp class="SANS_TheSansMonoCd_W5Regular_11">s1</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>, in this program).
    The storage for <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> begins
    at <samp class="SANS_TheSansMonoCd_W5Regular_11">0x7fffffffdcde</samp> and extends
    for only 10 bytes, so neither of these explain the <samp class="SANS_TheSansMonoCd_W5Regular_11">0xffffffffffffffff</samp>
    value, so the mystery deepens.
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to examine the behavior of the <samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp>
    function more closely. We’ll set a breakpoint on line 12 near the beginning of
    the function and start debugging. The buttons along the left of the title bar
    allow you to continue, step over, step into, step out, restart, and stop debugging.
    Starting from line 12, we can single-step through the program by clicking the
    Step Over button. The <samp class="SANS_TheSansMonoCd_W5Regular_11">vstrcat</samp>
    function loops several times, so you’ll have to step through a few iterations
    of the loop, watching the values in the VARIABLES pane. If you do this carefully,
    you’ll eventually see that <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp>
    is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">0xffffffffffffffff</samp>
    on line 18 following the call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    function, as shown in [Figure 11-2](chapter11.xhtml#fig11-2). This isn’t detected
    by the null pointer test, and the segmentation fault occurs on the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: It was here that I had my eureka moment. The <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    function returns a null pointer to indicate that <samp class="SANS_TheSansMonoCd_W5Regular_11">'\0'</samp>
    was not found in the first <samp class="SANS_TheSansMonoCd_W5Regular_11">buff_length
    - offset</samp> characters of <samp class="SANS_TheSansMonoCd_W5Regular_11">part</samp>.
    However, we are subtracting 1 from the value returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp>
    so that <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> points to the
    first occurrence of <samp class="SANS_TheSansMonoCd_W5Regular_11">'\0'</samp>
    rather than just after it. This works when the character is found, but when it
    isn’t found, we subtract 1 from a null pointer, which is technically undefined
    behavior in C. On this implementation, the null pointer is represented by a 0
    value. Subtracting 1 from 0 wraps around and produces the <samp class="SANS_TheSansMonoCd_W5Regular_11">0xffffffffffffffff</samp>
    value for <samp class="SANS_TheSansMonoCd_W5Regular_11">buff</samp> before we
    can test it. Consequently, the error condition is not detected, and the subsequent
    call to <samp class="SANS_TheSansMonoCd_W5Regular_11">memccpy</samp> results in
    the segmentation fault.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f11002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-2: An interesting
    program state</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discovered the root cause, the bug can be repaired by moving
    the minus-one subtraction after the null pointer check, which results in the final
    version of the program shown in [Chapter 7](chapter7.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Unit Testing</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing increases your confidence that your code is defect free. *Unit tests*
    are small programs that exercise your code. *Unit testing* is a process that validates
    that each unit of the software performs as designed. A *unit* is the smallest
    testable part of any software; in C, this is typically an individual function
    or data abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can write simple tests that resemble normal application code (see [Listing
    11-7](chapter11.xhtml#Lis11-7), for example), but it can be beneficial to use
    a *unit-testing framework*. Several unit-testing frameworks are available, including
    Google Test, CUnit, CppUnit, Unity, and others. We’ll examine the most popular
    of these, based on a recent survey of the C development ecosystem by JetBrains
    (*[https://<wbr>www<wbr>.jetbrains<wbr>.com<wbr>/lp<wbr>/devecosystem<wbr>-2023<wbr>/c<wbr>/](https://www.jetbrains.com/lp/devecosystem-2023/c/)*):
    Google Test.'
  prefs: []
  type: TYPE_NORMAL
- en: Google Test works for Linux, Windows, and macOS. Tests are written in C++, so
    you get to learn another (related) programming language for testing purposes.
    CUnit and Unity are good alternatives if you want to restrict your testing to
    pure C.
  prefs: []
  type: TYPE_NORMAL
- en: In Google Test, you write assertions to verify the tested code’s behavior. Google
    Test assertions, which are function-like macros, are the real language of the
    tests. If a test crashes or has a failed assertion, it fails; otherwise, it succeeds.
    An assertion’s result can be success, nonfatal failure, or fatal failure. If a
    fatal failure occurs, the current function is aborted; otherwise, the program
    continues normally.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use Google Test on Ubuntu Linux. To install it, follow the directions
    from the Google Test GitHub page at *[https://<wbr>github<wbr>.com<wbr>/google<wbr>/googletest<wbr>/tree<wbr>/main<wbr>/googletest](https://github.com/google/googletest/tree/main/googletest)*.
  prefs: []
  type: TYPE_NORMAL
- en: Once Google Test is installed, we’ll set up a unit test for the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp>
    function shown in [Listing 11-7](chapter11.xhtml#Lis11-7). This function returns
    an error message string corresponding to the error number passed in as an argument.
    You’ll need to include the headers that declare the <samp class="SANS_TheSansMonoCd_W5Regular_11">errno_t</samp>
    type and the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerrorlen_s</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> functions.
    Save it in a file named *error.c* so that the build instructions described later
    in this section will work properly.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">error.c</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-7: The</samp> <samp
    class="I">get_error</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This function calls both the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerrorlen_s</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> functions
    defined in the normative but optional Annex K, “Bounds-checking interfaces” (described
    in [Chapter 7](chapter7.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, neither GCC nor Clang implements Annex K, so instead we’ll use
    the Safeclib implementation developed by Reini Urban and available from GitHub
    (*[https://<wbr>github<wbr>.com<wbr>/rurban<wbr>/safeclib](https://github.com/rurban/safeclib)*).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install <samp class="SANS_TheSansMonoCd_W5Regular_11">libsafec-dev</samp>
    on Ubuntu with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 11-8](chapter11.xhtml#Lis11-8) contains a unit test suite for the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp> function named
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetErrorTest</samp>. A *test suite*
    is a set of test cases to be executed in a specific test cycle. The <samp class="SANS_TheSansMonoCd_W5Regular_11">GetErrorTest</samp>
    suite consists of two test cases: <samp class="SANS_TheSansMonoCd_W5Regular_11">KnownError</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">UnknownError</samp>. A *test
    case* is a set of preconditions, inputs, actions (where applicable), expected
    results, and postconditions, developed based on test conditions (*[https://<wbr>glossary<wbr>.istqb<wbr>.org](https://glossary.istqb.org)*).
    Save this code in a file named *tests.cc*.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">tests.cc</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-8: Unit tests for
    the</samp> <samp class="I">get_error</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the C++ code is boilerplate and can be copied without modification,
    including, for example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function, which invokes the function-like macro <samp class="SANS_TheSansMonoCd_W5Regular_11">RUN_ALL_TESTS</samp>
    to execute your tests. The two parts that aren’t boilerplate are the <samp class="SANS_TheSansMonoCd_W5Regular_11">extern
    "C"</samp> declaration ❶ and the tests ❷. The <samp class="SANS_TheSansMonoCd_W5Regular_11">extern
    "C"</samp> declaration changes the linkage requirements so that the C++ compiler
    linker doesn’t mangle the function name, as it is wont to do. You need to add
    a similar declaration for each function being tested, or you can simply include
    the C header file within an <samp class="SANS_TheSansMonoCd_W5Regular_11">extern
    "C"</samp> block as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: An <samp class="SANS_TheSansMonoCd_W5Regular_11">extern "C"</samp> declaration
    is necessary only when compiling with C but linking with C++.
  prefs: []
  type: TYPE_NORMAL
- en: Both test cases are specified using the <samp class="SANS_TheSansMonoCd_W5Regular_11">TEST</samp>
    macro, which takes two arguments. The first argument is the name of the test suite,
    and the second argument is the name of the test case.
  prefs: []
  type: TYPE_NORMAL
- en: Insert Google Test assertions, along with any additional C++ statements you
    wish to include, in the function body. In [Listing 11-8](chapter11.xhtml#Lis11-8),
    we used the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXPECT _STREQ</samp>
    assertion, which verifies that two strings have the same content. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    function returns a locale-specific message string, which can vary between implementations.
  prefs: []
  type: TYPE_NORMAL
- en: We used the assertion on several error numbers to verify that the function is
    returning the correct string for each error number. The <samp class="SANS_TheSansMonoCd_W5Regular_11">EXPECT_STREQ</samp>
    assertion is a nonfatal assertion because testing can continue even when this
    specific assertion fails. This is typically preferable to fatal assertions, as
    it lets you detect and fix multiple bugs in a single run-edit-compile cycle. If
    it’s not possible to continue testing after an initial failure (because a subsequent
    operation relies on a previous result, for example), you can use the fatal <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ASSERT_STREQ</samp> assertion.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-9](chapter11.xhtml#Lis11-9) shows a simple *CMakeLists.txt* file
    that can be used to build the tests. This file assumes that the C functions we’re
    testing can be found in the *error.c* file and that the implementations of the
    Annex K functions are provided by the <samp class="SANS_TheSansMonoCd_W5Regular_11">safec</samp>
    library.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-9: The</samp> <samp
    class="SANS_Futura_Std_Book_11">CMakeLists.txt</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer to install <samp class="SANS_TheSansMonoCd_W5Regular_11">libsafec-dev</samp>
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">apt install</samp> command,
    remove the lines specific to installing <samp class="SANS_TheSansMonoCd_W5Regular_11">libsafec</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run the tests using the following sequence of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The test case tests for several error numbers from <samp class="SANS_TheSansMonoCd_W5Regular_11"><errno.h></samp>.
    How many of these should be tested depends on what you’re trying to accomplish.
    Ideally, the tests should be comprehensive, which would mean adding an assertion
    for every error number in <samp class="SANS_TheSansMonoCd_W5Regular_11"><errno.h></samp>.
    This can become tiresome, however; once you have established that your code is
    working, you’re mostly just testing that the underlying C standard library functions
    you’re using are implemented correctly. Instead, we could test the error numbers
    we’re likely going to retrieve, but doing so can again become tiresome because
    we’d have to identify all the functions called in the program and which error
    codes they may return. We opted to implement a few spot checks for several randomly
    selected error numbers from different locations in the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-10](chapter11.xhtml#Lis11-10) shows the result of running this
    test.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-10: An unsuccessful
    test run</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the test output, you can see that two tests were executed from one test
    suite. The <samp class="SANS_TheSansMonoCd_W5Regular_11">KnownError</samp> test
    case passed, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">UnknownError</samp>
    test case failed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">UnknownError</samp>
    test failed because the following assertion returned false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The test assumed that the error path in the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp>
    function would execute and return the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"unknown
    error"</samp>). Instead, the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    function returned the string <samp class="SANS_TheSansMonoCd_W5Regular_11">"Unknown
    error -1"</samp>. Examining the source code for the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    function (at *[https://<wbr>github<wbr>.com<wbr>/rurban<wbr>/safeclib<wbr>/blob<wbr>/master<wbr>/src<wbr>/str<wbr>/strerror<wbr>_s<wbr>.c](https://github.com/rurban/safeclib/blob/master/src/str/strerror_s.c)*),
    we can see that the function does return error codes. Consequently, it’s clear
    that the function doesn’t treat an unknown error number as an error. Checking
    the C standard, we see that “<samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    shall map any value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    to a message,” so the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    function is implemented correctly, but our assumptions about how it behaved were
    incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a defect in the implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp>
    function in that it indicates “unknown error” when the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    function fails, but according to the standard:'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp> function
    returns zero if the length of the desired string was less than <samp class="SANS_TheSansMonoCd_W5Regular_11">maxsize</samp>
    and there was no runtime-constraint violation. Otherwise, the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    function returns a nonzero value.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, if the <samp class="SANS_TheSansMonoCd_W5Regular_11">strerror_s</samp>
    function returns a nonzero value, a serious error has occurred that’s bad enough
    to reconsider the design of this function. Instead of returning a string on an
    error condition, it should probably return a null pointer or otherwise handle
    the error in a manner consistent with the overall error handling strategy for
    your system. [Listing 11-11](chapter11.xhtml#Lis11-11) updates the function to
    return a null pointer value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-11: The</samp> <samp
    class="I">get_error</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to repair the test to check for the correct string returned by <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_error(-1)</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: After making this change, rebuilding, and rerunning the tests, we can see that
    both test cases succeeded as shown in [Listing 11-12](chapter11.xhtml#Lis11-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-12: A successful
    test run</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to discovering a design error, we also discovered that our tests
    are incomplete, as we failed to test the error case. We should add further tests
    to ensure that error cases are handled correctly. Adding these tests is left as
    an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Static Analysis</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Static analysis* includes any process for assessing code without executing
    it (ISO/IEC TS 17961:2013) to provide information about possible software defects.'
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis has practical limitations, as the correctness of software is
    computationally undecidable. For example, the halting theorem of computer science
    states that there are programs whose exact control flow cannot be determined statically.
    As a result, any property dependent on control flow—such as halting—may not be
    decidable for some programs. Consequently, static analysis may fail to report
    flaws or may report flaws where they don’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: A failure to report a real flaw in the code is known as a *false negative*.
    False negatives are serious analysis errors, as they may leave you with a false
    sense of security. Most tools err on the side of caution and, as a result, generate
    false positives. A *false positive* is a test result that incorrectly indicates
    that a flaw is present. Tools might report some high-risk flaws and miss other
    flaws as an unintended consequence of trying not to overwhelm the user with false
    positives. False positives can also occur when the code is too complex to completely
    analyze. The use of function pointers and libraries can make false positives more
    likely.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, tools are both complete and sound in their analysis. An analyzer is
    considered *sound* if it cannot give a false-negative result. An analyzer is considered
    *complete* if it cannot issue false positives. The possibilities for a given rule
    are outlined in [Figure 11-3](chapter11.xhtml#fig11-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f11003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-3: Completeness and
    soundness</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Compilers perform limited analysis, providing diagnostics about highly localized
    issues in code that don’t require much reasoning. For example, when comparing
    a signed value to an unsigned value, the compiler may issue a diagnostic about
    a type mismatch because it doesn’t require additional information to identify
    the error. As mentioned earlier in this chapter, there are numerous compiler flags,
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">/W4</samp> for Visual C++
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wall</samp> for GCC and Clang,
    that control compiler diagnostics.
  prefs: []
  type: TYPE_NORMAL
- en: Compilers generally provide high-quality diagnostics, and you shouldn’t ignore
    them. Always try to understand the reason for the warning and rewrite the code
    to eliminate the error, rather than simply quieting warnings by adding type casts
    or making arbitrary changes until the warning goes away. See the CERT C rule MSC00-C,
    “Compile cleanly at high warning levels,” for more information on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve addressed compiler warnings in your code, you can use a separate
    static analyzer to identify additional flaws. Static analyzers will diagnose more
    complex defects by evaluating the expressions in your program, performing in-depth
    control and data flow analysis, and reasoning about the possible ranges of values
    and control flow paths taken.
  prefs: []
  type: TYPE_NORMAL
- en: Having a tool locate and identify specific errors in your program is much, much
    easier than hours of testing and debugging, and it’s much less costly than deploying
    defective code. A wide variety of free and commercial static analysis tools are
    available. For example, Visual C++ has incorporated a static analyzer that you
    can invoke with the <samp class="SANS_TheSansMonoCd_W5Regular_11">/analyze</samp>
    flag. Visual C++ analysis allows you to specify which rule sets (such as recommended,
    security, or internationalization) you would like to run or whether to run them
    all. For more information on Visual C++’s static code analysis, see Microsoft’s
    website at *[https://<wbr>learn<wbr>.microsoft<wbr>.com<wbr>/en<wbr>-us<wbr>/visualstudio<wbr>/code<wbr>-quality](https://learn.microsoft.com/en-us/visualstudio/code-quality)*.
    Similarly, Clang has incorporated a static analyzer that can be run as a stand-alone
    tool or within Xcode (*[https://<wbr>clang<wbr>-analyzer<wbr>.llvm<wbr>.org](https://clang-analyzer.llvm.org)*).
    Beginning with version 10, GCC has introduced static analysis that’s enabled through
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">-fanalyzer</samp> option. Commercial
    tools also exist, such as CodeQL from GitHub, TrustInSoft Analyzer, SonarQube
    from SonarSource, Coverity from Synopsys, LDRA Testbed, Helix QAC from Perforce,
    and others.
  prefs: []
  type: TYPE_NORMAL
- en: Many static analysis tools have nonoverlapping capabilities, so it may make
    sense to use more than one.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Dynamic Analysis</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Dynamic analysis* is the process of evaluating a system or component during
    execution. It’s also referred to as *runtime analysis*, among other similar names.'
  prefs: []
  type: TYPE_NORMAL
- en: A common approach to dynamic analysis is to *instrument* the code—for example,
    by enabling compile-time flags that inject extra instructions into the executable—and
    then run the instrumented executable. The debug memory allocation library <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp> described in [Chapter 6](chapter6.xhtml)
    takes a similar approach. The <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>
    library provides replacement memory management routines with runtime-configurable
    debugging facilities. You can control the behavior of these routines by using
    a command line utility (also called <samp class="SANS_TheSansMonoCd_W5Regular_11">dmalloc</samp>)
    to detect memory leaks and to discover and report defects such as writing outside
    the bounds of an object and using a pointer after it’s been freed.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of dynamic analysis is that it has a low false-positive rate,
    so if one of these tools flags a problem, fix it!
  prefs: []
  type: TYPE_NORMAL
- en: A drawback of dynamic analysis is that it requires sufficient code coverage.
    If a defective code path is not exercised during the testing process, the defect
    won’t be found. Another drawback is that the instrumentation may change other
    aspects of the program in undesirable ways, such as adding performance overhead
    or increasing the binary size. Unlike other dynamic analysis tools, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">FORTIFY_SOURCE</samp> macro mentioned
    earlier in this chapter provides lightweight support for detecting buffer overflows
    so that it can be enabled in a production build with no noticeable impacts on
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">AddressSanitizer</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AddressSanitizer (ASan, *[https://<wbr>github<wbr>.com<wbr>/google<wbr>/sanitizers<wbr>/wiki<wbr>/AddressSanitizer](https://github.com/google/sanitizers/wiki/AddressSanitizer)*)
    is an example of an effective dynamic analysis tool that is available (for free)
    for several compilers. Several related sanitizers exist, including ThreadSanitizer,
    MemorySanitizer, Hardware-Assisted AddressSanitizer, and UndefinedBehaviorSanitizer.
    Many other dynamic analysis tools are available, both commercial and free. For
    more information on sanitizers, see *[https://<wbr>github<wbr>.com<wbr>/google<wbr>/sanitizers](https://github.com/google/sanitizers)*.
    I’ll demonstrate the value of these tools by discussing AddressSanitizer in some
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: ASan is a dynamic memory error detector for C and C++ programs. It’s incorporated
    into LLVM version 3.1 and GCC version 4.8, as well as later versions of these
    compilers. ASan is also available starting with Visual Studio 2019.
  prefs: []
  type: TYPE_NORMAL
- en: 'This dynamic analysis tool can find a variety of memory errors, including the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use after free (dangling pointer dereference)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap, stack, and global buffer overflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use after return
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use after scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialization order bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory leaks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To demonstrate ASan’s usefulness, we’ll start by replacing the <samp class="SANS_TheSansMonoCd_W5Regular_11">get
    _error</samp> function from [Listing 11-7](chapter11.xhtml#Lis11-7) with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp> function shown in [Listing
    11-13](chapter11.xhtml#Lis11-13).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">error.c</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-13: The</samp> <samp
    class="I">print_error</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also replace the unit test suite for the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_error</samp>
    function with the unit test suite for the <samp class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp>
    function shown in [Listing 11-14](chapter11.xhtml#Lis11-14).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">tests.cc</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-14: The</samp> <samp
    class="I">PrintTests</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">test
    suite</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This Google Test code defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">PrintTests</samp>
    test suite that contains a single test case, <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroReturn</samp>.
    This test case uses the nonfatal <samp class="SANS_TheSansMonoCd_W5Regular_11">EXPECT_EQ</samp>
    assertion to test for a return value of 0 from several calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp>
    function to print some randomly selected error numbers. Next, we need to build
    and run this code on Ubuntu Linux.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Tests</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Running the revised tests from [Listing 11-14](chapter11.xhtml#Lis11-14) produces
    the positive results shown in [Listing 11-15](chapter11.xhtml#Lis11-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-15: A test run of
    the</samp> <samp class="I">PrintTests</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">test
    suite</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: An inexperienced tester may look at these results and mistakenly think, “Hey,
    this code is working!” However, you should take additional steps to improve your
    confidence that your code is free from defects. Now that we have a working test
    harness in place, it’s time to instrument the code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Instrumenting the
    Code</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can instrument your code by using ASan to compile and link your program
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-fsanitize=address</samp>
    flag. [Table 11-3](chapter11.xhtml#tab11-3) shows some compiler flags that are
    commonly used with ASan.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 11-3:</samp> <samp class="SANS_Futura_Std_Book_11">Compiler
    and Linker Flags Commonly Used with AddressSanitizer</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Flag</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Purpose</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fsanitize=address</samp> |
    <samp class="SANS_Futura_Std_Book_11">Enable AddressSanitizer (must be passed
    to both the compiler and the linker)</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-g3</samp> | <samp class="SANS_Futura_Std_Book_11">Get
    symbolic debugging information</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fno-omit-frame-pointer</samp>
    | <samp class="SANS_Futura_Std_Book_11">Leave frame pointers to get more informative
    stack traces in error messages</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fsanitize-blacklist=path</samp>
    | <samp class="SANS_Futura_Std_Book_11">Pass a blacklist file</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-fno-common</samp> | <samp
    class="SANS_Futura_Std_Book_11">Do not treat global variables as common variables
    (allows ASan to instrument them)</samp> |'
  prefs: []
  type: TYPE_TB
- en: 'Select the compiler and linker flags you want to use from [Table 11-3](chapter11.xhtml#tab11-3)
    and add them to your *CMakeLists.txt* file using the <samp class="SANS_TheSansMonoCd_W5Regular_11">add_compile_options</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">add_link_options</samp> commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Do not enable sanitization in the build phase because the inserted runtime instrumentation
    can cause false positives.
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, AddressSanitizer works with Clang, GCC, and Visual
    C++. (See *[https://<wbr>devblogs<wbr>.microsoft<wbr>.com<wbr>/cppblog<wbr>/addresssanitizer<wbr>-asan<wbr>-for<wbr>-windows<wbr>-with<wbr>-msvc](https://devblogs.microsoft.com/cppblog/addresssanitizer-asan-for-windows-with-msvc)*
    for more information on ASan support.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on which version of which compiler you’re using, you may also need
    to define the following environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Try rebuilding and rerunning your tests with these environmental variables set.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Instrumented
    Tests</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The unit test suite you wrote using Google Test should continue to pass but
    will also exercise your code, allowing AddressSanitizer to detect additional problems.
    You should now see the additional output in [Listing 11-16](chapter11.xhtml#Lis11-16)
    from running <samp class="SANS_TheSansMonoCd_W7Bold_B_11">./build/tests</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-16: An instrumented
    test run of</samp> <samp class="I">PrintTests</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-16](chapter11.xhtml#Lis11-16) shows only the first finding of several
    that are produced. Most of this stack trace is redacted because it is from the
    test infrastructure itself and is uninteresting because it doesn’t help locate
    the defects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'AddressSanitizer’s <samp class="SANS_TheSansMonoCd_W5Regular_11">LeakSanitizer</samp>
    component has “detected memory leaks” and informs us that this is a direct leak
    of 31 bytes from one object. The stack trace identifies the filename and line
    number related to the diagnostic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This line of code contains the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp> function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an obvious error; the return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">malloc</samp>
    is assigned to an automatic variable defined within the scope of the <samp class="SANS_TheSansMonoCd_W5Regular_11">print_error</samp>
    function and never freed. We lose the opportunity to free this allocated memory
    after the function returns, and the lifetime of the object holding the pointer
    to the allocated memory ends. To fix this problem, add a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">free(msg)</samp>
    after the allocated storage is no longer required but before the function returns.
    Rerun the tests and repair any additional defects until you’re satisfied with
    the quality of your program.  ## <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about static and runtime assertions and were introduced
    to some of the more important and recommended compiler flags for GCC, Clang, and
    Visual C++. You also learned how to debug, test, and analyze your code by using
    both static and dynamic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the important last lessons in this book, because you’ll find you
    spend a considerable amount of time as a professional C programmer debugging and
    analyzing your code. I posted the following on social media a while back, and
    it summarizes my (and other C programmers) relationship with the C programming
    language:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Language I dislike: C'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Language I begrudgingly respect: C'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Language I think is overrated: C'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Language I think is underrated: C'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Language I like: C'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Future Directions</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With C23 complete, the committee can turn its attention to the next revision
    of the C programming language, C2Y. This will likely be published in 2029\. While
    that may seem like a long time, it’s roughly half the time previous C standard
    editions required.
  prefs: []
  type: TYPE_NORMAL
- en: The C committee has already approved a new charter to document our principles
    (Seacord et al. 2024). While the committee is dedicated to maintaining the traditional
    spirit of C, there will be a renewed focus on security and safety. For C2Y, we’ll
    likely improve automatic type inference, expand <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>
    support, and potentially adopt lambdas and other features from C++. We’re also
    working on a novel <samp class="SANS_TheSansMonoCd_W5Regular_11">defer</samp>
    feature for error handling and resource management. The C floating-point group
    will continue its work to update to IEEE 754:2019\. A technical specification
    for a provenance-aware memory object model for C (ISO/IEC CD TS 6010:2024) should
    be published soon and hopefully incorporated into C2Y.
  prefs: []
  type: TYPE_NORMAL
