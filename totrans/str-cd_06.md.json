["```\n> sudo apt-get install gforth\n```", "```\n> gforth\nGforth 0.7.3, Copyright (C) 1995-2008 Free Software Foundation, Inc.\nGforth comes with ABSOLUTELY NO WARRANTY; for details type `license'\nType `bye' to exit\n```", "```\ncr 1 2 + 3 * .\n9  ok\n```", "```\n> gforth\n1 2 3  ok\n. 3  ok . . 2 1  ok\nbye\n```", "```\n1 2 3 .s <3> 1 2 3  ok\ndup .s <4> 1 2 3 3  ok\n2drop .s <2> 1 2  ok\n3 nip .s <2> 1 3  ok\nswap .s <2> 3 1  ok\n2drop .s <0>  ok\n```", "```\n1 1121 / . 0  ok\n1e0 1121e0 f/ f. 0.000892060660124888  ok\n```", "```\n: hi ( -- ) .\" Hello, world!\" cr ;\n```", "```\n: hello ( -- ) 10 0 do  hi  loop ;\n```", "```\n<end> <start> do <body> loop\n```", "```\n: do here @ ' swap , ' >r , ' >r , ; immediate\n: loop ' r> , ' r> , ' swap , ' 1+ , ' 2dup , ' = , ' 0branch , here @ - , ' 2drop , ; immediate\n```", "```\nfor(int i=0; i < 10; i++)\n    printf(\"Hello, world!\\n\");\n```", "```\n: counter ( -- )  10 0 do  i .  loop ;  ok\ncounter 0 1 2 3 4 5 6 7 8 9  ok\n```", "```\n: counter2 ( -- )  20 0 do i . 3 +loop ;  ok\ncounter2 0 3 6 9 12 15 18  ok\n```", "```\n: counter3 ( -- )  100 1 do i dup . +loop ;  ok\ncounter3 1 2 4 8 16 32 64  ok\n```", "```\n: nested0 ( -- ) 3 0 do 3 0 do j . i . space loop loop ;  ok\nnested0 0 0  0 1  0 2  1 0  1 1  1 2  2 0  2 1  2 2   ok\n```", "```\n: nested0 ( -- )\n  3 0 do\n    3 0 do\n      j . i . space\n    loop\n  loop ;\n```", "```\n: nested1 ( -- ) 5 1 do i 0 do j . loop loop ;  ok\nnested1 1 2 2 3 3 3 4 4 4 4  ok\n: nested2 ( -- ) 5 1 do i 0 do i . loop loop ;  ok\nnested2 0 0 1 0 1 2 0 1 2 3  ok\n```", "```\n0\n0 1\n0 1 2\n0 1 2 3\n```", "```\n1 2 < . -1  ok\n-123 321 < . -1  ok\n45 3 > . -1  ok\n3 45 > . 0  ok\n```", "```\n1 2 = . 0  ok\n1 2 <> . -1  ok\n```", "```\n1 2 u< . -1  ok\n-123 321 u< . 0  ok\n```", "```\n<condition> if <true_instructions> then\n<condition> if <true_instructions> else <false_instructions> then\n```", "```\ndef porridge(n):\n    print(\"The porridge is \", end=\"\")\n    if (n < 90):\n       print(\"too cold\")\n    elif (n > 100):\n         print(\"too hot\")\n    else:\n         print(\"just right\")\n```", "```\n: porridge ( n -- )\n  .\" The porridge is \"\n  dup  90 < if  drop .\" too cold\"  else\n      100 < if  .\" just right\"     else\n                .\" too hot\" \n  then then cr ;\n```", "```\n80 porridge The porridge is too cold\n ok\n99 porridge The porridge is just right\n ok\n111 porridge The porridge is too hot\n```", "```\ndup  90 < if  drop .\" too cold\"    else\n```", "```\n: porridge (n -- )\n  .\" The porridge is \"\n  dup 90 < if\n    drop .\" too cold\"\n  else\n    100 < if\n      .\" just right\"\n    else\n      .\" too hot\"\n    then\n  then cr ;\n```", "```\n: menu ( n -- )\n  case\n    0 of .\" option 0\" endof\n    1 of .\" option 1\" endof\n    2 of .\" option 2\" endof\n    .\" bad option\"\n  endcase ;\n0 menu option 0 ok\n1 menu option 1 ok\n2 menu option 2 ok\n5 menu bad option ok\n```", "```\nbegin <condition> while <body> repeat\nbegin <body> <condition> until\nbegin <body> again\n```", "```\n: begin here @ ; immediate\n: again ' branch , here @ - , ; immediate\n```", "```\n: infinity ( -- ) 0 begin  dup . cr 1+  again ;\n```", "```\n: dsqr ( n -- )  0 begin  2dup dup * > while 1+ repeat nip ;\n```", "```\n: guess ( -- ) 0 begin 1+ key 15 and 7 = until . .\" guesses\" ;\n```", "```\nint main(int argc, char *argv[]) {\n    int count = 0;\n\n    do {\n        count++;\n    } while ((key() & 0xF) != 7); \n\n    printf(\"\\n%d guesses\\n\", count);\n    return 0;\n}\n```", "```\nvariable f\nvariable c\n32 constant b\n: c2f c @ 9 * 5 / b + f ! ;  ok\n: f2c f @ b - 5 * 9 / c ! ;  ok\n212 f !  f2c  c @ . 100  ok\n22 c !  c2f  f @ . 71  ok\n32 f !  f2c  c @ . 0  ok\n```", "```\nvariable x  ok\nhex 1122334455667788 x !  ok\nx @ . 1122334455667788  ok\nx c@ . 88  ok\nx 1+ c@ . 77  ok\nx 2 + c@ . 66  ok\nx 3 + c@ . 55  ok\nx 4 + c@ . 44  ok\nx 5 + c@ . 33  ok\nx 6 + c@ . 22  ok\nx 7 + c@ . 11  ok\n```", "```\nlong long x = 0x1122334455667788;\nprintf(\"%llx\", x);\n```", "```\nvariable x hex  ok\n1122334455667788 x !  ok\nx @ . 1122334455667788  ok\nee x c!  ok\nx @ . 11223344556677EE  ok\n```", "```\n1 constant 2  ok\n4 constant 1  ok\n1 1 + . 8  ok\n2 2 * . 1  ok\n```", "```\ncreate buf 1000 allot  ok\n```", "```\n1 buf c!  ok\n2 buf 1+ c!  ok\n3 buf 2 + c!  ok\nbuf c@ . 1  ok\nbuf 1+ c@ . 2  ok\nbuf 2 + c@ . 3  ok\n```", "```\n123456789 buf 3 + !  ok\nbuf 1+ c@ . 2  ok\nbuf 3 + @ . 123456789  ok\n```", "```\n: bArray ( n -- )  create allot does> + ;  ok\n100 bArray x  ok\n123 0 x c!  ok\n124 1 x c!  ok\n125 2 x c!  ok\n1 x c@ . 124  ok\n0 x c@ . 123  ok\n2 x c@ . 125  ok\n```", "```\n: array ( n -- )  create cells allot does> swap cells + ;  ok\n100 array y  ok\n111111 66 y !  ok\n222222 67 y !  ok\n333333 68 y !  ok\n66 y @ . 111111  ok\n68 y @ . 333333  ok\n67 y @ . 222222  ok\n```", "```\ncreate ABCDEF 65 c, 66 c, 67 c, 68 c, 69 c, 70 c,\n```", "```\n: one .\" one\" ;  ok\n: two .\" two\" ;  ok : three .\" three\" ;  ok\ncreate tbl ' one , ' two , ' three ,  ok\ntbl 2 cells + @ execute three ok\ntbl 1 cells + @ execute two ok\ntbl @ execute one ok\n```", "```\nhex -aa dup . cr u. cr decimal -AA \nFFFFFFFFFFFFFF56\n```", "```\ncreate x 10 , 100 , 1000 , 10000 , 100000 ,  ok\n: aligned cr 5 0 do  i cells x + @  6 u.r cr  loop ;  ok\naligned\n    10\n   100\n  1000\n 10000\n100000\n```", "```\n: alpha 26 0 do  [char] A i + emit loop cr ;  ok\nalpha ABCDEFGHIJKLMNOPQRSTUVWXYZ\n```", "```\ncreate str 80 allot  ok\nstr 80 accept (press enter here) How now brown cow?  ok\n. 18  ok\n```", "```\nstr 18 type How now brown cow? ok\n```", "```\npad 80 accept (press enter here) -2211333  ok\npad swap evaluate . -2211333  ok\n```", "```\n: sqrt ( n -- sqrt[n] )\n  0 >r 1 swap begin\n    dup 0 > \n  while \n    over - swap 1+ 1+ swap r> 1+ >r \n  repeat 2drop r> ;\n```", "```\n25 sqrt . 5  ok\n36 sqrt . 6  ok\n42 sqrt . 7  ok\n144 sqrt . 12  ok\n152399025 sqrt . 12345  ok\n```", "```\n( Park and Miller PRNG )\nvariable seed  8675309 seed ! ( default seed )\n: rand ( -- n ) 48271 seed @ * 2147483647 mod  dup seed ! ;\n: random ( m -- n ) rand swap mod ;\n\n( Time to find the square root by method )\nvariable x\nutime drop dup seed ! x ! ( keep seed )\n\n: run0 ( -- ) 100000 0 do  1000 random 1+ dup * sqrt drop  loop ;\n: run1 ( -- ) 100000 0 do  1000 random 1+ dup * dsqr drop  loop ;\n\n: main ( -- )\n  utime  run0  utime 2swap d- d. cr\n  x @ seed !  ( use the same sequence )\n  utime  run1  utime 2swap d- d. cr ;\n\nmain  bye\n```", "```\nSQRT: 0.7457714\nDSQR: 0.4978122\n```", "```\n: step ( n xi -- n xi x_{i+1} )  \n  2dup dup rot swap dup 0= if 2drop else / + then 2/ ;\n: newton ( n -- sqr[n] )\n  dup 2/ step begin 2dup swap < while nip step repeat drop nip ;\n```", "```\nSQRT:   0.7457714\nDSQR:   0.4978122\nNEWTON: 0.0493205\n```", "```\n: }Pixel ( x y z -- n )\n  ( Return value of x,y pixel in image z of current slice )\n  rot matsize @ m* zTmp 2! swap s>d zTmp 2@ d+ 2dup d+ zTmp 2!\n  s>d d>f imgsz 2@ d>f f* f>d  ( z*image_size )\n  zTmp 2@ d+  ( offset into slice )\n  slcoff 2@ d+  ( slice offset )\n  mem 2@ dl@ d+ l@ ;  ( fetch pixel value )\n```"]