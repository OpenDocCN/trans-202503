<html><head></head><body><section class="chapter" title="Chapter&#xA0;7.&#xA0;Custom Visualizations with D3.js" epub:type="chapter" id="custom_visualizations_with_d3dotjs"><div class="titlepage"><div><div><h2 class="title">Chapter 7. Custom Visualizations with D3.js</h2></div></div></div><p><a id="iddle1210" class="indexterm"/>In this book we’ve looked at many JavaScript libraries that were designed for specific types of visualizations. If you need a certain type of visualization for your web page and there’s a library that can create it, using that library is often the quickest and easiest way to create your visualization. There are drawbacks to such libraries, however. They all make assumptions about how the visualization should look and <a id="iddle1188" class="indexterm"/><a id="iddle1211" class="indexterm"/><a id="iddle1469" class="indexterm"/><a id="iddle2069" class="indexterm"/>act, and despite the configuration options they provide, you don’t have complete control over the results. Sometimes that’s not an acceptable trade-off.</p><p>In this chapter, we’ll look at an entirely different approach to JavaScript visualizations, one that allows us to be creative and to retain complete control over the results. As you might expect, that approach isn’t always as easy as, for example, adding a charting library and feeding it data. Fortunately, there is a very powerful JavaScript library that can help: D3.js (<span class="emphasis"><em><a class="ulink" href="http://d3js.org/" target="_top">http://d3js.org/</a></em></span>). D3.js doesn’t provide predefined visualizations such as charts, graphs, or maps. Instead, it’s a toolbox for data visualization, and it gives you the tools to create <span class="emphasis"><em>your own</em></span> charts, graphs, maps, and more.</p><p>To see some of the powerful features of D3.js, we’ll take a whirlwind tour. This chapter’s examples include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Adapting a traditional chart type for particular data</p></li><li class="listitem"><p>Building a force-directed graph that responds to user interactions</p></li><li class="listitem"><p>Displaying map-based data using high-quality SVGs</p></li><li class="listitem"><p>Creating a fully customized visualization</p></li></ul></div><div class="sect1" title="Adapting a Traditional Chart Type"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="adapting_a_traditional_chart_type">Adapting a Traditional Chart Type</h2></div></div></div><p>The most significant difference between D3.js and other JavaScript libraries is its philosophy. D3.js is not a tool for creating predefined types of charts and visualizations. Instead, it’s a library to help you create any visualization, including custom and unique presentations. It takes more effort to create a standard chart with D3.js, but by using it we’re not limited to standard charts. To get a sense of how D3.js works, we can create a custom chart that wouldn’t be possible with a typical charting library.</p><p>For this example, we’ll visualize one of the most important findings in modern physics—Hubble’s law. According to that law, the universe is expanding, and as a result, the speed at which we perceive distant galaxies to be moving varies according to their distance from us. More precisely, Hubble’s law proposes that the variation, or shift, in this speed is a linear function of distance. To visualize the law, we can chart the speed variation (known as <span class="emphasis"><em>red shift velocity</em></span>) versus distance for several galaxies. If Hubble is right, the chart should look like a line. For our data, we’ll use galaxies and clusters from Hubble’s original 1929 paper (<span class="emphasis"><em><a class="ulink" href="http://www.pnas.org/content/15/3/168.full" target="_top">http://www.pnas.org/content/15/3/168.full</a></em></span>) but updated with current values for distance and red shift velocities.</p><p>So far this task seems like a good match for a scatter chart. Distance could serve as the x-axis and velocity the y-axis. There’s a twist, though: physicists don’t actually know the distances or velocities that we want to chart, at least not exactly. The best they can do is estimate those values, and there is potential for error in both. But that’s no reason to abandon the effort. In fact, potential errors in the values might be an important aspect for us to highlight in our visualization. To do <a id="iddle1189" class="indexterm"/><a id="iddle1190" class="indexterm"/><a id="iddle2070" class="indexterm"/>that, we won’t draw each value as a point. Rather, we’ll show it as a box, and the box dimensions will correspond to the potential errors in the value. This approach isn’t common for scatter plots, but D3.js can accommodate it with ease.</p><div class="sect2" title="Step 1: Prepare the Data"><div class="titlepage"><div><div><h3 class="title" id="step_1_prepare_the_data-id00029">Step 1: Prepare the Data</h3></div></div></div><p>Here is the data for our chart according to recent estimates.</p><div class="table"><a id="distance_and_red_shift_velocity_for_nebu"/><div class="table-title">Table 7-1. Distance and Red Shift Velocity for Nebulae and Clusters</div><div class="table-contents"><table style="border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="c1"/><col class="c2"/><col class="c3"/></colgroup><thead><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Nebulae/cluster</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Distance (Mpc)</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>Red shift velocity (km/s)</p></td></tr></thead><tbody><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NGC 6822</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0.500±0.010</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>57±2</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NGC 221</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0.763±0.024</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>200±6</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NGC 598</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>0.835±0.105</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>179±3</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NGC 4736</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>4.900±0.400</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>308±1</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NGC 5457</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>6.400±0.500</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>241±2</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NGC 4258</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7.000±0.500</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>448±3</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NGC 5194</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7.100±1.200</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>463±3</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NGC 4826</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>7.400±0.610</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>408±4</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NGC 3627</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>11.000±1.500</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>727±3</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NGC 7331</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>12.200±1.000</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>816±1</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NGC 4486</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16.400±0.500</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>1307±7</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>NGC 4649</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>16.800±1.200</p></td><td style="vertical-align: top; border-bottom: 0.5pt solid ; "><p>1117±6</p></td></tr><tr><td style="vertical-align: top; border-right: 0.5pt solid ; "><p>NGC 4472</p></td><td style="vertical-align: top; border-right: 0.5pt solid ; "><p>17.100±1.200</p></td><td style="vertical-align: top; "><p>729±2</p></td></tr></tbody></table></div></div><p>We can represent that in JavaScript using the following array.</p><a id="pro_id00351"/><pre class="programlisting">hubble_data = [
    { <span class="dodgerblue">nebulae</span>: <span class="maroon">"NGC 6822"</span>, <span class="dodgerblue">distance</span>:  <span class="red">0.500</span>, <span class="dodgerblue">distance_error</span>: <span class="red">0.010</span>,
      <span class="dodgerblue">velocity</span>:   <span class="red">57</span>, <span class="dodgerblue">velocity_error</span>: <span class="red">2</span>, },
    { <span class="dodgerblue">nebulae</span>: <span class="maroon">"NGC  221"</span>, <span class="dodgerblue">distance</span>:  <span class="red">0.763</span>, <span class="dodgerblue">distance_error</span>: <span class="red">0.024</span>,
      <span class="dodgerblue">velocity</span>:  <span class="red">200</span>, <span class="dodgerblue">velocity_error</span>: <span class="red">6</span>, },
    { <span class="dodgerblue">nebulae</span>: <span class="maroon">"NGC  598"</span>, <span class="dodgerblue">distance</span>:  <span class="red">0.835</span>, <span class="dodgerblue">distance_error</span>: <span class="red">0.105</span>,
      <span class="dodgerblue">velocity</span>:  <span class="red">179</span>, <span class="dodgerblue">velocity_error</span>: <span class="red">3</span>, },
    <span class="indianred"><span class="emphasis"><em>// Data set continues...</em></span></span></pre></div><div class="sect2" title="Step 2: Set Up the Web Page"><div class="titlepage"><div><div><h3 class="title" id="step_2_set_up_the_web_page">Step 2: Set Up the Web Page</h3></div></div></div><p>D3.js doesn’t depend on any other libraries, and it’s available on most CDNs. All we need to do is include it in the page.</p><a id="pro_id00352"/><pre class="programlisting">   <span class="dodgerblue">&lt;!DOCTYPE</span> html<span class="dodgerblue">&gt;</span>
   <span class="steelblue"><span class="strong"><strong>&lt;html</strong></span></span> <span class="steelblue">lang=</span><span class="maroon">"en"</span><span class="steelblue"><span class="strong"><strong>&gt;</strong></span></span>
     <span class="steelblue"><span class="strong"><strong>&lt;head&gt;</strong></span></span>
       <span class="steelblue"><span class="strong"><strong>&lt;meta</strong></span></span> <span class="steelblue">charset=</span><span class="maroon">"utf-8"</span><span class="steelblue"><span class="strong"><strong>&gt;</strong></span></span>
       <span class="steelblue"><span class="strong"><strong>&lt;title&gt;&lt;/title&gt;</strong></span></span>
     <span class="steelblue"><span class="strong"><strong>&lt;/head&gt;</strong></span></span>
     <span class="steelblue"><span class="strong"><strong>&lt;body&gt;</strong></span></span>
➊     <span class="steelblue"><span class="strong"><strong>&lt;div</strong></span></span> <span class="steelblue">id=</span><span class="maroon">"container"</span><span class="steelblue"><span class="strong"><strong>&gt;&lt;/div&gt;</strong></span></span>
➋     <span class="steelblue"><span class="strong"><strong>&lt;script</strong></span></span>
         <span class="steelblue">src="//c</span><span class="maroon">dnjs.cloudflare.com/ajax/libs/d3/3.4.6/d3.min.js"</span><span class="steelblue"><span class="strong"><strong>&gt;</strong></span></span>
       <span class="steelblue"><span class="strong"><strong>&lt;/script&gt;</strong></span></span>
     <span class="steelblue"><span class="strong"><strong>&lt;/body&gt;</strong></span></span>
   <span class="steelblue"><span class="strong"><strong>&lt;/html&gt;</strong></span></span></pre><p><a id="iddle1039" class="indexterm"/><a id="iddle1055" class="indexterm"/><a id="iddle1185" class="indexterm"/><a id="iddle1186" class="indexterm"/><a id="iddle1454" class="indexterm"/><a id="iddle1981" class="indexterm"/><a id="iddle2066" class="indexterm"/><a id="iddle2067" class="indexterm"/><a id="iddle2157" class="indexterm"/>We include D3.js at ➋, and we set up a <code class="literal">&lt;div&gt;</code> with the <code class="literal">id "container"</code> at ➊ to contain our visualization.</p></div><div class="sect2" title="Step 3: Create a Stage for the Visualization"><div class="titlepage"><div><div><h3 class="title" id="step_3_create_a_stage_for_the_visualizat">Step 3: Create a Stage for the Visualization</h3></div></div></div><p>Unlike higher-level libraries, D3.js doesn’t draw the visualization on the page. We’ll have to do that ourselves. In exchange for the additional effort, though, we get the freedom to pick our own drawing technology. We could follow the same approach as most libraries in this book and use HTML5’s <code class="literal">&lt;canvas&gt;</code> element, or we could simply use native HTML. Now that we’ve seen it in action in <a class="xref" href="ch06.html" title="Chapter 6. Visualizing Geographic Data">Chapter 6</a>, however, it seems using SVG is the best approach for our chart. The root of our graph, therefore, will be an <code class="literal">&lt;svg&gt;</code> element, and we need to add that to the page. We can define its dimensions at the same time using attributes.</p><p>If we were using jQuery, we might do something like the following:</p><a id="pro_id00353"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> svg = <span class="olive">$</span>(<span class="maroon">"&lt;svg&gt;"</span>).<span class="olive">attr</span>(<span class="maroon">"height"</span>, height).<span class="olive">attr</span>(<span class="maroon">"width"</span>, width);
<span class="olive">$</span>(<span class="maroon">"#container"</span>).<span class="olive">append</span>(svg);</pre><p>With D3.js our code is very similar:</p><a id="pro_id00354"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> svg = <span class="steelblue">d3</span>.<span class="olive">select</span>(<span class="maroon">"#container"</span>).<span class="olive">append</span>(<span class="maroon">"svg"</span>)
    .<span class="olive">attr</span>(<span class="maroon">"height"</span>, height)
    .<span class="olive">attr</span>(<span class="maroon">"width"</span>, width);</pre><p>With this statement, we’re selecting the container, appending an <code class="literal">&lt;svg&gt;</code> element to it, and setting the attributes of that <code class="literal">&lt;svg&gt;</code> element. This statement highlights one important difference between D3.js and jQuery that often trips up developers starting out with D3.js. In jQuery the <code class="literal">append()</code> method returns the original selection so that you can continue operating on that selection. More specifically, <code class="literal">$("#container").append(svg)</code> returns <code class="literal">$("#container")</code>.</p><p>With D3.js, on the other hand, <code class="literal">append()</code> returns a different selection, the newly appended element(s). So <code class="literal">d3.select("#container").append("svg")</code> doesn’t return the container selection, but rather a selection of the new <code class="literal">&lt;svg&gt;</code> element. The <code class="literal">attr()</code> calls that follow, therefore, apply to the <code class="literal">&lt;svg&gt;</code> element and not the <code class="literal">"#container"</code>.</p></div><div class="sect2" title="Step 4: Control the Chart’s Dimensions"><div class="titlepage"><div><div><h3 class="title" id="step_4_control_the_chartapostrophes_dime">Step 4: Control the Chart’s Dimensions</h3></div></div></div><p><a id="iddle1410" class="indexterm"/><a id="iddle1435" class="indexterm"/><a id="iddle1982" class="indexterm"/>So far we haven’t specified the actual values for the chart’s height and width; we’ve only used <code class="literal">height</code> and <code class="literal">width</code> variables. Having the dimensions in variables will come in handy, and it will make it easy to incorporate margins into the visualization. The following code sets up those dimensions; its form is a common convention in D3.js visualizations.</p><a id="pro_id00355"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> margin = {<span class="dodgerblue">top</span>: <span class="red">20</span>, <span class="dodgerblue">right</span>: <span class="red">20</span>, <span class="dodgerblue">bottom</span>: <span class="red">30</span>, <span class="dodgerblue">left</span>: <span class="red">40</span>},
    width = <span class="red">640</span> - <span class="steelblue">margin</span>.<span class="olive">left</span> - <span class="steelblue">margin</span>.<span class="olive">right</span>,
    height = <span class="red">400</span> - <span class="steelblue">margin</span>.<span class="olive">top</span> - <span class="steelblue">margin</span>.<span class="olive">bottom</span>;</pre><p>We’ll have to adjust the code that creates the main <code class="literal">&lt;svg&gt;</code> container to account for these margins.</p><a id="pro_id00356"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> svg = <span class="steelblue">d3</span>.<span class="olive">select</span>(<span class="maroon">"#chart1"</span>).<span class="olive">append</span>(<span class="maroon">"svg"</span>)
    .<span class="olive">attr</span>(<span class="maroon">"height"</span>, height + <span class="steelblue">margin</span>.<span class="olive">left</span> + <span class="steelblue">margin</span>.<span class="olive">right</span>)
    .<span class="olive">attr</span>(<span class="maroon">"width"</span>, width + <span class="steelblue">margin</span>.<span class="olive">top</span> + <span class="steelblue">margin</span>.<span class="olive">bottom</span>);</pre><p>To make sure our chart honors the defined margins, we’ll construct it entirely within a child SVG group (<code class="literal">&lt;g&gt;</code>) element. The <code class="literal">&lt;g&gt;</code> element is just an arbitrary containing element in SVG, much like the <code class="literal">&lt;div&gt;</code> element for HTML. We can use D3.js to create the element and position it appropriately within the main <code class="literal">&lt;svg&gt;</code> element.</p><a id="pro_id00357"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> chart = <span class="steelblue">svg</span>.<span class="olive">append</span>(<span class="maroon">"g"</span>)
    .<span class="olive">attr</span>(<span class="maroon">"transform"</span>,
        <span class="maroon">"translate("</span> + <span class="steelblue">margin</span>.<span class="olive">left</span> + <span class="maroon">","</span> + <span class="steelblue">margin</span>.<span class="olive">top</span> + <span class="maroon">")"</span>
    );</pre><p>Visualizations must often rescale the source data. In our case, we’ll need to rescale the data to fit within the chart dimensions. Instead of ranging from 0.5 to 17 Mpc, for example, galactic distance should be scaled between 0 and 920 pixels. Since this type of requirement is common for visualizations, D3.js has tools to help. Not surprisingly, they’re <code class="literal">scale</code> objects. We’ll create scales for both the x- and y-dimensions.</p><p>As the following code indicates, both of our scales are linear. Linear transformations are pretty simple (and we really don’t need D3.js to manage them); however, D3.js supports other types of scales that can be quite complex. With D3.js, using more sophisticated scaling is just as easy as using linear scales.</p><a id="pro_id00358"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> xScale = <span class="steelblue">d3</span>.<span class="steelblue">scale</span>.<span class="olive">linear</span>()
    .<span class="olive">range</span>([<span class="red">0</span>,width]);
<span class="steelblue"><span class="strong"><strong>var</strong></span></span> yScale = <span class="steelblue">d3</span>.<span class="steelblue">scale</span>.<span class="olive">linear</span>()
    .<span class="olive">range</span>([height,<span class="red">0</span>]);</pre><p>We define both ranges as the desired limits for each scale. The x-scale ranges from <code class="literal">0</code> to the chart’s width, and the y-scale ranges from <code class="literal">0</code> to the chart’s height. Note, though, that we’ve reversed the normal order for the y-scale. That’s <a id="iddle1187" class="indexterm"/><a id="iddle1212" class="indexterm"/><a id="iddle2068" class="indexterm"/>because SVG dimensions (just like HTML dimensions) place 0 at the top of the area. That convention is the opposite of the normal chart convention, which places 0 at the bottom. To account for the reversal, we swap the values when defining the range.</p><p>At this point, we’ve set the ranges for each scale, and those ranges define the desired output. We also have to specify the possible inputs to each scale, which D3.js calls the <span class="emphasis"><em>domain.</em></span> Those inputs are the minimum and maximum values for the distance and velocity. We can use D3.js to extract the values directly from the data. Here’s how to get the minimum distance:</p><a id="pro_id00359"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> minDist = <span class="steelblue">d3</span>.<span class="olive">min</span>(hubble_data, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(nebulae) {
    <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">nebulae</span>.<span class="olive">distance</span> - <span class="steelblue">nebulae</span>.<span class="olive">distance_error</span>;
});</pre><p>We can’t simply find the minimum value in the data, because we have to account for the distance error. As we can see in the preceding snippet, D3.js accepts a function as a parameter to <code class="literal">d3.min()</code>, and that function can make the necessary adjustment. We can use the same approach for maximum values as well. Here’s the complete code for defining the domains of both scales:</p><a id="pro_id00360"/><pre class="programlisting"><span class="steelblue">xScale</span>.<span class="olive">domain</span>([
        <span class="steelblue">d3</span>.<span class="olive">min</span>(hubble_data, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(nebulae) {
            <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">nebulae</span>.<span class="olive">distance</span> - <span class="steelblue">nebulae</span>.<span class="olive">distance_error</span>;
        }),
        <span class="steelblue">d3</span>.<span class="olive">max</span>(hubble_data, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(nebulae) {
            <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">nebulae</span>.<span class="olive">distance</span> + <span class="steelblue">nebulae</span>.<span class="olive">distance_error</span>;
        })
    ])
    .<span class="olive">nice</span>();
<span class="steelblue">yScale</span>.<span class="olive">domain</span>([
        <span class="steelblue">d3</span>.<span class="olive">min</span>(hubble_data, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(nebulae) {
            <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">nebulae</span>.<span class="olive">velocity</span> - <span class="steelblue">nebulae</span>.<span class="olive">velocity_error</span>;
        }),
        <span class="steelblue">d3</span>.<span class="olive">max</span>(hubble_data, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(nebulae) {
            <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">nebulae</span>.<span class="olive">velocity</span> + <span class="steelblue">nebulae</span>.<span class="olive">velocity_error</span>;
        })
    ])
    .<span class="olive">nice</span>();</pre></div><div class="sect2" title="Step 5: Draw the Chart Framework"><div class="titlepage"><div><div><h3 class="title" id="step_5_draw_the_chart_framework">Step 5: Draw the Chart Framework</h3></div></div></div><p>Axes are another common feature in visualizations, and D3.js has tools for those as well. To create the axes for our chart, we specify the appropriate scales and an orientation. As you can see from the following code, D3.js supports axes as part of its SVG utilities.</p><a id="pro_id00361"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> xAxis = <span class="steelblue">d3</span>.<span class="steelblue">svg</span>.<span class="olive">axis</span>()
    .<span class="olive">scale</span>(xScale)
    .<span class="olive">orient</span>(<span class="maroon">"bottom");</span>
<span class="steelblue"><span class="strong"><strong>var</strong></span></span> yAxis = <span class="steelblue">d3</span>.<span class="steelblue">svg</span>.<span class="olive">axis</span>()
    .<span class="olive">scale</span>(yScale)
    .<span class="olive">orient</span>(<span class="maroon">"left"</span>);</pre><p><a id="iddle1411" class="indexterm"/><a id="iddle1436" class="indexterm"/>After defining the axes, we can use D3.js to add the appropriate SVG elements to the page. We’ll contain each axis within its own <code class="literal">&lt;g&gt;</code> group. For the x-axis, we need to shift that group to the bottom of the chart.</p><a id="pro_id00362"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> xAxisGroup = <span class="steelblue">chart</span>.<span class="olive">append</span>(<span class="maroon">"g"</span>)
    .<span class="olive">attr</span>(<span class="maroon">"transform"</span>, <span class="maroon">"translate(0,"</span> + height + <span class="maroon">")"</span>);</pre><p>To create the SVG elements that make up the axis, we could call the <code class="literal">xAxis</code> object and pass it the containing group as a parameter.</p><a id="pro_id00363"/><pre class="programlisting"><span class="olive">xAxis</span>(xAxisGroup);</pre><p>With D3.js, though, there’s a more concise expression that avoids creating unnecessary local variables and preserves method chaining.</p><a id="pro_id00364"/><pre class="programlisting"><span class="steelblue">chart</span>.<span class="olive">append</span>(<span class="maroon">"g"</span>)
    .<span class="olive">attr</span>(<span class="maroon">"transform"</span>, <span class="maroon">"translate(0,"</span> + height + <span class="maroon">")"</span>)
    .<span class="olive">call</span>(xAxis);</pre><p>And as long as we’re preserving method chaining, we can take advantage of it to add yet another element to our chart: this time, it’s the label for the axis.</p><a id="pro_id00365"/><pre class="programlisting"><span class="steelblue">chart</span>.<span class="olive">append</span>(<span class="maroon">"g"</span>)
    .<span class="olive">attr</span>(<span class="maroon">"transform"</span>, <span class="maroon">"translate(0,"</span> + height + <span class="maroon">")"</span>)
    .<span class="olive">call</span>(xAxis)
  .<span class="olive">append</span>(<span class="maroon">"text"</span>)
    .<span class="olive">attr</span>(<span class="maroon">"x"</span>, width)
    .<span class="olive">attr</span>(<span class="maroon">"y"</span>, -<span class="red">6</span>)
    .<span class="olive">style</span>(<span class="maroon">"text-anchor"</span>, <span class="maroon">"end"</span>)
    .<span class="olive">text</span>(<span class="maroon">"Distance (Mpc)"</span>);</pre><p>If you look under the hood, you’ll find that D3.js has done quite a bit of work for us in creating the axis, its tick marks, and its labels. Here’s a taste of the SVG it builds:</p><a id="pro_id00366"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>&lt;g</strong></span></span> <span class="steelblue">class=</span><span class="maroon">"x axis"</span> <span class="steelblue">transform=</span><span class="maroon">"translate(0,450)"</span><span class="steelblue"><span class="strong"><strong>&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;g</strong></span></span> <span class="steelblue">class=</span><span class="maroon">"tick"</span> <span class="steelblue">transform=</span><span class="maroon">"translate(0,0)"</span> <span class="steelblue">style=</span><span class="maroon">"opacity: 1;"</span><span class="steelblue"><span class="strong"><strong>&gt;</strong></span></span>
        <span class="steelblue"><span class="strong"><strong>&lt;line</strong></span></span> <span class="steelblue">y2=</span><span class="maroon">"6"</span> <span class="steelblue">x2=</span><span class="maroon">"0"</span><span class="steelblue"><span class="strong"><strong>&gt;&lt;/line&gt;</strong></span></span>
        <span class="steelblue"><span class="strong"><strong>&lt;text</strong></span></span> <span class="steelblue">y=</span><span class="maroon">"9"</span> <span class="steelblue">x=</span><span class="maroon">"0"</span> <span class="steelblue">dy=</span><span class="maroon">".71em"</span> <span class="steelblue">style=</span><span class="maroon">"text-anchor: middle;"</span><span class="steelblue"><span class="strong"><strong>&gt;</strong></span></span>0<span class="steelblue"><span class="strong"><strong>&lt;/text&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;/g&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;g</strong></span></span> <span class="steelblue">class=</span><span class="maroon">"tick"</span> <span class="steelblue">transform=</span><span class="maroon">"translate(77.77,0)"</span> <span class="steelblue">style=</span><span class="maroon">"opacity: 1;"</span><span class="steelblue"><span class="strong"><strong>&gt;</strong></span></span>
        <span class="steelblue"><span class="strong"><strong>&lt;line</strong></span></span> <span class="steelblue">y2=</span><span class="maroon">"6"</span> <span class="steelblue">x2=</span><span class="maroon">"0"</span><span class="steelblue"><span class="strong"><strong>&gt;&lt;/line&gt;</strong></span></span>
        <span class="steelblue"><span class="strong"><strong>&lt;text</strong></span></span> <span class="steelblue">y=</span><span class="maroon">"9"</span> <span class="steelblue">x=</span><span class="maroon">"0"</span> <span class="steelblue">dy=</span><span class="maroon">".71em"</span> <span class="steelblue">style=</span><span class="maroon">"text-anchor: middle;"</span><span class="steelblue"><span class="strong"><strong>&gt;</strong></span></span>2<span class="steelblue"><span class="strong"><strong>&lt;/text&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;/g&gt;</strong></span></span>
    <span class="indianred"><span class="emphasis"><em>&lt;!-- Additional tick marks... --&gt;</em></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;path</strong></span></span> <span class="steelblue">class=</span><span class="maroon">"domain"</span> <span class="steelblue">d=</span><span class="maroon">"M0,6V0H700V6"</span><span class="steelblue"><span class="strong"><strong>&gt;&lt;/path&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;text</strong></span></span> <span class="steelblue">x=</span><span class="maroon">"700"</span> <span class="steelblue">y=</span><span class="maroon">"-6"</span> <span class="steelblue">style=</span><span class="maroon">"text-anchor: end;"</span><span class="steelblue"><span class="strong"><strong>&gt;</strong></span></span>Distance (Mpc)<span class="steelblue"><span class="strong"><strong>&lt;/text&gt;</strong></span></span>
<span class="steelblue"><span class="strong"><strong>&lt;/g&gt;</strong></span></span></pre><p>When we add the code for the y-axis, we’ve completed the framework for the chart.</p><a id="pro_id00367"/><pre class="programlisting"><span class="steelblue">chart</span>.<span class="olive">append</span>(<span class="maroon">"g"</span>)
    .<span class="olive">attr</span>(<span class="maroon">"transform"</span>, <span class="maroon">"translate(0,"</span> + height + <span class="maroon">")"</span>)
    .<span class="olive">call</span>(xAxis)
  .<span class="olive">append</span>(<span class="maroon">"text"</span>)
    .<span class="olive">attr</span>(<span class="maroon">"x"</span>, width)
    .<span class="olive">attr</span>(<span class="maroon">"y"</span>, -<span class="red">6</span>)
    .<span class="olive">style</span>(<span class="maroon">"text-anchor"</span>, <span class="maroon">"end"</span>)
    .<span class="olive">text</span>(<span class="maroon">"Distance (Mpc)"</span>);

<span class="steelblue">chart</span>.<span class="olive">append</span>(<span class="maroon">"g"</span>)
    .<span class="olive">call</span>(yAxis)
  .<span class="olive">append</span>(<span class="maroon">"text"</span>)
    .<span class="olive">attr</span>(<span class="maroon">"transform"</span>, <span class="maroon">"rotate(-90)"</span>)
    .<span class="olive">attr</span>(<span class="maroon">"y"</span>, <span class="red">6</span>)
    .<span class="olive">attr</span>(<span class="maroon">"dy"</span>, <span class="maroon">".71em"</span>)
    .<span class="olive">style</span>(<span class="maroon">"text-anchor"</span>, <span class="maroon">"end"</span>)
    .<span class="olive">text</span>(<span class="maroon">"Red Shift Velocity (km/s)"</span>)</pre><p>The result of <a class="xref" href="ch07.html#d3dotjs_provides_tools_to_create_the_fra" title="Figure 7-1. D3.js provides tools to create the framework for a chart.">Figure 7-1</a> isn’t very exciting without any data, but it does give us a framework for the chart.</p><div class="figure"><a id="d3dotjs_provides_tools_to_create_the_fra"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00098"/><img src="figs/web/07fig01.png.jpg" alt="D3.js provides tools to create the framework for a chart."/></div></div><div class="figure-title">Figure 7-1. D3.js provides tools to create the framework for a chart.</div></div><p><a id="iddle1183" class="indexterm"/><a id="iddle1184" class="indexterm"/><a id="iddle1798" class="indexterm"/><a id="iddle2064" class="indexterm"/><a id="iddle2065" class="indexterm"/><a id="iddle2126" class="indexterm"/>As you can tell, we’ve had to write quite a bit of code just to get a couple of axes on the page. That’s the nature of D3.js. It’s not a library to which you can simply pass a data set and get a chart as an output. Instead, think of it as a collection of very useful utilities that you can use to help create your own charts.</p></div><div class="sect2" title="Step 6: Add the Data to the Chart"><div class="titlepage"><div><div><h3 class="title" id="step_6_add_the_data_to_the_chart">Step 6: Add the Data to the Chart</h3></div></div></div><p>Now that our chart’s framework is ready, we can add the actual data. Because we want to show both the distance and velocity errors in the data, we can draw each point as a rectangle. For a simple, static chart, we can add SVG <code class="literal">&lt;rect&gt;</code> elements just as we’ve created the rest of the chart. We can take advantage of our x- and y-scales to calculate the dimensions of the rectangles.</p><a id="pro_id00368"/><pre class="programlisting"><span class="steelblue">hubble_data</span>.<span class="olive">forEach</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(nebulae) {
    <span class="steelblue">chart2</span>.<span class="olive">append</span>(<span class="maroon">"rect"</span>)
      .<span class="olive">attr</span>(<span class="maroon">"x"</span>, <span class="olive">xScale</span>(<span class="steelblue">nebulae</span>.<span class="olive">distance</span> - <span class="steelblue">nebulae</span>.<span class="olive">distance_error</span>))
      .<span class="olive">attr</span>(<span class="maroon">"width"</span>, <span class="olive">xScale</span>(<span class="red">2</span> * <span class="steelblue">nebulae</span>.<span class="olive">distance_error</span>))
      .<span class="olive">attr</span>(<span class="maroon">"y"</span>, <span class="olive">yScale</span>(<span class="steelblue">nebulae</span>.<span class="olive">velocity</span> - <span class="steelblue">nebulae</span>.<span class="olive">velocity_error</span>))
      .<span class="olive">attr</span>(<span class="maroon">"height"</span>, height - <span class="olive">yScale</span>(<span class="red">2</span> * <span class="steelblue">nebulae</span>.<span class="olive">velocity_error</span>));
});</pre><p>The preceding approach works fine for this example and results in the chart in <a class="xref" href="ch07.html#d3dotjs_can_render_the_data_elements_usi" title="Figure 7-2. D3.js can render the data elements using any valid markup, including SVG &lt;rect&gt; elements with defined dimensions.">Figure 7-2</a>. Typically, however, D3.js visualizations combine their data sets directly with markup elements and rely on D3’s <code class="literal">enter</code>, <code class="literal">update</code>, and <code class="literal">exit</code> selections to add the data to the page. We’ll defer further discussion of this alternative approach until the next example.</p><div class="figure"><a id="d3dotjs_can_render_the_data_elements_usi"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00099"/><img src="figs/web/07fig02.png.jpg" alt="D3.js can render the data elements using any valid markup, including SVG &lt;rect&gt; elements with defined dimensions."/></div></div><div class="figure-title">Figure 7-2. D3.js can render the data elements using any valid markup, including SVG <code class="literal">&lt;rect&gt;</code> elements with defined dimensions.</div></div></div><div class="sect2" title="Step 7: Answer Users’ Questions"><div class="titlepage"><div><div><h3 class="title" id="step_7_answer_usersapostrophe_qu-id00030">Step 7: Answer Users’ Questions</h3></div></div></div><p><a id="iddle1196" class="indexterm"/><a id="iddle1396" class="indexterm"/>Whenever you create a visualization, it’s a good idea to anticipate questions that users might ask when they view it. In our example so far, we’ve presented a data set that leads to Hubble’s law. But we haven’t (yet) shown how well the data fits that law. Since that is such an obvious question, let’s answer it right on the chart itself.</p><p>The current estimate for the Hubble constant (H<sub>0</sub>) is about 70 km/s/Mpc. To show how that matches the data on our chart, we can create a line graph with that slope beginning at the point (0,0). A single SVG <code class="literal">&lt;line&gt;</code> is all that’s required. Once again we rely on the D3.js scales to define the line’s coordinates.</p><a id="pro_id00369"/><pre class="programlisting"><span class="steelblue">chart</span>.<span class="olive">append</span>(<span class="maroon">"line"</span>)
    .<span class="olive">attr</span>(<span class="maroon">"x1"</span>,<span class="olive">xScale</span>(<span class="red">0</span>))
    .<span class="olive">attr</span>(<span class="maroon">"y1"</span>,<span class="olive">yScale</span>(<span class="red">0</span>))
    .<span class="olive">attr</span>(<span class="maroon">"x2"</span>,<span class="olive">xScale</span>(<span class="red">20</span>))
    .<span class="olive">attr</span>(<span class="maroon">"y2"</span>,<span class="olive">yScale</span>(<span class="red">1400</span>));</pre><p>In <a class="xref" href="ch07.html#complete_custom_chart_shows_the_data_set" title="Figure 7-3. The complete custom chart shows the data set exactly as we wish.">Figure 7-3</a> we can see that Hubble’s law remains a good approximation.</p><div class="figure"><a id="complete_custom_chart_shows_the_data_set"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00100"/><img src="figs/web/07fig03.png.jpg" alt="The complete custom chart shows the data set exactly as we wish."/></div></div><div class="figure-title">Figure 7-3. The complete custom chart shows the data set exactly as we wish.</div></div></div></div><div class="sect1" title="Creating a Force-Directed Network Graph"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="creating_a_force-directed_network_graph">Creating a Force-Directed Network Graph</h2></div></div></div><p>Unlike the JavaScript plotting libraries we considered in the early chapters, D3.js is not limited to standard charts. In fact, it excels at specialized and custom graph types. To see its power, we’ll create another version of the network graph from <a class="xref" href="ch04.html" title="Chapter 4. Creating Specialized Graphs">Chapter 4</a>. In the earlier implementation we used the Sigma library, and most of our work was structuring the data into the format that library requires. We didn’t have to decide how to draw the nodes and edges, how to connect them, or, once <a id="iddle1198" class="indexterm"/><a id="iddle1398" class="indexterm"/>we enabled layouts, how to position them on the page. As we’ll see next, D3.js doesn’t make those decisions for us. For this example, we’ll have to draw the nodes and edges, connect them to each other appropriately, and position them on the page. That may sound like a lot of work, but, as we’ll also see, D3.js gives us a lot of tools to help.</p><div class="sect2" title="Step 1: Prepare the Data"><div class="titlepage"><div><div><h3 class="title" id="step_1_prepare_the_data-id00031">Step 1: Prepare the Data</h3></div></div></div><p>Since we’re replicating the network graph from <a class="xref" href="ch04.html" title="Chapter 4. Creating Specialized Graphs">Chapter 4</a>, we start with the same data set.</p><a id="pro_id00370"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> albums = [
  {
    <span class="dodgerblue">album</span>: <span class="maroon">"Miles Davis - Kind of Blue"</span>,
    <span class="dodgerblue">musicians</span>: [
      <span class="maroon">"Cannonball Adderley"</span>,
      <span class="maroon">"Paul Chambers"</span>,
      <span class="maroon">"Jimmy Cobb"</span>,
      <span class="maroon">"John Coltrane"</span>,
      <span class="maroon">"Miles Davis"</span>,
      <span class="maroon">"Bill Evans"</span>
  ]
},{
  <span class="dodgerblue">album</span>: <span class="maroon">"John Coltrane - A Love Supreme"</span>,
  <span class="dodgerblue">musicians</span>: [
    <span class="maroon">"John Coltrane"</span>,
    <span class="maroon">"Jimmy Garrison"</span>,
    <span class="maroon">"Elvin Jones"</span>,
    <span class="maroon">"McCoy Tyner"</span>
  ]
<span class="indianred"><span class="emphasis"><em>// Data set continues...</em></span></span></pre><p>For the visualization, it will be helpful to have two separate arrays, one for the graph’s nodes and one for the graph’s edges. Extracting those arrays from the original data is straightforward, so we won’t bother looking at it in this chapter. You can, however, see the full implementation in the book’s source code. The result looks like the following:</p><a id="pro_id00371"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> nodes = [
  {
    <span class="maroon">"name"</span>: <span class="maroon">"Miles Davis - Kind of Blue"</span>,
    <span class="maroon">"links"</span>: [
      <span class="maroon">"Cannonball Adderley"</span>,
      <span class="maroon">"Paul Chambers"</span>,
      <span class="maroon">"Jimmy Cobb"</span>,
      <span class="maroon">"John Coltrane"</span>,
      <span class="maroon">"Miles Davis"</span>,
      <span class="maroon">"Bill Evans"</span>
    ],
    <span class="maroon">"x"</span>: <span class="red">270</span>,
    <span class="maroon">"y"</span>: <span class="red">200</span>
  },
  {
    <span class="maroon">"name"</span>: <span class="maroon">"John Coltrane - A Love Supreme"</span>,
    <span class="maroon">"links"</span>: [
      <span class="maroon">"John Coltrane"</span>,
      <span class="maroon">"Jimmy Garrison"</span>,
      <span class="maroon">"Elvin Jones"</span>,
      <span class="maroon">"McCoy Tyner"</span>
    ],
    <span class="maroon">"x"</span>: <span class="red">307.303483</span>,
    <span class="maroon">"y"</span>: <span class="red">195.287474</span>
  },
  <span class="indianred"><span class="emphasis"><em>// Data set continues...</em></span></span>
];</pre><p><a id="iddle1199" class="indexterm"/><a id="iddle1399" class="indexterm"/>For the nodes, we’ve added <code class="literal">x</code> and <code class="literal">y</code> properties to define a position on the graph. Initially the code arbitrarily sets these values so that the nodes are positioned in a circle.</p><a id="pro_id00372"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> edges = [
  {
    <span class="maroon">"source"</span>: <span class="red">0</span>,
    <span class="maroon">"target"</span>: <span class="red">16</span>,
    <span class="maroon">"links"</span>: [
      <span class="maroon">"Cannonball Adderley"</span>,
      <span class="maroon">"Miles Davis"</span>
    ]
  },
  {
    <span class="maroon">"source"</span>: <span class="red">0</span>,
    <span class="maroon">"target"</span>: <span class="red">6</span>,
    <span class="maroon">"links"</span>: [
      <span class="maroon">"Paul Chambers"</span>,
      <span class="maroon">"John Coltrane"</span>
    ]
  },
  <span class="indianred"><span class="emphasis"><em>// Data set continues...</em></span></span>
];</pre><p>The edges indicate the two nodes that they connect as indices in the <code class="literal">nodes</code> array, and they include an array of the individual musicians that are common between the albums.</p></div><div class="sect2" title="Step 2: Set Up the Page"><div class="titlepage"><div><div><h3 class="title" id="step_2_set_up_the_page">Step 2: Set Up the Page</h3></div></div></div><p>As noted in the previous example, D3.js doesn’t depend on any other libraries, and it’s available on most content distribution networks. All we need to do is include it in the page.</p><a id="pro_id00373"/><pre class="programlisting"><span class="dodgerblue">&lt;!DOCTYPE</span> html<span class="dodgerblue">&gt;</span>
<span class="steelblue"><span class="strong"><strong>&lt;html</strong></span></span> <span class="steelblue">lang=</span><span class="maroon">"en"</span><span class="steelblue"><span class="strong"><strong>&gt;</strong></span></span>
  <span class="steelblue"><span class="strong"><strong>&lt;head&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;meta</strong></span></span> <span class="steelblue">charset=</span><span class="maroon">"utf-8"</span><span class="steelblue"><span class="strong"><strong>&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;title&gt;&lt;/title&gt;</strong></span></span>
  <span class="steelblue"><span class="strong"><strong>&lt;/head&gt;</strong></span></span>
  <span class="steelblue"><span class="strong"><strong>&lt;body&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;div</strong></span></span> <span class="steelblue">id=</span><span class="maroon">"container"</span><span class="steelblue"><span class="strong"><strong>&gt;&lt;/div&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;script</strong></span></span>
      <span class="steelblue">src=</span><span class="maroon">"//cdnjs.cloudflare.com/ajax/libs/d3/3.4.6/d3.min.js"</span><span class="steelblue"><span class="strong"><strong>&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;/script&gt;</strong></span></span>
  <span class="steelblue"><span class="strong"><strong>&lt;/body&gt;</strong></span></span>
<span class="steelblue"><span class="strong"><strong>&lt;/html&gt;</strong></span></span></pre><p><a id="iddle1128" class="indexterm"/><a id="iddle1193" class="indexterm"/><a id="iddle1195" class="indexterm"/><a id="iddle1393" class="indexterm"/><a id="iddle1395" class="indexterm"/><a id="iddle1983" class="indexterm"/>Just as in the previous example, we set up a container for the visualization by including a <code class="literal">&lt;div&gt;</code> with the <code class="literal">id "container"</code>.</p></div><div class="sect2" title="Step 3: Create a Stage for the Visualization"><div class="titlepage"><div><div><h3 class="title" id="step_3_create_a_stage_for_the_vi-id00032">Step 3: Create a Stage for the Visualization</h3></div></div></div><p>This step is also the same as in the previous example.</p><a id="pro_id00374"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> svg = <span class="steelblue">d3</span>.<span class="olive">select</span>(<span class="maroon">"#container"</span>).<span class="olive">append</span>(<span class="maroon">"svg"</span>)
    .<span class="olive">attr</span>(<span class="maroon">"height"</span>, <span class="red">500</span>)
    .<span class="olive">attr</span>(<span class="maroon">"width"</span>, <span class="red">960</span>);</pre><p>We ask D3.js to select the container element and then insert an <code class="literal">&lt;svg&gt;</code> element within it. We also define <code class="literal">&lt;svg&gt;</code> element’s size by setting the <code class="literal">height</code> and <code class="literal">width</code> attributes.</p></div><div class="sect2" title="Step 4: Draw the Graph’s Nodes"><div class="titlepage"><div><div><h3 class="title" id="step_4_draw_the_graphapostrophes_nodes">Step 4: Draw the Graph’s Nodes</h3></div></div></div><p>We’ll draw each node as a circle by appending <code class="literal">&lt;circle&gt;</code> elements inside the <code class="literal">&lt;svg&gt;</code> stage. Based on the previous step, you might think that would be as simple as executing <code class="literal">svg.append("circle")</code> for each element in the <code class="literal">nodes</code> array.</p><a id="pro_id00375"/><pre class="programlisting"><span class="steelblue">nodes</span>.<span class="olive">forEach</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(node) {
    <span class="steelblue">svg</span>.<span class="olive">append</span>(<span class="maroon">"circle"</span>);
});</pre><p>That code will indeed add 25 circles to the visualization. What it <span class="emphasis"><em>won’t</em></span> do, though, is create any links between the data (nodes in the array) and the document (circle elements on the page). D3.js has another way to add the circles to the page that does create that linkage. In fact, not only will D3.js create the links, it will even manage them for us. This support becomes especially valuable as visualizations grow more complex.</p><div class="note" title="Note"><h3 class="title"><a id="ch07note01"/>Note</h3><p><span class="strong"><strong>This feature is really the core of D3.js and, in fact, is the source for the name</strong></span> <span class="emphasis"><em>D3</em></span><span class="strong"><strong>, which is shorthand for</strong></span> <span class="emphasis"><em>data-driven documents</em></span>.</p></div><p><a id="iddle1129" class="indexterm"/><a id="iddle1217" class="indexterm"/>Here’s how we can use D3.js more effectively to add the <code class="literal">&lt;circle&gt;</code> elements to the graph:</p><a id="pro_id00376"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> selection = <span class="steelblue">svg</span>.<span class="olive">selectAll</span>(<span class="maroon">"circle"</span>)
.<span class="olive">data</span>(nodes);

<span class="steelblue">selection</span>.<span class="olive">enter</span>().<span class="olive">append</span>(<span class="maroon">"circle"</span>);</pre><p>If you haven’t seen D3.js code before, that fragment surely looks very strange. What are we trying to do by selecting <code class="literal">&lt;circle&gt;</code> elements before we’ve even created any? Won’t the result just be empty? And if so, what’s the point of the <code class="literal">data()</code> function that follows? To answer those questions, we have to understand how D3.js differs from traditional JavaScript libraries like jQuery. In those libraries a selection represents elements of HTML markup. With jQuery, <code class="literal">$("circle")</code> is nothing more than the <code class="literal">&lt;circle&gt;</code> elements in the page. With D3.js, however, selections are more than just markup elements. D3.js selections can contain both markup <span class="emphasis"><em>and</em></span> data.</p><p>D3.js puts markup elements and data objects together with the <code class="literal">data()</code> function. The object on which it operates (<code class="literal">svg.selectAll("circle")</code> in the preceding code) supplies the elements, and its parameter (<code class="literal">nodes</code>, in this case) provides the data. The first statement in the fragment, therefore, tells D3.js that we want to match <code class="literal">&lt;circle&gt;</code> elements with nodes in our graph. We are, in effect, saying that we want one <code class="literal">&lt;circle&gt;</code> to represent each value in the <code class="literal">nodes</code> array.</p><p>The result is easiest to understand when there are exactly as many elements as there are data values. <a class="xref" href="ch07.html#d3dotjs_selections_can_associate_page_co" title="Figure 7-4. D3.js selections can associate page content such as &lt;circle&gt; elements with data items such as albums.">Figure 7-4</a> shows four <code class="literal">&lt;circle&gt;</code> elements and four albums. D3.js dutifully combines the two sets, giving us a selection of four objects. Each object has both a <code class="literal">&lt;circle&gt;</code> and an album.</p><div class="figure"><a id="d3dotjs_selections_can_associate_page_co"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00101"/><img src="figs/web/07fig04.png.jpg" alt="D3.js selections can associate page content such as &lt;circle&gt; elements with data items such as albums."/></div></div><div class="figure-title">Figure 7-4. D3.js selections can associate page content such as <code class="literal">&lt;circle&gt;</code> elements with data items such as albums.</div></div><p><a id="iddle1130" class="indexterm"/><a id="iddle1194" class="indexterm"/><a id="iddle1309" class="indexterm"/><a id="iddle1394" class="indexterm"/><a id="iddle1611" class="indexterm"/><a id="iddle1878" class="indexterm"/>In general, though, we can’t guarantee that there will be exactly as many elements as data values. Suppose, for example, only two <code class="literal">&lt;circle&gt;</code> elements existed for our four albums. As <a class="xref" href="ch07.html#d3dotjs_selections_keep_track_of_page_co" title="Figure 7-5. D3.js selections keep track of page content that doesn’t exist (yet).">Figure 7-5</a> shows, D3.js still creates a selection of four objects, even though there aren’t enough circles for all of them. Two of the objects will have a data value but no element.</p><div class="figure"><a id="d3dotjs_selections_keep_track_of_page_co"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00102"/><img src="figs/web/07fig05.png.jpg" alt="D3.js selections keep track of page content that doesn’t exist (yet)."/></div></div><div class="figure-title">Figure 7-5. D3.js selections keep track of page content that doesn’t exist (yet).</div></div><p>Our code fragment is an even more extreme example. When it executes, there are absolutely no circles on the page. There are, however, values in the <code class="literal">nodes</code> array that we’re telling D3.js to use as data. D3.js, therefore, creates an object for each of those data values. It just won’t have a <code class="literal">&lt;circle&gt;</code> element to go with them.</p><p>(Take a breath because magic is about to happen.)</p><p>Now we can look at the second statement in our code fragment. It starts with <code class="literal">selection.enter()</code>. The <code class="literal">enter()</code> function is a special D3.js function. It tells D3.js to search through the selection and find all of the objects that have a data value <span class="emphasis"><em>but no markup element.</em></span> We then complete the statement by taking that subset of the selection and calling <code class="literal">append("circle")</code>. And with that function call, D3.js will take any object in the selection without a markup element and create a circle for it. That’s how we add <code class="literal">&lt;circle&gt;</code> elements to the graph.</p><p>To be a little more concise, we can combine our two statements into a single one.</p><a id="pro_id00377"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> nodeSelection = <span class="steelblue">svg</span>.<span class="olive">selectAll</span>(<span class="maroon">"circle"</span>)
    .<span class="olive">data</span>(nodes)
    .<span class="olive">enter</span>().<span class="olive">append</span>(<span class="maroon">"circle"</span>);</pre><p>The effect for our visualization is to create a <code class="literal">&lt;circle&gt;</code> within the <code class="literal">&lt;svg&gt;</code> container for every node in the graph.</p></div><div class="sect2" title="Step 5: Draw the Graph’s Edges"><div class="titlepage"><div><div><h3 class="title" id="step_5_draw_the_graphapostrophes_edges">Step 5: Draw the Graph’s Edges</h3></div></div></div><p><a id="iddle1180" class="indexterm"/><a id="iddle1181" class="indexterm"/><a id="iddle1197" class="indexterm"/><a id="iddle1310" class="indexterm"/><a id="iddle1317" class="indexterm"/><a id="iddle1397" class="indexterm"/><a id="iddle1786" class="indexterm"/><a id="iddle2111" class="indexterm"/>You won’t be surprised to find that adding the edges to the graph works just like adding nodes. We simply append <code class="literal">&lt;line&gt;</code> elements instead of circles.</p><a id="pro_id00378"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> edgeSelection = <span class="steelblue">svg</span>.<span class="olive">selectAll</span>(<span class="maroon">"line"</span>)
    .<span class="olive">data</span>(edges)
    .<span class="olive">enter</span>().<span class="olive">append</span>(<span class="maroon">"line"</span>);</pre><p>Even though we won’t need to use them for this example, D3.js has other functions that complement the <code class="literal">enter()</code> function. To find objects that have a markup element but no data value, you can use the function <code class="literal">exit()</code>. And to find objects that have a markup element with a data value that has changed, you can use the function <code class="literal">update()</code>. The names <span class="emphasis"><em>enter</em></span> and <span class="emphasis"><em>exit</em></span> derive from a theater metaphor that D3.js associates with a visualization. The <code class="literal">enter()</code> subset represents those elements that are entering the stage, while the <code class="literal">exit()</code> subset represents elements exiting the stage.</p><p>Because we’re using SVG elements for both the nodes and the edges, we can use CSS rules to style them. That’s especially important for the edges because, by default, SVG lines have a stroke width of <code class="literal">0</code>.</p><a id="pro_id00379"/><pre class="programlisting">circle <span class="steelblue"><span class="strong"><strong>{</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>fill:</strong></span></span> <span class="dodgerblue">#ccc</span><span class="steelblue"><span class="strong"><strong>;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>stroke:</strong></span></span> <span class="dodgerblue">#fff</span><span class="steelblue"><span class="strong"><strong>;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>stroke-width:</strong></span></span> <span class="dodgerblue">1px</span><span class="steelblue"><span class="strong"><strong>;</strong></span></span>
<span class="steelblue"><span class="strong"><strong>}</strong></span></span>

line <span class="steelblue"><span class="strong"><strong>{</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>stroke:</strong></span></span> <span class="dodgerblue">#777</span><span class="steelblue"><span class="strong"><strong>;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>stroke-width:</strong></span></span> <span class="dodgerblue">1px</span><span class="steelblue"><span class="strong"><strong>;</strong></span></span>
<span class="steelblue"><span class="strong"><strong>}</strong></span></span></pre></div><div class="sect2" title="Step 6: Position the Elements"><div class="titlepage"><div><div><h3 class="title" id="step_6_position_the_elements">Step 6: Position the Elements</h3></div></div></div><p>At this point, we’ve added the necessary markup elements to our visualization, but we haven’t given them any dimensions or positions. As noted before, D3.js doesn’t do any drawing, so we’ll have to write the code to do it. And as noted in Step 2, we did assign somewhat arbitrary positions to the nodes by arranging them in a circle. For now, we can use that to position them.</p><p>To position an SVG circle, we set its <code class="literal">cx</code> and <code class="literal">cy</code> attributes to correspond to the circle’s center. We also specify the circle’s radius with the <code class="literal">r</code> attribute. Let’s start with the radius; we’ll set it to a fixed value for all nodes. We’ve already created a D3.js selection for all of those nodes. Setting their <code class="literal">r</code> attributes is a simple statement:</p><a id="pro_id00380"/><pre class="programlisting"><span class="steelblue">nodeSelection</span>.<span class="olive">attr</span>(<span class="maroon">"r"</span>, <span class="red">10</span>);</pre><p><a id="iddle1391" class="indexterm"/><a id="iddle1612" class="indexterm"/>The <code class="literal">cx</code> and <code class="literal">cy</code> values are a little trickier because they’re not the same for all of the nodes. Those values depend on properties of the data associated with the nodes. More specifically, each element in the <code class="literal">nodes</code> array has <code class="literal">x</code> and <code class="literal">y</code> properties. D3.js, however, makes it very easy to access those properties.</p><a id="pro_id00381"/><pre class="programlisting">nodeSelection
    .<span class="olive">attr</span>(<span class="maroon">"r"</span>, <span class="red">10</span>)
    .<span class="olive">attr</span>(<span class="maroon">"cx"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(dataValue) { <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">dataValue</span>.<span class="olive">x</span>; })
    .<span class="olive">attr</span>(<span class="maroon">"cy"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(dataValue) { <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">dataValue</span>.<span class="olive">y</span>; });</pre><p>Instead of providing constant values for the attributes, we provide functions. D3.js will then call those functions and pass the data values as parameters. Our functions will return the appropriate value for the attribute.</p><p>Positioning the edges relies on a similar strategy. We want to set the endpoints of the lines to the centers of the corresponding nodes. Those endpoints are the <code class="literal">x1,y1</code> and <code class="literal">x2,y2</code> attributes of the <code class="literal">&lt;line&gt;</code> elements. Here’s the code to set those attributes.</p><a id="pro_id00382"/><pre class="programlisting">edgeSelection
    .<span class="olive">attr</span>(<span class="maroon">"x1"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) { <span class="steelblue"><span class="strong"><strong>return</strong></span></span> nodes[<span class="steelblue">d</span>.<span class="olive">source</span>].<span class="olive">x</span>; })
    .<span class="olive">attr</span>(<span class="maroon">"y1"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) { <span class="steelblue"><span class="strong"><strong>return</strong></span></span> nodes[<span class="steelblue">d</span>.<span class="olive">source</span>].<span class="olive">y</span>; })
    .<span class="olive">attr</span>(<span class="maroon">"x2"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) { <span class="steelblue"><span class="strong"><strong>return</strong></span></span> nodes[<span class="steelblue">d</span>.<span class="olive">target</span>].<span class="olive">x</span>; })
    .<span class="olive">attr</span>(<span class="maroon">"y2"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) { <span class="steelblue"><span class="strong"><strong>return</strong></span></span> nodes[<span class="steelblue">d</span>.<span class="olive">target</span>].<span class="olive">y</span>; });</pre><p>As is conventional with D3.js, the parameter <code class="literal">d</code> is the data value.</p><p>With the elements finally drawn and positioned, we have the first version of our visualization with <a class="xref" href="ch07.html#d3dotjs_provides_tools_to_help_draw_the" title="Figure 7-6. D3.js provides tools to help draw the circles and lines for a network graph.">Figure 7-6</a>.</p><div class="figure"><a id="d3dotjs_provides_tools_to_help_draw_the"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00103"/><img src="figs/web/07fig06.png.jpg" alt="D3.js provides tools to help draw the circles and lines for a network graph."/></div></div><div class="figure-title">Figure 7-6. D3.js provides tools to help draw the circles and lines for a network graph.</div></div></div><div class="sect2" title="Step 7: Add Force Direction to the Graph"><div class="titlepage"><div><div><h3 class="title" id="step_7_add_force_direction_to_the_graph">Step 7: Add Force Direction to the Graph</h3></div></div></div><p><a id="iddle1191" class="indexterm"/><a id="iddle1385" class="indexterm"/><a id="iddle1386" class="indexterm"/><a id="iddle2008" class="indexterm"/>The graph has all the essential components, but its layout doesn’t make identifying the connections as easy as we’d like. In <a class="xref" href="ch04.html" title="Chapter 4. Creating Specialized Graphs">Chapter 4</a> the Sigma library could automate the layout with only a couple of lines of JavaScript. To perform that automation, Sigma uses a force-direction algorithm. Force direction treats nodes as physical objects and simulates the effect of forces such as gravity and electromagnetism.</p><p>With D3.js we cannot rely on the library to fully automate the layout. As we’ve seen, D3.js does not draw any of the graph elements, so it cannot, by itself, set positions and dimensions. D3.js does, however, provide a lot of tools to help us create our own graph layouts. One of those tools is the <span class="emphasis"><em>force layout tool.</em></span> As you might expect, the force layout tool helps us draw our own force-directed graph. It handles all of the messy and complex calculations that underlie force direction and gives us results we can use directly in code that draws the graph.</p><p>To get started with the layout, we define a new <code class="literal">force</code> object. That object accepts many configuration parameters, but only five are essential for our visualization:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The dimensions of the graph</p></li><li class="listitem"><p>The nodes in the graph</p></li><li class="listitem"><p>The edges in the graph</p></li><li class="listitem"><p>The distance we’d like to see between connected nodes</p></li><li class="listitem"><p>How strongly nodes repel each other, a parameter D3.js calls <span class="emphasis"><em>charge</em></span></p></li></ul></div><p>The last parameter can take a bit of trial and error to optimize for any particular visualization. In our case, we’ll want to increase it substantially above its default (<code class="literal">-30</code>) because we have a lot of nodes in a small space. (Negative charge values indicate repulsion.) Here’s the code to set all of those values:</p><a id="pro_id00383"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> force = <span class="steelblue">d3</span>.<span class="steelblue">layout</span>.<span class="olive">charge</span>()
    .<span class="olive">size</span>([width, height])
    .<span class="olive">nodes</span>(nodes)
    .<span class="olive">links</span>(edges)
    .<span class="olive">linkDistance</span>(<span class="red">40</span>)
    .<span class="olive">charge</span>(<span class="red">-500</span>);</pre><p>When we tell D3.js to start its force-direction calculations, it will generate events at intermediate steps and when the calculations complete. Force direction often takes several seconds to execute fully, and if we wait until the calculations are complete before we draw the graph, users may think the browser has frozen. It’s usually better to update the graph at each iteration so users see some indication of progress. To do that, we can add a function to respond to the intermediate force-direction calculations. That happens on a D3.js <code class="literal">tick</code> event.</p><a id="pro_id00384"/><pre class="programlisting"><span class="steelblue">force</span>.<span class="olive">on</span>(<span class="maroon">"tick"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>() {
    <span class="indianred"><span class="emphasis"><em>// Update graph with intermediate results</em></span></span>
});</pre><p><a id="iddle1387" class="indexterm"/><a id="iddle1720" class="indexterm"/>Each time D3.js calls our event handler function, it will have updated the <code class="literal">x</code> and <code class="literal">y</code> properties of the <code class="literal">nodes</code> array. The new values will reflect how the force direction has nudged the nodes on the graph’s stage. We can update our graph accordingly by changing the SVG attributes of the circles and lines. Before we do that, however, we can take advantage of the fact that D3.js is giving us an opportunity to tweak the force-direction algorithm as it executes. One problem that we may encounter, especially with the large charge force we defined, is that nodes may repel each other so strongly that some tend to drift off the stage entirely. We can prevent that by ensuring that the node positions remain within the dimensions of the graph.</p><a id="pro_id00385"/><pre class="programlisting"><span class="steelblue">force</span>.<span class="olive">on</span>(<span class="maroon">"tick"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>() {
    <span class="steelblue">nodeSelection</span>.<span class="olive">each</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(node) {
        <span class="steelblue">node</span>.<span class="olive">x</span> = <span class="steelblue">Math</span>.<span class="olive">max</span>(<span class="steelblue">node</span>.<span class="olive">x</span>, <span class="red">5</span>);
        <span class="steelblue">node</span>.<span class="olive">y</span> = <span class="steelblue">Math</span>.<span class="olive">max</span>(<span class="steelblue">node</span>.<span class="olive">y</span>, <span class="red">5</span>);
        <span class="steelblue">node</span>.<span class="olive">x</span> = <span class="steelblue">Math</span>.<span class="olive">min</span>(<span class="steelblue">node</span>.<span class="olive">x</span>, width<span class="red">-5</span>);
        <span class="steelblue">node</span>.<span class="olive">y</span> = <span class="steelblue">Math</span>.<span class="olive">min</span>(<span class="steelblue">node</span>.<span class="olive">y</span>, height<span class="red">-5</span>);
    });
    <span class="indianred"><span class="emphasis"><em>// Update graph with intermediate results</em></span></span>
});</pre><p>We’ve added or subtracted <code class="literal">5</code> in the preceding fragment to account for the radius of the nodes’ circles.</p><p>Once we’ve adjusted the nodes’ properties to keep them on the stage, we can update their positions. The code is exactly the same as the code we used to position them initially.</p><a id="pro_id00386"/><pre class="programlisting">nodeSelection
    .<span class="olive">attr</span>(<span class="maroon">"cx"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) { <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">d</span>.<span class="olive">x</span>; })
    .<span class="olive">attr</span>(<span class="maroon">"cy"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) { <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">d</span>.<span class="olive">y</span>; });</pre><p>We’ll also want to adjust the endpoints of our edge lines. For these objects, however, there’s a small twist. When we initialized the <code class="literal">edges</code> array, we set the <code class="literal">source</code> and <code class="literal">target</code> properties to the indices of the respective nodes in the <code class="literal">nodes</code> array. When the D3.js force layout tool begins execution, it replaces those indices with direct references to the nodes themselves. That makes it a little easier for us to find the appropriate coordinates for the lines.</p><a id="pro_id00387"/><pre class="programlisting">edgeSelection
    .<span class="olive">attr</span>(<span class="maroon">"x1"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) { <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">d</span>.<span class="steelblue">source</span>.<span class="olive">x</span>; })
    .<span class="olive">attr</span>(<span class="maroon">"y1"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) { <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">d</span>.<span class="steelblue">source</span>.<span class="olive">y</span>; })
    .<span class="olive">attr</span>(<span class="maroon">"x2"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) { <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">d</span>.<span class="steelblue">target</span>.<span class="olive">x</span>; })
    .<span class="olive">attr</span>(<span class="maroon">"y2"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) { <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">d</span>.<span class="steelblue">target</span>.<span class="olive">y</span>; });</pre><p>With our function ready to handle updates from the force-direction calculations, we can tell D3.js to start its work. That’s a simple method of the <code class="literal">force</code> object.</p><a id="pro_id00388"/><pre class="programlisting"><span class="steelblue">force</span>.<span class="olive">start</span>();</pre><p><a id="iddle1192" class="indexterm"/><a id="iddle1392" class="indexterm"/>With that statement, the graph begins an animated transition to its final, force-directed state, as <a class="xref" href="ch07.html#d3dotjs_force_layout_tool_provides_the_i" title="Figure 7-7. The D3.js force layout tool provides the information to reposition network graph elements.">Figure 7-7</a> shows.</p><div class="figure"><a id="d3dotjs_force_layout_tool_provides_the_i"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00104"/><img src="figs/web/07fig07.png.jpg" alt="The D3.js force layout tool provides the information to reposition network graph elements."/></div></div><div class="figure-title">Figure 7-7. The D3.js force layout tool provides the information to reposition network graph elements.</div></div></div><div class="sect2" title="Step 8: Add Interactivity"><div class="titlepage"><div><div><h3 class="title" id="step_8_add_interactivity-id00033">Step 8: Add Interactivity</h3></div></div></div><p>Since D3.js is a JavaScript library, you would expect it to support interactions with the user. It does, and to demonstrate, we can add a simple interaction to the graph. When a user clicks on one of the nodes in the graph, we can emphasize that node and its neighbors.</p><p>Event handlers in D3.js closely resemble those in other JavaScript libraries such as jQuery. We define an event handler using the <code class="literal">on()</code> method of a selection, as in the following code.</p><a id="pro_id00389"/><pre class="programlisting"><span class="steelblue">nodeSelection</span>.<span class="olive">on</span>(<span class="maroon">"click"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) {
    <span class="indianred"><span class="emphasis"><em>// Handle the click event</em></span></span>
});</pre><p>The first parameter to <code class="literal">on()</code> is the event type, and the second parameter is a function that D3.js will call when the event occurs. The parameter to this function is the data object that corresponds to the selection element, and by convention it’s named <code class="literal">d</code>. Because we’re adding the event to the selection of nodes (<code class="literal">nodeSelection</code>), <code class="literal">d</code> will be one of the graph nodes.</p><p><a id="iddle1131" class="indexterm"/><a id="iddle1613" class="indexterm"/><a id="iddle1909" class="indexterm"/><a id="iddle2000" class="indexterm"/>For our visualization, we’ll emphasize the clicked node by adding a CSS-accessible class to the corresponding <code class="literal">&lt;circle&gt;</code> and by increasing the circle’s size. The class makes it possible to style the circle uniquely, but a circle’s size cannot be specified with CSS rules. Ultimately, therefore, we have to do two things to the circle: add the <code class="literal">selected</code> class and increase the radius using the <code class="literal">r</code> attribute. Of course, in order to do either, we have to select the <code class="literal">&lt;circle&gt;</code> element. When D3.js calls an event handler, it sets <code class="literal">this</code> equal to the target of the event; we can turn that target into a selection with <code class="literal">d3.select(this)</code>. The following code, therefore, is all it takes to change the clicked node’s circle.</p><a id="pro_id00390"/><pre class="programlisting"><span class="steelblue">d3</span>.<span class="olive">select</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>)
   .<span class="olive">classed</span>(<span class="maroon">"selected"</span>, <span class="steelblue"><span class="strong"><strong>true</strong></span></span>)
   .<span class="olive">attr</span>(<span class="maroon">"r"</span>, <span class="red">1.5</span>*nodeRadius);</pre><p>We can do something similar by adding a <code class="literal">selected</code> class to all the edges that connect to the clicked node. To find those edges we can iterate through the full edge selection. D3.js provides the <code class="literal">each()</code> function to do just that.</p><a id="pro_id00391"/><pre class="programlisting">   <span class="steelblue">edgeSelection</span>.<span class="olive">each</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(edge) {
       <span class="steelblue"><span class="strong"><strong>if</strong></span></span> ((<span class="steelblue">edge</span>.<span class="olive">source</span> === d) || (<span class="steelblue">edge</span>.<span class="olive">target</span> === d)) {
➊         <span class="steelblue">d3</span>.<span class="olive">select</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>).<span class="olive">classed</span>(<span class="maroon">"selected"</span>,<span class="steelblue"><span class="strong"><strong>true</strong></span></span>);
       }
   });</pre><p>As we look at each edge, we check the <code class="literal">source</code> and <code class="literal">target</code> properties to see if either matches our clicked node. When we find a match, we add the <code class="literal">selected</code> class to the edge. Note that at ➊ we’re once again using <code class="literal">d3.select(this)</code>. In this example the code is inside the <code class="literal">each()</code> function, so <code class="literal">this</code> will equal the particular element of the current iteration. In our case that’s the <code class="literal">&lt;line&gt;</code> for the edge.</p><p>The preceding code handles setting the <code class="literal">selected</code> class, but we still need to remove it when appropriate. We can remove it from all the other circles (and make sure their radii are restored to their default values) by operating on the node selection.</p><a id="pro_id00392"/><pre class="programlisting">   nodeSelection
➊     .<span class="olive">filter</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(node) { <span class="steelblue"><span class="strong"><strong>return</strong></span></span> node !== d; })
       .<span class="olive">classed</span>(<span class="maroon">"selected"</span>, <span class="steelblue"><span class="strong"><strong>false</strong></span></span>)
       .<span class="olive">attr</span>(<span class="maroon">"r"</span>, nodeRadius);</pre><p>The code looks the same as we’ve seen before, except that at ➊ we use the D3.js <code class="literal">filter()</code> function to limit the selection to the nodes other than the one that was clicked.</p><p><a id="iddle1866" class="indexterm"/>A similar process resets the <code class="literal">selected</code> class on all the edges. We can remove the class from all edges first, before we add to the appropriate edges in the previous code fragment. Here’s the code that removes it; with D3.js it takes only a single line:</p><a id="pro_id00393"/><pre class="programlisting"><span class="steelblue">edgeSelection</span>.<span class="olive">classed</span>(<span class="maroon">"selected"</span>, <span class="steelblue"><span class="strong"><strong>false</strong></span></span>);</pre><p>And finally, if the user clicks on a node that’s already selected, we can restore it to its default state like so:</p><a id="pro_id00394"/><pre class="programlisting"><span class="steelblue">d3</span>.<span class="olive">select</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>)
    .<span class="olive">classed</span>(<span class="maroon">"selected"</span>, <span class="steelblue"><span class="strong"><strong>true</strong></span></span>)
    .<span class="olive">attr</span>(<span class="maroon">"r"</span>, <span class="red">1.5</span>*nodeRadius);</pre><p>When you put all of the preceding code fragments together, you have the complete event handler shown here:</p><a id="pro_id00395"/><pre class="programlisting"><span class="steelblue">nodeSelection</span>.<span class="olive">on</span>(<span class="maroon">"click"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) {

    nodeSelection
        .<span class="olive">filter</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(node) { <span class="steelblue"><span class="strong"><strong>return</strong></span></span> node !== d; })
        .<span class="olive">classed</span>(<span class="maroon">"selected"</span>, <span class="steelblue"><span class="strong"><strong>false</strong></span></span>)
        .<span class="olive">attr</span>(<span class="maroon">"r"</span>, nodeRadius);

    <span class="steelblue">edgeSelection</span>.<span class="olive">classed</span>(<span class="maroon">"selected"</span>, <span class="steelblue"><span class="strong"><strong>false</strong></span></span>);

    <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (<span class="steelblue">d3</span>.<span class="olive">select</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>).<span class="olive">classed</span>(<span class="maroon">"selected"</span>)) {
        <span class="steelblue">d3</span>.<span class="olive">select</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>)
            .<span class="olive">classed</span>(<span class="maroon">"selected"</span>, <span class="steelblue"><span class="strong"><strong>false</strong></span></span>)
            .<span class="olive">attr</span>(<span class="maroon">"r"</span>, nodeRadius)

    } <span class="steelblue"><span class="strong"><strong>else</strong></span></span> {
        <span class="steelblue">d3</span>.<span class="olive">select</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>)
            .<span class="olive">classed</span>(<span class="maroon">"selected"</span>, <span class="steelblue"><span class="strong"><strong>true</strong></span></span>)
            .<span class="olive">attr</span>(<span class="maroon">"r"</span>, <span class="red">1.5</span>*nodeRadius);

        <span class="steelblue">edgeSelection</span>.<span class="olive">each</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(edge) {
             <span class="steelblue"><span class="strong"><strong>if</strong></span></span> ((<span class="steelblue">edge</span>.<span class="olive">source</span> === d) || (<span class="steelblue">edge</span>.<span class="olive">target</span> === d)) {
                 <span class="steelblue">d3</span>.<span class="olive">select</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>).<span class="olive">classed</span>(<span class="maroon">"selected"</span>,<span class="steelblue"><span class="strong"><strong>true</strong></span></span>);
             }
        });
    }
});</pre><p>Along with a bit of CSS styling to emphasize the selected circles and lines, this code results in the interactive visualization of <a class="xref" href="ch07.html#d3dotjs_includes_functions_to_make_visua" title="Figure 7-8. D3.js includes functions to make visualizations interactive.">Figure 7-8</a>.</p><div class="figure"><a id="d3dotjs_includes_functions_to_make_visua"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00105"/><img src="figs/web/07fig08.png.jpg" alt="D3.js includes functions to make visualizations interactive."/></div></div><div class="figure-title">Figure 7-8. D3.js includes functions to make visualizations interactive.</div></div></div><div class="sect2" title="Step 9: Experiment with Other Enhancements"><div class="titlepage"><div><div><h3 class="title" id="step_9_experiment_with_other_enhancement">Step 9: Experiment with Other Enhancements</h3></div></div></div><p><a id="iddle1200" class="indexterm"/><a id="iddle1654" class="indexterm"/><a id="iddle1838" class="indexterm"/><a id="iddle1840" class="indexterm"/>Our example has explored many of the features that D3.js provides for custom visualizations. The code so far, however, has only scratched the surface of D3’s capabilities. We haven’t added labels to our graph or animated the transitions in the graph’s state. In fact, it’s a pretty safe bet that if there is anything we want to add to the visualization, D3.js has tools to help. And although we don’t have the time or space to consider other enhancements here, the source code for the book does include a more full-featured implementation that takes advantage of other D3.js capabilities.</p></div></div><div class="sect1" title="Creating a Scalable Map"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="creating_a_scalable_map">Creating a Scalable Map</h2></div></div></div><p>The first two examples touched on some of the capabilities of D3.js, but the library includes many others. From the examples in <a class="xref" href="ch06.html" title="Chapter 6. Visualizing Geographic Data">Chapter 6</a>, we know some of the best visualizations rely on maps, and D3.js—as a general-purpose visualization library—has extensive support for mapping. To illustrate that support, we’ll create a map that shows tornado sightings in the continental United States.</p><div class="sect2" title="Step 1: Prepare the Data"><div class="titlepage"><div><div><h3 class="title" id="step_1_prepare_the_data-id00034">Step 1: Prepare the Data</h3></div></div></div><p>The US National Oceanic and Atmospheric Administration (<span class="emphasis"><em><a class="ulink" href="http://www.noaa.gov/" target="_top">http://www.noaa.gov/</a></em></span>) publishes an extensive set of weather and climate data on its Climate Data Online site (<span class="emphasis"><em><a class="ulink" href="http://www.ncdc.noaa.gov/cdo-web/" target="_top">http://www.ncdc.noaa.gov/cdo-web/</a></em></span>). That data includes all storm events reported in the United States and its territories. We can download the data set for the year 2013 as a comma-separated value (CSV) file. Because the file is extremely large and contains many events that aren’t tornadoes, we can edit it to remove the extraneous information using a spreadsheet application such as Microsoft <a id="iddle1837" class="indexterm"/><a id="iddle1842" class="indexterm"/>Excel or Numbers for Mac. For this visualization, we need only records that have an <code class="literal">event_type</code> equal to <code class="literal">"Tornado"</code>, and we want only the columns for the tornado’s latitude, longitude, and Enhanced Fujita Scale classification (a measure of tornado strength). Once we’ve pruned the CSV file appropriately, it will look something like the following data.</p><a id="pro_id00396"/><pre class="programlisting">f_scale,latitude,longitude
EF1,33.87,-88.23
EF1,33.73,-87.9
EF0,33.93,-87.5
EF1,34.06,-87.37
EF1,34.21,-87.18
EF1,34.23,-87.11
EF1,31.54,-88.16
EF1,31.59,-88.06
EF1,31.62,-87.85
--<span class="emphasis"><em>snip</em></span>--</pre><p>Since we’re going to access this data using JavaScript, you might be tempted to convert the file from CSV to JSON format. It’s better, however, to keep the data in a CSV file. D3.js has full support for CSV, so we don’t really gain anything by converting to JSON. More importantly, the JSON file would be more than four times larger than the CSV version, and that extra size would slow down the loading of our web page.</p></div><div class="sect2" title="Step 2: Set Up the Page"><div class="titlepage"><div><div><h3 class="title" id="step_2_set_up_the_page-id00035">Step 2: Set Up the Page</h3></div></div></div><p>Our skeletal web page is no different from the other D3.js examples. We set aside a container for the map and include the D3.js library.</p><a id="pro_id00397"/><pre class="programlisting"><span class="dodgerblue">&lt;!DOCTYPE</span> html<span class="dodgerblue">&gt;</span>
<span class="steelblue"><span class="strong"><strong>&lt;html</strong></span></span> <span class="steelblue">lang=</span><span class="maroon">"en"</span><span class="steelblue"><span class="strong"><strong>&gt;</strong></span></span>
  <span class="steelblue"><span class="strong"><strong>&lt;head&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;meta</strong></span></span> <span class="steelblue">charset=</span><span class="maroon">"utf-8"</span><span class="steelblue"><span class="strong"><strong>&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;title&gt;&lt;/title&gt;</strong></span></span>
  <span class="steelblue"><span class="strong"><strong>&lt;/head&gt;</strong></span></span>
  <span class="steelblue"><span class="strong"><strong>&lt;body&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;div</strong></span></span> <span class="steelblue">id=</span><span class="maroon">"map"</span><span class="steelblue"><span class="strong"><strong>&gt;&lt;/div&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;script</strong></span></span>
      <span class="steelblue">src=</span><span class="maroon">"//cdnjs.cloudflare.com/ajax/libs/d3/3.4.6/d3.min.js"</span><span class="steelblue"><span class="strong"><strong>&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;/script&gt;</strong></span></span>
  <span class="steelblue"><span class="strong"><strong>&lt;/body&gt;</strong></span></span>
<span class="steelblue"><span class="strong"><strong>&lt;/html&gt;</strong></span></span></pre></div><div class="sect2" title="Step 3: Create a Map Projection"><div class="titlepage"><div><div><h3 class="title" id="step_3_create_a_map_projection">Step 3: Create a Map Projection</h3></div></div></div><p>If you can’t quite recall your geography lessons about map projections, don’t worry; D3.js can handle all of the heavy lifting. Not only does it have extensive support for common projections, but it also supports extensions for custom projections tailored <a id="iddle1413" class="indexterm"/><a id="iddle1704" class="indexterm"/><a id="iddle1743" class="indexterm"/><a id="iddle1836" class="indexterm"/><a id="iddle1843" class="indexterm"/>specifically for visualizations. For example, there’s a modified Albers projection that’s optimized for choropleth maps of the United States. It repositions (and resizes) Alaska and Hawaii to provide a convenient map of all 50 states. In our case, since there were no tornado sightings in Alaska or Hawaii in 2013, we can use a standard Albers projection.</p><p>We set up the projection in the following code.</p><a id="pro_id00398"/><pre class="programlisting">➊ <span class="steelblue"><span class="strong"><strong>var</strong></span></span> width = <span class="red">640</span>,
➋     height = <span class="red">400</span>;

➌ <span class="steelblue"><span class="strong"><strong>var</strong></span></span> projection = <span class="steelblue">d3</span>.<span class="steelblue">geo</span>.<span class="olive">albers</span>()
➍     .<span class="olive">scale</span>(<span class="red">888</span>)
➎     .<span class="olive">translate</span>([width / <span class="red">2</span>, height / <span class="red">2</span>]);

➏ <span class="steelblue"><span class="strong"><strong>var</strong></span></span> path = <span class="steelblue">d3</span>.<span class="steelblue">geo</span>.<span class="olive">path</span>()
➐     .<span class="olive">projection</span>(projection);</pre><p>First, at ➊ and ➋, we define the size of our map in pixels. Then, at ➌, we create the Albers projection. D3.js supports many adjustments to position the projection appropriately on the page, but the default values are fine in our case. We need only to scale the map at ➍ and center it at ➎.</p><p>To draw the map on the page, we’re going to use SVG <code class="literal">&lt;path&gt;</code> elements, but our map data takes the form of latitude and longitude values. D3.js has a <code class="literal">path</code> object to translate geographic coordinates to SVG paths based on a particular map projection. At ➏ and ➐, we create our <code class="literal">path</code> object.</p></div><div class="sect2" title="Step 4: Initialize the SVG Container"><div class="titlepage"><div><div><h3 class="title" id="step_4_initialize_the_svg_container">Step 4: Initialize the SVG Container</h3></div></div></div><p>We can create an SVG container to hold the map, just as we did in the previous D3.js example.</p><a id="pro_id00399"/><pre class="programlisting">   <span class="steelblue"><span class="strong"><strong>var</strong></span></span> svg = <span class="steelblue">d3</span>.<span class="olive">select</span>(<span class="maroon">"#map"</span>).<span class="olive">append</span>(<span class="maroon">"svg"</span>)
       .<span class="olive">attr</span>(<span class="maroon">"width"</span>, width)
       .<span class="olive">attr</span>(<span class="maroon">"height"</span>, height);

➊  <span class="steelblue"><span class="strong"><strong>var</strong></span></span> g = <span class="steelblue">svg</span>.<span class="olive">append</span>(<span class="maroon">"g"</span>);</pre><p>As we’ll see in later steps, it will be helpful have an inner group in which to place the map. This inner group (defined by a <code class="literal">&lt;g&gt;</code> element) acts much like an arbitrary <code class="literal">&lt;div&gt;</code> element in HTML. We create that inner group at ➊.</p></div><div class="sect2" title="Step 5: Retrieve the Map Data"><div class="titlepage"><div><div><h3 class="title" id="step_5_retrieve_the_map_data">Step 5: Retrieve the Map Data</h3></div></div></div><p>For our visualization, the map data is nothing but a map of the United States with individual states. D3.js uses GeoJSON (<span class="emphasis"><em><a class="ulink" href="http://geojson.org/" target="_top">http://geojson.org/</a></em></span>) for its map data. Unlike most of the image tiles that we used in <a class="xref" href="ch06.html" title="Chapter 6. Visualizing Geographic Data">Chapter 6</a>, GeoJSON data is vector based, so it can be used at any scale. GeoJSON data is also in JSON format, which makes it especially compatible with JavaScript.</p><p><a id="iddle1004" class="indexterm"/><a id="iddle1744" class="indexterm"/><a id="iddle1835" class="indexterm"/><a id="iddle1839" class="indexterm"/><a id="iddle1841" class="indexterm"/>Since our data is in a JSON format, we can use the <code class="literal">d3.json()</code> function to retrieve it. This function is almost identical to the jQuery <code class="literal">$.getJSON()</code> function.</p><a id="pro_id00400"/><pre class="programlisting"><span class="steelblue">d3</span>.<span class="olive">json</span>(<span class="maroon">"data/us-states.json"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(map) {
    <span class="indianred"><span class="emphasis"><em>// Process the JSON map data</em></span></span>
});</pre></div><div class="sect2" title="Step 6: Draw the Map"><div class="titlepage"><div><div><h3 class="title" id="step_6_draw_the_map-id00036">Step 6: Draw the Map</h3></div></div></div><p>Once we have our data, we can draw the map on the page. The code in this step is very similar to that in the previous example. Each state will be a <code class="literal">&lt;path&gt;</code> element within the <code class="literal">&lt;g&gt;</code> container.</p><a id="pro_id00401"/><pre class="programlisting">➊ <span class="steelblue">g</span>.<span class="olive">selectAll</span>(<span class="maroon">"path"</span>)
➋     .<span class="olive">data</span>(<span class="steelblue">map</span>.<span class="olive">features</span>)
➌   .<span class="olive">enter</span>().<span class="olive">append</span>(<span class="maroon">"path"</span>)
➍     .<span class="olive">attr</span>(<span class="maroon">"d"</span>, path);</pre><p>Using D3.js conventions, we create a selection of <code class="literal">&lt;path&gt;</code> elements at ➊ and bind those elements to our data at ➋. When there is no element, we create one ➌ and we set its <code class="literal">d</code> attribute to be the path associated with the data, given our projection. Note that <code class="literal">path</code> at ➍ is the object we created in Step 4. It is a function that translates the latitude and longitude information into appropriate SVG coordinates.</p><p>As we can see from <a class="xref" href="ch07.html#d3dotjs_helps_create_vector_maps_from_ge" title="Figure 7-9. D3.js helps create vector maps from geographic JSON data.">Figure 7-9</a>, D3.js gives us the paths required to create a nice SVG map.</p><div class="figure"><a id="d3dotjs_helps_create_vector_maps_from_ge"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00106"/><img src="figs/web/07fig09.png.jpg" alt="D3.js helps create vector maps from geographic JSON data."/></div></div><div class="figure-title">Figure 7-9. D3.js helps create vector maps from geographic JSON data.</div></div></div><div class="sect2" title="Step 7: Retrieve the Weather Data"><div class="titlepage"><div><div><h3 class="title" id="step_7_retrieve_the_weather_data">Step 7: Retrieve the Weather Data</h3></div></div></div><p>Now our map is ready for some data. We can retrieve the CSV file using another D3.js utility. Note, though, that all of the properties of a CSV file are considered text strings. We’ll want to convert those strings to numbers. We also want to filter out the few tornado sightings that don’t include latitude and longitude information.</p><a id="pro_id00402"/><pre class="programlisting">   <span class="steelblue">d3</span>.<span class="olive">csv</span>(<span class="maroon">"tornadoes.csv"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(data) {
➊     data = <span class="steelblue">data</span>.<span class="olive">filter</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d, i) {
➋         <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (<span class="steelblue">d</span>.<span class="olive">latitude</span> &amp;&amp; <span class="steelblue">d</span>.<span class="olive">longitude</span>) {
➌             <span class="steelblue">d</span>.<span class="olive">latitude</span> = +<span class="steelblue">d</span>.<span class="olive">latitude</span>;
➍             <span class="steelblue">d</span>.<span class="olive">longitude</span> = +<span class="steelblue">d</span>.<span class="olive">longitude</span>;
➎             <span class="steelblue">d</span>.<span class="olive">f_scale</span> = +<span class="steelblue">d</span>.<span class="olive">f_scale</span>[<span class="red">2</span>];
➏             <span class="steelblue">d</span>.<span class="olive">position</span> = <span class="olive">projection</span>([
➐                 <span class="steelblue">d</span>.<span class="olive">longitude</span>, <span class="steelblue">d</span>.<span class="olive">latitude</span>
               ]);
➑             <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue"><span class="strong"><strong>true</strong></span></span>;
           }
       });
       <span class="indianred"><span class="emphasis"><em>// Continue creating the visualization...</em></span></span>
   });</pre><p>Once the browser has retrieved the CSV file from the server, we can begin processing it at ➊. Here we’re using the <code class="literal">.filter()</code> method of arrays to iterate through the data values. The <code class="literal">.filter()</code> method eliminates the data points without latitude and longitude values. It only returns <code class="literal">true</code> at ➑ if both values are present ➋. While we’re checking the data points for latitude and longitude, we convert the string values into numbers at ➌ and ➍, extract the number from the Enhanced Fujita Scale classification at ➎, and calculate the position of the sighting in SVG coordinates at ➏ and ➐ using the projection function we created in Step 3.</p></div><div class="sect2" title="Step 8: Plot the Data"><div class="titlepage"><div><div><h3 class="title" id="step_8_plot_the_data">Step 8: Plot the Data</h3></div></div></div><p>With the data retrieved, cleaned, and converted, it’s a simple matter to plot the points on the map. Once again we’ll use the traditional D3.js approach.</p><a id="pro_id00403"/><pre class="programlisting">   <span class="steelblue">g</span>.<span class="olive">selectAll</span>(<span class="maroon">"circle"</span>)
       .<span class="olive">data</span>(data)
     .<span class="olive">enter</span>().<span class="olive">append</span>(<span class="maroon">"circle"</span>)
       .<span class="olive">attr</span>(<span class="maroon">"cx"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) { <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">d</span>.<span class="olive">position</span>[<span class="red">0</span>]; })
       .<span class="olive">attr</span>(<span class="maroon">"cy"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) { <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">d</span>.<span class="olive">position</span>[<span class="red">1</span>]; })
➊     .<span class="olive">attr</span>(<span class="maroon">"r"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) { <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="red">4</span> + <span class="red">2</span>*<span class="steelblue">d</span>.<span class="olive">f_scale</span>; });</pre><p>Each data point is an SVG <code class="literal">&lt;circle&gt;</code> element, so we select those elements, bind the data to the selection, and use the <code class="literal">.enter()</code> function to create new <code class="literal">&lt;circle&gt;</code> elements to match the data.</p><p><a id="iddle1834" class="indexterm"/>As you can see, we set the position of the circles using the <code class="literal">position</code> property we created in the previous step. Also, to indicate the relative strength of each tornado, we make the size of the circle proportional to the Enhanced Fujita Scale classification at ➊. The result in <a class="xref" href="ch07.html#adding_points_to_a_map_is_easy_with_d3do" title="Figure 7-10. Adding points to a map is easy with D3.js projections.">Figure 7-10</a> is a nice map of 2013 tornado sightings in the continental United States.</p><div class="figure"><a id="adding_points_to_a_map_is_easy_with_d3do"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00107"/><img src="figs/web/07fig10.png.jpg" alt="Adding points to a map is easy with D3.js projections."/></div></div><div class="figure-title">Figure 7-10. Adding points to a map is easy with D3.js projections.</div></div></div><div class="sect2" title="Step 9: Add Interactivity"><div class="titlepage"><div><div><h3 class="title" id="step_9_add_interactivity">Step 9: Add Interactivity</h3></div></div></div><p>Maps naturally invite users to zoom in and pan around, and D3.js makes it easy to support those standard map interactions. In fact, D3.js gives us complete control, so we’re not limited to standard map interaction conventions. Let’s do something a little different with our map. We can make it so that a user can click any state to zoom in on it. Clicking a state that’s already zoomed in on will then zoom the map back out to its default. As you’ll see, this behavior is easy to implement with D3.js.</p><p>The first bit of code we’ll add is a variable that keeps track of the particular state into which the map is zoomed. Initially, the user won’t have zoomed anywhere, so that variable is empty.</p><a id="pro_id00404"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> active = <span class="steelblue">d3</span>.<span class="olive">select</span>(<span class="steelblue"><span class="strong"><strong>null</strong></span></span>)</pre><p>Next we add an event handler to all of the state <code class="literal">&lt;path&gt;</code> elements. We can do that when we create the elements (which we did earlier in Step 6).</p><a id="pro_id00405"/><pre class="programlisting">   <span class="steelblue">g</span>.<span class="olive">selectAll</span>(<span class="maroon">"path"</span>)
       .<span class="olive">data</span>(<span class="steelblue">map</span>.<span class="olive">features</span>)
     .<span class="olive">enter</span>().<span class="olive">append</span>(<span class="maroon">"path"</span>)
       .<span class="olive">attr</span>(<span class="maroon">"d"</span>, path)
➊     .<span class="olive">on</span>(<span class="maroon">"click"</span>, clicked);</pre><p>The extra statement is at ➊. Like jQuery, D3.js gives us an easy way to add event handlers to HTML and SVG elements. Now we have to write that event handler.</p><p>The handler needs to identify the state that the user clicked, calculate the position of that state (in SVG coordinates), and transition the map to zoom to those coordinates. Before we look at the implementation in detail, it’s worth noting that D3.js event handlers are optimized to work with data visualizations (which shouldn’t be surprising). In particular, the parameter passed to the handler is the data item associated with the target element (conventionally named <code class="literal">d</code>). The JavaScript context (<code class="literal">this</code>) is set to the specific element that received the event. If the handler needs access to the other properties of the JavaScript event, they’re available in the <code class="literal">d3.event</code> global variable. Here’s how those conventions work in a real event handler:</p><a id="pro_id00406"/><pre class="programlisting">   <span class="steelblue"><span class="strong"><strong>var</strong></span></span> clicked = <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) {
➊     <span class="steelblue">active</span>.<span class="olive">attr</span>(<span class="maroon">"fill"</span>, <span class="maroon">"#cccccc"</span>);
       active = <span class="steelblue">d3</span>.<span class="olive">select</span>(<span class="steelblue"><span class="strong"><strong>this</strong></span></span>)
           .<span class="olive">attr</span>(<span class="maroon">"fill"</span>, <span class="maroon">"#F77B15"</span>);

➋     <span class="steelblue"><span class="strong"><strong>var</strong></span></span> bounds = <span class="steelblue">path</span>.<span class="olive">bounds</span>(d),
           dx = bounds[<span class="red">1</span>][<span class="red">0</span>] - bounds[<span class="red">0</span>][<span class="red">0</span>],
           dy = bounds[<span class="red">1</span>][<span class="red">1</span>] - bounds[<span class="red">0</span>][<span class="red">1</span>],
           x = (bounds[<span class="red">0</span>][<span class="red">0</span>] + bounds[<span class="red">1</span>][<span class="red">0</span>]) / <span class="red">2</span>,
           y = (bounds[<span class="red">0</span>][<span class="red">1</span>] + bounds[<span class="red">1</span>][<span class="red">1</span>]) / <span class="red">2</span>,
➌         scale = <span class="red">.9</span> / <span class="steelblue">Math</span>.<span class="olive">max</span>(dx / width, dy / height),
➍         translate = [
               width / <span class="red">2</span> - scale * x,
               height / <span class="red">2</span> - scale * y];

➎     <span class="steelblue">g</span>.<span class="olive">transition</span>()
           .<span class="olive">duration</span>(<span class="red">750</span>)
           .<span class="olive">attr</span>(<span class="maroon">"transform"</span>, <span class="maroon">"translate("</span> +
               translate + <span class="maroon">")scale("</span> +
               scale + <span class="maroon">")"</span>);
   };</pre><p>In the first code block (starting at ➊), we manipulate the map colors. The previously zoomed state is reset to a muted gray, and the clicked state is filled with a vibrant orange. Notice that this same code resets the <code class="literal">active</code> variable so that it accurately tracks the zoomed state. Next, starting at ➋, we calculate the bounds of the zoomed state. Or rather, we let D3.js do the calculation. All the work happens <a id="iddle1206" class="indexterm"/>in the <code class="literal">bounds()</code> function we call at ➋. The other lines are mostly just extracting the individual parts of that calculation. At ➌, we calculate how to scale the map so that the zoomed state fills 90 percent of the map. Then, starting at ➍, we calculate how to shift the map to center that state. The final block of code, starting at ➎, adjusts the map by scaling and translating the SVG. As you can see, we’re using a D3.js transition to animate the change in view.</p><p>The code we’ve seen so far still needs a few minor additions to deal with some loose ends, but I’ll leave those to the book’s source code (<span class="emphasis"><em><a class="ulink" href="http://jsDataV.is/source/" target="_top">http://jsDataV.is/source/</a></em></span>). The result in <a class="xref" href="ch07.html#d3dotjs_makes_it_easy_to_add_custom_inte" title="Figure 7-11. D3.js makes it easy to add custom interactions to maps.">Figure 7-11</a> is a nice interactive map of our data.</p><div class="figure"><a id="d3dotjs_makes_it_easy_to_add_custom_inte"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00108"/><img src="figs/web/07fig11.png.jpg" alt="D3.js makes it easy to add custom interactions to maps."/></div></div><div class="figure-title">Figure 7-11. D3.js makes it easy to add custom interactions to maps.</div></div></div></div><div class="sect1" title="Creating a Unique Visualization"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="creating_a_unique_visualization">Creating a Unique Visualization</h2></div></div></div><p>If you’ve followed the first three examples in this chapter, you’re probably beginning to appreciate the level of flexibility D3.js offers compared to traditional JavaScript libraries. Instead of creating visualizations for you, it provides many tools and utilities that you can use however you wish. We’ve used that flexibility to add unconventional error bars to a chart, to refine the behavior of a network graph, and to customize user interactions with a map. With D3.js, however, we aren’t limited to minor adjustments to existing visualization types. Instead, we can use the library to create unique visualizations that are nothing like those found in traditional libraries.</p><p>In this example, we’ll use the same data from the previous visualization—tornado sightings in 2013 from the US National Oceanic and Atmospheric Administration’s Climate Data Online site (<span class="emphasis"><em><a class="ulink" href="http://www.noaa.gov/cdo-web/" target="_top">http://www.noaa.gov/cdo-web/</a></em></span>). Rather than placing the sightings on a map, however, we’ll create an interactive, hierarchical visualization that lets users understand the number of sightings by region, state, <a id="iddle1093" class="indexterm"/><a id="iddle1204" class="indexterm"/><a id="iddle1207" class="indexterm"/><a id="iddle1209" class="indexterm"/><a id="iddle1412" class="indexterm"/><a id="iddle1437" class="indexterm"/>or even counties within a state. A circular hierarchy can be especially effective for this subject matter, so we’ll create a sunburst visualization with rotational animations. The code that follows is based on an example (<span class="emphasis"><em><a class="ulink" href="http://bl.ocks.org/mbostock/4348373/" target="_top">http://bl.ocks.org/mbostock/4348373/</a></em></span>) developed by Mike Bostock, the lead D3.js developer.</p><div class="note" title="Note"><h3 class="title"><a id="ch07note02"/>Note</h3><p><span class="strong"><strong>It is also possible to create sunburst visualizations using some charting libraries, generally by customizing a variation of the pie chart. Those libraries, however, are much more focused on off-the-shelf use. Creating custom visualizations is generally much easier with a library like D3.js, which is designed especially for customization.</strong></span></p></div><div class="sect2" title="Step 1: Prepare the Data"><div class="titlepage"><div><div><h3 class="title" id="step_1_prepare_the_data-id00037">Step 1: Prepare the Data</h3></div></div></div><p>As before, we’ll clean and prune the 2013 tornado sightings data set. Instead of longitude, latitude, and Enhanced Fujita Scale classification, however, we’ll keep the state and county. We’ll also add a region name as a way to group subsets of states. The resulting CSV file begins as follows.</p><a id="pro_id00407"/><pre class="programlisting">state,region,county
Connecticut,New England,Fairfield County
Connecticut,New England,Hartford County
Connecticut,New England,Hartford County
Connecticut,New England,Tolland County
Maine,New England,Somerset County
Maine,New England,Washington County
Maine,New England,Piscataquis County
--<span class="emphasis"><em>snip</em></span>--</pre></div><div class="sect2" title="Step 2: Set Up the Page"><div class="titlepage"><div><div><h3 class="title" id="step_2_set_up_the_page-id00038">Step 2: Set Up the Page</h3></div></div></div><p>Our skeletal web page is no different from the other D3.js examples. We set aside a container for the visualization and include the D3.js library.</p><a id="pro_id00408"/><pre class="programlisting"><span class="dodgerblue">&lt;!DOCTYPE</span> html<span class="dodgerblue">&gt;</span>
<span class="steelblue"><span class="strong"><strong>&lt;html</strong></span></span> <span class="steelblue">lang=</span><span class="maroon">"en"</span><span class="steelblue"><span class="strong"><strong>&gt;</strong></span></span>
  <span class="steelblue"><span class="strong"><strong>&lt;head&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;meta</strong></span></span> <span class="steelblue">charset=</span><span class="maroon">"utf-8"</span><span class="steelblue"><span class="strong"><strong>&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;title&gt;&lt;/title&gt;</strong></span></span>
  <span class="steelblue"><span class="strong"><strong>&lt;/head&gt;</strong></span></span>
  <span class="steelblue"><span class="strong"><strong>&lt;body&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;div</strong></span></span> <span class="steelblue">id=</span><span class="maroon">"chart"</span><span class="steelblue"><span class="strong"><strong>&gt;&lt;/div&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;script</strong></span></span>
      <span class="steelblue">src=</span><span class="maroon">"//cdnjs.cloudflare.com/ajax/libs/d3/3.4.6/d3.min.js"</span><span class="steelblue"><span class="strong"><strong>&gt;</strong></span></span>
    <span class="steelblue"><span class="strong"><strong>&lt;/script&gt;</strong></span></span>
  <span class="steelblue"><span class="strong"><strong>&lt;/body&gt;</strong></span></span>
<span class="steelblue"><span class="strong"><strong>&lt;/html&gt;</strong></span></span></pre></div><div class="sect2" title="Step 3: Create a Stage for the Visualization"><div class="titlepage"><div><div><h3 class="title" id="step_3_create_a_stage_for_the_vi-id00039">Step 3: Create a Stage for the Visualization</h3></div></div></div><p><a id="iddle1203" class="indexterm"/><a id="iddle1851" class="indexterm"/>As with our other D3.js examples, we start by creating an <code class="literal">&lt;svg&gt;</code> container for the visualization. Within that container, we’ll also add a group (<code class="literal">&lt;g&gt;</code>) element.</p><a id="pro_id00409"/><pre class="programlisting">   <span class="steelblue"><span class="strong"><strong>var</strong></span></span> width = <span class="red">640</span>,
       height = <span class="red">400</span>,
➊     maxRadius = <span class="steelblue">Math</span>.<span class="olive">min</span>(width, height) / <span class="red">2</span>;

   <span class="steelblue"><span class="strong"><strong>var</strong></span></span> svg = <span class="steelblue">d3</span>.<span class="olive">select</span>(<span class="maroon">"#chart"</span>).<span class="olive">append</span>(<span class="maroon">"svg"</span>)
       .<span class="olive">attr</span>(<span class="maroon">"width"</span>, width)
       .<span class="olive">attr</span>(<span class="maroon">"height"</span>, height);

   <span class="steelblue"><span class="strong"><strong>var</strong></span></span> g = <span class="steelblue">svg</span>.<span class="olive">append</span>("g");
➋     .<span class="olive">attr</span>(<span class="maroon">"transform"</span>, <span class="maroon">"translate("</span> +
           (width / <span class="red">2</span>) + <span class="maroon">","</span> +
           (height / <span class="red">2</span>) + <span class="maroon">")"</span>);</pre><p>This code contains a couple of new wrinkles. First, at ➊, we calculate the maximum radius for the visualization. This value—which is half of the height or the width, whichever is smaller—will come in handy in the code that follows. More interestingly, starting at ➋, we translate the inner <code class="literal">&lt;g&gt;</code> container so that its coordinate system places the point (0,0) right in the center of the visualization. This translation makes it easy to center the sunburst and calculate sunburst parameters.</p></div><div class="sect2" title="Step 4: Create Scales"><div class="titlepage"><div><div><h3 class="title" id="step_4_create_scales">Step 4: Create Scales</h3></div></div></div><p>When it’s complete, our visualization will consist of areas corresponding to regions in the United States; larger areas will represent regions with more tornadoes. Because we’re dealing with areas, we’ll need two dimensions for each region. But we’re not going to draw our areas as simple rectangles; instead we’re going to use arcs. That will require a bit of trigonometry, but fortunately, D3.js provides a lot of help. We’ll start by defining some <code class="literal">scale</code> objects. We first saw scales in Step 4 of <a class="xref" href="ch07.html#adapting_a_traditional_chart_type" title="Adapting a Traditional Chart Type">Adapting a Traditional Chart Type</a>, where we used them to translate data values to SVG coordinates. The scales in the following code do much the same, except they’re using polar coordinates.</p><a id="pro_id00410"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> theta = <span class="steelblue">d3</span>.<span class="steelblue">scale</span>.<span class="olive">linear</span>()
    .<span class="olive">range</span>([<span class="red">0</span>, <span class="red">2</span> * <span class="steelblue">Math</span>.<span class="olive">PI</span>]);
<span class="steelblue"><span class="strong"><strong>var</strong></span></span> radius= <span class="steelblue">d3</span>.<span class="steelblue">scale</span>.<span class="olive">sqrt</span>()
    .<span class="olive">range</span>([<span class="red">0</span>, maxRadius]);</pre><p>As you can see, the angular scale is a linear scale that ranges from 0 to 2π (or 360°). The radial scale ranges from 0 to the maximum radius, but it’s not linear. Instead, this scale is a square root scale; D3.js takes the square root of the input before computing the output. The area of an arc varies as the square of its radius, and the square root scale compensates for this effect.</p><div class="note" title="Note"><h3 class="title"><a id="ch07note03"/>Note</h3><p><a id="iddle1045" class="indexterm"/><a id="iddle1215" class="indexterm"/><span class="strong"><strong>In prior examples, we’ve set both ranges (outputs) and domains (inputs) for our scales. In this case, however, we won’t need to set domains explicitly. The default domain of [0,1] is exactly what we need for both scales.</strong></span></p></div><p>The scales we’ve defined come in handy in the next bit of code, where we define a function that calculates the SVG path for a single arc. Most of the work takes place in the D3.js function <code class="literal">d3.svg.arc()</code>, which computes an arc’s path. That function, though, needs four parameters: the starting and ending angles and the starting and ending radii for the arc. The values for those parameters come from our scales.</p><p>When we use our <code class="literal">arc()</code> function later in the code, we’re going to call it with a D3.js selection. That selection will have a data value associated with it, and the data value will include four properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none"><p><span class="strong"><strong><code class="literal">.x</code></strong></span> the starting x–position for the data</p></li><li class="listitem" style="list-style-type: none"><p><span class="strong"><strong><code class="literal">.dx</code></strong></span> the data’s length along the x–axis (Δ<span class="emphasis"><em>x</em></span>)</p></li><li class="listitem" style="list-style-type: none"><p><span class="strong"><strong><code class="literal">.y</code></strong></span> the starting y–position for the data</p></li><li class="listitem" style="list-style-type: none"><p><span class="strong"><strong><code class="literal">.dx</code></strong></span> the data’s length along the y–axis (Δ<span class="emphasis"><em>y</em></span>)</p></li></ul></div><p>Given those properties, here’s the code that generates the arc path.</p><a id="pro_id00411"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> arc = <span class="steelblue">d3</span>.<span class="steelblue">svg</span>.<span class="olive">arc</span>()
    .<span class="olive">startAngle</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) {
        <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">Math</span>.<span class="olive">max</span>(<span class="red">0</span>, <span class="steelblue">Math</span>.<span class="olive">min</span>(<span class="red">2</span> * <span class="steelblue">Math</span>.<span class="olive">PI</span>, <span class="olive">theta</span>(<span class="steelblue">d</span>.<span class="olive">x</span>)));
    })
    .<span class="olive">endAngle</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) {
        <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">Math</span>.<span class="olive">max</span>(<span class="red">0</span>, <span class="steelblue">Math</span>.<span class="olive">min</span>(<span class="red">2</span> * <span class="steelblue">Math</span>.<span class="olive">PI</span>, <span class="olive">theta</span>(<span class="steelblue">d</span>.<span class="olive">x</span> + <span class="steelblue">d</span>.<span class="olive">dx</span>)));
    })
    .<span class="olive">innerRadius</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) {
        <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">Math</span>.<span class="olive">max</span>(<span class="red">0</span>, <span class="olive">radius</span>(<span class="steelblue">d</span>.<span class="olive">y</span>));
    })
    .<span class="olive">outerRadius</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) {
        <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">Math</span>.<span class="olive">max</span>(<span class="red">0</span>, <span class="olive">radius</span>(<span class="steelblue">d</span>.<span class="olive">y</span> + <span class="steelblue">d</span>.<span class="olive">dy</span>));
    });</pre><p>The code itself is pretty straightforward, but a picture helps explain why we’re using the code this way. Assume that the data associated with a selection has an (<span class="emphasis"><em>x</em></span>,<span class="emphasis"><em>y</em></span>) position of (12.5,10), a width of 25, and a height of 30. The data properties would then be:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">.x = 12.5</code></p></li><li class="listitem"><p><code class="literal">.dx = 25</code></p></li><li class="listitem"><p><code class="literal">.y = 10</code></p></li><li class="listitem"><p><code class="literal">.dy = 30</code></p></li></ul></div><p><a id="iddle1182" class="indexterm"/><a id="iddle1208" class="indexterm"/>With Cartesian coordinates, we could draw the selection as on the left side of <a class="xref" href="ch07.html#d3dotjs_helps_transform_a_rectangular_ar" title="Figure 7-12. D3.js helps transform a rectangular area into an arc.">Figure 7-12</a>. Our scales and arc function will transform the rectangle to the arc shown on the right side of the figure.</p><div class="figure"><a id="d3dotjs_helps_transform_a_rectangular_ar"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00109"/><img src="figs/web/07fig12.png.jpg" alt="D3.js helps transform a rectangular area into an arc."/></div></div><div class="figure-title">Figure 7-12. D3.js helps transform a rectangular area into an arc.</div></div><p>We haven’t specified the ranges of the x- and y-scales, but assume for now that each ranges from 0 to 100. The starting x-value of 12.5, therefore, is 12.5 percent of the full range. When we convert that value to polar coordinates, the result will be 12.5 percent of the full 360°. That’s 45°, or π/4. The x-value extends another 25 percent, so the final x-value adds another 90°, or π/2, to the starting value. For the y-values, our scales take the square root and map the results to the domain from 0 to 250 (<code class="literal">maxRadius</code>). The initial value of 10, therefore, is divided by 100 (for the range) and transformed to <span class="inlinemediaobject"><a id="inline_id00005"/><img src="figs/web/256equ01.png.jpg" alt=""/></span>, or 79. The final value of 10 + 30 results in a radius of <span class="inlinemediaobject"><a id="inline_id00006"/><img src="figs/web/256equ02.png.jpg" alt=""/></span>, or 158. That’s the process that creates an SVG for each data value.</p></div><div class="sect2" title="Step 5: Retrieve the Data"><div class="titlepage"><div><div><h3 class="title" id="step_5_retrieve_the_data">Step 5: Retrieve the Data</h3></div></div></div><p>With the initial preparation complete, we’re now ready to process the data. As in the previous example, we’ll use <code class="literal">d3.csv()</code> to retrieve the CSV file from the server.</p><a id="pro_id00412"/><pre class="programlisting"><span class="steelblue">d3</span>.<span class="olive">csv</span>(<span class="maroon">"tornadoes.csv"</span>, <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(data) {
    <span class="indianred"><span class="emphasis"><em>// Continue processing the data...</em></span></span>
});</pre><p>When D3.js retrieves the file, it creates a data structure that begins like the following fragment.</p><a id="pro_id00413"/><pre class="programlisting">[ {
    <span class="maroon">"state"</span>:<span class="maroon">"Connecticut"</span>,
    <span class="maroon">"region"</span>:<span class="maroon">"New England"</span>,
    <span class="maroon">"county"</span>:<span class="maroon">"Fairfield County"</span>
  },{
    <span class="maroon">"state"</span>:<span class="maroon">"Connecticut"</span>,
    <span class="maroon">"region"</span>:<span class="maroon">"New England"</span>,
    <span class="maroon">"county"</span>:<span class="maroon">"Hartford County"</span>
  },{
    <span class="maroon">"state"</span>:<span class="maroon">"Connecticut"</span>,
    <span class="maroon">"region"</span>:<span class="maroon">"New England"</span>,
    <span class="maroon">"county"</span>:<span class="maroon">"Hartford County"</span>
  },
<span class="indianred"><span class="emphasis"><em>// Data set continues...</em></span></span></pre><p><a id="iddle1213" class="indexterm"/><a id="iddle1296" class="indexterm"/><a id="iddle1297" class="indexterm"/><a id="iddle1438" class="indexterm"/><a id="iddle1552" class="indexterm"/><a id="iddle2175" class="indexterm"/><a id="iddle2179" class="indexterm"/>That data structure reflects the data, but it doesn’t include the <code class="literal">.x</code>, <code class="literal">.dx</code>, <code class="literal">.y</code>, and <code class="literal">.dy</code> properties that we need to draw the arcs. There’s additional work to be done to calculate those values. If you recall the second example in this chapter, we’ve seen this situation before. We have a set of raw data, but we need to augment that raw data with additional properties for the visualization. In the earlier example, we used the D3.js force layout to calculate the extra properties. In this case, we can use the partition layout.</p><p>Before we can use the partition layout, however, we have to restructure our data. The partition layout works with hierarchical data, and right now all we have is a single dimensional array. We must structure the data to reflect the natural hierarchy of region, state, and county. Here again, however, D3.js can help us. The <code class="literal">d3.nest()</code> operator analyzes an array of data and extracts the hierarchy from it. If you’re familiar with database commands, it’s the D3.js equivalent of the <code class="literal">GROUP BY</code> operation. We can use the operator to create a new version of the data.</p><a id="pro_id00414"/><pre class="programlisting">➊ <span class="steelblue"><span class="strong"><strong>var</strong></span></span> hierarchy = {
       <span class="dodgerblue">key</span>: <span class="maroon">"United States"</span>,
       <span class="dodgerblue">values</span>: <span class="steelblue">d3</span>.<span class="olive">nest</span>()
➋         .<span class="olive">key</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) { <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">d</span>.<span class="olive">region</span>; })
           .<span class="olive">key</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) { <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">d</span>.<span class="olive">state</span>; })
           .<span class="olive">key</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) { <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">d</span>.<span class="olive">county</span>; })
➌         .<span class="olive">rollup</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(leaves) {
➍             <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">leaves</span>.<span class="olive">length</span>;
           })
➎         .<span class="olive">entries</span>(data)
       };</pre><p>First, at ➊, we define the variable that will hold our restructured data. It’s an object with two properties. The <code class="literal">.key</code> property is set to <code class="literal">"United States"</code>, and the <code class="literal">.values</code> property is the result of the <code class="literal">d3.nest()</code> operation. Starting at ➋, we tell the operator to group the data, first by <code class="literal">.region</code>, then by <code class="literal">.state</code>, and finally by <code class="literal">.county</code>. Then, at ➌ and ➍, we tell the operator to set the final value to be the count of <a id="iddle1205" class="indexterm"/><a id="iddle1214" class="indexterm"/><a id="iddle1455" class="indexterm"/><a id="iddle2116" class="indexterm"/>entries for the final grouping. Finally, at ➎, we pass the original data set to the operator. When this statement finishes, the <code class="literal">hierarchy</code> variable contains a structured version of our data that begins like the following fragment:</p><a id="pro_id00415"/><pre class="programlisting">{
    <span class="maroon">"key"</span>: <span class="maroon">"United States"</span>,
    <span class="maroon">"values"</span>: [
        {
            <span class="maroon">"key"</span>: <span class="maroon">"New England"</span>,
            <span class="maroon">"values"</span>: [
                {
                    <span class="maroon">"key"</span>: <span class="maroon">"Connecticut"</span>,
                    <span class="maroon">"values"</span>: [
                        {
                            <span class="maroon">"key"</span>: <span class="maroon">"Fairfield County"</span>,
                            <span class="maroon">"values"</span>: <span class="red">1</span>
                        },{
                            <span class="maroon">"key"</span>: <span class="maroon">"Hartford County"</span>,
                            <span class="maroon">"values"</span>: <span class="red">2</span>
                        },{
<span class="indianred"><span class="emphasis"><em>// Data set continues...</em></span></span></pre><p>This structure matches what the partition layout needs, but there’s still one more step we need to take. The <code class="literal">d3.nest()</code> operator places both child arrays and leaf data in the <code class="literal">.values</code> property. By default, however, the partition layout expects the data to use different property names for each type of property. More specifically, it expects child nodes to be stored in the <code class="literal">.children</code> property and data values in the <code class="literal">.value</code> property. Since the <code class="literal">d3.nest()</code> operator doesn’t create exactly that structure, we have to extend the default partition layout. Here’s the code to do that:</p><a id="pro_id00416"/><pre class="programlisting">   <span class="steelblue"><span class="strong"><strong>var</strong></span></span> partition = <span class="steelblue">d3</span>.<span class="steelblue">layout</span>.<span class="olive">partition</span>()
➊     .<span class="olive">children</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) {
➋         <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">Array</span>.<span class="olive">isArray</span>(<span class="steelblue">d</span>.<span class="olive">values</span>) ? <span class="steelblue">d</span>.<span class="olive">values</span> : <span class="steelblue"><span class="strong"><strong>null</strong></span></span>;
       })
➌     .<span class="olive">value</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) {
➍         <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">d</span>.<span class="olive">values</span>;
       });</pre><p>At ➊ and ➋, we provide a custom function to return a node’s children. If the node’s <code class="literal">.values</code> property is an array, then that property contains the children. Otherwise, the node has no children and we return <code class="literal">null</code>. Then at ➌ and ➍, we provide a custom function to return a node’s value. Since this function is used only when no children exist, the <code class="literal">.values</code> property has to contain the node value.</p></div><div class="sect2" title="Step 6: Draw the Visualization"><div class="titlepage"><div><div><h3 class="title" id="step_6_draw_the_visualization">Step 6: Draw the Visualization</h3></div></div></div><p>It’s taken a bit of work to get to this point, but now we’re ready to draw the visualization. Here’s where we see the payoff for all the work. It takes only a few lines of code to create the visualization.</p><a id="pro_id00417"/><pre class="programlisting">➊  <span class="steelblue"><span class="strong"><strong>var</strong></span></span> path = <span class="steelblue">g</span>.<span class="olive">selectAll</span>(<span class="maroon">"path"</span>)
       .<span class="olive">data</span>(<span class="steelblue">partition</span>.<span class="olive">nodes</span>(hierarchy))
➋     .<span class="olive">enter</span>().<span class="olive">append</span>(<span class="maroon">"path"</span>)
➌       .<span class="olive">attr</span>(<span class="maroon">"d"</span>, arc);</pre><p><a id="iddle1046" class="indexterm"/><a id="iddle1202" class="indexterm"/><a id="iddle1745" class="indexterm"/>This code follows the same structure we’ve used for all of our D3.js examples. At ➊, we create a selection of the SVG elements that represent our data; in this case we’re using <code class="literal">&lt;path&gt;</code> elements. We then bind the selection to the hierarchical data using the custom partition layout. At ➋, we identify the data values that don’t (yet) have an associated SVG element, and at ➌ we create new elements for those values. That final step relies on the <code class="literal">.arc()</code> function that we created in Step 4. We haven’t yet added any colors or labels, but we can see from <a class="xref" href="ch07.html#d3dotjs_handles_the_math_required_to_cre" title="Figure 7-13. D3.js handles the math required to create a sunburst diagram.">Figure 7-13</a> that we’re on the right track.</p><div class="figure"><a id="d3dotjs_handles_the_math_required_to_cre"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00110"/><img src="figs/web/07fig13.png.jpg" alt="D3.js handles the math required to create a sunburst diagram."/></div></div><div class="figure-title">Figure 7-13. D3.js handles the math required to create a sunburst diagram.</div></div></div><div class="sect2" title="Step 7: Color the Areas"><div class="titlepage"><div><div><h3 class="title" id="step_7_color_the_areas">Step 7: Color the Areas</h3></div></div></div><p>Now we can turn our attention to coloring the visualization. We want to give each region a unique, dominant color and then shade that color for states and counties within the region. A good starting point for us is a different type of D3.js scale, a categorical scale for colors. All of the scales we’ve seen so far are cardinal scales; they map numerical values to properties for the visualization. Categorical scales <a id="iddle1154" class="indexterm"/>work with data values that are not numerical; rather, the values simply represent different categories of some quantity. In our case, the regions represent categorical data. After all, there isn’t anything intrinsically numerical about New England or the Southwest.</p><p>As the name suggests, a categorical <span class="emphasis"><em>color</em></span> scale maps different category values to different colors. D3.js includes several of these predefined color scales. Since we have fewer than 10 regions in our data, the <code class="literal">d3.scale.category10()</code> scale works fine for this example. <a class="xref" href="ch07.html#d3dotjs_includes_color_scales_for_catego" title="Figure 7-14. D3.js includes color scales for categorical data.">Figure 7-14</a> shows the colors in this scale.</p><div class="figure"><a id="d3dotjs_includes_color_scales_for_catego"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00111"/><img src="figs/web/07fig14.png" alt="D3.js includes color scales for categorical data."/></div></div><div class="figure-title">Figure 7-14. D3.js includes color scales for categorical data.</div></div><p>Our next task is assigning colors from this scale to the arcs in our visualization. To do that, we’ll define our own <code class="literal">color()</code> function. That function will accept a data node from the partition layout as input.</p><a id="pro_id00418"/><pre class="programlisting">➊ <span class="steelblue"><span class="strong"><strong>var</strong></span></span> color = <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) {
       <span class="steelblue"><span class="strong"><strong>var</strong></span></span> colors;
       <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (!<span class="steelblue">d</span>.<span class="olive">parent</span>) {
➋         colors = <span class="steelblue">d3</span>.<span class="steelblue">scale</span>.<span class="olive">category10</span>();
➌         <span class="steelblue">d</span>.<span class="olive">color</span> = <span class="maroon">"#fff"</span>;
       }

       <span class="indianred"><span class="emphasis"><em>// More code needed...</em></span></span></pre><p>First, at ➊, we create a local variable that we’ll use to store colors. We then check to see if the input node is the root of the hierarchy. If it is, we then create a color scale at ➋ for the node’s children and assign the node its own color at ➌. The root node in our visualization, which represents the entire United States, will be white. That assigned color will eventually be returned by the function.</p><p>After we create a color scale for the child nodes, we want to distribute the individual colors to those nodes. There’s a slight catch, though. The nodes in the <code class="literal">d.children</code> array aren’t necessarily distributed in the clockwise order we want for our visualization. To make sure the colors from our scale are distributed in order, we’ll have to sort the <code class="literal">d.children</code> array first. Here’s the complete code for this step.</p><a id="pro_id00419"/><pre class="programlisting">   <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (<span class="steelblue">d</span>.<span class="olive">children</span>) {
➊     <span class="steelblue">d</span>.<span class="steelblue">children</span>.<span class="olive">map</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(child, i) {
           <span class="steelblue"><span class="strong"><strong>return</strong></span></span> {<span class="dodgerblue">value</span>: <span class="steelblue">child</span>.<span class="olive">value</span>, <span class="dodgerblue">idx</span>: i};
➋     }).<span class="olive">sort</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(a,b) {
             <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue">b</span>.<span class="olive">value</span> - <span class="steelblue">a</span>.<span class="olive">value</span>
➌     }).<span class="olive">forEach</span>(<span class="steelblue"><span class="strong"><strong>function</strong></span></span>(child, i) {
           <span class="steelblue">d</span>.<span class="olive">children</span>[<span class="steelblue">child</span>.<span class="olive">idx</span>].<span class="olive">color</span> = <span class="olive">colors</span>(i);
       });
   }</pre><p>In the first line, we make sure that there is a children array. If there is, we create a copy of the children array that contains just the node values and their original array index at ➊. Then, at ➋, we sort that copy based on the node values. Finally, at ➌, we iterate through the sorted array and assign colors to the child nodes.</p><p>So far we’ve created a categorical color scale and assigned its colors to the first-level children. That takes care of colors for the regions, but there are also states and counties that need colors. For those, we can create a different scale based on the parent color. Let’s go back to our function definition and add an <code class="literal">else</code> clause for non-root nodes. In this clause, we also create a color scale for the children. These child nodes, however, are not regions; they are states or counties. For states of a region and counties of a state, we don’t want unique, distinct colors like those from a categorical scale. Instead, we want colors related to the color of the parent. That calls for a linear gradient.</p><a id="pro_id00420"/><pre class="programlisting">   <span class="steelblue"><span class="strong"><strong>var</strong></span></span> color = <span class="steelblue"><span class="strong"><strong>function</strong></span></span>(d) {
       <span class="steelblue"><span class="strong"><strong>var</strong></span></span> colors;
       <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (!<span class="steelblue">d</span>.<span class="olive">parent</span>) {
           <span class="indianred"><span class="emphasis"><em>// Handle root node as above...</em></span></span>
       } <span class="steelblue"><span class="strong"><strong>else</strong></span></span> <span class="steelblue"><span class="strong"><strong>if</strong></span></span> (<span class="steelblue">d</span>.<span class="olive">children</span>) {

➊         <span class="steelblue"><span class="strong"><strong>var</strong></span></span> startColor = <span class="steelblue">d3</span>.<span class="olive">hcl</span>(<span class="steelblue">d</span>.<span class="olive">color</span>)
                               .<span class="olive">darker</span>(),
               endColor = <span class="steelblue">d3</span>.<span class="olive">hcl</span>(<span class="steelblue">d</span>.<span class="olive">color</span>)
                               .<span class="olive">brighter</span>();

➋         colors = <span class="steelblue">d3</span>.<span class="steelblue">scale</span>.<span class="olive">linear</span>()
➌                 .<span class="olive">interpolate</span>(<span class="steelblue">d3</span>.<span class="olive">interpolateHcl</span>)
➍                 .<span class="olive">range</span>([
                       <span class="steelblue">startColor</span>.<span class="olive">toString</span>(),
                       <span class="steelblue">endColor</span>.<span class="olive">toString</span>()
                   ])
➎                 .<span class="olive">domain</span>([<span class="red">0</span>,<span class="steelblue">d</span>.<span class="steelblue">children</span>.<span class="olive">length</span><span class="red">+1</span>]);
       }

       <span class="indianred"><span class="emphasis"><em>// Code continues...</em></span></span></pre><p>Starting at ➊, we define the starting and ending colors for our gradient. To create those colors, we start with the parent node’s color (<code class="literal">d.color</code>) and darken or brighten it. In both cases we use hue, chroma, and luminance (HCL) as the basis for the color manipulations. The HCL color space is based on human visual perception, unlike the purely mathematical basis for the more familiar RGB color space. Using HCL generally results in a more visually pleasing gradient.</p><p>The code block starting at ➋ actually creates the gradient. We’re using a D3.js linear scale and a built-in interpolation algorithm for HCL colors ➌. Our gradient ranges between the start and end colors ➍, and its domain is the indices of the node’s children ➎.</p><p><a id="iddle1201" class="indexterm"/><a id="iddle1746" class="indexterm"/>Now all we need to do is assign the appropriate color when we create each data value’s <code class="literal">&lt;path&gt;</code> element. That requires a oneline addition, <code class="literal">.attr("fill", color)</code>, to the code that creates those paths.</p><a id="pro_id00421"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>var</strong></span></span> path = <span class="steelblue">g</span>.<span class="olive">selectAll</span>(<span class="maroon">"path"</span>)
    .<span class="olive">data</span>(<span class="steelblue">partition</span>.<span class="olive">nodes</span>(hierarchy))
  .<span class="olive">enter</span>().<span class="olive">append</span>(<span class="maroon">"path"</span>)
    .<span class="olive">attr</span>(<span class="maroon">"d"</span>, arc)
    .<span class="olive">attr</span>(<span class="maroon">"fill"</span>, color);</pre><p>As <a class="xref" href="ch07.html#d3dotjs_provides_tools_to_add_attractive" title="Figure 7-15. D3.js provides tools to add attractive colors to visualizations such as our sunburst.">Figure 7-15</a> shows, our visualization now includes appropriate colors.</p><div class="figure"><a id="d3dotjs_provides_tools_to_add_attractive"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00112"/><img src="figs/web/07fig15.png.jpg" alt="D3.js provides tools to add attractive colors to visualizations such as our sunburst."/></div></div><div class="figure-title">Figure 7-15. D3.js provides tools to add attractive colors to visualizations such as our sunburst.</div></div></div><div class="sect2" title="Step 8: Make the Visualization Interactive"><div class="titlepage"><div><div><h3 class="title" id="step_8_make_the_visualization_interactiv">Step 8: Make the Visualization Interactive</h3></div></div></div><p>To conclude this example, we will add some interactivity. When a user clicks an area in the chart, the chart will zoom in to show more detail for that area. To emphasize the subject matter, we’ll create a custom rotating animation effect for this zoom. The easiest part of this step is adding the function to handle click events. We can do that when we add the <code class="literal">&lt;path&gt;</code> elements to the page.</p><a id="pro_id00422"/><pre class="programlisting">   <span class="steelblue"><span class="strong"><strong>var</strong></span></span> path = <span class="steelblue">g</span>.<span class="olive">selectAll</span>(<span class="maroon">"path"</span>)
       .<span class="olive">data</span>(<span class="steelblue">partition</span>.<span class="olive">nodes</span>(hierarchy))
       .<span class="olive">enter</span>().<span class="olive">append</span>(<span class="maroon">"path"</span>)
         .<span class="olive">attr</span>(<span class="maroon">"d"</span>, arc)
         .<span class="olive">attr</span>(<span class="maroon">"fill"</span>, color)
➊         .<span class="olive">on</span>(<span class="maroon">"click"</span>, handleClick);</pre><p><a id="iddle1056" class="indexterm"/><a id="iddle1110" class="indexterm"/><a id="iddle1443" class="indexterm"/><a id="iddle1524" class="indexterm"/><a id="iddle1525" class="indexterm"/>The <code class="literal">handleClick</code> function at ➊ is the event handler that we’ll have to write. Conceptually, the function is pretty straightforward. When the user clicks an area, we want to modify all the paths to make that area the focal point of the visualization. The complete function is shown in the following code.</p><a id="pro_id00423"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>function</strong></span></span> <span class="olive">handleClick</span>(datum) {
    <span class="steelblue">path</span>.<span class="olive">transition</span>().<span class="olive">duration</span>(<span class="red">750</span>)
        .<span class="olive">attrTween</span>(<span class="maroon">"d"</span>, <span class="olive">arcTween</span>(datum));
};</pre><p>The function’s single parameter is the data value corresponding to the clicked element. Conventionally, D3.js uses <code class="literal">d</code> for that value; in this case, however, we’re using <code class="literal">datum</code> to avoid confusion with the SVG <code class="literal">"d"</code> attribute. The first line in the function references all of the paths in the visualization and sets up an animated transition for those paths. The next line tells D3.js what values we’re going to transition. In this case, we’re changing an attribute of the <code class="literal">&lt;path&gt;</code> elements (so we use the function <code class="literal">attrTween</code>), and the specific attribute we’re changing is the <code class="literal">"d"</code> attribute (the first parameter to that function). The second parameter, <code class="literal">arcTween(datum)</code>, is a function that returns a function.</p><p>Here’s the complete implementation of <code class="literal">arcTween()</code>.</p><a id="pro_id00424"/><pre class="programlisting"><span class="steelblue"><span class="strong"><strong>function</strong></span></span> <span class="olive">arcTween</span>(datum) {
    <span class="steelblue"><span class="strong"><strong>var</strong></span></span> thetaDomain = <span class="steelblue">d3</span>.<span class="olive">interpolate</span>(<span class="steelblue">theta</span>.<span class="olive">domain</span>(),
                         [<span class="steelblue">datum</span>.<span class="olive">x</span>, <span class="steelblue">datum</span>.<span class="olive">x</span> + <span class="steelblue">datum</span>.<span class="olive">dx</span>]),
        radiusDomain = <span class="steelblue">d3</span>.<span class="olive">interpolate</span>(<span class="steelblue">radius</span>.<span class="olive">domain</span>(),
                         [<span class="steelblue">datum</span>.<span class="olive">y</span>, <span class="red">1</span>]),
        radiusRange = <span class="steelblue">d3</span>.<span class="olive">interpolate</span>(<span class="steelblue">radius</span>.<span class="olive">range</span>(),
                         [<span class="steelblue">datum</span>.<span class="olive">y</span> ? <span class="red">20</span> : <span class="red">0</span>, maxRadius]);

    <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="steelblue"><span class="strong"><strong>function</strong></span></span> <span class="olive">calculateNewPath</span>(d, i) {
        <span class="steelblue"><span class="strong"><strong>return</strong></span></span> i ?
            <span class="steelblue"><span class="strong"><strong>function</strong></span></span> <span class="olive">interpolatePathForRoot</span>(t) {
                <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="olive">arc</span>(d);
            } :
            <span class="steelblue"><span class="strong"><strong>function</strong></span></span> <span class="olive">interpolatePathForNonRoot</span>(t) {
                <span class="steelblue">theta</span>.<span class="olive">domain</span>(<span class="olive">thetaDomain</span>(t));
                <span class="steelblue">radius</span>.<span class="olive">domain</span>(<span class="olive">radiusDomain</span>(t)).<span class="olive">range</span>(<span class="olive">radiusRange</span>(t));
                <span class="steelblue"><span class="strong"><strong>return</strong></span></span> <span class="olive">arc</span>(d);
            };
    };
};</pre><p>You can see that this code block defines several different functions. First, there’s <code class="literal">arcTween()</code>. It returns another function <code class="literal">calculateNewPath()</code>, and <span class="emphasis"><em>that</em></span> function <a id="iddle1057" class="indexterm"/><a id="iddle1111" class="indexterm"/>returns either <code class="literal">interpolatePathForRoot()</code> or <code class="literal">interpolatePathForNonRoot()</code>. Before we look at the details of the implementation, let me go over the distinctions between these functions.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">arcTween()</code> is called once (for a single click) in the click event handler. Its input parameter is the data value corresponding to the clicked element.</p></li><li class="listitem"><p><code class="literal">calculateNewPath()</code> is then called once for every path element, a total of 702 times for each click. Its input parameters are the data value and index of the path element.</p></li><li class="listitem"><p><code class="literal">interpolatePathForRoot()</code> or <code class="literal">interpolatePathForNonRoot()</code> are called multiple times for each path element. Every call provides the input parameter <code class="literal">t</code> (for time) that represents the amount of progress in the current animation transition. The time parameter ranges from 0 when the animation starts to 1 when the animation ends. If, for example, D3.js requires 100 individual animation steps for the transition, then these functions will be called 70,200 times for each click.</p></li></ul></div><p>Now that we know when each of these functions is called, we can start to look at what they actually do. A concrete example definitely helps, so let’s consider what happens when the user clicks the state of Kentucky. As <a class="xref" href="ch07.html#tornado_sightings_sunburst_graph_with_ke" title="Figure 7-16. The tornado sightings sunburst graph with Kentucky highlighted">Figure 7-16</a> shows, it’s on the second row in the upper-right section of the visualization.</p><div class="figure"><a id="tornado_sightings_sunburst_graph_with_ke"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00113"/><img src="figs/web/07fig16.png.jpg" alt="The tornado sightings sunburst graph with Kentucky highlighted"/></div></div><div class="figure-title">Figure 7-16. The tornado sightings sunburst graph with Kentucky highlighted</div></div><p><a id="iddle1058" class="indexterm"/><a id="iddle1112" class="indexterm"/>The data value associated with this SVG <code class="literal">&lt;path&gt;</code> will have properties calculated by the partition layout, specifically:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>an <code class="literal">x</code> value of 0.051330798479087454</p></li><li class="listitem"><p>a <code class="literal">y</code> value of 0.5</p></li><li class="listitem"><p>a <code class="literal">dx</code> value of 0.04182509505703422</p></li><li class="listitem"><p>a <code class="literal">dy</code> value of 0.25</p></li></ul></div><p>In terms of our visualization, the area begins at an angular position of 18.479° (<code class="literal">x</code>) and continues for another 15.057° (<code class="literal">dx</code>). Its innermost radius begins 177 pixels (<code class="literal">y</code>) from the center. When the user clicks Kentucky, we want the visualization to zoom in on Kentucky and its counties. That’s the region that <a class="xref" href="ch07.html#when_the_user_clicks_kentuckycomma_we_wa" title="Figure 7-17. When the user clicks Kentucky, we want the visualization to focus on that small area.">Figure 7-17</a> highlights. The angle begins at 18.479° and continues for another 15.057°; the radius begins at 177 pixels and continues to the <code class="literal">maxRadius</code> value, a total length of 73 pixels.</p><div class="figure"><a id="when_the_user_clicks_kentuckycomma_we_wa"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00114"/><img src="figs/web/07fig17.png.jpg" alt="When the user clicks Kentucky, we want the visualization to focus on that small area."/></div></div><div class="figure-title">Figure 7-17. When the user clicks Kentucky, we want the visualization to focus on that small area.</div></div><p>The concrete example helps explain the <code class="literal">arcTween()</code> implementation. The function first creates three <code class="literal">d3.interpolate</code> objects. These objects provide a convenient way to handle the mathematical calculations for interpolations. The first object interpolates from the starting <code class="literal">theta</code> domain (initially 0 to 1) to our desired subset (0.051 to 0.093 for Kentucky). The second object does the same for the radius, interpolating from the starting radius domain (initially 0 to 1) to our desired subset (0.5 to 1 for Kentucky and its counties). The final object provides a new, interpolated range for the radius. If the clicked element has a non-zero <code class="literal">y</code> value, the new range will start at 20 instead of 0. If the clicked element was the <code class="literal">&lt;path&gt;</code> representing the entire United States, then the range reverts to the initial starting value of 0.</p><p><code class="literal">arcTween()</code> returns the <code class="literal">calculateNewPath</code> function after creating the <code class="literal">d3.interpolate</code> objects. D3.js calls this function once for each <code class="literal">&lt;path&gt;</code> element. When it executes, <code class="literal">calculateNewPath()</code> checks to see if the associated <code class="literal">&lt;path&gt;</code> element is the root (representing the entire United States). If so, <code class="literal">calculateNewPath()</code> returns the <code class="literal">interpolatePathForRoot</code> function. For the root, no interpolation is necessary, so the desired path is just the regular path that our <code class="literal">arc()</code> function (from Step 4) creates. For all other elements, however, we use the <code class="literal">d3.interpolate</code> objects to redefine the <code class="literal">theta</code> and <code class="literal">radius</code> scales. Instead of the full 0 to 2π and 0 to <code class="literal">maxRadius</code>, we set these scales to be the desired area of focus. Furthermore, we use the amount of progress in the transition from the parameter <code class="literal">t</code> to interpolate how close we are to those desired values. With the scales redefined, calling the <code class="literal">arc()</code> function returns a path appropriate for the new scales. As the transition progresses, the paths reshape themselves to fit the desired outcome. You can see the intermediate steps in <a class="xref" href="ch07.html#transition_smoothly_animates_the_visuali" title="Figure 7-18. The transition smoothly animates the visualization to zoom in on the area of focus.">Figure 7-18</a>.</p><div class="figure"><a id="transition_smoothly_animates_the_visuali"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00115"/><img src="figs/web/07fig18.png.jpg" alt="The transition smoothly animates the visualization to zoom in on the area of focus."/></div></div><div class="figure-title">Figure 7-18. The transition smoothly animates the visualization to zoom in on the area of focus.</div></div><p>With this final bit of code, our visualization is complete. <a class="xref" href="ch07.html#d3dotjs_provides_all_the_tools_needed_fo" title="Figure 7-19. D3.js provides all the tools needed for complex custom interactive visualizations like this animated zoomable sunburst.">Figure 7-19</a> shows the result. It includes some additional hover effects in lieu of a true legend; you can find the complete implementation in the book’s source code (<span class="emphasis"><em><a class="ulink" href="http://jsDataV.is/source/" target="_top">http://jsDataV.is/source/</a></em></span>).</p><div class="figure"><a id="d3dotjs_provides_all_the_tools_needed_fo"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00116"/><img src="figs/web/07fig19.png.jpg" alt="D3.js provides all the tools needed for complex custom interactive visualizations like this animated zoomable sunburst."/></div></div><div class="figure-title">Figure 7-19. D3.js provides all the tools needed for complex custom interactive visualizations like this animated zoomable sunburst.</div></div></div></div><div class="sect1" title="Summing Up"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summing_up-id00040">Summing Up</h2></div></div></div><p>As we’ve seen in these examples, D3.js is a very powerful library for building JavaScript visualizations. Using it effectively requires a deeper understanding of JavaScript techniques than most of the other libraries we’ve seen in this book. If you make the investment to learn D3.js, though, you’ll have more control and flexibility over the results.</p></div></section></body></html>