<html><head></head><body>
<h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_149"/><strong><span class="big">6</span><br/>COMPILE-TIME POLYMORPHISM</strong></h2>&#13;
<p class="quote"><em>The more adapt, the more interesting you are.<br/>—Martha Stewart</em></p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">In this chapter, you’ll learn how to achieve compile-time polymorphism with templates. You’ll learn how to declare and use templates, enforce type safety, and survey some of the templates’ more advanced usages. This chapter concludes with a comparison of runtime and compile-time polymorphism in C++.</p>&#13;
<h3 class="h3" id="ch06lev1sec1"><strong>Templates</strong></h3>&#13;
<p class="noindent">C++ achieves compile-time polymorphism through <em>templates</em>. A template is a class or function with template parameters. These parameters can stand in for any type, including fundamental and user-defined types. When the compiler sees a template used with a type, it stamps out a bespoke template instantiation.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_150"/><em>Template instantiation</em> is the process of creating a class or a function from a template. Somewhat confusingly, you can also refer to “a template instantiation” as the result of the template instantiation process. Template instantiations are sometimes called concrete classes and concrete types.</p>&#13;
<p class="indent">The big idea is that, rather than copying and pasting common code all over the place, you write a single template; the compiler generates new template instances when it encounters a new combination of types in the template parameters.</p>&#13;
<h3 class="h3" id="ch06lev1sec2"><strong>Declaring Templates</strong></h3>&#13;
<p class="noindent">You declare templates with a <em>template prefix</em>, which consists of the keyword <code>template</code> followed by angle brackets <code>&lt; &gt;</code>. Within the angle brackets, you place the declarations of one or more template parameters. You can declare template parameters using either the <code>typename</code> or <code>class</code> keywords followed by an identifier. For example, the template prefix <code>template&lt;typename T&gt;</code> declares that the template takes a template parameter <code>T</code>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The coexistence of the <code>typename</code> and <code>class</code> keywords is unfortunate and confusing. They mean the same thing. (They’re both supported for historical reasons.) This chapter always uses <code>typename</code>.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch06lev2sec1"><strong><em>Template Class Definitions</em></strong></h4>&#13;
<p class="noindent">Consider <code>MyTemplateClass</code> in <a href="ch06.xhtml#ch06ex01">Listing 6-1</a>, which takes three template parameters: <code>X, Y</code>, and <code>Z</code>.</p>&#13;
<pre>template<span class="ent">➊</span>&lt;typename X, typename Y, typename Z&gt; <span class="ent">➋</span>&#13;
struct MyTemplateClass<span class="ent">➌</span> {&#13;
  X foo(Y&amp;); <span class="ent">➍</span>&#13;
private:&#13;
  Z* member; <span class="ent">➎</span>&#13;
};</pre>&#13;
<p class="listing"><a id="ch06ex01"/><em>Listing 6-1: A template class with three template parameters</em></p>&#13;
<p class="indent">The <code>template</code> keyword <span class="ent">➊</span> begins the template prefix, which contains the template parameters <span class="ent">➋</span>. This <code>template</code> preamble leads to something special about the remaining declaration of <code>MyTemplateClass</code> <span class="ent">➌</span>. Within <code>MyTemplateClass</code>, you use <code>X, Y</code>, and <code>Z</code> as if they were any fully specified type, like an <code>int</code> or a user-defined class.</p>&#13;
<p class="indent">The <code>foo</code> method takes a <code>Y</code> reference and returns an <code>X</code> <span class="ent">➍</span>. You can declare members with types that include template parameters, like a pointer to <code>Z</code> <span class="ent">➎</span>. Besides the special prefix beginning <span class="ent">➊</span>, this template class is essentially identical to a non-template class.</p>&#13;
<h4 class="h4" id="ch06lev2sec2"><strong><em><span epub:type="pagebreak" id="page_151"/>Template Function Definitions</em></strong></h4>&#13;
<p class="noindent">You can also specify template functions, like the <code>my_template_function</code> in <a href="ch06.xhtml#ch06ex02">Listing 6-2</a> that also takes three template parameters: <code>X, Y</code>, and <code>Z</code>.</p>&#13;
<pre>template&lt;typename X, typename Y, typename Z&gt;&#13;
X my_template_function(Y&amp; arg1, const Z* arg2) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex02"/><em>Listing 6-2: A template function with three template parameters</em></p>&#13;
<p class="indent">Within the body of <code>my_template_function</code>, you can use <code>arg1</code> and <code>arg2</code> however you’d like, as long as you return an object of type <code>X</code>.</p>&#13;
<h4 class="h4" id="ch06lev2sec3"><strong><em>Instantiating Templates</em></strong></h4>&#13;
<p class="noindent">To instantiate a template class, use the following syntax:</p>&#13;
<pre><span class="codeitalic1">tc_name</span><span class="ent">➊</span>&lt;<span class="codeitalic1">t_param1</span><span class="ent">➋</span>, <span class="codeitalic1">t_param2</span>, ...&gt; <span class="codeitalic1">my_concrete_class</span>{ ... }<span class="ent">➌</span>;</pre>&#13;
<p class="indent">The <span class="codeitalic">tc_name</span> <span class="ent">➊</span> is where you place the template class’s name. Next, you fill in your template parameters <span class="ent">➋</span>. Finally, you treat this combination of template name and parameters as if it were a normal type: you use whatever initialization syntax you like <span class="ent">➌</span>.</p>&#13;
<p class="indent">Instantiating a template function is similar:</p>&#13;
<pre>auto result = <span class="codeitalic1">tf_name</span><span class="ent">➊</span>&lt;<span class="codeitalic1">t_param1</span><span class="ent">➋</span>, <span class="codeitalic1">t_param2</span>, ...&gt;(<span class="codeitalic1">f_param1</span><span class="ent">➌</span>, <span class="codeitalic1">f_param2</span>, ...);</pre>&#13;
<p class="indent">The <span class="codeitalic">tf_name</span> <span class="ent">➊</span> is where you put the template function’s name. You fill in the parameters just as you do for template classes <span class="ent">➋</span>. You use the combination of template name and parameters as if it were a normal type. You invoke this template function instantiation with parentheses and function parameters <span class="ent">➌</span>.</p>&#13;
<p class="indent">All this new notation might be daunting to a newcomer, but it’s not so bad once you get used to it. In fact, it’s used in a set of language features called named conversion functions.</p>&#13;
<h3 class="h3" id="ch06lev1sec3"><strong>Named Conversion Functions</strong></h3>&#13;
<p class="noindent"><em>Named conversions</em> are language features that explicitly convert one type into another type. You use named conversions sparingly in situations where you cannot use implicit conversions or constructors to get the types you need.</p>&#13;
<p class="indent">All named conversions accept a single object parameter, which is the object you want to cast <code>object-to-cast</code>, and a single type parameter, which is the type you want to cast to <code>desired-type</code>:</p>&#13;
<pre><span class="codeitalic1">named-conversion</span>&lt;<span class="codeitalic1">desired-type</span>&gt;(<span class="codeitalic1">object-to-cast</span>)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_152"/>For example, if you need to modify a <code>const</code> object, you would first need to cast away the <code>const</code> qualifier. The named conversion function <code>const_cast</code> allows you to perform this operation. Other named conversions help you to reverse implicit casts (<code>static_cast</code>) or reinterpret memory with a different type (<code>reinterpret_cast</code>).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Although named conversion functions aren’t technically template functions, they are conceptually very close to templates—a relationship reflected in their syntactic similarity.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch06lev2sec4"><strong><em>const_cast</em></strong></h4>&#13;
<p class="noindent">The <code>const_cast</code> function shucks away the <code>const</code> modifier, allowing the modification of <code>const</code> values. The <code>object-to-cast</code> is of some <code>const</code> type, and the <span class="codeitalic">desired-type</span> is that type minus the <code>const</code> qualifier.</p>&#13;
<p class="indent">Consider the <code>carbon_thaw</code> function in <a href="ch06.xhtml#ch06ex03">Listing 6-3</a>, which takes a <code>const</code> reference to an <code>encased_solo</code> argument.</p>&#13;
<pre>void carbon_thaw(const<span class="ent">➊</span> int&amp; encased_solo) {&#13;
  //encased_solo++; <span class="ent">➋</span> // Compiler error; modifying const&#13;
  auto&amp; hibernation_sick_solo = const_cast<span class="ent">➌</span>&lt;int&amp;<span class="ent">➍</span>&gt;(encased_solo<span class="ent">➎</span>);&#13;
  hibernation_sick_solo++; <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex03"/><em>Listing 6-3: A function using <code>const_cast</code>. Uncommenting yields a compiler error.</em></p>&#13;
<p class="indent">The <code>encased_solo</code> parameter is <code>const</code> <span class="ent">➊</span>, so any attempt to modify it <span class="ent">➋</span> would result in a compiler error. You use <code>const_cast</code> <span class="ent">➌</span> to obtain the non-<code>const</code> reference <code>hibernation_sick_solo</code>. The <code>const_cast</code> takes a single template parameter, the type you want to cast into <span class="ent">➍</span>. It also takes a function parameter, the object you want to remove <code>const</code> from <span class="ent">➎</span>. You’re then free to modify the <code>int</code> pointed to by <code>encased_solo</code> via the new, non-<code>const</code> reference <span class="ent">➏</span>.</p>&#13;
<p class="indent">Only use <code>const_cast</code> to obtain write access to <code>const</code> objects. Any other type conversion will result in a compiler error.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Trivially, you can use <code>const_cast</code> to add <code>const</code> to an object’s type, but you shouldn’t because it’s verbose and unnecessary. Use an implicit cast instead. In <a href="ch07.xhtml#ch07">Chapter 7</a>, you’ll learn what the <code>volatile</code> modifier is. You can also use <code>const_cast</code> to remove the <code>volatile</code> modifier from an object.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch06lev2sec5"><strong><em>static_cast</em></strong></h4>&#13;
<p class="noindent">The <code>static_cast</code> reverses a well-defined implicit conversion, such as an integer type to another integer type. The <code>object-to-cast</code> is of some type that the <code>desired-type</code> implicitly converts to. The reason you might need <code>static_cast</code> is that, generally, implicit casts aren’t reversible.</p>&#13;
<p class="indent">The program in <a href="ch06.xhtml#ch06ex04">Listing 6-4</a> defines an <code>increment_as_short</code> function that takes a <code>void</code> pointer argument. It employs a <code>static_cast</code> to create a <code>short</code> pointer from this argument, increment the pointed-to <code>short</code>, and return the result. In some low-level applications, such as network programming <span epub:type="pagebreak" id="page_153"/>or handling binary file formats, you might need to interpret raw bytes as an integer type.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
short increment_as_short(void*<span class="ent">➊</span> target) {&#13;
  auto as_short = static_cast<span class="ent">➋</span>&lt;short*<span class="ent">➌</span>&gt;(target<span class="ent">➍</span>);&#13;
  *as_short = *as_short + 1;&#13;
  return *as_short;&#13;
}&#13;
&#13;
int main() {&#13;
  short beast{ 665 };&#13;
  auto mark_of_the_beast = increment_as_short(&amp;beast);&#13;
  printf("%d is the mark_of_the_beast.", mark_of_the_beast);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">666 is the mark_of_the_beast.</span></pre>&#13;
<p class="listing"><a id="ch06ex04"/><em>Listing 6-4: A program using <code>static_cast</code></em></p>&#13;
<p class="indent">The <code>target</code> parameter is a <code>void</code> pointer <span class="ent">➊</span>. You employ <code>static_cast</code> to cast <code>target</code> into a <code>short*</code> <span class="ent">➋</span>. The template parameter is the desired type <span class="ent">➌</span>, and the function parameter is the object you want to cast into <span class="ent">➍</span>.</p>&#13;
<p class="indent">Notice that the implicit conversion of <code>short*</code> to <code>void*</code> is well defined. Attempting ill-defined conversions with <code>static_cast</code>, such as converting a <code>char*</code> to a <code>float*</code>, will result in a compiler error:</p>&#13;
<pre>float on = 3.5166666666;&#13;
auto not_alright = static_cast&lt;char*&gt;(&amp;on); // Bang!</pre>&#13;
<p class="indent">To perform such chainsaw juggling, you need to use <code>reinterpret_cast</code>.</p>&#13;
<h4 class="h4" id="ch06lev2sec6"><strong><em>reinterpret_cast</em></strong></h4>&#13;
<p class="noindent">Sometimes in low-level programming, you must perform type conversions that are not well defined. In system programming and especially in embedded environments, you often need complete control over how to interpret memory. The <code>reinterpret_cast</code> gives you such control, but ensuring the correctness of these conversions is entirely your responsibility.</p>&#13;
<p class="indent">Suppose your embedded device keeps an <code>unsigned long</code> timer at memory address 0x1000. You could use <code>reinterpret_cast</code> to read from the timer, as demonstrated in <a href="ch06.xhtml#ch06ex05">Listing 6-5</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
int main() {&#13;
  auto timer = reinterpret_cast<span class="ent">➊</span>&lt;const unsigned long*<span class="ent">➋</span>&gt;(0x1000<span class="ent">➌</span>);&#13;
  printf("Timer is %lu.", *timer);&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex05"/><em>Listing 6-5: A program using <code>reinterpret_cast</code>. This program will compile, but you should expect a runtime crash unless 0x1000 is readable.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_154"/>The <code>reinterpret_cast</code> <span class="ent">➊</span> takes a type parameter corresponding to the desired pointer type <span class="ent">➋</span> and the memory address the result should point to <span class="ent">➌</span>.</p>&#13;
<p class="indent">Of course, the compiler has no idea whether the memory at address 0x1000 contains an <code>unsigned long</code>. It’s entirely up to you to ensure correctness. Because you’re taking full responsibility for this very dangerous construction, the compiler forces you to employ <code>reinterpret_cast</code>. You couldn’t, for example, replace the initialization of <code>timer</code> with the following line:</p>&#13;
<pre>const unsigned long* timer{ 0x1000 };</pre>&#13;
<p class="indent">The compiler will grumble about converting an <code>int</code> to a pointer.</p>&#13;
<h4 class="h4" id="ch06lev2sec7"><strong><em>narrow_cast</em></strong></h4>&#13;
<p class="noindent"><a href="ch06.xhtml#ch06ex06">Listing 6-6</a> illustrates a custom <code>static_cast</code> that performs a runtime check for <em>narrowing</em>. Narrowing is a loss in information. Think about converting from an <code>int</code> to a <code>short</code>. As long as the value of <code>int</code> fits into a <code>short</code>, the conversion is reversible and no narrowing occurs. If the value of <code>int</code> is too big for the <code>short</code>, the conversion isn’t reversible and results in narrowing.</p>&#13;
<p class="indent">Let’s implement a named conversion called <code>narrow_cast</code> that checks for narrowing and throws a <code>runtime_error</code> if it’s detected.</p>&#13;
<pre>#include &lt;stdexcept&gt;&#13;
template &lt;typename To<span class="ent">➊</span>, typename From<span class="ent">➋</span>&gt;&#13;
To<span class="ent">➌</span> narrow_cast(From<span class="ent">➍</span> value) {&#13;
  const auto converted = static_cast&lt;To&gt;(value); <span class="ent">➎</span>&#13;
  const auto backwards = static_cast&lt;From&gt;(converted); <span class="ent">➏</span>&#13;
  if (value != backwards) throw std::runtime_error{ "Narrowed!" }; <span class="ent">➐</span>&#13;
  return converted; <span class="ent">➑</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex06"/><em>Listing 6-6: A <code>narrow_cast</code> definition</em></p>&#13;
<p class="indent">The <code>narrow_cast</code> function template takes two template parameters: the type you’re casting <code>To</code> <span class="ent">➊</span> and the type you’re casting <code>From</code> <span class="ent">➋</span>. You can see these template parameters in action as the return type of the function <span class="ent">➌</span> and the type of the parameter value <span class="ent">➍</span>. First, you perform the requested conversion using <code>static_cast</code> to yield <code>converted</code> <span class="ent">➎</span>. Next, you perform the conversion in the opposite direction (from <code>converted</code> to type <code>From</code>) to yield <code>backwards</code> <span class="ent">➏</span>. If <code>value</code> doesn’t equal <code>backwards</code>, you’ve narrowed, so you throw an exception <span class="ent">➐</span>. Otherwise, you return <code>converted</code> <span class="ent">➑</span>.</p>&#13;
<p class="indent">You can see <code>narrow_cast</code> in action in <a href="ch06.xhtml#ch06ex07">Listing 6-7</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;stdexcept&gt;&#13;
&#13;
template &lt;typename To, typename From&gt;&#13;
To narrow_cast(From value) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
<span epub:type="pagebreak" id="page_155"/>int main() {&#13;
  int perfect{ 496 }; <span class="ent">➊</span>&#13;
  const auto perfect_short = narrow_cast&lt;short&gt;(perfect); <span class="ent">➋</span>&#13;
  printf("perfect_short: %d\n", perfect_short); <span class="ent">➌</span>&#13;
  try {&#13;
    int cyclic{ 142857 }; <span class="ent">➍</span>&#13;
    const auto cyclic_short = narrow_cast&lt;short&gt;(cyclic); <span class="ent">➎</span>&#13;
    printf("cyclic_short: %d\n", cyclic_short);&#13;
  } catch (const std::runtime_error&amp; e) {&#13;
    printf("Exception: %s\n", e.what()); <span class="ent">➏</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">perfect_short: 496 <span class="ent">➌</span></span>&#13;
<span class="color1">Exception: Narrowed! <span class="ent">➏</span></span></pre>&#13;
<p class="listing"><a id="ch06ex07"/><em>Listing 6-7: A program using <code>narrow_cast</code>. (The output comes from an execution on Windows 10 x64.)</em></p>&#13;
<p class="indent">You first initialize <code>perfect</code> to 496 <span class="ent">➊</span> and then <code>narrow_cast</code> it to the short <code>perfect_short</code> <span class="ent">➋</span>. This proceeds without exception because the value 496 fits easily into a 2-byte short on Windows 10 x64 (maximum value 32767). You see the output as expected <span class="ent">➌</span>. Next, you initialize <code>cyclic</code> to 142857 <span class="ent">➍</span> and attempt to <code>narrow_cast</code> to the short <code>cyclic_short</code> <span class="ent">➎</span>. This throws a <code>runtime_error</code> because 142857 is greater than the short’s maximum value of 32767. The check within <code>narrow_cast</code> will fail. You see the exception printed in the <code>output</code> <span class="ent">➏</span>.</p>&#13;
<p class="indent">Notice that you need to provide only a single template parameter, the return type, upon instantiation <span class="ent">➋➎</span>. The compiler can deduce the <code>From</code> parameter based on usage.</p>&#13;
<h3 class="h3" id="ch06lev1sec4"><strong>mean: A Template Function Example</strong></h3>&#13;
<p class="noindent">Consider the function in <a href="ch06.xhtml#ch06ex08">Listing 6-8</a> that computes the mean of a <code>double</code> array using the sum-and-divide approach.</p>&#13;
<pre>#include &lt;cstddef&gt;&#13;
&#13;
double mean(const double* values, size_t length) {&#13;
  double result{}; <span class="ent">➊</span>&#13;
  for(size_t i{}; i&lt;length; i++) {&#13;
    result += values[i]; <span class="ent">➋</span>&#13;
  }&#13;
  return result / length; <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex08"/><em>Listing 6-8: A function for computing the mean of an array</em></p>&#13;
<p class="indent">You initialize a <code>result</code> variable to zero <span class="ent">➊</span>. Next, you sum over <code>values</code> by iterating over each index <code>i</code>, adding the corresponding element to <code>result</code> <span class="ent">➋</span>. Then you divide <code>result</code> by <code>length</code> and <code>return</code> <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch06lev2sec8"><span epub:type="pagebreak" id="page_156"/><strong><em>Genericizing mean</em></strong></h4>&#13;
<p class="noindent">Suppose you want to support <code>mean</code> calculations for other numeric types, such as <code>float</code> or <code>long</code>. You might be thinking, “That’s what function overloads are for!” Essentially, you would be correct.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06ex09">Listing 6-9</a> overloads <code>mean</code> to accept a <code>long</code> array. The straightforward approach is to copy and paste the original, then replace instances of <code>double</code> with <code>long</code>.</p>&#13;
<pre>#include &lt;cstddef&gt;&#13;
&#13;
long<span class="ent">➊</span> mean(const long*<span class="ent">➋</span> values, size_t length) {&#13;
  long result{}; <span class="ent">➌</span>&#13;
  for(size_t i{}; i&lt;length; i++) {&#13;
    result += values[i];&#13;
  }&#13;
  return result / length;&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex09"/><em>Listing 6-9: An overload of <a href="ch06.xhtml#ch06ex08">Listing 6-8</a> accepting a <code>long</code> array</em></p>&#13;
<p class="indent">That sure is a lot of copying and pasting, and you’ve changed very little: the return type <span class="ent">➊</span>, the function argument <span class="ent">➋</span>, and <code>result</code> <span class="ent">➌</span>.</p>&#13;
<p class="indent">This approach doesn’t scale as you add more types. What if you want to support other integral types, such as <code>short</code> types or <code>uint_64</code> types? What about <code>float</code> types? What if, later on, you want to refactor some logic in <code>mean</code>? You’re in for a lot of tedious and error-prone maintenance.</p>&#13;
<p class="indent">There are three changes to <code>mean</code> in <a href="ch06.xhtml#ch06ex09">Listing 6-9</a>, and all of them involve finding and replacing <code>double</code> types with <code>long</code> types. Ideally, you could have the compiler automatically generate versions of the function for you whenever it encounters usage with a different type. The key is that none of the logic changes—only the types.</p>&#13;
<p class="indent">What you need to solve this copy-and-paste problem is <em>generic programming</em>, a programming style where you program with yet-to-be-specified types. You achieve generic programming using the support C++ has for templates. Templates allow the compiler to instantiate a custom class or function based on the types in use.</p>&#13;
<p class="indent">Now that you know how to declare templates, consider the <code>mean</code> function again. You still want <code>mean</code> to accept a wide range of types—not just <code>double</code> types—but you don’t want to have to copy and paste the same code over and over again.</p>&#13;
<p class="indent">Consider how you can refactor <a href="ch06.xhtml#ch06ex08">Listing 6-8</a> into a template function, as demonstrated in <a href="ch06.xhtml#ch06ex10">Listing 6-10</a>.</p>&#13;
<pre>#include &lt;cstddef&gt;&#13;
&#13;
template&lt;typename T&gt; <span class="ent">➊</span>&#13;
T<span class="ent">➋</span> mean(constT*<span class="ent">➌</span> values, size_t length) {&#13;
  T<span class="ent">➍</span> result{};&#13;
  for(size_t i{}; i&lt;length; i++) {&#13;
    result += values[i];&#13;
<span epub:type="pagebreak" id="page_157"/>  }&#13;
  return result / length;&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex10"/><em>Listing 6-10: Refactoring <a href="ch06.xhtml#ch06ex08">Listing 6-8</a> into a template function</em></p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06ex10">Listing 6-10</a> kicks off with a template prefix <span class="ent">➊</span>. This prefix communicates a single template parameter <code>T</code>. Next, you update <code>mean</code> to use <code>T</code> instead of <code>double</code> <span class="ent">➋➌➍</span>.</p>&#13;
<p class="indent">Now you can use <code>mean</code> with many different types. Each time the compiler encounters a usage of <code>mean</code> with a new type, it performs template instantiation. It’s <em>as if</em> you had done the copy-paste-and-replace-types procedure, but the compiler is much better at doing detail-oriented, monotonous tasks than you are. Consider the example in <a href="ch06.xhtml#ch06ex11">Listing 6-11</a>, which computes means for <code>double, float</code>, and <code>size_t</code> types.</p>&#13;
<pre>#include &lt;cstddef&gt;&#13;
#include &lt;cstdio&gt;&#13;
&#13;
template&lt;typename T&gt;&#13;
T mean(const T* values, size_t length) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
int main() {&#13;
  const double nums_d[] { 1.0, 2.0, 3.0, 4.0 };&#13;
  const auto result1 = mean&lt;double&gt;(nums_d, 4); <span class="ent">➊</span>&#13;
  printf("double: %f\n", result1);&#13;
&#13;
  const float nums_f[] { 1.0f, 2.0f, 3.0f, 4.0f };&#13;
  const auto result2 = mean&lt;float&gt;(nums_f, 4); <span class="ent">➋</span>&#13;
  printf("float: %f\n", result2);&#13;
&#13;
  const size_t nums_c[] { 1, 2, 3, 4 };&#13;
  const auto result3 = mean&lt;size_t&gt;(nums_c, 4); <span class="ent">➌</span>&#13;
  printf("size_t: %zu\n", result3);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">double: 2.500000</span>&#13;
<span class="color1">float: 2.500000</span>&#13;
<span class="color1">size_t: 2</span></pre>&#13;
<p class="listing"><a id="ch06ex11"/><em>Listing 6-11: A program using the template function <code>mean</code></em></p>&#13;
<p class="indent">Three templates are instantiated <span class="ent">➊➋➌</span>; it’s as if you generated the overloads isolated in <a href="ch06.xhtml#ch06ex12">Listing 6-12</a> by hand. (Each template instantiation contains types, shown in bold, where the compiler substituted a type for a template parameter.)</p>&#13;
<pre><span class="codeitalicstrong1">double</span> mean(const <span class="codeitalicstrong1">double</span>* values, size_t length) {&#13;
  <span class="codeitalicstrong1">double</span> result{};&#13;
  for(size_t i{}; i&lt;length; i++) {&#13;
    result += values[i];&#13;
  }&#13;
<span epub:type="pagebreak" id="page_158"/>  return result / length;&#13;
}&#13;
&#13;
<span class="codeitalicstrong1">float</span> mean(const <span class="codeitalicstrong1">float</span>* values, size_t length) {&#13;
  <span class="codeitalicstrong1">float</span> result{};&#13;
  for(size_t i{}; i&lt;length; i++) {&#13;
    result += values[i];&#13;
  }&#13;
  return result / length;&#13;
}&#13;
&#13;
<span class="codeitalicstrong1">size_t</span> mean(const <span class="codeitalicstrong1">size_t</span>* values, size_t length) {&#13;
  <span class="codeitalicstrong1">size_t</span> result{};&#13;
  for(size_t i{}; i&lt;length; i++) {&#13;
    result += values[i];&#13;
  }&#13;
  return result / length;&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex12"/><em>Listing 6-12: The template instantiations for <a href="ch06.xhtml#ch06ex11">Listing 6-11</a></em></p>&#13;
<p class="indent">The compiler has done a lot of work for you, but you might have noticed that you had to type the pointed-to array type twice: once to declare an array and again to specify a template parameter. This gets tedious and can cause errors. If the template parameter doesn’t match, you’ll likely get a compiler error or cause unintended casting.</p>&#13;
<p class="indent">Fortunately, you can generally omit the template parameters when invoking a template function. The process that the compiler uses to determine the correct template parameters is called <em>template type deduction</em>.</p>&#13;
<h4 class="h4" id="ch06lev2sec9"><strong><em>Template Type Deduction</em></strong></h4>&#13;
<p class="noindent">Generally, you don’t have to provide template function parameters. The compiler can deduce them from usage, so a rewrite of <a href="ch06.xhtml#ch06ex11">Listing 6-11</a> without them is shown in <a href="ch06.xhtml#ch06ex13">Listing 6-13</a>.</p>&#13;
<pre>#include &lt;cstddef&gt;&#13;
#include &lt;cstdio&gt;&#13;
&#13;
template&lt;typename T&gt;&#13;
T mean(const T* values, size_t length) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
int main() {&#13;
  const double nums_d[] { 1.0, 2.0, 3.0, 4.0 };&#13;
  const auto result1 = mean(nums_d, 4); <span class="ent">➊</span>&#13;
  printf("double: %f\n", result1);&#13;
&#13;
  const float nums_f[] { 1.0f, 2.0f, 3.0f, 4.0f };&#13;
  const auto result2 = mean(nums_f, 4); <span class="ent">➋</span>&#13;
  printf("float: %f\n", result2);&#13;
&#13;
  const size_t nums_c[] { 1, 2, 3, 4 };&#13;
<span epub:type="pagebreak" id="page_159"/>  const auto result3 = mean(nums_c, 4); <span class="ent">➌</span>&#13;
  printf("size_t: %zu\n", result3);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">double: 2.500000</span>&#13;
<span class="color1">float: 2.500000</span>&#13;
<span class="color1">size_t: 2</span></pre>&#13;
<p class="listing"><a id="ch06ex13"/><em>Listing 6-13: A refactor of <a href="ch06.xhtml#ch06ex11">Listing 6-11</a> without explicit template parameters</em></p>&#13;
<p class="indent">It’s clear from usage that the template parameters are <code>double</code> <span class="ent">➊</span>, <code>float</code> <span class="ent">➋</span>, and <code>size_t</code> <span class="ent">➌</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Template type deduction mostly works the way you might expect, but there is some nuance you’ll want to become familiar with if you’re writing a lot of generic code. For more information, see the ISO standard [temp]. Also, refer to Item 1 of Effective Modern C++ by Scott Meyers and Section 23.5.1 of  The C++ Programming Language, 4th Edition, by Bjarne Stroustrup.</em></p>&#13;
</div>&#13;
<p class="indent">Sometimes, template arguments cannot be deduced. For example, if a template function’s return type is a template argument that’s entirely independent of other function and template arguments, you must specify template arguments explicitly.</p>&#13;
<h3 class="h3" id="ch06lev1sec5"><strong>SimpleUniquePointer: A Template Class Example</strong></h3>&#13;
<p class="noindent">A <em>unique pointer</em> is an RAII wrapper around a free-store-allocated object. As its name suggests, the unique pointer has a single owner at a time, so when a unique pointer’s lifetime ends, the pointed-to object gets destructed.</p>&#13;
<p class="indent">The underlying object’s type in unique pointers doesn’t matter, making them a prime candidate for a template class. Consider the implementation in <a href="ch06.xhtml#ch06ex14">Listing 6-14</a>.</p>&#13;
<pre>template &lt;typename T&gt; <span class="ent">➊</span>&#13;
struct SimpleUniquePointer {&#13;
  SimpleUniquePointer() = default; <span class="ent">➋</span>&#13;
  SimpleUniquePointer(T* pointer)&#13;
    : pointer{ pointer } { <span class="ent">➌</span>&#13;
  }&#13;
  ~SimpleUniquePointer() { <span class="ent">➍</span>&#13;
    if(pointer) delete pointer;&#13;
  }&#13;
  SimpleUniquePointer(const SimpleUniquePointer&amp;) = delete;&#13;
  SimpleUniquePointer&amp; operator=(const SimpleUniquePointer&amp;) = delete; <span class="ent">➎</span>&#13;
  SimpleUniquePointer(SimpleUniquePointer&amp;&amp; other) noexcept <span class="ent">➏</span>&#13;
    : pointer{ other.pointer } {&#13;
    other.pointer = nullptr;&#13;
  }&#13;
  SimpleUniquePointer&amp; operator=(SimpleUniquePointer&amp;&amp; other) noexcept { <span class="ent">➐</span>&#13;
    if(pointer) delete pointer;&#13;
    pointer = other.pointer;&#13;
    other.pointer = nullptr;&#13;
    return *this;&#13;
<span epub:type="pagebreak" id="page_160"/>  }&#13;
  T* get() { <span class="ent">➑</span>&#13;
    return pointer;&#13;
  }&#13;
private:&#13;
  T* pointer;&#13;
};</pre>&#13;
<p class="listing"><a id="ch06ex14"/><em>Listing 6-14: A simple unique pointer implementation</em></p>&#13;
<p class="indent">You announce the template class with a template prefix <span class="ent">➊</span>, which establishes <code>T</code> as the wrapped object’s type. Next, you specify a default constructor using the <code>default</code> keyword <span class="ent">➋</span>. (Recall from <a href="ch04.xhtml#ch04">Chapter 4</a> that you need <code>default</code> when you want both a default constructor <em>and</em> a non-default constructor.) The generated default constructor will set the private member <code>T*</code> pointer to <code>nullptr</code> thanks to default initialization rules. You have a non-default constructor that takes a <code>T*</code> and sets the private member pointer <span class="ent">➌</span>. Because the pointer is possibly <code>nullptr</code>, the destructor checks before deleting <span class="ent">➍</span>.</p>&#13;
<p class="indent">Because you want to allow only a single owner of the pointed-to object, you <code>delete</code> the copy constructor and the copy-assignment operator <span class="ent">➎</span>. This prevents double-free issues, which were discussed in <a href="ch04.xhtml#ch04">Chapter 4</a>. However, you can make your unique pointer moveable by adding a move constructor <span class="ent">➏</span>. This steals the value of <code>pointer</code> from <code>other</code> and then sets the pointer of <code>other</code> to <code>nullptr</code>, handing responsibility of the pointed-to object to <code>this</code>. Once the move constructor returns, the moved-from object is destroyed. Because the moved-from object’s pointer is set to <code>nullptr</code>, the destructor will not delete the pointed-to object.</p>&#13;
<p class="indent">The possibility that <code>this</code> already owns an object complicates the move assignment <span class="ent">➐</span>. You must check explicitly for prior ownership, because failure to delete a pointer leaks a resource. After this check, you perform the same operations as in the copy constructor: you set <code>pointer</code> to the value of <code>other.pointer</code> and then set <code>other.pointer</code> to <code>nullptr</code>. This ensures that the moved-from object doesn’t delete the pointed-to object.</p>&#13;
<p class="indent">You can obtain direct access to the underlying pointer by calling the <code>get</code> method <span class="ent">➑</span>.</p>&#13;
<p class="indent">Let’s enlist our old friend <code>Tracer</code> from <a href="ch04.xhtml#ch04ex05">Listing 4-5</a> to investigate <code>SimpleUniquePointer</code>. Consider the program in <a href="ch06.xhtml#ch06ex15">Listing 6-15</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;utility&gt;&#13;
&#13;
template &lt;typename T&gt;&#13;
struct SimpleUniquePointer {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct Tracer {&#13;
  Tracer(const char* name) : name{ name } {&#13;
    printf("%s constructed.\n", name); <span class="ent">➊</span>&#13;
  }&#13;
  ~Tracer() {&#13;
<span epub:type="pagebreak" id="page_161"/>    printf("%s destructed.\n", name); <span class="ent">➋</span>&#13;
  }&#13;
private:&#13;
  const char* const name;&#13;
};&#13;
&#13;
void consumer(SimpleUniquePointer&lt;Tracer&gt; consumer_ptr) {&#13;
  printf("(cons) consumer_ptr: 0x%p\n", consumer_ptr.get()); <span class="ent">➌</span>&#13;
}&#13;
&#13;
int main() {&#13;
  auto ptr_a = SimpleUniquePointer(new Tracer{ "ptr_a" });&#13;
  printf("(main) ptr_a: 0x%p\n", ptr_a.get()); <span class="ent">➍</span>&#13;
  consumer(std::move(ptr_a));&#13;
  printf("(main) ptr_a: 0x%p\n", ptr_a.get()); <span class="ent">➎</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">ptr_a constructed. <span class="ent">➊</span></span>&#13;
<span class="color1">(main) ptr_a: 0x000001936B5A2970 <span class="ent">➍</span></span>&#13;
<span class="color1">(cons) consumer_ptr: 0x000001936B5A2970 <span class="ent">➌</span></span>&#13;
<span class="color1">ptr_a destructed. <span class="ent">➋</span></span>&#13;
<span class="color1">(main) ptr_a: 0x0000000000000000 <span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch06ex15"/><em>Listing 6-15: A program investigating <code>SimpleUniquePointers</code> with the <code>Tracer</code> class</em></p>&#13;
<p class="indent">First, you dynamically allocate a <code>Tracer</code> with the message <code>ptr_a</code>. This prints the first message <span class="ent">➊</span>. You use the resulting <code>Tracer</code> pointer to construct a <code>SimpleUniquePointer</code> called <code>ptr_a</code>. Next, you use the <code>get()</code> method of <code>ptr_a</code> to retrieve the address of its <code>Tracer</code>, which you print <span class="ent">➍</span>. Then you use <code>std::move</code> to relinquish the <code>Tracer</code> of <code>ptr_a</code> to the <code>consumer</code> function, which moves <code>ptr_a</code> into the <code>consumer_ptr</code> argument.</p>&#13;
<p class="indent">Now, <code>consumer_ptr</code> owns the <code>Tracer</code>. You use the <code>get()</code> method of <code>consumer_ptr</code> to retrieve the address of <code>Tracer</code>, then print <span class="ent">➌</span>. Notice this address matches the one printed at <span class="ent">➍</span>. When <code>consumer</code> returns, <code>consumer_ptr</code> dies because its storage duration is the scope of <code>consumer</code>. As a result, <code>ptr_a</code> gets destructed <span class="ent">➋</span>.</p>&#13;
<p class="indent">Recall that <code>ptr_a</code> is in a moved-from state—you moved its <code>Tracer</code> into <code>consumer</code>. You use the <code>get()</code> method of <code>ptr_a</code> to illustrate that it now holds a <code>nullptr</code> <span class="ent">➎</span>.</p>&#13;
<p class="indent">Thanks to <code>SimpleUniquePointer</code>, you won’t leak a dynamically allocated object; also, because the <code>SimpleUniquePointer</code> is just carrying around a pointer under the hood, move semantics are efficient.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The <code>SimpleUniquePointer</code> is a pedagogical implementation of the stdlib’s <code>std::unique_ptr</code>, which is a member of the family of RAII templates called smart pointers. You’ll learn about these in <a href="part02.xhtml#part02">Part II</a>.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch06lev1sec6"><strong>Type Checking in Templates</strong></h3>&#13;
<p class="noindent">Templates are type safe. During template instantiation, the compiler pastes in the template parameters. If the resulting code is incorrect, the compiler will not generate the instantiation.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_162"/>Consider the template function in <a href="ch06.xhtml#ch06ex16">Listing 6-16</a>, which squares an element and returns the result.</p>&#13;
<pre>template&lt;typename T&gt;&#13;
T square(T value) {&#13;
  return value * value; <span class="ent">➊</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex16"/><em>Listing 6-16: A template function that squares a value</em></p>&#13;
<p class="indent">The <code>T</code> has a silent requirement: it must support multiplication <span class="ent">➊</span>.</p>&#13;
<p class="indent">If you try to use <code>square</code> with, say, a <code>char*</code>, the compilation will fail, as shown in <a href="ch06.xhtml#ch06ex17">Listing 6-17</a>.</p>&#13;
<pre>template&lt;typename T&gt;&#13;
T square(T value) {&#13;
  return value * value;&#13;
}&#13;
&#13;
int main() {&#13;
  char my_char{ 'Q' };&#13;
  auto result = square(&amp;my_char); <span class="ent">➊</span> // Bang!&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex17"/><em>Listing 6-17: A program with a failed template instantiation. (This program fails to compile.)</em></p>&#13;
<p class="indent">Pointers don’t support multiplication, so template initialization fails <span class="ent">➊</span>.</p>&#13;
<p class="indent">The square function is trivially small, but the failed template initialization’s error message isn’t. On MSVC v141, you get this:</p>&#13;
<pre>main.cpp(3): error C2296: '*': illegal, left operand has type 'char *'&#13;
main.cpp(8): note: see reference to function template instantiation 'T *square&lt;char*&gt;(T)' being compiled&#13;
        with&#13;
        [&#13;
            T=char *&#13;
        ]&#13;
main.cpp(3): error C2297: '*': illegal, right operand has type 'char *'</pre>&#13;
<p class="indent">And on GCC 7.3, you get this:</p>&#13;
<pre>main.cpp: In instantiation of 'T square(T) [with T = char*]':&#13;
main.cpp:8:32:   required from here&#13;
main.cpp:3:16: error: invalid operands of types 'char*' and 'char*' to binary&#13;
'operator*'&#13;
   return value * value;&#13;
          ~~~~~~^~~~~~~</pre>&#13;
<p class="indent">These error messages exemplify the notoriously cryptic error messages emitted by template initialization failures.</p>&#13;
<p class="indent">Although template instantiation ensures type safety, the checking happens very late in the compilation process. When the compiler instantiates <span epub:type="pagebreak" id="page_163"/>a template, it pastes the template parameter types into the template. After type insertion, the compiler attempts to compile the result. If instantiation fails, the compiler emits the dying words inside the template instantiation.</p>&#13;
<p class="indent">C++ template programming shares similarities with <em>duck-typed languages</em>. Duck-typed languages (like Python) defer type checking until runtime. The underlying philosophy is that if an object looks like a duck and quacks like a duck, then it must be type duck. Unfortunately, this means you can’t generally know whether an object supports a particular operation until you execute the program.</p>&#13;
<p class="indent">With templates, you cannot know whether an instantiation will succeed until you try to compile it. Although duck-typed languages might blow up at runtime, templates might blow up at compile time.</p>&#13;
<p class="indent">This situation is widely regarded as unacceptable by right-thinking people in the C++ community, so there is a splendid solution called <em>concepts</em>.</p>&#13;
<h3 class="h3" id="ch06lev1sec7"><strong>Concepts</strong></h3>&#13;
<p class="noindent"><em>Concepts</em> constrain template parameters, allowing for parameter checking at the point of instantiation rather than the point of first use. By catching usage issues at the point of instantiation, the compiler can give you a friendly, informative error code—for example, “You tried to instantiate this template with a <code>char*</code>, but this template requires a type that supports multiplication.”</p>&#13;
<p class="indent">Concepts allow you to express requirements on template parameters directly in the language.</p>&#13;
<p class="indent">Unfortunately, concepts aren’t yet officially part of the C++ standard, although they’ve been voted into C++ 20. At press time, GCC 6.0 and later support the Concepts Technical Specification, and Microsoft is actively working toward implementing concepts in its C++ compiler, MSVC. Regardless of its unofficial status, it’s worth exploring concepts in some detail for a few reasons:</p>&#13;
<ul>&#13;
<li class="noindent">They’ll fundamentally change the way you achieve compile-time polymorphism. Familiarity with concepts will pay major dividends.</li>&#13;
<li class="noindent">They provide a conceptual framework for understanding some of the makeshift solutions that you can put in place to get better compiler errors when templates are misused.</li>&#13;
<li class="noindent">They provide an excellent conceptual bridge from compile-time templates to interfaces, the primary mechanism for runtime polymorphism (covered in <a href="ch05.xhtml#ch05">Chapter 5</a>).</li>&#13;
<li class="noindent">If you can use GCC 6.0 or later, concepts <em>are</em> available by turning on the <code>-fconcepts</code> compiler flag.</li>&#13;
</ul>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>C++ 20’s final concept specification will almost certainly deviate from the Concepts Technical Specification. This section presents concepts as specified in the Concepts Technical Specification so you can follow along.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch06lev2sec10"><strong><em><span epub:type="pagebreak" id="page_164"/>Defining a Concept</em></strong></h4>&#13;
<p class="noindent">A concept is a template. It’s a constant expression involving template arguments, evaluated at compile time. Think of a concept as one big <em>predicate</em>: a function that evaluates to <code>true</code> or <code>false</code>.</p>&#13;
<p class="indent">If a set of template parameters meets the criteria for a given concept, that concept evaluates to <code>true</code> when instantiated with those parameters; otherwise, it will evaluate to <code>false</code>. When a concept evaluates to <code>false</code>, template instantiation fails.</p>&#13;
<p class="indent">You declare concepts using the keyword <code>concept</code> on an otherwise familiar template function definition:</p>&#13;
<pre>template&lt;typename T1, typename T2, ...&gt;&#13;
concept bool ConceptName() {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<h4 class="h4" id="ch06lev2sec11"><strong><em>Type Traits</em></strong></h4>&#13;
<p class="noindent">Concepts validate type parameters. Within concepts, you manipulate types to inspect their properties. You can hand roll these manipulations, or you can use the type support library built into the stdlib. The library contains utilities for inspecting type properties. These utilities are collectively called <em>type traits</em>. They’re available in the <code>&lt;type_traits&gt;</code> header and are part of the <code>std</code> namespace. <a href="ch06.xhtml#ch06tab01">Table 6-1</a> lists some commonly used type traits.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>See Chapter 5.4 of  The C++ Standard Library, 2nd Edition, by Nicolai M. Josuttis for an exhaustive listing of type traits available in the stdlib.</em></p>&#13;
</div>&#13;
<p class="tabcap" id="ch06tab01"><strong>Table 6-1:</strong> Selected Type Traits from the <code>&lt;type_traits&gt;</code> Header</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type trait</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Checks if template argument is …</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>is_void</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>void</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>is_null_pointer</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>nullptr</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>is_integral</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>bool</code>, a <code>char</code> type, an <code>int</code> type, a <code>short</code> type, a <code>long</code> type, or a <code>long long</code> type</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>is_floating_point</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>float</code>, <code>double</code>, or <code>long double</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>is_fundamental</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Any of <code>is_void</code>, <code>is_null_pointer</code>, <code>is_integral</code>, or <code>is_floating_point</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>is_array</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">An array; that is, a type containing square brackets <code>[]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>is_enum</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">An enumeration type (<code>enum</code>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>is_class</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A class type (but not a union type)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>is_function</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A function</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>is_pointer</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A pointer; function pointers count, but pointers to class members and <code>nullptr</code> do not</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>is_reference</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A reference (either lvalue or rvalue)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>is_arithmetic</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>is_floating_point</code> or <code>is_integral</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><span epub:type="pagebreak" id="page_165"/><p class="taba"><code>is_pod</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A plain-old-data type; that is, a type that can be represented as a data type in plain C</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>is_default_constructible</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Default constructible; that is, it can be constructed without arguments or initialization values</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>is_constructible</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructible with the given template parameters: this type trait allows the user to provide additional template parameters beyond the type under consideration</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>is_copy_constructible</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Copy constructible</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>is_move_constructible</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Move constructible</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>is_destructible</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Destructible</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>is_same</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The same type as the additional template parameter type (including const and volatile modifiers)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><code>is_invocable</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Invocable with the given template parameters: this type trait allows the user to provide additional template parameters beyond the type under consideration</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Each type trait is a template class that takes a single template parameter, the type you want to inspect. You extract the results using the template’s static member <code>value</code>. This member equals <code>true</code> if the type parameter meets the criteria; otherwise, it’s <code>false</code>.</p>&#13;
<p class="indent">Consider the type trait classes <code>is_integral</code> and <code>is_floating_point</code>. These are useful for checking if a type is (you guessed it) integral or floating point. Both of these templates take a single template parameter. The example in <a href="ch06.xhtml#ch06ex18">Listing 6-18</a> investigates type traits with several types.</p>&#13;
<pre>#include &lt;type_traits&gt;&#13;
#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
constexpr const char* as_str(bool x) { return x ? "True" : "False"; } <span class="ent">➊</span>&#13;
&#13;
int main() {&#13;
  printf("%s\n", as_str(std::is_integral&lt;int&gt;::value)); <span class="ent">➋</span>&#13;
  printf("%s\n", as_str(std::is_integral&lt;const int&gt;::value)); <span class="ent">➌</span>&#13;
  printf("%s\n", as_str(std::is_integral&lt;char&gt;::value)); <span class="ent">➍</span>&#13;
  printf("%s\n", as_str(std::is_integral&lt;uint64_t&gt;::value)); <span class="ent">➎</span>&#13;
  printf("%s\n", as_str(std::is_integral&lt;int&amp;&gt;::value)); <span class="ent">➏</span>&#13;
  printf("%s\n", as_str(std::is_integral&lt;int*&gt;::value)); <span class="ent">➐</span>&#13;
  printf("%s\n", as_str(std::is_integral&lt;float&gt;::value)); <span class="ent">➑</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">True <span class="ent">➋</span></span>&#13;
<span class="color1">True <span class="ent">➌</span></span>&#13;
<span class="color1">True <span class="ent">➍</span></span>&#13;
<span class="color1">True <span class="ent">➎</span></span>&#13;
<span class="color1">False <span class="ent">➏</span></span>&#13;
<span class="color1">False <span class="ent">➐</span></span>&#13;
<span class="color1">False <span class="ent">➑</span></span></pre>&#13;
<p class="listing"><a id="ch06ex18"/><em>Listing 6-18: A program using type traits</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_166"/><a href="ch06.xhtml#ch06ex18">Listing 6-18</a> defines the convenience function <code>as_str</code> <span class="ent">➊</span> to print Boolean values with the string <code>True</code> or <code>False</code>. Within <code>main</code>, you print the result of various type trait instantiations. The template parameters <code>int</code> <span class="ent">➋, const int</span> <span class="ent">➌</span>, char <span class="ent">➍</span>, and <code>uint64_t</code> <span class="ent">➎</span> all return <code>true</code> when passed to <code>is_integral</code>. Reference types <span class="ent">➏➐</span> and floating-point types <span class="ent">➑</span> return <code>false</code>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Recall that <code>printf</code> doesn’t have a format specifier for <code>bool</code>. Rather than using the integer format specifier <code>%d</code> as a stand-in, <a href="ch06.xhtml#ch06ex18">Listing 6-18</a> employs the <code>as_str</code> function, which returns the string literal <code>True</code> or <code>False</code> depending on the value of the <code>bool</code>. Because these values are string literals, you can capitalize them however you like</em>.</p>&#13;
</div>&#13;
<p class="indent">Type traits are often the building blocks for a concept, but sometimes you need more flexibility. Type traits tell you <em>what</em> types are, but sometimes you must also specify <em>how</em> the template will use them. For this, you use requirements.</p>&#13;
<h4 class="h4" id="ch06lev2sec12"><strong><em>Requirements</em></strong></h4>&#13;
<p class="noindent"><em>Requirements</em> are ad hoc constraints on template parameters. Each concept can specify any number of requirements on its template parameters. Requirements are encoded into requires expressions denoted by the <code>requires</code> keyword followed by function arguments and a body.</p>&#13;
<p class="indent">A sequence of syntactic requirements comprises the requirements expression’s body. Each syntactic requirement puts a constraint on the template parameters. Together, requires expressions have the following form:</p>&#13;
<pre>requires (<span class="codeitalic1">arg-1</span>, <span class="codeitalic1">arg-2</span>, ...<span class="ent">➊</span>) {&#13;
  { <span class="codeitalic1">expression1</span><span class="ent">➋</span> } -&gt; <span class="codeitalic1">return-type1</span><span class="ent">➌</span>;&#13;
  { <span class="codeitalic1">expression2</span> } -&gt; <span class="codeitalic1">return-type2</span>;&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="indent">Requires expressions take arguments that you place after the <code>requires</code> keyword <span class="ent">➊</span>. These arguments have types derived from template parameters. The syntactic requirements follow, each denoted with <code>{ } -&gt;</code>. You put an arbitrary expression within each of the braces <span class="ent">➋</span>. This expression can involve any number of the arguments to the argument expression.</p>&#13;
<p class="indent">If an instantiation causes a syntactic expression not to compile, that syntactic requirement fails. Supposing the expression evaluates without error, the next check is whether the return type of that expression matches the type given after the arrow <code>-&gt;</code> <span class="ent">➌</span>. If the expression result’s evaluated type can’t implicitly convert to the return type <span class="ent">➌</span>, the syntactic requirement fails.</p>&#13;
<p class="indent">If any of the syntactic requirements fail, the requires expression evaluates to <code>false</code>. If all of the syntactic requirements pass, the requires expression evaluates to <code>true</code>.</p>&#13;
<p class="indent">Suppose you have two types, <code>T</code> and <code>U</code>, and you want to know whether you can compare objects of these types using the equality <code>==</code> and inequality <code>!=</code> operators. One way to encode this requirement is to use the following expression.</p>&#13;
<pre><span epub:type="pagebreak" id="page_167"/>// T, U are types&#13;
requires (T t, U u) {&#13;
  { t == u } -&gt; bool; // syntactic requirement 1&#13;
  { u == t } -&gt; bool; // syntactic requirement 2&#13;
  { t != u } -&gt; bool; // syntactic requirement 3&#13;
  { u != t } -&gt; bool; // syntactic requirement 4&#13;
}</pre>&#13;
<p class="indent">The requires expression takes two arguments, one each of types <code>T</code> and <code>U</code>. Each of the syntactic requirements contained in the requires expression is an expression using <code>t</code> and <code>u</code> with either <code>==</code> or <code>!=</code>. All four syntactic requirements enforce a <code>bool</code> result. Any two types that satisfy this requires expression are guaranteed to support comparison with <code>==</code> and <code>!=</code>.</p>&#13;
<h4 class="h4" id="ch06lev2sec13"><strong><em>Building Concepts from Requires Expressions</em></strong></h4>&#13;
<p class="noindent">Because requires expressions are evaluated at compile time, concepts can contain any number of them. Try to construct a concept that guards against the misuse of <code>mean</code>. <a href="ch06.xhtml#ch06ex19">Listing 6-19</a> annotates some of the implicit requirements used earlier in <a href="ch06.xhtml#ch06ex10">Listing 6-10</a>.</p>&#13;
<pre>template&lt;typename T&gt;&#13;
T mean(T* values, size_t length) {&#13;
  T result{}; <span class="ent">➊</span>&#13;
  for(size_t i{}; i&lt;length; i++) {&#13;
    result <span class="ent">➋</span>+= values[i];&#13;
  }&#13;
  <span class="ent">➌</span>return result / length;&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex19"/><em>Listing 6-19: A relisting of 6-10 with annotations for some implicit requirements on <code>T</code></em></p>&#13;
<p class="indent">You can see three requirements implied by this code:</p>&#13;
<ul>&#13;
<li class="noindent"><code>T</code> must be default constructible <span class="ent">➊</span>.</li>&#13;
<li class="noindent"><code>T</code> supports <code>operator+=</code> <span class="ent">➋</span>.</li>&#13;
<li class="noindent">Dividing a <code>T</code> by a <code>size_t</code> yields a <code>T</code> <span class="ent">➌</span>.</li>&#13;
</ul>&#13;
<p class="indent">From these requirements, you could create a concept called <code>Averageable</code>, as demonstrated in <a href="ch06.xhtml#ch06ex20">Listing 6-20</a>.</p>&#13;
<pre>template&lt;typename T&gt;&#13;
concept bool Averageable() {&#13;
  return std::is_default_constructible&lt;T&gt;::value <span class="ent">➊</span>&#13;
    &amp;&amp; requires (T a, T b) {&#13;
      { a += b } -&gt; T; <span class="ent">➋</span>&#13;
      { a / size_t{ 1 } } -&gt; T; <span class="ent">➌</span>&#13;
    };&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex20"/><em>Listing 6-20: An <code>Averageable</code> concept. Annotations are consistent with the requirements and the body of <code>mean</code>.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_168"/>You use the type trait <code>is_default_constructible</code> to ensure that <code>T</code> is default constructible <span class="ent">➊</span>, that you can add two <code>T</code> types <span class="ent">➋</span>, and that you can divide a <code>T</code> by a <code>size_t</code> <span class="ent">➌</span> and get a result of type <code>T</code>.</p>&#13;
<p class="indent">Recall that concepts are just predicates; you’re building a Boolean expression that evaluates to <code>true</code> when the template parameters are supported and <code>false</code> when they’re not. The concept is composed of a type trait <span class="ent">➊</span> and a requires containing two requirement expressions <span class="ent">➋➌</span>. If any of the three returns <code>false</code>, the concept’s constraints are not met.</p>&#13;
<h4 class="h4" id="ch06lev2sec14"><strong><em>Using Concepts</em></strong></h4>&#13;
<p class="noindent">Declaring concepts is a lot more work than using them. To use a concept, just use the concept’s name in place of the <code>typename</code> keyword.</p>&#13;
<p class="indent">For example, you can refactor <a href="ch06.xhtml#ch06ex13">Listing 6-13</a> with the <code>Averageable</code> concept, as shown in <a href="ch06.xhtml#ch06ex21">Listing 6-21</a>.</p>&#13;
<pre>#include &lt;cstddef&gt;&#13;
#include &lt;type_traits&gt;&#13;
&#13;
template&lt;typename T&gt;&#13;
concept bool Averageable() { <span class="ent">➊</span>&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
template&lt;Averageable<span class="ent">➋</span> T&gt;&#13;
T mean(const T* values, size_t length) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
int main() {&#13;
  const double nums_d[] { 1.0f, 2.0f, 3.0f, 4.0f };&#13;
  const auto result1 = mean(nums_d, 4);&#13;
  printf("double: %f\n", result1);&#13;
&#13;
  const float nums_f[] { 1.0, 2.0, 3.0, 4.0 };&#13;
  const auto result2 = mean(nums_f, 4);&#13;
  printf("float: %f\n", result2);&#13;
&#13;
  const size_t nums_c[] { 1, 2, 3, 4 };&#13;
  const auto result3 = mean(nums_c, 4);&#13;
  printf("size_t: %d\n", result3);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">double: 2.500000</span>&#13;
<span class="color1">float: 2.500000</span>&#13;
<span class="color1">size_t: 2</span></pre>&#13;
<p class="listing"><a id="ch06ex21"/><em>Listing 6-21: A refactor of <a href="ch06.xhtml#ch06ex13">Listing 6-13</a> using <code>Averageable</code></em></p>&#13;
<p class="indent">After defining <code>Averageable</code> <span class="ent">➊</span>, you just use it in place of <code>typename</code> <span class="ent">➋</span>. No further modification is necessary. The code generated from compiling <a href="ch06.xhtml#ch06ex13">Listing 6-13</a> is identical to the code generated from compiling <a href="ch06.xhtml#ch06ex21">Listing 6-21</a>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_169"/>The payoff is when you get to try to use <code>mean</code> with a type that is not <code>Averageable</code>: you get a compiler error at the point of instantiation. This produces much better compiler error messages than you would obtain from a raw template.</p>&#13;
<p class="indent">Look at the instantiation of <code>mean</code> in <a href="ch06.xhtml#ch06ex22">Listing 6-22</a> where you “accidentally” try to average an array of <code>double</code> pointers.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>—&#13;
int main() {&#13;
  auto value1 = 0.0;&#13;
  auto value2 = 1.0;&#13;
  const double* values[] { &amp;value1, &amp;value2 };&#13;
  mean(values<span class="ent">➊</span>, 2);&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex22"/><em>Listing 6-22: A bad template instantiation using a non-<code>Averageable</code> argument</em></p>&#13;
<p class="indent">There are several problems with using <code>values</code> <span class="ent">➊</span>. What can the compiler tell you about those problems?</p>&#13;
<p class="indent">Without concepts, GCC 6.3 produces the error message shown in <a href="ch06.xhtml#ch06ex23">Listing 6-23</a>.</p>&#13;
<pre>&lt;source&gt;: In instantiation of 'T mean(const T*, size_t) [with T = const&#13;
double*; size_t = long unsigned int]':&#13;
&lt;source&gt;:17:17:   required from here&#13;
&lt;source&gt;:8:12: error: invalid operands of types 'const double*' and 'const&#13;
double*' to binary 'operator+'&#13;
     result += values[i]; <span class="ent">➊</span>&#13;
     ~~~~~~~^~~~~~~~~~&#13;
&lt;source&gt;:8:12: error:   in evaluation of 'operator+=(const double*, const&#13;
double*)'&#13;
&lt;source&gt;:10:17: error: invalid operands of types 'const double*' and 'size_t'&#13;
{aka 'long unsigned int'} to binary 'operator/'&#13;
   return result / length; <span class="ent">➋</span>&#13;
          ~~~~~~~^~~~~~~~</pre>&#13;
<p class="listing"><a id="ch06ex23"/><em>Listing 6-23: Error message from GCC 6.3 when compiling <a href="ch06.xhtml#ch06ex22">Listing 6-22</a></em></p>&#13;
<p class="indent">You might expect a casual user of <code>mean</code> to be extremely confused by this error message. What is <code>i</code> <span class="ent">➊</span>? Why is a <code>const double*</code> involved in division <span class="ent">➋</span>?</p>&#13;
<p class="indent">Concepts provide a far more illuminating error message, as <a href="ch06.xhtml#ch06ex24">Listing 6-24</a> demonstrates.</p>&#13;
<pre>&lt;source&gt;: In function 'int main()':&#13;
&lt;source&gt;:28:17: error: cannot call function 'T mean(const T*, size_t) [with T&#13;
= const double*; size_t = long unsigned int]'&#13;
   mean(values, 2); <span class="ent">➊</span>&#13;
                 ^&#13;
&lt;source&gt;:16:3: note:   constraints not satisfied&#13;
 T mean(const T* values, size_t length) {&#13;
   ^~~~&#13;
&#13;
&lt;source&gt;:6:14: note: within 'template&lt;class T&gt; concept bool Averageable()&#13;
[with T = const double*]'&#13;
 <span epub:type="pagebreak" id="page_170"/>concept bool Averageable() {&#13;
              ^~~~~~~~~~~&#13;
&lt;source&gt;:6:14: note:     with 'const double* a'&#13;
&lt;source&gt;:6:14: note:     with 'const double* b'&#13;
&lt;source&gt;:6:14: note: the required expression '(a + b)' would be ill-formed <span class="ent">➋</span>&#13;
&lt;source&gt;:6:14: note: the required expression '(a / b)' would be ill-formed <span class="ent">➌</span></pre>&#13;
<p class="listing"><a id="ch06ex24"/><em>Listing 6-24: Error message from GCC 7.2 when compiling <a href="ch06.xhtml#ch06ex22">Listing 6-22</a> with concepts enabled</em></p>&#13;
<p class="indent">This error message is fantastic. The compiler tells you which argument (<code>values</code>) didn’t meet a constraint <span class="ent">➊</span>. Then it tells you that <code>values</code> is not <code>Averageable</code> because it doesn’t satisfy two required expressions <span class="ent">➋➌</span>. You know immediately how to modify your arguments to make this template instantiation successful.</p>&#13;
<p class="indent">When concepts incorporate into the C++ standard, it’s likely that the stdlib will include many concepts. The design goal of concepts is that a programmer shouldn’t have to define very many concepts on their own; rather, they should be able to combine concepts and ad hoc requirements within a template prefix. <a href="ch06.xhtml#ch06tab02">Table 6-2</a> provides a partial listing of some concepts you might expect to be included; these are borrowed from Andrew Sutton’s implementation of concepts in the Origins Library.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>See <a href="https://github.com/asutton/origin/">https://github.com/asutton/origin/</a> for more information on the Origins Library. To compile the examples that follow, you can install Origins and use GCC version 6.0 or later with the <code>-fconcepts</code> flag.</em></p>&#13;
</div>&#13;
<p class="tabcap" id="ch06tab02"><strong>Table 6-2:</strong> The Concepts Contained in the Origins Library</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Concept</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>A type that …</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>Conditional</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Can be explicitly converted to <code>bool</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>Boolean</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Is <code>Conditional</code> and supports <code>!</code>, <code>&amp;&amp;</code>, and <code>||</code> Boolean operations</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>Equality_comparable</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Supports <code>==</code> and <code>!=</code> operations returning a <code>Boolean</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>Destructible</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Can be destroyed (compare <code>is_destructible</code>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>Default_constructible</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Is default constructible (compare <code>is_default_constructible</code>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>Movable</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Supports move semantics: it must be move assignable and move constructible (compare <code>is_move_assignable</code>, <code>is_move_constructible</code>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>Copyable</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Supports copy semantics: it must be copy assignable and copy constructible (compare <code>is_copy_assignable</code>, <code>is_copy_constructible</code>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>Regular</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Is default constructible, copyable, and <code>Equality_comparable</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>Ordered</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Is <code>Regular</code> and is totally ordered (essentially, it can be sorted)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>Number</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Is <code>Ordered</code> and supports math operations like <code>+</code>, <code>-</code>, <code>/</code>, and <code>*</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><code>Function</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Supports invocation; that is, you can call it (compare <code>is_invocable</code>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><code>Predicate</code></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Is a <code>Function</code> and returns <code>bool</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><code>Range</code></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Can be iterated over in a range-based <code>for</code> loop</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_171"/>There are several ways to build constraints into a template prefix. If a template parameter is only used to declare the type of a function parameter, you can omit the template prefix entirely:</p>&#13;
<pre>return-type function-name(Concept1<span class="ent">➊</span> arg-1, …) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="indent">Because you use a concept rather than a <code>typename</code> to define an argument’s type <span class="ent">➊</span>, the compiler knows that the associated function is a template. You are even free to mix concepts and concrete types in the argument list. In other words, whenever you use a concept as part of a function definition, that function becomes a template.</p>&#13;
<p class="indent">The template function in <a href="ch06.xhtml#ch06ex25">Listing 6-25</a> takes an array of <code>Ordered</code> elements and finds the minimum.</p>&#13;
<pre>#include &lt;origin/core/concepts.hpp&gt;&#13;
size_t index_of_minimum(Ordered<span class="ent">➊</span>* x, size_t length) {&#13;
  size_t min_index{};&#13;
  for(size_t i{ 1 }; i&lt;length; i++) {&#13;
    if(x[i] &lt; x[min_index]) min_index = i;&#13;
  }&#13;
  return min_index;&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex25"/><em>Listing 6-25: A template function using the <code>Ordered</code> concept</em></p>&#13;
<p class="indent">Even though there’s no template prefix, <code>index_of_minimum</code> is a template because <code>Ordered</code> <span class="ent">➊</span> is a concept. This template can be instantiated in the same way as any other template function, as demonstrated in <a href="ch06.xhtml#ch06ex26">Listing 6-26</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
#include &lt;origin/core/concepts.hpp&gt;&#13;
&#13;
struct Goblin{};&#13;
&#13;
size_t index_of_minimum(Ordered* x, size_t length) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
int main() {&#13;
  int x1[] { -20, 0, 100, 400, -21, 5123 };&#13;
  printf("%zu\n", index_of_minimum(x1, 6)); <span class="ent">➊</span>&#13;
&#13;
  unsigned short x2[] { 42, 51, 900, 400 };&#13;
  printf("%zu\n", index_of_minimum(x2, 4)); <span class="ent">➋</span>&#13;
&#13;
  Goblin x3[] { Goblin{}, Goblin{} };&#13;
  //index_of_minimum(x3, 2); <span class="ent">➌</span> // Bang! Goblin is not Ordered.&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span epub:type="pagebreak" id="page_172"/><span class="color1">4 <span class="ent">➊</span></span>&#13;
<span class="color1">0 <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch06ex26"/><em>Listing 6-26: A listing employing <code>index_of_minimum</code> from <a href="ch06.xhtml#ch06ex25">Listing 6-25</a>. Uncommenting</em> <span class="ent">➌</span> <em>causes compilation to fail.</em></p>&#13;
<p class="indent">The instantiations for <code>int</code> <span class="ent">➊</span> and <code>unsigned short</code> <span class="ent">➋</span> arrays succeed because types are <code>Ordered</code> (see <a href="ch06.xhtml#ch06tab02">Table 6-2</a>).</p>&#13;
<p class="indent">However, the <code>Goblin</code> class is not <code>Ordered</code>, and template instantiation would fail if you tried to compile <span class="ent">➌</span>. Crucially, the error message would be informative:</p>&#13;
<pre>error: cannot call function 'size_t index_&#13;
of_minimum(auto:1*, size_t) [with auto:1 = Goblin; size_t = long unsigned int]'&#13;
   index_of_minimum(x3, 2); // Bang! Goblin is not Ordered.&#13;
                         ^&#13;
note:   constraints not satisfied&#13;
 size_t index_of_minimum(Ordered* x, size_t length) {&#13;
        ^~~~~~~~~~~~~~~~&#13;
&#13;
note: within 'template&lt;class T&gt; concept bool origin::Ordered() [with T =&#13;
Goblin]'&#13;
 Ordered()</pre>&#13;
<p class="indent">You know that the <code>index_of_minimum</code> instantiation failed and that the issue is with the <code>Ordered</code> concept.</p>&#13;
<h4 class="h4" id="ch06lev2sec15"><strong><em>Ad Hoc Requires Expressions</em></strong></h4>&#13;
<p class="noindent">Concepts are fairly heavyweight mechanisms for enforcing type safety. Sometimes, you just want to enforce some requirement directly in the template prefix. You can embed requires expressions directly into the template definition to accomplish this. Consider the <code>get_copy</code> function in <a href="ch06.xhtml#ch06ex27">Listing 6-27</a> that takes a pointer and safely returns a copy of the pointed-to object.</p>&#13;
<pre>#include &lt;stdexcept&gt;&#13;
&#13;
template&lt;typename T&gt;&#13;
  requires<span class="ent">➊</span> is_copy_constructible&lt;T&gt;::value <span class="ent">➋</span>&#13;
T get_copy(T* pointer) {&#13;
  if (!pointer) throw std::runtime_error{ "Null-pointer dereference" };&#13;
  return *pointer;&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex27"/><em>Listing 6-27: A template function with an ad hoc requires expression</em></p>&#13;
<p class="indent">The template prefix contains the <code>requires</code> keyword <span class="ent">➊</span>, which begins the requires expression. In this case, the type trait <code>is_copy_constructible</code> ensures that <code>T</code> is copyable <span class="ent">➋</span>. This way, if a user accidentally tries to <code>get_copy</code> with a pointer that points to an uncopyable object, they’ll be presented with a clear explanation of why template instantiation failed. Consider the example in <a href="ch06.xhtml#ch06ex28">Listing 6-28</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_173"/>#include &lt;stdexcept&gt;&#13;
#include &lt;type_traits&gt;&#13;
&#13;
template&lt;typename T&gt;&#13;
  requires std::is_copy_constructible&lt;T&gt;::value&#13;
T get_copy(T* pointer) { <span class="ent">➊</span>&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
struct Highlander {&#13;
  Highlander() = default; <span class="ent">➋</span>&#13;
  Highlander(const Highlander&amp;) = delete; <span class="ent">➌</span>&#13;
};&#13;
&#13;
int main() {&#13;
  Highlander connor; <span class="ent">➍</span>&#13;
  auto connor_ptr = &amp;connor; <span class="ent">➎</span>&#13;
  auto connor_copy = get_copy(connor_ptr); <span class="ent">➏</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">In function 'int main()':</span>&#13;
<span class="color1">error: cannot call function 'T get_copy(T*) [with T = Highlander]'</span>&#13;
   <span class="color1">auto connor_copy = get_copy(connor_ptr);</span>&#13;
                                         <span class="color1">^</span>&#13;
<span class="color1">note:   constraints not satisfied</span>&#13;
 <span class="color1">T get_copy(T* pointer) {</span>&#13;
   <span class="color1">^~~~~~~~</span>&#13;
&#13;
<span class="color1">note: 'std::is_copy_constructible::value' evaluated to false</span></pre>&#13;
<p class="listing"><a id="ch06ex28"/><em>Listing 6-28: Program using the <code>get_copy</code> template in <a href="ch06.xhtml#ch06ex27">Listing 6-27</a>. This code doesn’t compile.</em></p>&#13;
<p class="indent">The definition of <code>get_copy</code> <span class="ent">➊</span> is followed by a <code>Highlander</code> class definition, which contains a default constructor <span class="ent">➋</span> and a deleted copy constructor <span class="ent">➌</span>. Within <code>main</code>, you’ve initialized a <code>Highlander</code> <span class="ent">➍</span>, taken its reference <span class="ent">➎</span>, and attempted to instantiate <code>get_copy</code> with the result <span class="ent">➏</span>. Because there can be only one <code>Highlander</code> (it’s not copyable), <a href="ch06.xhtml#ch06ex28">Listing 6-28</a> produces an exquisitely clear error message.</p>&#13;
<h3 class="h3" id="ch06lev1sec8"><strong>static_assert: The Preconcepts Stopgap</strong></h3>&#13;
<p class="noindent">As of C++17, concepts aren’t part of the standard, so they’re not guaranteed to be available across compilers. There is a stopgap you can apply in the interim: the <code>static_assert</code> expression. These assertions evaluate at compile time. If an assertion fails, the compiler will issue an error and optionally provide a diagnostic message. A <code>static_assert</code> has the following form:</p>&#13;
<pre>static_assert(boolean-expression, optional-message);</pre>&#13;
<p class="indent">In the absence of concepts, you can include one or more <code>static_assert</code> expressions in the bodies of templates to assist users in diagnosing usage errors.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_174"/>Suppose you want to improve the error messages of <code>mean</code> without leaning on concepts. You can use type traits in combination with <code>static_assert</code> to achieve a similar result, as demonstrated in <a href="ch06.xhtml#ch06ex29">Listing 6-29</a>.</p>&#13;
<pre>#include &lt;type_traits&gt;&#13;
&#13;
template &lt;typename T&gt;&#13;
T mean(T* values, size_t length) {&#13;
  static_assert(std::is_default_constructible&lt;T&gt;(),&#13;
    "Type must be default constructible."); <span class="ent">➊</span>&#13;
  static_assert(std::is_copy_constructible&lt;T&gt;(),&#13;
    "Type must be copy constructible."); <span class="ent">➋</span>&#13;
  static_assert(std::is_arithmetic&lt;T&gt;(),&#13;
    "Type must support addition and division."); <span class="ent">➌</span>&#13;
  static_assert(std::is_constructible&lt;T, size_t&gt;(),&#13;
    "Type must be constructible from size_t."); <span class="ent">➍</span>&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex29"/><em>Listing 6-29: Using <code>static_assert</code> expressions to improve compile time errors in <code>mean</code> in <a href="ch06.xhtml#ch06ex10">Listing 6-10</a>.</em></p>&#13;
<p class="indent">You see the familiar type traits for checking that <code>T</code> is default <span class="ent">➊</span> and copy constructible <span class="ent">➋</span>, and you provide error methods to help users diagnose issues with template instantiation. You use <code>is_arithmetic</code> <span class="ent">➌</span>, which evaluates to <code>true</code> if the type parameter supports arithmetic operations (<code>+, -, /</code>, and <code>*</code>), and <code>is_constructible</code> <span class="ent">➍</span>, which determines whether you can construct a <code>T</code> from a <code>size_t</code>.</p>&#13;
<p class="indent">Using <code>static_assert</code> as a proxy for concepts is a hack, but it’s widely used. Using type traits, you can limp along until concepts are included in the standard. You’ll often see <code>static_assert</code> if you use modern third-party libraries; if you’re writing code for others (including future you), consider using <code>static_assert</code> and type traits.</p>&#13;
<p class="indent">Compilers, and often programmers, don’t read documentation. By baking requirements directly into the code, you can avoid stale documentation. In the absence of concepts, <code>static_assert</code> is a fine stopgap.</p>&#13;
<h3 class="h3" id="ch06lev1sec9"><strong>Non-Type Template Parameters</strong></h3>&#13;
<p class="noindent">A template parameter declared with the <code>typename</code> (or <code>class</code>) keyword is called a <em>type template parameter</em>, which is a stand-in for some yet-to-be-specified <em>type</em>. Alternatively, you can use <em>non-type template parameters</em>, which are stand-ins for some yet-to-be-specified <em>value</em>. Non-type template parameters can be any of the following:</p>&#13;
<ul>&#13;
<li class="noindent">An integral type</li>&#13;
<li class="noindent">An lvalue reference type</li>&#13;
<li class="noindent">A pointer (or pointer-to-member) type</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_175"/>A <code>std::nullptr_t</code> (the type of <code>nullptr</code>)</li>&#13;
<li class="noindent">An <code>enum class</code></li>&#13;
</ul>&#13;
<p class="indent">Using a non-type template parameter allows you to inject a value into the generic code at compile time. For example, you can construct a template function called <code>get</code> that checks for out-of-bounds array access at compile time by taking the index you want to access as a non-type template parameter.</p>&#13;
<p class="indent">Recall from <a href="ch03.xhtml#ch03">Chapter 3</a> that if you pass an array to a function, it decays into a pointer. You can instead pass an array reference with a particularly off-putting syntax:</p>&#13;
<pre><span class="codeitalic1">element-type</span>(<span class="codeitalic1">¶m-name</span>)[<span class="codeitalic1">array-length</span>]</pre>&#13;
<p class="indent">For example, <a href="ch06.xhtml#ch06ex30">Listing 6-30</a> contains a <code>get</code> function that makes a first attempt at performing bounds-checked array access.</p>&#13;
<pre>#include &lt;stdexcept&gt;&#13;
&#13;
int&amp; get(int (&amp;arr)[10]<span class="ent">➊</span>, size_t index<span class="ent">➋</span>) {&#13;
  if (index &gt;= 10) throw std::out_of_range{ "Out of bounds" }; <span class="ent">➌</span>&#13;
  return arr[index]; <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex30"/><em>Listing 6-30: A function for accessing array elements with bounds checking</em></p>&#13;
<p class="indent">The <code>get</code> function accepts a reference to an <code>int</code> array of length 10 <span class="ent">➊</span> and an <code>index</code> to extract <span class="ent">➋</span>. If <code>index</code> is out of bounds, it throws an <code>out_of_bounds</code> exception <span class="ent">➌</span>; otherwise, it returns a reference to the corresponding element <span class="ent">➍</span>.</p>&#13;
<p class="indent">You can improve <a href="ch06.xhtml#ch06ex30">Listing 6-30</a> in three ways, which are all enabled by non-type template parameters genericizing the values out of <code>get</code>.</p>&#13;
<p class="indent">First, you can relax the requirement that <code>arr</code> refer to an <code>int</code> array by making <code>get</code> a template function, as in <a href="ch06.xhtml#ch06ex31">Listing 6-31</a>.</p>&#13;
<pre>#include &lt;stdexcept&gt;&#13;
&#13;
template &lt;typename T<span class="ent">➊</span>&gt;&#13;
T&amp;<span class="ent">➋</span> get(T<span class="ent">➌</span> (&amp;arr)[10], size_t index) {&#13;
  if (index &gt;= 10) throw std::out_of_range{ "Out of bounds" };&#13;
  return arr[index];&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex31"/><em>Listing 6-31: A refactor of <a href="ch06.xhtml#ch06ex30">Listing 6-30</a> to accept an array of a generic type</em></p>&#13;
<p class="indent">As you’ve done throughout this chapter, you’ve genericized the function by replacing a concrete type (here, <code>int</code>) with a template parameter <span class="ent">➊➋➌</span>.</p>&#13;
<p class="indent">Second, you can relax the requirement that <code>arr</code> refer to an array of length 10 by introducing a non-type template parameter <code>Length</code>. <a href="ch06.xhtml#ch06ex32">Listing 6-32</a> shows how: simply declare a <code>size_t Length</code> template parameter and use it in place of 10.</p>&#13;
<pre><span epub:type="pagebreak" id="page_176"/>#include &lt;stdexcept&gt;&#13;
&#13;
template &lt;typename T, size_t Length<span class="ent">➊</span>&gt;&#13;
T&amp; get (T(&amp;arr)[Length<span class="ent">➋</span>], size_t index) {&#13;
  if (index &gt;= Length<span class="ent">➌</span>) throw std::out_of_range{ "Out of bounds" };&#13;
  return arr[index];&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex32"/><em>Listing 6-32: A refactor of <a href="ch06.xhtml#ch06ex31">Listing 6-31</a> to accept an array of a generic length</em></p>&#13;
<p class="indent">The idea is the same: rather than replacing a specific type (<code>int</code>), you’ve replaced a specific integral value (<code>10</code>) <span class="ent">➊➋➌</span>. Now you can use the function with arrays of any size.</p>&#13;
<p class="indent">Third, you can perform compile time bounds checking by taking <code>size_t index</code> as another non-type template parameter. This allows you to replace the <code>std::out_of_range</code> with a <code>static_assert</code>, as in <a href="ch06.xhtml#ch06ex33">Listing 6-33</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
template &lt;size_t Index<span class="ent">➊</span>, typename T, size_t Length&gt;&#13;
T&amp; get(T (&amp;arr)[Length]) {&#13;
  static_assert(Index &lt; Length, "Out-of-bounds access"); <span class="ent">➋</span>&#13;
  return arr[Index<span class="ent">➌</span>];&#13;
}&#13;
&#13;
int main() {&#13;
  int fib[]{ 1, 1, 2, 0 }; <span class="ent">➍</span>&#13;
  printf("%d %d %d ", get&lt;0&gt;(fib), get&lt;1&gt;(fib), get&lt;2&gt;(fib)); <span class="ent">➎</span>&#13;
  get&lt;3&gt;(fib) = get&lt;1&gt;(fib) + get&lt;2&gt;(fib); <span class="ent">➏</span>&#13;
  printf("%d", get&lt;3&gt;(fib)); <span class="ent">➐</span>&#13;
  //printf("%d", get&lt;4&gt;(fib)); <span class="ent">➑</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">1 1 2 <span class="ent">➎</span>3 <span class="ent">➐</span></span></pre>&#13;
<p class="listing"><a id="ch06ex33"/><em>Listing 6-33: A program using compile time bounds-checked array accesses</em></p>&#13;
<p class="indent">You’ve moved the <code>size_t</code> index parameter into a non-type template parameter <span class="ent">➊</span> and updated the array access with the correct name <code>Index</code> <span class="ent">➌</span>. Because <code>Index</code> is now a compile time constant, you also replace the <code>logic_error</code> with a <code>static_assert</code>, which prints the friendly message <code>Out-of-bounds access</code> whenever you accidentally try to access an out-of-bounds element <span class="ent">➋</span>.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06ex33">Listing 6-33</a> also contains example usage of get in <code>main</code>. You’ve first declared an <code>int</code> array <code>fib</code> of length 4 <span class="ent">➍</span>. You then print the first three elements of the array using <code>get</code> <span class="ent">➎</span>, set the fourth element <span class="ent">➏</span>, and print it <span class="ent">➐</span>. If you uncomment the out-of-bounds access <span class="ent">➑</span>, the compiler will generate an error thanks to the <code>static_assert</code>.</p>&#13;
<h3 class="h3" id="ch06lev1sec10"><strong>Variadic Templates</strong></h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_177"/>Sometimes, templates must take in an unknown number of arguments. The compiler knows these arguments at template instantiation, but you want to avoid having to write many different templates each for different numbers of arguments. This is the raison d’être of variadic templates. <em>Variadic templates</em> take a variable number of arguments.</p>&#13;
<p class="indent">You denote variadic templates using a final template parameter that has a special syntax, namely <code>typename... arguments</code>. The ellipsis indicates that <code>arguments</code> is a <em>parameter pack type</em>, meaning you can declare parameter packs within your template. A parameter pack is a template argument that accepts zero or more function arguments. These definitions can seem a bit abstruse, so consider the following sample variadic template that builds upon <code>SimpleUniquePointer</code>.</p>&#13;
<p class="indent">Recall from <a href="ch06.xhtml#ch06ex14">Listing 6-14</a> that you pass a raw pointer into the constructor of <code>SimpleUniquePointer</code>. <a href="ch06.xhtml#ch06ex34">Listing 6-34</a> implements a <code>make_simple_unique</code> function that handles construction of the underlying type.</p>&#13;
<pre>template &lt;typename T, typename... Arguments<span class="ent">➊</span>&gt;&#13;
SimpleUniquePointer&lt;T&gt; make_simple_unique(Arguments... arguments<span class="ent">➋</span>) {&#13;
  return SimpleUniquePointer&lt;T&gt;{ new T{ arguments...<span class="ent">➌</span> } };&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex34"/><em>Listing 6-34: Implementing a <code>make_simple_unique</code> function to ease <code>SimpleUniquePointer</code> usage</em></p>&#13;
<p class="indent">You define the parameter pack type <code>Arguments</code> <span class="ent">➊</span>, which declares <code>make_simple_unique</code> as a variadic template. This function passes arguments <span class="ent">➋</span> to the constructor of template parameter <code>T</code> <span class="ent">➌</span>.</p>&#13;
<p class="indent">The upshot is you can now create <code>SimpleUniquePointers</code> very easily, even when the pointed-to object has a non-default constructor.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>There is a slightly more efficient implementation of <a href="ch06.xhtml#ch06ex34">Listing 6-34</a>. If <code>arguments</code> is an rvalue, you can move it directly into the constructor of <code>T</code>. The stdlib contains a function called <code>std::forward</code> in the <code>&lt;utility&gt;</code> header that will detect whether <code>arguments</code> is an lvalue or rvalue and perform a copy or move, respectively. See Item 23 in Effective Modern C++ by Scott Meyers.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch06lev1sec11"><strong>Advanced Template Topics</strong></h3>&#13;
<p class="noindent">For everyday polymorphic programming, templates are your go-to tool. It turns out that templates are also used in a wide range of advanced settings, especially in implementing libraries, high-performance programs, and embedded system firmware. This section outlines some of the major terrain features of this vast space.</p>&#13;
<h4 class="h4" id="ch06lev2sec16"><span epub:type="pagebreak" id="page_178"/><strong><em>Template Specialization</em></strong></h4>&#13;
<p class="noindent">To understand advanced template usage, you must first understand <em>template specialization</em>. Templates can actually take more than just <code>concept</code> and <code>typename</code> parameters (type parameters). They can also accept fundamental types, like <code>char</code> (value parameters), as well as other templates. Given the tremendous flexibility of template parameters, you can make a lot of compile-time decisions about their features. You could have different versions of templates depending on the characteristics of these parameters. For example, if a type parameter is <code>Ordered</code> instead of <code>Regular</code>, you might be able to make a generic program more efficient. Programming this way is called <em>template specialization</em>. Refer to the ISO standard [temp.spec] for more information about template specialization.</p>&#13;
<h4 class="h4" id="ch06lev2sec17"><strong><em>Name Binding</em></strong></h4>&#13;
<p class="noindent">Another critical component of how templates get instantiated is name binding. Name binding helps determine the rules for when the compiler matches a named element within a template to a concrete implementation. The named element could, for example, be part of the template definition, a local name, a global name, or from some named namespace. If you want to write heavily templated code, you need to understand how this binding occurs. If you’re in such a situation, refer to <a href="ch09.xhtml#ch09">Chapter 9</a>, “Names in Templates,” in <em>C++ Templates: The Complete Guide</em> by David Vandevoorde et al. and to [temp.res].</p>&#13;
<h4 class="h4" id="ch06lev2sec18"><strong><em>Type Function</em></strong></h4>&#13;
<p class="noindent">A <em>type function</em> takes types as arguments and returns a type. The type traits with which you build up concepts are closely related to type functions. You can combine type functions with compile time control structures to do general computation, such as programming control flow, at compile time. Generally, programming using these techniques is called <em>template metaprogramming</em>.</p>&#13;
<h4 class="h4" id="ch06lev2sec19"><strong><em>Template Metaprogramming</em></strong></h4>&#13;
<p class="noindent">Template metaprogramming has a deserved reputation for resulting in code that is exceedingly clever and absolutely inscrutable to all but the mightiest of wizards. Fortunately, once concepts are part of the C++ standard, template metaprogramming should become more approachable to us mere mortals. Until then, tread carefully. For those interested in further detail on this topic, refer to <em>Modern C++ Design: Generic Programming and Design Patterns Applied</em> by Andrei Alexandrescu and <em>C++ Templates: The Complete Guide</em> by David Vandevoorde et al.</p>&#13;
<h3 class="h3" id="ch06lev1sec12"><span epub:type="pagebreak" id="page_179"/><strong>Template Source Code Organization</strong></h3>&#13;
<p class="noindent">Each time a template is instantiated, the compiler must be able to generate all the code necessary to use the template. This means all the information about how to instantiate a custom class or function must be available within the same translation unit as the template instantiation. By far, the most popular way to achieve this is to implement templates entirely within header files.</p>&#13;
<p class="indent">There are some modest inconveniences associated with this approach. Compile times can increase, because templates with the same parameters might get instantiated multiple times. It also decreases your ability to hide implementation details. Fortunately, the benefits of generic programming far outweigh these inconveniences. (Major compilers will probably minimize the problems of compile times and code duplication anyway.)</p>&#13;
<p class="indent">There are even a few advantages to having header-only templates:</p>&#13;
<ul>&#13;
<li class="noindent">It’s very easy for others to use your code: it’s a matter of applying <code>#include</code> to some headers (rather than compiling the library, ensuring the resulting object files are visible to the linker, and so on).</li>&#13;
<li class="noindent">It’s trivially easy for compilers to inline header-only templates, which can lead to faster code at runtime.</li>&#13;
<li class="noindent">Compilers can generally do a better job of optimizing code when all of the source is available.</li>&#13;
</ul>&#13;
<h3 class="h3" id="ch06lev1sec13"><strong>Polymorphism at Runtime vs. Compile Time</strong></h3>&#13;
<p class="noindent">When you want polymorphism, you should use templates. But sometimes you can’t use templates because you won’t know the types used with your code until runtime. Remember that template instantiation only occurs when you pair a template’s parameters with types. At this point, the compiler can instantiate a custom class for you. In some situations, you might not be able to perform such pairings until your program is executing (or, at least, performing such pairing at compile time would be tedious).</p>&#13;
<p class="indent">In such cases, you can use runtime polymorphism. Whereas the template is the mechanism for achieving compile-time polymorphism, the runtime mechanism is the interface.</p>&#13;
<h3 class="h3" id="ch06lev1sec14"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you explored polymorphism in C++. The chapter started with a discussion of what polymorphism is and why it’s so tremendously useful. You explored how to achieve polymorphism at compile time with templates. You learned about type checking with concepts and then explored some advanced topics, such as variadic templates and template metaprogramming.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_180"/><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>6-1.</strong> The mode of a series of values is the value that appears most commonly. Implement a mode function using the following signature: <code>int mode(constint* values, size_t length)</code>. If you encounter an error condition, such as input having multiple modes and no values, return zero.</p>&#13;
<p class="noindent"><strong>6-2.</strong> Implement <code>mode</code> as a template function.</p>&#13;
<p class="noindent"><strong>6-3.</strong> Modify mode to accept an <code>Integer</code> concept. Verify that mode fails to instantiate with floating types like  <code>double</code>.</p>&#13;
<p class="noindent"><strong>6-4.</strong> Refactor <code>mean</code> in <a href="ch06.xhtml#ch06ex13">Listing 6-13</a> to accept an array rather than pointer and length arguments. Use <a href="ch06.xhtml#ch06ex33">Listing 6-33</a> as a guide.</p>&#13;
<p class="noindent"><strong>6-5.</strong> Using the example from <a href="ch05.xhtml#ch05">Chapter 5</a>, make <code>Bank</code> a template class that accepts a template parameter. Use this type parameter as the type of an account rather than  <code>long</code>. Verify that your code still works using a <code>Bank&lt;long&gt;</code> class.</p>&#13;
<p class="noindent"><strong>6-6.</strong> Implement an <code>Account</code> class and instantiate a  <code>Bank&lt;Account&gt;</code>. Implement functions in <code>Account</code> to keep track of balances.</p>&#13;
<p class="noindent"><strong>6-7.</strong> Make <code>Account</code> an interface. Implement a  <code>CheckingAccount</code> and  <code>SavingsAccount</code>. Create a program with several checking and savings accounts. Use a <code>Bank&lt;Account&gt;</code> to make several transactions between the accounts.</p>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>C++ Templates: The Complete Guide</em>, 2nd Edition, by David Vandevoorde, Nicolai M. Josuttis, and Douglas Gregor (Addison-Wesley, 2017)</li>&#13;
<li class="noindent"><em>Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14</em> by Scott Meyers (O’Reilly Media, 2015)</li>&#13;
<li class="noindent"><em>The C++ Programming Language</em>, 4th Edition, by Bjarne Stroustrup (Pearson Education, 2013)</li>&#13;
<li class="noindent"><em>Modern C++ Design: Generic Programming and Design Patterns Applied</em> by Andrei Alexandrescu (Addison-Wesley, 2001)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>