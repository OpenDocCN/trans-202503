<html><head></head><body>
<h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_149"/><strong><span class="big">6</span><br/>COMPILE-TIME POLYMORPHISM</strong></h2>&#13;
<p class="quote"><em>The more adapt, the more interesting you are.<br/>—Martha Stewart</em></p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">In this chapter, you’ll learn how to achieve compile-time polymorphism with templates. You’ll learn how to declare and use templates, enforce type safety, and survey some of the templates’ more advanced usages. This chapter concludes with a comparison of runtime and compile-time polymorphism in C++.</p>&#13;
<h3 class="h3" id="ch06lev1sec1"><strong>Templates</strong></h3>&#13;
<p class="noindent">C++ achieves compile-time polymorphism through <em>templates</em>. A template is a class or function with template parameters. These parameters can stand in for any type, including fundamental and user-defined types. When the compiler sees a template used with a type, it stamps out a bespoke template instantiation.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_150"/><em>Template instantiation</em> is the process of creating a class or a function from a template. Somewhat confusingly, you can also refer to “a template instantiation” as the result of the template instantiation process. Template instantiations are sometimes called concrete classes and concrete types.</p>&#13;
<p class="indent">The big idea is that, rather than copying and pasting common code all over the place, you write a single template; the compiler generates new template instances when it encounters a new combination of types in the template parameters.</p>&#13;
<h3 class="h3" id="ch06lev1sec2"><strong>Declaring Templates</strong></h3>&#13;
<p class="noindent">You declare templates with a <em>template prefix</em>, which consists of the keyword <span class="literal">template</span> followed by angle brackets <span class="literal">&lt; &gt;</span>. Within the angle brackets, you place the declarations of one or more template parameters. You can declare template parameters using either the <span class="literal">typename</span> or <span class="literal">class</span> keywords followed by an identifier. For example, the template prefix <span class="literal">template&lt;typename T&gt;</span> declares that the template takes a template parameter <span class="literal">T</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The coexistence of the <span class="literal">typename</span> and <span class="literal">class</span> keywords is unfortunate and confusing. They mean the same thing. (They’re both supported for historical reasons.) This chapter always uses <span class="literal">typename</span>.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch06lev2sec1"><strong><em>Template Class Definitions</em></strong></h4>&#13;
<p class="noindent">Consider <span class="literal">MyTemplateClass</span> in <a href="ch06.xhtml#ch06ex01">Listing 6-1</a>, which takes three template parameters: <span class="literal">X, Y</span>, and <span class="literal">Z</span>.</p>&#13;
<pre>template<span class="ent">➊</span>&lt;typename X, typename Y, typename Z&gt; <span class="ent">➋</span>&#13;
struct MyTemplateClass<span class="ent">➌</span> {&#13;
  X foo(Y&amp;); <span class="ent">➍</span>&#13;
private:&#13;
  Z* member; <span class="ent">➎</span>&#13;
};</pre>&#13;
<p class="listing"><a id="ch06ex01"/><em>Listing 6-1: A template class with three template parameters</em></p>&#13;
<p class="indent">The <span class="literal">template</span> keyword <span class="ent">➊</span> begins the template prefix, which contains the template parameters <span class="ent">➋</span>. This <span class="literal">template</span> preamble leads to something special about the remaining declaration of <span class="literal">MyTemplateClass</span> <span class="ent">➌</span>. Within <span class="literal">MyTemplateClass</span>, you use <span class="literal">X, Y</span>, and <span class="literal">Z</span> as if they were any fully specified type, like an <span class="literal">int</span> or a user-defined class.</p>&#13;
<p class="indent">The <span class="literal">foo</span> method takes a <span class="literal">Y</span> reference and returns an <span class="literal">X</span> <span class="ent">➍</span>. You can declare members with types that include template parameters, like a pointer to <span class="literal">Z</span> <span class="ent">➎</span>. Besides the special prefix beginning <span class="ent">➊</span>, this template class is essentially identical to a non-template class.</p>&#13;
<h4 class="h4" id="ch06lev2sec2"><strong><em><span epub:type="pagebreak" id="page_151"/>Template Function Definitions</em></strong></h4>&#13;
<p class="noindent">You can also specify template functions, like the <span class="literal">my_template_function</span> in <a href="ch06.xhtml#ch06ex02">Listing 6-2</a> that also takes three template parameters: <span class="literal">X, Y</span>, and <span class="literal">Z</span>.</p>&#13;
<pre>template&lt;typename X, typename Y, typename Z&gt;&#13;
X my_template_function(Y&amp; arg1, const Z* arg2) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex02"/><em>Listing 6-2: A template function with three template parameters</em></p>&#13;
<p class="indent">Within the body of <span class="literal">my_template_function</span>, you can use <span class="literal">arg1</span> and <span class="literal">arg2</span> however you’d like, as long as you return an object of type <span class="literal">X</span>.</p>&#13;
<h4 class="h4" id="ch06lev2sec3"><strong><em>Instantiating Templates</em></strong></h4>&#13;
<p class="noindent">To instantiate a template class, use the following syntax:</p>&#13;
<pre><span class="codeitalic1">tc_name</span><span class="ent">➊</span>&lt;<span class="codeitalic1">t_param1</span><span class="ent">➋</span>, <span class="codeitalic1">t_param2</span>, ...&gt; <span class="codeitalic1">my_concrete_class</span>{ ... }<span class="ent">➌</span>;</pre>&#13;
<p class="indent">The <span class="codeitalic">tc_name</span> <span class="ent">➊</span> is where you place the template class’s name. Next, you fill in your template parameters <span class="ent">➋</span>. Finally, you treat this combination of template name and parameters as if it were a normal type: you use whatever initialization syntax you like <span class="ent">➌</span>.</p>&#13;
<p class="indent">Instantiating a template function is similar:</p>&#13;
<pre>auto result = <span class="codeitalic1">tf_name</span><span class="ent">➊</span>&lt;<span class="codeitalic1">t_param1</span><span class="ent">➋</span>, <span class="codeitalic1">t_param2</span>, ...&gt;(<span class="codeitalic1">f_param1</span><span class="ent">➌</span>, <span class="codeitalic1">f_param2</span>, ...);</pre>&#13;
<p class="indent">The <span class="codeitalic">tf_name</span> <span class="ent">➊</span> is where you put the template function’s name. You fill in the parameters just as you do for template classes <span class="ent">➋</span>. You use the combination of template name and parameters as if it were a normal type. You invoke this template function instantiation with parentheses and function parameters <span class="ent">➌</span>.</p>&#13;
<p class="indent">All this new notation might be daunting to a newcomer, but it’s not so bad once you get used to it. In fact, it’s used in a set of language features called named conversion functions.</p>&#13;
<h3 class="h3" id="ch06lev1sec3"><strong>Named Conversion Functions</strong></h3>&#13;
<p class="noindent"><em>Named conversions</em> are language features that explicitly convert one type into another type. You use named conversions sparingly in situations where you cannot use implicit conversions or constructors to get the types you need.</p>&#13;
<p class="indent">All named conversions accept a single object parameter, which is the object you want to cast <span class="literal">object-to-cast</span>, and a single type parameter, which is the type you want to cast to <span class="literal">desired-type</span>:</p>&#13;
<pre><span class="codeitalic1">named-conversion</span>&lt;<span class="codeitalic1">desired-type</span>&gt;(<span class="codeitalic1">object-to-cast</span>)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_152"/>For example, if you need to modify a <span class="literal">const</span> object, you would first need to cast away the <span class="literal">const</span> qualifier. The named conversion function <span class="literal">const_cast</span> allows you to perform this operation. Other named conversions help you to reverse implicit casts (<span class="literal">static_cast</span>) or reinterpret memory with a different type (<span class="literal">reinterpret_cast</span>).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Although named conversion functions aren’t technically template functions, they are conceptually very close to templates—a relationship reflected in their syntactic similarity.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch06lev2sec4"><strong><em>const_cast</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">const_cast</span> function shucks away the <span class="literal">const</span> modifier, allowing the modification of <span class="literal">const</span> values. The <span class="literal">object-to-cast</span> is of some <span class="literal">const</span> type, and the <span class="codeitalic">desired-type</span> is that type minus the <span class="literal">const</span> qualifier.</p>&#13;
<p class="indent">Consider the <span class="literal">carbon_thaw</span> function in <a href="ch06.xhtml#ch06ex03">Listing 6-3</a>, which takes a <span class="literal">const</span> reference to an <span class="literal">encased_solo</span> argument.</p>&#13;
<pre>void carbon_thaw(const<span class="ent">➊</span> int&amp; encased_solo) {&#13;
  //encased_solo++; <span class="ent">➋</span> // Compiler error; modifying const&#13;
  auto&amp; hibernation_sick_solo = const_cast<span class="ent">➌</span>&lt;int&amp;<span class="ent">➍</span>&gt;(encased_solo<span class="ent">➎</span>);&#13;
  hibernation_sick_solo++; <span class="ent">➏</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex03"/><em>Listing 6-3: A function using <span class="literal">const_cast</span>. Uncommenting yields a compiler error.</em></p>&#13;
<p class="indent">The <span class="literal">encased_solo</span> parameter is <span class="literal">const</span> <span class="ent">➊</span>, so any attempt to modify it <span class="ent">➋</span> would result in a compiler error. You use <span class="literal">const_cast</span> <span class="ent">➌</span> to obtain the non-<span class="literal">const</span> reference <span class="literal">hibernation_sick_solo</span>. The <span class="literal">const_cast</span> takes a single template parameter, the type you want to cast into <span class="ent">➍</span>. It also takes a function parameter, the object you want to remove <span class="literal">const</span> from <span class="ent">➎</span>. You’re then free to modify the <span class="literal">int</span> pointed to by <span class="literal">encased_solo</span> via the new, non-<span class="literal">const</span> reference <span class="ent">➏</span>.</p>&#13;
<p class="indent">Only use <span class="literal">const_cast</span> to obtain write access to <span class="literal">const</span> objects. Any other type conversion will result in a compiler error.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Trivially, you can use <span class="literal">const_cast</span> to add <span class="literal">const</span> to an object’s type, but you shouldn’t because it’s verbose and unnecessary. Use an implicit cast instead. In <a href="ch07.xhtml#ch07">Chapter 7</a>, you’ll learn what the <span class="literal">volatile</span> modifier is. You can also use <span class="literal">const_cast</span> to remove the <span class="literal">volatile</span> modifier from an object.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch06lev2sec5"><strong><em>static_cast</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">static_cast</span> reverses a well-defined implicit conversion, such as an integer type to another integer type. The <span class="literal">object-to-cast</span> is of some type that the <span class="literal">desired-type</span> implicitly converts to. The reason you might need <span class="literal">static_cast</span> is that, generally, implicit casts aren’t reversible.</p>&#13;
<p class="indent">The program in <a href="ch06.xhtml#ch06ex04">Listing 6-4</a> defines an <span class="literal">increment_as_short</span> function that takes a <span class="literal">void</span> pointer argument. It employs a <span class="literal">static_cast</span> to create a <span class="literal">short</span> pointer from this argument, increment the pointed-to <span class="literal">short</span>, and return the result. In some low-level applications, such as network programming <span epub:type="pagebreak" id="page_153"/>or handling binary file formats, you might need to interpret raw bytes as an integer type.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
short increment_as_short(void*<span class="ent">➊</span> target) {&#13;
  auto as_short = static_cast<span class="ent">➋</span>&lt;short*<span class="ent">➌</span>&gt;(target<span class="ent">➍</span>);&#13;
  *as_short = *as_short + 1;&#13;
  return *as_short;&#13;
}&#13;
&#13;
int main() {&#13;
  short beast{ 665 };&#13;
  auto mark_of_the_beast = increment_as_short(&amp;beast);&#13;
  printf("%d is the mark_of_the_beast.", mark_of_the_beast);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">666 is the mark_of_the_beast.</span></pre>&#13;
<p class="listing"><a id="ch06ex04"/><em>Listing 6-4: A program using <span class="literal">static_cast</span></em></p>&#13;
<p class="indent">The <span class="literal">target</span> parameter is a <span class="literal">void</span> pointer <span class="ent">➊</span>. You employ <span class="literal">static_cast</span> to cast <span class="literal">target</span> into a <span class="literal">short*</span> <span class="ent">➋</span>. The template parameter is the desired type <span class="ent">➌</span>, and the function parameter is the object you want to cast into <span class="ent">➍</span>.</p>&#13;
<p class="indent">Notice that the implicit conversion of <span class="literal">short*</span> to <span class="literal">void*</span> is well defined. Attempting ill-defined conversions with <span class="literal">static_cast</span>, such as converting a <span class="literal">char*</span> to a <span class="literal">float*</span>, will result in a compiler error:</p>&#13;
<pre>float on = 3.5166666666;&#13;
auto not_alright = static_cast&lt;char*&gt;(&amp;on); // Bang!</pre>&#13;
<p class="indent">To perform such chainsaw juggling, you need to use <span class="literal">reinterpret_cast</span>.</p>&#13;
<h4 class="h4" id="ch06lev2sec6"><strong><em>reinterpret_cast</em></strong></h4>&#13;
<p class="noindent">Sometimes in low-level programming, you must perform type conversions that are not well defined. In system programming and especially in embedded environments, you often need complete control over how to interpret memory. The <span class="literal">reinterpret_cast</span> gives you such control, but ensuring the correctness of these conversions is entirely your responsibility.</p>&#13;
<p class="indent">Suppose your embedded device keeps an <span class="literal">unsigned long</span> timer at memory address 0x1000. You could use <span class="literal">reinterpret_cast</span> to read from the timer, as demonstrated in <a href="ch06.xhtml#ch06ex05">Listing 6-5</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
int main() {&#13;
  auto timer = reinterpret_cast<span class="ent">➊</span>&lt;const unsigned long*<span class="ent">➋</span>&gt;(0x1000<span class="ent">➌</span>);&#13;
  printf("Timer is %lu.", *timer);&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex05"/><em>Listing 6-5: A program using <span class="literal">reinterpret_cast</span>. This program will compile, but you should expect a runtime crash unless 0x1000 is readable.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_154"/>The <span class="literal">reinterpret_cast</span> <span class="ent">➊</span> takes a type parameter corresponding to the desired pointer type <span class="ent">➋</span> and the memory address the result should point to <span class="ent">➌</span>.</p>&#13;
<p class="indent">Of course, the compiler has no idea whether the memory at address 0x1000 contains an <span class="literal">unsigned long</span>. It’s entirely up to you to ensure correctness. Because you’re taking full responsibility for this very dangerous construction, the compiler forces you to employ <span class="literal">reinterpret_cast</span>. You couldn’t, for example, replace the initialization of <span class="literal">timer</span> with the following line:</p>&#13;
<pre>const unsigned long* timer{ 0x1000 };</pre>&#13;
<p class="indent">The compiler will grumble about converting an <span class="literal">int</span> to a pointer.</p>&#13;
<h4 class="h4" id="ch06lev2sec7"><strong><em>narrow_cast</em></strong></h4>&#13;
<p class="noindent"><a href="ch06.xhtml#ch06ex06">Listing 6-6</a> illustrates a custom <span class="literal">static_cast</span> that performs a runtime check for <em>narrowing</em>. Narrowing is a loss in information. Think about converting from an <span class="literal">int</span> to a <span class="literal">short</span>. As long as the value of <span class="literal">int</span> fits into a <span class="literal">short</span>, the conversion is reversible and no narrowing occurs. If the value of <span class="literal">int</span> is too big for the <span class="literal">short</span>, the conversion isn’t reversible and results in narrowing.</p>&#13;
<p class="indent">Let’s implement a named conversion called <span class="literal">narrow_cast</span> that checks for narrowing and throws a <span class="literal">runtime_error</span> if it’s detected.</p>&#13;
<pre>#include &lt;stdexcept&gt;&#13;
template &lt;typename To<span class="ent">➊</span>, typename From<span class="ent">➋</span>&gt;&#13;
To<span class="ent">➌</span> narrow_cast(From<span class="ent">➍</span> value) {&#13;
  const auto converted = static_cast&lt;To&gt;(value); <span class="ent">➎</span>&#13;
  const auto backwards = static_cast&lt;From&gt;(converted); <span class="ent">➏</span>&#13;
  if (value != backwards) throw std::runtime_error{ "Narrowed!" }; <span class="ent">➐</span>&#13;
  return converted; <span class="ent">➑</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex06"/><em>Listing 6-6: A <span class="literal">narrow_cast</span> definition</em></p>&#13;
<p class="indent">The <span class="literal">narrow_cast</span> function template takes two template parameters: the type you’re casting <span class="literal">To</span> <span class="ent">➊</span> and the type you’re casting <span class="literal">From</span> <span class="ent">➋</span>. You can see these template parameters in action as the return type of the function <span class="ent">➌</span> and the type of the parameter value <span class="ent">➍</span>. First, you perform the requested conversion using <span class="literal">static_cast</span> to yield <span class="literal">converted</span> <span class="ent">➎</span>. Next, you perform the conversion in the opposite direction (from <span class="literal">converted</span> to type <span class="literal">From</span>) to yield <span class="literal">backwards</span> <span class="ent">➏</span>. If <span class="literal">value</span> doesn’t equal <span class="literal">backwards</span>, you’ve narrowed, so you throw an exception <span class="ent">➐</span>. Otherwise, you return <span class="literal">converted</span> <span class="ent">➑</span>.</p>&#13;
<p class="indent">You can see <span class="literal">narrow_cast</span> in action in <a href="ch06.xhtml#ch06ex07">Listing 6-7</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;stdexcept&gt;&#13;
&#13;
template &lt;typename To, typename From&gt;&#13;
To narrow_cast(From value) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
<span epub:type="pagebreak" id="page_155"/>int main() {&#13;
  int perfect{ 496 }; <span class="ent">➊</span>&#13;
  const auto perfect_short = narrow_cast&lt;short&gt;(perfect); <span class="ent">➋</span>&#13;
  printf("perfect_short: %d\n", perfect_short); <span class="ent">➌</span>&#13;
  try {&#13;
    int cyclic{ 142857 }; <span class="ent">➍</span>&#13;
    const auto cyclic_short = narrow_cast&lt;short&gt;(cyclic); <span class="ent">➎</span>&#13;
    printf("cyclic_short: %d\n", cyclic_short);&#13;
  } catch (const std::runtime_error&amp; e) {&#13;
    printf("Exception: %s\n", e.what()); <span class="ent">➏</span>&#13;
  }&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">perfect_short: 496 <span class="ent">➌</span></span>&#13;
<span class="color1">Exception: Narrowed! <span class="ent">➏</span></span></pre>&#13;
<p class="listing"><a id="ch06ex07"/><em>Listing 6-7: A program using <span class="literal">narrow_cast</span>. (The output comes from an execution on Windows 10 x64.)</em></p>&#13;
<p class="indent">You first initialize <span class="literal">perfect</span> to 496 <span class="ent">➊</span> and then <span class="literal">narrow_cast</span> it to the short <span class="literal">perfect_short</span> <span class="ent">➋</span>. This proceeds without exception because the value 496 fits easily into a 2-byte short on Windows 10 x64 (maximum value 32767). You see the output as expected <span class="ent">➌</span>. Next, you initialize <span class="literal">cyclic</span> to 142857 <span class="ent">➍</span> and attempt to <span class="literal">narrow_cast</span> to the short <span class="literal">cyclic_short</span> <span class="ent">➎</span>. This throws a <span class="literal">runtime_error</span> because 142857 is greater than the short’s maximum value of 32767. The check within <span class="literal">narrow_cast</span> will fail. You see the exception printed in the <span class="literal">output</span> <span class="ent">➏</span>.</p>&#13;
<p class="indent">Notice that you need to provide only a single template parameter, the return type, upon instantiation <span class="ent">➋➎</span>. The compiler can deduce the <span class="literal">From</span> parameter based on usage.</p>&#13;
<h3 class="h3" id="ch06lev1sec4"><strong>mean: A Template Function Example</strong></h3>&#13;
<p class="noindent">Consider the function in <a href="ch06.xhtml#ch06ex08">Listing 6-8</a> that computes the mean of a <span class="literal">double</span> array using the sum-and-divide approach.</p>&#13;
<pre>#include &lt;cstddef&gt;&#13;
&#13;
double mean(const double* values, size_t length) {&#13;
  double result{}; <span class="ent">➊</span>&#13;
  for(size_t i{}; i&lt;length; i++) {&#13;
    result += values[i]; <span class="ent">➋</span>&#13;
  }&#13;
  return result / length; <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex08"/><em>Listing 6-8: A function for computing the mean of an array</em></p>&#13;
<p class="indent">You initialize a <span class="literal">result</span> variable to zero <span class="ent">➊</span>. Next, you sum over <span class="literal">values</span> by iterating over each index <span class="literal">i</span>, adding the corresponding element to <span class="literal">result</span> <span class="ent">➋</span>. Then you divide <span class="literal">result</span> by <span class="literal">length</span> and <span class="literal">return</span> <span class="ent">➌</span>.</p>&#13;
<h4 class="h4" id="ch06lev2sec8"><span epub:type="pagebreak" id="page_156"/><strong><em>Genericizing mean</em></strong></h4>&#13;
<p class="noindent">Suppose you want to support <span class="literal">mean</span> calculations for other numeric types, such as <span class="literal">float</span> or <span class="literal">long</span>. You might be thinking, “That’s what function overloads are for!” Essentially, you would be correct.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06ex09">Listing 6-9</a> overloads <span class="literal">mean</span> to accept a <span class="literal">long</span> array. The straightforward approach is to copy and paste the original, then replace instances of <span class="literal">double</span> with <span class="literal">long</span>.</p>&#13;
<pre>#include &lt;cstddef&gt;&#13;
&#13;
long<span class="ent">➊</span> mean(const long*<span class="ent">➋</span> values, size_t length) {&#13;
  long result{}; <span class="ent">➌</span>&#13;
  for(size_t i{}; i&lt;length; i++) {&#13;
    result += values[i];&#13;
  }&#13;
  return result / length;&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex09"/><em>Listing 6-9: An overload of <a href="ch06.xhtml#ch06ex08">Listing 6-8</a> accepting a <span class="literal">long</span> array</em></p>&#13;
<p class="indent">That sure is a lot of copying and pasting, and you’ve changed very little: the return type <span class="ent">➊</span>, the function argument <span class="ent">➋</span>, and <span class="literal">result</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">This approach doesn’t scale as you add more types. What if you want to support other integral types, such as <span class="literal">short</span> types or <span class="literal">uint_64</span> types? What about <span class="literal">float</span> types? What if, later on, you want to refactor some logic in <span class="literal">mean</span>? You’re in for a lot of tedious and error-prone maintenance.</p>&#13;
<p class="indent">There are three changes to <span class="literal">mean</span> in <a href="ch06.xhtml#ch06ex09">Listing 6-9</a>, and all of them involve finding and replacing <span class="literal">double</span> types with <span class="literal">long</span> types. Ideally, you could have the compiler automatically generate versions of the function for you whenever it encounters usage with a different type. The key is that none of the logic changes—only the types.</p>&#13;
<p class="indent">What you need to solve this copy-and-paste problem is <em>generic programming</em>, a programming style where you program with yet-to-be-specified types. You achieve generic programming using the support C++ has for templates. Templates allow the compiler to instantiate a custom class or function based on the types in use.</p>&#13;
<p class="indent">Now that you know how to declare templates, consider the <span class="literal">mean</span> function again. You still want <span class="literal">mean</span> to accept a wide range of types—not just <span class="literal">double</span> types—but you don’t want to have to copy and paste the same code over and over again.</p>&#13;
<p class="indent">Consider how you can refactor <a href="ch06.xhtml#ch06ex08">Listing 6-8</a> into a template function, as demonstrated in <a href="ch06.xhtml#ch06ex10">Listing 6-10</a>.</p>&#13;
<pre>#include &lt;cstddef&gt;&#13;
&#13;
template&lt;typename T&gt; <span class="ent">➊</span>&#13;
T<span class="ent">➋</span> mean(constT*<span class="ent">➌</span> values, size_t length) {&#13;
  T<span class="ent">➍</span> result{};&#13;
  for(size_t i{}; i&lt;length; i++) {&#13;
    result += values[i];&#13;
<span epub:type="pagebreak" id="page_157"/>  }&#13;
  return result / length;&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex10"/><em>Listing 6-10: Refactoring <a href="ch06.xhtml#ch06ex08">Listing 6-8</a> into a template function</em></p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06ex10">Listing 6-10</a> kicks off with a template prefix <span class="ent">➊</span>. This prefix communicates a single template parameter <span class="literal">T</span>. Next, you update <span class="literal">mean</span> to use <span class="literal">T</span> instead of <span class="literal">double</span> <span class="ent">➋➌➍</span>.</p>&#13;
<p class="indent">Now you can use <span class="literal">mean</span> with many different types. Each time the compiler encounters a usage of <span class="literal">mean</span> with a new type, it performs template instantiation. It’s <em>as if</em> you had done the copy-paste-and-replace-types procedure, but the compiler is much better at doing detail-oriented, monotonous tasks than you are. Consider the example in <a href="ch06.xhtml#ch06ex11">Listing 6-11</a>, which computes means for <span class="literal">double, float</span>, and <span class="literal">size_t</span> types.</p>&#13;
<pre>#include &lt;cstddef&gt;&#13;
#include &lt;cstdio&gt;&#13;
&#13;
template&lt;typename T&gt;&#13;
T mean(const T* values, size_t length) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
int main() {&#13;
  const double nums_d[] { 1.0, 2.0, 3.0, 4.0 };&#13;
  const auto result1 = mean&lt;double&gt;(nums_d, 4); <span class="ent">➊</span>&#13;
  printf("double: %f\n", result1);&#13;
&#13;
  const float nums_f[] { 1.0f, 2.0f, 3.0f, 4.0f };&#13;
  const auto result2 = mean&lt;float&gt;(nums_f, 4); <span class="ent">➋</span>&#13;
  printf("float: %f\n", result2);&#13;
&#13;
  const size_t nums_c[] { 1, 2, 3, 4 };&#13;
  const auto result3 = mean&lt;size_t&gt;(nums_c, 4); <span class="ent">➌</span>&#13;
  printf("size_t: %zu\n", result3);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">double: 2.500000</span>&#13;
<span class="color1">float: 2.500000</span>&#13;
<span class="color1">size_t: 2</span></pre>&#13;
<p class="listing"><a id="ch06ex11"/><em>Listing 6-11: A program using the template function <span class="literal">mean</span></em></p>&#13;
<p class="indent">Three templates are instantiated <span class="ent">➊➋➌</span>; it’s as if you generated the overloads isolated in <a href="ch06.xhtml#ch06ex12">Listing 6-12</a> by hand. (Each template instantiation contains types, shown in bold, where the compiler substituted a type for a template parameter.)</p>&#13;
<pre><span class="codeitalicstrong1">double</span> mean(const <span class="codeitalicstrong1">double</span>* values, size_t length) {&#13;
  <span class="codeitalicstrong1">double</span> result{};&#13;
  for(size_t i{}; i&lt;length; i++) {&#13;
    result += values[i];&#13;
  }&#13;
<span epub:type="pagebreak" id="page_158"/>  return result / length;&#13;
}&#13;
&#13;
<span class="codeitalicstrong1">float</span> mean(const <span class="codeitalicstrong1">float</span>* values, size_t length) {&#13;
  <span class="codeitalicstrong1">float</span> result{};&#13;
  for(size_t i{}; i&lt;length; i++) {&#13;
    result += values[i];&#13;
  }&#13;
  return result / length;&#13;
}&#13;
&#13;
<span class="codeitalicstrong1">size_t</span> mean(const <span class="codeitalicstrong1">size_t</span>* values, size_t length) {&#13;
  <span class="codeitalicstrong1">size_t</span> result{};&#13;
  for(size_t i{}; i&lt;length; i++) {&#13;
    result += values[i];&#13;
  }&#13;
  return result / length;&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex12"/><em>Listing 6-12: The template instantiations for <a href="ch06.xhtml#ch06ex11">Listing 6-11</a></em></p>&#13;
<p class="indent">The compiler has done a lot of work for you, but you might have noticed that you had to type the pointed-to array type twice: once to declare an array and again to specify a template parameter. This gets tedious and can cause errors. If the template parameter doesn’t match, you’ll likely get a compiler error or cause unintended casting.</p>&#13;
<p class="indent">Fortunately, you can generally omit the template parameters when invoking a template function. The process that the compiler uses to determine the correct template parameters is called <em>template type deduction</em>.</p>&#13;
<h4 class="h4" id="ch06lev2sec9"><strong><em>Template Type Deduction</em></strong></h4>&#13;
<p class="noindent">Generally, you don’t have to provide template function parameters. The compiler can deduce them from usage, so a rewrite of <a href="ch06.xhtml#ch06ex11">Listing 6-11</a> without them is shown in <a href="ch06.xhtml#ch06ex13">Listing 6-13</a>.</p>&#13;
<pre>#include &lt;cstddef&gt;&#13;
#include &lt;cstdio&gt;&#13;
&#13;
template&lt;typename T&gt;&#13;
T mean(const T* values, size_t length) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
int main() {&#13;
  const double nums_d[] { 1.0, 2.0, 3.0, 4.0 };&#13;
  const auto result1 = mean(nums_d, 4); <span class="ent">➊</span>&#13;
  printf("double: %f\n", result1);&#13;
&#13;
  const float nums_f[] { 1.0f, 2.0f, 3.0f, 4.0f };&#13;
  const auto result2 = mean(nums_f, 4); <span class="ent">➋</span>&#13;
  printf("float: %f\n", result2);&#13;
&#13;
  const size_t nums_c[] { 1, 2, 3, 4 };&#13;
<span epub:type="pagebreak" id="page_159"/>  const auto result3 = mean(nums_c, 4); <span class="ent">➌</span>&#13;
  printf("size_t: %zu\n", result3);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">double: 2.500000</span>&#13;
<span class="color1">float: 2.500000</span>&#13;
<span class="color1">size_t: 2</span></pre>&#13;
<p class="listing"><a id="ch06ex13"/><em>Listing 6-13: A refactor of <a href="ch06.xhtml#ch06ex11">Listing 6-11</a> without explicit template parameters</em></p>&#13;
<p class="indent">It’s clear from usage that the template parameters are <span class="literal">double</span> <span class="ent">➊</span>, <span class="literal">float</span> <span class="ent">➋</span>, and <span class="literal">size_t</span> <span class="ent">➌</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Template type deduction mostly works the way you might expect, but there is some nuance you’ll want to become familiar with if you’re writing a lot of generic code. For more information, see the ISO standard [temp]. Also, refer to Item 1 of Effective Modern C++ by Scott Meyers and Section 23.5.1 of  The C++ Programming Language, 4th Edition, by Bjarne Stroustrup.</em></p>&#13;
</div>&#13;
<p class="indent">Sometimes, template arguments cannot be deduced. For example, if a template function’s return type is a template argument that’s entirely independent of other function and template arguments, you must specify template arguments explicitly.</p>&#13;
<h3 class="h3" id="ch06lev1sec5"><strong>SimpleUniquePointer: A Template Class Example</strong></h3>&#13;
<p class="noindent">A <em>unique pointer</em> is an RAII wrapper around a free-store-allocated object. As its name suggests, the unique pointer has a single owner at a time, so when a unique pointer’s lifetime ends, the pointed-to object gets destructed.</p>&#13;
<p class="indent">The underlying object’s type in unique pointers doesn’t matter, making them a prime candidate for a template class. Consider the implementation in <a href="ch06.xhtml#ch06ex14">Listing 6-14</a>.</p>&#13;
<pre>template &lt;typename T&gt; <span class="ent">➊</span>&#13;
struct SimpleUniquePointer {&#13;
  SimpleUniquePointer() = default; <span class="ent">➋</span>&#13;
  SimpleUniquePointer(T* pointer)&#13;
    : pointer{ pointer } { <span class="ent">➌</span>&#13;
  }&#13;
  ~SimpleUniquePointer() { <span class="ent">➍</span>&#13;
    if(pointer) delete pointer;&#13;
  }&#13;
  SimpleUniquePointer(const SimpleUniquePointer&amp;) = delete;&#13;
  SimpleUniquePointer&amp; operator=(const SimpleUniquePointer&amp;) = delete; <span class="ent">➎</span>&#13;
  SimpleUniquePointer(SimpleUniquePointer&amp;&amp; other) noexcept <span class="ent">➏</span>&#13;
    : pointer{ other.pointer } {&#13;
    other.pointer = nullptr;&#13;
  }&#13;
  SimpleUniquePointer&amp; operator=(SimpleUniquePointer&amp;&amp; other) noexcept { <span class="ent">➐</span>&#13;
    if(pointer) delete pointer;&#13;
    pointer = other.pointer;&#13;
    other.pointer = nullptr;&#13;
    return *this;&#13;
<span epub:type="pagebreak" id="page_160"/>  }&#13;
  T* get() { <span class="ent">➑</span>&#13;
    return pointer;&#13;
  }&#13;
private:&#13;
  T* pointer;&#13;
};</pre>&#13;
<p class="listing"><a id="ch06ex14"/><em>Listing 6-14: A simple unique pointer implementation</em></p>&#13;
<p class="indent">You announce the template class with a template prefix <span class="ent">➊</span>, which establishes <span class="literal">T</span> as the wrapped object’s type. Next, you specify a default constructor using the <span class="literal">default</span> keyword <span class="ent">➋</span>. (Recall from <a href="ch04.xhtml#ch04">Chapter 4</a> that you need <span class="literal">default</span> when you want both a default constructor <em>and</em> a non-default constructor.) The generated default constructor will set the private member <span class="literal">T*</span> pointer to <span class="literal">nullptr</span> thanks to default initialization rules. You have a non-default constructor that takes a <span class="literal">T*</span> and sets the private member pointer <span class="ent">➌</span>. Because the pointer is possibly <span class="literal">nullptr</span>, the destructor checks before deleting <span class="ent">➍</span>.</p>&#13;
<p class="indent">Because you want to allow only a single owner of the pointed-to object, you <span class="literal">delete</span> the copy constructor and the copy-assignment operator <span class="ent">➎</span>. This prevents double-free issues, which were discussed in <a href="ch04.xhtml#ch04">Chapter 4</a>. However, you can make your unique pointer moveable by adding a move constructor <span class="ent">➏</span>. This steals the value of <span class="literal">pointer</span> from <span class="literal">other</span> and then sets the pointer of <span class="literal">other</span> to <span class="literal">nullptr</span>, handing responsibility of the pointed-to object to <span class="literal">this</span>. Once the move constructor returns, the moved-from object is destroyed. Because the moved-from object’s pointer is set to <span class="literal">nullptr</span>, the destructor will not delete the pointed-to object.</p>&#13;
<p class="indent">The possibility that <span class="literal">this</span> already owns an object complicates the move assignment <span class="ent">➐</span>. You must check explicitly for prior ownership, because failure to delete a pointer leaks a resource. After this check, you perform the same operations as in the copy constructor: you set <span class="literal">pointer</span> to the value of <span class="literal">other.pointer</span> and then set <span class="literal">other.pointer</span> to <span class="literal">nullptr</span>. This ensures that the moved-from object doesn’t delete the pointed-to object.</p>&#13;
<p class="indent">You can obtain direct access to the underlying pointer by calling the <span class="literal">get</span> method <span class="ent">➑</span>.</p>&#13;
<p class="indent">Let’s enlist our old friend <span class="literal">Tracer</span> from <a href="ch04.xhtml#ch04ex05">Listing 4-5</a> to investigate <span class="literal">SimpleUniquePointer</span>. Consider the program in <a href="ch06.xhtml#ch06ex15">Listing 6-15</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;utility&gt;&#13;
&#13;
template &lt;typename T&gt;&#13;
struct SimpleUniquePointer {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct Tracer {&#13;
  Tracer(const char* name) : name{ name } {&#13;
    printf("%s constructed.\n", name); <span class="ent">➊</span>&#13;
  }&#13;
  ~Tracer() {&#13;
<span epub:type="pagebreak" id="page_161"/>    printf("%s destructed.\n", name); <span class="ent">➋</span>&#13;
  }&#13;
private:&#13;
  const char* const name;&#13;
};&#13;
&#13;
void consumer(SimpleUniquePointer&lt;Tracer&gt; consumer_ptr) {&#13;
  printf("(cons) consumer_ptr: 0x%p\n", consumer_ptr.get()); <span class="ent">➌</span>&#13;
}&#13;
&#13;
int main() {&#13;
  auto ptr_a = SimpleUniquePointer(new Tracer{ "ptr_a" });&#13;
  printf("(main) ptr_a: 0x%p\n", ptr_a.get()); <span class="ent">➍</span>&#13;
  consumer(std::move(ptr_a));&#13;
  printf("(main) ptr_a: 0x%p\n", ptr_a.get()); <span class="ent">➎</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">ptr_a constructed. <span class="ent">➊</span></span>&#13;
<span class="color1">(main) ptr_a: 0x000001936B5A2970 <span class="ent">➍</span></span>&#13;
<span class="color1">(cons) consumer_ptr: 0x000001936B5A2970 <span class="ent">➌</span></span>&#13;
<span class="color1">ptr_a destructed. <span class="ent">➋</span></span>&#13;
<span class="color1">(main) ptr_a: 0x0000000000000000 <span class="ent">➎</span></span></pre>&#13;
<p class="listing"><a id="ch06ex15"/><em>Listing 6-15: A program investigating <span class="literal">SimpleUniquePointers</span> with the <span class="literal">Tracer</span> class</em></p>&#13;
<p class="indent">First, you dynamically allocate a <span class="literal">Tracer</span> with the message <span class="literal">ptr_a</span>. This prints the first message <span class="ent">➊</span>. You use the resulting <span class="literal">Tracer</span> pointer to construct a <span class="literal">SimpleUniquePointer</span> called <span class="literal">ptr_a</span>. Next, you use the <span class="literal">get()</span> method of <span class="literal">ptr_a</span> to retrieve the address of its <span class="literal">Tracer</span>, which you print <span class="ent">➍</span>. Then you use <span class="literal">std::move</span> to relinquish the <span class="literal">Tracer</span> of <span class="literal">ptr_a</span> to the <span class="literal">consumer</span> function, which moves <span class="literal">ptr_a</span> into the <span class="literal">consumer_ptr</span> argument.</p>&#13;
<p class="indent">Now, <span class="literal">consumer_ptr</span> owns the <span class="literal">Tracer</span>. You use the <span class="literal">get()</span> method of <span class="literal">consumer_ptr</span> to retrieve the address of <span class="literal">Tracer</span>, then print <span class="ent">➌</span>. Notice this address matches the one printed at <span class="ent">➍</span>. When <span class="literal">consumer</span> returns, <span class="literal">consumer_ptr</span> dies because its storage duration is the scope of <span class="literal">consumer</span>. As a result, <span class="literal">ptr_a</span> gets destructed <span class="ent">➋</span>.</p>&#13;
<p class="indent">Recall that <span class="literal">ptr_a</span> is in a moved-from state—you moved its <span class="literal">Tracer</span> into <span class="literal">consumer</span>. You use the <span class="literal">get()</span> method of <span class="literal">ptr_a</span> to illustrate that it now holds a <span class="literal">nullptr</span> <span class="ent">➎</span>.</p>&#13;
<p class="indent">Thanks to <span class="literal">SimpleUniquePointer</span>, you won’t leak a dynamically allocated object; also, because the <span class="literal">SimpleUniquePointer</span> is just carrying around a pointer under the hood, move semantics are efficient.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The <span class="literal">SimpleUniquePointer</span> is a pedagogical implementation of the stdlib’s <span class="literal">std::unique_ptr</span>, which is a member of the family of RAII templates called smart pointers. You’ll learn about these in <a href="part02.xhtml#part02">Part II</a>.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch06lev1sec6"><strong>Type Checking in Templates</strong></h3>&#13;
<p class="noindent">Templates are type safe. During template instantiation, the compiler pastes in the template parameters. If the resulting code is incorrect, the compiler will not generate the instantiation.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_162"/>Consider the template function in <a href="ch06.xhtml#ch06ex16">Listing 6-16</a>, which squares an element and returns the result.</p>&#13;
<pre>template&lt;typename T&gt;&#13;
T square(T value) {&#13;
  return value * value; <span class="ent">➊</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex16"/><em>Listing 6-16: A template function that squares a value</em></p>&#13;
<p class="indent">The <span class="literal">T</span> has a silent requirement: it must support multiplication <span class="ent">➊</span>.</p>&#13;
<p class="indent">If you try to use <span class="literal">square</span> with, say, a <span class="literal">char*</span>, the compilation will fail, as shown in <a href="ch06.xhtml#ch06ex17">Listing 6-17</a>.</p>&#13;
<pre>template&lt;typename T&gt;&#13;
T square(T value) {&#13;
  return value * value;&#13;
}&#13;
&#13;
int main() {&#13;
  char my_char{ 'Q' };&#13;
  auto result = square(&amp;my_char); <span class="ent">➊</span> // Bang!&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex17"/><em>Listing 6-17: A program with a failed template instantiation. (This program fails to compile.)</em></p>&#13;
<p class="indent">Pointers don’t support multiplication, so template initialization fails <span class="ent">➊</span>.</p>&#13;
<p class="indent">The square function is trivially small, but the failed template initialization’s error message isn’t. On MSVC v141, you get this:</p>&#13;
<pre>main.cpp(3): error C2296: '*': illegal, left operand has type 'char *'&#13;
main.cpp(8): note: see reference to function template instantiation 'T *square&lt;char*&gt;(T)' being compiled&#13;
        with&#13;
        [&#13;
            T=char *&#13;
        ]&#13;
main.cpp(3): error C2297: '*': illegal, right operand has type 'char *'</pre>&#13;
<p class="indent">And on GCC 7.3, you get this:</p>&#13;
<pre>main.cpp: In instantiation of 'T square(T) [with T = char*]':&#13;
main.cpp:8:32:   required from here&#13;
main.cpp:3:16: error: invalid operands of types 'char*' and 'char*' to binary&#13;
'operator*'&#13;
   return value * value;&#13;
          ~~~~~~^~~~~~~</pre>&#13;
<p class="indent">These error messages exemplify the notoriously cryptic error messages emitted by template initialization failures.</p>&#13;
<p class="indent">Although template instantiation ensures type safety, the checking happens very late in the compilation process. When the compiler instantiates <span epub:type="pagebreak" id="page_163"/>a template, it pastes the template parameter types into the template. After type insertion, the compiler attempts to compile the result. If instantiation fails, the compiler emits the dying words inside the template instantiation.</p>&#13;
<p class="indent">C++ template programming shares similarities with <em>duck-typed languages</em>. Duck-typed languages (like Python) defer type checking until runtime. The underlying philosophy is that if an object looks like a duck and quacks like a duck, then it must be type duck. Unfortunately, this means you can’t generally know whether an object supports a particular operation until you execute the program.</p>&#13;
<p class="indent">With templates, you cannot know whether an instantiation will succeed until you try to compile it. Although duck-typed languages might blow up at runtime, templates might blow up at compile time.</p>&#13;
<p class="indent">This situation is widely regarded as unacceptable by right-thinking people in the C++ community, so there is a splendid solution called <em>concepts</em>.</p>&#13;
<h3 class="h3" id="ch06lev1sec7"><strong>Concepts</strong></h3>&#13;
<p class="noindent"><em>Concepts</em> constrain template parameters, allowing for parameter checking at the point of instantiation rather than the point of first use. By catching usage issues at the point of instantiation, the compiler can give you a friendly, informative error code—for example, “You tried to instantiate this template with a <span class="literal">char*</span>, but this template requires a type that supports multiplication.”</p>&#13;
<p class="indent">Concepts allow you to express requirements on template parameters directly in the language.</p>&#13;
<p class="indent">Unfortunately, concepts aren’t yet officially part of the C++ standard, although they’ve been voted into C++ 20. At press time, GCC 6.0 and later support the Concepts Technical Specification, and Microsoft is actively working toward implementing concepts in its C++ compiler, MSVC. Regardless of its unofficial status, it’s worth exploring concepts in some detail for a few reasons:</p>&#13;
<ul>&#13;
<li class="noindent">They’ll fundamentally change the way you achieve compile-time polymorphism. Familiarity with concepts will pay major dividends.</li>&#13;
<li class="noindent">They provide a conceptual framework for understanding some of the makeshift solutions that you can put in place to get better compiler errors when templates are misused.</li>&#13;
<li class="noindent">They provide an excellent conceptual bridge from compile-time templates to interfaces, the primary mechanism for runtime polymorphism (covered in <a href="ch05.xhtml#ch05">Chapter 5</a>).</li>&#13;
<li class="noindent">If you can use GCC 6.0 or later, concepts <em>are</em> available by turning on the <span class="literal">-fconcepts</span> compiler flag.</li>&#13;
</ul>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>C++ 20’s final concept specification will almost certainly deviate from the Concepts Technical Specification. This section presents concepts as specified in the Concepts Technical Specification so you can follow along.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch06lev2sec10"><strong><em><span epub:type="pagebreak" id="page_164"/>Defining a Concept</em></strong></h4>&#13;
<p class="noindent">A concept is a template. It’s a constant expression involving template arguments, evaluated at compile time. Think of a concept as one big <em>predicate</em>: a function that evaluates to <span class="literal">true</span> or <span class="literal">false</span>.</p>&#13;
<p class="indent">If a set of template parameters meets the criteria for a given concept, that concept evaluates to <span class="literal">true</span> when instantiated with those parameters; otherwise, it will evaluate to <span class="literal">false</span>. When a concept evaluates to <span class="literal">false</span>, template instantiation fails.</p>&#13;
<p class="indent">You declare concepts using the keyword <span class="literal">concept</span> on an otherwise familiar template function definition:</p>&#13;
<pre>template&lt;typename T1, typename T2, ...&gt;&#13;
concept bool ConceptName() {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<h4 class="h4" id="ch06lev2sec11"><strong><em>Type Traits</em></strong></h4>&#13;
<p class="noindent">Concepts validate type parameters. Within concepts, you manipulate types to inspect their properties. You can hand roll these manipulations, or you can use the type support library built into the stdlib. The library contains utilities for inspecting type properties. These utilities are collectively called <em>type traits</em>. They’re available in the <span class="literal">&lt;type_traits&gt;</span> header and are part of the <span class="literal">std</span> namespace. <a href="ch06.xhtml#ch06tab01">Table 6-1</a> lists some commonly used type traits.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>See Chapter 5.4 of  The C++ Standard Library, 2nd Edition, by Nicolai M. Josuttis for an exhaustive listing of type traits available in the stdlib.</em></p>&#13;
</div>&#13;
<p class="tabcap" id="ch06tab01"><strong>Table 6-1:</strong> Selected Type Traits from the <span class="literal">&lt;type_traits&gt;</span> Header</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type trait</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Checks if template argument is …</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">is_void</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">void</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">is_null_pointer</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">nullptr</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">is_integral</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">bool</span>, a <span class="literal">char</span> type, an <span class="literal">int</span> type, a <span class="literal">short</span> type, a <span class="literal">long</span> type, or a <span class="literal">long long</span> type</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">is_floating_point</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">float</span>, <span class="literal">double</span>, or <span class="literal">long double</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">is_fundamental</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Any of <span class="literal">is_void</span>, <span class="literal">is_null_pointer</span>, <span class="literal">is_integral</span>, or <span class="literal">is_floating_point</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">is_array</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">An array; that is, a type containing square brackets <span class="literal">[]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">is_enum</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">An enumeration type (<span class="literal">enum</span>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">is_class</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A class type (but not a union type)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">is_function</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A function</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">is_pointer</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A pointer; function pointers count, but pointers to class members and <span class="literal">nullptr</span> do not</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">is_reference</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A reference (either lvalue or rvalue)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">is_arithmetic</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">is_floating_point</span> or <span class="literal">is_integral</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><span epub:type="pagebreak" id="page_165"/><p class="taba"><span class="literal">is_pod</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A plain-old-data type; that is, a type that can be represented as a data type in plain C</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">is_default_constructible</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Default constructible; that is, it can be constructed without arguments or initialization values</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">is_constructible</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Constructible with the given template parameters: this type trait allows the user to provide additional template parameters beyond the type under consideration</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">is_copy_constructible</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Copy constructible</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">is_move_constructible</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Move constructible</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">is_destructible</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Destructible</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">is_same</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The same type as the additional template parameter type (including const and volatile modifiers)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">is_invocable</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Invocable with the given template parameters: this type trait allows the user to provide additional template parameters beyond the type under consideration</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Each type trait is a template class that takes a single template parameter, the type you want to inspect. You extract the results using the template’s static member <span class="literal">value</span>. This member equals <span class="literal">true</span> if the type parameter meets the criteria; otherwise, it’s <span class="literal">false</span>.</p>&#13;
<p class="indent">Consider the type trait classes <span class="literal">is_integral</span> and <span class="literal">is_floating_point</span>. These are useful for checking if a type is (you guessed it) integral or floating point. Both of these templates take a single template parameter. The example in <a href="ch06.xhtml#ch06ex18">Listing 6-18</a> investigates type traits with several types.</p>&#13;
<pre>#include &lt;type_traits&gt;&#13;
#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
&#13;
constexpr const char* as_str(bool x) { return x ? "True" : "False"; } <span class="ent">➊</span>&#13;
&#13;
int main() {&#13;
  printf("%s\n", as_str(std::is_integral&lt;int&gt;::value)); <span class="ent">➋</span>&#13;
  printf("%s\n", as_str(std::is_integral&lt;const int&gt;::value)); <span class="ent">➌</span>&#13;
  printf("%s\n", as_str(std::is_integral&lt;char&gt;::value)); <span class="ent">➍</span>&#13;
  printf("%s\n", as_str(std::is_integral&lt;uint64_t&gt;::value)); <span class="ent">➎</span>&#13;
  printf("%s\n", as_str(std::is_integral&lt;int&amp;&gt;::value)); <span class="ent">➏</span>&#13;
  printf("%s\n", as_str(std::is_integral&lt;int*&gt;::value)); <span class="ent">➐</span>&#13;
  printf("%s\n", as_str(std::is_integral&lt;float&gt;::value)); <span class="ent">➑</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">True <span class="ent">➋</span></span>&#13;
<span class="color1">True <span class="ent">➌</span></span>&#13;
<span class="color1">True <span class="ent">➍</span></span>&#13;
<span class="color1">True <span class="ent">➎</span></span>&#13;
<span class="color1">False <span class="ent">➏</span></span>&#13;
<span class="color1">False <span class="ent">➐</span></span>&#13;
<span class="color1">False <span class="ent">➑</span></span></pre>&#13;
<p class="listing"><a id="ch06ex18"/><em>Listing 6-18: A program using type traits</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_166"/><a href="ch06.xhtml#ch06ex18">Listing 6-18</a> defines the convenience function <span class="literal">as_str</span> <span class="ent">➊</span> to print Boolean values with the string <span class="literal">True</span> or <span class="literal">False</span>. Within <span class="literal">main</span>, you print the result of various type trait instantiations. The template parameters <span class="literal">int</span> <span class="ent">➋, const int</span> <span class="ent">➌</span>, char <span class="ent">➍</span>, and <span class="literal">uint64_t</span> <span class="ent">➎</span> all return <span class="literal">true</span> when passed to <span class="literal">is_integral</span>. Reference types <span class="ent">➏➐</span> and floating-point types <span class="ent">➑</span> return <span class="literal">false</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Recall that <span class="literal">printf</span> doesn’t have a format specifier for <span class="literal">bool</span>. Rather than using the integer format specifier <span class="literal">%d</span> as a stand-in, <a href="ch06.xhtml#ch06ex18">Listing 6-18</a> employs the <span class="literal">as_str</span> function, which returns the string literal <span class="literal">True</span> or <span class="literal">False</span> depending on the value of the <span class="literal">bool</span>. Because these values are string literals, you can capitalize them however you like</em>.</p>&#13;
</div>&#13;
<p class="indent">Type traits are often the building blocks for a concept, but sometimes you need more flexibility. Type traits tell you <em>what</em> types are, but sometimes you must also specify <em>how</em> the template will use them. For this, you use requirements.</p>&#13;
<h4 class="h4" id="ch06lev2sec12"><strong><em>Requirements</em></strong></h4>&#13;
<p class="noindent"><em>Requirements</em> are ad hoc constraints on template parameters. Each concept can specify any number of requirements on its template parameters. Requirements are encoded into requires expressions denoted by the <span class="literal">requires</span> keyword followed by function arguments and a body.</p>&#13;
<p class="indent">A sequence of syntactic requirements comprises the requirements expression’s body. Each syntactic requirement puts a constraint on the template parameters. Together, requires expressions have the following form:</p>&#13;
<pre>requires (<span class="codeitalic1">arg-1</span>, <span class="codeitalic1">arg-2</span>, ...<span class="ent">➊</span>) {&#13;
  { <span class="codeitalic1">expression1</span><span class="ent">➋</span> } -&gt; <span class="codeitalic1">return-type1</span><span class="ent">➌</span>;&#13;
  { <span class="codeitalic1">expression2</span> } -&gt; <span class="codeitalic1">return-type2</span>;&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="indent">Requires expressions take arguments that you place after the <span class="literal">requires</span> keyword <span class="ent">➊</span>. These arguments have types derived from template parameters. The syntactic requirements follow, each denoted with <span class="literal">{ } -&gt;</span>. You put an arbitrary expression within each of the braces <span class="ent">➋</span>. This expression can involve any number of the arguments to the argument expression.</p>&#13;
<p class="indent">If an instantiation causes a syntactic expression not to compile, that syntactic requirement fails. Supposing the expression evaluates without error, the next check is whether the return type of that expression matches the type given after the arrow <span class="literal">-&gt;</span> <span class="ent">➌</span>. If the expression result’s evaluated type can’t implicitly convert to the return type <span class="ent">➌</span>, the syntactic requirement fails.</p>&#13;
<p class="indent">If any of the syntactic requirements fail, the requires expression evaluates to <span class="literal">false</span>. If all of the syntactic requirements pass, the requires expression evaluates to <span class="literal">true</span>.</p>&#13;
<p class="indent">Suppose you have two types, <span class="literal">T</span> and <span class="literal">U</span>, and you want to know whether you can compare objects of these types using the equality <span class="literal">==</span> and inequality <span class="literal">!=</span> operators. One way to encode this requirement is to use the following expression.</p>&#13;
<pre><span epub:type="pagebreak" id="page_167"/>// T, U are types&#13;
requires (T t, U u) {&#13;
  { t == u } -&gt; bool; // syntactic requirement 1&#13;
  { u == t } -&gt; bool; // syntactic requirement 2&#13;
  { t != u } -&gt; bool; // syntactic requirement 3&#13;
  { u != t } -&gt; bool; // syntactic requirement 4&#13;
}</pre>&#13;
<p class="indent">The requires expression takes two arguments, one each of types <span class="literal">T</span> and <span class="literal">U</span>. Each of the syntactic requirements contained in the requires expression is an expression using <span class="literal">t</span> and <span class="literal">u</span> with either <span class="literal">==</span> or <span class="literal">!=</span>. All four syntactic requirements enforce a <span class="literal">bool</span> result. Any two types that satisfy this requires expression are guaranteed to support comparison with <span class="literal">==</span> and <span class="literal">!=</span>.</p>&#13;
<h4 class="h4" id="ch06lev2sec13"><strong><em>Building Concepts from Requires Expressions</em></strong></h4>&#13;
<p class="noindent">Because requires expressions are evaluated at compile time, concepts can contain any number of them. Try to construct a concept that guards against the misuse of <span class="literal">mean</span>. <a href="ch06.xhtml#ch06ex19">Listing 6-19</a> annotates some of the implicit requirements used earlier in <a href="ch06.xhtml#ch06ex10">Listing 6-10</a>.</p>&#13;
<pre>template&lt;typename T&gt;&#13;
T mean(T* values, size_t length) {&#13;
  T result{}; <span class="ent">➊</span>&#13;
  for(size_t i{}; i&lt;length; i++) {&#13;
    result <span class="ent">➋</span>+= values[i];&#13;
  }&#13;
  <span class="ent">➌</span>return result / length;&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex19"/><em>Listing 6-19: A relisting of 6-10 with annotations for some implicit requirements on <span class="literal">T</span></em></p>&#13;
<p class="indent">You can see three requirements implied by this code:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">T</span> must be default constructible <span class="ent">➊</span>.</li>&#13;
<li class="noindent"><span class="literal">T</span> supports <span class="literal">operator+=</span> <span class="ent">➋</span>.</li>&#13;
<li class="noindent">Dividing a <span class="literal">T</span> by a <span class="literal">size_t</span> yields a <span class="literal">T</span> <span class="ent">➌</span>.</li>&#13;
</ul>&#13;
<p class="indent">From these requirements, you could create a concept called <span class="literal">Averageable</span>, as demonstrated in <a href="ch06.xhtml#ch06ex20">Listing 6-20</a>.</p>&#13;
<pre>template&lt;typename T&gt;&#13;
concept bool Averageable() {&#13;
  return std::is_default_constructible&lt;T&gt;::value <span class="ent">➊</span>&#13;
    &amp;&amp; requires (T a, T b) {&#13;
      { a += b } -&gt; T; <span class="ent">➋</span>&#13;
      { a / size_t{ 1 } } -&gt; T; <span class="ent">➌</span>&#13;
    };&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex20"/><em>Listing 6-20: An <span class="literal">Averageable</span> concept. Annotations are consistent with the requirements and the body of <span class="literal">mean</span>.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_168"/>You use the type trait <span class="literal">is_default_constructible</span> to ensure that <span class="literal">T</span> is default constructible <span class="ent">➊</span>, that you can add two <span class="literal">T</span> types <span class="ent">➋</span>, and that you can divide a <span class="literal">T</span> by a <span class="literal">size_t</span> <span class="ent">➌</span> and get a result of type <span class="literal">T</span>.</p>&#13;
<p class="indent">Recall that concepts are just predicates; you’re building a Boolean expression that evaluates to <span class="literal">true</span> when the template parameters are supported and <span class="literal">false</span> when they’re not. The concept is composed of a type trait <span class="ent">➊</span> and a requires containing two requirement expressions <span class="ent">➋➌</span>. If any of the three returns <span class="literal">false</span>, the concept’s constraints are not met.</p>&#13;
<h4 class="h4" id="ch06lev2sec14"><strong><em>Using Concepts</em></strong></h4>&#13;
<p class="noindent">Declaring concepts is a lot more work than using them. To use a concept, just use the concept’s name in place of the <span class="literal">typename</span> keyword.</p>&#13;
<p class="indent">For example, you can refactor <a href="ch06.xhtml#ch06ex13">Listing 6-13</a> with the <span class="literal">Averageable</span> concept, as shown in <a href="ch06.xhtml#ch06ex21">Listing 6-21</a>.</p>&#13;
<pre>#include &lt;cstddef&gt;&#13;
#include &lt;type_traits&gt;&#13;
&#13;
template&lt;typename T&gt;&#13;
concept bool Averageable() { <span class="ent">➊</span>&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
template&lt;Averageable<span class="ent">➋</span> T&gt;&#13;
T mean(const T* values, size_t length) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
int main() {&#13;
  const double nums_d[] { 1.0f, 2.0f, 3.0f, 4.0f };&#13;
  const auto result1 = mean(nums_d, 4);&#13;
  printf("double: %f\n", result1);&#13;
&#13;
  const float nums_f[] { 1.0, 2.0, 3.0, 4.0 };&#13;
  const auto result2 = mean(nums_f, 4);&#13;
  printf("float: %f\n", result2);&#13;
&#13;
  const size_t nums_c[] { 1, 2, 3, 4 };&#13;
  const auto result3 = mean(nums_c, 4);&#13;
  printf("size_t: %d\n", result3);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">double: 2.500000</span>&#13;
<span class="color1">float: 2.500000</span>&#13;
<span class="color1">size_t: 2</span></pre>&#13;
<p class="listing"><a id="ch06ex21"/><em>Listing 6-21: A refactor of <a href="ch06.xhtml#ch06ex13">Listing 6-13</a> using <span class="literal">Averageable</span></em></p>&#13;
<p class="indent">After defining <span class="literal">Averageable</span> <span class="ent">➊</span>, you just use it in place of <span class="literal">typename</span> <span class="ent">➋</span>. No further modification is necessary. The code generated from compiling <a href="ch06.xhtml#ch06ex13">Listing 6-13</a> is identical to the code generated from compiling <a href="ch06.xhtml#ch06ex21">Listing 6-21</a>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_169"/>The payoff is when you get to try to use <span class="literal">mean</span> with a type that is not <span class="literal">Averageable</span>: you get a compiler error at the point of instantiation. This produces much better compiler error messages than you would obtain from a raw template.</p>&#13;
<p class="indent">Look at the instantiation of <span class="literal">mean</span> in <a href="ch06.xhtml#ch06ex22">Listing 6-22</a> where you “accidentally” try to average an array of <span class="literal">double</span> pointers.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>—&#13;
int main() {&#13;
  auto value1 = 0.0;&#13;
  auto value2 = 1.0;&#13;
  const double* values[] { &amp;value1, &amp;value2 };&#13;
  mean(values<span class="ent">➊</span>, 2);&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex22"/><em>Listing 6-22: A bad template instantiation using a non-<span class="literal">Averageable</span> argument</em></p>&#13;
<p class="indent">There are several problems with using <span class="literal">values</span> <span class="ent">➊</span>. What can the compiler tell you about those problems?</p>&#13;
<p class="indent">Without concepts, GCC 6.3 produces the error message shown in <a href="ch06.xhtml#ch06ex23">Listing 6-23</a>.</p>&#13;
<pre>&lt;source&gt;: In instantiation of 'T mean(const T*, size_t) [with T = const&#13;
double*; size_t = long unsigned int]':&#13;
&lt;source&gt;:17:17:   required from here&#13;
&lt;source&gt;:8:12: error: invalid operands of types 'const double*' and 'const&#13;
double*' to binary 'operator+'&#13;
     result += values[i]; <span class="ent">➊</span>&#13;
     ~~~~~~~^~~~~~~~~~&#13;
&lt;source&gt;:8:12: error:   in evaluation of 'operator+=(const double*, const&#13;
double*)'&#13;
&lt;source&gt;:10:17: error: invalid operands of types 'const double*' and 'size_t'&#13;
{aka 'long unsigned int'} to binary 'operator/'&#13;
   return result / length; <span class="ent">➋</span>&#13;
          ~~~~~~~^~~~~~~~</pre>&#13;
<p class="listing"><a id="ch06ex23"/><em>Listing 6-23: Error message from GCC 6.3 when compiling <a href="ch06.xhtml#ch06ex22">Listing 6-22</a></em></p>&#13;
<p class="indent">You might expect a casual user of <span class="literal">mean</span> to be extremely confused by this error message. What is <span class="literal">i</span> <span class="ent">➊</span>? Why is a <span class="literal">const double*</span> involved in division <span class="ent">➋</span>?</p>&#13;
<p class="indent">Concepts provide a far more illuminating error message, as <a href="ch06.xhtml#ch06ex24">Listing 6-24</a> demonstrates.</p>&#13;
<pre>&lt;source&gt;: In function 'int main()':&#13;
&lt;source&gt;:28:17: error: cannot call function 'T mean(const T*, size_t) [with T&#13;
= const double*; size_t = long unsigned int]'&#13;
   mean(values, 2); <span class="ent">➊</span>&#13;
                 ^&#13;
&lt;source&gt;:16:3: note:   constraints not satisfied&#13;
 T mean(const T* values, size_t length) {&#13;
   ^~~~&#13;
&#13;
&lt;source&gt;:6:14: note: within 'template&lt;class T&gt; concept bool Averageable()&#13;
[with T = const double*]'&#13;
 <span epub:type="pagebreak" id="page_170"/>concept bool Averageable() {&#13;
              ^~~~~~~~~~~&#13;
&lt;source&gt;:6:14: note:     with 'const double* a'&#13;
&lt;source&gt;:6:14: note:     with 'const double* b'&#13;
&lt;source&gt;:6:14: note: the required expression '(a + b)' would be ill-formed <span class="ent">➋</span>&#13;
&lt;source&gt;:6:14: note: the required expression '(a / b)' would be ill-formed <span class="ent">➌</span></pre>&#13;
<p class="listing"><a id="ch06ex24"/><em>Listing 6-24: Error message from GCC 7.2 when compiling <a href="ch06.xhtml#ch06ex22">Listing 6-22</a> with concepts enabled</em></p>&#13;
<p class="indent">This error message is fantastic. The compiler tells you which argument (<span class="literal">values</span>) didn’t meet a constraint <span class="ent">➊</span>. Then it tells you that <span class="literal">values</span> is not <span class="literal">Averageable</span> because it doesn’t satisfy two required expressions <span class="ent">➋➌</span>. You know immediately how to modify your arguments to make this template instantiation successful.</p>&#13;
<p class="indent">When concepts incorporate into the C++ standard, it’s likely that the stdlib will include many concepts. The design goal of concepts is that a programmer shouldn’t have to define very many concepts on their own; rather, they should be able to combine concepts and ad hoc requirements within a template prefix. <a href="ch06.xhtml#ch06tab02">Table 6-2</a> provides a partial listing of some concepts you might expect to be included; these are borrowed from Andrew Sutton’s implementation of concepts in the Origins Library.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>See <a href="https://github.com/asutton/origin/">https://github.com/asutton/origin/</a> for more information on the Origins Library. To compile the examples that follow, you can install Origins and use GCC version 6.0 or later with the <span class="literal">-fconcepts</span> flag.</em></p>&#13;
</div>&#13;
<p class="tabcap" id="ch06tab02"><strong>Table 6-2:</strong> The Concepts Contained in the Origins Library</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Concept</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>A type that …</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">Conditional</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Can be explicitly converted to <span class="literal">bool</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">Boolean</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Is <span class="literal">Conditional</span> and supports <span class="literal">!</span>, <span class="literal">&amp;&amp;</span>, and <span class="literal">||</span> Boolean operations</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">Equality_comparable</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Supports <span class="literal">==</span> and <span class="literal">!=</span> operations returning a <span class="literal">Boolean</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">Destructible</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Can be destroyed (compare <span class="literal">is_destructible</span>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">Default_constructible</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Is default constructible (compare <span class="literal">is_default_constructible</span>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">Movable</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Supports move semantics: it must be move assignable and move constructible (compare <span class="literal">is_move_assignable</span>, <span class="literal">is_move_constructible</span>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">Copyable</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Supports copy semantics: it must be copy assignable and copy constructible (compare <span class="literal">is_copy_assignable</span>, <span class="literal">is_copy_constructible</span>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">Regular</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Is default constructible, copyable, and <span class="literal">Equality_comparable</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">Ordered</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Is <span class="literal">Regular</span> and is totally ordered (essentially, it can be sorted)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">Number</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Is <span class="literal">Ordered</span> and supports math operations like <span class="literal">+</span>, <span class="literal">-</span>, <span class="literal">/</span>, and <span class="literal">*</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">Function</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Supports invocation; that is, you can call it (compare <span class="literal">is_invocable</span>)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">Predicate</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Is a <span class="literal">Function</span> and returns <span class="literal">bool</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">Range</span></p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Can be iterated over in a range-based <span class="literal">for</span> loop</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_171"/>There are several ways to build constraints into a template prefix. If a template parameter is only used to declare the type of a function parameter, you can omit the template prefix entirely:</p>&#13;
<pre>return-type function-name(Concept1<span class="ent">➊</span> arg-1, …) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="indent">Because you use a concept rather than a <span class="literal">typename</span> to define an argument’s type <span class="ent">➊</span>, the compiler knows that the associated function is a template. You are even free to mix concepts and concrete types in the argument list. In other words, whenever you use a concept as part of a function definition, that function becomes a template.</p>&#13;
<p class="indent">The template function in <a href="ch06.xhtml#ch06ex25">Listing 6-25</a> takes an array of <span class="literal">Ordered</span> elements and finds the minimum.</p>&#13;
<pre>#include &lt;origin/core/concepts.hpp&gt;&#13;
size_t index_of_minimum(Ordered<span class="ent">➊</span>* x, size_t length) {&#13;
  size_t min_index{};&#13;
  for(size_t i{ 1 }; i&lt;length; i++) {&#13;
    if(x[i] &lt; x[min_index]) min_index = i;&#13;
  }&#13;
  return min_index;&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex25"/><em>Listing 6-25: A template function using the <span class="literal">Ordered</span> concept</em></p>&#13;
<p class="indent">Even though there’s no template prefix, <span class="literal">index_of_minimum</span> is a template because <span class="literal">Ordered</span> <span class="ent">➊</span> is a concept. This template can be instantiated in the same way as any other template function, as demonstrated in <a href="ch06.xhtml#ch06ex26">Listing 6-26</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
#include &lt;cstdint&gt;&#13;
#include &lt;origin/core/concepts.hpp&gt;&#13;
&#13;
struct Goblin{};&#13;
&#13;
size_t index_of_minimum(Ordered* x, size_t length) {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
int main() {&#13;
  int x1[] { -20, 0, 100, 400, -21, 5123 };&#13;
  printf("%zu\n", index_of_minimum(x1, 6)); <span class="ent">➊</span>&#13;
&#13;
  unsigned short x2[] { 42, 51, 900, 400 };&#13;
  printf("%zu\n", index_of_minimum(x2, 4)); <span class="ent">➋</span>&#13;
&#13;
  Goblin x3[] { Goblin{}, Goblin{} };&#13;
  //index_of_minimum(x3, 2); <span class="ent">➌</span> // Bang! Goblin is not Ordered.&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span epub:type="pagebreak" id="page_172"/><span class="color1">4 <span class="ent">➊</span></span>&#13;
<span class="color1">0 <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch06ex26"/><em>Listing 6-26: A listing employing <span class="literal">index_of_minimum</span> from <a href="ch06.xhtml#ch06ex25">Listing 6-25</a>. Uncommenting</em> <span class="ent">➌</span> <em>causes compilation to fail.</em></p>&#13;
<p class="indent">The instantiations for <span class="literal">int</span> <span class="ent">➊</span> and <span class="literal">unsigned short</span> <span class="ent">➋</span> arrays succeed because types are <span class="literal">Ordered</span> (see <a href="ch06.xhtml#ch06tab02">Table 6-2</a>).</p>&#13;
<p class="indent">However, the <span class="literal">Goblin</span> class is not <span class="literal">Ordered</span>, and template instantiation would fail if you tried to compile <span class="ent">➌</span>. Crucially, the error message would be informative:</p>&#13;
<pre>error: cannot call function 'size_t index_&#13;
of_minimum(auto:1*, size_t) [with auto:1 = Goblin; size_t = long unsigned int]'&#13;
   index_of_minimum(x3, 2); // Bang! Goblin is not Ordered.&#13;
                         ^&#13;
note:   constraints not satisfied&#13;
 size_t index_of_minimum(Ordered* x, size_t length) {&#13;
        ^~~~~~~~~~~~~~~~&#13;
&#13;
note: within 'template&lt;class T&gt; concept bool origin::Ordered() [with T =&#13;
Goblin]'&#13;
 Ordered()</pre>&#13;
<p class="indent">You know that the <span class="literal">index_of_minimum</span> instantiation failed and that the issue is with the <span class="literal">Ordered</span> concept.</p>&#13;
<h4 class="h4" id="ch06lev2sec15"><strong><em>Ad Hoc Requires Expressions</em></strong></h4>&#13;
<p class="noindent">Concepts are fairly heavyweight mechanisms for enforcing type safety. Sometimes, you just want to enforce some requirement directly in the template prefix. You can embed requires expressions directly into the template definition to accomplish this. Consider the <span class="literal">get_copy</span> function in <a href="ch06.xhtml#ch06ex27">Listing 6-27</a> that takes a pointer and safely returns a copy of the pointed-to object.</p>&#13;
<pre>#include &lt;stdexcept&gt;&#13;
&#13;
template&lt;typename T&gt;&#13;
  requires<span class="ent">➊</span> is_copy_constructible&lt;T&gt;::value <span class="ent">➋</span>&#13;
T get_copy(T* pointer) {&#13;
  if (!pointer) throw std::runtime_error{ "Null-pointer dereference" };&#13;
  return *pointer;&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex27"/><em>Listing 6-27: A template function with an ad hoc requires expression</em></p>&#13;
<p class="indent">The template prefix contains the <span class="literal">requires</span> keyword <span class="ent">➊</span>, which begins the requires expression. In this case, the type trait <span class="literal">is_copy_constructible</span> ensures that <span class="literal">T</span> is copyable <span class="ent">➋</span>. This way, if a user accidentally tries to <span class="literal">get_copy</span> with a pointer that points to an uncopyable object, they’ll be presented with a clear explanation of why template instantiation failed. Consider the example in <a href="ch06.xhtml#ch06ex28">Listing 6-28</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_173"/>#include &lt;stdexcept&gt;&#13;
#include &lt;type_traits&gt;&#13;
&#13;
template&lt;typename T&gt;&#13;
  requires std::is_copy_constructible&lt;T&gt;::value&#13;
T get_copy(T* pointer) { <span class="ent">➊</span>&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}&#13;
&#13;
struct Highlander {&#13;
  Highlander() = default; <span class="ent">➋</span>&#13;
  Highlander(const Highlander&amp;) = delete; <span class="ent">➌</span>&#13;
};&#13;
&#13;
int main() {&#13;
  Highlander connor; <span class="ent">➍</span>&#13;
  auto connor_ptr = &amp;connor; <span class="ent">➎</span>&#13;
  auto connor_copy = get_copy(connor_ptr); <span class="ent">➏</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">In function 'int main()':</span>&#13;
<span class="color1">error: cannot call function 'T get_copy(T*) [with T = Highlander]'</span>&#13;
   <span class="color1">auto connor_copy = get_copy(connor_ptr);</span>&#13;
                                         <span class="color1">^</span>&#13;
<span class="color1">note:   constraints not satisfied</span>&#13;
 <span class="color1">T get_copy(T* pointer) {</span>&#13;
   <span class="color1">^~~~~~~~</span>&#13;
&#13;
<span class="color1">note: 'std::is_copy_constructible::value' evaluated to false</span></pre>&#13;
<p class="listing"><a id="ch06ex28"/><em>Listing 6-28: Program using the <span class="literal">get_copy</span> template in <a href="ch06.xhtml#ch06ex27">Listing 6-27</a>. This code doesn’t compile.</em></p>&#13;
<p class="indent">The definition of <span class="literal">get_copy</span> <span class="ent">➊</span> is followed by a <span class="literal">Highlander</span> class definition, which contains a default constructor <span class="ent">➋</span> and a deleted copy constructor <span class="ent">➌</span>. Within <span class="literal">main</span>, you’ve initialized a <span class="literal">Highlander</span> <span class="ent">➍</span>, taken its reference <span class="ent">➎</span>, and attempted to instantiate <span class="literal">get_copy</span> with the result <span class="ent">➏</span>. Because there can be only one <span class="literal">Highlander</span> (it’s not copyable), <a href="ch06.xhtml#ch06ex28">Listing 6-28</a> produces an exquisitely clear error message.</p>&#13;
<h3 class="h3" id="ch06lev1sec8"><strong>static_assert: The Preconcepts Stopgap</strong></h3>&#13;
<p class="noindent">As of C++17, concepts aren’t part of the standard, so they’re not guaranteed to be available across compilers. There is a stopgap you can apply in the interim: the <span class="literal">static_assert</span> expression. These assertions evaluate at compile time. If an assertion fails, the compiler will issue an error and optionally provide a diagnostic message. A <span class="literal">static_assert</span> has the following form:</p>&#13;
<pre>static_assert(boolean-expression, optional-message);</pre>&#13;
<p class="indent">In the absence of concepts, you can include one or more <span class="literal">static_assert</span> expressions in the bodies of templates to assist users in diagnosing usage errors.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_174"/>Suppose you want to improve the error messages of <span class="literal">mean</span> without leaning on concepts. You can use type traits in combination with <span class="literal">static_assert</span> to achieve a similar result, as demonstrated in <a href="ch06.xhtml#ch06ex29">Listing 6-29</a>.</p>&#13;
<pre>#include &lt;type_traits&gt;&#13;
&#13;
template &lt;typename T&gt;&#13;
T mean(T* values, size_t length) {&#13;
  static_assert(std::is_default_constructible&lt;T&gt;(),&#13;
    "Type must be default constructible."); <span class="ent">➊</span>&#13;
  static_assert(std::is_copy_constructible&lt;T&gt;(),&#13;
    "Type must be copy constructible."); <span class="ent">➋</span>&#13;
  static_assert(std::is_arithmetic&lt;T&gt;(),&#13;
    "Type must support addition and division."); <span class="ent">➌</span>&#13;
  static_assert(std::is_constructible&lt;T, size_t&gt;(),&#13;
    "Type must be constructible from size_t."); <span class="ent">➍</span>&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex29"/><em>Listing 6-29: Using <span class="literal">static_assert</span> expressions to improve compile time errors in <span class="literal">mean</span> in <a href="ch06.xhtml#ch06ex10">Listing 6-10</a>.</em></p>&#13;
<p class="indent">You see the familiar type traits for checking that <span class="literal">T</span> is default <span class="ent">➊</span> and copy constructible <span class="ent">➋</span>, and you provide error methods to help users diagnose issues with template instantiation. You use <span class="literal">is_arithmetic</span> <span class="ent">➌</span>, which evaluates to <span class="literal">true</span> if the type parameter supports arithmetic operations (<span class="literal">+, -, /</span>, and <span class="literal">*</span>), and <span class="literal">is_constructible</span> <span class="ent">➍</span>, which determines whether you can construct a <span class="literal">T</span> from a <span class="literal">size_t</span>.</p>&#13;
<p class="indent">Using <span class="literal">static_assert</span> as a proxy for concepts is a hack, but it’s widely used. Using type traits, you can limp along until concepts are included in the standard. You’ll often see <span class="literal">static_assert</span> if you use modern third-party libraries; if you’re writing code for others (including future you), consider using <span class="literal">static_assert</span> and type traits.</p>&#13;
<p class="indent">Compilers, and often programmers, don’t read documentation. By baking requirements directly into the code, you can avoid stale documentation. In the absence of concepts, <span class="literal">static_assert</span> is a fine stopgap.</p>&#13;
<h3 class="h3" id="ch06lev1sec9"><strong>Non-Type Template Parameters</strong></h3>&#13;
<p class="noindent">A template parameter declared with the <span class="literal">typename</span> (or <span class="literal">class</span>) keyword is called a <em>type template parameter</em>, which is a stand-in for some yet-to-be-specified <em>type</em>. Alternatively, you can use <em>non-type template parameters</em>, which are stand-ins for some yet-to-be-specified <em>value</em>. Non-type template parameters can be any of the following:</p>&#13;
<ul>&#13;
<li class="noindent">An integral type</li>&#13;
<li class="noindent">An lvalue reference type</li>&#13;
<li class="noindent">A pointer (or pointer-to-member) type</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_175"/>A <span class="literal">std::nullptr_t</span> (the type of <span class="literal">nullptr</span>)</li>&#13;
<li class="noindent">An <span class="literal">enum class</span></li>&#13;
</ul>&#13;
<p class="indent">Using a non-type template parameter allows you to inject a value into the generic code at compile time. For example, you can construct a template function called <span class="literal">get</span> that checks for out-of-bounds array access at compile time by taking the index you want to access as a non-type template parameter.</p>&#13;
<p class="indent">Recall from <a href="ch03.xhtml#ch03">Chapter 3</a> that if you pass an array to a function, it decays into a pointer. You can instead pass an array reference with a particularly off-putting syntax:</p>&#13;
<pre><span class="codeitalic1">element-type</span>(<span class="codeitalic1">¶m-name</span>)[<span class="codeitalic1">array-length</span>]</pre>&#13;
<p class="indent">For example, <a href="ch06.xhtml#ch06ex30">Listing 6-30</a> contains a <span class="literal">get</span> function that makes a first attempt at performing bounds-checked array access.</p>&#13;
<pre>#include &lt;stdexcept&gt;&#13;
&#13;
int&amp; get(int (&amp;arr)[10]<span class="ent">➊</span>, size_t index<span class="ent">➋</span>) {&#13;
  if (index &gt;= 10) throw std::out_of_range{ "Out of bounds" }; <span class="ent">➌</span>&#13;
  return arr[index]; <span class="ent">➍</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex30"/><em>Listing 6-30: A function for accessing array elements with bounds checking</em></p>&#13;
<p class="indent">The <span class="literal">get</span> function accepts a reference to an <span class="literal">int</span> array of length 10 <span class="ent">➊</span> and an <span class="literal">index</span> to extract <span class="ent">➋</span>. If <span class="literal">index</span> is out of bounds, it throws an <span class="literal">out_of_bounds</span> exception <span class="ent">➌</span>; otherwise, it returns a reference to the corresponding element <span class="ent">➍</span>.</p>&#13;
<p class="indent">You can improve <a href="ch06.xhtml#ch06ex30">Listing 6-30</a> in three ways, which are all enabled by non-type template parameters genericizing the values out of <span class="literal">get</span>.</p>&#13;
<p class="indent">First, you can relax the requirement that <span class="literal">arr</span> refer to an <span class="literal">int</span> array by making <span class="literal">get</span> a template function, as in <a href="ch06.xhtml#ch06ex31">Listing 6-31</a>.</p>&#13;
<pre>#include &lt;stdexcept&gt;&#13;
&#13;
template &lt;typename T<span class="ent">➊</span>&gt;&#13;
T&amp;<span class="ent">➋</span> get(T<span class="ent">➌</span> (&amp;arr)[10], size_t index) {&#13;
  if (index &gt;= 10) throw std::out_of_range{ "Out of bounds" };&#13;
  return arr[index];&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex31"/><em>Listing 6-31: A refactor of <a href="ch06.xhtml#ch06ex30">Listing 6-30</a> to accept an array of a generic type</em></p>&#13;
<p class="indent">As you’ve done throughout this chapter, you’ve genericized the function by replacing a concrete type (here, <span class="literal">int</span>) with a template parameter <span class="ent">➊➋➌</span>.</p>&#13;
<p class="indent">Second, you can relax the requirement that <span class="literal">arr</span> refer to an array of length 10 by introducing a non-type template parameter <span class="literal">Length</span>. <a href="ch06.xhtml#ch06ex32">Listing 6-32</a> shows how: simply declare a <span class="literal">size_t Length</span> template parameter and use it in place of 10.</p>&#13;
<pre><span epub:type="pagebreak" id="page_176"/>#include &lt;stdexcept&gt;&#13;
&#13;
template &lt;typename T, size_t Length<span class="ent">➊</span>&gt;&#13;
T&amp; get (T(&amp;arr)[Length<span class="ent">➋</span>], size_t index) {&#13;
  if (index &gt;= Length<span class="ent">➌</span>) throw std::out_of_range{ "Out of bounds" };&#13;
  return arr[index];&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex32"/><em>Listing 6-32: A refactor of <a href="ch06.xhtml#ch06ex31">Listing 6-31</a> to accept an array of a generic length</em></p>&#13;
<p class="indent">The idea is the same: rather than replacing a specific type (<span class="literal">int</span>), you’ve replaced a specific integral value (<span class="literal">10</span>) <span class="ent">➊➋➌</span>. Now you can use the function with arrays of any size.</p>&#13;
<p class="indent">Third, you can perform compile time bounds checking by taking <span class="literal">size_t index</span> as another non-type template parameter. This allows you to replace the <span class="literal">std::out_of_range</span> with a <span class="literal">static_assert</span>, as in <a href="ch06.xhtml#ch06ex33">Listing 6-33</a>.</p>&#13;
<pre>#include &lt;cstdio&gt;&#13;
&#13;
template &lt;size_t Index<span class="ent">➊</span>, typename T, size_t Length&gt;&#13;
T&amp; get(T (&amp;arr)[Length]) {&#13;
  static_assert(Index &lt; Length, "Out-of-bounds access"); <span class="ent">➋</span>&#13;
  return arr[Index<span class="ent">➌</span>];&#13;
}&#13;
&#13;
int main() {&#13;
  int fib[]{ 1, 1, 2, 0 }; <span class="ent">➍</span>&#13;
  printf("%d %d %d ", get&lt;0&gt;(fib), get&lt;1&gt;(fib), get&lt;2&gt;(fib)); <span class="ent">➎</span>&#13;
  get&lt;3&gt;(fib) = get&lt;1&gt;(fib) + get&lt;2&gt;(fib); <span class="ent">➏</span>&#13;
  printf("%d", get&lt;3&gt;(fib)); <span class="ent">➐</span>&#13;
  //printf("%d", get&lt;4&gt;(fib)); <span class="ent">➑</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">1 1 2 <span class="ent">➎</span>3 <span class="ent">➐</span></span></pre>&#13;
<p class="listing"><a id="ch06ex33"/><em>Listing 6-33: A program using compile time bounds-checked array accesses</em></p>&#13;
<p class="indent">You’ve moved the <span class="literal">size_t</span> index parameter into a non-type template parameter <span class="ent">➊</span> and updated the array access with the correct name <span class="literal">Index</span> <span class="ent">➌</span>. Because <span class="literal">Index</span> is now a compile time constant, you also replace the <span class="literal">logic_error</span> with a <span class="literal">static_assert</span>, which prints the friendly message <span class="literal">Out-of-bounds access</span> whenever you accidentally try to access an out-of-bounds element <span class="ent">➋</span>.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06ex33">Listing 6-33</a> also contains example usage of get in <span class="literal">main</span>. You’ve first declared an <span class="literal">int</span> array <span class="literal">fib</span> of length 4 <span class="ent">➍</span>. You then print the first three elements of the array using <span class="literal">get</span> <span class="ent">➎</span>, set the fourth element <span class="ent">➏</span>, and print it <span class="ent">➐</span>. If you uncomment the out-of-bounds access <span class="ent">➑</span>, the compiler will generate an error thanks to the <span class="literal">static_assert</span>.</p>&#13;
<h3 class="h3" id="ch06lev1sec10"><strong>Variadic Templates</strong></h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_177"/>Sometimes, templates must take in an unknown number of arguments. The compiler knows these arguments at template instantiation, but you want to avoid having to write many different templates each for different numbers of arguments. This is the raison d’être of variadic templates. <em>Variadic templates</em> take a variable number of arguments.</p>&#13;
<p class="indent">You denote variadic templates using a final template parameter that has a special syntax, namely <span class="literal">typename... arguments</span>. The ellipsis indicates that <span class="literal">arguments</span> is a <em>parameter pack type</em>, meaning you can declare parameter packs within your template. A parameter pack is a template argument that accepts zero or more function arguments. These definitions can seem a bit abstruse, so consider the following sample variadic template that builds upon <span class="literal">SimpleUniquePointer</span>.</p>&#13;
<p class="indent">Recall from <a href="ch06.xhtml#ch06ex14">Listing 6-14</a> that you pass a raw pointer into the constructor of <span class="literal">SimpleUniquePointer</span>. <a href="ch06.xhtml#ch06ex34">Listing 6-34</a> implements a <span class="literal">make_simple_unique</span> function that handles construction of the underlying type.</p>&#13;
<pre>template &lt;typename T, typename... Arguments<span class="ent">➊</span>&gt;&#13;
SimpleUniquePointer&lt;T&gt; make_simple_unique(Arguments... arguments<span class="ent">➋</span>) {&#13;
  return SimpleUniquePointer&lt;T&gt;{ new T{ arguments...<span class="ent">➌</span> } };&#13;
}</pre>&#13;
<p class="listing"><a id="ch06ex34"/><em>Listing 6-34: Implementing a <span class="literal">make_simple_unique</span> function to ease <span class="literal">SimpleUniquePointer</span> usage</em></p>&#13;
<p class="indent">You define the parameter pack type <span class="literal">Arguments</span> <span class="ent">➊</span>, which declares <span class="literal">make_simple_unique</span> as a variadic template. This function passes arguments <span class="ent">➋</span> to the constructor of template parameter <span class="literal">T</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">The upshot is you can now create <span class="literal">SimpleUniquePointers</span> very easily, even when the pointed-to object has a non-default constructor.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>There is a slightly more efficient implementation of <a href="ch06.xhtml#ch06ex34">Listing 6-34</a>. If <span class="literal">arguments</span> is an rvalue, you can move it directly into the constructor of <span class="literal">T</span>. The stdlib contains a function called <span class="literal">std::forward</span> in the <span class="literal">&lt;utility&gt;</span> header that will detect whether <span class="literal">arguments</span> is an lvalue or rvalue and perform a copy or move, respectively. See Item 23 in Effective Modern C++ by Scott Meyers.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch06lev1sec11"><strong>Advanced Template Topics</strong></h3>&#13;
<p class="noindent">For everyday polymorphic programming, templates are your go-to tool. It turns out that templates are also used in a wide range of advanced settings, especially in implementing libraries, high-performance programs, and embedded system firmware. This section outlines some of the major terrain features of this vast space.</p>&#13;
<h4 class="h4" id="ch06lev2sec16"><span epub:type="pagebreak" id="page_178"/><strong><em>Template Specialization</em></strong></h4>&#13;
<p class="noindent">To understand advanced template usage, you must first understand <em>template specialization</em>. Templates can actually take more than just <span class="literal">concept</span> and <span class="literal">typename</span> parameters (type parameters). They can also accept fundamental types, like <span class="literal">char</span> (value parameters), as well as other templates. Given the tremendous flexibility of template parameters, you can make a lot of compile-time decisions about their features. You could have different versions of templates depending on the characteristics of these parameters. For example, if a type parameter is <span class="literal">Ordered</span> instead of <span class="literal">Regular</span>, you might be able to make a generic program more efficient. Programming this way is called <em>template specialization</em>. Refer to the ISO standard [temp.spec] for more information about template specialization.</p>&#13;
<h4 class="h4" id="ch06lev2sec17"><strong><em>Name Binding</em></strong></h4>&#13;
<p class="noindent">Another critical component of how templates get instantiated is name binding. Name binding helps determine the rules for when the compiler matches a named element within a template to a concrete implementation. The named element could, for example, be part of the template definition, a local name, a global name, or from some named namespace. If you want to write heavily templated code, you need to understand how this binding occurs. If you’re in such a situation, refer to <a href="ch09.xhtml#ch09">Chapter 9</a>, “Names in Templates,” in <em>C++ Templates: The Complete Guide</em> by David Vandevoorde et al. and to [temp.res].</p>&#13;
<h4 class="h4" id="ch06lev2sec18"><strong><em>Type Function</em></strong></h4>&#13;
<p class="noindent">A <em>type function</em> takes types as arguments and returns a type. The type traits with which you build up concepts are closely related to type functions. You can combine type functions with compile time control structures to do general computation, such as programming control flow, at compile time. Generally, programming using these techniques is called <em>template metaprogramming</em>.</p>&#13;
<h4 class="h4" id="ch06lev2sec19"><strong><em>Template Metaprogramming</em></strong></h4>&#13;
<p class="noindent">Template metaprogramming has a deserved reputation for resulting in code that is exceedingly clever and absolutely inscrutable to all but the mightiest of wizards. Fortunately, once concepts are part of the C++ standard, template metaprogramming should become more approachable to us mere mortals. Until then, tread carefully. For those interested in further detail on this topic, refer to <em>Modern C++ Design: Generic Programming and Design Patterns Applied</em> by Andrei Alexandrescu and <em>C++ Templates: The Complete Guide</em> by David Vandevoorde et al.</p>&#13;
<h3 class="h3" id="ch06lev1sec12"><span epub:type="pagebreak" id="page_179"/><strong>Template Source Code Organization</strong></h3>&#13;
<p class="noindent">Each time a template is instantiated, the compiler must be able to generate all the code necessary to use the template. This means all the information about how to instantiate a custom class or function must be available within the same translation unit as the template instantiation. By far, the most popular way to achieve this is to implement templates entirely within header files.</p>&#13;
<p class="indent">There are some modest inconveniences associated with this approach. Compile times can increase, because templates with the same parameters might get instantiated multiple times. It also decreases your ability to hide implementation details. Fortunately, the benefits of generic programming far outweigh these inconveniences. (Major compilers will probably minimize the problems of compile times and code duplication anyway.)</p>&#13;
<p class="indent">There are even a few advantages to having header-only templates:</p>&#13;
<ul>&#13;
<li class="noindent">It’s very easy for others to use your code: it’s a matter of applying <span class="literal">#include</span> to some headers (rather than compiling the library, ensuring the resulting object files are visible to the linker, and so on).</li>&#13;
<li class="noindent">It’s trivially easy for compilers to inline header-only templates, which can lead to faster code at runtime.</li>&#13;
<li class="noindent">Compilers can generally do a better job of optimizing code when all of the source is available.</li>&#13;
</ul>&#13;
<h3 class="h3" id="ch06lev1sec13"><strong>Polymorphism at Runtime vs. Compile Time</strong></h3>&#13;
<p class="noindent">When you want polymorphism, you should use templates. But sometimes you can’t use templates because you won’t know the types used with your code until runtime. Remember that template instantiation only occurs when you pair a template’s parameters with types. At this point, the compiler can instantiate a custom class for you. In some situations, you might not be able to perform such pairings until your program is executing (or, at least, performing such pairing at compile time would be tedious).</p>&#13;
<p class="indent">In such cases, you can use runtime polymorphism. Whereas the template is the mechanism for achieving compile-time polymorphism, the runtime mechanism is the interface.</p>&#13;
<h3 class="h3" id="ch06lev1sec14"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you explored polymorphism in C++. The chapter started with a discussion of what polymorphism is and why it’s so tremendously useful. You explored how to achieve polymorphism at compile time with templates. You learned about type checking with concepts and then explored some advanced topics, such as variadic templates and template metaprogramming.</p>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_180"/><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>6-1.</strong> The mode of a series of values is the value that appears most commonly. Implement a mode function using the following signature: <span class="literal">int mode(constint* values, size_t length)</span>. If you encounter an error condition, such as input having multiple modes and no values, return zero.</p>&#13;
<p class="noindent"><strong>6-2.</strong> Implement <span class="literal">mode</span> as a template function.</p>&#13;
<p class="noindent"><strong>6-3.</strong> Modify mode to accept an <span class="literal">Integer</span> concept. Verify that mode fails to instantiate with floating types like  <span class="literal">double</span>.</p>&#13;
<p class="noindent"><strong>6-4.</strong> Refactor <span class="literal">mean</span> in <a href="ch06.xhtml#ch06ex13">Listing 6-13</a> to accept an array rather than pointer and length arguments. Use <a href="ch06.xhtml#ch06ex33">Listing 6-33</a> as a guide.</p>&#13;
<p class="noindent"><strong>6-5.</strong> Using the example from <a href="ch05.xhtml#ch05">Chapter 5</a>, make <span class="literal">Bank</span> a template class that accepts a template parameter. Use this type parameter as the type of an account rather than  <span class="literal">long</span>. Verify that your code still works using a <span class="literal">Bank&lt;long&gt;</span> class.</p>&#13;
<p class="noindent"><strong>6-6.</strong> Implement an <span class="literal">Account</span> class and instantiate a  <span class="literal">Bank&lt;Account&gt;</span>. Implement functions in <span class="literal">Account</span> to keep track of balances.</p>&#13;
<p class="noindent"><strong>6-7.</strong> Make <span class="literal">Account</span> an interface. Implement a  <span class="literal">CheckingAccount</span> and  <span class="literal">SavingsAccount</span>. Create a program with several checking and savings accounts. Use a <span class="literal">Bank&lt;Account&gt;</span> to make several transactions between the accounts.</p>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>C++ Templates: The Complete Guide</em>, 2nd Edition, by David Vandevoorde, Nicolai M. Josuttis, and Douglas Gregor (Addison-Wesley, 2017)</li>&#13;
<li class="noindent"><em>Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14</em> by Scott Meyers (O’Reilly Media, 2015)</li>&#13;
<li class="noindent"><em>The C++ Programming Language</em>, 4th Edition, by Bjarne Stroustrup (Pearson Education, 2013)</li>&#13;
<li class="noindent"><em>Modern C++ Design: Generic Programming and Design Patterns Applied</em> by Andrei Alexandrescu (Addison-Wesley, 2001)</li>&#13;
</ul>&#13;
</div>&#13;
</body></html>