<html><head></head><body><div id="sbo-rt-content"><span epub:type="pagebreak" id="page_183"/>
<h2 class="h2" id="ch09"><strong><span class="big">9</span><br/>CROSS-REFERENCES</strong></h2>
<div class="image1"><img src="Images/com.jpg" alt="Image" width="204" height="204"/></div>
<p class="noindent">Two common questions asked while reverse engineering a binary are “Where is this function called from?” and “Which functions access this data?” These and other similar questions seek to identify and catalog the references to and from various resources in a program. The following two examples serve to show the usefulness of such questions.</p>
<p class="listhead"><strong>Example 1</strong></p>
<p class="listbody">While you are reviewing the large number of ASCII strings in a particular binary, you see a string that seems particularly suspicious: “Pay within 72 hours or the recovery key will be destroyed and your data will remain encrypted forever.” On its own, this string is just circumstantial evidence. It in no way confirms that the binary has the capability or intent to execute a crypto ransomware attack. The answer to the question “Where is this string referenced in the binary?” would help <span epub:type="pagebreak" id="page_184"/>you to quickly track down the program location(s) that makes use of the string. This information, in turn, should assist you in locating any related crypto ransomware code that uses the string or to demonstrate that the string, in this context, is benign.</p>
<p class="listhead"><strong>Example 2</strong></p>
<p class="listbody">You have located a function containing a stack-allocated buffer that can be overflowed, possibly leading to exploitation of the program, and you want to determine if this is actually possible. If you want to develop and demonstrate an exploit, the function is useless to you unless you can get it to execute. This leads to the question “Which functions call this vulnerable function?” as well as additional questions regarding the nature of the data that those functions may pass to the vulnerable function. This line of reasoning must continue as you work your way back up potential call chains to find one that you can influence to demonstrate that the overflow is exploitable.</p>
<h3 class="h3" id="ch09lev169"><strong>Referencing Basics</strong></h3>
<p class="noindent">Ghidra can help you analyze both of these cases (and many others) through its extensive mechanisms for displaying and accessing reference information. In this chapter, we discuss the types of references that Ghidra makes available, the tools for accessing reference information, and ways to interpret that information. In <a href="ch10.xhtml#ch10">Chapter 10</a>, we will use Ghidra’s graphing capabilities to examine visual representations of reference relationships.</p>
<p class="indent">All references obey the same general traffic rules. Associated with each reference is the notion of a direction. All references are made from one address to another address. If you are familiar with graph theory, you can think of addresses as nodes (or <em>vertices</em>) in a directed graph, and references as the <em>edges</em> that identify directed connections between the nodes. <a href="ch09.xhtml#fig9_1">Figure 9-1</a> provides a quick refresher on basic graph terminology. In this simple graph, three nodes—A, B, and C—are connected by two directed edges.</p>
<p class="indent">Directed edges are represented by arrows to indicate the allowable direction of travel along the edge. In <a href="ch09.xhtml#fig9_1">Figure 9-1</a>, travel from A to B is possible, but travel from B to A is not, similar to a one-way street. If the arrows were bidirectional, travel in either direction would be acceptable.</p>
<p class="indent">Ghidra has two basic categories of references: forward references and back references (each with subcategories as well). The back references are the less complex of the two types and are likely to be used most frequently in reverse engineering. Back references, also referred to as <em>cross-references</em>, provide a means to navigate between locations in the listing such as code and data.</p>
<div class="image"><img src="Images/fig9-1.jpg" alt="image" width="126" height="92"/></div>
<p class="figcap" id="fig9_1"><em>Figure 9-1: Directed graph with three nodes and two edges</em></p>
<span epub:type="pagebreak" id="page_185"/>
<h4 class="h4" id="ch09lev170"><strong><em>Cross-References (Back References)</em></strong></h4>
<p class="noindent">Back references within Ghidra are often referred to simply as <em>XREFs</em>, which is a mnemonic for the term <em>cross-reference</em>. Within this text, we use the term <em>XREF</em> only when referring to the specific sequence of characters (XREF) in a Ghidra listing, menu item, or dialog. In all other cases, we stick to the more general term <em>cross-reference</em> when referring to back references. Let’s start by looking at specific examples of XREFs in Ghidra before moving on to a more comprehensive example.</p>
<h5 class="h5" id="ch09lev171"><strong>Example 1: Basic XREFs</strong></h5>
<p class="noindent">Let’s begin by examining some of the XREFs that we encountered in <code>demo_stackframe</code> (see <a href="ch06.xhtml#ch06">Chapter 6</a>) and use the following listing to understand the associated format and meaning:</p>
<pre>     *******************************************************************<br/>
     *                         FUNCTION                                *<br/>
     *******************************************************************<br/>
     undefined demo_stackframe(undefined param_1, undefined4. . . <br/>
        undefined   AL:1            &lt;RETURN&gt;<br/>
        undefined   Stack[0x4]:4    param_1 <br/>
        undefined4  Stack[0x8]:4    param_2   XREF[1]:<span class="ent">➊</span>0804847f<span class="ent">➋</span>(R)<span class="ent">➌</span><br/>
        undefined4  Stack[0xc]:4    param_3   XREF[1]:  08048479(R) <br/>
        undefined4  Stack[-0x10]:4  local_10  XREF[1]:  0804847c(W)  <br/>
        undefined4  Stack[-0x14]:4  local_14  XREF[2]:  08048482(W), <br/>
                                                        08048493(R)  <br/>
        undefined4  Stack[-0x18]:4  local_18  XREF[2]:  08048485(W), <br/>
                                                        08048496(R)  <br/>
        undefined1  Stack[-0x58]:1  local_58  XREF[1]:  0804848c(W)  <br/>
     demo_stackframe                          XREF[4]:  Entry Point(*),  <br/>
                                                        main:080484be(c)<span class="ent">➍</span>, <br/>
                                                        080485e4, 08048690(*)  </pre>
<p class="indent">Ghidra not only indicates that there is a cross-reference with the indicator <code>XREF</code> <span class="ent">➊</span> but also shows the number of cross-references with an index value following <code>XREF</code>. This part of the cross-reference (for example, <code>XREF[2]:</code>) is called the <em>XREF header</em>. Examining the headers in the listing, we can see that most of the cross-references have only one referring address, but a few have more.</p>
<p class="indent">Following the header is the address associated with the cross-reference <span class="ent">➋</span>, which is a navigable object. Following the address, there is a type indicator in parentheses <span class="ent">➌</span>. For data cross-references (which is the case in this example), the valid types are <code>R</code> (indicating that the variable is read at the corresponding XREF address), <code>W</code> (indicating that the variable is being written to), and <code>*</code> (indicating that an address of a location is being taken as a pointer). In summary, <em>data cross-references</em> are identified in the listing where the data is declared, and associated XREF entries provide links to the locations where the data is referenced.</p>
<span epub:type="pagebreak" id="page_186"/>
<div class="box5">
<p class="boxtitle-c"><strong>FORMATTING XREFS</strong></p>
<p class="noindent">As with most items you encounter in the Listing window, you can control the attributes associated with the cross-reference display. Selecting Edit ▸ Tool Options opens the editable options for the CodeBrowser. Since an XREF is part of the Listing window, the XREFs Field can be found within the Listing Fields folder. When it is selected, it will open the dialog shown in <a href="ch09.xhtml#fig9_2">Figure 9-2</a> (here with default options). If you were to change Maximum Number of XREFs to Display to 2, the header for all cross-references exceeding this number would be displayed as <code>XREF[more]</code>. The option to display nonlocal namespaces allows you to quickly identify all of the cross-references that are not within the current function’s body. All of the options are explained in Ghidra Help.</p>
<div class="image"><img src="Images/fig9-2.jpg" alt="image" width="616" height="472"/></div>
<p class="figcap" id="fig9_2"><em>Figure 9-2: XREFs Field edit window showing defaults</em></p>
</div>
<p class="indent">The listing also contains a <em>code cross-reference</em> <span class="ent">➍</span>. Code cross-references are a very important concept, as they facilitate Ghidra’s generation of function graphs and function call graphs, which are the focus of <a href="ch10.xhtml#ch10">Chapter 10</a>. A code cross-reference is used to indicate that an instruction transfers or may transfer control to another instruction. The manner in which instructions transfer control is referred to as a <em>flow</em>. Flows may be any of three basic types: sequential, jump, or call. Jump and call flows can be further divided according to whether the target address is a near or far address.</p>
<p class="indent">A <em>sequential flow</em> is the simplest flow type, as it represents linear flow from one instruction to the next. This is the default execution flow for all nonbranching instructions such as <code>ADD</code>. There are no special display indicators <span epub:type="pagebreak" id="page_187"/>for sequential flows other than the order in which instructions are listed in the disassembly: if instruction A has a sequential flow to instruction B, then instruction B will immediately follow instruction A in the disassembly listing.</p>
<h5 class="h5" id="ch09lev172"><strong>Example 2: Jump and Call XREFs</strong></h5>
<p class="noindent">Let’s take a quick look at a new example containing code cross-references that demonstrate jumps and calls. As with data cross-references, code cross-references also have an associated XREF entry in the Listing window. The following listing shows information associated with the function <code>main</code>:</p>
<pre>     ********************************************************************<br/>
     *                         FUNCTION                                 *<br/>
     ********************************************************************<br/>
     undefined4 __stdcall main(void)<br/>
        undefined4  EAX:4           &lt;RETURN&gt;<br/>
        undefined4  Stack[-0x8]:4   ptr      <span class="ent">➊</span>XREF[3]:  00401014(W),<br/>
                                                         0040101b(R),<br/>
                                                         00401026(R)<br/>
     main                                    <span class="ent">➋</span>XREF[1]:  entry:0040121e(c)</pre>
<p class="indent">You can clearly identify the three XREFs associated with the stack variable <span class="ent">➊</span> as well as the XREF associated with the function itself <span class="ent">➋</span>. Let’s decode the meaning of the XREF, <code>entry:0040121e(c)</code><em>.</em> The address (or in this case, identifier) before the colon indicates the referring (or source) entity. In this case, control is transferred from <code>entry</code>. To the right of the colon is the specific address within <code>entry</code> that is the source of the cross-reference. The suffix <code>(c)</code> indicates that this is a <code>CALL</code> to <code>main</code>. Stated simply, the cross-reference says, “<code>main</code> is called from address <code>0040121e</code> within <code>entry</code>.”</p>
<p class="indent">If we double-click the cross-reference address to follow the link, we are taken to the specified address within <code>entry</code> where we can examine the call. While the XREF is a unidirectional link, we can quickly return to <code>main</code> by double-clicking the function name (<code>main</code>) or using the backward navigation arrow in the CodeBrowser toolbar:</p>
<pre>0040121e  CALL   main</pre>
<p class="indent">In the following listing, the <code>(j)</code> suffix on the XREF indicates that this labeled location is the target of a <code>JUMP</code>:</p>
<pre>004011fe  JZ     LAB_00401207<span class="ent">➊</span><br/>
00401200  PUSH   EAX<br/>
00401201  CALL   __amsg_exit<br/>
00401206  POP    ECX<br/>
        LAB_00401207                           XREF[1]: 004011fe(j)<span class="ent">➋</span><br/>
00401207  MOV    EAX,[DAT_0040acf0]</pre>
<p class="indent">Similar to the previous example, we can double-click the XREF address <span class="ent">➋</span> to navigate to the statement that transferred control. We can return by double-clicking the associated label <span class="ent">➊</span>.</p>
<span epub:type="pagebreak" id="page_188"/>
<h4 class="h4" id="ch09lev173"><strong><em>References Example</em></strong></h4>
<p class="noindent">Let’s walk through an example from source code to disassembly to demonstrate many types of cross-references. The following program, <em>simple_flows.c</em>, contains various operations that exercise Ghidra’s cross-referencing features, as noted in the comment text:</p>
<pre>int read_it;            // integer variable read in main<br/>
int write_it;           // integer variable written 3 times in main<br/>
int ref_it;             // integer variable whose address is taken in main<br/>
void callflow() {}      // function called twice from main<br/><br/>
int main() {<br/>
    int *ptr = &amp;ref_it; // results in a "pointer" style data reference (*)<br/>
    *ptr = read_it;     // results in a "read" style data reference (R)<br/>
    write_it = *ptr;    // results in a "write" style data reference (W)<br/>
    callflow();         // results in a "call" style code reference (c)<br/>
    if (read_it == 3) { // results in "jump" style code reference (j)<br/>
        write_it = 2;   // results in a "write" style data reference (W)<br/>
    }<br/>
    else {              // results in an "jump" style code reference (j)<br/>
        write_it = 1;   // results in a "write" style data reference (W)<br/>
    }<br/>
    callflow();         // results in an "call" style code reference (c)<br/>
}</pre>
<h5 class="h5" id="ch09lev174"><strong>Code Cross-References</strong></h5>
<p class="noindent"><a href="ch09.xhtml#exa9_1">Listing 9-1</a> shows the disassembly of the preceding program.</p>
<pre>     undefined4 __stdcall main(void)<br/>
        undefined4 EAX:4 &lt;RETURN&gt;<br/>
        undefined4 Stack[-0x8]:4 ptr          XREF[3]:  00401014(W),<br/>
                                                        0040101b(R),<br/>
                                                        00401026(R)<br/>
     main                                     XREF[1]:  entry:0040121e(c)<br/>
00401010  PUSH   EBP<br/>
00401011  MOV    EBP,ESP<br/>
00401013  PUSH   ECX<br/>
00401014  MOV<span class="ent">➊</span>  dword ptr [EBP + ptr],ref_it<br/>
0040101b  MOV    EAX,dword ptr [EBP + ptr]<br/>
0040101e  MOV<span class="ent">➋</span>  ECX,dword ptr [read_it]<br/>
00401024  MOV    dword ptr [EAX]=&gt;ref_it,ECX<br/>
00401026  MOV    EDX,dword ptr [EBP + ptr]<br/>
00401029  MOV    EAX=&gt;ref_it,dword ptr [EDX]<br/>
0040102b  MOV    [write_it],EAX<br/>
00401030  CALL<span class="ent">➌</span> callflow<br/>
00401035  CMP    dword ptr [read_it],3<br/>
0040103c  JNZ    LAB_0040104a<br/>
0040103e  MOV    dword ptr [write_it],2<br/>
00401048  JMP<span class="ent">➍</span>  LAB_00401054<br/><br/>
        LAB_0040104a                          XREF[1]:<span class="ent">➎</span>0040103c(j)<br/>
0040104a  MOV   dword ptr [write_it],1<br/>
<span epub:type="pagebreak" id="page_189"/>
        LAB_00401054                          XREF[1]:  00401048(j)<br/>
00401054  CALL   callflow<br/>
00401059  XOR    EAX,EAX<br/>
0040105b  MOV    ESP,EBP<br/>
0040105d  POP    EBP<br/>
0040105e  RET<span class="ent">➏</span></pre>
<p class="ex-caption" id="exa9_1"><em>Listing 9-1: Disassembly of main in</em> simple_flows.exe</p>
<p class="indent">Every instruction other than <code>JMP</code> <span class="ent">➍</span> and <code>RET</code> <span class="ent">➏</span> has an associated sequential flow to its immediate successor. Instructions used to invoke functions, such as the x86 <code>CALL</code> instruction <span class="ent">➌</span>, are assigned a <em>call flow</em>, indicating transfer of control to the target function. Call flows are noted by XREFs at the target function (the destination address of the flow). The disassembly of the <code>callflow</code> function referenced in <a href="ch09.xhtml#exa9_1">Listing 9-1</a> is shown in <a href="ch09.xhtml#exa9_2">Listing 9-2</a>.</p>
<pre>     undefined __stdcall callflow(void)<br/>
        undefined AL:1 &lt;RETURN&gt;<br/>
     callflow                                 XREF[4]:  0040010c(*),<br/>
                                                        004001e4(*),<br/>
                                                        main:00401030(c),<br/>
                                                        main:00401054(c)<br/>
00401000  PUSH   EBP<br/>
00401001  MOV    EBP,ESP<br/>
00401003  POP    EBP<br/>
00401004  RET</pre>
<p class="ex-caption" id="exa9_2"><em>Listing 9-2: Disassembly of the</em> <span class="codeitalic">callflow</span> <em>function</em></p>
<div class="box5">
<p class="boxtitle-c"><strong>EXTRA XREFS?</strong></p>
<p class="noindent">Every now and again, you see something in a listing that seems anomalous. <a href="ch09.xhtml#exa9_2">Listing 9-2</a> has two pointer XREFs, <code>0040010c(*)</code> and <code>004001e4(*)</code>, that are not easily explained. We immediately understood the two XREFs that we could trace back to the calls to <code>callflow</code> in <code>main</code>. What are the other two XREFs? It turns out that these are an interesting artifact of this particular code. This program was compiled for Windows, which results in a PE file, and the two anomalous XREFs take us to the PE header in the Headers section of the listing. The two reference addresses (including the associated bytes) are shown here:</p>
<pre>0040010c  00 10 00 00 ibo32     callflow               BaseOfCode<br/>
               .  .  .<br/>
004001e4  00 10 00 00 ibo32     callflow               VirtualAddress</pre>
<p class="indent">Why is this function referenced in the PE header? A quick Google search can help us understand what is happening: <code>callflow</code> just happens to be the very first thing in the text section, and the two PE fields indirectly reference the start of the text section, hence the unanticipated XREFs associated with the <code>callflow</code> function.</p>
</div>
<span epub:type="pagebreak" id="page_190"/>
<p class="indent">In this example, we see that <code>callflow</code> is called twice from <code>main</code>: once from address <code>00401030</code> and again from address <code>00401054</code>. Cross-references resulting from function calls are distinguished by the suffix <code>(c)</code>. The source location displayed in the cross-references indicates both the address from which the call is being made and the function that contains the call.</p>
<p class="indent">A <em>jump flow</em> is assigned to each unconditional and conditional branch instruction. Conditional branches are also assigned sequential flows to account for control flow when the branch is not taken; unconditional branches have no associated sequential flow because the branch is always taken. Jump flows are associated with jump-style cross-references displayed at the target of the <code>JNZ</code> <span class="ent">➎</span> in <a href="ch09.xhtml#exa9_1">Listing 9-1</a>. As with call-style cross-references, jump cross-references display the address of the referring location (the source of the jump). Jump cross-references are distinguished by the <code>(j)</code> suffix.</p>
<div class="box5">
<p class="boxtitle-c"><strong>BASIC BLOCKS</strong></p>
<p class="noindent">In program analysis, a <em>basic block</em> is a maximal sequence of instructions that executes, without branching, from beginning to end. Each basic block therefore has a single entry point (the first instruction in the block) and a single exit point (the last instruction in the block). The first instruction in a basic block is often the target of a branching instruction, while the last instruction is often a branch instruction. The first instruction may be the target of multiple code cross-references. Other than the first instruction, no other instruction within a basic block can be the target of a code cross-reference. The last instruction of a basic block may be the source of multiple code cross-references, such as a conditional jump, or it may flow into an instruction that is the target of multiple code cross-references (which, by definition, must begin a new basic block).</p>
</div>
<h5 class="h5" id="ch09lev175"><strong>Data Cross-References</strong></h5>
<p class="noindent"><em>Data cross-references</em> are used to track how data is accessed within a binary. The three most commonly encountered types of data cross-references indicate when a location is being read, when a location is being written, and when the address of a location is being taken. The global variables from the previous sample program are shown in <a href="ch09.xhtml#exa9_3">Listing 9-3</a>, as they provide several examples of data cross-references.</p>
<pre>        read_it                               XREF[2]:  main:0040101e(R),<br/>
                                                        main:00401035(R)<br/>
0040b720 undefined4    ??<br/>
        write_it                              XREF[3]:  main:0040102b(W),<br/>
                                                        main:0040103e(W),<br/>
                                                        main:0040104a(W)<br/>
<span epub:type="pagebreak" id="page_191"/>
0040b724    ??         ??<br/>
0040b725    ??         ??<br/>
0040b726    ??         ??<br/>
0040b727    ??         ??<br/>
        ref_it                                XREF[3]:  main:00401014(*),<br/>
                                                        main:00401024(W),<br/>
                                                        main:00401029(R)<br/>
0040b728 undefined4    ??</pre>
<p class="ex-caption" id="exa9_3"><em>Listing 9-3: Global variables referenced in</em> simple_flows.c</p>
<p class="indent">A <em>read cross-reference</em> indicates that the contents of a memory location are being read. Read cross-references can originate only from an instruction address but may refer to any program location. The global variable <code>read_it</code> is read twice in <a href="ch09.xhtml#exa9_1">Listing 9-1</a>. The associated cross-reference comments shown in this listing indicate exactly which locations in <code>main</code> are referencing <code>read_it</code> and are recognizable as read cross-references from the <code>(R)</code> suffix. The read performed on <code>read_it</code> <span class="ent">➋</span> in <a href="ch09.xhtml#exa9_1">Listing 9-1</a> is a 32-bit read into the <code>ECX</code> register, which leads Ghidra to format <code>read_it</code> as an <code>undefined4</code> (a 4-byte value of unspecified type). Ghidra often attempts to infer the size of a data item based on how the item is manipulated by code throughout a binary.</p>
<p class="indent">The global variable <code>write_it</code> is referenced three times in <a href="ch09.xhtml#exa9_1">Listing 9-1</a>. Associated <em>write cross-references</em> are generated and displayed as comments for the <code>write_it</code> variable, indicating the program locations that modify the contents of the variable. Write cross-references utilize the <code>(W)</code> suffix. In this case, Ghidra did not format <code>write_it</code> as a 4-byte variable even though there seems to be enough information to do so. As with read cross-references, write cross-references can originate only from a program instruction but may reference any program location. Generally, a write cross-reference that targets a program instruction byte is indicative of self-modifying code and is frequently encountered in malware de-obfuscation routines.</p>
<p class="indent">The third type of data cross-reference, a <em>pointer cross-reference</em>, indicates that the address of a location is being used (rather than the content of the location). The address of global variable <code>ref_it</code> is taken <span class="ent">➊</span> in <a href="ch09.xhtml#exa9_1">Listing 9-1</a>, resulting in the pointer cross-reference at <code>ref_it</code> in <a href="ch09.xhtml#exa9_3">Listing 9-3</a>, as indicated by the suffix <code>(*)</code>. Pointer cross-references are commonly the result of address derivations either in code or in data. As you saw in <a href="ch08.xhtml#ch08">Chapter 8</a>, array access operations are typically implemented by adding an offset to the starting address of the array, and the first address in most global arrays can often be recognized by the presence of a pointer cross-reference. For this reason, most string literals (strings being arrays of characters in C/C++) are the targets of pointer cross-references.</p>
<p class="indent">Unlike read and write cross-references, which can originate only from instruction locations, pointer cross-references can originate from either instruction locations or data locations. An example of pointers that can originate from a program’s data section is any table of addresses (such as a vftable, which results in the generation of a pointer cross-reference from each entry in the table to the corresponding virtual function). Let’s <span epub:type="pagebreak" id="page_192"/>see this in context using the <code>SubClass</code> example from <a href="ch08.xhtml#ch08">Chapter 8</a>. The disassembly for the vftable for <code>SubClass</code> is shown here:</p>
<pre>           SubClass::vftable           XREF[1]:  SubClass_Constructor:00401062(*)<br/>
   00408148 void * SubClass::vfunc1 vfunc1<br/>
<span class="ent">➊</span> 0040814c void * BaseClass::vfunc2 vfunc2<br/>
   00408150 void * SubClass::vfunc3 vfunc3<br/>
   00408154 void * BaseClass::vfunc4 vfunc4<br/>
   00408158 void * SubClass::vfunc5 vfunc5</pre>
<p class="indent">Here you see that the data item at location <code>0040814c</code> <span class="ent">➊</span> is a pointer to <code>BaseClass::vfunc2</code>. Navigating to <code>BaseClass::vfunc2</code> presents us with the following listing:</p>
<pre>     **************************************************************<br/>
     *                          FUNCTION                          *<br/>
     **************************************************************<br/>
     undefined __stdcall vfunc2(void)<br/>
        undefined AL:1 &lt;RETURN&gt;<br/>
        undefined4 Stack[-0x8]:4 local_8      XREF[1]:  00401024(W)<br/>
     BaseClass::vfunc2                        XREF[2]:  00408138(*)<span class="ent">➊</span>,<br/>
                                                        0040814c(*)<span class="ent">➋</span><br/>
00401020  PUSH   EBP<br/>
00401021  MOV    EBP,ESP<br/>
00401023  PUSH   ECX<br/>
00401024  MOV    dword ptr [EBP + local_8],ECX<br/>
00401027  MOV    ESP,EBP<br/>
00401029  POP    EBP<br/>
0040102a  RET</pre>
<p class="indent">Unlike most functions, this function has no code cross-references. Instead, we see two pointer cross-references indicating that the address of the function is derived in two locations. The second XREF <span class="ent">➋</span> refers back to the <code>SubClass</code> vftable entry discussed earlier. Following the first XREF <span class="ent">➊</span> would lead us to the vftable for <code>BaseClass</code>, which also contains a pointer to this virtual function.</p>
<p class="indent">This example demonstrates that C++ virtual functions are rarely called directly and are usually not the target of a call cross-reference. Because of the way vftables are created, all C++ virtual functions will be referred to by at least one vftable entry and will always be the target of at least one pointer cross-reference. (Remember that overriding a virtual function is not mandatory.)</p>
<p class="indent">When a binary contains sufficient information, Ghidra is able to locate vftables for you. Any vftables that Ghidra finds are listed as an entry under the vftable’s corresponding class entry within the <em>Classes</em> folder of the Symbol Tree. Clicking a vftable in the Symbol Tree window navigates you to the vftable location in the program’s data section.</p>
<span epub:type="pagebreak" id="page_193"/>
<h3 class="h3" id="ch09lev176"><strong>Reference Management Windows</strong></h3>
<p class="noindent">By now, you’ve probably noticed that XREF annotations are quite common in the Listing window. This is no accident, as the links formed by cross-references are the glue that hold a program together. Cross-references tell the story of intra- and inter-functional dependencies, and most successful reverse engineering efforts demand a comprehensive understanding of their behavior. The sections that follow move beyond the basic display and navigational usefulness of cross-references to introduce several options for managing cross-references within Ghidra.</p>
<h4 class="h4" id="ch09lev177"><strong><em>XRefs Window</em></strong></h4>
<p class="noindent">You can use XREF headers to learn more about a particular cross-reference, as shown in the following listing:</p>
<pre>        undefined4 Stack[-0x10]:4 local_10    XREF[1]:  0804847c(W)  <br/>
        undefined4 Stack[-0x14]:4 local_14    XREF[2]:<span class="ent">➊</span>08048482(W), <br/>
                                                        08048493(R)  </pre>
<p class="indent">Double-clicking the <code>XREF[2]</code> header <span class="ent">➊</span> will bring up the associated XRefs window shown in <a href="ch09.xhtml#fig9_3">Figure 9-3</a> with a more detailed listing of the cross-references. By default, the window shows the location, label (if applicable), referring disassembly, and reference type.</p>
<div class="image"><img src="Images/fig9-3.jpg" alt="image" width="694" height="452"/></div>
<p class="figcap" id="fig9_3"><em>Figure 9-3: XRefs window</em></p>
<span epub:type="pagebreak" id="page_194"/>
<h4 class="h4" id="ch09lev178"><strong><em>References To</em></strong></h4>
<p class="noindent">Another window that can be helpful in understanding the program flow is the References To window. Right-clicking any address in the Listing window and choosing <strong>References</strong> ▸ <strong>Show Reference to Address</strong> brings up the window shown in <a href="ch09.xhtml#fig9_4">Figure 9-4</a>.</p>
<div class="image"><img src="Images/fig9-4.jpg" alt="image" width="694" height="410"/></div>
<p class="figcap" id="fig9_4"><em>Figure 9-4: References To window</em></p>
<p class="noindent">In this example, we have selected the starting address of the <code>helper</code> function. Within this window, you can navigate to the associated location by clicking any entry in the window.</p>
<h4 class="h4" id="ch09lev179"><strong><em>Symbol References</em></strong></h4>
<p class="noindent">Another reference view that was introduced in “<a href="ch05.xhtml#ch05lev85">The Symbol Table and Symbol References Windows</a>” on <a href="ch05.xhtml#page_82">page 82</a> is the combination of the Symbol Table and Symbol Reference windows. By default, when you choose Window ▸ Symbol References, you get two related windows. One displays every symbol in the entire symbol table. The other displays the associated references to the symbols. Selecting any entry in the Symbol Table window (function, vftable, and so on) causes the associated symbol references to be displayed in the Symbol References window.</p>
<p class="indent">Reference lists can be used to rapidly identify every location from which a particular function is called. For example, many people consider the C <code>strcpy</code> function to be dangerous as it copies a source array of characters, up to and including the associated null termination character, to a destination array, with no checks whatsoever that the destination array is large enough to hold all of the characters from the source. You could locate any one call to <code>strcpy</code> in your listing and use the aforementioned method to open the References To window, but if you don’t want to take the time <span epub:type="pagebreak" id="page_195"/>to find <code>strcpy</code> used somewhere in the binary, you can open the Symbol References window and quickly locate <code>strcpy</code> and all associated references.</p>
<h4 class="h4" id="ch09lev180"><strong><em>Advanced Reference Manipulation</em></strong></h4>
<p class="noindent">At the start of this chapter, we equated the term <em>back reference</em> with <em>cross-reference</em> and briefly mentioned that Ghidra also has <em>forward references</em>, of which there are two types. <em>Inferred forward references</em> are generally added to the listing automatically and correspond one-for-one to back references, although inferred forward references are travelled in the opposite direction. In other words, we traverse back references from a target address back to a source address, and we traverse inferred forward references from a source address forward to a target address.</p>
<p class="indent">The second type is an <em>explicit forward reference</em>. There are several types of explicit forward references, and their management is much more complex than other cross-references. The types of explicit forward references include memory references, external references, stack references, and register references. In addition to viewing references, Ghidra allows you to add and edit a variety of reference types.</p>
<p class="indent">You may need to add your own cross-references when Ghidra’s static analysis cannot determine jump or call targets that are computed at runtime, but you know the target from other analysis. In the following code, which we last saw in <a href="ch08.xhtml#ch08">Chapter 8</a>, a virtual function is called.</p>
<pre>0001072e  PUSH   EBP<br/>
0001072f  MOV    EBP,ESP<br/>
00010731  SUB    ESP,8<br/>
00010734  MOV    EAX,dword ptr [EBP + param_1]<span class="ent">➊</span><br/>
00010737  MOV    EAX,dword ptr [EAX]<br/>
00010739  ADD    EAX,8<br/>
0001073c  MOV    EAX,dword ptr [EAX]<br/>
0001073e  SUB    ESP,12<br/>
00010741  PUSH   dword ptr [EBP + param_1]<br/>
00010744  CALL<span class="ent">➋</span> EAX<br/>
00010746  ADD    ESP,16<br/>
00010749  NOP<br/>
0001074a  LEAVE<br/>
0001074b  RET</pre>
<p class="indent">The value held in <code>EAX</code> <span class="ent">➋</span> depends on the value of the pointer passed in <code>param_1</code> <span class="ent">➊</span>. As a result, Ghidra does not have enough information to create a cross-reference linking <code>00010744</code> (the address of the <code>CALL</code> instruction) to the target of the call. Manually adding a cross-reference (to <code>SubClass::vfunc3</code> for example) would, among other things, link the target functions into a call graph, thereby improving Ghidra’s analysis of the program. Right-clicking the call <span class="ent">➋</span> and selecting <strong>References</strong> ▸ <strong>Add Reference from</strong> opens the dialog shown in <a href="ch09.xhtml#fig9_5">Figure 9-5</a>. This dialog is also available through the References ▸ Add/Edit option.</p>
<span epub:type="pagebreak" id="page_196"/>
<div class="image"><img src="Images/fig9-5.jpg" alt="image" width="694" height="426"/></div>
<p class="figcap" id="fig9_5"><em>Figure 9-5: The Add Reference dialog</em></p>
<p class="indent">Specify the address of the target function as the To Address setting and make sure that the correct setting for Ref-Type is selected. When you close the dialog with the Add button, Ghidra creates the reference, and a new <code>(c)</code> cross-reference appears at the target address. More information on forward references, including the remaining reference types as well as reference manipulation, can be found in Ghidra Help.</p>
<h3 class="h3" id="ch09lev181"><strong>Summary</strong></h3>
<p class="noindent">References are powerful tools to help you understand how artifacts within a binary are related. We discussed cross-references in detail and introduced some other capabilities associated with references that will be visited again in later chapters. In the next chapter, we look at visual representations of references and how the resulting graphs can help us better understand the control flows within functions and the relationships between functions in our binaries.</p>
</div>



  </body></html>