- en: Chapter 42. Advanced Features of Shared Libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous chapter covered the fundamentals of shared libraries. This chapter
    describes a number of advanced features of shared libraries, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: dynamically loading shared libraries;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: controlling the visibility of symbols defined by a shared library;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: using linker scripts to create versioned symbols;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: using initialization and finalization functions to automatically execute code
    when a library is loaded and unloaded;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: shared library preloading; and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: using `LD_DEBUG` to monitor the operation of the dynamic linker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically Loaded Libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an executable starts, the dynamic linker loads all of the shared libraries
    in the program’s dynamic dependency list. Sometimes, however, it can be useful
    to load libraries at a later time. For example, a plug-in is loaded only when
    it is needed. This functionality is provided by an API to the dynamic linker.
    This API, usually referred to as the *dlopen* API, originated on Solaris, and
    much of it is now specified in SUSv3.
  prefs: []
  type: TYPE_NORMAL
- en: The *dlopen* API enables a program to open a shared library at run time, search
    for a function by name in that library, and then call the function. A shared library
    loaded at run time in this way is commonly referred to as a *dynamically loaded
    library*, and is created in the same way as any other shared library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core *dlopen* API consists of the following functions (all of which are
    specified in SUSv3):'
  prefs: []
  type: TYPE_NORMAL
- en: The *dlopen()* function opens a shared library, returning a handle used by subsequent
    calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *dlsym()* function searches a library for a symbol (a string containing
    the name of a function or variable) and returns its address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *dlclose()* function closes a library previously opened by *dlopen()*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *dlerror()* function returns an error-message string, and is used after
    a failure return from one of the preceding functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *glibc* implementation also includes a number of related functions, some
    of which we describe below.
  prefs: []
  type: TYPE_NORMAL
- en: To build programs that use the *dlopen* API on Linux, we must specify the *-ldl*
    option, in order to link against the *libdl* library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening a Shared Library: *dlopen()*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *dlopen()* function loads the shared library named in *libfilename* into
    the calling process’s virtual address space and increments the count of open references
    to the library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns library handle on success, or `NULL` on error
  prefs: []
  type: TYPE_NORMAL
- en: If *libfilename* contains a slash (`/`), *dlopen()* interprets it as an absolute
    or relative pathname. Otherwise, the dynamic linker searches for the shared library
    using the rules described in [Finding Shared Libraries at Run Time](ch41.html#finding_shared_libraries_at_run_time
    "Finding Shared Libraries at Run Time").
  prefs: []
  type: TYPE_NORMAL
- en: On success, *dlopen()* returns a handle that can be used to refer to the library
    in subsequent calls to functions in the *dlopen* API. If an error occurred (e.g.,
    the library couldn’t be found), *dlopen()* returns `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: If the shared library specified by *libfilename* contains dependencies on other
    shared libraries, *dlopen()* also automatically loads those libraries. This procedure
    occurs recursively if necessary. We refer to the set of such loaded libraries
    as this library’s *dependency tree*.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to call *dlopen()* multiple times on the same library file. The
    library is loaded into memory only once (by the initial call), and all calls return
    the same *handle* value. However, the *dlopen* API maintains a reference count
    for each library handle. This count is incremented by each call to *dlopen()*
    and decremented by each call to *dlclose()*; only when the count reaches 0 does
    *dlclose()* unload the library from memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *flags* argument is a bit mask that must include exactly one of the constants
    `RTLD_LAZY` or `RTLD_NOW`, with the following meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RTLD_LAZY`'
  prefs: []
  type: TYPE_NORMAL
- en: Undefined function symbols in the library should be resolved only as the code
    is executed. If a piece of code requiring a particular symbol is not executed,
    that symbol is never resolved. Lazy resolution is performed only for function
    references; references to variables are always resolved immediately. Specifying
    the `RTLD_LAZY` flag provides behavior that corresponds to the normal operation
    of the dynamic linker when loading the shared libraries identified in an executable’s
    dynamic dependency list.
  prefs: []
  type: TYPE_NORMAL
- en: '`RTLD_NOW`'
  prefs: []
  type: TYPE_NORMAL
- en: All undefined symbols in the library should be immediately resolved before *dlopen()*
    completes, regardless of whether they will ever be required. As a consequence,
    opening the library is slower, but any potential undefined function symbol errors
    are detected immediately instead of at some later time. This can be useful when
    debugging an application, or simply to ensure that an application fails immediately
    on an unresolved symbol, rather than doing so only after executing for a long
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By setting the environment variable `LD_BIND_NOW` to a nonempty string, we can
    force the dynamic linker to immediately resolve all symbols (i.e., like `RTLD_NOW`)
    when loading the shared libraries identified in an executable’s dynamic dependency
    list. This environment variable is effective in *glibc* 2.1.1 and later. Setting
    `LD_BIND_NOW` overrides the effect of the *dlopen()* `RTLD_LAZY` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to include further values in *flags*. The following flags
    are specified in SUSv3:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RTLD_GLOBAL`'
  prefs: []
  type: TYPE_NORMAL
- en: Symbols in this library and its dependency tree are made available for resolving
    references in other libraries loaded by this process and also for lookups via
    *dlsym()*.
  prefs: []
  type: TYPE_NORMAL
- en: '`RTLD_LOCAL`'
  prefs: []
  type: TYPE_NORMAL
- en: This is the converse of `RTLD_GLOBAL` and the default if neither constant is
    specified. It specifies that symbols in this library and its dependency tree are
    not available to resolve references in subsequently loaded libraries.
  prefs: []
  type: TYPE_NORMAL
- en: SUSv3 doesn’t specify a default if neither `RTLD_GLOBAL` nor `RTLD_LOCAL` is
    specified. Most UNIX implementations assume the same default (`RTLD_LOCAL`) as
    Linux, but a few assume a default of `RTLD_GLOBAL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux also supports a number of flags that are not specified in SUSv3:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RTLD_NODELETE` (since *glibc* 2.2)'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t unload the library during a *dlclose()*, even if the reference count falls
    to 0\. This means that the library’s static variables are not reinitialized if
    the library is later reloaded by *dlopen()*. (We can achieve a similar effect
    for libraries loaded automatically by the dynamic linker by specifying the *gcc
    -Wl,-znodelete* option when creating the library.)
  prefs: []
  type: TYPE_NORMAL
- en: '`RTLD_NOLOAD` (since *glibc* 2.2)'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t load the library. This serves two purposes. First, we can use this flag
    to check if a particular library is currently loaded as part of the process’s
    address space. If it is, *dlopen()* returns the library’s handle; if it is not,
    *dlopen()* returns `NULL`. Second, we can use this flag to “promote” the *flags*
    of an already loaded library. For example, we can specify `RTLD_NOLOAD | RTLD_GLOBAL`
    in *flags* when using *dlopen()* on a library previously opened with `RTLD_LOCAL`.
  prefs: []
  type: TYPE_NORMAL
- en: '`RTLD_DEEPBIND` (since *glibc* 2.3.4)'
  prefs: []
  type: TYPE_NORMAL
- en: When resolving symbol references made by this library, search for definitions
    in the library before searching for definitions in libraries that have already
    been loaded. This allows a library to be self-contained, using its own symbol
    definitions in preference to global symbols with the same name defined in other
    shared libraries that have already been loaded. (This is similar to the effect
    of the *-Bsymbolic* linker option described in [Run-Time Symbol Resolution](ch41.html#run-time_symbol_resolution
    "Run-Time Symbol Resolution").)
  prefs: []
  type: TYPE_NORMAL
- en: The `RTLD_NODELETE` and `RTLD_NOLOAD` flags are also implemented in the Solaris
    *dlopen* API, but are available on few other UNIX implementations. The `RTLD_DEEPBIND`
    flag is Linux-specific.
  prefs: []
  type: TYPE_NORMAL
- en: As a special case, we can specify *libfilename* as `NULL`. This causes *dlopen()*
    to return a handle for the main program. (SUSv3 refers to this as a handle for
    the “global symbol object.”) Specifying this handle in a subsequent call to *dlsym()*
    causes the requested symbol to be sought in the main program, followed by all
    shared libraries loaded at program startup, and then all libraries dynamically
    loaded with the `RTLD_GLOBAL` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Diagnosing Errors: *dlerror()*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we receive an error return from *dlopen()* or one of the other functions
    in the *dlopen* API, we can use *dlerror()* to obtain a pointer to a string that
    indicates the cause of the error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns pointer to error-diagnostic string, or `NULL` if no error has occurred
    since previous call to *dlerror()*
  prefs: []
  type: TYPE_NORMAL
- en: The *dlerror()* function returns `NULL` if no error has occurred since the last
    call to *dlerror()*. We’ll see how this is useful in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obtaining the Address of a Symbol: *dlsym()*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *dlsym()* function searches for the named *symbol* (a function or variable)
    in the library referred to by *handle* and in the libraries in that library’s
    dependency tree.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns address of *symbol*, or `NULL` if *symbol* is not found
  prefs: []
  type: TYPE_NORMAL
- en: If *symbol* is found, *dlsym()* returns its address; otherwise, *dlsym()* returns
    `NULL`. The *handle* argument is normally a library handle returned by a previous
    call to *dlopen()*. Alternatively, it may be one of the so-called pseudohandles
    described below.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A related function, *dlvsym(handle, symbol, version)*, is similar to *dlsym()*,
    but can be used to search a symbol-versioned library for a symbol definition whose
    version matches the string specified in *version*. (We describe symbol versioning
    in [Symbol Versioning](ch42.html#symbol_versioning "Symbol Versioning").) The
    `_GNU_SOURCE` feature test macro must be defined in order to obtain the declaration
    of this function from `<dlfcn.h>`.
  prefs: []
  type: TYPE_NORMAL
- en: The value of a symbol returned by *dlsym()* may be `NULL`, which is indistinguishable
    from the “symbol not found” return. In order to differentiate the two possibilities,
    we must call *dlerror()* beforehand (to make sure that any previously held error
    string is cleared) and then if, after the call to *dlsym()*, *dlerror()* returns
    a non-`NULL` value, we know that an error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'If *symbol* is the name of a variable, then we can assign the return value
    of *dlsym()* to an appropriate pointer type, and obtain the value of the variable
    by dereferencing the pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If *symbol* is the name of a function, then the pointer returned by *dlsym()*
    can be used to call the function. We can store the value returned by *dlsym()*
    in a pointer of the appropriate type, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can’t simply assign the result of *dlsym()* to such a pointer,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason is that the C99 standard forbids assignment between a function pointer
    and *void **. The solution is to use the following (somewhat clumsy) cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Having used *dlsym()* to obtain a pointer to the function, we can then call
    the function using the usual C syntax for dereferencing function pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the **(void **)* syntax shown above, one might consider using the
    following seemingly equivalent code when assigning the return value of *dlsym()*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: However, for this code, *gcc -pedantic* warns that “ANSI C forbids the use of
    cast expressions as lvalues.” The **(void **)* syntax doesn’t incur this warning
    because we are assigning to an address *pointed to* by the assignment’s lvalue.
  prefs: []
  type: TYPE_NORMAL
- en: 'On many UNIX implementations, we can use casts such as the following to eliminate
    warnings from the C compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: However, the specification of *dlsym()* in SUSv3 *Technical Corrigendum Number
    1* notes that the C99 standard nevertheless requires compilers to generate a warning
    for such a conversion, and proposes the **(void **)* syntax shown above.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SUSv3 TC1 noted that because of the need for the **(void **)* syntax, a future
    version of the standard may define separate *dlsym()*-like APIs for handling data
    and function pointers. However, SUSv4 contains no changes with respect to this
    point.
  prefs: []
  type: TYPE_NORMAL
- en: Using library pseudohandles with *dlsym()*
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Instead of specifying a library handle returned by a call to *dlopen()*, either
    of the following *pseudohandles* may be specified as the *handle* argument for
    *dlsym()*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RTLD_DEFAULT`'
  prefs: []
  type: TYPE_NORMAL
- en: Search for *symbol* starting with the main program, and then proceeding in order
    through the list of all shared libraries loaded, including those libraries dynamically
    loaded by *dlopen()* with the `RTLD_GLOBAL` flag. This corresponds to the default
    search model employed by the dynamic linker.
  prefs: []
  type: TYPE_NORMAL
- en: '`RTLD_NEXT`'
  prefs: []
  type: TYPE_NORMAL
- en: Search for *symbol* in shared libraries loaded after the one invoking *dlsym()*.
    This is useful when creating a wrapper function with the same name as a function
    defined elsewhere. For example, in our main program, we may define our own version
    of *malloc()* (which perhaps does some bookkeeping of memory allocation), and
    this function can invoke the real *malloc()* by first obtaining its address via
    the call *func = dlsym(RTLD_NEXT, “malloc”)*.
  prefs: []
  type: TYPE_NORMAL
- en: The pseudohandle values listed above are not required by SUSv3 (which nevertheless
    reserves them for future use), and are not available on all UNIX implementations.
    In order to get the definitions of these constants from `<dlfcn.h>`, we must define
    the `_GNU_SOURCE` feature test macro.
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 42-1](ch42.html#using_the_dlopen_api "Example 42-1. Using the dlopen
    API") demonstrates the use of the *dlopen* API. This program takes two command-line
    arguments: the name of a shared library to load and the name of a function to
    execute within that library. The following examples demonstrate the use of this
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the first of the above commands, *dlopen()* notes that the library path includes
    a slash and thus interprets it as a relative pathname (in this case, to a library
    in the current working directory). In the second command, we specify a library
    search path in `LD_LIBRARY_PATH`. This search path is interpreted according to
    the usual rules of the dynamic linker (in this case, likewise to find the library
    in the current working directory).
  prefs: []
  type: TYPE_NORMAL
- en: Example 42-1. Using the *dlopen* API
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Closing a Shared Library: *dlclose()*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *dlclose()* function closes a library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *dlclose()* function decrements the system’s counter of open references
    to the library referred to by *handle*. If this reference count falls to 0, and
    no symbols in the library are required by other libraries, then the library is
    unloaded. This procedure is also (recursively) performed for the libraries in
    this library’s dependency tree. An implicit *dlclose()* of all libraries is performed
    on process termination.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From *glibc* 2.2.3 onward, a function within a shared library can use *atexit()*
    (or *on_exit()*) to establish a function that is called automatically when the
    library is unloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obtaining Information About Loaded Symbols: *dladdr()*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given an address in *addr* (typically, one obtained by an earlier call to *dlsym()*),
    *dladdr()* returns a structure containing information about that address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns nonzero value if *addr* was found in a shared library, otherwise 0
  prefs: []
  type: TYPE_NORMAL
- en: 'The *info* argument is a pointer to a caller-allocated structure that has the
    following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first two fields of the *Dl_info* structure specify the pathname and run-time
    base address of the shared library containing the address specified in *addr*.
    The last two fields return information about that address. Assuming that *addr*
    points to the exact address of a symbol in the shared library, then *dli_saddr*
    returns the same value as was passed in *addr*.
  prefs: []
  type: TYPE_NORMAL
- en: SUSv3 doesn’t specify *dladdr()*, and this function is not available on all
    UNIX implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Symbols in the Main Program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose that we use *dlopen()* to dynamically load a shared library, use *dlsym()*
    to obtain the address of a function *x()* from that library, and then call *x()*.
    If *x()* in turn calls a function *y()*, then *y()* would normally be sought in
    one of the shared libraries loaded by the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, it is desirable instead to have *x()* invoke an implementation of
    *y()* in the main program. (This is similar to a callback mechanism.) In order
    to do this, we must make the (global-scope) symbols in the main program available
    to the dynamic linker, by linking the program using the *--export-dynamic* linker
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Equivalently, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using either of these options allows a dynamically loaded library to access
    global symbols in the main program.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *gcc -rdynamic* option and the *gcc -Wl,-E* option are further synonyms
    for *-Wl,--export-dynamic*.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling Symbol Visibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A well-designed shared library should make visible only those symbols (functions
    and variables) that form part of its specified application binary interface (ABI).
    The reasons for this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the shared library designer accidentally exports unspecified interfaces,
    then authors of applications that use the library may choose to employ these interfaces.
    This creates a compatibility problem for future upgrades of the shared library.
    The library developer expects to be able to change or remove any interfaces other
    than those in the documented ABI, while the library user expects to continue using
    the same interfaces (with the same semantics) that they currently employ.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During run-time symbol resolution, any symbols that are exported by a shared
    library might interpose definitions that are provided in other shared libraries
    ([Run-Time Symbol Resolution](ch41.html#run-time_symbol_resolution "Run-Time Symbol
    Resolution")).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting unnecessary symbols increases the size of the dynamic symbol table
    that must be loaded at run time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these problems can be minimized or avoided altogether if the library
    designer ensures that only the symbols required by the library’s specified ABI
    are exported. The following techniques can be used to control the export of symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: In a C program, we can use the `static` keyword to make a symbol private to
    a source-code module, thus rendering it unavailable for binding by other object
    files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As well as making a symbol private to a source-code module, the `static` keyword
    also has a converse effect. If a symbol is marked as `static`, then all references
    to the symbol in the same source file will be bound to that definition of the
    symbol. Consequently, these references won’t be subject to run-time interposition
    by definitions from other shared libraries (in the manner described in [Run-Time
    Symbol Resolution](ch41.html#run-time_symbol_resolution "Run-Time Symbol Resolution")).
    This effect of the `static` keyword is similar to the *-Bsymbolic* linker option
    described in [Run-Time Symbol Resolution](ch41.html#run-time_symbol_resolution
    "Run-Time Symbol Resolution"), with the difference that the `static` keyword affects
    a single symbol within a single source file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GNU C complier, *gcc*, provides a compiler-specific attribute declaration
    that performs a similar task to the `static` keyword:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Whereas the `static` keyword limits the visibility of a symbol to a single source
    code file, the `hidden` attribute makes the symbol available across all source
    code files that compose the shared library, but prevents it from being visible
    outside the library.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: As with the `static` keyword, the `hidden` attribute also has the converse effect
    of preventing symbol interposition at run time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Version scripts ([Linker Version Scripts](ch42.html#linker_version_scripts "Linker
    Version Scripts")) can be used to precisely control symbol visibility and to select
    the version of a symbol to which a reference is bound.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When dynamically loading a shared library ([Opening a Shared Library: *dlopen()*](ch42.html#opening_a_shared_library_colon_dlopen_op
    "Opening a Shared Library: dlopen()")), the *dlopen()* `RTLD_GLOBAL` flag can
    be used to specify that the symbols defined by the library should be made available
    for binding by subsequently loaded libraries, and the *—export-dynamic* linker
    option ([Accessing Symbols in the Main Program](ch42.html#accessing_symbols_in_the_main_program
    "Accessing Symbols in the Main Program")) can be used to make the global symbols
    of the main program available to dynamically loaded libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For further details on the topic of symbol visibility, see [Drepper, 2004 (b)].
  prefs: []
  type: TYPE_NORMAL
- en: Linker Version Scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *version script* is a text file containing instructions for the linker, *ld*.
    In order to use a version script, we must specify the *—version-script* linker
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]*`myscriptfile.map`*`` `...`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: $ `gcc -g -c -fPIC -Wall vis_comm.c vis_f1.c vis_f2.c`
  prefs: []
  type: TYPE_NORMAL
- en: $ `gcc -g -shared -o vis.so vis_comm.o vis_f1.o vis_f2.o`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: $ `readelf --syms --use-dynamic vis.so | grep vis_`
  prefs: []
  type: TYPE_NORMAL
- en: '30  12: 00000790    59    FUNC GLOBAL DEFAULT  10 vis_f1'
  prefs: []
  type: TYPE_NORMAL
- en: '25  13: 000007d0    73    FUNC GLOBAL DEFAULT  10 vis_f2'
  prefs: []
  type: TYPE_NORMAL
- en: '27  16: 00000770    20    FUNC GLOBAL DEFAULT  10 vis_comm'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: $ `cat vis.map`
  prefs: []
  type: TYPE_NORMAL
- en: VER_1 {
  prefs: []
  type: TYPE_NORMAL
- en: 'global:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: vis_f1;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: vis_f2;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'local:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*;'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: $ `gcc -g -c -fPIC -Wall vis_comm.c vis_f1.c vis_f2.c`
  prefs: []
  type: TYPE_NORMAL
- en: $ `gcc -g -shared -o vis.so vis_comm.o vis_f1.o vis_f2.o \`
  prefs: []
  type: TYPE_NORMAL
- en: '`-Wl,--version-script,vis.map`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: $ `readelf --syms --use-dynamic vis.so | grep vis_`
  prefs: []
  type: TYPE_NORMAL
- en: '25   0: 00000730    73    FUNC GLOBAL DEFAULT  11 vis_f2'
  prefs: []
  type: TYPE_NORMAL
- en: '29  16: 000006f0    59    FUNC GLOBAL DEFAULT  11 vis_f1'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: $ `cat sv_lib_v1.c`
  prefs: []
  type: TYPE_NORMAL
- en: '#include <stdio.h>'
  prefs: []
  type: TYPE_NORMAL
- en: void xyz(void) { printf("v1 xyz\n"); }
  prefs: []
  type: TYPE_NORMAL
- en: $ `cat sv_v1.map`
  prefs: []
  type: TYPE_NORMAL
- en: VER_1 {
  prefs: []
  type: TYPE_NORMAL
- en: 'global: xyz;'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'local:  *;      # Hide all other symbols'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: $ `gcc -g -c -fPIC -Wall sv_lib_v1.c`
  prefs: []
  type: TYPE_NORMAL
- en: $ `gcc -g -shared -o libsv.so sv_lib_v1.o -Wl,--version-script,sv_v1.map`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: $ `cat sv_prog.c`
  prefs: []
  type: TYPE_NORMAL
- en: '#include <stdlib.h>'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: main(int argc, char *argv[])
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: void xyz(void);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: xyz();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: exit(EXIT_SUCCESS);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: $ `gcc -g -o p1 sv_prog.c libsv.so`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: $ `LD_LIBRARY_PATH=. ./p1`
  prefs: []
  type: TYPE_NORMAL
- en: v1 xyz
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: $ `cat sv_lib_v2.c`
  prefs: []
  type: TYPE_NORMAL
- en: '#include <stdio.h>'
  prefs: []
  type: TYPE_NORMAL
- en: __asm__(".symver xyz_old,xyz@VER_1");
  prefs: []
  type: TYPE_NORMAL
- en: __asm__(".symver xyz_new,xyz@@VER_2");
  prefs: []
  type: TYPE_NORMAL
- en: void xyz_old(void) { printf("v1 xyz\n"); }
  prefs: []
  type: TYPE_NORMAL
- en: void xyz_new(void) { printf("v2 xyz\n"); }
  prefs: []
  type: TYPE_NORMAL
- en: void pqr(void) { printf("v2 pqr\n"); }
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: $ `cat sv_v2.map`
  prefs: []
  type: TYPE_NORMAL
- en: VER_1 {
  prefs: []
  type: TYPE_NORMAL
- en: 'global: xyz;'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'local:  *;      # Hide all other symbols'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: VER_2 {
  prefs: []
  type: TYPE_NORMAL
- en: 'global: pqr;'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '} VER_1;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '} VER_1;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: $ `gcc -g -c -fPIC -Wall sv_lib_v2.c`
  prefs: []
  type: TYPE_NORMAL
- en: $ `gcc -g -shared -o libsv.so sv_lib_v2.o -Wl,--version-script,sv_v2.map`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: $ `gcc -g -o p2 sv_prog.c libsv.so`
  prefs: []
  type: TYPE_NORMAL
- en: $ `LD_LIBRARY_PATH=. ./p2`
  prefs: []
  type: TYPE_NORMAL
- en: v2 xyz                                        *Uses* *xyz@VER_2*
  prefs: []
  type: TYPE_NORMAL
- en: $ `LD_LIBRARY_PATH=. ./p1`
  prefs: []
  type: TYPE_NORMAL
- en: v1 xyz                                        *Uses* *xyz@VER_1*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: $ `objdump -t p1 | grep xyz`
  prefs: []
  type: TYPE_NORMAL
- en: 08048380       F *UND*  0000002e              xyz@@VER_1
  prefs: []
  type: TYPE_NORMAL
- en: $ `objdump -t p2 | grep xyz`
  prefs: []
  type: TYPE_NORMAL
- en: 080483a0       F *UND*  0000002e              xyz@@VER_2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: void __attribute__ ((constructor)) some_name_load(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: /* Initialization code */
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: void __attribute__ ((destructor)) some_name_unload(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: /* Finalization code */
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: $ `./prog`
  prefs: []
  type: TYPE_NORMAL
- en: Called mod1-x1 DEMO
  prefs: []
  type: TYPE_NORMAL
- en: Called mod2-x2 DEMO
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: $ `LD_PRELOAD=libalt.so ./prog`
  prefs: []
  type: TYPE_NORMAL
- en: Called mod1-x1 ALT
  prefs: []
  type: TYPE_NORMAL
- en: Called mod2-x2 DEMO
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: $ `LD_DEBUG=help date`
  prefs: []
  type: TYPE_NORMAL
- en: 'Valid options for the LD_DEBUG environment variable are:'
  prefs: []
  type: TYPE_NORMAL
- en: libs       display library search paths
  prefs: []
  type: TYPE_NORMAL
- en: reloc      display relocation processing
  prefs: []
  type: TYPE_NORMAL
- en: files      display progress for input file
  prefs: []
  type: TYPE_NORMAL
- en: symbols    display symbol table processing
  prefs: []
  type: TYPE_NORMAL
- en: bindings   display information about symbol binding
  prefs: []
  type: TYPE_NORMAL
- en: versions   display version dependencies
  prefs: []
  type: TYPE_NORMAL
- en: all        all previous options combined
  prefs: []
  type: TYPE_NORMAL
- en: statistics display relocation statistics
  prefs: []
  type: TYPE_NORMAL
- en: unused     determine unused DSOs
  prefs: []
  type: TYPE_NORMAL
- en: help       display this help message and exit
  prefs: []
  type: TYPE_NORMAL
- en: To direct the debugging output into a file instead of standard output
  prefs: []
  type: TYPE_NORMAL
- en: a filename can be specified using the LD_DEBUG_OUTPUT environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: $ `LD_DEBUG=libs date`
  prefs: []
  type: TYPE_NORMAL
- en: '10687:     find library=librt.so.1 [0]; searching'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10687:      search cache=/etc/ld.so.cache'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10687:       trying file=/lib/librt.so.1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10687:     find library=libc.so.6 [0]; searching'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10687:      search cache=/etc/ld.so.cache'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10687:       trying file=/lib/libc.so.6'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10687:     find library=libpthread.so.0 [0]; searching'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10687:      search cache=/etc/ld.so.cache'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10687:       trying file=/lib/libpthread.so.0'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10687:     calling init: /lib/libpthread.so.0'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10687:     calling init: /lib/libc.so.6'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10687:     calling init: /lib/librt.so.1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10687:     initialize program: date'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10687:     transferring control: date'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tue Dec 28 17:26:56 CEST 2010
  prefs: []
  type: TYPE_NORMAL
- en: '10687:     calling fini: date [0]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10687:     calling fini: /lib/librt.so.1 [0]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10687:     calling fini: /lib/libpthread.so.0 [0]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '10687:     calling fini: /lib/libc.so.6 [0]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The value 10687 displayed at the start of each line is the process ID of the
    process being traced. This is useful if we are monitoring several processes (e.g.,
    parent and child).
  prefs: []
  type: TYPE_NORMAL
- en: By default, `LD_DEBUG` output is written to standard error, but we can direct
    it elsewhere by assigning a pathname to the `LD_DEBUG_OUTPUT` environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: If desired, we can assign multiple options to `LD_DEBUG` by separating them
    with commas (no spaces should appear). The output of the *symbols* option (which
    traces symbol resolution by the dynamic linker) is particularly voluminous.
  prefs: []
  type: TYPE_NORMAL
- en: '`LD_DEBUG` is effective both for libraries implicitly loaded by the dynamic
    linker and for libraries dynamically loaded by *dlopen()*.'
  prefs: []
  type: TYPE_NORMAL
- en: For security reasons, `LD_DEBUG` is (since *glibc* 2.2.5) ignored in set-user-ID
    and set-group-ID programs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dynamic linker provides the *dlopen* API, which allows programs to explicitly
    load additional shared libraries at run time. This allows programs to implement
    plug-in functionality.
  prefs: []
  type: TYPE_NORMAL
- en: An important aspect of shared library design is controlling symbol visibility,
    so that the library exports only those symbols (functions and variables) that
    should actually be used by programs linked against the library. We looked at a
    range of techniques that can be used to control symbol visibility. Among these
    techniques was the use of version scripts, which provide fine-grained control
    of symbol visibility.
  prefs: []
  type: TYPE_NORMAL
- en: We also showed how version scripts can be used to implement a scheme that allows
    a single shared library to export multiple definitions of a symbol for use by
    different applications linked against the library. (Each application uses the
    definition that was current when the application was statically linked against
    the library.) This technique provides an alternative to the traditional library
    versioning approach of using major and minor version numbers in the shared library
    real name.
  prefs: []
  type: TYPE_NORMAL
- en: Defining initialization and finalization functions within a shared library allows
    us to automatically execute code when the library is loaded and unloaded.
  prefs: []
  type: TYPE_NORMAL
- en: The `LD_PRELOAD` environment variable allows us to preload shared libraries.
    Using this mechanism, we can selectively override functions and other symbols
    that the dynamic linker would normally find in other shared libraries.
  prefs: []
  type: TYPE_NORMAL
- en: We can assign various values to the `LD_DEBUG` environment variable in order
    to monitor the operation of the dynamic linker.
  prefs: []
  type: TYPE_NORMAL
- en: Further information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Refer to the sources of further information listed in [Summary](ch41.html#summary-id40
    "Summary").
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a program to verify that if a library is closed with *dlclose()*, it is
    not unloaded if any of its symbols are used by another library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a *dladdr()* call to the program in [Example 42-1](ch42.html#using_the_dlopen_api
    "Example 42-1. Using the dlopen API") (`dynload.c`) in order to retrieve information
    about the address returned by *dlsym()*. Print out the values of the fields of
    the returned *Dl_info* structure, and verify that they are as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
