<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_325"/><strong><span class="big">11</span><br/>FORENSIC TRACES OF ATTACHED PERIPHERAL DEVICES</strong></h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="190" height="189"/></div>&#13;
<p class="noindent">In this chapter, peripheral devices refer to externally connected hardware such as storage, cameras, webcams, printers, scanners, mobile devices, and so on. We will try to identify and analyze these attached devices from traces in the logs and configuration files. From a forensics perspective, we are attempting to learn as much about the devices as possible; in particular, any unique identifying information and evidence of use. Knowing what devices were attached to a system and how they were used helps to reconstruct past events and activity.</p>&#13;
<p class="indent">You may notice the absence of Bluetooth devices in this chapter. They are also considered peripherals, but they’re covered together with the other wireless analysis topics in <a href="ch08.xhtml">Chapter 8</a>.</p>&#13;
<h3 class="h3" id="ch00lev1_51"><strong>Linux Peripheral Devices</strong></h3>&#13;
<p class="noindent">The most common interfaces used to connect external peripheral devices are USB and Thunderbolt. USB devices make up the vast majority of externally attached devices, far outnumbering any other external interface. Thunderbolt’s physical interface now uses USB3C and provides the ability to connect PCI Express devices. In addition, Fibre Channel (FC) and serial attached SCSI (SAS) PCI boards provide external interfaces that are found primarily in enterprise environments.</p>&#13;
<h4 class="h4" id="ch00lev2_151"><span epub:type="pagebreak" id="page_326"/><strong><em>Linux Device Management</em></strong></h4>&#13;
<p class="noindent">As mentioned in <a href="ch02.xhtml">Chapter 2</a>, when Unix was first developed, a core philosophy (that Linux adopted) was “everything is a file.” This revolutionary idea enabled access to hardware devices through special files that interacted with the kernel.</p>&#13;
<p class="indent">Device files can be one of two types (block or character), and they have associated numbers (major and minor) that specify the class and instance of a device. Character devices are sequentially accessed (or streamed) one byte at a time, and they’re used for keyboards, video, printers, and other serial devices. Block devices are accessed in block-sized chunks, can be cached or randomly accessed, and are typically used for storage devices.</p>&#13;
<p class="indent">Device files are normally located in the <em>/dev/</em> directory and are created dynamically by the udev daemon (systemd-udevd). The <em>/dev/</em> directory is a pseudo-filesystem that a running kernel provides in memory. Thus, the device files in this directory will not exist during a postmortem forensic examination.<sup><a id="ch11foot01" href="footnotes.xhtml#ch11foot_01">1</a></sup> Device files are not required to be in <em>/dev/</em> and can be created anywhere using the <code>mknod</code> command or <code>mknod</code> system call. However, a device file anywhere outside <em>/dev/</em> is suspicious and worth closer examination.</p>&#13;
<p class="indent">The systemd-udevd daemon notices when devices are attached or removed from the system by the kernel, and sets up the appropriate device files using udev rules specified in rule files. Software packages may create udev rule files in the <em>/usr/lib/udev/rules.d/</em> directory, and system administrators create custom udev rule files in the <em>/etc/udev/rules.d/</em> directory. Here is an example of a udev rule file:</p>&#13;
<pre>$ <span class="codestrong1">cat /etc/udev/rules.d/nitrokey.rules</span>&#13;
ATTRS{idVendor}=="20a0", ATTRS{idProduct}=="4108", MODE="660", GROUP="sam", TAG+="systemd"</pre>&#13;
<p class="noindent">The system owner (<code>sam</code>) created a rule for a Nitrokey authentication stick with a USB device ID of 20a0:4108 to define how the permissions and group ownership are set.</p>&#13;
<p class="indent">An examination of <em>/etc/udev/rules.d/</em> will reveal any files tweaked or created by the system’s owner. See the udev(7) man page for more information about udev.</p>&#13;
<h4 class="h4" id="ch00lev2_152"><span epub:type="pagebreak" id="page_327"/><strong><em>Identify Attached USB Devices</em></strong></h4>&#13;
<p class="noindent">USB indexUSB deviceswas created to consolidate and replace aging external peripheral interfaces such as RS-232, the parallel printer interface, PS/2 keyboard and mouse, and other proprietary PC interfaces. It was designed to accommodate multipurpose functionality such as disks, keyboards, mice, sound, network connections, printing and scanning, and connecting small devices (mobile phones and the like). A growing number of IoT devices can be attached to a PC via USB and may contain data useful as forensic evidence.</p>&#13;
<p class="indent">During a forensic examination, creating a list of attached USB devices will help answer questions related to an investigation, providing information such as:</p>&#13;
<ul>&#13;
<li class="noindent">Indication of human proximity</li>&#13;
<li class="noindent">Activity at a certain point in time</li>&#13;
<li class="noindent">Additional devices to find and analyze</li>&#13;
<li class="noindent">Association of a particular device to the system under analysis</li>&#13;
</ul>&#13;
<p class="noindent">In the context of a forensic investigation, we are especially interested in unique identifiers and timestamps. The unique identifiers will link a particular device to a particular computer within the context of an incident or crime. USB unique identifiers may include hardware serial numbers or UUIDs stored in the device firmware or in the device’s memory. When trying to identify USB devices, we can examine logfiles, configuration files, and other persistent data.</p>&#13;
<p class="indent">USB devices appear in the kernel logs like this:</p>&#13;
<pre>Dec 30 09:13:20 pc1 kernel: usb 5-3.2: new full-speed USB device number 36 using xhci_hcd&#13;
Dec 30 09:13:20 pc1 kernel: usb 5-3.2: New USB device found, idVendor=05ac, idProduct=1393,&#13;
bcdDevice= 1.05&#13;
Dec 30 09:13:20 pc1 kernel: usb 5-3.2: New USB device strings: Mfr=1, Product=2, SerialNumber=3&#13;
Dec 30 09:13:20 pc1 kernel: usb 5-3.2: Product: AirPod Case&#13;
Dec 30 09:13:20 pc1 kernel: usb 5-3.2: Manufacturer: Apple Inc.&#13;
Dec 30 09:13:20 pc1 kernel: usb 5-3.2: SerialNumber: GX3CFW4PLKKT&#13;
...&#13;
Dec 30 09:13:20 pc1 kernel: usbcore: registered new device driver apple-mfi-fastcharge&#13;
...&#13;
Dec 30 09:16:00 pc1 kernel: usb 5-3.2: USB disconnect, device number 36</pre>&#13;
<p class="noindent">This example shows that an Apple AirPod charging case was connected on December 30 at 9:13 AM (<code>09:13:20</code>). The serial number provides a unique identification. The disconnect log entry shows the AirPod case was unplugged several minutes later. When analyzing storage device logs, the device number and USB port (<code>36</code> and <code>5-3.2</code> in this example) are the only information shown in the kernel logs upon removal of the device. These provide an association to the other log entries that contain more detailed device information (manufacturer, product, serial number, and so on).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_328"/>From a forensics perspective, the insertion and removal timestamps are interesting. They provide an indicator that a person was in physical proximity of the computer when the device was plugged in and unplugged, and suggest a possible duration of use. Other logs and information may need to corroborate with these timestamps before definite usage conclusions can be made. The port where the USB device was inserted indicates which physical connector was used to plug in the device. This could be useful information, for example, if the USB device was plugged in to a server in the middle of a row of racks; the front or back location could correlate with activity observed in data center CCTV footage.</p>&#13;
<p class="indent">Video conferencing has become more popular recently, and Linux supports video conferencing software like Zoom, Teams, Jitsi, and more. This software relies on USB webcams and microphones (internal on laptops; external on desktops). These devices can be found in the same manner as other devices described in this section, but Linux manages video devices through the Video4Linux (V4L) framework, which is part of the Linux media subsystem. When a video device is attached to a Linux system, the kernel detects it and a <em>/dev/video0</em> device is created (multiple cameras will appear as <em>/dev/video1</em>, <em>/dev/video2</em>, and so on). Typical video devices include webcams, digital video cameras, TV tuners, and video grabbers. Here’s an example:</p>&#13;
<pre>Dec 30 03:45:56 pc1 kernel: usb 6-3.4: new SuperSpeed Gen 1 USB device number 3 using xhci_hcd&#13;
Dec 30 03:45:56 pc1 kernel: usb 6-3.4: New USB device found, idVendor=046d, idProduct=0893,&#13;
bcdDevice= 3.17&#13;
Dec 30 03:45:56 pc1 kernel: usb 6-3.4: New USB device strings: Mfr=0, Product=2, SerialNumber=3&#13;
Dec 30 03:45:56 pc1 kernel: usb 6-3.4: Product: Logitech StreamCam&#13;
Dec 30 03:45:56 pc1 kernel: usb 6-3.4: SerialNumber: 32B24605&#13;
Dec 30 03:45:56 pc1 kernel: hid-generic 0003:046D:0893.0005: hiddev1,hidraw4: USB HID v1.11&#13;
 Device [Logitech StreamCam] on usb-0000:0f:00.3-3.4/input5&#13;
...&#13;
Dec 30 03:45:56 pc1 kernel: mc: Linux media interface: v0.10&#13;
Dec 30 03:45:56 pc1 kernel: videodev: Linux video capture interface: v2.00&#13;
Dec 30 03:45:56 pc1 kernel: usbcore: registered new interface driver snd-usb-audio&#13;
Dec 30 03:45:56 pc1 kernel: uvcvideo: Found UVC 1.00 device Logitech StreamCam (046d:0893)&#13;
Dec 30 03:45:56 pc1 kernel: input: Logitech StreamCam as&#13;
/devices/pci0000:00/0000:00:08.1/0000:0f:00.3/usb6/6-3/6-3.4/6-3.4:1.0/input/input25&#13;
Dec 30 03:45:56 pc1 kernel: usbcore: registered new interface driver uvcvideo&#13;
Dec 30 03:45:56 pc1 kernel: USB Video Class driver (1.1.1)&#13;
Dec 30 03:45:56 pc1 systemd[587]: Reached target Sound Card.</pre>&#13;
<p class="noindent">Here, the USB device is detected with make/model/serial information, and then the Linux video driver is started, which enables the use of video equipment for recording, video conferencing, or watching television.</p>&#13;
<p class="indent">A list of known USB hardware IDs can be found in the <em>/usr/share/hwdata/ usb.ids</em> file or from the <em><a href="http://www.linux-usb.org/usb-ids.html">http://www.linux-usb.org/usb-ids.html</a></em> website. This list is formatted by vendor, device, and interface name, and is maintained by community effort.</p>&#13;
<h4 class="h4" id="ch00lev2_153"><span epub:type="pagebreak" id="page_329"/><strong><em>Identify PCI and Thunderbolt Devices</em></strong></h4>&#13;
<p class="noindent">PCI Express or PCIe (Peripheral Component Interconnect Express) is a specification (<em><a href="https://pcisig.com/">https://pcisig.com/</a></em>) for a bus interface to attach PCIe devices. PCIe devices are typically cards plugged in to PCIe slots on the mainboard or devices integrated into the mainboard itself.</p>&#13;
<p class="indent">Finding PCIe devices in the logs depends on the device’s kernel module, with some modules logging more than others. The following example shows a kernel module logging information about a PCIe device:</p>&#13;
<pre>Dec 29 10:37:32 pc1 kernel: pci 0000:02:00.0: [10de:1c82] type 00 class&#13;
 0x030000&#13;
...&#13;
Dec 29 10:37:32 pc1 kernel: pci 0000:02:00.0: 16.000 Gb/s available&#13;
PCIe bandwidth, limited by 2.5 GT/s PCIe x8 link at 0000:00:01.0&#13;
(capable of 126.016 Gb/s with 8.0 GT/s PCIe x16 link)&#13;
...&#13;
Dec 29 10:37:33 pc1 kernel: nouveau 0000:02:00.0: NVIDIA GP107 (137000a1)&#13;
...&#13;
Dec 29 10:37:33 pc1 kernel: nouveau 0000:02:00.0: bios: version 86.07.59.00.24&#13;
Dec 29 10:37:34 pc1 kernel: nouveau 0000:02:00.0: pmu: firmware unavailable&#13;
Dec 29 10:37:34 pc1 kernel: nouveau 0000:02:00.0: fb: 4096 MiB GDDR5&#13;
...&#13;
Dec 29 10:37:34 pc1 kernel: nouveau 0000:02:00.0: DRM: allocated 3840x2160 fb:&#13;
0x200000, bo 00000000c125ca9a&#13;
Dec 29 10:37:34 pc1 kernel: fbcon: nouveaudrmfb (fb0) is primary device</pre>&#13;
<p class="noindent">Here an Nvidia GP107 PCIe graphics card is detected in the physical slot (bus) 2 of the mainboard. We can analyze the kernel logs describing the physical PCIe slots and associate them with PCIe devices that were detected.</p>&#13;
<p class="indent">The string <code>0000:02:00.0</code> in the above example is represented in <code>&lt;domain&gt;:</code> <code>&lt;bus&gt;:&lt;device&gt;.&lt;function&gt;</code> format. This format describes where the PCIEe device is located in the system, and the function number for multifunction devices. The string <code>[10de:1c82]</code> refers to the device vendor (NVIDIA) and the product (GP107).</p>&#13;
<p class="indent">For a list of known PCI hardware IDs, see the <em>/usr/share/hwdata/pci.ids</em> file or the <em><a href="http://pci-ids.ucw.cz/">http://pci-ids.ucw.cz/</a></em> website. These lists are formatted by vendor, device, subvendor, and subdevice names, and are maintained by community effort. The pci.ids(5) man page describes the file in more detail.</p>&#13;
<p class="indent">Thunderbolt was developed jointly by Apple and Intel as a high-speed external interface to connect disks, video displays, and PCIe devices using a single interface. Using the code name Light Peak, it was originally intended to be a fiber-optic connection. Apple is largely responsible for Thunderbolt’s popularity (primarily among Apple users), promoting it with Apple hardware.</p>&#13;
<p class="indent">The physical interface uses Mini DisplayPort for Thunderbolt 1 and Thunderbolt 2, and transitions to the USB Type-C cable and connector for</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_330"/>Thunderbolt 3. The Thunderbolt 3 interface combines PCIe, DisplayPort, and USB3 into a single interface. Thunderbolt 1, 2, and 3 offer speeds of 10, 20, and 40Gbps, respectively.</p>&#13;
<p class="indent">The following example shows a Thunderbolt device connected to a Linux laptop:</p>&#13;
<pre>Dec 30 10:45:27 pc1 kernel: thunderbolt 0-3: new device found, vendor=0x1 device=0x8003&#13;
Dec 30 10:45:27 pc1 kernel: thunderbolt 0-3: Apple, Inc. Thunderbolt to Gigabit Ethernet&#13;
 Adapter&#13;
Dec 30 10:45:27 pc1 boltd[429]: [409f9f01-0200-Thunderbolt to Gigabit Ethe] parent is&#13;
 c6030000-0060...&#13;
Dec 30 10:45:27 pc1 boltd[429]: [409f9f01-0200-Thunderbolt to Gigabit Ethe] connected:&#13;
 authorized&#13;
 (/sys/devices/pci0000:00/0000:00:1d.4/0000:05:00.0/0000:06:00.0/0000:07:00.0/domain0/0-0/0-3)&#13;
Dec 30 10:45:29 pc1 kernel: tg3 0000:30:00.0 eth1: Link is up at 1000 Mbps, full duplex&#13;
Dec 30 10:45:29 pc1 kernel: tg3 0000:30:00.0 eth1: Flow control is on for TX and on for RX&#13;
Dec 30 10:45:29 pc1 kernel: tg3 0000:30:00.0 eth1: EEE is enabled&#13;
Dec 30 10:45:29 pc1 kernel: IPv6: ADDRCONF(NETDEV_CHANGE): eth1: link becomes ready&#13;
Dec 30 10:45:29 pc1 systemd-networkd[270]: eth1: Gained carrier&#13;
...&#13;
Dec 30 10:50:56 pc1 kernel: thunderbolt 0-3: device disconnected&#13;
Dec 30 10:50:56 pc1 boltd[429]: [409f9f01-0200-Thunderbolt to Gigabit Ethe] disconnected&#13;
 (/sys/devices/pci0000:00/0000:00:1d.4/0000:05:00.0/0000:06:00.0/0000:07:00.0/domain0/0-0/0-3)&#13;
Dec 30 10:50:56 pc1 systemd-networkd[270]: eth1: Lost carrier</pre>&#13;
<p class="noindent">The logs show that a Thunderbolt gigabit Ethernet adapter was inserted on at 10:45 on December 30 and was unplugged several minutes later (10:50). On this machine, the systemd-networkd daemon is managing the network and notices the Ethernet link status (carrier).</p>&#13;
<p class="indent">Thunderbolt 3 introduced several security features to mitigate unauthorized access to memory via direct memory access (DMA).<sup><a id="ch11foot02" href="footnotes.xhtml#ch11foot_02">2</a></sup> The <code>boltd</code> daemon (seen in the preceding example) manages the authorization of Thunderbolt 3 devices that have a security level enabled.</p>&#13;
<h3 class="h3" id="ch00lev1_52"><strong>Printers and Scanners</strong></h3>&#13;
<p class="noindent">Printing and printers have been part of Unix computing since the beginning. One of the first applications of Unix was to perform text formatting<sup><a id="ch11foot03" href="footnotes.xhtml#ch11foot_03">3</a></sup> for printing documents (patent applications) at Bell Labs.</p>&#13;
<p class="indent">Printers and scanners serve as the bridge between the digital and physical worlds of documentation. Printers and scanners perform opposite functions: one converts electronic files into paper documents, and the other converts paper documents into electronic files. Both are standard components</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_331"/>in offices today and are well supported by Linux systems. Analysis of printing and scanning is a standard part of a forensic examination when identifying artifacts left behind on a Linux system.</p>&#13;
<h4 class="h4" id="ch00lev2_154"><strong><em>Analysis of Printers and Printing History</em></strong></h4>&#13;
<p class="noindent">Traditional Unix printing commonly used the BSD line printer daemon (<code>lpd</code>) to accept and queue print jobs for installed printers. Modern Linux systems adopted the common Unix printing system (CUPS), which has had significant involvement and support from Apple since it was originally used in its Unix-based OS X operating system. Forensic analysis of the printing system may reveal information about past printing activity.</p>&#13;
<p class="indent">The CUPS software package can be configured to use printers that are directly connected (typically via USB) or over a network. When printing over a network, a variety of protocols are available (IPP, lpr, HP JetDirect, and more), with the internet printing protocol (IPP) being preferred. The <code>cupsd</code> daemon listens for print requests and manages the printing system through a local web server on TCP port 631.</p>&#13;
<p class="indent">The <em>/etc/cups/</em> directory contains the CUPS configuration, and individual printers are added to the <em>printers.conf</em> file (using the CUPS interface or a GUI provided by the distro). Here’s an example <em>/etc/cups/printers.conf</em> file:</p>&#13;
<pre># Printer configuration file for CUPS v2.3.3op1&#13;
# Written by cupsd&#13;
# DO NOT EDIT THIS FILE WHEN CUPSD IS RUNNING&#13;
NextPrinterId 7&#13;
&lt;Printer bro&gt;&#13;
PrinterId 6&#13;
UUID urn:uuid:55fea3b9-7948-3f4c-75af-e18d47c02475&#13;
AuthInfoRequired none&#13;
Info Tree Killer&#13;
Location My Office&#13;
MakeModel Brother HLL2370DN for CUPS&#13;
DeviceURI ipp://bro.example.com/ipp/port1&#13;
State Idle&#13;
StateTime 1609329922&#13;
ConfigTime 1609329830&#13;
Type 8425492&#13;
Accepting Yes&#13;
Shared No&#13;
JobSheets none none&#13;
QuotaPeriod 0&#13;
PageLimit 0&#13;
KLimit 0&#13;
OpPolicy default&#13;
ErrorPolicy stop-printer&#13;
<span epub:type="pagebreak" id="page_332"/>Attribute marker-colors \#000000,none&#13;
Attribute marker-levels -1,98&#13;
Attribute marker-low-levels 16&#13;
Attribute marker-high-levels 100&#13;
Attribute marker-names Black Toner Cartridge,Drum Unit&#13;
Attribute marker-types toner&#13;
Attribute marker-change-time 1609329922&#13;
&lt;/Printer&gt;</pre>&#13;
<p class="noindent">The printer name <code>bro</code> is specified with <code>&lt;printer bro&gt;</code> and <code>&lt;/printer&gt;</code> tags (this HTML-like tagging allows multiple printers to be configured in the same file). Information about the make and model is recorded, and several time-stamps are updated when the printer configuration or attributes change.</p>&#13;
<p class="indent">In addition to print jobs, the cupsd daemon manages configuration requests and other local management tasks. This activity is logged in the <em>/var/log/cups/</em> directory, which may contain the <em>access_log</em>, <em>error_log</em>, and <em>page_log</em> files that log information about CUPS activity, including configured printer activity. The logs are documented in the cupsd-logs(5) man page.</p>&#13;
<p class="indent">The <em>access_log</em> file records administrative activity as well as print requests to different configured printers:</p>&#13;
<pre>localhost - root [30/Dec/2020:13:46:57 +0100] "POST /admin/ HTTP/1.1"&#13;
 200 163 Pause-Printer successful-ok&#13;
localhost - root [30/Dec/2020:13:47:02 +0100] "POST /admin/ HTTP/1.1"&#13;
 200 163 Resume-Printer successful-ok&#13;
...&#13;
localhost - - [30/Dec/2020:13:48:19 +0100] "POST /printers/bro HTTP/1.1"&#13;
 200 52928 Send-Document successful-ok</pre>&#13;
<p class="noindent">Here, the printer is paused and resumed, and then a document is printed.</p>&#13;
<p class="indent">The <em>error_log</em> file records various error and warning messages, and it may contain interesting information about failed printer installations, problems with printing, and other unusual events that could be relevant to an investigation, such as in the following example:</p>&#13;
<pre>E [30/Apr/2020:10:46:37 +0200] [Job 46] The printer is not responding.</pre>&#13;
<p class="noindent">The <em>error_log</em> lines begin with a letter (<code>E</code> for error, <code>W</code> for warning, and so on). These error letters are listed in the cupsd-logs(5) man page.</p>&#13;
<p class="indent">The <em>page_log</em> file is especially interesting for investigators because it records a history of past printing jobs and filenames; for example:</p>&#13;
<pre>bro sam 271 [15/Oct/2020:08:46:16 +0200] total 1 - localhost Sales receipt_35099373.pdf - -&#13;
bro sam 368 [30/Dec/2020:13:48:41 +0100] total 1 - localhost Hacking History - Part2.odt - -&#13;
...</pre>&#13;
<p class="noindent">Two print jobs are shown with the printer name (<code>bro</code>), the user who printed the job (<code>sam</code>), the time of printing, and the filenames.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_333"/>These logfiles may rotate over time and have a numeric extension added (<em>error_log.1</em>, <em>page_log.2</em>, and so on). In contrast to other user activity, not much information is stored in the user’s home directory. The print jobs are passed to the CUPS daemon, which manages the configuration and logging as a system-wide function. These logs are used for both local and network-configured printers. CUPS has more than a dozen man pages, so start with the cups(1) man page or <em><a href="https://www.cups.org/">https://www.cups.org/</a></em> for more information.</p>&#13;
<p class="indent">In addition to CUPS logs, attaching a USB printer to a local machine will generate logs in the systemd journal, as shown here:</p>&#13;
<pre>Dec 30 14:42:41 localhost.localdomain kernel: usb 4-1.3: new high-speed USB device number 15&#13;
using ehci-pci&#13;
Dec 30 14:42:41 pc1 kernel: usb 4-1.3: New USB device found, idVendor=04f9,&#13;
idProduct=00a0, bcdDevice= 1.00&#13;
Dec 30 14:42:41 pc1 kernel: usb 4-1.3: New USB device strings: Mfr=1, Product=2,&#13;
SerialNumber=3&#13;
Dec 30 14:42:41 pc1 kernel: usb 4-1.3: Product: HL-L2370DN series&#13;
Dec 30 14:42:41 pc1 kernel: usb 4-1.3: Manufacturer: Brother&#13;
Dec 30 14:42:41 pc1 kernel: usb 4-1.3: SerialNumber: E78098H9N222411&#13;
...&#13;
<span epub:type="pagebreak" id="page_334"/>Dec 30 14:42:41 localhost.localdomain kernel: usblp 4-1.3:1.0: usblp0: USB Bidirectional&#13;
printer dev 15 if 0 alt 0 proto 2 vid 0x04F9 pid 0x00A0&#13;
Dec 30 14:42:41 localhost.localdomain kernel: usbcore: registered new interface&#13;
driver usblp&#13;
...&#13;
Dec 30 14:45:19 localhost.localdomain kernel: usb 4-1.3: USB disconnect, device number 15&#13;
Dec 30 14:45:19 localhost.localdomain kernel: usblp0: removed</pre>&#13;
<p class="noindent">Here, a Brother printer is plugged in at 2:42 PM (<code>14:42:41</code>) and unplugged a few minutes later at 2:45 PM (<code>14:45:19</code>). The model and serial number are shown. The USB device (<code>usblp0</code>) is also logged, which is useful information when multiple printers are attached to a single system.</p>&#13;
<h4 class="h4" id="ch00lev2_155"><strong><em>Analysis of Scanning Devices and History</em></strong></h4>&#13;
<p class="noindent">Scanning under Linux uses the Scanner Access Now Easy (SANE) API. An older competing system is TWAIN (<em><a href="https://www.twain.org/">https://www.twain.org/</a></em>), but most distros are now using SANE. SANE’s popularity is partly because of the separation of the frontend GUIs and backend scanner configuration drivers (found in <em>/etc/sane.d/</em>), and the SANE daemon (<code>saned</code>) for scanning over a network.</p>&#13;
<p class="indent">Plugging a USB scanner in to a Linux machine will cause information to be logged:</p>&#13;
<pre>Dec 30 15:04:41 pc1 kernel: usb 1-3: new high-speed USB device number 19 using xhci_hcd&#13;
Dec 30 15:04:41 pc1 kernel: usb 1-3: New USB device found, idVendor=04a9, idProduct=1905,&#13;
bcdDevice= 6.03&#13;
Dec 30 15:04:41 pc1 kernel: usb 1-3: New USB device strings: Mfr=1, Product=2, SerialNumber=0&#13;
&#13;
Dec 30 15:04:41 pc1 kernel: usb 1-3: Product: CanoScan&#13;
Dec 30 15:04:41 pc1 kernel: usb 1-3: Manufacturer: Canon&#13;
...&#13;
Dec 30 15:21:32 pc1 kernel: usb 1-3: USB disconnect, device number 19</pre>&#13;
<p class="noindent">Here, a Canon CanoScan device is plugged in a little after 3:00 PM and is then unplugged 17 minutes later.</p>&#13;
<p class="indent">Any frontend application can use the API provided by the SANE backend libraries. This means that interesting logging and persistent data from a forensics perspective will be application specific. The following example shows the simple-scan app installed by default on Linux Mint. This information is found in the user’s home directory in the <em>~/.cache/simple-scan/ simple-scan.log</em> file:</p>&#13;
<pre>[+0.00s] DEBUG: simple-scan.vala:1720: Starting simple-scan 3.36.3, PID=172794&#13;
...&#13;
[+62.29s] DEBUG: scanner.vala:1285: sane_start (page=0, pass=0) -&gt; SANE_STATUS_GOOD&#13;
...&#13;
[+87.07s] DEBUG: scanner.vala:1399: sane_read (15313) -&gt; (SANE_STATUS_EOF, 0)&#13;
...&#13;
[+271.21s] DEBUG: app-window.vala:659: Saving to&#13;
 'file:///home/sam/Documents/Scanned%20Document.pdf'</pre>&#13;
<p class="noindent">This scan log is recreated each time the <code>simple-scan</code> program is used (overwriting previous logs). The log times reflect the number of seconds since the program started, and timestamps can be calculated by adding these values to the logfile’s creation timestamp. Here we see that the program was started and a document was scanned a minute later (which took about 25 seconds to complete). Three minutes later, the document was saved to the user’s <em>Documents</em> folder with the name <em>Scanned Document.pdf</em> (the <code>%20</code> in the log represents a space).</p>&#13;
<p class="indent">In a forensic examination involving a scanner, you need to determine which scanning software was used and then analyze the artifacts for that particular program (XDG directories, logs, cache, and so on).</p>&#13;
<h3 class="h3" id="ch00lev1_53"><strong>External Attached Storage</strong></h3>&#13;
<p class="noindent">In many forensic investigations, especially those involving the possession of illicit material or stolen documents, it is important to identify all storage devices that have been attached to the computer under examination. On Linux systems, we can find this information in several places.</p>&#13;
<p class="indent">External storage attaches to a computer system through a hardware interface such as USB or Thunderbolt. The computer communicates with these drives over the interface using a low-level protocol (SCSI, ATA, USB BoT, and others) to read and write sectors (which form the filesystem blocks). Storage devices such as USB thumb drives or external disks have the interface electronics and media integrated into a single device. However, in some <span epub:type="pagebreak" id="page_335"/>cases, the drive and storage media are separate and known as removable media devices. Examples of this include SD cards, optical discs (CD/DVD), and magnetic tapes.</p>&#13;
<h4 class="h4" id="ch00lev2_156"><strong><em>Storage Hardware Identification</em></strong></h4>&#13;
<p class="noindent">When a new storage device is attached to a Linux system, the appropriate device drivers are set up and the device files are created. After the setup is complete, filesystems can be mounted. Mounting filesystems can be automatic, manual, or performed during system startup. Setting up a newly attached device in the kernel is separate and independent from mounting any filesystems it contains. This is why we can take a forensic image of a device without mounting it (by accessing the device sectors directly).</p>&#13;
<p class="indent">Once the kernel recognizes a new storage device, device files are created in the <em>/dev/</em> directory (with the help of udevd), which can be found in the kernel’s dmesg log or other system logs. The following example is from the systemd journal:</p>&#13;
<pre>Dec 30 15:49:23 pc1 kernel: usb 1-7: new high-speed USB device number 23 using xhci_hcd&#13;
Dec 30 15:49:23 pc1 kernel: usb 1-7: New USB device found, idVendor=0781, idProduct=5567,&#13;
 bcdDevice= 1.00&#13;
Dec 30 15:49:23 pc1 kernel: usb 1-7: New USB device strings: Mfr=1, Product=2, SerialNumber=3&#13;
Dec 30 15:49:23 pc1 kernel: usb 1-7: Product: Cruzer Blade&#13;
Dec 30 15:49:23 pc1 kernel: usb 1-7: Manufacturer: SanDisk&#13;
Dec 30 15:49:23 pc1 kernel: usb 1-7: SerialNumber: 4C530001310731103142&#13;
Dec 30 15:49:23 pc1 kernel: usb-storage 1-7:1.0: USB Mass Storage device detected&#13;
Dec 30 15:49:23 pc1 kernel: scsi host5: usb-storage 1-7:1.0&#13;
...&#13;
Dec 30 15:49:24 pc1 kernel: scsi 5:0:0:0: Direct-Access   SanDisk Cruzer Blade   1.00&#13;
 PQ: 0 ANSI: 6&#13;
Dec 30 15:49:24 pc1 kernel: sd 5:0:0:0: Attached scsi generic sg2 type 0&#13;
Dec 30 15:49:24 pc1 kernel: sd 5:0:0:0: [sdc] 30031872 512-byte logical blocks:&#13;
 (15.4 GB/14.3 GiB)&#13;
...&#13;
Dec 30 15:49:24 pc1 kernel: sdc: sdc1&#13;
Dec 30 15:49:24 pc1 kernel: sd 5:0:0:0: [sdc] Attached SCSI removable disk&#13;
...</pre>&#13;
<p class="noindent">Here, the kernel detected a new USB device, determined it was storage, and created the <code>sdc</code> device. The number of 512-byte sectors is shown, indicating the drive’s size (<code>30031872 512-byte logical blocks</code>). Information about the manufacturer, product, and serial number is also logged. The device name used (<code>[sdc]</code> here) may be found in other logs during the time the drive was connected.</p>&#13;
<p class="indent">When a storage device is removed from a Linux system, as mentioned previously, the kernel doesn’t generate much information:</p>&#13;
<pre>Dec 30 16:02:54 pc1 kernel: usb 1-7: USB disconnect, device number 23</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_336"/>In this example, the USB stick is removed around 15 minutes after being plugged in. (Information related to the mounting and unmounting of the drive is described in the next section.)</p>&#13;
<p class="indent">It may be obvious from the product, manufacturer, and size whether the storage device is a USB stick or an external disk enclosure. But in some cases, you may want an additional indicator. If a normal SATA drive housed in a drive enclosure is an Advanced Format or 4K Native drive, it may show an additional log line with <code>4096-byte physical blocks</code>. USB sticks (and older hard drives) will show only the 512-byte logical block line. An example of this additional log is shown here:</p>&#13;
<pre>Dec 30 16:41:57 pc1 kernel: sd 7:0:0:0: [sde] 7814037168 512-byte logical blocks:&#13;
 (4.00 TB/3.64 TiB)&#13;
Dec 30 16:41:57 pc1 kernel: sd 7:0:0:0: [sde] 4096-byte physical blocks</pre>&#13;
<p class="noindent">Here, a disk in an external USB enclosure (a SATA docking station) logs the 4096-byte physical blocks (4K Native sectors). My previous book, <em>Practical Forensic Imaging</em> (No Starch Press, 2016), explains Advance Format and 4K Native drives in much more detail.</p>&#13;
<h4 class="h4" id="ch00lev2_157"><strong><em>Evidence of Mounted Storage</em></strong></h4>&#13;
<p class="noindent">After the kernel has set up the device driver and device files have been created, the filesystems can be mounted. Evidence of mounted external drives can be found in several places.</p>&#13;
<p class="indent">On servers, filesystems on permanently attached external storage are statically configured in the <em>/etc/fstab</em> file so they are automatically mounted every time the system starts up. An example <em>fstab</em> looks like this:</p>&#13;
<pre>$ <span class="codestrong1">cat /etc/fstab</span>&#13;
# Static information about the filesystems.&#13;
# See fstab(5) for details.&#13;
&#13;
# &lt;file system&gt; &lt;dir&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;&#13;
UUID=b4b80f70-1517-4637-ab5f-fa2a211bc5a3/    ext4   rw,relatime0 1&#13;
&#13;
# all my cool vids&#13;
UUID=e2f063d4-e442-47f5-b4d1-b5c936b6ec7f/data    ext4   rw,relatime0 1&#13;
...</pre>&#13;
<p class="noindent">Here, <code>/</code> is the root filesystem with the installed operating system, and <code>/data</code> is the external data drive added by the administrator. This file contains the unique UUID, mount directory, and possibly comments added by the administrator. Other device-identifying information may be found in the logs (as described in the previous section).</p>&#13;
<p class="indent">On desktop machines, Linux distros want to provide an easy and comfortable user experience and typically mount filesystems automatically and display them on the desktop or in a file manager. This is done with the <code>udisks</code> program that is called (via D-Bus) after the system has set up the devices.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_337"/>The udisks program creates a temporary mount point in <em>/media/</em> or <em>/run/ media/</em> where it then mounts the drive. It is then displayed on the user’s desktop or in the file manager. The following example shows a log from an automatically mounted drive:</p>&#13;
<pre>Dec 30 15:49:25 pc1 udisksd[773]: Mounted /dev/sdc1 at /run/media/sam/My Awesome Vids&#13;
on behalf of uid 1000&#13;
...&#13;
Dec 30 16:01:52 pc1 udisksd[773]: udisks_state_check_mounted_fs_entry: block device&#13;
/dev/sdc1 is busy, skipping cleanup&#13;
Dec 30 16:01:52 pc1 systemd[2574]: run-media-sam-My\x20Awesome\x20Vids.mount: Succeeded.&#13;
Dec 30 16:01:52 pc1 udisksd[773]: Cleaning up mount point /run/media/sam/My Awesome Vids&#13;
(device 8:33 is not mounted)&#13;
...</pre>&#13;
<p class="noindent">The mounted drive has the volume name <code>My Awesome Vids</code>. When the drive is unmounted via the Eject menu item on the desktop, it will remove the temporary directory after unmounting and log it:</p>&#13;
<pre>Dec 30 16:01:52 pc1 udisksd[773]: Unmounted /dev/sdc1 on behalf of uid 1000&#13;
Dec 30 16:01:53 pc1 kernel: sdc: detected capacity change from 15376318464 to 0</pre>&#13;
<p class="noindent">The drive can then be physically removed.</p>&#13;
<p class="indent">Manual mounting will also leave traces in system logfiles. When a system administrator mounts a filesystem on the command line to a mount point of their choosing, evidence of the manual mounting may be found in the logs and in the shell history. If a non-root user manually mounts a filesystem, they will need escalated privileges and typically will prefix their command with <code>sudo</code>. Here are two examples of <code>mount</code> commands, one in the shell history of the root user and one in that of a normal user:</p>&#13;
<pre># <span class="codestrong1">mount /dev/sda1 /mnt</span>&#13;
$ <span class="codestrong1">sudo mount /dev/sda1 /mnt</span></pre>&#13;
<p class="noindent">Other indicators to look for may include error messages related to storage, bad sectors, or storage removed without cleanly dismounting. Also, depending on the file manager used, there may be cached information, history, or bookmarks, indicating the use of peripheral storage.</p>&#13;
<h3 class="h3" id="ch00lev1_54"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter has covered the analysis of external peripheral devices attached to a Linux system. Attaching and removing peripherals leaves traces in the logs, which can be examined. In addition, this chapter describes how to analyze the printing subsystem and how scanning works. You now should be able to look for evidence of attached and removed peripherals and scanned and printed documents.<span epub:type="pagebreak" id="page_338"/></p>&#13;
</div></body></html>