["```\n❶ const newTree = () => null;\n\n❷ const newNode = (key, left = null, right = null) => ({\n  key,\n  left,\n  right\n});\n\n❸ const isEmpty = (tree) => tree === null;\n```", "```\nconst find = (tree, keyToFind) => {\n❶ if (isEmpty(tree)) {\n   return false;\n❷} else if (keyToFind === tree.key) {\n   return true;\n } else {\n ❸ return find(keyToFind < tree.key ? tree.left : tree.right, keyToFind);\n  }\n};\n```", "```\nconst add = (tree, keyToAdd) => {\n❶ if (isEmpty(tree)) {\n    return newNode(keyToAdd);\n  } else {\n  ❷ const side = keyToAdd <= tree.key ? \"left\" : \"right\";\n    tree[side] = add(tree[side], keyToAdd);\n    return tree;\n  }\n};\n```", "```\nconst remove = (tree, keyToRemove) => {\n❶ if (isEmpty(tree)) {\n   // nothing to do\n❷} else if (keyToRemove < tree.key) {\n   tree.left = remove(tree.left, keyToRemove);\n❸} else if (keyToRemove > tree.key) {\n   tree.right = remove(tree.right, keyToRemove);\n❹} else if (isEmpty(tree.left) && isEmpty(tree.right)) {\n   tree = null;\n❺} else if (isEmpty(tree.left)) {\n   tree = tree.right;\n❻} else if (isEmpty(tree.right)) {\n   tree = tree.left;\n❼} else {\n ❽ tree.key = minKey(tree.right);\n ❾ tree.right = remove(tree.right, tree.key);\n }\n\n  return tree;\n};\n```", "```\n❶ const _minMax = (tree, side, defaultValue) => {\n❷ if (isEmpty(tree)) {\n   return defaultValue;\n❸} else if (isEmpty(tree[side])) {\n   return tree.key;\n } else {\n ❹ return _minMax(tree[side], side, defaultValue);\n }\n};\n\nconst minKey = (tree) => _minMax(tree, \"left\", Infinity);\nconst maxKey = (tree) => _minMax(tree, \"right\", -Infinity);\n```", "```\nconst preOrder = (tree, visit = (x) => console.log(x)) => {\n  if (!isEmpty(tree)) {\n    visit(tree.key);\n    preOrder(tree.left, visit);\n    preOrder(tree.right, visit);\n  }\n};\n\nconst inOrder = (tree, visit = (x) => console.log(x)) => {\n  if (!isEmpty(tree)) {\n    inOrder(tree.left, visit);\n    visit(tree.key);\n    inOrder(tree.right, visit);\n  }\n};\n\nconst postOrder = (tree, visit = (x) => console.log(x)) => {\n  if (!isEmpty(tree)) {\n    postOrder(tree.left, visit);\n    postOrder(tree.right, visit);\n    visit(tree.key);\n  }\n};\n```", "```\n{\"key\":22, \"left\":{\"key\":9,  \"left\":{\"key\":4, \"left\":null, \"right\":null}, \"rig\nht\":{\"key\":11, \"left\":{\"key\":10, \"left\":null,\"right\":null}, \"right\":{\"key\":12,\n \"left\":null, \"right\":null}}}, \"right\":{\"key\":60, \"left\":{\"key\":24, \"left\":{\"k\ney\":23, \"left\":null, \"right\":null}, \"right\":{\"key\":56, \"left\":null, \"right\":nu\nll}}, \"right\":null}}\n```", "```\n 22\n  L: 9\n  L:  L: 4\n  L:  R: 11\n  L:  R:  L: 10\n  L:  R:  R: 12\n  R: 60\n  R:  L: 24\n  R:  L:  L: 23\n  R:  L:  R: 56\n```", "```\nconst print = (tree, s = \"\") => {\n  if (!isEmpty(tree)) {\n    console.log(s, tree.key);\n    print(tree.left, `${s}  L:`);\n    print(tree.right, `${s}  R:`);\n  }\n};\n```", "```\nconst newAvlTree = () => null;\n\nconst newNode = (key) => ({\n  key,\n  left: null,\n  right: null,\n❶ height: 1\n});\n\n❷ const _getHeight = (tree) => (isEmpty(tree) ? 0 : tree.height);\n\n❸ const _calcHeight = (tree) =>\n  isEmpty(tree)\n    ? 0\n    : 1 + Math.max(_getHeight(tree.left), _getHeight(tree.right));\n\n❹ const _calcBalance = (tree) =>\n  isEmpty(tree) ? 0 : _getHeight(tree.right) - _getHeight(tree.left);\n```", "```\nconst add = (tree, keyToAdd) => {\n  if (isEmpty(tree)) {\n    tree = newNode(keyToAdd);\n  } else {\n    const side = keyToAdd <= tree.key ? \"left\" : \"right\";\n    tree[side] = add(tree[side], keyToAdd);\n  }\n\n **return _fixBalance(tree);**\n};\n```", "```\nconst remove = (tree, keyToRemove) => {\n  if (isEmpty(tree)) {\n    // nothing to do\n  } else if (keyToRemove < tree.key) {\n    tree.left = remove(tree.left, keyToRemove);\n } else if (keyToRemove > tree.key) {\n    tree.right = remove(tree.right, keyToRemove);\n  } else if (isEmpty(tree.left) && isEmpty(tree.right)) {\n    tree = null;\n  } else if (isEmpty(tree.left)) {\n    tree = tree.right;\n  } else if (isEmpty(tree.right)) {\n    tree = tree.left;\n  } else {\n    tree.key = minKey(tree.right);\n    tree.right = remove(tree.right, tree.key);\n  }\n\n  **return _fixBalance(tree);**\n};\n```", "```\nconst _rotate = (tree, side) => {\n❶ const otherSide = side === \"left\" ? \"right\" : \"left\";\n❷ const auxTree = tree[side];\n❸ tree[side] = auxTree[otherSide];\n  auxTree[otherSide] = tree;\n\n❹ tree.height = _calcHeight(tree);\n  auxTree.height = _calcHeight(auxTree);\n  return auxTree;\n};\n```", "```\nconst _fixBalance = (tree) => {\n❶ if (!isEmpty(tree)) {\n  ❷ tree.height = _calcHeight(tree);\n  ❸ const balance = _calcBalance(tree);\n  ❹ if (balance < -1) {\n    ❺ if (_calcBalance(tree.left) === 1) {\n        tree.left = _rotate(tree.left, \"right\");\n      }\n    ❻ tree = _rotate(tree, \"left\");\n  ❼} else if (balance > 1) {\n      if (_calcBalance(tree.right) === -1) {\n        tree.right = _rotate(tree.right, \"left\");\n      }\n      tree = _rotate(tree, \"right\");\n    }\n  }\n  return tree;\n};\n```", "```\nconst {\n  find,\n  inOrder,\n  isEmpty,\n  maxKey,\n  minKey,\n  postOrder,\n  preOrder\n} = require(\"./binary_search_tree.js\");\nconst newBBTree = () => null;\n\nconst newNode = (key) => ({\n  key,\n  left: null,\n  right: null,\n❶ **size: 1**\n});\n\n❷ const _getSize = (tree) => (isEmpty(tree) ? 0 : tree.size);\n\n❸ const _calcSize = (tree) => 1 + _getSize(tree.left) + _getSize(tree.right);\n\n❹ const _balance = (subtree, tree) =>\n  (1 + _getSize(subtree)) / (1 + _getSize(tree));\n```", "```\nconst add = (tree, keyToAdd) => {\n  if (isEmpty(tree)) {\n    tree = newNode(keyToAdd);\n  } else {\n    const side = keyToAdd <= tree.key ? \"left\" : \"right\";\n    tree[side] = add(tree[side], keyToAdd);\n  }\n\n  **return _fixBalance(tree);**\n};\n```", "```\nconst ALPHA = 0.29289;\nconst BETA = 1 – ALPHA;     // 0.70711\nconst GAMMA = ALPHA / BETA; // 0.41421\nconst DELTA = 1 – GAMMA;    // 0.58579\n```", "```\nconst _fixBalance = (tree) => {\n  if (!isEmpty(tree)) {\n  ❶ tree.size = _calcSize(tree);\n\n  ❷ if (_balance(tree.left, tree) > BETA) {\n    ❸ if (_balance(tree.left.right, tree.left) > DELTA) {\n      ❹ tree.left = _rotate(tree.left, \"right\");\n      }\n    ❺ tree = _rotate(tree, \"left\");\n  ❻} else if (_balance(tree.right, tree) > BETA) {\n      if (_balance(tree.right.left, tree.right) > DELTA) {\n        tree.right = _rotate(tree.right, \"left\");\n      }\n      tree = _rotate(tree, \"right\");\n    }\n  }\n\n  return tree;\n};\n```", "```\nconst findByRank = (tree, rank) => {\n❶ if (isEmpty(tree) || rank < 1 || rank > _getSize(tree)) {\n   return undefined;\n  } else {\n  ❷ if (rank <= _getSize(tree.left)) {\n     return findByRank(tree.left, rank);\n  ❸} else if (rank === _getSize(tree.left) + 1) {\n     return tree.key;\n  ❹} else {\n return findByRank(tree.right, rank - _getSize(tree.left) - 1);\n   }\n }\n};\n```", "```\nconst newRandomTree = () => null;\n\nconst newNode = (key, **left = null, right = null**) => ({\n  key,\n  left,\n  right,\n  size: 1\n});\n\nconst _getSize = (tree) => (isEmpty(tree) ? 0 : tree.size);\n\nconst _calcSize = (tree) => 1 + _getSize(tree.left) + _getSize(tree.right);\n```", "```\nconst add = (tree, keyToAdd) => {\n❶ if (isEmpty(tree)) {\n   tree = newNode(keyToAdd);\n❷} else if (tree.size * Math.random() < 1) {\n ❸ const newTrees = _split(tree, keyToAdd);\n ❹ tree = newNode(keyToAdd, newTrees.right, newTrees.left);\n❺} else {\n   const side = keyToAdd <= tree.key ? \"left\" : \"right\";\n   tree[side] = add(tree[side], keyToAdd);\n }\n❻ tree.size = _calcSize(tree);\n  return tree;\n};\n```", "```\nconst _split = (\n  tree,\n  keyForSplit,\n  newTrees = {left: null, right: null},\n  lastNodes = {left: newTrees, right: newTrees}\n) => {\n❶ if (isEmpty(tree)) {\n   return newTrees;\n❷} else {\n   const [side, other] =\n      keyForSplit <= tree.key ? [\"left\", \"right\"] : [\"right\", \"left\"];\n  ❸ const nextTree = tree[side];\n    tree[side] = null;\n  ❹ lastNodes[other][side] = tree;\n    lastNodes[other] = tree;\n  ❺ const newSplit = _split(nextTree, keyForSplit, newTrees, lastNodes);\n  ❻ tree.size = _calcSize(tree);\n    return newSplit;\n  }\n};\n```", "```\nconst remove = (tree, keyToRemove) => {\n  if (isEmpty(tree)) {\n    // nothing to do\n  } else if (keyToRemove < tree.key) {\n    tree.left = remove(tree.left, keyToRemove);\n  ❶ **tree.size = _calcSize(tree);**\n  } else if (keyToRemove > tree.key) {\n    tree.right = remove(tree.right, keyToRemove);\n  ❷ **tree.size = _calcSize(tree);**\n  } else if (isEmpty(tree.left) && isEmpty(tree.right)) {\n    tree = null;\n  } else if (isEmpty(tree.left)) {\n    tree = tree.right;\n  } else if (isEmpty(tree.right)) {\n    tree = tree.left;\n  } else {\n  ❸ **tree = _join(tree.left, tree.right);**\n  }\n  return tree;\n};\n```", "```\nconst _join = (leftTree, rightTree) => {\n❶ const leftSize = _getSize(leftTree);\n  const rightSize = _getSize(rightTree);\n  const totalSize = leftSize + rightSize;\n\n❷ if (totalSize === 0) {\n   return null;\n❸} else if (totalSize * Math.random() < leftSize) {\n   leftTree.right = _join(leftTree.right, rightTree);\n   leftTree.size = _calcSize(leftTree);\n   return leftTree;\n❹} else {\n   rightTree.left = _join(leftTree, rightTree.left);\n   rightTree.size = _calcSize(rightTree);\n   return rightTree;\n }\n};\n```", "```\nconst _splay = (tree, keyToUp) => {\n❶ if (isEmpty(tree) || keyToUp === tree.key) {\n    return tree;\n  } else {\n  ❷ const side = keyToUp < tree.key ? \"left\" : \"right\";\n    if (isEmpty(tree[side])) {\n     return tree;\n  ❸} else if (keyToUp === tree[side].key) {\n     return _rotate(tree, side);\n  ❹} else {\n     if (keyToUp <= tree[side].key === keyToUp <= tree.key) {\n     ❺ tree[side][side] = _splay(tree[side][side], keyToUp);\n     ❻ tree = _rotate(tree, side);\n     } else {\n     ❼ const other = side === \"left\" ? \"right\" : \"left\";\n     ❽ tree[side][other] = _splay(tree[side][other], keyToUp);\n       if (!isEmpty(tree[side][other])) {\n         tree[side] = _rotate(tree[side], other);\n       }\n     }\n   ❾ return isEmpty(tree[side]) ? tree : _rotate(tree, side);\n   }\n }\n};\n```", "```\nconst find = (tree, keyToFind) => {\n❶ if (!isEmpty(tree)) {\n    tree = _splay(tree, keyToFind);\n  }\n❷ return [tree, !isEmpty(tree) && tree.key === keyToFind];\n};\n```", "```\nconst add = (tree, keyToAdd) => {\n❶ const newTree = newNode(keyToAdd);\n  if (!isEmpty(tree)) {\n  ❷ tree = _splay(tree, keyToAdd);\n  ❸ const [side, other] =\n      keyToAdd <= tree.key ? [\"left\", \"right\"] : [\"right\", \"left\"];\n    newTree[side] = tree[side];\n    newTree[other] = tree;\n    tree[side] = null;\n  }\n  return newTree;\n};\n```", "```\nconst _splayMinimum = (tree) => {\n  if (isEmpty(tree) || isEmpty(tree.left)) {\n    return tree;\n  } else {\n  ❶ tree.left.left = _splayMinimum(tree.left.left);\n  ❷ tree = _rotate(tree, \"left\");\n  ❸ return isEmpty(tree.left) ? tree : _rotate(tree, \"left\");\n  }\n};\n```", "```\nconst remove = (tree, keyToRemove) => {\n  if (!isEmpty(tree)) {\n  ❶ tree = _splay(tree, keyToRemove);\n    if (keyToRemove === tree.key) {\n    ❷ if (isEmpty(tree.left) && isEmpty(tree.right)) {\n       tree = null;\n    ❸} else if (isEmpty(tree.left)) {\n       tree = tree.right;\n    ❹} else if (isEmpty(tree.right)) {\n       tree = tree.left;\n     } else {\n     ❺ const oldLeft = tree.left;\n     ❻ tree = _splayMinimum(tree.right);\n     ❼ tree.left = oldLeft;\n     }\n   }\n }\n return tree;\n};\n```", "```\nconst remove = (tree, keyToRemove) => {\n  if (isEmpty(tree)) {\n    // nothing to do\n  } else if (keyToRemove < tree.key) {\n    tree.left = remove(tree.left, keyToRemove);\n    **tree.size--;**\n  } else if (keyToRemove > tree.key) {\n    tree.right = remove(tree.right, keyToRemove);\n    **tree.size--;**\n    return tree;\n    ... etc. ...\n};\n```"]