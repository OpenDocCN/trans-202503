- en: '**7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7'
- en: ORGANIZING DATA**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据组织**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: If you’ve been paying attention, you may have noticed a bit of an obsession
    when it comes to dealing with memory. Back in [Chapter 3](ch03.xhtml#ch03), you
    learned that the order in which memory devices such as DRAM, flash memory, and
    disk drives are accessed affects their speed. And in [Chapter 5](ch05.xhtml#ch05),
    you learned that performance also depends on whether or not the data that you
    need is present in cache memory. Keeping these characteristics of the memory system
    in mind when organizing your data leads to better performance. To help you do
    this, in this chapter we’ll examine a number of *data structures*, or standard
    ways of organizing data. Many of these exist to support the efficient use of different
    types of memory. This often involves a space/time trade-off wherein more memory
    is used to make certain operations faster. (Note that higher-level data structures
    are provided by programming languages, not the computer hardware itself.)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在关注，你可能会注意到，处理内存时有些“执着”。在[第 3 章](ch03.xhtml#ch03)中，你学到过，像 DRAM、闪存和磁盘驱动器等内存设备的访问顺序会影响它们的速度。而在[第
    5 章](ch05.xhtml#ch05)中，你学到过，性能也取决于你需要的数据是否在缓存内存中。将内存系统的这些特性考虑进来，在组织数据时能带来更好的性能。为了帮助你做到这一点，本章我们将探讨多种*数据结构*，或标准的数据组织方式。许多数据结构的存在是为了支持不同类型内存的高效使用。这通常涉及一个空间/时间的权衡，其中使用更多的内存以加速某些操作。（请注意，高级数据结构是由编程语言提供的，而非计算机硬件本身。）
- en: The phrase *locality of reference* sums up much of what this chapter covers
    in a fully buzzword-compliant manner. Or “keep the data you need close, the data
    you’ll need soon even closer.”
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*引用局部性*这个术语充分总结了本章所讨论的内容，完全符合流行术语的要求。或者可以说是“把你需要的数据放得近一些，把你很快就需要的数据放得更近一些。”'
- en: '**Primitive Data Types**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**原始数据类型**'
- en: 'Programming languages offer a variety of primitive data *types*. There are
    two aspects to these types: their size (number of bits) and their interpretation
    (signed, unsigned, floating point, char, pointer, Boolean). [Figure 7-1](ch07.xhtml#ch07fig01)
    shows the data types available to programmers on a typical modern machine via
    the C programming language. Different implementations of C on the same machine,
    as well as different languages such as Pascal or Java, may present these data
    types differently. Some language environments include facilities that allow the
    programmer to query the endianness (see [Figure 4-4](ch04.xhtml#ch04fig04) on
    [page 96](ch04.xhtml#page_96)), number of bits per byte, and more.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言提供了多种原始数据*类型*。这些类型有两个方面：它们的大小（位数）和它们的解释（有符号、无符号、浮动点、字符、指针、布尔值）。[图 7-1](ch07.xhtml#ch07fig01)展示了通过
    C 编程语言，程序员在典型现代计算机上可用的数据类型。即使在同一台机器上，不同的 C 实现以及其他语言，如 Pascal 或 Java，可能会以不同的方式呈现这些数据类型。一些语言环境包括允许程序员查询字节序（见[图
    4-4](ch04.xhtml#ch04fig04)在[第 96 页](ch04.xhtml#page_96)），每字节的位数等的功能。
- en: '![Image](../images/07fig01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig01.jpg)'
- en: '*Figure 7-1: Typical C language primitive data types*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：典型 C 语言原始数据类型*'
- en: We saw all of these in [Chapter 1](ch01.xhtml#ch01) except the pointer; the
    only difference here is that we’re using the C language names for them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 1 章](ch01.xhtml#ch01)中看到过这些内容，除了指针；唯一的不同是这里我们使用了 C 语言的名称。
- en: American engineer Harold Lawson invented the pointer for the PL/I (Programming
    Language One) in 1964\. A *pointer* is just an unsigned integer of some architecture-dependent
    size, but it’s interpreted as a memory address. It’s like the address of your
    house—it’s not the house itself, but it can be used to find your house. We’ve
    seen how this works before; it’s indirect addressing from “[Addressing Modes](ch04.xhtml#ch04lev2sec5)”
    on [page 104](ch04.xhtml#page_104). A zero-valued, or *NULL*, pointer is not generally
    considered a valid memory address.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 美国工程师哈罗德·劳森（Harold Lawson）在 1964 年为 PL/I（编程语言一）发明了指针。*指针*只是某种架构相关大小的无符号整数，但它被解释为内存地址。它就像你家的地址——它不是房子本身，但可以用来找到你的房子。我们之前已经看到过它是如何工作的；这就是“[寻址模式](ch04.xhtml#ch04lev2sec5)”中提到的间接寻址，见[第
    104 页](ch04.xhtml#page_104)。一个值为零的，或者说*NULL*，指针通常不被认为是有效的内存地址。
- en: C popularized pointers. Some languages have implemented more abstract *references*
    in order to try to avoid problems resulting from sloppy pointer use, a subject
    I’ll touch on this later in the chapter. Pointers tend to be the size of the natural
    word on a machine so that they can be accessed in a single cycle.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: C语言使指针变得流行。一些语言实现了更抽象的*引用*，以试图避免因指针使用不当而导致的问题，这一点我将在本章稍后讨论。指针通常与机器上的自然字长相同，以便在一个周期内可以访问它们。
- en: Advances in chip technology spurred the development of a large number of new
    machines in the 1980s, which included the transition from 16-bit to 32-bit computers.
    A lot of code written in the 1970s and early 1980s was very cavalier about pointer
    use; for example, it assumed that pointers and integers were the same size and
    used them interchangeably. This code broke in often difficult-to-debug ways when
    ported to these new machines, spawning two independent remediation approaches.
    First, people started paying a lot more attention to portability issues. This
    solution was quite successful; portability and pointer issues are much less of
    a problem today. Second, languages that eliminated pointers were developed, such
    as Java. This approach has helped in some places but is not always worth the price.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 芯片技术的进步促使了1980年代大量新机器的发展，其中包括从16位计算机过渡到32位计算机。许多在1970年代和1980年代早期编写的代码对指针使用非常随意；例如，它假设指针和整数的大小相同，并将它们互换使用。当这些代码移植到新机器上时，经常会出现难以调试的问题，从而催生了两种独立的修复方法。首先，人们开始更加关注可移植性问题。这个解决方案非常成功；如今，可移植性和指针问题已经不再是大问题。其次，开发了消除了指针的语言，例如Java。这种方法在某些地方有所帮助，但并不总是值得付出代价。
- en: '**Arrays**'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数组**'
- en: The data types you saw in the previous section are simple; you can think of
    them as houses. Languages also support *arrays*, which can instead be likened
    to apartment buildings. Apartment buildings have an address, and the individual
    apartments have unit numbers. Programmers call the unit number the *index* (starting
    at 0, unlike most apartments), and the individual apartments are called array
    *elements*. Typical computer building codes mandate that all apartments in a building
    be identical. [Figure 7-2](ch07.xhtml#ch07fig02) shows a building that contains
    ten 16-bit apartments in C.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你在上一节中看到的数据类型是简单的；你可以把它们看作是房子。语言还支持*数组*，可以将其比作公寓楼。公寓楼有一个地址，每个公寓有单元号。程序员将单元号称为*索引*（从0开始，与大多数公寓不同），而各个公寓则称为数组*元素*。典型的计算机建筑规范要求建筑中的所有公寓都是相同的。[图
    7-2](ch07.xhtml#ch07fig02)展示了一座包含十个16位公寓的C语言建筑。
- en: '![Image](../images/07fig02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig02.jpg)'
- en: '*Figure 7-2: Ten-element array of 16-bit numbers*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：十元素的16位数字数组*'
- en: Each box in [Figure 7-2](ch07.xhtml#ch07fig02) is a byte. In this array of 16-bit
    items, therefore, each element occupies two 8-bit bytes. The element subscript
    indicates the array’s index.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-2](ch07.xhtml#ch07fig02)中的每个方框代表一个字节。因此，在这个由16位元素组成的数组中，每个元素占据两个8位字节。元素下标表示数组的索引。'
- en: An alternative way to view an array is the through the lens of relative addressing
    (see “[Relative Addressing](ch05.xhtml#ch05lev1sec5)” on [page 128](ch05.xhtml#page_128)).
    Each element is an offset from the address of the 0th element, or *base address*.
    Thus, element[1] is 2 bytes away from element[0].
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 查看数组的另一种方式是通过相对寻址的视角（参见[“相对寻址”](ch05.xhtml#ch05lev1sec5)在[第128页](ch05.xhtml#page_128)的内容）。每个元素都是相对于第0个元素的地址，或者说是*基地址*的偏移量。因此，element[1]距离element[0]有2个字节。
- en: The array in [Figure 7-2](ch07.xhtml#ch07fig02) is a *one-dimensional* array—an
    ugly one-story building with all the apartments on one hall. Programming languages
    also support *multidimensional* arrays—for example, a building with four floors
    of three byte-sized apartments. This would be a two-dimensional array with two
    indices, one for the floor number and another for the apartment number on that
    floor. We can even make three-dimensional buildings with indices for wing, floor,
    and apartment; four-dimensional buildings with four indices; and so on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-2](ch07.xhtml#ch07fig02)中的数组是一个*一维*数组——一座丑陋的单层建筑，所有的公寓都在一个走廊上。编程语言也支持*多维*数组——例如，一座四层楼的建筑，每层有三个字节大小的公寓。这将是一个二维数组，具有两个索引，一个表示楼层号，另一个表示该楼层的公寓号。我们甚至可以构建三维建筑，索引分别用于区翼、楼层和公寓；四维建筑使用四个索引，依此类推。'
- en: It’s important to know how multidimensional arrays are laid out in memory. Let’s
    say we’re putting a flyer under every door in a 4×3 apartment building. We could
    do that in one of two ways. We could start on floor 0 and put a flier in apartment
    0, then go to floor 1 and put a flier into apartment 0, and so on. Or we could
    start on floor 0 and put a flier under every door on that floor, then do the same
    on floor 1, and so on. This is a *locality of reference* issue. The second approach
    (doing all the doors on one floor) has better locality of reference and is much
    easier on the legs. You can see this in [Figure 7-3](ch07.xhtml#ch07fig03), where
    the numbers in parentheses are the addresses relative to the start of the array.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 了解多维数组在内存中的布局非常重要。假设我们要在一个4×3的公寓大楼下每个门放一张传单。我们可以用两种方式之一来做。我们可以从0楼开始，把传单放到0号公寓，然后去1楼把传单放到0号公寓，以此类推。或者我们可以从0楼开始，把每一层的所有门下都放传单，然后对1楼做同样的事情，依此类推。这是一个*引用局部性*问题。第二种方法（在一层楼做所有门的操作）具有更好的引用局部性，对腿部的负担也较小。你可以在[图
    7-3](ch07.xhtml#ch07fig03)中看到这一点，其中括号中的数字是相对于数组起始位置的地址。
- en: '![Image](../images/07fig03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig03.jpg)'
- en: '*Figure 7-3: Two-dimensional array layout*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3: 二维数组布局*'
- en: The column index moves between adjacent columns, whereas the row index moves
    between rows, which are farther apart in the address space.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列索引在相邻的列之间移动，而行索引在地址空间中更远的行之间移动。
- en: This approach extends to higher dimensions. If we had a five-building complex
    with four floors of three apartments per floor, [Figure 7-3](ch07.xhtml#ch07fig03)
    would be replicated five times, once for each building. In address space, adjacent
    buildings are farther apart than adjacent rows, which are farther apart than adjacent
    columns.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以扩展到更高维度。如果我们有一个五座大楼组成的复合体，每座楼有四层，每层有三个公寓，[图 7-3](ch07.xhtml#ch07fig03)将会被复制五次，每座楼一次。在地址空间中，相邻的楼栋比相邻的行更远，而相邻的行又比相邻的列更远。
- en: Going back to [Figure 7-2](ch07.xhtml#ch07fig02), think about what would happen
    if you tried to access element[10]. Some programming languages, such as Pascal,
    check to make sure that array indices are within the bounds of the array, but
    many others (including C) don’t. Without being checked, element[10] would land
    us at bytes 20 and 21 relative to the start of the array. That could crash a program
    if there’s no memory at that address, or it could be a security hole allowing
    unintended access to data stored past the end of the array. It’s your job as a
    programmer to stay within bounds if the language doesn’t do it for you.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[图 7-2](ch07.xhtml#ch07fig02)，想象一下如果你尝试访问element[10]会发生什么。一些编程语言（如 Pascal）会检查数组索引是否在数组的范围内，但许多其他语言（包括
    C）不会。如果没有检查，element[10]会将我们指向相对于数组起始位置的第20和21字节。如果该地址没有内存，这可能会崩溃程序，或者它可能成为一个安全漏洞，允许访问数组末尾之后的数据。作为程序员，如果语言没有为你做这项工作，你的责任是确保操作在合法范围内。
- en: '**Bitmaps**'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**位图**'
- en: You’ve seen how you can construct arrays out of the primitive data types, but
    sometimes there isn’t a primitive data type that’s small enough for your purposes.
    For example, say Santa needs to track naughty versus nice for a large number of
    innocent children. Two values means that we need only 1 bit per child. We could
    easily use a byte for each value, but that’s less efficient—which translates into
    more warming at the North Pole and bad news for Frosty the Snowman because meltiness
    is considered a preexisting condition and not covered. What we really need is
    an array of bits, or a *bitmap*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到如何使用原始数据类型构建数组，但有时没有足够小的原始数据类型来满足需求。例如，假设圣诞老人需要跟踪大量无辜孩子的“乖”与“淘气”状态。两个值意味着我们每个孩子只需要1位。我们本可以为每个值轻松使用一个字节，但这效率较低——这会导致北极变暖，给雪人弗罗斯特带来坏消息，因为融化被认为是一种已有的健康状况，不予覆盖。我们真正需要的是一个位数组，或者称作*位图*。
- en: Bitmaps are easy to create. For example, say we want to keep track of 35 bits.
    We know that an array of five 8-bit bytes would be enough memory, as shown in
    [Figure 7-4](ch07.xhtml#ch07fig04).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 位图是很容易创建的。例如，假设我们想跟踪35个位。我们知道五个8位字节的数组足够存储这些位，正如[图 7-4](ch07.xhtml#ch07fig04)所示。
- en: '![Image](../images/07fig04.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig04.jpg)'
- en: '*Figure 7-4: Array as bitmap*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4: 数组作为位图*'
- en: 'There are four basic operations that we can do on bitmaps: set a bit, clear
    a bit (set it to 0), test a bit to see if it is set, and test a bit to see if
    it is clear.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在位图上执行四种基本操作：设置一个位，清除一个位（将其设为0），测试一个位查看它是否已设置，以及测试一个位查看它是否已清除。
- en: We can use integer division to find the byte containing a particular bit; all
    we have to do is divide by 8\. We can do that quickly on machines with barrel
    shifters (see “[Shiftiness](ch04.xhtml#ch04lev2sec2)” on [page 99](ch04.xhtml#page_99))
    by right-shifting the desired bit number by 3\. For example, bit number 17 would
    be in the third byte because 17 ÷ 8 is 2 in integer division, and byte 2 is the
    third byte counting from 0.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用整数除法来查找包含特定比特的字节；我们只需要除以 8。对于具有桶形移位器的机器（参见 “[移位性](ch04.xhtml#ch04lev2sec2)”
    在 [第99页](ch04.xhtml#page_99)）来说，这一步可以通过将目标比特的编号右移 3 位来快速完成。例如，比特编号 17 将位于第三个字节，因为
    17 ÷ 8 在整数除法中是 2，而字节 2 是从 0 开始数的第三个字节。
- en: The next step is to make a mask for the bit position. Similar to its physical
    counterpart, a *mask* is a bit pattern with holes that we can “see through.” We
    start by ANDing our desired bit number with a mask of 0x07 to get the lower three
    bits; for 17, that’s 00010001 AND 00000111, which yields 00000001, or bit position
    1\. We then left-shift a 1 by that amount, giving us a mask of 00000010, which
    is the position of bit 17 in byte 2.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为比特位置制作掩码。类似于其物理对应物，*掩码* 是一种具有孔洞的比特模式，我们可以通过这些孔“看到”。我们通过将所需的比特编号与 0x07 掩码进行与操作，获取低三位；对于
    17，结果是 00010001 AND 00000111，得到 00000001，即比特位置 1。然后，我们将 1 左移这么多位，得到掩码 00000010，这就是字节
    2 中比特 17 的位置。
- en: 'Using the array index and bit mask, we can easily perform the following operations:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组索引和比特掩码，我们可以轻松执行以下操作：
- en: '| **Set a bit** | bits[index] = bits[index] OR mask |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **设置一个比特** | bits[index] = bits[index] OR mask |'
- en: '| **Clear a bit** | bits[index] = bits[index] AND (NOT mask) |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **清除一个比特** | bits[index] = bits[index] AND (NOT mask) |'
- en: '| **Test for set bit** | (bits[index] AND mask) ≠ 0 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **测试是否为设置的比特** | (bits[index] AND mask) ≠ 0 |'
- en: '| **Test for clear bit** | (bits[index] AND mask) = 0 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **测试是否为清除的比特** | (bits[index] AND mask) = 0 |'
- en: 'There’s another useful application of bitmaps: to indicate whether resources
    are available or busy. If a set bit represents a busy resource, we can scan the
    array looking for a byte that’s not all 1s. This lets us test eight at a time.
    Of course, we would need to find the clear bit once we find a byte that contains
    one, but that’s much more efficient than testing each bit individually. Note that
    in cases like this, it’s more efficient to use an array of the largest primitive
    data type, such as C’s `unsigned long long`, instead of an array of bytes.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 位图还有另一个有用的应用：指示资源是否可用或忙碌。如果一个设置的比特表示一个忙碌的资源，我们可以扫描数组，寻找一个不是全 1 的字节。这允许我们一次测试八个比特。当然，一旦找到一个包含
    1 的字节，我们需要找到清除的比特，但这比单独测试每个比特要高效得多。请注意，在像这种情况下，使用最大原始数据类型的数组（例如 C 的 `unsigned
    long long`）比使用字节数组更为高效。
- en: '**Strings**'
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**字符串**'
- en: You learned about encoding characters in “[Representing Text](ch01.xhtml#ch01lev1sec10)”
    on [page 22](ch01.xhtml#page_22). A sequence of characters, such as those in this
    sentence, is called a *string*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第22页](ch01.xhtml#page_22)的 “[表示文本](ch01.xhtml#ch01lev1sec10)” 中学到了关于字符编码的内容。像这句话中的字符序列就是一个
    *字符串*。
- en: As with arrays, we often need to know a string’s length in order to be able
    to operate on it. Usually, it’s not enough to just make an array for each string,
    because many programs operate on variable-length string data; large arrays are
    often used when the length of a string isn’t known in advance. Since the array
    size is unrelated to the string length, we need some other method to track the
    string length. The most convenient way to do that is to somehow bundle the string
    length in with the string data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 和数组一样，我们经常需要知道一个字符串的长度，以便能够对其进行操作。通常，单单为每个字符串创建一个数组是不够的，因为许多程序处理的是可变长度的字符串数据；当字符串的长度无法预先确定时，通常使用较大的数组。由于数组大小与字符串长度无关，我们需要其他方法来跟踪字符串的长度。最方便的做法是将字符串长度与字符串数据捆绑在一起。
- en: One approach is to store the length in the string itself—for example, in the
    first byte. This works well but limits the length of the string to a maximum of
    255 characters, which is insufficient for many applications. More bytes can be
    used to support longer strings, but at some point, the amount of overhead (bookkeeping
    bytes) exceeds the length of many strings. Also, because strings are bytes, they
    can have any alignment, but if multibyte counts are needed, strings would have
    to be aligned on those boundaries.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是将长度存储在字符串本身中——例如，存储在第一个字节中。这种方法效果不错，但将字符串的最大长度限制为255个字符，这对于许多应用程序来说是不够的。可以使用更多的字节来支持更长的字符串，但在某些情况下，开销（记录字节）的数量会超过许多字符串的长度。此外，由于字符串是字节，它们可以有任意对齐方式，但如果需要多字节计数，字符串必须按这些边界对齐。
- en: 'C uses a different approach, borrowed from the PDP-11 assembly language’s `.ASCIZ`
    pseudo-instruction, which doesn’t have a special data type for strings like some
    languages do. It just uses one-dimensional arrays of bytes; the fact that strings
    are arrays of characters is why the byte-sized data type in C is a `char`. But
    there’s a twist: C doesn’t store a string length. Instead, it adds an extra byte
    at the end of the array of characters for a NUL terminator. C uses the ASCII NUL
    character (refer back to [Table 1-11](ch01.xhtml#ch01tab11)), which has a value
    of 0, as a *string terminator*. In other words, the NUL terminator is used to
    mark the end of a string. This works both for ASCII and UTF-8, and it looks like
    [Figure 7-5](ch07.xhtml#ch07fig05).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: C 使用了不同的方法，这种方法借鉴了 PDP-11 汇编语言中的 `.ASCIZ` 伪指令，该语言不像某些语言那样为字符串提供专门的数据类型。它只是使用一维字节数组；字符串是字符数组的事实说明了
    C 中字节大小的数据类型是 `char`。但有一个变化：C 不存储字符串的长度。相反，它在字符数组的末尾添加一个额外的字节作为 NUL 终止符。C 使用 ASCII
    的 NUL 字符（参见 [表 1-11](ch01.xhtml#ch01tab11)），其值为 0，作为 *字符串终止符*。换句话说，NUL 终止符用于标记字符串的结束。这对于
    ASCII 和 UTF-8 都适用，效果如 [图 7-5](ch07.xhtml#ch07fig05) 所示。
- en: '![Image](../images/07fig05.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig05.jpg)'
- en: '*Figure 7-5: C string storage and termination*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：C 字符串存储和终止*'
- en: As you can see, C uses 7 bytes of memory for the string, even though it’s only
    six characters long, because an extra byte is needed for the terminator.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，C 使用 7 字节的内存来存储字符串，尽管字符串只有六个字符长，因为需要额外的一个字节来存储终止符。
- en: NUL turns out to be a good choice for the terminator because most machines include
    an instruction that tests whether or not a value is 0\. Any other choice would
    involve extra instructions to load the value against which we’d be testing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: NUL 作为终止符是一个不错的选择，因为大多数机器都包含一种指令来测试某个值是否为 0。任何其他选择都需要额外的指令来加载我们要测试的值。
- en: The use of a string terminator instead of an explicit length has its benefits
    and drawbacks. On one hand, storage is compact, which is important, and there’s
    essentially no overhead to do something like “print each character in the string
    until the end is reached.” But when you need the string’s length, you have to
    scan the string for the end, counting the characters. Also, with this approach
    you can’t have a NUL character in a string.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串终止符而不是显式长度有其优缺点。一方面，存储紧凑，这一点很重要，而且执行像“打印字符串中的每个字符直到末尾”这样的操作几乎没有开销。但当你需要字符串的长度时，你必须扫描字符串直到找到末尾，计算字符数。此外，采用这种方法时，字符串中不能包含
    NUL 字符。
- en: '**Compound Data Types**'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**复合数据类型**'
- en: Although simple rooms are good for some things, the market often demands fancier
    accommodations, such as suites. Most modern languages include facilities that
    allow you to roll your own data types—the “suites,” often called *structures*.
    The various rooms in each suite are its *members*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单的房间适合做一些事情，但市场通常要求更为豪华的住宿，例如套房。大多数现代编程语言都提供了允许你自定义数据类型的功能——这些“套房”，通常被称为
    *结构体*。每个套房中的各种房间就是它的 *成员*。
- en: Let’s say we’re writing a calendar program that includes a list (array) of events
    with their starting and ending dates and times. If we were doing this in C, the
    day, month, hours, minutes, and seconds would each be held in an `unsigned char`,
    but the year would need to be in an `unsigned short`. [Figure 7-6](ch07.xhtml#ch07fig06)
    creates a structure for the date and time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在编写一个日历程序，包含一个事件列表（数组），其中每个事件有其开始和结束的日期和时间。如果我们用 C 来实现，日期、月份、小时、分钟和秒会分别存储在一个
    `unsigned char` 中，而年份则需要存储在一个 `unsigned short` 中。[图 7-6](ch07.xhtml#ch07fig06)
    创建了一个用于日期和时间的结构体。
- en: '![Image](../images/07fig06.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig06.jpg)'
- en: '*Figure 7-6: Structure for date and time*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-6：日期和时间的结构体*'
- en: 'Note that this isn’t strictly necessary; we could just have arrays of hours,
    minutes, and so on. But it’s certainly more convenient to have an array of date-time
    structures, and it makes programs easier to read and understand. British computer
    scientist Peter Landin coined the term *syntactic sugar* in 1964 for constructs
    such as this that make programs “sweeter.” Of course, one person’s sweetener is
    often another person’s essential functionality, leading to intense philosophical
    debates. Many would argue that syntactic sugar is limited to things like replacing
    `a = a + 1` with `a += 1` or `a++`, while fewer would claim that arrays of structures
    are syntactic sugar for sets of arrays. Time further complicates this fuzzy definition:
    `a += 1` and `a++` were not syntactic sugar when they were introduced, as compilers
    weren’t as good and these constructs generated better machine language. On the
    other hand, structures were more sugary when they were introduced, because prior
    code used arrays; they’re more essential now that programs are designed with structures
    in mind.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这并非绝对必要；我们可以只使用小时、分钟等的数组。但将日期时间结构数组结合在一起显然更为方便，这样也让程序更易于阅读和理解。英国计算机科学家彼得·兰丁（Peter
    Landin）在1964年创造了“*语法糖*”这个术语，用来形容那些让程序变得“更甜”的结构。当然，一个人的甜味剂往往是另一个人必不可少的功能，这也引发了激烈的哲学辩论。许多人认为，语法糖仅限于像将`a
    = a + 1`替换为`a += 1`或`a++`之类的改写，而较少有人认为结构数组是集合数组的语法糖。时间进一步复杂化了这一模糊的定义：当`a += 1`和`a++`首次出现时，它们并非语法糖，因为当时的编译器不够强大，这些构造生成了更高效的机器语言。另一方面，当结构首次出现时，它们是更具“甜味”的，因为之前的代码使用了数组；而现在，结构在程序设计中更为重要。
- en: We can use compound data types, such as our date-time structure, as if they’re
    primitive data types. [Figure 7-7](ch07.xhtml#ch07fig07) combines a pair of date-time
    structures with a small array to hold an event name string to make a complete
    calendar event structure.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像使用基本数据类型一样使用复合数据类型，比如我们的日期时间结构。[图 7-7](ch07.xhtml#ch07fig07)将一对日期时间结构与一个小数组结合在一起，用来存储事件名称字符串，从而构成一个完整的日历事件结构。
- en: '![Image](../images/07fig07.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig07.jpg)'
- en: '*Figure 7-7: Structure for calendar entry*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：日历条目的结构*'
- en: Structures often take up more memory space than you might expect. I discussed
    aligned and nonaligned memory in “[Memory](ch04.xhtml#ch04lev1sec1)” on [page
    94](ch04.xhtml#page_94). Say we built our date-time structure in an area zoned
    for 32-bit computers, as in [Figure 4-2](ch04.xhtml#ch04fig02) on [page 95](ch04.xhtml#page_95).
    The language keeps the structure members in the order specified by the programmer
    because it might matter. But the language also has to respect the alignment ([Figure
    4-3](ch04.xhtml#ch04fig03) on [page 95](ch04.xhtml#page_95)), which means that
    it can’t put the year in the fourth and fifth bytes, as shown in [Figure 7-7](ch07.xhtml#ch07fig07),
    because that crosses a boundary. The language tools solve this problem by automatically
    adding *padding* as needed. The actual memory layout of our structure would look
    like [Figure 7-8](ch07.xhtml#ch07fig08).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 结构通常比你预期的占用更多的内存空间。我在“[内存](ch04.xhtml#ch04lev1sec1)”一节中讨论了对齐和非对齐内存，具体见[第94页](ch04.xhtml#page_94)。假设我们将日期时间结构构建在为32位计算机预留的区域中，如[图
    4-2](ch04.xhtml#ch04fig02)所示，位于[第95页](ch04.xhtml#page_95)。编程语言会根据程序员指定的顺序保持结构成员的位置，因为这可能很重要。但编程语言还必须遵守对齐要求（见[图
    4-3](ch04.xhtml#ch04fig03)，位于[第95页](ch04.xhtml#page_95)），这意味着它不能将年份放置在第四和第五字节中，如[图
    7-7](ch07.xhtml#ch07fig07)所示，因为这会跨越边界。语言工具通过根据需要自动添加*填充*来解决这个问题。我们结构的实际内存布局会像[图
    7-8](ch07.xhtml#ch07fig08)所示。
- en: '![Image](../images/07fig08.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig08.jpg)'
- en: '*Figure 7-8: Structure for date and time with padding*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-8：带有填充的日期时间结构*'
- en: You could rearrange the structure members to make sure that you ended up with
    a 7-byte structure with no padding. Of course, when you combine a pair of these
    into the calendar structure, the language tools will likely pad them out to 8
    bytes anyway.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以重新排列结构成员，以确保最终得到一个没有填充的7字节结构。当然，当你将一对这样的结构合并成日历结构时，语言工具可能会将它们填充到8字节。
- en: It’s worth mentioning that this is a contrived example and you shouldn’t necessary
    handle dates and times this way. The standard in many systems, which came from
    UNIX, is to use a 32-bit number to represent the number of seconds since the “UNIX
    epoch” began on January 1, 1970\. This scheme will run out of bits in 2038, but
    many systems have expanded this to 64 bits in preparation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，这是一个人为构造的例子，实际上你不必以这种方式处理日期和时间。许多系统的标准，尤其是源自UNIX的系统，采用32位数字来表示自“UNIX纪元”开始以来的秒数，即1970年1月1日。这种方案将在2038年耗尽位数，但许多系统已经为此扩展到64位。
- en: '[Figure 1-21](ch01.xhtml#ch01fig21) showed a way to use four 8-bit values to
    represent color with transparency. That’s a great use for a structure, but it’s
    not always the best way to view that data. For example, if we needed to copy a
    color, it would be much more efficient to copy all 32 bits at once rather than
    doing four 8-bit copies. Another compound data type to the rescue.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-21](ch01.xhtml#ch01fig21)展示了一种使用四个8位值表示带透明度的颜色的方法。这是结构体的一个很好的应用，但它并不总是查看这些数据的最佳方式。例如，如果我们需要复制一个颜色，直接复制所有32位会比进行四次8位复制更高效。另一个复合数据类型来帮忙。'
- en: Not only can we have suites, as we saw in the previous section, but we can also
    have offices with movable partitions, which are called *unions* in C. A union
    allows multiple views of the same space or content. The difference between a structure
    and a union is that everything in a structure takes memory, whereas everything
    in a union shares memory. [Figure 7-9](ch07.xhtml#ch07fig09) combines the RGBα
    structure with an unsigned long to form a union.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅我们可以像在上一节看到的那样有套房，我们还可以有带活动隔断的办公室，这在C语言中被称为*联合体*。联合体允许对同一空间或内容进行多种视图。结构体和联合体的区别在于，结构体中的每一部分都需要占用内存，而联合体中的所有部分共享同一块内存。[图7-9](ch07.xhtml#ch07fig09)将RGBα结构体与无符号长整型结合，形成了一个联合体。
- en: '![Image](../images/07fig09.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig09.jpg)'
- en: '*Figure 7-9: Pixel union*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-9：像素联合体*'
- en: Using the union and C language syntax, we could set the `pixel.color` to `0x12345678`
    and then `pixel.components.red` would be `0x12`, `pixel.components.green` would
    be `0x34`, and so on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用联合体和C语言语法，我们可以将`pixel.color`设置为`0x12345678`，然后`pixel.components.red`就是`0x12`，`pixel.components.green`就是`0x34`，依此类推。
- en: '**Singly Linked Lists**'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**单链表**'
- en: Arrays are the most efficient way to keep lists of things. They only hold actual
    data, without requiring any additional bookkeeping information. But they don’t
    work as well for arbitrary amounts of data, because if we didn’t make the array
    large enough, then we have to create a new, larger array and copy all the data
    into it. And they waste space if we make them larger than necessary. Similarly,
    copying is required if you need to insert an element into the middle of a list
    or delete an element.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是存储列表数据最高效的方式。它们只存储实际数据，不需要任何额外的管理信息。但它们并不适用于任意数量的数据，因为如果我们没有预留足够大的数组，就必须创建一个更大数组并将所有数据复制进去。如果我们将数组做得比实际需要的大，它们也会浪费空间。同样的，如果你需要将元素插入到列表的中间或删除元素，也需要进行复制。
- en: '*Linked lists* can perform better than arrays when you don’t know in advance
    how many things you’ll be tracking. Singly linked lists, implemented using structures,
    look like [Figure 7-10](ch07.xhtml#ch07fig10).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*链表*在你不知道将跟踪多少个元素时，相比数组可能会表现得更好。使用结构体实现的单链表，看起来像[图7-10](ch07.xhtml#ch07fig10)。'
- en: '![Image](../images/07fig10.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig10.jpg)'
- en: '*Figure 7-10: Singly linked list*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-10：单链表*'
- en: Note that `next` is a pointer that holds the address of the next element in
    the list. The first thing in the list is known as the *head*; the last thing is
    the *tail*. We can recognize the tail because `next` is a value that can’t be
    another list element, usually a `NULL` pointer.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`next`是一个指针，保存链表中下一个元素的地址。链表中的第一个元素称为*头*，最后一个元素称为*尾*。我们可以通过`next`是一个不能指向其他链表元素的值来识别尾部，通常是`NULL`指针。
- en: A big difference between the list shown in [Figure 7-10](ch07.xhtml#ch07fig10)
    and an array is that all array elements are contiguous in memory. List elements
    can be anywhere in memory and look more like [Figure 7-11](ch07.xhtml#ch07fig11).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-10](ch07.xhtml#ch07fig10)中展示的链表和数组之间的一个大区别是，所有数组元素在内存中是连续的，而链表元素可以在内存中的任何地方，形态更像是[图7-11](ch07.xhtml#ch07fig11)。'
- en: '![Image](../images/07fig11.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig11.jpg)'
- en: '*Figure 7-11: Singly linked list in memory*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-11：内存中的单链表*'
- en: Adding an element to a list is easy; just pop it on the head, as shown in [Figure
    7-12](ch07.xhtml#ch07fig12).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 向链表中添加元素很简单；只需将其放到头部，如[图7-12](ch07.xhtml#ch07fig12)所示。
- en: '![Image](../images/07fig12.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig12.jpg)'
- en: '*Figure 7-12: Singly linked list insertion*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-12：单链表插入*'
- en: Deleting an element is a bit more complicated because we need to make the `next`
    of the previous element point to the following element, as shown in [Figure 7-13](ch07.xhtml#ch07fig13).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 删除元素要复杂一些，因为我们需要使前一个元素的`next`指针指向下一个元素，如[图 7-13](ch07.xhtml#ch07fig13)所示。
- en: '![Image](../images/07fig13.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig13.jpg)'
- en: '*Figure 7-13: Singly linked list deletion*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-13：单链表删除*'
- en: One way to do that is by using a pair of pointers, as shown in [Figure 7-14](ch07.xhtml#ch07fig14).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用一对指针，如[图 7-14](ch07.xhtml#ch07fig14)所示。
- en: '![Image](../images/07fig14.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig14.jpg)'
- en: '*Figure 7-14: Singly linked list deletion using a pair of pointers*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-14：使用一对指针进行单链表删除*'
- en: The `current` pointer walks the list looking for the node to delete. The `previous`
    pointer allows us to adjust the `next` of the node before the one to delete. We
    use a dot (`.`) to indicate a member of a structure, so `current.next` means the
    next member of the current node.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`current`指针遍历列表，寻找要删除的节点。`previous`指针让我们可以调整要删除节点之前节点的`next`。我们使用点号（`.`）表示结构体的成员，因此`current.next`表示当前节点的下一个成员。'
- en: '**NOTE**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*[Figure 7-14](ch07.xhtml#ch07fig14) isn’t a great example; although to be
    fair, I looked online while writing this section and found algorithms that were
    much worse. The problem with the code shown here is that it’s complicated because
    a special test is needed for the list head.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*[图 7-14](ch07.xhtml#ch07fig14)并不是一个很好的例子；不过公平地说，在写这一节时，我上网查找了，发现有些算法更糟糕。这里代码的问题在于，它很复杂，因为需要为列表头进行特殊测试。*'
- en: The algorithm in [Figure 7-15](ch07.xhtml#ch07fig15) shows how the power of
    *double indirect addressing* eliminates the special case, resulting in simpler
    code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-15](ch07.xhtml#ch07fig15)中的算法展示了*双重间接寻址*如何消除特殊情况，从而简化代码。'
- en: '![Image](../images/07fig15.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig15.jpg)'
- en: '*Figure 7-15: Singly linked list deletion using indirect addressing*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-15：使用间接寻址进行单链表删除*'
- en: Let’s examine how this algorithm works in more detail. Have a look at [Figure
    7-16](ch07.xhtml#ch07fig16). The subscripts show how `current` changes as the
    algorithm proceeds.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地检查一下这个算法的工作原理。看看[图 7-16](ch07.xhtml#ch07fig16)。下标显示了随着算法的执行，`current`是如何变化的。
- en: '![Image](../images/07fig16.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig16.jpg)'
- en: '*Figure 7-16: Singly linked list deletion in action*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-16：单链表删除的实际操作*'
- en: The steps shown in [Figure 7-16](ch07.xhtml#ch07fig16) are complicated, so let’s
    walk through them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-16](ch07.xhtml#ch07fig16)中显示的步骤比较复杂，我们来逐步分析一下。'
- en: We start by setting `current`[`0`] to the address of `head`, which results in
    `current`[`1`], which in turn points to `head`. This means that `current` points
    to `head`, which points to list element `A`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从将`current`[`0`]设置为`head`的地址开始，这样得到`current`[`1`]，而`current`[`1`]又指向`head`。这意味着`current`指向`head`，而`head`指向列表元素`A`。
- en: We’re not looking for element `A`, so we move along.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们并不寻找元素`A`，所以继续向前移动。
- en: As shown by the dashed arrow, we set `current` to the address of the `next`
    pointer in the element pointed to by whatever `current` points to. Since `current`[`1`]
    points to `head`, which points to element `A`, `current`[`2`] ends up pointing
    to `A.next`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如虚线箭头所示，我们将`current`设置为`current`指向的元素的`next`指针的地址。由于`current`[`1`]指向`head`，而`head`指向元素`A`，因此`current`[`2`]最终指向`A.next`。
- en: It’s still not the element that we want to delete, so we do it all again, causing
    `current`[`3`] to reference `B.next`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这仍然不是我们想要删除的元素，所以我们重新执行一遍，导致`current`[`3`]引用`B.next`。
- en: It’s still not the element that we want to delete, so we do it all again, causing
    `current`[`4`] to reference `C.next`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这仍然不是我们想要删除的元素，所以我们重新执行一遍，导致`current`[`4`]引用`C.next`。
- en: '`C.next` points to element `D`, which is the one we want to delete. Following
    the light dashed arrow, we follow `current` to `C.next` to `D`, and replace `C.next`
    with the contents of `D.next`. Since `D.next` points to element `E`, `C.next`
    now points to `E` as shown by the heavy dashed arrow, removing `D` from the list.'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`C.next`指向元素`D`，这是我们想要删除的元素。沿着浅虚线箭头，我们通过`current`指向`C.next`，到达`D`，并将`C.next`替换为`D.next`的内容。由于`D.next`指向元素`E`，现在`C.next`指向`E`，如粗虚线箭头所示，成功将`D`从列表中移除。'
- en: We could modify the preceding algorithm to insert links into the middle of the
    list. That might be useful if we, for example, wanted the list to be ordered by
    date, name, or some other criteria.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改之前的算法，将链接插入到列表的中间。如果我们想要按日期、名称或其他标准对列表进行排序，这可能会很有用。
- en: Earlier I mentioned that this second algorithm produced better code. Let’s compare
    the two as written in the C programming language. You don’t have to understand
    this code to see the difference between [Listing 7-1](ch07.xhtml#ch07list01) and
    [Listing 7-2](ch07.xhtml#ch07list02).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我提到过，第二种算法生成了更好的代码。让我们比较一下以 C 语言编写的两个版本。你不需要理解这些代码就能看到[清单 7-1](ch07.xhtml#ch07list01)和[清单
    7-2](ch07.xhtml#ch07list02)之间的区别。
- en: '[PRE0]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 7-1: C language code for singly linked list deletion using a pair
    of pointers*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-1：使用一对指针的单向链表删除的 C 语言代码*'
- en: '[PRE1]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 7-2: C language code for singly linked list deletion using double
    indirect addressing*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-2：使用双重间接寻址的单向链表删除的 C 语言代码*'
- en: As you can see, the indirect addressing version of this code in [Listing 7-2](ch07.xhtml#ch07list02)
    is much simpler than the code using a pair of pointers in [Listing 7-1](ch07.xhtml#ch07list01).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，[清单 7-2](ch07.xhtml#ch07list02)中的间接寻址版本的代码比[清单 7-1](ch07.xhtml#ch07list01)中使用一对指针的代码要简单得多。
- en: '**Dynamic Memory Allocation**'
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**动态内存分配**'
- en: Our discussion of linked list insertion conveniently omitted something important.
    I showed how to insert a new node but didn’t say where the memory for that node
    came from.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的链表插入方便地忽略了一些重要的内容。我展示了如何插入一个新节点，但没有说明该节点的内存是从哪里来的。
- en: We saw back in [Figure 5-16](ch05.xhtml#ch05fig16) that program data space starts
    with a section for statically allocated data followed by the heap that the runtime
    library sets up for the program. This is all of the data memory available to a
    program (except for the stack and interrupt vectors) on machines that don’t have
    memory management units (MMUs). On systems with MMUs, the runtime library requests
    the amount of memory it thinks it needs, because tying up all of the main memory
    doesn’t make sense. The *break* is the end of the memory available to a program,
    and there are some system calls that grow or shrink the amount of available memory.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[图 5-16](ch05.xhtml#ch05fig16)中看到，程序的数据空间从一个静态分配的数据段开始，接着是运行时库为程序设置的堆。这是程序可以使用的所有数据内存（除了栈和中断向量），适用于没有内存管理单元（MMU）的机器。在有
    MMU 的系统上，运行时库会请求它认为需要的内存量，因为占用所有主内存没有意义。*break*是程序可用内存的结束位置，并且有一些系统调用可以增大或缩小可用内存的量。
- en: Memory for variables such as arrays is static; that is, it’s assigned an address
    that doesn’t change. Things like list nodes are dynamic; they come and go as needed.
    We get memory for them from the heap.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 变量如数组的内存是静态的；也就是说，它被分配了一个不会改变的地址。像链表节点这样的东西是动态的；它们根据需要出现和消失。我们从堆中为它们分配内存。
- en: A program needs some way to manage the heap. It needs to know what memory is
    in use and what’s available. There are library functions for this so that you
    don’t have to write your own. In C, they’re the `malloc` and `free` functions.
    Let’s look at how they can be implemented.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 程序需要某种方式来管理堆内存。它需要知道哪些内存正在使用，哪些内存是可用的。为此有库函数，这样你就不需要自己编写。在 C 语言中，它们是`malloc`和`free`函数。让我们看看它们是如何实现的。
- en: One implementation of `malloc` works by using a singly linked list data structure.
    The heap is divided up into blocks, each of which has a size and a pointer to
    the next block, as shown in [Figure 7-17](ch07.xhtml#ch07fig17).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc`的一个实现通过使用单向链表数据结构来工作。堆被划分为多个块，每个块都有一个大小和指向下一个块的指针，如[图 7-17](ch07.xhtml#ch07fig17)所示。'
- en: '![Image](../images/07fig17.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig17.jpg)'
- en: '*Figure 7-17: malloc structure for heap management*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-17：堆管理的 malloc 结构*'
- en: Initially there’s just one block for the entire heap. When a program asks for
    memory, `malloc` looks for a block that has enough space, returns the caller a
    pointer to the requested space, and adjusts the size of the block to reflect the
    memory that it gave away. When a program frees memory using the `free` function,
    it just puts the block back in the list.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最初堆内存只有一个块。当程序请求内存时，`malloc`会查找一个足够大的块，返回指向请求空间的指针，并调整块的大小以反映它已分配的内存。当程序使用`free`函数释放内存时，它只是将该块重新放回链表中。
- en: At various times, `malloc` scans the list for adjacent free blocks and coalesces
    them into a single larger block. One way of doing this is when allocating memory
    (calling `malloc`) because allocation requires going through the list looking
    for a large enough block. Over time, the memory space can become *fragmented*,
    which means there’s no available block of memory large enough to satisfy a request,
    even if not all memory has been used up. On systems with MMUs, the break is adjusted
    to get more memory if needed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的时刻，`malloc`会扫描链表中的相邻空闲块，并将它们合并为一个更大的块。做到这一点的一种方式是在分配内存时（调用`malloc`），因为分配内存时需要通过链表查找足够大的块。随着时间的推移，内存空间可能会变得*碎片化*，即使所有内存没有用完，也没有足够大的内存块可以满足请求。在具有MMU（内存管理单元）的系统中，如果需要，可以调整断点来获取更多内存。
- en: 'You can see that there’s a certain amount of overhead to this approach: `next`
    and `size` add 16 bytes to each block on a 64-bit machine.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这种方法有一定的开销：`next`和`size`在64位机器上为每个块增加了16字节的开销。
- en: Freeing unallocated memory is a common error that inexperienced programmers
    make. Another is continuing to use memory that has already been freed. As you
    can see in [Figure 7-17](ch07.xhtml#ch07fig17), if you write data outside the
    bounds of allocated memory, you can corrupt the `size` and `next` fields. That’s
    particularly insidious because the problems this causes may not show up until
    a later operation needs to use the information in those fields.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 释放未分配的内存是一个经验不足的程序员常犯的错误。另一个错误是继续使用已经释放的内存。正如在[图 7-17](ch07.xhtml#ch07fig17)中所看到的，如果你在分配的内存边界外写入数据，可能会破坏`size`和`next`字段。这特别狡猾，因为这个问题可能直到后续操作需要使用这些字段中的信息时才会显现出来。
- en: One side effect of technological advances is that small machines often come
    with way more RAM than your program needs. In these cases, it’s better to just
    statically allocate everything because that reduces overhead and eliminates memory
    allocation bugs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 技术进步的一个副作用是，小型计算机通常配备的内存远远超过程序的需求。在这些情况下，最好直接静态分配所有内存，因为这样可以减少开销并消除内存分配错误。
- en: '**More Efficient Memory Allocation**'
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**更高效的内存分配**'
- en: Linked lists that include text strings are common. Suppose we have a linked
    list where the node includes a pointer to a string, as shown in [Figure 7-18](ch07.xhtml#ch07fig18).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 包含文本字符串的链表很常见。假设我们有一个链表，其中每个节点包含一个指向字符串的指针，如[图 7-18](ch07.xhtml#ch07fig18)所示。
- en: '![Image](../images/07fig18.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig18.jpg)'
- en: '*Figure 7-18: List node with string*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-18：包含字符串的链表节点*'
- en: We have to allocate memory not only for each node but also for the string attached
    to the node. The `malloc` overhead can be significant, especially on a 64-bit
    machine where we would have 16 bytes of overhead for the 16-byte node, and then
    another 16 bytes of overhead for a string such as the 4-byte `cat` in [Figure
    7-18](ch07.xhtml#ch07fig18).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅需要为每个节点分配内存，还需要为附加在节点上的字符串分配内存。`malloc`的开销可能会很大，特别是在64位机器上，我们需要为16字节的节点分配16字节的开销，然后再为字符串（如[图
    7-18](ch07.xhtml#ch07fig18)中的4字节字符串`cat`）分配16字节的开销。
- en: We can reduce the overhead by allocating the node and string at the same time.
    Instead of allocating the node and then the string, we can allocate space for
    the sum of the node and string sizes plus whatever padding might be necessary
    for alignment. This means that nodes are of variable size, which is okay. This
    trick cuts the overhead in half. The result looks like [Figure 7-19](ch07.xhtml#ch07fig19),
    with a string of `cat`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过同时分配节点和字符串来减少开销。与其先分配节点再分配字符串，我们可以分配节点和字符串大小的总和，再加上可能需要的对齐填充空间。这意味着节点的大小是可变的，这样没问题。这个技巧将开销减半。最终结果如下图[图
    7-19](ch07.xhtml#ch07fig19)，其中包含字符串`cat`。
- en: '![Image](../images/07fig19.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig19.jpg)'
- en: '*Figure 7-19: More efficient memory allocation*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-19：更高效的内存分配*'
- en: This approach is also more efficient when you are deleting nodes. In the less
    efficient case, two calls to `free` would be required, one for the string and
    another for the node. In the more efficient case, both get freed with a single
    call.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你删除节点时，这种方法也更高效。在效率较低的情况下，需要两次调用`free`，一次释放字符串，另一次释放节点。而在效率较高的情况下，两者可以通过一次调用同时释放。
- en: '**Garbage Collection**'
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**垃圾回收**'
- en: Two problems can arise from explicit dynamic memory management that are really
    problems of sloppy pointer use. Remember, a pointer is just a number that represents
    a memory address. But not all numbers are valid memory addresses. Using a pointer
    to try to access nonexistent memory or memory that doesn’t meet the processor
    alignment rules can cause an exception and crash a program.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 显式的动态内存管理可能会引发两个问题，这实际上是指针使用不当的问题。记住，指针只是一个表示内存地址的数字。但并非所有的数字都是有效的内存地址。使用指针尝试访问不存在的内存，或访问不符合处理器对齐规则的内存，可能会引发异常并导致程序崩溃。
- en: You might be learning a programming language such as Java or JavaScript that
    doesn’t have pointers but supports dynamic memory allocation without equivalents
    to `malloc` and `free`. These languages instead implement *garbage collection*,
    a technique invented in 1959 by American computer and cognitive scientist John
    McCarthy (1927–2011) for the LISP programming language. Garbage collection has
    experienced a renaissance, partly as a proscriptive remedy for bad pointer use.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在学习一种像 Java 或 JavaScript 这样的编程语言，这些语言没有指针，但支持动态内存分配，没有类似于`malloc`和`free`的对应功能。这些语言实现了*垃圾回收*，这项技术由美国计算机和认知科学家约翰·麦卡锡（John
    McCarthy，1927–2011）于 1959 年为 LISP 编程语言发明。垃圾回收经历了一次复兴，部分原因是它被认为是解决不良指针使用的有效方法。
- en: Languages like Java use references instead of pointers. *References* are an
    abstraction for pointers that provide much of the same functionality without actually
    exposing memory addresses.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Java 这样的语言使用引用而不是指针。*引用*是指针的抽象，提供了与指针相同的功能，但不会暴露内存地址。
- en: Garbage-collected languages often have a `new` operator that creates items and
    allocates memory for them (this operator also appears in non-garbage-collected
    languages such as C++). There is no corresponding operator for item deletion.
    Instead, the language runtime environment tracks the use of variables and automatically
    deletes those it deems no longer in use. There are many ways in which this is
    done, one of which is to keep a count of references to variables so the variables
    can be deleted when there are no references left.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收语言通常有一个`new`操作符，用于创建项目并为其分配内存（该操作符也出现在非垃圾回收语言如 C++ 中）。没有与删除项目对应的操作符。相反，语言的运行时环境跟踪变量的使用，并自动删除那些它认为不再使用的变量。有许多方式可以实现这一点，其中一种方式是保持对变量的引用计数，以便在没有引用时删除变量。
- en: Garbage collection is a trade-off; it’s not without its issues. One issue is
    similar to the LSI-11 refresh problem (see “[Random-Access Memory](ch03.xhtml#ch03lev2sec8)”
    on [page 82](ch03.xhtml#page_82)) in that the programmer doesn’t have much control
    over the garbage collection system, which may decide to run even though the program
    needs to do something more important. Also, programs tend to take a lot of memory
    because it’s easy to leave unnecessary references around, which prevents memory
    from being reclaimed. This makes programs run slowly as opposed to just crashing
    due to bad pointers. It turns out that despite good intentions of solving the
    pointer problem, tracking down unnecessary references is actually harder to debug.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收是一种权衡；它并非没有问题。一个问题类似于 LSI-11 刷新问题（参见[《随机存取存储器》](ch03.xhtml#ch03lev2sec8)在[第
    82 页](ch03.xhtml#page_82)的描述），即程序员对垃圾回收系统没有太多控制权，垃圾回收系统可能会决定运行，即使程序需要做更重要的事情。此外，程序通常占用大量内存，因为很容易留下不必要的引用，导致内存无法被回收。这使得程序运行缓慢，而不是因为错误的指针直接崩溃。事实证明，尽管旨在解决指针问题，但追踪不必要的引用实际上更难调试。
- en: '**Doubly Linked Lists**'
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**双向链表**'
- en: Our singly linked list `delete` function can be pretty slow because we have
    to find the element before the one we want to delete so that we can adjust its
    pointer. This could involve traversing a very long list. Fortunately, there’s
    a different type of list that solves this problem at the expense of some extra
    memory.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单向链表`删除`函数可能相当慢，因为我们必须找到我们想要删除元素之前的那个元素，以便调整其指针。这可能涉及遍历一个非常长的列表。幸运的是，有一种不同类型的链表可以通过增加一些额外的内存来解决这个问题。
- en: A doubly linked list includes a link not only to the next element but also to
    the previous element, as you can see in [Figure 7-20](ch07.xhtml#ch07fig20). This
    doubles the per-node overhead, but it eliminates the need for list walking in
    the `delete` case, so it’s a space/time trade-off.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表不仅包括指向下一个元素的链接，还包括指向上一个元素的链接，正如你在[图 7-20](ch07.xhtml#ch07fig20)中看到的那样。这增加了每个节点的开销，但它消除了在`删除`操作中遍历列表的需要，因此这是一个空间/时间的权衡。
- en: '![Image](../images/07fig20.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig20.jpg)'
- en: '*Figure 7-20: Doubly linked list*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-20：双向链表*'
- en: The advantage of a doubly linked list is that you can insert and delete anywhere
    without having to spend time traversing the list. [Figure 7-21](ch07.xhtml#ch07fig21)
    shows how you’d add a new node into a list after element A.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表的优点在于你可以在任何位置进行插入和删除，而无需花时间遍历链表。[图 7-21](ch07.xhtml#ch07fig21)展示了如何在元素 A
    后插入一个新节点。
- en: '![Image](../images/07fig21.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig21.jpg)'
- en: '*Figure 7-21: Doubly linked list insertion*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-21：双向链表插入*'
- en: '[Figure 7-22](ch07.xhtml#ch07fig22) shows that deleting an element is just
    as simple.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-22](ch07.xhtml#ch07fig22)显示了删除一个元素也同样简单。'
- en: '![Image](../images/07fig22.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig22.jpg)'
- en: '*Figure 7-22: Doubly linked list deletion*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-22：双向链表删除*'
- en: As you can see, these operations on doubly linked list elements don’t require
    traversal.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，操作双向链表元素时不需要遍历。
- en: '**Hierarchical Data Structures**'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**层级数据结构**'
- en: So far, we’ve looked only at *linear* data structures. They’re great for many
    applications, but at some point their linearity can be a problem. That’s because
    storing data is only half of the work; we also need to be able to retrieve it
    efficiently. Let’s say we have a list of things stored in a linked list. We might
    need to walk the entire list to find a particular one; for a list of length *n*,
    it could take *n* lookups. This is fine for small numbers of things but impractical
    for large values of *n*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看过*线性*数据结构。它们在许多应用中非常有用，但它们的线性结构有时也会带来问题。这是因为存储数据只是工作的其中一半；我们还需要能够高效地检索数据。假设我们有一个存储在链表中的事物列表。我们可能需要遍历整个列表才能找到某个特定项；对于长度为*n*的列表，可能需要进行*n*次查找。对于少量的数据，这没有问题，但对于大量的*n*来说，这就不切实际了。
- en: Earlier we saw how pointers could be used to connect nodes into linked lists.
    We’re not restricted to any number of pointers, so the ways in which we can organize
    data are limited only by our imagination and memory space. For example, we could
    come up with a hierarchical arrangement of nodes, as in the example back in [Figure
    5-4](ch05.xhtml#ch05fig04).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们看到如何使用指针将节点连接成链表。我们不受指针数量的限制，因此我们组织数据的方式仅受我们的想象力和内存空间的限制。例如，我们可以想出一个节点的层级结构，如在[图
    5-4](ch05.xhtml#ch05fig04)中的示例。
- en: The simplest hierarchical data structure is the *binary tree*—“binary” not because
    of binary numbers but because a node can connect to two other nodes. Let’s make
    a node that contains a number arranged as shown in [Figure 7-23](ch07.xhtml#ch07fig23).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的层级数据结构是*二叉树*——“二进制”并不是指二进制数字，而是因为一个节点可以连接到两个其他节点。让我们创建一个节点，其中包含一个数字，按[图
    7-23](ch07.xhtml#ch07fig23)所示排列。
- en: '![Image](../images/07fig23.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig23.jpg)'
- en: '*Figure 7-23: Binary tree nodes containing numbers*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-23：包含数字的二叉树节点*'
- en: The *root* is the tree equivalent of a linked list’s head.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*根*是树形结构中相当于链表头部的部分。'
- en: We’re going to hang out in a bingo parlor and record the numbers in a binary
    tree as they’re called out. We’ll then be able to look up numbers to see if they’ve
    been called. [Figure 7-24](ch07.xhtml#ch07fig24) shows an algorithm that inserts
    a number into a tree. It works in a manner similar to our singly linked list deletion
    in that it relies on indirect addressing.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将去一个宾果厅，记录二叉树中被叫出的数字。然后我们可以查找这些数字，看看它们是否已经被叫出。[图 7-24](ch07.xhtml#ch07fig24)展示了一个将数字插入树中的算法。它的工作方式类似于我们在单向链表删除时使用的间接寻址。
- en: '![Image](../images/07fig24.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig24.jpg)'
- en: '*Figure 7-24: Binary tree insertion algorithm*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-24：二叉树插入算法*'
- en: Let’s look at this in action by inserting the numbers 8, 6, 9, 4, and 5\. Nothing
    is attached to the root when we insert the 8, so we attach it there. When we insert
    the 6, the root spot is taken, so we compare that node; then because 6 is less
    than 8, we hit the left side. It’s vacant, so we plop a new node there. The 9
    goes on the right-hand side of the 8, the 4 on the left-hand side of the 6, and
    so on, as shown in [Figure 7-25](ch07.xhtml#ch07fig25).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过插入数字 8、6、9、4 和 5 来看看这个过程的实际操作。当我们插入 8 时，根节点处没有任何节点，所以我们把它插入到那里。当插入 6 时，根节点位置已被占用，因此我们比较当前节点；因为
    6 小于 8，我们走到左侧。左侧为空，于是我们将一个新节点放在那里。9 放在 8 的右侧，4 放在 6 的左侧，依此类推，如[图 7-25](ch07.xhtml#ch07fig25)所示。
- en: '![Image](../images/07fig25.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig25.jpg)'
- en: '*Figure 7-25: Binary tree*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-25：二叉树*'
- en: You can see that even though there are five things in this data structure, worst
    case we can find one by checking three nodes. This beats a linked list, where
    we may have to check all five. It’s easy to look something up in a binary tree,
    as shown in [Figure 7-26](ch07.xhtml#ch07fig26). Note that we don’t need a pointer
    to a pointer to a node here because we don’t have to modify the tree.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，尽管这个数据结构中有五个元素，但在最坏的情况下，我们只需要检查三个节点就能找到一个。这比链表要好，因为链表可能需要检查所有五个元素。在二叉树中查找某个元素很容易，如[图7-26](ch07.xhtml#ch07fig26)所示。请注意，由于我们不需要修改树，因此这里不需要指向节点的指针。
- en: '![Image](../images/07fig26.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig26.jpg)'
- en: '*Figure 7-26: Binary tree look-up algorithm*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-26：二叉树查找算法*'
- en: 'You may have noticed that the arrangement of the tree depends on insertion
    order. [Figure 7-27](ch07.xhtml#ch07fig27) shows what happens if we insert the
    numbers in order: 4, 5, 6, 8, and 9.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，树的排列方式取决于插入顺序。[图7-27](ch07.xhtml#ch07fig27)展示了如果按顺序插入数字：4、5、6、8和9，会发生什么。
- en: '![Image](../images/07fig27.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig27.jpg)'
- en: '*Figure 7-27: Poorly balanced binary tree*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-27：平衡不佳的二叉树*'
- en: This degenerate case looks a lot like a singly linked list. Not only do we lose
    the benefits of a binary tree, but now we have the additional overhead of the
    unused left pointers as well. We’d really prefer that our tree ended up looking
    like the one on the right in [Figure 7-28](ch07.xhtml#ch07fig28).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种退化的情况看起来很像一个单链表。不仅我们失去了二叉树的优势，而且现在还有未使用的左指针的额外开销。我们确实希望我们的树能够像[图7-28](ch07.xhtml#ch07fig28)右侧的那棵树一样。
- en: '![Image](../images/07fig28.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig28.jpg)'
- en: '*Figure 7-28: Unbalanced versus balanced binary trees*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-28：不平衡与平衡二叉树*'
- en: Searching for something in a binary tree is a function of the depth in the tree;
    if it’s *n* levels down, then it takes *n* tests to find it. It takes only log[2]*n*
    in a balanced binary tree as opposed to *n* in a linked list. Putting that in
    perspective, in the worst case you’d have to visit 1,024 nodes in a linked list
    containing 1,024 nodes, but you’d need to visit only 10 nodes in a balanced binary
    tree.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在二叉树中搜索某个元素的时间与树的深度相关；如果它位于* n *层深的位置，那么需要进行* n *次测试来找到它。在平衡二叉树中，查找时间是log[2]*n*，而在链表中则是*n*。从这个角度看，在最坏的情况下，如果链表有1,024个节点，你需要访问所有1,024个节点，而在平衡二叉树中，你只需要访问10个节点。
- en: There are numerous tree-balancing algorithms, which I’m not going to cover here
    in detail. It takes time to rebalance a tree, so there’s a trade-off between algorithm
    speed, insert/lookup time, and rebalancing time. Tree-balancing algorithms have
    more computational overhead, and some have additional storage overhead. That overhead
    is quickly overcome, however, as the size of the tree increases, because log[2]*n*
    becomes much smaller than *n*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多树平衡算法，我在这里不会详细讲解。重新平衡树需要时间，因此在算法速度、插入/查找时间和重新平衡时间之间存在权衡。树平衡算法有更多的计算开销，有些还会增加额外的存储开销。然而，随着树的大小增加，这些开销很快就被克服，因为log[2]*n*远小于*n*。
- en: '**Storage for the Masses**'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**面向大众的存储**'
- en: 'We talked about disk drives back in “[Block Devices](ch03.xhtml#ch03lev1sec3)”
    on [page 85](ch03.xhtml#page_85). Let’s look at them in more detail so we can
    understand their data organization peculiarities. Warning: we’re going to go pointer-crazy
    here!'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在“[块设备](ch03.xhtml#ch03lev1sec3)”一节中提到过磁盘驱动器，在[第85页](ch03.xhtml#page_85)中讨论过。现在让我们更详细地了解它们，以便理解它们的数据组织特性。警告：我们将在这里疯狂使用指针！
- en: 'I mentioned that the basic unit on a disk is a *block* and consecutive blocks
    are called *clusters*. It would be nice if we could just store data in clusters,
    which are contiguous sectors on a track. Although that’s done in certain circumstances
    where very high performance is required, it’s not a good general-purpose solution,
    and there might be more data than would fit on a track anyway. Instead, data is
    stored in whatever sectors are available; the operating system’s device driver
    provides the illusion of contiguous storage. Now we’re sort of in familiar territory,
    with a twist: instead of finding a block of storage to hold an object, we now
    have to find enough fixed-size blocks to hold an object and divide the object
    up among them.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到过，磁盘上的基本单位是 *块*，连续的块称为 *簇*。如果我们能仅仅将数据存储在簇中——簇是轨道上的连续扇区——那该多好。虽然在某些需要高性能的情况下会这么做，但这不是一个好的通用解决方案，而且可能会有比一条轨道能容纳的数据还多的情况。相反，数据被存储在可用的任何扇区中；操作系统的设备驱动程序提供了连续存储的假象。现在，我们进入了一个熟悉的领域，但有一个变化：我们不再是找到一个存储块来容纳一个对象，而是需要找到足够的固定大小的块来容纳一个对象，并将对象分割到这些块中。
- en: Linked lists are not a great solution for keeping track of which disk blocks
    are free and which are in use, because traversing a list would be too slow. An
    8 TiB disk has almost 2 billion blocks, and with worst-case behavior, 250 blocks
    can be accessed per second. That adds up to more than 15 years, which makes it
    impractical. That sounds really bad, but keep in mind that’s 1 MiB of data per
    second.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 链表并不是跟踪哪些磁盘块是空闲的，哪些是已使用的好方法，因为遍历列表会太慢。一块 8 TiB 的磁盘有近 20 亿个块，在最差的情况下，每秒可以访问 250
    个块。这加起来超过 15 年，这使得它不可行。这听起来很糟糕，但请记住，那是每秒 1 MiB 的数据。
- en: 'When we’re managing data in memory, it suffices to reference it using a pointer.
    But those are transient, and because disks are used for long-term data storage,
    we need something more persistent. You’ve already seen the answer: *filenames*.
    We need some way to both store those filenames on the disk and associate them
    with the blocks used to store the file data.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在内存中管理数据时，只需使用指针引用它即可。但这些是临时的，因为磁盘用于长期数据存储，我们需要更持久的解决方案。你已经看到了答案：*文件名*。我们需要某种方式将这些文件名存储在磁盘上，并将它们与用于存储文件数据的块关联起来。
- en: One way to manage all of this comes from—yup, you guessed it—UNIX. A number
    of blocks are set aside as *inodes*, a contraction of the disk block *index* and
    *node*; thus, inodes are index nodes. An inode contains various pieces of information
    about a file, such as its owner, size, and permissions. It also contains the indices
    of the blocks containing the file data, as you can see in [Figure 7-29](ch07.xhtml#ch07fig29).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 管理这一切的方式来自——没错，你猜对了——UNIX。若干块被作为 *inode* 留出来，inode 是磁盘块 *索引*（index）和 *节点*（node）的缩写；因此，inode
    就是索引节点。一个 inode 包含关于文件的各种信息，如其所有者、大小和权限。它还包含存储文件数据的块的索引，正如你在[图 7-29](ch07.xhtml#ch07fig29)中看到的那样。
- en: '![Image](../images/07fig29.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig29.jpg)'
- en: '*Figure 7-29: Filesystem data structure*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-29：文件系统数据结构*'
- en: This looks really complicated, but it isn’t. An inode typically has 12 *direct
    block* pointers (they’re really not pointers, just block indices), which support
    files up to 4,096 × 12 = 49,152 bytes in length. That’s good enough for most files.
    If a file is larger, it uses *indirect blocks*. Assuming 32-bit indices (though
    these will need to be 64-bit soon), 1,024 indirect blocks which at 4 bytes each
    fit in one block, add another 4 MiB to the maximum file size. If that’s not enough,
    4 GiB are available via the *double indirect* blocks, and finally another 4 PiB
    via the *triple indirect* blocks.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很复杂，但其实并不复杂。一个 inode 通常有 12 个 *直接块* 指针（它们实际上不是指针，只是块索引），这些指针支持最大 4,096 ×
    12 = 49,152 字节的文件。这对于大多数文件来说足够了。如果文件更大，它将使用 *间接块*。假设是 32 位索引（尽管这些很快会需要 64 位），1,024
    个间接块，每个间接块 4 字节，适合在一个块中，将最大文件大小再增加 4 MiB。如果这还不够，还可以通过 *双重间接* 块提供 4 GiB，最后通过 *三重间接*
    块提供 4 PiB 的空间。
- en: One piece of information an inode indicates is whether the blocks contain *directory*
    information instead of other data. A directory maps filenames to the inodes that
    reference the file data. One of the nice things about the way UNIX does things
    is that a directory is really just another type of file. That means a directory
    can reference other directories, which is what gives us our familiar tree-structured
    *hierarchical filesystems*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: inode表示的一个信息是这些块是否包含*目录*信息，而不是其他数据。目录将文件名映射到引用文件数据的inode。UNIX的一个好处是，目录实际上只是另一种类型的文件。这意味着目录可以引用其他目录，这正是我们熟悉的树状*层次文件系统*的来源。
- en: At this point, you may be thinking that all this looks a lot like an arbitrary
    tree, which was true for a while. One of the features of this arrangement is that
    multiple inodes can reference the same blocks. Each reference is called a *link*.
    Links allow the same file to appear in multiple directories. It turns out that
    it’s very convenient to also be able to link to directories, so *symbolic links*
    were invented to make that possible. But symbolic links allow loops in the filesystem
    graph, so we need special code to detect that to prevent infinite looping. In
    any case, we have this complex structure that tracks the blocks used, but we’re
    still missing an efficient way to track the *free space*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你可能会觉得这一切看起来像是一个任意的树形结构，过去的确如此。这种安排的一个特点是多个inode可以引用相同的块。每个引用称为*链接*。链接使得同一个文件可以出现在多个目录中。事实证明，能够链接到目录也是非常方便的，因此发明了*符号链接*来实现这一点。但符号链接允许文件系统图中出现循环，因此我们需要特别的代码来检测这种情况，以防止无限循环。无论如何，我们有了这个复杂的结构来跟踪已使用的块，但我们仍然缺乏一种有效的方法来跟踪*空闲空间*。
- en: 'One way to accomplish this is by using a bitmap (see “[Bitmaps](ch07.xhtml#ch07lev1sec3)”
    on [page 187](ch07.xhtml#page_187)) with 1 bit for each disk block. A bitmap can
    be pretty large: an 8 TB disk drive would need almost 2 billion bits, which would
    consume about 256 MiB. It’s still a reasonable way to go—it’s way less than 0.01
    percent of the total disk space, and it doesn’t all have to be in memory at the
    same time.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的一种方法是使用位图（参见 “[位图](ch07.xhtml#ch07lev1sec3)” 在 [第187页](ch07.xhtml#page_187)），每个磁盘块占用1个位。位图可能非常大：一个8TB的硬盘需要近20亿个位，这将消耗约256
    MiB的空间。这仍然是一个合理的选择——它只占总磁盘空间的不到0.01%，并且不需要一次性将其全部加载到内存中。
- en: Working with bitmaps is pretty simple and efficient, especially if they’re stored
    in 64-bit words. Assuming that a 1 indicates a block in use and a 0 indicates
    a free block, we can easily look for words that are not all 1s to find free blocks.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用位图工作相当简单和高效，特别是当它们存储在64位字中时。假设1表示正在使用的块，0表示空闲块，我们可以很容易地查找不全是1的字，从而找到空闲块。
- en: 'But there is a problem with this approach: it’s possible for the filesystem
    graph and the free space bitmap to get out of sync. For example, the power could
    fail while data is being written to the disk. In the dark ages when computers
    had front panels with switches and blinking lights, you’d have to repair a damaged
    filesystem by inputting inode numbers through the front panel switches. This ordeal
    was remedied by programs such as `fsck`, which traverse the filesystem graph and
    compare it to the free block data. That’s a better approach, but it’s increasingly
    time-consuming as disks get larger. New journaling filesystem designs make damage
    control more efficient.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种方法存在一个问题：文件系统图和空闲空间位图可能会不同步。例如，电力中断可能会发生在数据写入磁盘时。在计算机前面板有开关和闪烁指示灯的黑暗时代，你必须通过前面板开关输入inode号来修复损坏的文件系统。这个问题通过如`fsck`之类的程序得到解决，它遍历文件系统图并将其与空闲块数据进行比较。这是一种更好的方法，但随着硬盘容量的增大，这也变得越来越耗时。新的日志记录文件系统设计使得损坏控制更加高效。
- en: '**Databases**'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据库**'
- en: Binary trees are a great way to store data in memory, but they don’t work as
    well when it comes to storing huge amounts of data that doesn’t fit in memory.
    That’s partly because tree nodes tend to be small and therefore don’t map well
    to disk sectors.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树是存储内存中数据的好方法，但在存储大量不适合放入内存的数据时效果并不好。这部分是因为树节点通常较小，因此不容易映射到磁盘扇区。
- en: A *database* is just a collection of data organized in some way. A *database
    management system (DBMS)* is a program that allows information to be stored in
    and retrieved from a database. A DBMS usually includes a number of interfaces
    layered on top of the underlying storage mechanism.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据库*只是以某种方式组织的数据集合。*数据库管理系统 (DBMS)*是一个允许信息存储在数据库中并从中检索的程序。一个DBMS通常包含许多接口，这些接口位于底层存储机制之上。'
- en: Databases are a common application of the *B-tree* data structure invented by
    German computer scientist Rudolf Bayer and American computer scientist Ed McCreight
    at Boeing in 1971\. The B-tree is a balanced tree, but not a binary tree. It’s
    a bit less space efficient than a balanced binary tree but performs better, especially
    when data is stored on disk. This is yet another case where an understanding of
    memory architecture leads to more efficient code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是*B树*数据结构的常见应用，该结构由德国计算机科学家鲁道夫·拜尔（Rudolf Bayer）和美国计算机科学家埃德·麦克雷特（Ed McCreight）于1971年在波音公司发明。B树是一种平衡树，但不是二叉树。它的空间效率稍逊于平衡二叉树，但性能更好，特别是在数据存储在磁盘上的时候。这又是一个理解内存架构可以导致更高效代码的例子。
- en: Say we have a balanced binary tree of names sorted alphabetically. It would
    look something like [Figure 7-30](ch07.xhtml#ch07fig30).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个按字母顺序排序的平衡二叉树。它看起来像是[图 7-30](ch07.xhtml#ch07fig30)所示。
- en: '![Image](../images/07fig30.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig30.jpg)'
- en: '*Figure 7-30: Balanced binary tree*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-30: 平衡二叉树*'
- en: A B-tree node has many more legs (children) than a binary tree node. The number
    of legs is chosen such that a node fits exactly into a disk block, as shown in
    [Figure 7-31](ch07.xhtml#ch07fig31).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: B树节点比二叉树节点有更多的“腿”（子节点）。子节点的数量被选择为使一个节点恰好适合一个磁盘块，如[图 7-31](ch07.xhtml#ch07fig31)所示。
- en: '![Image](../images/07fig31.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig31.jpg)'
- en: '*Figure 7-31: B-tree*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-31: B树*'
- en: As you can see, the interior nodes are balanced, which yields a predictable
    search time. There are unused child links in [Figure 7-31](ch07.xhtml#ch07fig31)
    that consume space. You can easily rebalance the tree when child links run out
    by changing the range covered by the node. For example, if the A-M node ran out
    of children, it could be subdivided into A-G and H-M nodes. This isn’t a great
    example, because power-of-2 subdivision is most often used but we don’t have an
    even number of things to subdivide here.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，内部节点是平衡的，这保证了可预测的查找时间。[图 7-31](ch07.xhtml#ch07fig31)中存在未使用的子链接，这些链接会消耗空间。当子链接用尽时，你可以通过改变节点覆盖的范围来轻松地重新平衡树。例如，如果A-M节点用尽了子节点，可以将其细分为A-G和H-M节点。这不是一个很好的例子，因为通常使用的是2的幂次划分，但这里我们没有偶数个要划分的内容。
- en: More keys per node means less fetching of nodes. The larger nodes aren’t a problem
    because they’re the size of a disk block, which is fetched as a unit. There is
    some wasted space because of unused child links, but it’s a reasonable trade-off.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点的键更多意味着更少的节点提取。较大的节点并不成问题，因为它们的大小与磁盘块相同，磁盘块是作为一个单元被提取的。由于未使用的子链接，会有一些空间浪费，但这是一个合理的权衡。
- en: '**Indices**'
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**索引**'
- en: Accessing sorted data is efficient, but we often need to access data sorted
    in more than one way. We might have both first and last names, or names and favorite
    bands.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 访问已排序的数据效率很高，但我们通常需要以多种方式访问数据。我们可能需要同时有名字和姓氏，或者名字和最喜欢的乐队。
- en: '[Figure 7-31](ch07.xhtml#ch07fig31) shows nodes organized by name. These nodes
    are often referred to as the *primary index*. But we can have more than one index,
    as shown in [Figure 7-32](ch07.xhtml#ch07fig32), which allows us to efficiently
    search for things in different ways.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-31](ch07.xhtml#ch07fig31)展示了按名称组织的节点。这些节点通常被称为*主索引*。但我们可以有多个索引，正如[图 7-32](ch07.xhtml#ch07fig32)所示，这使我们能够以不同的方式高效地搜索数据。'
- en: '![Image](../images/07fig32.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig32.jpg)'
- en: '*Figure 7-32: Multiple indices*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-32: 多重索引*'
- en: The trade-off with indices is that they need maintenance. Every index must be
    updated when the data changes. That’s a worthwhile cost when searching is a more
    common activity than modification.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 索引的权衡在于它们需要维护。每次数据更改时，必须更新每个索引。当查找比修改更为常见时，这是一项值得的成本。
- en: '**Moving Data Around**'
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**移动数据**'
- en: I mentioned earlier that using arrays instead of linked lists requires copying
    data if the array needs to grow in size. You need copying in order to move page
    tables in and out of MMUs, free disk bitmaps on and off disk, and so on. Programs
    spend a lot of time moving data from one place to another, so it’s important to
    do it efficiently.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，使用数组代替链表时，如果数组需要增长，就需要复制数据。为了将页面表从MMU中移进移出，或将磁盘位图在磁盘上释放并重新加载，就需要复制数据。程序花费大量时间在不同位置之间移动数据，因此提高效率非常重要。
- en: 'Let’s start with a half-measure: setting a block of `length` memory bytes to
    all 0s, as shown in [Figure 7-33](ch07.xhtml#ch07fig33).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先从一个折中的方法开始：将`length`大小的内存块设置为全0，如[图7-33](ch07.xhtml#ch07fig33)所示。
- en: '![Image](../images/07fig33.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig33.jpg)'
- en: '*Figure 7-33: Zeroing a block of memory*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-33：清零内存块*'
- en: That algorithm works fine, but it’s not very efficient. Assuming that each box
    in [Figure 7-33](ch07.xhtml#ch07fig33) takes the same amount of time to execute,
    we spend more time bookkeeping than zeroing memory locations. The *loop unrolling*
    technique can make this more efficient, as shown in [Figure 7-34](ch07.xhtml#ch07fig34).
    For example, assuming that `length` is an even number, we can unroll the loop
    so that now more of the time is spent zeroing and less is spent on other things.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法运行得不错，但效率不是很高。假设[图7-33](ch07.xhtml#ch07fig33)中的每个框执行的时间相同，我们花更多时间做记账而不是清零内存位置。*循环展开*技术可以提高效率，如[图7-34](ch07.xhtml#ch07fig34)所示。例如，假设`length`是一个偶数，我们可以展开循环，使得更多的时间用于清零，而不是做其他事情。
- en: '![Image](../images/07fig34.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig34.jpg)'
- en: '*Figure 7-34: Zeroing a block of memory with loop unrolling*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-34：通过循环展开清零内存块*'
- en: It would be nice to have a more general implementation, and fortunately there
    is one. When he worked at Lucasfilm, Canadian programmer Tom Duff invented *Duff’s
    Device* to speed up the copying of data; [Figure 7-35](ch07.xhtml#ch07fig35) shows
    a variant for zeroing memory. This approach works only if the `length` is greater
    than zero.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果能有一个更通用的实现那就太好了，幸运的是，确实有。加拿大程序员Tom Duff在Lucasfilm工作时发明了*Duff设备*，用于加速数据复制；[图7-35](ch07.xhtml#ch07fig35)展示了一个用于清零内存的变体。此方法只有在`length`大于零时才能工作。
- en: '![Image](../images/07fig35.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig35.jpg)'
- en: '*Figure 7-35: Zeroing a block of memory using a modified Duff’s Device*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-35：使用修改版的Duff设备清零内存块*'
- en: Duff’s Device unrolls the loop eight times and jumps into the middle to handle
    any leftover bytes. Though you might be tempted to unroll the loop further, this
    approach must be balanced with the code size because having it fit into the instruction
    cache is worth a lot of speed.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Duff设备将循环展开八次，并跳转到中间部分处理剩余字节。尽管你可能会想进一步展开循环，但这种方法必须与代码大小平衡，因为将代码放入指令缓存是非常重要的，它带来了显著的速度提升。
- en: 'You can see on the loop side of the figure that the ratio of memory-zeroing
    time to bookkeeping time is much improved. Though the initial setup and branching
    to the proper place in the loop looks complicated, it really isn’t. It doesn’t
    take a pile of conditional branches, just some address manipulation as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到图中的循环部分，内存清零时间与记账时间的比例得到了大幅改善。尽管最初的设置和跳转到循环中的正确位置看起来很复杂，但实际上并不复杂。它不需要大量的条件分支，只需一些地址操作，如下所示：
- en: Mask off all but the lower 3 bits of the length by ANDing with 0x7.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过与0x7进行按位与操作，屏蔽掉`length`中除最低3位外的所有位。
- en: Subtract the result from 8.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从8中减去结果。
- en: Mask off all but the lower 3 bits by ANDing with 0x7.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过与0x7进行按位与操作，屏蔽掉除最低3位外的所有位。
- en: Multiply by the number of bytes between zeroing instructions.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 乘以清零指令之间的字节数。
- en: Add the address of the first zeroing instruction.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第一个清零指令的地址。
- en: Branch to that address.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳转到那个地址。
- en: Another way to increase the efficiency is to recognize that, for example, on
    a 64-bit machine, 8 bytes can be zeroed at a time. Of course, a bit of extra code
    is needed to handle leftover bytes at the beginning and the end. We need to use
    the algorithm from [Figure 7-36](ch07.xhtml#ch07fig36) without the loop on the
    `eights` for the beginning and end. In the middle, we zero as many 8-byte chunks
    as possible.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 提高效率的另一种方法是认识到，例如，在64位机器上，一次可以清零8个字节。当然，需要额外的代码来处理开头和结尾的剩余字节。我们需要使用[图7-36](ch07.xhtml#ch07fig36)中的算法，但不在`eights`上进行循环展开，开头和结尾部分需要特殊处理。中间部分我们尽可能多地清零8字节一组的数据。
- en: This all becomes more complicated when we’re copying a block of data instead
    of just setting it to a value, because chances are, the source and destination
    won’t have the same byte alignment. It’s often worth testing for the case where
    both the source and destination are word aligned because it’s a pretty common
    case.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们复制数据块而不仅仅是将其设置为某个值时，事情变得更复杂，因为源数据和目标数据通常不会具有相同的字节对齐方式。在这种情况下，值得测试源和目标是否都已按字对齐，因为这是一个相当常见的情况。
- en: Copying has yet another complication, which is that it’s common to use copying
    to move data around in a region of memory. For example, we may have a buffer full
    of space-separated words in which we want to read the first word out of the buffer
    and then cram everything else down so that there’s room for more at the end. You
    have to take care when copying data in overlapping regions; sometimes you have
    to copy backward in order to avoid overwriting the data.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 复制还面临另一个复杂性，即常常使用复制将数据在内存区域中移动。例如，我们可能有一个充满空格分隔单词的缓冲区，需要读取第一个单词并将其余的内容向下移动，为更多数据腾出空间。复制重叠区域时必须小心；有时需要向后复制，以避免覆盖已有数据。
- en: An interesting historical case was an early raster graphics terminal (see “[Raster
    Graphics](ch06.xhtml#ch06lev2sec22)” on [page 180](ch06.xhtml#page_180)) called
    the *blit*, designed by Canadian programmer Rob Pike at Bell Telephone Laboratories
    in the early 1980s, an era before it became practical to make custom integrated
    circuits to do this sort of thing. Source and destination data could overlap,
    such as in the case of dragging a window, and the data could be of any bit alignment.
    Performance was very important because processors weren’t very fast compared to
    today; the blit used a Motorola 68000\. There was no MMU, so Pike wrote code that
    looked at the source and destination and generated optimal code on the fly to
    do the fastest copy. I did a similar implementation on a system that used the
    Motorola 68020\. This achieved even better performance because the 68020 had an
    instruction cache into which the generated code fit, so it didn’t have to keep
    accessing instruction memory. Note that this was a precursor to the JIT (just-in-time)
    techniques used in many virtual machines, including Java.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的历史案例是早期的光栅图形终端（请参阅[《光栅图形》](ch06.xhtml#ch06lev2sec22)在[第180页](ch06.xhtml#page_180)）被称为*blit*，由加拿大程序员Rob
    Pike在1980年代初期于贝尔电话实验室设计，那时还没有为此类操作制造定制集成电路的技术成熟。源数据和目标数据可以重叠，例如在拖动窗口的情况下，数据可以是任何位对齐方式。由于当时的处理器速度相较于今天并不快，因此性能非常重要；blit使用了Motorola
    68000处理器。没有MMU（内存管理单元），所以Pike编写了代码，查看源和目标数据，并动态生成最优代码以执行最快的复制。我在一个使用Motorola 68020的系统上实现了类似的功能。由于68020有指令缓存，生成的代码可以适配其中，因此不必每次都访问指令内存，从而实现了更好的性能。请注意，这也是许多虚拟机中使用的JIT（即时编译）技术的先驱，包括Java。
- en: '**Vectored I/O**'
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**矢量化I/O**'
- en: Copying data efficiently is important for system performance, but avoiding copying
    altogether helps even more. A lot of data is moved through the operating system
    to and from user space programs, and this data is often not in contiguous memory.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 高效复制数据对于系统性能很重要，但完全避免复制则更加有效。大量数据在操作系统中传输，进出用户空间程序，这些数据通常不在连续的内存中。
- en: For example, say we’re generating some audio data in the mp3 format that we
    want to write to an audio device. Like many file formats, mp3 files consist of
    a number of *frames*, each of which includes a *header* followed by some data.
    A typical audio file contains multiple frames that, in many cases, have identical
    headers, as shown in [Figure 7-36](ch07.xhtml#ch07fig36).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在生成一些希望写入音频设备的mp3格式音频数据。像许多文件格式一样，mp3文件由多个*帧*组成，每一帧都包括一个*头部*，后面跟随一些数据。典型的音频文件包含多个帧，在许多情况下，这些帧的头部是相同的，如[图7-36](ch07.xhtml#ch07fig36)所示。
- en: '![Image](../images/07fig36.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig36.jpg)'
- en: '*Figure 7-36: mp3 frame layout*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-36：mp3帧布局*'
- en: We could build each frame by copying all the data into a buffer, but then when
    we write that data to an audio device, we’ll have to copy it yet again. Alternatively,
    we could write each portion of each frame separately, but that would increase
    the context-switching overhead and might cause problems for an audio device if
    only a partial frame gets written.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将所有数据复制到一个缓冲区来构建每一帧，但当我们将数据写入音频设备时，还需要再次复制这些数据。另一种方法是将每一帧的每个部分单独写入，但这会增加上下文切换的开销，并且如果只写入了部分帧，可能会导致音频设备出现问题。
- en: It would be more efficient if we could just hand the system a set of pointers
    to each piece of the frame and let the system gather the pieces together as they’re
    written, as shown in [Figure 7-37](ch07.xhtml#ch07fig37). This is sufficiently
    worthwhile to justify system call (`readv`, `writev`) support.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能直接将一组指向框架每个部分的指针交给系统，并让系统在写入时将这些部分聚集起来，那将更高效，如[图 7-37](ch07.xhtml#ch07fig37)所示。这是非常值得的，因此值得支持系统调用（`readv`，`writev`）。
- en: '![Image](../images/07fig37.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig37.jpg)'
- en: '*Figure 7-37: Data gather*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-37：数据收集*'
- en: 'The idea is to hand a vector of sizes and data pointers to the operating system,
    which then assembles them in order. There are versions for both reading and writing:
    writing is known as *gathering* because data is collected from many places, while
    reading is known as *scattering* because data is dispersed to many places. The
    whole concept is called *scatter/gather*.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个思路是将一个大小和数据指针的向量交给操作系统，然后操作系统按顺序将它们组装起来。读取和写入都有不同的版本：写入被称为*聚集*，因为数据是从多个地方收集过来的，而读取被称为*散布*，因为数据被分散到多个地方。这个概念被称为*scatter/gather*。
- en: Scatter/gather became mainstream with the Berkeley networking code that became
    a foundation of the internet. I mentioned back in “[TCP/IP](ch06.xhtml#ch06lev3sec1)”
    on [page 158](ch06.xhtml#page_158) that IP data is sent in packets and TCP is
    responsible for making sure that the packets arrive and are in the correct order.
    Packets arriving from a communications endpoint (well, it might be a communications
    endpoint to you, but it’s a socket to me) are gathered into a contiguous stream
    for presentation to user programs.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Scatter/gather（散点/聚集）成为主流，源于伯克利网络代码，这些代码成为了互联网的基础。我在“[TCP/IP](ch06.xhtml#ch06lev3sec1)”一章中提到过，[第158页](ch06.xhtml#page_158)指出，IP数据是通过数据包发送的，而TCP负责确保数据包到达并且顺序正确。从通信端点（好吧，对你来说可能是通信端点，但对我来说是套接字）到达的数据包被收集成一个连续的数据流，以便呈现给用户程序。
- en: '**Object-Oriented Pitfalls**'
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**面向对象的陷阱**'
- en: Since you’re learning to code, you may be learning an *object-oriented* language
    such as Java, C++, Python, or JavaScript. Object-oriented programming is a great
    methodology, but it can lead to performance issues if not used judiciously.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在学习编程，你可能正在学习像Java、C++、Python或JavaScript这样的*面向对象*语言。面向对象编程是一种很好的方法论，但如果不加以审慎使用，它可能会导致性能问题。
- en: Object-oriented programming first gained serious traction with C++. C++ is an
    interesting case because it was initially built on top of C, which gives us an
    opportunity to see how it works.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程首次在C++中获得了真正的关注。C++是一个有趣的案例，因为它最初是建立在C语言之上的，这让我们有机会看到它是如何工作的。
- en: '*Objects* have *methods*, which are equivalent to functions, and *properties*,
    which are equivalent to data. Everything needed for an object can be collected
    into a single data structure. C’s support for type casting and pointers, especially
    pointers to functions, wins big here. A C structure for an object might look something
    like [Figure 7-38](ch07.xhtml#ch07fig38).'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象*具有*方法*，相当于函数，还有*属性*，相当于数据。对象所需的一切都可以汇集到一个单一的数据结构中。C语言对类型转换和指针的支持，尤其是对指向函数的指针的支持，在这里起到了重要作用。一个用于对象的C结构可能类似于[图
    7-38](ch07.xhtml#ch07fig38)所示。'
- en: '![Image](../images/07fig38.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig38.jpg)'
- en: '*Figure 7-38: A C structure for an object*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-38：用于对象的C结构*'
- en: Some properties, such as those with integer values (`property 1`), reside in
    the object structure itself, whereas others require additional memory allocation
    (`property 2`) that’s referenced by the object structure.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性，比如具有整数值的（`property 1`），驻留在对象结构本身中，而其他属性则需要额外的内存分配（`property 2`），由对象结构引用。
- en: Clearly this structure could get quite large, especially if there are a lot
    of methods. We can address that by breaking the methods out into a separate structure—another
    space/time trade-off—as shown in [Figure 7-39](ch07.xhtml#ch07fig39).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种结构可能会变得相当庞大，尤其是在方法很多的情况下。我们可以通过将方法分离到一个单独的结构中来解决这个问题——这是一种空间/时间的权衡——如[图
    7-39](ch07.xhtml#ch07fig39)所示。
- en: '![Image](../images/07fig39.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig39.jpg)'
- en: '*Figure 7-39: Separate method structure*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-39：单独的方法结构*'
- en: Programmers used this sort of approach to object-oriented programming long before
    Danish programmer Bjarne Stroustrup invented C++. The original C++ was a wrapper
    around C that did things like this.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员在丹麦程序员比约恩·斯特劳斯特鲁普发明C++之前很久就开始使用这种面向对象编程的方法。最初的C++是C语言的一个封装，做了类似这样的事情。
- en: Why does this matter? Object-oriented ideologues believe that objects are the
    answer for everything. But as you can see in the previous figures, there’s a certain
    amount of overhead associated with objects. They have to carry around their own
    methods instead of using globally available functions. The upshot is that objects
    don’t pack as densely as pure data types, so stick to classic arrays when performance
    is paramount.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这很重要？面向对象的理想主义者认为对象是万灵药。但正如你在前面的图中看到的那样，使用对象会带来一定的开销。对象必须携带自己的方法，而不是使用全局可用的函数。结果是，对象不像纯数据类型那样紧凑，所以当性能至关重要时，还是应该坚持使用经典的数组。
- en: '**Sorting**'
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**排序**'
- en: There are many reasons to sort data. Sometimes we just want sorted results,
    like when we alphabetize names to make them easier for people to find. Many times
    we want to store data in sorted form because it speeds up searching by reducing
    the number of memory accesses.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 排序数据有很多原因。有时我们只是想要排序结果，比如当我们按字母顺序排列名字以便让别人更容易找到它们。很多时候，我们希望以排序的形式存储数据，因为这样可以通过减少内存访问次数来加速搜索。
- en: I’m not going to go into sorting algorithms in depth here, because it’s a pretty
    mature subject covered in many books. And plenty of good sort functions are available,
    so it’s not likely that you’ll need to write your own except as a homework problem.
    But there are a few important points to keep in mind.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我这里不打算深入讲解排序算法，因为这是一个非常成熟的话题，已经在许多书籍中讨论过了。而且有很多优秀的排序函数可用，因此你不太可能需要自己编写，除非是作为作业题目。但有几个重要的要点需要记住。
- en: One is that if the size of the things you’re sorting is larger than the size
    of a pointer, you should sort by rearranging the pointers to the data instead
    of by moving the data itself around.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一点是，如果你要排序的对象的大小大于指针的大小，你应该通过重新排列指向数据的指针来排序，而不是直接移动数据本身。
- en: Also, a convention for sorting has evolved. Our bingo parlor tree example enabled
    decisions based on an arithmetic comparison; we made decisions based on whether
    one number was less than, equal to, or greater than another. This method of decision
    making is rooted in the FORTRAN programming language from 1956, which included
    a statement that looked like [Listing 7-3](ch07.xhtml#ch07list03).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，排序的约定已经逐渐发展。我们的宾果厅树示例使得基于算术比较做出决策成为可能；我们根据一个数字是否小于、等于或大于另一个数字来做决策。这种决策方法源自1956年的
    FORTRAN 编程语言，该语言包含了类似于[清单 7-3](ch07.xhtml#ch07list03)的语句。
- en: '[PRE2]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 7-3: A FORTRAN arithmetic IF statement*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-3：一个 FORTRAN 算术 IF 语句*'
- en: This `IF` statement evaluated the `expression` and went to `branch1` if the
    result was less than zero, `branch2` if it was zero, and `branch3` if it was greater
    than zero; the branches are similar to what we saw in “[Branching](ch04.xhtml#ch04lev2sec7)”
    on [page 105](ch04.xhtml#page_105).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`IF`语句评估了`expression`，如果结果小于零就跳转到`branch1`，如果是零就跳转到`branch2`，如果大于零就跳转到`branch3`；这些分支类似于我们在[《分支结构》](ch04.xhtml#ch04lev2sec7)中看到的内容，出现在[第
    105 页](ch04.xhtml#page_105)。
- en: Sorting numbers is straightforward. It would be nice to apply this same methodology
    to sorting other things. We saw back in [Figure 7-10](ch07.xhtml#ch07fig10) that
    a list node can include arbitrary data; the same is true with tree nodes and other
    data structures.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 排序数字是直接的。将相同的方法应用于排序其他事物也是很好的选择。我们在[图 7-10](ch07.xhtml#ch07fig10)中看到，列表节点可以包含任意数据；树节点和其他数据结构也是如此。
- en: UNIX version III introduced a library function called `qsort` that implemented
    a variation of the classic *quicksort* algorithm. The interesting thing about
    the `qsort` implementation is that although it knew how to sort things, it didn’t
    know how to compare them. Therefore, it took advantage of C’s pointers to functions;
    when calling `qsort` with a list of things to sort, you also provided a comparison
    function that returned `<0`, `0`, or `>0` for less than, equal to, or greater
    than, just like the FORTRAN arithmetic `IF`. This approach allowed the caller
    to use `qsort` to sort things however they wanted. For example, if a node contained
    both a name and an age, the supplied function could compare first by age and then
    name so that `qsort` would produce results organized by age first and name second.
    This approach worked well and has been copied by many other systems.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX版本III引入了一个库函数，叫做`qsort`，它实现了一种变种的经典*快速排序*算法。关于`qsort`实现的有趣之处在于，虽然它知道如何排序，但它并不知道如何进行比较。因此，它利用了C语言的函数指针；当你调用`qsort`并传入一个待排序的列表时，你还需要提供一个比较函数，该函数返回`<0`、`0`或`>0`，分别表示小于、等于或大于，就像FORTRAN算术中的`IF`语句。这种方法使得调用者可以通过`qsort`按照自己的需求进行排序。例如，如果一个节点包含名字和年龄，提供的比较函数可以先按年龄比较，再按名字比较，这样`qsort`就会按照年龄和名字的顺序进行排序。这种方法效果很好，已经被许多其他系统复制。
- en: The standard C library string comparison function `strcmp` was designed with
    this in mind; it returns a value of less than, equal to, or greater than zero.
    This has also become the de facto way of doing things.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C库字符串比较函数`strcmp`就是在考虑到这一点的情况下设计的；它返回一个小于、等于或大于零的值。这也成为了事实上的标准做法。
- en: The original ASCII version of `strcmp` just walked the strings, subtracting
    the character of one from the other. It kept going if the value was zero and returned
    `0` if the end of the strings was reached. Otherwise, it returned the subtraction
    result.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的ASCII版本的`strcmp`只是在字符串之间逐个字符地进行减法比较。如果字符相同，继续比较，直到字符串末尾，返回`0`。否则，返回减法结果。
- en: This is all well and good if you’re just sorting to distribute data in a tree,
    but it falls apart if you’re sorting to put things into alphabetical order. It
    worked in the ASCII days—you can see in [Table 1-10](ch01.xhtml#ch01tab10) that
    the numerical order and alphabetical order are the same. Where it falls apart
    is with support for other *locales*. A side effect of support for other languages
    coming later is that only the ASCII characters are numerically in the correct
    *collating order*, or language-specific sorting rules.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是要排序以分发数据到树形结构中，这样做很好，但如果你是为了按字母顺序排序，它就会出问题。在ASCII时代它是有效的——你可以在[表1-10](ch01.xhtml#ch01tab10)中看到，数字顺序和字母顺序是一样的。问题出在对其他*地区设置*的支持上。随着对其他语言的支持逐步加入，只有ASCII字符在数字排序上符合正确的*排序顺序*，即符合特定语言的排序规则。
- en: For example, what value should be assigned to the German letter *β*, the sharp
    *S* (*Eszett* or *scharfes S*)? Its Unicode value is 0x00DF. Because of that,
    the word *Straβe* would get sorted after the word *Strasse* using a vanilla string
    comparison. But these are actually different representations of the same word.
    The *β* is equivalent to *ss*. A string comparison that heeded the locale would
    say that the two words are equal.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，德国字母*β*，即锐音*S*（*Eszett* 或 *scharfes S*）应该赋予什么值呢？它的Unicode值是0x00DF。由于这一点，单纯的字符串比较会把单词*Straβe*排在*Strasse*之后。但这实际上是同一个词的不同表示形式。*β*等同于*ss*。如果字符串比较考虑到地区设置，它会认为这两个词是相等的。
- en: '**Making a Hash of Things**'
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**制作哈希**'
- en: All the searching methods we’ve seen so far involve repeated testing while traversing
    a data structure. There’s another approach that performs better in some circumstances,
    called *hashing*. Hashing has many applications. We’re talking about in-memory
    storage and retrieval here, not mass storage. The general concept is to apply
    some *hash function* to the search keys that evenly splatter them onto the wall.
    If the hash function is easy to compute and transforms a key into a splat in a
    unique location on the wall, then single-step lookup should be fast. Of course,
    there are some practical realities to consider.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的所有查找方法都涉及在遍历数据结构时反复测试。还有另一种方法在某些情况下性能更好，叫做*哈希*。哈希有很多应用。我们在这里讨论的是内存中的存储和检索，而不是大规模存储。一般概念是对搜索键应用某种*哈希函数*，将它们均匀地“溅射”到某个位置。如果哈希函数易于计算，并且能够将一个键转换成在唯一位置的“溅射”，那么单步查找应该非常快。当然，还是有一些实际问题需要考虑。
- en: Each splat represents the storage for the object associated with the key. The
    hash function must produce values that fit in memory. And it shouldn’t splatter
    things across too much memory or performance will suffer, both from using too
    much memory and from lack of locality of reference. Coming up with a perfect hash
    function isn’t really possible because we don’t have any prior knowledge of our
    keys.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分裂符号代表与键相关联的对象的存储。哈希函数必须产生适合内存的值。而且它不应该将数据分散到过多的内存中，否则性能会受到影响，既因为使用了过多内存，也因为缺乏局部性引用。因为我们无法预先了解键的情况，设计一个完美的哈希函数实际上是不可能的。
- en: One way to bound the storage is to have a hash function that maps keys into
    array indices. The array is called a *hash table*, shown in [Figure 7-40](ch07.xhtml#ch07fig40).
    The array elements are called *buckets*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 限制存储的一种方法是使用一个哈希函数，将键映射到数组索引。这个数组被称为*哈希表*，如[图7-40](ch07.xhtml#ch07fig40)所示。数组元素被称为*桶*。
- en: '![Image](../images/07fig40.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig40.jpg)'
- en: '*Figure 7-40: Hashing*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-40：哈希*'
- en: What makes a good hash function? It needs to be easy to compute, and it needs
    to distribute keys evenly into the buckets. A simple hash function that works
    pretty well for text is just to sum up the character values. That’s not quite
    enough, because the sum might produce an index that’s beyond the end of the hash
    table, but we can easily solve this by making the index the sum modulo the hash
    table size. Let’s look at how this works in practice. We’ll use a table size of
    11; prime numbers make good table sizes because multiples of the sum end up in
    different buckets, improving the splatter pattern.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的哈希函数有什么特点？它需要易于计算，并且需要将键均匀地分布到桶中。一个对于文本效果不错的简单哈希函数就是将字符值相加。这还不够，因为和可能会产生一个超出哈希表末尾的索引，但我们可以通过将索引设置为和对哈希表大小取模来轻松解决这个问题。让我们来看一下这个方法在实践中的效果。我们将使用一个大小为11的表；素数是一个好的表大小，因为和的倍数最终会落入不同的桶，从而改善分布模式。
- en: Say we have an application that keeps track of songs played at our favorite
    jam band concerts. Maybe it stores the last played date. We’ll just use the first
    word of each song name.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个应用程序，它记录我们最喜欢的即兴乐队音乐会中播放的歌曲。也许它会存储最后播放的日期。我们将只使用每首歌曲名称的第一个词。
- en: As you can see in [Figure 7-41](ch07.xhtml#ch07fig41), we start with *Hell*
    in a bucket—in this case, bucket 4\. Next is *Touch* in bucket 9, followed by
    *Scarlet* in 3\. But when we get to *Alligator*, we have a problem because the
    value of the hash function is the same as it was for *Scarlet*. This is called
    a *collision*.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图7-41](ch07.xhtml#ch07fig41)所示，我们从桶中放入*Hell*，在这种情况下是桶4。接下来是桶9中的*Touch*，然后是桶3中的*Scarlet*。但是当我们遇到*Alligator*时，我们遇到了一个问题，因为哈希函数的值与*Scarlet*的值相同。这叫做*碰撞*。
- en: '![Image](../images/07fig41.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig41.jpg)'
- en: '*Figure 7-41: Hash collision*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-41：哈希碰撞*'
- en: We solve this by replacing the buckets with *hash chains*, which in their simplest
    form are singly linked lists, as shown in [Figure 7-42](ch07.xhtml#ch07fig42).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将桶替换为*哈希链*来解决这个问题，哈希链在最简单的形式下是单向链表，如[图7-42](ch07.xhtml#ch07fig42)所示。
- en: '![Image](../images/07fig42.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig42.jpg)'
- en: '*Figure 7-42: Hash chains*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-42：哈希链*'
- en: There are a number of trade-offs in hash chain management. We can just insert
    collisions at the head of the chain, as in [Figure 7-42](ch07.xhtml#ch07fig42),
    because it’s fast. But lookup can slow down as the chains get longer, so we could
    also do an insertion sort, which takes longer but means we don’t have to traverse
    a chain to the end to determine whether or not an item exists. There are also
    many different collision-handling methods—for example, eliminating hash chains
    and using some algorithm to find an empty slot in the table.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希链管理中存在许多权衡。我们可以像[图7-42](ch07.xhtml#ch07fig42)中那样将冲突插入链的头部，因为这种方法很快。但当链变长时，查找可能会变慢，因此我们也可以进行插入排序，虽然需要更多时间，但这样我们就不必遍历整个链来判断一个项目是否存在。还有许多不同的冲突处理方法——例如，消除哈希链并使用某些算法在表中找到一个空槽。
- en: It’s difficult to pick a good hash table size without knowing the expected number
    of symbols in advance. You can keep track of chain length and grow the hash table
    if the chains are getting too long. This can be an expensive operation, but it
    can pay off because it doesn’t need to be done very often.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在不知道预期符号数量的情况下，很难选择合适的哈希表大小。如果链的长度过长，可以通过跟踪链的长度并扩展哈希表来解决。这可能是一个昂贵的操作，但它的回报是值得的，因为它不需要频繁执行。
- en: There are many variations on hash functions. The holy grail of hash functions
    is the *perfect hash*, which maps each key to a unique bucket. It’s pretty much
    impossible to create a perfect hash function unless all of the keys are known
    in advance, but mathematicians have come up with much better functions than the
    one used in this example.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数有很多种变体。哈希函数的“圣杯”是*完美哈希*，它将每个键映射到一个独特的桶中。除非事先知道所有的键，否则几乎不可能创建一个完美的哈希函数，但数学家们已经想出了比本例中使用的哈希函数更好的函数。
- en: '**Efficiency vs. Performance**'
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**效率与性能**'
- en: A lot of effort has gone into making efficient search algorithms. Much of this
    work was done in an era when computers were expensive. Performance and efficiency
    were linked.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 很多努力都投入到了高效搜索算法的研究中。大部分工作是在计算机昂贵的时代进行的。性能和效率是紧密相关的。
- en: The cost of electronics has plunged so dramatically that it’s almost impossible
    to purchase anything that doesn’t include a gratuitous blue LED. Performance and
    efficiency are decoupled; there are cases where better performance can be achieved
    by using less efficient algorithms on more processors than more efficient algorithms
    on fewer processors.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 电子产品的成本已经急剧下降，以至于几乎不可能购买任何不包含多余蓝色LED的产品。性能和效率已被解耦；有时，通过在更多处理器上使用效率较低的算法，而不是在更少的处理器上使用更高效的算法，可以实现更好的性能。
- en: One application of this decoupling is database *sharding*, also called *horizontal
    partitioning*. Sharding involves breaking up a database into multiple shards,
    each of which lives on its own machine, as shown in [Figure 7-43](ch07.xhtml#ch07fig43).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解耦的一种应用是数据库*分片*，也叫做*水平分区*。分片是将一个数据库拆分成多个分片，每个分片都存储在自己的机器上，如[图 7-43](ch07.xhtml#ch07fig43)所示。
- en: '![Image](../images/07fig43.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig43.jpg)'
- en: '*Figure 7-43: Database sharding*'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-43：数据库分片*'
- en: Database operations requested over the interface are sent to all of the shards,
    and the results are assembled by a controller. This technique improves performance
    because operations are split across multiple workers.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 通过接口请求的数据库操作会被发送到所有分片，然后由控制器组装结果。这种技术提高了性能，因为操作被分配到多个工作者上。
- en: A variation on sharding is called *MapReduce*, which essentially allows you
    to provide code to the controller for assembly of the intermediate results. This
    makes it possible to do operations such as “count the number of students in all
    math classes” without having to first request a list of students and then count
    them.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 分片的一种变体被称为*MapReduce*，它本质上允许你向控制器提供代码，用于汇总中间结果。这使得像“计算所有数学课学生人数”这样的操作成为可能，而无需先请求学生名单然后再统计他们的数量。
- en: Databases aren’t the only application of this multiple processor approach. A
    historically interesting use is the Electronic Frontier Foundation’s DES (Data
    Encryption Standard) cracker built in 1998; see the book *Cracking DES* (O’Reilly,
    1998) for the full story. A machine was constructed that used 1,856 custom processor
    chips, each of which tried a range of keys on the encrypted data. Any “interesting”
    results were forwarded to a controller for further analysis. This machine could
    test 90 billion keys per second.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库并不是这种多处理器方法的唯一应用。一个历史上有趣的应用是1998年电子前沿基金会开发的DES（数据加密标准）破解器；详情请参阅《Cracking
    DES》一书（O'Reilly，1998）。这台机器使用了1,856个定制的处理器芯片，每个芯片尝试一系列的密钥来破解加密数据。任何“有趣”的结果都会被转发到控制器进行进一步分析。这台机器每秒可以测试900亿个密钥。
- en: '**Summary**'
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter introduced you to a number of ways in which data can be organized
    to take advantage of what you’ve learned so far about computer hardware. In the
    next chapter, you’ll see how your programs get converted into forms that computer
    hardware can understand.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了数据可以如何组织，以利用你迄今为止了解的计算机硬件知识。在下一章中，你将看到你的程序是如何被转换为计算机硬件可以理解的形式的。
