- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">MICROSOFT-WINDOWS-THREAT-INTELLIGENCE</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">MICROSOFT-WINDOWS-THREAT-INTELLIGENCE</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: For years, Microsoft Defender for Endpoint (MDE) presented a huge challenge
    for offensive security practitioners because it could detect issues that all the
    other EDR vendors missed. One of the primary reasons for its effectiveness is
    its use of the *Microsoft-Windows-Threat-Intelligence (EtwTi)* ETW provider. Today,
    developers who publish ELAM drivers use it to access some of the most powerful
    detection sources on Windows.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，Microsoft Defender for Endpoint (MDE) 给进攻性安全从业者带来了巨大挑战，因为它能够检测到其他所有 EDR
    厂商遗漏的问题。其有效性的主要原因之一是它使用了 *Microsoft-Windows-Threat-Intelligence (EtwTi)* ETW 提供程序。今天，发布
    ELAM 驱动程序的开发者使用它来访问 Windows 上最强大的检测源之一。
- en: Despite its name, this ETW provider won’t provide you with attribution information.
    Rather, it reports on events that were previously unavailable to EDRs, like memory
    allocations, driver loads, and syscall policy violations to *Win32k*, the kernel
    component of the Graphics Device Interface. These events functionally replace
    the information EDR vendors gleaned from user-mode function hooking, which attackers
    can easily evade, as covered in [Chapter 2](chapter2.xhtml).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其名称如此，这个 ETW 提供程序并不会为你提供归属信息。相反，它报告一些先前无法被 EDR 获取的事件，如内存分配、驱动程序加载和系统调用策略违规，针对
    *Win32k*（图形设备接口的内核组件）。这些事件在功能上替代了 EDR 厂商从用户模式函数钩子中获取的信息，而攻击者可以轻松规避这些钩子，正如 [第 2
    章](chapter2.xhtml) 中所述。
- en: Because events from this provider originate from the kernel, the provider is
    more difficult to evade, has greater coverage than user-mode alternatives, and
    is less risky than function hooking, as the provider is integrated into the operating
    system itself. Due to these factors, it is rare to encounter mature EDR vendors
    that don’t use it as a telemetry source.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该提供程序的事件源自内核，因此它比用户模式的替代方案更难规避，覆盖面更广，而且比函数钩子风险更低，因为该提供程序已集成在操作系统本身中。由于这些因素，很少遇到不使用它作为遥测源的成熟
    EDR 厂商。
- en: This chapter covers how the EtwTi provider works, its detection sources, the
    types of events it emits, and how attackers may evade detection.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 EtwTi 提供程序的工作原理、其检测源、它发出的事件类型，以及攻击者可能如何规避检测。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Reverse Engineering the Provider</samp>
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">逆向工程提供程序</samp>
- en: Before we cover the types of events emitted by the EtwTi provider, you should
    understand how it gets the information in the first place. Unfortunately, Microsoft
    provides no public documentation about the provider’s internals, so discovering
    this is largely a manual effort.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们介绍 EtwTi 提供程序发出的事件类型之前，您需要了解它是如何获取信息的。不幸的是，Microsoft 没有提供该提供程序内部的公开文档，因此发现这些信息在很大程度上是一个手动过程。
- en: 'As a case study, this section covers one example of EtwTi’s source: what happens
    when a developer changes the protection level of a memory allocation to mark it
    as executable. Malware developers frequently use this technique; they’ll first
    write shellcode to an allocation marked with read-write (RW) permissions and then
    change these to read-execute (RX) through an API such as <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!VirtualProtect()</samp>
    before they execute the shellcode.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个案例分析，本节介绍了 EtwTi 的一个来源示例：当开发者将内存分配的保护级别更改为标记为可执行时会发生什么。恶意软件开发者经常使用这种技术；他们首先将
    shellcode 写入一个标记为读写（RW）权限的分配区域，然后通过如 <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!VirtualProtect()</samp>
    这样的 API 将其更改为读执行（RX）权限，然后执行 shellcode。
- en: When the malware developer calls this API, execution eventually flows down to
    the syscall for <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtProtectVirtualMemory()</samp>.
    Execution is transferred into the kernel, where some safety checks and validations
    occur. Then, <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!MmProtectVirtualMemory()</samp>
    is called to change the protection level on the allocation. This is all pretty
    standard, and it would be reasonable to assume that <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!NtProtectVirtualMemory()</samp>
    would clean up and return at this point. However, one last conditional block of
    code in the kernel, shown in [Listing 12-1](#list12-1), calls <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogProtectExecVm()</samp>
    if the protection change succeeded.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当恶意软件开发者调用这个API时，执行最终会流向系统调用<samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtProtectVirtualMemory()</samp>。执行流被转移到内核，在那里进行一些安全检查和验证。接着，调用了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nt!MmProtectVirtualMemory()</samp>来更改分配的保护级别。这一切都很标准，可以合理地假设<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nt!NtProtectVirtualMemory()</samp>会在此时进行清理并返回。然而，内核中的最后一个条件代码块，如[清单12-1](#list12-1)所示，如果保护级别更改成功，它会调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogProtectExecVm()</samp>。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 12-1: The EtwTi function called inside <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!NtProtectVirtualMemory()</samp>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-1：在<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!NtProtectVirtualMemory()</samp>内部调用的EtwTi函数
- en: The name of this function implies that it is responsible for logging protection
    changes for executable regions of memory.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的名字暗示它负责记录可执行内存区域的保护变化。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Checking That the
    Provider and Event Are Enabled</samp>
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">检查提供者和事件是否已启用</samp>
- en: Within the function is a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwProviderEnabled()</samp>,
    which is defined in [Listing 12-2](#list12-2). It verifies that a given ETW provider
    is enabled on the system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中调用了<samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwProviderEnabled()</samp>，其定义见[清单12-2](#list12-2)。它验证指定的ETW提供者是否在系统上启用。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 12-2: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!EtwProviderEnabled()</samp>
    definition'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-2：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!EtwProviderEnabled()</samp>定义
- en: The most interesting part of this function is the <samp class="SANS_TheSansMonoCd_W5Regular_11">RegHandle</samp>
    parameter, which is the global <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwThreatIntProvRegHandle</samp>,
    in the case of this provider. This handle is referenced in every EtwTi function,
    meaning we can use it to find other functions of interest. If we examine the cross-reference
    to the global ETW provider handle, as shown in [Figure 12-1](#fig12-1), we can
    see 31 other references made to it, most of which are other EtwTi functions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数最有趣的部分是< samp class="SANS_TheSansMonoCd_W5Regular_11">RegHandle</samp>参数，它是全局的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EtwThreatIntProvRegHandle</samp>，在这个提供者的情况下。这个句柄在每个EtwTi函数中都会被引用，意味着我们可以用它来找到其他感兴趣的函数。如果我们检查全局ETW提供者句柄的交叉引用，如[图12-1](#fig12-1)所示，我们可以看到它有31个其他引用，其中大多数是其他EtwTi函数。
- en: '![](../images/Figure12-1.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: Cross-references
    to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ThreatIntProviderGuid</samp></samp>'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图12-1：对<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ThreatIntProviderGuid</samp>的交叉引用</samp>
- en: One of the cross-references originates from <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwpInitialize()</samp>,
    a function called during the boot process that, among other things, is responsible
    for registering system ETW providers. To do this, it calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwRegister()</samp>
    function. The signature for this function is shown in [Listing 12-3](#list12-3).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个交叉引用来自<samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwpInitialize()</samp>，这是一个在启动过程中调用的函数，负责注册系统ETW提供者等任务。为此，它调用了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwRegister()</samp>函数。此函数的签名如[清单12-3](#list12-3)所示。
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 12-3: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!EtwRegister()</samp>
    definition'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-3：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!EtwRegister()</samp>定义
- en: This function is called during the boot process with a pointer to a GUID named
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ThreatIntProviderGuid</samp>, shown
    in [Listing 12-4](#list12-4).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数在启动过程中被调用，传入一个指向名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ThreatIntProviderGuid</samp>
    的 GUID 的指针，显示在 [清单 12-4](#list12-4) 中。
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 12-4: Registering <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ThreatIntProviderGuid</samp>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-4：注册 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ThreatIntProviderGuid</samp>
- en: The GUID pointed to is in the <samp class="SANS_TheSansMonoCd_W5Regular_11">.data</samp>
    section, shown in [Figure 12-2](#fig12-2) as <samp class="SANS_TheSansMonoCd_W5Regular_11">f4e1897c-bb5d-5668-f1d8-040f4d8dd344</samp>.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 指向的 GUID 位于 <samp class="SANS_TheSansMonoCd_W5Regular_11">.data</samp> 段中，在
    [图 12-2](#fig12-2) 中显示为 <samp class="SANS_TheSansMonoCd_W5Regular_11">f4e1897c-bb5d-5668-f1d8-040f4d8dd344</samp>。
- en: '![](../images/Figure12-2.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: The GUID pointed
    to by <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ThreatIntProviderGuid</samp></samp>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-2：由 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ThreatIntProviderGuid</samp>
    指向的 GUID</samp>
- en: If the provider is enabled, the system checks the event descriptor to determine
    if the specific event is enabled for the provider. This check is performed by
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwEventEnabled()</samp>
    function, which takes the provider handle used by <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwProviderEnabled()</samp>
    and an <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_DESCRIPTOR</samp> structure
    corresponding to the event to be logged. Logic determines which <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_DESCRIPTOR</samp>
    to use based on the calling thread’s context (either user or kernel).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供者已启用，系统会检查事件描述符，以确定该特定事件是否已为提供者启用。此检查由 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwEventEnabled()</samp>
    函数执行，该函数使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwProviderEnabled()</samp>
    使用的提供者句柄和与要记录的事件对应的 <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_DESCRIPTOR</samp>
    结构。逻辑根据调用线程的上下文（用户或内核）决定使用哪个 <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_DESCRIPTOR</samp>。
- en: Following these checks, the EtwTi function builds out a structure with functions
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwpTiFillProcessIdentity()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwpTiFillVad()</samp>. This
    structure is not easily statically reversed, but thankfully, it is passed into
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwWrite()</samp>, a function
    used for emitting events. Let’s use a debugger to examine it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些检查后，EtwTi 函数构建一个包含如 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwpTiFillProcessIdentity()</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwpTiFillVad()</samp> 等函数的结构。该结构并不容易静态反向分析，但幸运的是，它被传递到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwWrite()</samp> 中，后者是一个用于发出事件的函数。我们可以使用调试器来检查它。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Determining the Events
    Emitted</samp>
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">确定已发出的事件</samp>
- en: At this point, we know the syscall passes data to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogProtectExecVm()</samp>,
    which emits an event over ETW using the EtwTi provider. The particular event emitted
    is still unknown, though. To collect this information, let’s view the data in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">PEVENT_DATA_DESCRIPTOR</samp>
    passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwWrite()</samp> using
    WinDbg.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们知道系统调用将数据传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogProtectExecVm()</samp>，该函数通过
    EtwTi 提供者在 ETW 上发出一个事件。但发出的具体事件仍然未知。为了收集此信息，让我们通过 WinDbg 查看传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwWrite()</samp>
    的 <samp class="SANS_TheSansMonoCd_W5Regular_11">PEVENT_DATA_DESCRIPTOR</samp>
    中的数据。
- en: By placing a conditional breakpoint on the function that writes the ETW event
    when its call stack includes <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogProtectExecVm()</samp>,
    we can further investigate the parameters passed to it ([Listing 12-5](#list12-5)).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在写入 ETW 事件的函数上设置条件断点，当其调用堆栈包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogProtectExecVm()</samp>
    时，我们可以进一步调查传递给该函数的参数（[清单 12-5](#list12-5)）。
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 12-5: Using a conditional breakpoint to watch calls to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!EtwTiLogProtectExecVm()</samp>'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-5：使用条件断点监视对 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!EtwTiLogProtectExecVm()</samp>
    的调用
- en: This call stack shows a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtProtectVirtualMemory()</samp>
    surfacing from user mode and hitting the System Service Dispatch Table (SSDT)
    ❷, which is really just an array of addresses to functions that handle a given
    syscall. Control is then passed up to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!NtProtectVirtualMemory()</samp>
    where the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogProtectExecVm()</samp>
    ❶ is made, just as we identified earlier through static analysis.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用栈显示了一个对 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtProtectVirtualMemory()</samp>
    的调用，从用户模式浮现并命中系统服务调度表 (SSDT) ❷，这实际上只是一个函数地址数组，用于处理给定的系统调用。然后控制权被传递到 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!NtProtectVirtualMemory()</samp>，在那里调用了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogProtectExecVm()</samp>
    ❶，正如我们之前通过静态分析所识别的那样。
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">UserDataCount</samp> parameter
    passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwWrite()</samp> contains
    the number of <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_DATA_DESCRIPTOR</samp>
    structures in its fifth parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp>.
    This value will be stored in the R9 register and can be used to display all entries
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp> array, stored
    in RAX. This is shown in the WinDbg output in [Listing 12-6](#list12-6).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwWrite()</samp> 的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">UserDataCount</samp> 参数包含其第五个参数 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp> 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_DATA_DESCRIPTOR</samp>
    结构的数量。这个值将被存储在 R9 寄存器中，并可用于显示存储在 RAX 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp>
    数组中的所有条目。该过程在 [清单 12-6](#list12-6) 中的 WinDbg 输出中有所展示。
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 12-6: Listing the values in <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">UserData</samp>
    using the number of entries stored in R9'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-6：使用 R9 中存储的条目数列出 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">UserData</samp>
    中的值
- en: The first 64-bit value on each line of the WinDbg output is a pointer to the
    data, and the next one describes the size of the data in bytes. Unfortunately,
    this data isn’t named or labeled, so discovering what each descriptor describes
    is a manual process. To decipher which pointer holds which type of data, we can
    use the provider GUID collected earlier in this section, <samp class="SANS_TheSansMonoCd_W5Regular_11">f4e1897c-bb5d-5668-f1d8-040f4d8dd344</samp>.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: WinDbg 输出中的每一行的前 64 位值是指向数据的指针，接下来的值描述数据的字节大小。不幸的是，这些数据没有名称或标签，因此需要手动过程来发现每个描述符所描述的内容。为了破译哪个指针包含哪种类型的数据，我们可以使用本节前面收集到的提供程序
    GUID：<samp class="SANS_TheSansMonoCd_W5Regular_11">f4e1897c-bb5d-5668-f1d8-040f4d8dd344</samp>。
- en: As discussed in [Chapter 8](chapter8.xhtml), ETW providers can register an event
    manifest, which describes the events emitted by the provider and their contents.
    We can list these providers using the *logman.exe* utility, as shown in [Listing
    12-7](#list12-7). Searching for the GUID associated with the EtwTi provider reveals
    that the provider’s name is *Microsoft-Windows-Threat-Intelligence*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [第 8 章](chapter8.xhtml) 中讨论的那样，ETW 提供程序可以注册一个事件清单，描述由提供程序发出的事件及其内容。我们可以使用
    *logman.exe* 工具列出这些提供程序，如 [清单 12-7](#list12-7) 所示。搜索与 EtwTi 提供程序相关的 GUID 会发现该提供程序的名称是
    *Microsoft-Windows-Threat-Intelligence*。
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 12-7: Retrieving the provider’s name using logman.exe'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-7：使用 logman.exe 获取提供程序的名称
- en: After identifying the name of the provider, we can pass it to tools such as
    PerfView to get the provider manifest. When the PerfView command in [Listing 12-8](#list12-8)
    completes, it will create the manifest in the directory from which it was called.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了提供程序的名称后，我们可以将其传递给如 PerfView 等工具，以获取提供程序的清单。当 [清单 12-8](#list12-8) 中的 PerfView
    命令完成时，它将在被调用的目录中创建清单文件。
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 12-8: Using PerfView to dump the provider manifest'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-8：使用 PerfView 转储提供程序清单
- en: You can view the sections of this manifest that relate to the protection of
    virtual memory in the generated XML. The most important section for understanding
    the data in the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp>
    array is in the <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">template></samp>
    tags, shown in [Listing 12-9](#list12-9).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在生成的 XML 文件中查看与虚拟内存保护相关的清单部分。理解 <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp>
    数组数据的最重要部分在于 <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">template></samp>
    标签，如 [清单 12-9](#list12-9) 中所示。
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 12-9: ETW provider manifest dumped by PerfView'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-9：PerfView 转储的 ETW 提供程序清单
- en: Comparing the data sizes specified in the manifests with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp>
    field of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_DATA_DESCRIPTOR</samp>
    structures reveals that the data appears in the same order. Using this information,
    we can extract individual fields of the event. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectionMask</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">LastProtectionMask</samp> correlate
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtProtectVirtualMemory()</samp>’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NewAccessProtection</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">OldAccessProtection</samp>, respectively.
    The last two entries in the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp>
    array match their data type. [Listing 12-10](#list12-10) shows how we can investigate
    these values using WinDbg.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 比较清单中指定的数据大小与 <samp class="SANS_TheSansMonoCd_W5Regular_11">EVENT_DATA_DESCRIPTOR</samp>
    结构的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Size</samp> 字段，发现数据顺序相同。利用这些信息，我们可以提取事件的各个字段。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ProtectionMask</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">LastProtectionMask</samp>
    与 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtProtectVirtualMemory()</samp>
    的 <samp class="SANS_TheSansMonoCd_W5Regular_11">NewAccessProtection</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">OldAccessProtection</samp> 分别对应。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">UserData</samp> 数组中的最后两个条目与它们的数据类型匹配。[清单
    12-10](#list12-10) 显示了我们如何使用 WinDbg 检查这些值。
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 12-10: Evaluating protection mask changes using WinDbg'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-10：使用 WinDbg 评估保护掩码变化
- en: We can inspect the values’ contents to see that <samp class="SANS_TheSansMonoCd_W5Regular_11">LastProtectionMask</samp>
    ❷ was originally <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_EXECUTE_READ</samp>
    (0x20) and has been changed to <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_READWRITE</samp>
    (0x4) ❶. Now we know that removing the executable flag in the memory allocation
    caused the event to fire.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查值的内容，看到 <samp class="SANS_TheSansMonoCd_W5Regular_11">LastProtectionMask</samp>
    ❷ 最初是 <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_EXECUTE_READ</samp> (0x20)，现在已更改为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_READWRITE</samp> (0x4) ❶。现在我们知道，移除内存分配中的可执行标志导致了事件的触发。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Determining the Source of an Event</samp>
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">确定事件的来源</samp>
- en: Although we’ve explored the flow from a user-mode function call to an event
    being emitted, we’ve done so for a single sensor only, <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogProtectExecVm()</samp>.
    At the time of this writing, there are 11 of these sensors, shown in [Table 12-1](#tab12-1).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经探索了从用户模式函数调用到事件被触发的流程，但我们只针对单个传感器进行了分析，即 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogProtectExecVm()</samp>。在撰写本文时，已有
    11 个这样的传感器，如 [表 12-1](#tab12-1) 所示。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-1:</samp> <samp class="SANS_Futura_Std_Book_11">Security
    and Security Mitigation Sensors</samp>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 12-1：</samp> <samp class="SANS_Futura_Std_Book_11">安全性和安全缓解传感器</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Microsoft-Windows-Threat-Intelligence
    Sensors</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Microsoft-Windows-Security-
    Mitigations Sensors</samp> |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">Microsoft-Windows-Threat-Intelligence
    Sensors</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Microsoft-Windows-Security-
    Mitigations Sensors</samp> |'
- en: '| --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogAllocExecVm</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogBlockNonCetBinaries</samp>
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogAllocExecVm</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogBlockNonCetBinaries</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogDeviceObjectLoadUnload</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogControlProtectionKernelModeReturnMismatch</samp>
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogDeviceObjectLoadUnload</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogControlProtectionKernelModeReturnMismatch</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogDriverObjectLoad</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogControlProtectionUserModeReturnMismatch</samp>
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogDriverObjectLoad</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogControlProtectionUserModeReturnMismatch</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogDriverObjectUnLoad</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogProhibitChildProcessCreation</samp>
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogDriverObjectUnLoad</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogProhibitChildProcessCreation</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogInsertQueueUserApc</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogProhibitDynamicCode</samp>
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogInsertQueueUserApc</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogProhibitDynamicCode</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogMapExecView</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogProhibitLowILImageMap</samp>
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogMapExecView</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogProhibitLowILImageMap</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogProtectExecView</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogProhibitNonMicrosoftBinaries</samp>
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogProtectExecView</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogProhibitNonMicrosoftBinaries</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogReadWriteVm</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogProhibitWin32kSystemCalls</samp>
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogReadWriteVm</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogProhibitWin32kSystemCalls</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogSetContextThread</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogRedirectionTrustPolicy</samp>
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogSetContextThread</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogRedirectionTrustPolicy</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogSuspendResumeProcess</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogUserCetSetContextIpValidationFailure</samp>
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogSuspendResumeProcess</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTimLogUserCetSetContextIpValidationFailure</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogSuspendResumeThread</samp>
    |  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogSuspendResumeThread</samp>
    |  |'
- en: An additional 10 sensors relate to security mitigations and are identified by
    their <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTim</samp> prefix. These
    sensors emit events through a different provider, Microsoft-Windows-Security-Mitigations,
    but function identically to the normal EtwTi sensors. They’re responsible for
    generating alerts about security mitigation violations, such as the loading of
    low-integrity-level or remote images or the triggering of Arbitrary Code Guard,
    based on system configuration. While these exploit mitigations are out of scope
    for this book, you’ll occasionally encounter them while investigating EtwTi sensors.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，10个传感器与安全缓解措施相关，并通过其前缀<samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTim</samp>进行标识。这些传感器通过不同的提供程序Microsoft-Windows-Security-Mitigations发出事件，但功能与正常的EtwTi传感器完全相同。它们负责生成关于安全缓解措施违规的警报，例如加载低完整性级别或远程图像，或基于系统配置触发任意代码保护。虽然这些漏洞缓解措施超出了本书的范围，但在调查EtwTi传感器时，你偶尔会遇到它们。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Neo4j to Discover
    the Sensor Triggers</samp>
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用Neo4j发现传感器触发器</samp>
- en: What causes the sensors in [Table 12-1](#tab12-1) to emit events? Thankfully,
    there is a relatively easy way for us to figure this out. Most measure activity
    coming from user mode, and for control to transition from user mode to kernel
    mode, a syscall needs to be made. Execution will land in functions prefixed with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp> after control is handed
    to the kernel, and the SSDT will handle the entry-point resolution.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[表12-1](#tab12-1)中的传感器是什么原因导致其发出事件？幸运的是，我们有一种相对简单的方法来弄清楚这一点。大多数传感器衡量来自用户模式的活动，而为了从用户模式切换到内核模式，需要发出系统调用（syscall）。在控制权交给内核后，执行将进入以<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>为前缀的函数，SSDT将处理入口点的解析。'
- en: Therefore, we can map paths from functions with <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>
    prefixes to functions with <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTi</samp>
    prefixes to identify APIs that cause events to be emitted due to actions in user
    mode. Ghidra and IDA both offer call-tree mapping functions that serve this purpose
    generally. Their performance can be limited, however. For example, Ghidra’s default
    search depth is five nodes, and longer searches take exponentially longer. They’re
    also exceedingly difficult to parse.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将以<samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>为前缀的函数路径映射到以<samp
    class="SANS_TheSansMonoCd_W5Regular_11">EtwTi</samp>为前缀的函数，以识别由于用户模式中的操作而触发事件的API。Ghidra和IDA都提供了调用树映射功能，通常可以实现这一目的。然而，它们的性能可能有限。例如，Ghidra的默认搜索深度为五个节点，较长的搜索会呈指数级增长，并且非常难以解析。
- en: To address this, we can use a system built for identifying paths, such as the
    graph database Neo4j. If you’ve ever used BloodHound, the attack path-mapping
    tool, you’ve used Neo4j in some form. Neo4j can map the relationships (called
    *edges*) between any kind of item (called *nodes*). For example, BloodHound uses
    Active Directory principals as its nodes and properties like access control entries,
    group membership, and Microsoft Azure permissions as edges.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以使用一个专门用于识别路径的系统，比如图数据库 Neo4j。如果你曾经使用过 BloodHound 这个攻击路径映射工具，那你其实已经在某种形式上使用过
    Neo4j。Neo4j 可以映射任何类型项之间的关系（称为 *边*）。例如，BloodHound 使用 Active Directory 实体作为节点，而像访问控制项、组成员身份和
    Microsoft Azure 权限等属性作为边。
- en: In order to map nodes and edges, Neo4j supports a query language called Cypher
    whose syntax lies somewhere between Structured Query Language (SQL) and ASCII
    art and can often look like a drawn diagram. Rohan Vazarkar, one of the inventors
    of BloodHound, wrote a fantastic blog post about Cypher queries, “Intro to Cypher,”
    that remains one of the best resources on the topic.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了映射节点和边，Neo4j 支持一种名为 Cypher 的查询语言，其语法介于结构化查询语言（SQL）和 ASCII 艺术之间，通常看起来像是一个手绘图。BloodHound
    的发明者之一 Rohan Vazarkar 写了一篇关于 Cypher 查询的精彩博文《Intro to Cypher》，它仍然是该主题的最佳资源之一。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Getting a Dataset
    to Work with Neo4j</samp>
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">让数据集与 Neo4j 配合使用</samp>
- en: To work with Neo4j, we need a structured dataset, typically in JSON format,
    to define nodes and edges. We then load this dataset into the Neo4j database using
    functions from the Awesome Procedures on Cypher add-on library (such as <samp
    class="SANS_TheSansMonoCd_W5Regular_11">apoc.load.json()</samp>). After ingestion,
    the data is queried using Cypher in either the web interface hosted on the Neo4j
    server or a connected Neo4j client.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与 Neo4j 配合使用，我们需要一个结构化的数据集，通常是 JSON 格式，用于定义节点和边。然后，我们使用来自 Cypher 插件库 Awesome
    Procedures 的函数（如 <samp class="SANS_TheSansMonoCd_W5Regular_11">apoc.load.json()</samp>）将该数据集加载到
    Neo4j 数据库中。数据加载后，我们可以在 Neo4j 服务器上的 Web 界面或连接的 Neo4j 客户端中使用 Cypher 查询数据。
- en: 'We must extract the data needed to map call graphs into the graph database
    from Ghidra or IDA using a plug-in, then convert it to JSON. Specifically, each
    entry in the JSON object needs to have three properties: a string containing the
    name of the function that will serve as the node, the entry point offset for later
    analysis, and the outgoing references (in other words, the functions being called
    by this function) to serve as the edges.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用插件从 Ghidra 或 IDA 提取所需的数据，以便将调用图映射到图形数据库中，然后将其转换为 JSON。具体来说，JSON 对象中的每个条目需要包含三个属性：一个字符串，包含将作为节点的函数名称，一个用于后续分析的入口点偏移量，以及作为边的外部引用（换句话说，即该函数调用的函数）。
- en: The open source Ghidra script *CallTreeToJSON.py* iterates over all functions
    in a program that Ghidra has analyzed, collects the attributes of interest, and
    creates new JSON objects for ingestion by Neo4j. To map the paths related to the
    EtwTi sensors, we must first load and analyze *ntoskrnl.exe*, the kernel image,
    in Ghidra. Then we can load the Python script into Ghidra’s Script Manager and
    execute it. This will create a file, *xrefs.json*, that we can load into Neo4j.
    It contains the Cypher commands shown in [Listing 12-11](#list12-11).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 开源的 Ghidra 脚本 *CallTreeToJSON.py* 会遍历 Ghidra 分析过的程序中的所有函数，收集感兴趣的属性，并为 Neo4j
    创建新的 JSON 对象进行加载。为了映射与 EtwTi 传感器相关的路径，我们必须首先在 Ghidra 中加载并分析 *ntoskrnl.exe* 内核映像。然后，我们可以将
    Python 脚本加载到 Ghidra 的脚本管理器中并执行它。这将创建一个名为 *xrefs.json* 的文件，我们可以将其加载到 Neo4j 中。它包含了清单
    [12-11](#list12-11) 中所示的 Cypher 命令。
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 12-11: Loading call trees into Ghidra'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-11：将调用树加载到 Ghidra 中
- en: After importing the JSON file into Neo4j, we can query the dataset using Cypher.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JSON 文件导入 Neo4j 后，我们可以使用 Cypher 查询数据集。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Viewing the Call
    Trees</samp>
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">查看调用树</samp>
- en: To make sure everything is set up correctly, let’s write a query to map the
    path to the <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogProtectExecVm</samp>
    sensor. In plain English, the query in [Listing 12-12](#list12-12) says, “Return
    the shortest paths of any length from any function name that begins with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp> to the sensor function we specify.”
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保一切设置正确，我们来编写一个查询，映射到 <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogProtectExecVm</samp>
    传感器的路径。简单来说，清单 [12-12](#list12-12) 中的查询表示：“返回任何长度的最短路径，从任何以 <samp class="SANS_TheSansMonoCd_W5Regular_11">Nt</samp>
    开头的函数名，到我们指定的传感器函数。”
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 12-12: Mapping the shortest paths between <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Nt</samp>
    functions and the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EtwTiLogProtectExecVm</samp>
    sensor'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-12：映射 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Nt</samp>
    函数与 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">EtwTiLogProtectExecVm</samp>
    传感器之间的最短路径
- en: When entered into Neo4j, it should display the path shown in [Figure 12-3](#fig12-3).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入到 Neo4j 时，它应该显示[图 12-3](#fig12-3)所示的路径。
- en: '![](../images/Figure12-3.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-3: A simple path
    between a syscall and an EtwTi function</samp>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-3：系统调用与 EtwTi 函数之间的简单路径</samp>
- en: The call trees for other sensors are far more complex. For example, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogMapExecView()</samp> sensor’s
    call tree is 12 levels deep, leading all the way back to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!NtCreatePagingFile()</samp>.
    You can see this by modifying the sensor name in the previous query, generating
    the path in [Figure 12-4](#fig12-4).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 其他传感器的调用树要复杂得多。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogMapExecView()</samp>传感器的调用树有12个层级，最终回溯到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nt!NtCreatePagingFile()</samp>。你可以通过修改之前查询中的传感器名称来查看这一点，从而生成[图
    12-4](#fig12-4)中的路径。
- en: '![](../images/Figure12-4.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-4: Paths from <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!NtCreatePagingFile()</samp></samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!EtwTiLogMapExecView()</samp></samp>'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-4：从<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!NtCreatePagingFile()</samp></samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">到<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!EtwTiLogMapExecView()</samp></samp>
- en: As this example demonstrates, many syscalls indirectly hit the sensor. Enumerating
    these can be useful if you’re looking for coverage gaps, but the amount of information
    generated can quickly become overwhelming.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如此示例所示，许多系统调用间接触及传感器。列举这些调用对于寻找覆盖漏洞可能很有用，但生成的信息量可能会迅速变得压倒性。
- en: You might want to scope your queries to a depth of three to four levels (representing
    two or three calls); these should return the APIs that are directly responsible
    for calling the sensor function and hold the conditional logic to do so. Using
    the previous example, a scoped query would show that the syscall <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtMapViewOfSection()</samp>
    calls the sensor function directly, while the syscall <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtMapViewOfSectionEx()</samp>
    calls it indirectly via a memory manager function, as shown in [Figure 12-5](#fig12-5).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望将查询的范围限制为三到四个层级（代表两到三个调用）；这些查询应返回直接负责调用传感器函数并包含条件逻辑的 API。以之前的示例为例，限定范围的查询将显示系统调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtMapViewOfSection()</samp>直接调用传感器函数，而系统调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtMapViewOfSectionEx()</samp>则通过内存管理器函数间接调用传感器，如[图
    12-5](#fig12-5)所示。
- en: '![](../images/Figure12-5.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-5: Scoped query that
    returns more useful results</samp>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-5：返回更有用结果的限定查询</samp>
- en: Performing this analysis across EtwTi sensor functions yields information about
    their callers, both direct and indirect. [Table 12-2](#tab12-2) shows some of
    these mappings.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对 EtwTi 传感器函数进行此类分析会产生关于它们调用者的信息，包括直接和间接调用者。[表 12-2](#tab12-2)展示了其中一些映射。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 12-2:</samp> <samp class="SANS_Futura_Std_Book_11">EtwTi
    Sensor-to-Syscall Mappings</samp>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 12-2：</samp> <samp class="SANS_Futura_Std_Book_11">EtwTi
    传感器到系统调用的映射</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Sensor</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Call
    tree from syscall (depth = 4)</samp> |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">传感器</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">来自系统调用的调用树（深度
    = 4）</samp> |'
- en: '| --- | --- |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogAllocExecVm</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">MiAllocateVirtualMemory</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp> |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogAllocExecVm</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">MiAllocateVirtualMemory</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogDriverObjectLoad</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">IopLoadDriver</samp>←<samp class="SANS_TheSansMonoCd_W5Regular_11">IopLoadUnloadDriver</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IopLoadDriverImage</samp>←<samp class="SANS_TheSansMonoCd_W5Regular_11">NtLoadDriverIopLoadDriver</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IopLoadUnloadDriver</samp>←<samp class="SANS_TheSansMonoCd_W5Regular_11">IopUnloadDriver</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtUnloadDriver</samp> |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogDriverObjectLoad</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">IopLoadDriver</samp>←<samp class="SANS_TheSansMonoCd_W5Regular_11">IopLoadUnloadDriver</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IopLoadDriverImage</samp>←<samp class="SANS_TheSansMonoCd_W5Regular_11">NtLoadDriverIopLoadDriver</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">IopLoadUnloadDriver</samp>←<samp class="SANS_TheSansMonoCd_W5Regular_11">IopUnloadDriver</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtUnloadDriver</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogInsertQueueUserApc</samp>
    <samp class="SANS_Futura_Std_Book_11">There are other branches of the call tree
    that lead to system calls, such as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!IopCompleteRequest()</samp><samp
    class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PspGet
    ContextThreadInternal()</samp><samp class="SANS_Futura_Std_Book_11">, and</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PspSet ContextThreadInternal()</samp><samp
    class="SANS_Futura_Std_Book_11">, but these aren’t particularly useful, as many
    internal functions rely on these functions regardless of whether the APC is being
    created explicitly.</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">KeInsertQueueApc</samp>
    ←<samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThread</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">KeInsertQueueApc</samp>
    ←<samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThreadEx</samp> |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogInsertQueueUserApc</samp>
    <samp class="SANS_Futura_Std_Book_11">还有其他分支的调用树会导致系统调用，例如</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!IopCompleteRequest()</samp><samp
    class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PspGet
    ContextThreadInternal()</samp><samp class="SANS_Futura_Std_Book_11">, 和</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PspSet ContextThreadInternal()</samp><samp
    class="SANS_Futura_Std_Book_11">, 但这些并不特别有用，因为许多内部函数无论是否显式创建了 APC 都依赖这些函数。</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">KeInsertQueueApc</samp> ←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThread</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">KeInsertQueueApc</samp>
    ←<samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThreadEx</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogMapExecView</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSectionMiMapViewOf</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">SectionExCommon</samp> ←<samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSectionEx</samp>
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogMapExecView</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSectionMiMapViewOf</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">SectionExCommon</samp> ←<samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSectionEx</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogProtectExecVm</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp>
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogProtectExecVm</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogReadWriteVm</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">MiReadWriteVirtualMemory</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemoryMiReadWriteVirtualMemory</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemoryExMiReadWriteVirtualMemory</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp> |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogReadWriteVm</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">MiReadWriteVirtualMemory</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemoryMiReadWriteVirtualMemory</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemoryExMiReadWriteVirtualMemory</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogSetContextThread</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">PspSetContextThreadInternal</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtSetContextThread</samp> |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogSetContextThread</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">PspSetContextThreadInternal</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtSetContextThread</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogSuspendResumeThread</samp>
    <samp class="SANS_Futura_Std_Book_11">This sensor has additional paths that are
    not listed and are tied to debugging APIs, including</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtDebugActiveProcess()</samp><samp
    class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!Nt
    DebugContinue()</samp><samp class="SANS_Futura_Std_Book_11">, and</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtRemove ProcessDebug()</samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSuspendThread</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtSuspendThreadPsSuspendThread</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtChangeThreadStatePsSuspendThread</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PsSuspendProcess</samp>←<samp class="SANS_TheSansMonoCd_W5Regular_11">NtSuspendProcessPsMultiResumeThread</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtResumeThread</samp> |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwTiLogSuspendResumeThread</samp>
    <samp class="SANS_Futura_Std_Book_11">此传感器有额外的路径，未列出并与调试API相关，包括</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtDebugActiveProcess()</samp><samp
    class="SANS_Futura_Std_Book_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!Nt
    DebugContinue()</samp><samp class="SANS_Futura_Std_Book_11">, 和</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtRemove
    ProcessDebug()</samp><samp class="SANS_Futura_Std_Book_11">.</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">PsSuspendThread</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtSuspendThreadPsSuspendThread</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtChangeThreadStatePsSuspendThread</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PsSuspendProcess</samp>←<samp class="SANS_TheSansMonoCd_W5Regular_11">NtSuspendProcessPsMultiResumeThread</samp>←<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtResumeThread</samp> |'
- en: An important fact to consider when reviewing this dataset is that Ghidra does
    not factor conditional calls in its call trees but rather looks for *call* instructions
    inside functions. This means that while the graphs generated from the Cypher queries
    are technically correct, they may not be followed in all instances. To demonstrate
    this, an exercise for the reader is to reverse <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>
    to find where the determination to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogAllocExecVm()</samp>
    sensor is made.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看此数据集时需要考虑的一个重要事实是，Ghidra不会在调用树中考虑条件调用，而是查找函数内部的*call*指令。这意味着，尽管从Cypher查询生成的图表在技术上是正确的，但在所有实例中可能不会遵循这些图表。为了演示这一点，读者可以进行一个练习，反向分析<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>，找到决定调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogAllocExecVm()</samp>传感器的地方。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Consuming EtwTi Events</samp>
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">消费EtwTi事件</samp>
- en: In [Chapter 8](chapter8.xhtml), you learned how EDRs consume events from other
    ETW providers. To try consuming ETW events from EtwTi, run the commands in [Listing
    12-13](#list12-13) from an elevated command prompt.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](chapter8.xhtml)中，你学习了EDR如何从其他ETW提供者获取事件。要尝试从EtwTi获取ETW事件，请在提升的命令提示符中运行[清单12-13](#list12-13)中的命令。
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 12-13: Logman commands to collect events from the EtwTi provider'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-13：从EtwTi提供者收集事件的Logman命令
- en: You’ll probably receive an access denied error, despite having run the commands
    in high integrity. This is due to a security feature implemented by Microsoft
    in Windows 10 and later versions called *Secure ETW*, which prevents malware processes
    from reading or tampering with antimalware traces. To accomplish this, Windows
    allows only processes with the <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_PROTECTED_ANTIMALWARE_LIGHT</samp>
    protection level and services started with the <samp class="SANS_TheSansMonoCd_W5Regular_11">SERVICE_LAUNCH_PROTECTED_ANTIMALWARE_LIGHT</samp>
    service protection type to consume events from the channel.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你已在高完整性下运行命令，但你可能会收到访问被拒绝的错误。这是因为微软在Windows 10及更高版本中实施的一个安全功能，名为*Secure ETW*，它防止恶意软件进程读取或篡改反恶意软件跟踪。为实现这一点，Windows只允许具有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PS_PROTECTED_ANTIMALWARE_LIGHT</samp>保护级别的进程和以<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SERVICE_LAUNCH_PROTECTED_ANTIMALWARE_LIGHT</samp>服务保护类型启动的服务从该通道消费事件。
- en: Let’s explore process protection so that you can better understand how consuming
    events from EtwTi works.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索进程保护，以便你更好地理解如何从EtwTi消费事件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding Protected
    Processes</samp>
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">理解受保护的进程</samp>
- en: Process protections allow sensitive processes, such as those that interact with
    DRM-protected content, to evade interaction by outside processes. While originally
    created for software such as media players, the introduction of Protected Process
    Light (PPL) eventually extended this protection to other types of applications.
    In modern versions of Windows, you’ll find PPL used heavily by not only Windows
    components but also third-party applications, as seen in the Process Explorer
    window in [Figure 12-6](#fig12-6).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 进程保护允许敏感进程（例如与 DRM 保护内容交互的进程）避免外部进程的交互。虽然最初为媒体播放器等软件创建，但随着受保护进程轻量化（PPL）的引入，此保护最终扩展到其他类型的应用程序。在现代版本的
    Windows 中，不仅 Windows 组件，而且第三方应用程序广泛使用 PPL，正如在 [图 12-6](#fig12-6) 中的进程资源管理器窗口中所见。
- en: '![](../images/Figure12-6.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-6: Protection levels
    across various processes</samp>'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-6：各个进程的保护级别</samp>
- en: You can view a process’s protection state in the protection field of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp> structure that backs every
    process on Windows. This field is of the type <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_PROTECTION</samp>,
    which is defined in [Listing 12-14](#list12-14).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Windows 上备份每个进程的 <samp class="SANS_TheSansMonoCd_W5Regular_11">EPROCESS</samp>
    结构的保护字段中查看进程的保护状态。该字段是 <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_PROTECTION</samp>
    类型的，它在 [列表 12-14](#list12-14) 中定义。
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 12-14: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PS_PROTECTION</samp>
    structure definition'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-14： <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PS_PROTECTION</samp>
    结构定义
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> member of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">PS_PROTECTION</samp> correlates to a value
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_PROTECTED_TYPE</samp>
    enumeration, defined in [Listing 12-15](#list12-15).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Type</samp> 成员与 [列表 12-15](#list12-15)
    中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_PROTECTED_TYPE</samp> 枚举中的一个值相关联。
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 12-15: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PS_PROTECTED_TYPE</samp>
    enumeration'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-15： <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PS_PROTECTED_TYPE</samp>
    枚举
- en: Lastly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Signer</samp> member
    is a value from the <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_PROTECTED_SIGNER</samp>
    enumeration, defined in [Listing 12-16](#list12-16).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，<samp class="SANS_TheSansMonoCd_W5Regular_11">Signer</samp> 成员是来自 [列表 12-16](#list12-16)
    中定义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">PS_PROTECTED_SIGNER</samp>
    枚举的一个值。
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 12-16: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PS_PROTECTED_SIGNER</samp>
    enumeration'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-16： <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PS_PROTECTED_SIGNER</samp>
    枚举
- en: As an example, let’s take a look at the process protection state of *msmpeng.exe*,
    Microsoft Defender’s primary process, using WinDbg, as demonstrated in [Listing
    12-17](#list12-17).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们来看一下 *msmpeng.exe*，即 Microsoft Defender 的主要进程的进程保护状态，使用 WinDbg，如 [列表 12-17](#list12-17)
    中演示的。
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 12-17: Evaluating msmpeng.exe’s process protection level'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-17：评估 msmpeng.exe 进程的进程保护级别
- en: The process’s protection type is <samp class="SANS_TheSansMonoCd_W5Regular_11">PsProtectedTypeProtectedLight</samp>
    ❶ and its signer is <samp class="SANS_TheSansMonoCd_W5Regular_11">PsProtectedSignerAntimalware</samp>
    (a value equivalent to 3 in decimal) ❷. With this protection level, also referred
    to as <samp class="SANS_TheSansMonoCd_W5Regular_11">PsProtectedSignerAntimalware-Light</samp>,
    outside processes have limited ability to request access to the process, and the
    memory manager will prevent improperly signed modules (such as DLLs and application
    compatibility databases) from being loaded into the process.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的保护类型是 <samp class="SANS_TheSansMonoCd_W5Regular_11">PsProtectedTypeProtectedLight</samp>
    ❶，其签名者是 <samp class="SANS_TheSansMonoCd_W5Regular_11">PsProtectedSignerAntimalware</samp>（相当于十进制中的
    3） ❷。在这种保护级别下，也被称为 <samp class="SANS_TheSansMonoCd_W5Regular_11">PsProtectedSignerAntimalware-Light</samp>，外部进程有限的能力请求访问该进程，并且内存管理器将阻止未正确签名的模块（如
    DLL 和应用程序兼容性数据库）加载到该进程中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Protected
    Process</samp>
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建受保护的进程</samp>
- en: Creating a process to run with this protection level is not as simple as passing
    flags into <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateProcess()</samp>,
    however. Windows validates the image file’s digital signature against a Microsoft-owned
    root certificate authority used to sign many pieces of software, from drivers
    to third-party applications.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个运行在此保护级别下的进程，实际上并不像将标志传递给<samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateProcess()</samp>那样简单。Windows会将映像文件的数字签名与用于签名许多软件的微软根证书授权进行验证，从驱动程序到第三方应用程序。
- en: It also validates the file by checking for one of several Enhanced Key Usage
    (EKU) extensions to determine the process’s granted signing level. If this granted
    signing level doesn’t dominate the requested signing level, meaning that the signer
    belongs to the <samp class="SANS_TheSansMonoCd_W5Regular_11">DominateMask</samp>
    member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">RTL_PROTECTED_ACCESS</samp>
    structure, Windows checks whether the signing level is runtime customizable. If
    so, it checks whether the signing level matches any of the registered runtime
    signers on the system, and if a match is found, it authenticates the certificate
    chain with the runtime signer’s registration data, such as the hash of the signer
    and EKUs. If all checks pass, Windows grants the requested signature level.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 它还通过检查多个增强密钥使用（EKU）扩展中的一个，来验证文件并确定进程的签名级别。如果该签名级别未能主导请求的签名级别，意味着签名者属于<samp class="SANS_TheSansMonoCd_W5Regular_11">DominateMask</samp>成员的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">RTL_PROTECTED_ACCESS</samp>结构，Windows会检查该签名级别是否可以在运行时进行自定义。如果可以，Windows将检查签名级别是否与系统上任何已注册的运行时签名者匹配，如果找到匹配项，它将使用运行时签名者的注册数据（如签名者的哈希值和EKU）来验证证书链。如果所有检查都通过，Windows将授予请求的签名级别。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Registering an ELAM Driver</samp>
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">注册ELAM驱动程序</samp>
- en: To create a process or service with the required protection level, a developer
    needs a signed ELAM driver. This driver must have an embedded resource, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">MICROSOFTELAMCERTIFICATEINFO</samp>, that
    contains the certificate hash and hashing algorithm used for the executables associated
    with the user-mode process or service to be protected, along with up to three
    EKU extensions. The operating system will parse or register this information at
    boot via an internal call to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!SeRegisterElamCertResources()</samp>
    (or an administrator can do so manually at runtime). If registration happens during
    the boot process, it occurs during pre-boot, before control is handed to the Windows
    Boot Manager, as shown in the WinDbg output in [Listing 12-18](#list12-18).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建具有所需保护级别的进程或服务，开发人员需要一个签名的ELAM驱动程序。该驱动程序必须具有一个嵌入式资源，<samp class="SANS_TheSansMonoCd_W5Regular_11">MICROSOFTELAMCERTIFICATEINFO</samp>，其中包含用于保护用户模式进程或服务相关可执行文件的证书哈希值和哈希算法，并且最多可以包含三个EKU扩展。操作系统将在启动时通过对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nt!SeRegisterElamCertResources()</samp>的内部调用解析或注册此信息（或者管理员可以在运行时手动执行此操作）。如果注册发生在启动过程中，它将在预启动期间进行，即在将控制权交给Windows启动管理器之前，如[列表
    12-18](#list12-18)中的WinDbg输出所示。
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 12-18: ELAM resources registered during the boot process'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-18：启动过程中注册的ELAM资源
- en: You’ll rarely see the manual registration option implemented in enterprise products,
    as resources parsed at boot require no further interaction at runtime. Still,
    both options net the same result and can be used interchangeably.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你很少会在企业产品中看到手动注册选项的实现，因为在启动时解析的资源在运行时不需要进一步交互。不过，这两种选项的结果相同，并且可以互换使用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Creating a Signature</samp>
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">创建签名</samp>
- en: After registration, the driver becomes available for comparison when a signing-level
    match is found. The rest of this section covers the implementation of the consumer
    application in the context of an endpoint agent.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注册后，当找到签名级别匹配时，该驱动程序将可用于比较。本节的其余部分将介绍在端点代理上下文中实施消费者应用程序的实现。
- en: To create the resource and register it with the system, the developer first
    obtains a certificate that includes the Early Launch and Code Signing EKUs, either
    from the certificate authority or generated as a self-signed certificate for test
    environments. We can create a self-signed certificate using the *New-SelfSignedCertificate*
    PowerShell cmdlet, as shown in [Listing 12-19](#list12-19).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建资源并将其注册到系统中，开发者首先需要获得一个包含 Early Launch 和 Code Signing EKU 的证书，可以通过证书颁发机构获取，或者在测试环境中生成一个自签名证书。我们可以使用*New-SelfSignedCertificate*
    PowerShell cmdlet 创建自签名证书，如 [列表 12-19](#list12-19) 所示。
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 12-19: Generating and exporting a code-signing certificate'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-19：生成并导出代码签名证书
- en: This command generates a new self-signed certificate, adds both the Early Launch
    and Code Signing EKUs, then exports it in *.pfx* format.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令生成一个新的自签名证书，添加 Early Launch 和 Code Signing EKU，然后将其导出为 *.pfx* 格式。
- en: Next, the developer signs their executable and any dependent DLLs using this
    certificate. You can do this using the *signtool.exe* syntax included in [Listing
    12-20](#list12-20).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，开发者使用此证书对其可执行文件及任何依赖的 DLL 进行签名。你可以使用 [列表 12-20](#list12-20) 中包含的 *signtool.exe*
    语法来执行此操作。
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 12-20: Signing an executable using the generated certificate'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-20：使用生成的证书对可执行文件进行签名
- en: At this point, the service executable meets the signing requirements to be launched
    as protected. But before it can be started, the driver’s resource must be created
    and registered.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，服务可执行文件已满足作为保护启动的签名要求。但在启动之前，驱动程序的资源必须被创建并注册。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Creating the Resource</samp>
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">创建资源</samp>
- en: 'The first piece of information needed to create the resource is the To-Be-Signed
    (TBS) hash for the certificate. The second piece of information is the certificate’s
    file-digest algorithm. As of this writing, this field can be one of the following
    four values: 0x8004 (SHA10), x800C (SHA256), 0x800D (SHA384), or 0x800E (SHA512).
    We specified this algorithm in the <samp class="SANS_TheSansMonoCd_W5Regular_11">/fd</samp>
    parameter when we created the certificate with *signtool.exe*.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 创建资源所需的第一条信息是证书的待签名（TBS）哈希值。第二条信息是证书的文件摘要算法。截止本文写作时，这个字段可以是以下四个值中的一个：0x8004（SHA10）、x800C（SHA256）、0x800D（SHA384）或
    0x800E（SHA512）。我们在使用*signtool.exe*创建证书时，通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">/fd</samp>
    参数指定了这个算法。
- en: We can collect both of these values by using *certmgr.exe* with the <samp class="SANS_TheSansMonoCd_W5Regular_11">-v</samp>
    argument, as shown in [Listing 12-21](#list12-21).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用*certmgr.exe*并带上 <samp class="SANS_TheSansMonoCd_W5Regular_11">-v</samp>
    参数来收集这两个值，如 [列表 12-21](#list12-21) 所示。
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 12-21: Retrieving the To Be Signed hash and signature algorithm using
    certmgr.exe'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-21：使用 certmgr.exe 检索待签名哈希值和签名算法
- en: The hash is located under <samp class="SANS_TheSansMonoCd_W5Regular_11">Content
    Hash</samp> and the signature algorithm under <samp class="SANS_TheSansMonoCd_W5Regular_11">Content
    SignatureAlgorithm</samp>.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希值位于 <samp class="SANS_TheSansMonoCd_W5Regular_11">Content Hash</samp> 下，签名算法位于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Content SignatureAlgorithm</samp>
    下。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Adding a New Resource File</samp>
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">添加新资源文件</samp>
- en: Now we can add a new resource file to the driver project with the contents shown
    in [Listing 12-22](#list12-22) and compile the driver.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以向驱动程序项目中添加一个新的资源文件，内容如 [列表 12-22](#list12-22) 所示，并编译驱动程序。
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 12-22: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">MicrosoftElamCertificateInfo</samp>
    resource contents'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-22：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">MicrosoftElamCertificateInfo</samp>
    资源内容
- en: The first value of this resource is the number of entries; in our case, there
    is only one entry, but there may be up to three. Next is the TBS hash that we
    collected earlier, followed by the hexadecimal value corresponding to the hashing
    algorithm used (SHA256 in our case).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此资源的第一个值是条目数；在我们的案例中，只有一个条目，但最多可以有三个。接下来是我们之前收集的 TBS 哈希值，后面是与使用的哈希算法（在我们的例子中是
    SHA256）对应的十六进制值。
- en: Finally, there is a field in which we can specify additional EKUs. Developers
    use these to uniquely identify antimalware components signed by the same certificate
    authority. For example, if there are two services with the same signer on the
    host, but only one needs to be launched with the <samp class="SANS_TheSansMonoCd_W5Regular_11">SERVICE_LAUNCH_PROTECTED_ANTIMALWARE_LIGHT</samp>
    flag, the developer could add a unique EKU when signing that service and add it
    to the ELAM driver’s resource. The system will then evaluate this additional EKU
    when starting the service with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Anti-Malware</samp>
    protection level. Since we’re not providing any additional EKUs in our resource,
    we pass what equates to an empty string.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个字段，我们可以在其中指定额外的EKU（扩展密钥用法）。开发者使用这些来唯一标识由相同证书颁发机构签名的反恶意软件组件。例如，如果主机上有两个服务具有相同的签名者，但只有一个需要使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SERVICE_LAUNCH_PROTECTED_ANTIMALWARE_LIGHT</samp>标志启动，则开发者可以在签名该服务时添加唯一的EKU，并将其添加到ELAM驱动程序的资源中。系统随后将在以<samp
    class="SANS_TheSansMonoCd_W5Regular_11">反恶意软件</samp>保护级别启动服务时评估此额外的EKU。由于我们没有在资源中提供任何额外的EKU，我们传递的相当于一个空字符串。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Signing the Resource</samp>
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">签名资源</samp>
- en: We then sign the driver using the same syntax we used to sign the service executable
    ([Listing 12-23](#list12-23)).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用与签名服务可执行文件相同的语法来签名驱动程序（[清单12-23](#list12-23)）。
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 12-23: Signing the driver with our certificate'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-23：使用我们的证书签名驱动程序
- en: Now the resource will be included in the driver and is ready to be installed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，资源将被包含在驱动程序中，并准备好安装。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Installing the Driver</samp>
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">安装驱动程序</samp>
- en: If the developer wants the operating system to handle loading the certificate
    information, they simply create the kernel service as described in “Registering
    an ELAM Driver” on [page 229](#sec11). If they would like to install the ELAM
    certificate at runtime, they can use a registration function in their agent, such
    as the one shown in [Listing 12-24](#list12-24).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者希望操作系统处理加载证书信息，他们只需按照[第229页](#sec11)“注册ELAM驱动程序”中描述的方法创建内核服务。如果他们希望在运行时安装ELAM证书，他们可以在代理中使用注册功能，例如在[清单12-24](#list12-24)中显示的函数。
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 12-24: Installing the certificate on the system'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-24：在系统上安装证书
- en: This code first opens a handle to the ELAM driver containing the <samp class="SANS_TheSansMonoCd_W5Regular_11">MicrosoftElamCertificateInfo</samp>
    resource. The handle is then passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel
    32!InstallELAMCertificateInfo()</samp> to install the certificate on the system.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先打开一个到包含<samp class="SANS_TheSansMonoCd_W5Regular_11">MicrosoftElamCertificateInfo</samp>资源的ELAM驱动程序的句柄。然后将该句柄传递给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">kernel 32!InstallELAMCertificateInfo()</samp>以将证书安装到系统中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Starting the Service</samp>
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">启动服务</samp>
- en: All that is left at this point is to create and start the service with the required
    protection level. This can be done in any number of ways, but it is most frequently
    done programmatically using the Win32 API. [Listing 12-25](#list12-25) shows an
    example function for doing so.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，只剩下创建并启动具有所需保护级别的服务。可以通过多种方式完成此操作，但最常见的方式是通过Win32 API编程完成。[清单12-25](#list12-25)显示了一个示例函数。
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 12-25: Creating the consumer service'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-25：创建消费者服务
- en: First, we open a handle to the Service Control Manager ❶, the operating system
    component responsible for overseeing all services on the host. Next, we create
    the base service via a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateServiceW()</samp>
    ❷. This function accepts information, such as the service name, its display name,
    and the path to the service binary, and returns a handle to the newly created
    service when it completes. We then call <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!ChangeServiceConfig2W()</samp>
    to set the new service’s protection level ❸.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们打开一个到服务控制管理器的句柄❶，这是负责监控主机上所有服务的操作系统组件。接下来，我们通过调用<samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!CreateServiceW()</samp>
    ❷来创建基础服务。此函数接受服务名称、显示名称和服务二进制文件路径等信息，并在完成时返回指向新创建服务的句柄。然后，我们调用<samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!ChangeServiceConfig2W()</samp>来设置新服务的保护级别❸。
- en: When this function completes successfully, Windows will start the protected
    consumer service, shown running in the Process Explorer window in [Figure 12-7](#fig12-7).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当此函数成功完成时，Windows 将启动受保护的消费者服务，并在[图 12-7](#fig12-7)的进程资源管理器窗口中显示运行状态。
- en: '![](../images/Figure12-7.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure12-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-7: EtwTi consumer
    service running with the required protection level</samp>'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-7：具有所需保护级别的 EtwTi 消费者服务正在运行</samp>
- en: Now it can begin working with events from the EtwTi provider.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它可以开始与来自 EtwTi 提供者的事件一起工作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Processing Events</samp>
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">处理事件</samp>
- en: You can write a consumer for the EtwTi provider in virtually the same way as
    you would for a normal ETW consumer, a process discussed in [Chapter 8](chapter8.xhtml).
    Once you’ve completed the protection and signing steps described in the previous
    section, the code for receiving, processing, and extracting data from events is
    the same as for any other provider.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以几乎相同的方式为 EtwTi 提供者编写消费者，就像为普通的 ETW 消费者编写消费者一样，这一过程在[第 8 章](chapter8.xhtml)中讨论过。一旦你完成了前一节描述的保护和签名步骤，接收、处理和提取事件数据的代码与其他提供者相同。
- en: However, because the EtwTi consumer service is protected, you might find it
    difficult to work with events during development, such as by reading *printf*-style
    output. Thankfully, the provider’s manifest can provide you with event formats,
    IDs, and keywords, which can make working with the events much easier.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于 EtwTi 消费者服务是受保护的，你可能会发现很难在开发过程中与事件一起工作，例如通过读取 *printf* 样式的输出。幸运的是，提供者的清单可以为你提供事件格式、ID
    和关键字，这将使处理事件变得更加容易。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evading EtwTi</samp>
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">规避 EtwTi</samp>
- en: Because they live in the kernel, EtwTi sensors provide EDRs with a robust telemetry
    source that is hard to tamper with. There are, however, a few ways that attackers
    may either neutralize the sensors’ capabilities or at least coexist with them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 EtwTi 传感器位于内核中，它们为 EDR 提供了一个强大的遥测源，且难以篡改。然而，攻击者仍有一些方法可以使传感器的功能失效，或者至少与它们共存。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Coexistence</samp>
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">共存</samp>
- en: The simplest evasion approach involves using Neo4j to return all syscalls that
    hit EtwTi sensors, then refraining from calling these functions in your operations.
    This means you’ll have to find alternative ways to perform tasks such as memory
    allocation, which can be daunting.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的规避方法是使用 Neo4j 返回所有触发 EtwTi 传感器的系统调用，然后避免在操作中调用这些函数。这意味着你需要找到其他方法来执行内存分配等任务，这可能会很有挑战性。
- en: 'For example, Cobalt Strike’s Beacon supports three memory allocation methods:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">MapViewOfFile</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>. Those last
    two methods both call a syscall that EtwTi sensors monitor. The first method,
    on the other hand, calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!RtlAllocateHeap()</samp>,
    which has no direct outgoing references to EtwTi functions, making it the safest
    bet. The downside is that it doesn’t support allocations in remote processes,
    so you can’t perform process injection with it.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Cobalt Strike 的 Beacon 支持三种内存分配方法：<samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MapViewOfFile</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>。后两种方法都调用一个系统调用（syscall），该调用被
    EtwTi 传感器监控。而第一种方法则调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!RtlAllocateHeap()</samp>，它没有直接指向
    EtwTi 函数的外部引用，因此被认为是最安全的选择。缺点是它不支持在远程进程中进行分配，因此无法使用该方法执行进程注入。
- en: As with all telemetry sources in this book, remember that some other source
    might be covering the gaps in the EtwTi sensors. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapAlloc</samp>
    as an example, endpoint security agents may track and scan executable heap allocations
    created by user-mode programs. Microsoft may also modify APIs to call the existing
    sensors or add entirely new sensors at any time. This requires that teams remap
    the relationships from syscalls to EtwTi sensors on each new build of Windows,
    which can be time consuming.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本书中所有遥测源一样，请记住，一些其他源可能正在处理 EtwTi 传感器的间隙。例如，安全终端代理可以跟踪和扫描由用户模式程序创建的可执行堆分配。微软也可能随时修改
    API 来调用现有的传感器或添加全新的传感器。这要求团队在每个新的 Windows 构建中重新映射从系统调用到 EtwTi 传感器的关系，这可能会耗费一些时间。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Trace-Handle Overwriting</samp>
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Trace-Handle Overwriting</samp>
- en: 'Another option is to simply invalidate the global trace handle in the kernel.
    Upayan Saha’s “Data Only Attack: Neutralizing EtwTi Provider” blog post covers
    this technique in great detail. It requires the operator to have an arbitrary
    read-write primitive in a vulnerable driver, such as those present in previous
    versions of Gigabyte’s *atillk64.sys* and LG Device Manager’s *lha.sys*, two signed
    drivers published by the PC hardware and peripheral manufacturers for legitimate
    device-support purposes.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是简单地使内核中的全局跟踪句柄无效化。Upayan Saha 的“仅数据攻击：中和 EtwTi 提供程序”博客文章详细介绍了这种技术。操作者需要在一个易受攻击的驱动程序中具有任意读写原语，例如前几个版本的技嘉
    *atillk64.sys* 和 LG 设备管理器 *lha.sys* 中的已签名驱动程序，这两个驱动程序是由 PC 硬件和外围设备制造商发布用于合法设备支持目的。
- en: The primary challenge of this technique is locating the <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_ENABLE_INFO</samp>
    structure, which defines the information used to enable the provider. Inside this
    structure is a member, <samp class="SANS_TheSansMonoCd_W5Regular_11">IsEnabled</samp>,
    that we must manually change to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    to prevent events from reaching the security product. We can use some of what
    we’ve already learned about how events are published to help make this process
    easier.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的主要挑战是定位定义用于启用提供程序的 <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_ENABLE_INFO</samp>
    结构。在这个结构内部有一个成员 <samp class="SANS_TheSansMonoCd_W5Regular_11">IsEnabled</samp>，我们必须手动将其更改为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> 以防止事件传达到安全产品。我们可以利用已经学到的有关事件发布方式的部分知识来帮助简化这个过程。
- en: Recall from the previous sections that all sensors use the global <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwThreatIntProvRegHandle
    REGHANDLE</samp> when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwWrite()</samp>
    to emit an event. This handle is actually a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW_REG_ENTRY</samp>
    structure, which itself contains a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW_GUID_ENTRY</samp>
    structure in its <samp class="SANS_TheSansMonoCd_W5Regular_11">GuidEntry</samp>
    member (offset 0x20), as shown in [Listing 12-26](#list12-26).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的部分回顾，所有传感器在调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwWrite()</samp>
    发出事件时使用全局 <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwThreatIntProvRegHandle
    REGHANDLE</samp>。该句柄实际上是指向一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW_REG_ENTRY</samp>
    结构的指针，该结构本身在其 <samp class="SANS_TheSansMonoCd_W5Regular_11">GuidEntry</samp> 成员（偏移量
    0x20）中包含一个指向 <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW_GUID_ENTRY</samp>
    结构的指针，如 [Listing 12-26](#list12-26) 中所示。
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 12-26: Getting the address of the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ETW_GUID_ENTRY</samp>
    structure'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 12-26: 获取 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ETW_GUID_ENTRY</samp>
    结构的地址'
- en: This structure is the kernel’s record of an event provider and contains an array
    of eight <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_ENABLE_INFO</samp>
    structures in its <samp class="SANS_TheSansMonoCd_W5Regular_11">EnableInfo</samp>
    member (offset 0x80). Only the first entry, the contents of which are included
    in [Listing 12-27](#list12-27), is used by default.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构是内核的事件提供者记录，包含一个由八个 <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_ENABLE_INFO</samp>
    结构组成的数组，位于其 <samp class="SANS_TheSansMonoCd_W5Regular_11">EnableInfo</samp> 成员（偏移量
    0x80）。默认情况下只使用第一个条目，其内容包含在 [Listing 12-27](#list12-27) 中。
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 12-27: Extracting the contents of the first <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">TRACE_ENABLE_INFO</samp>
    structure'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 12-27: 提取第一个 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">TRACE_ENABLE_INFO</samp>
    结构的内容'
- en: This member is an unsigned long (really a Boolean, per Microsoft’s documentation)
    that indicates whether the provider is enabled for the trace session ❶.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 该成员是一个无符号长整型（根据微软文档，它实际上是一个布尔值），表示提供程序是否为跟踪会话启用 ❶。
- en: 'If an attacker can flip this value to 0, they can disable the Microsoft-Windows-Threat-Intelligence
    provider, preventing the consumer from receiving events. Working back through
    these nested structures, we can find our target using the following steps:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者可以将该值修改为0，他们可以禁用 Microsoft-Windows-Threat-Intelligence 提供程序，从而阻止消费者接收事件。通过逆向这些嵌套结构，我们可以使用以下步骤找到目标：
- en: Finding the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW_REG_ENTRY</samp>
    pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwThreatIntRegHandle</samp>
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到由 <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwThreatIntRegHandle</samp>
    指向的 <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW_REG_ENTRY</samp> 的地址
- en: Finding the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW_GUID_ENTRY</samp>
    pointed to by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW_REG_ENTRY</samp>
    structure’s <samp class="SANS_TheSansMonoCd_W5Regular_11">GuidEntry</samp> member
    (offset 0x20)
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到 <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW_GUID_ENTRY</samp> 的地址，该地址由
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ETW_REG_ENTRY</samp> 结构的 <samp class="SANS_TheSansMonoCd_W5Regular_11">GuidEntry</samp>
    成员（偏移量 0x20）指向
- en: Adding 0x80 to the address to get the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsEnabled</samp>
    member of the first <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_ENABLE_INFO</samp>
    structure in the array
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向地址中添加 0x80 以获取数组中第一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">TRACE_ENABLE_INFO</samp>
    结构的 <samp class="SANS_TheSansMonoCd_W5Regular_11">IsEnabled</samp> 成员
- en: Finding the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwThreatIntProvRegHandle</samp>
    is the most challenging part of this technique, as it requires using the arbitrary
    read in the vulnerable driver to search for a pattern of opcodes that work with
    the pointer to the structure.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 查找 <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwThreatIntProvRegHandle</samp>
    的地址是此技术中最具挑战性的部分，因为它需要使用易受攻击驱动程序中的任意读取来搜索与结构指针配合使用的操作码模式。
- en: According to his blog post, Saha used <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!KeInsertQueueApc()</samp>
    as the starting point of the search, as this function is exported by *ntoskrnl.exe*
    and references the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp>
    in an early call to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwProviderEnabled</samp>.
    Per the Windows calling convention, the first parameter passed to a function is
    stored in the RCX register. Therefore, this address will be placed into the register
    prior to the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwProviderEnabled</samp>
    using a <samp class="SANS_TheSansMonoCd_W5Regular_11">MOV</samp> instruction.
    By searching for the opcodes <samp class="SANS_TheSansMonoCd_W5Regular_11">48
    8b 0d</samp> corresponding to <samp class="SANS_TheSansMonoCd_W5Regular_11">mov
    rcx,qword ptr [x]</samp> from the function entry point until the call to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwProviderEnabled</samp>, we can identify
    the virtual address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp>.
    Then, using the offsets identified earlier, we can set its <samp class="SANS_TheSansMonoCd_W5Regular_11">IsEnabled</samp>
    member to 0.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 根据他在博客中的文章，Saha 使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!KeInsertQueueApc()</samp>
    作为搜索的起始点，因为此函数由 *ntoskrnl.exe* 导出，并在早期调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwProviderEnabled</samp>
    时引用 <samp class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp> 的地址。根据 Windows
    的调用约定，第一个传递给函数的参数存储在 RCX 寄存器中。因此，在调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwProviderEnabled</samp>
    之前，这个地址将通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">MOV</samp> 指令放入寄存器中。通过搜索与
    <samp class="SANS_TheSansMonoCd_W5Regular_11">mov rcx,qword ptr [x]</samp> 对应的操作码
    <samp class="SANS_TheSansMonoCd_W5Regular_11">48 8b 0d</samp>，从函数入口点到调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwProviderEnabled</samp>，我们可以识别出 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp> 的虚拟地址。然后，使用之前识别的偏移量，我们可以将其
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IsEnabled</samp> 成员设置为0。
- en: Another method of locating <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwThreatIntProvRegHandle</samp>
    is to use its offset from the base address of the kernel. Due to kernel address
    space layout randomization (KASLR), we can’t know its full virtual address, but
    its offset has proven to be stable across reboots. For example, on one build of
    Windows, this offset is <samp class="SANS_TheSansMonoCd_W5Regular_11">0xC197D0</samp>,
    as shown in [Listing 12-28](#list12-28).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种定位<samp class="SANS_TheSansMonoCd_W5Regular_11">EtwThreatIntProvRegHandle</samp>的方法是使用其相对于内核基地址的偏移量。由于内核地址空间布局随机化（KASLR），我们无法知道其完整的虚拟地址，但其偏移量在重启后证明是稳定的。例如，在某个版本的Windows中，该偏移量为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0xC197D0</samp>，如[列表 12-28](#list12-28)所示。
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 12-28: Finding the offset to the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">REGHANDLE</samp>'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-28：查找<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">REGHANDLE</samp>的偏移量
- en: The last line in this listing subtracts the base address of the kernel from
    the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp>.
    We can retrieve this base address from user mode by running <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQuerySystemInformation()</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemModuleInformation</samp>
    information class, demonstrated in [Listing 12-29](#list12-29).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本列表的最后一行将内核的基地址与<samp class="SANS_TheSansMonoCd_W5Regular_11">REGHANDLE</samp>的地址相减。我们可以通过以用户模式运行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQuerySystemInformation()</samp>并使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SystemModuleInformation</samp>信息类来检索此基地址，具体示例见[列表
    12-29](#list12-29)。
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 12-29: Getting the base address of the kernel'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-29：获取内核的基地址
- en: This function first gets a function pointer to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQuerySystemInformation()</samp>
    ❶ and then invokes it, passing in the <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemModuleInformation</samp>
    information class ❷. Upon completion, this function will populate the <samp class="SANS_TheSansMonoCd_W5Regular_11">RTL_PROCESS_MODULES</samp>
    structure (named <samp class="SANS_TheSansMonoCd_W5Regular_11">ModuleInfo</samp>),
    at which point the address of the kernel can be retrieved by referencing the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ImageBase</samp> attribute of the first
    entry in the array ❸.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先获取指向<samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQuerySystemInformation()</samp>
    ❶的函数指针，然后调用它，传入<samp class="SANS_TheSansMonoCd_W5Regular_11">SystemModuleInformation</samp>信息类
    ❷。完成后，该函数将填充<samp class="SANS_TheSansMonoCd_W5Regular_11">RTL_PROCESS_MODULES</samp>结构体（命名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ModuleInfo</samp>），此时可以通过引用数组中第一个条目的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ImageBase</samp>属性来获取内核地址 ❸。
- en: You’ll still require a driver with a write-what-where primitive to patch the
    value, but using this approach avoids us having to parse memory for opcodes. This
    technique also introduces the problem of tracking offsets to <samp class="SANS_TheSansMonoCd_W5Regular_11">EtwThreatIntProvRegHandle</samp>
    across all kernel versions on which they operate, however, so it isn’t without
    its own challenges.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然需要一个具有写入任意位置功能的驱动程序来修补该值，但使用这种方法可以避免我们需要解析内存中的操作码。尽管如此，这种技术也引入了跟踪<samp class="SANS_TheSansMonoCd_W5Regular_11">EtwThreatIntProvRegHandle</samp>在所有操作的内核版本中的偏移量的问题，因此它也不是没有挑战的。
- en: Additionally, those who employ this technique must also consider the telemetry
    it generates. For instance, loading a vulnerable driver is harder on Windows 11,
    as Hypervisor-Protected Code Integrity is enabled by default, which can block
    drivers known to contain vulnerabilities. At the detection level, loading a new
    driver will trigger the <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogDriverObjectLoad()</samp>
    sensor, which may be atypical for the system or environment, causing a response.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，采用此技术的人还必须考虑它生成的遥测。例如，在Windows 11上加载一个有漏洞的驱动程序更为困难，因为默认启用了受Hypervisor保护的代码完整性，这可以阻止已知含有漏洞的驱动程序。在检测层面，加载新驱动程序将触发<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nt!EtwTiLogDriverObjectLoad()</samp>传感器，这在系统或环境中可能是不典型的，从而引发响应。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp>
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">结论</samp>
- en: The Microsoft-Windows-Threat-Intelligence ETW provider is one of the most important
    data sources available to an EDR at the time of this writing. It provides unparalleled
    visibility into processes executing on the system by sitting inline of their execution,
    similar to function-hooking DLLs. Despite their likeness, however, this provider
    and its hooks live in the kernel, where they are far less susceptible to evasion
    through direct attacks. Evading this data source is more about learning to work
    around it than it is about finding the glaring gap or logical flaw in its implementation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft-Windows-Threat-Intelligence ETW 提供程序是当前 EDR 最重要的数据源之一。它通过在进程执行过程中插入
    inline 的方式，提供对系统上执行进程的无与伦比的可视性，类似于函数钩子 DLL。尽管它们有相似之处，但这个提供程序及其钩子位于内核中，在那里它们更不容易通过直接攻击来规避。规避此数据源更多的是学会如何绕过它，而不是找到其实现中的明显漏洞或逻辑缺陷。
