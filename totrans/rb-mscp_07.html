<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;The Hash Table: The Workhorse of Ruby Internals"><div class="titlepage"><div><div><h1 class="title"><a id="hash_table_the_workhorse_of_ruby_int"/>Chapter 7. The Hash Table: The Workhorse of Ruby Internals</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="informalfigure"><div class="mediaobject"><a id="med_id00161"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1853819.png.jpg"/></div></div><p><span class="emphasis"><em>Ruby stores much of its own internal data in hash tables.</em></span></p></blockquote></div><p><a class="xref" href="ch05.html#experiment_5-1_how_long_does_it_take_to" title="Experiment 5-1: How Long Does It Take to Save a New Instance Variable?">Experiment 5-1: How Long Does It Take to Save a New Instance Variable?</a> showed us how in Ruby 1.9 and 2.0 the <code class="literal">ivptr</code> member of the <code class="literal">RObject</code> structure pointed to a simple array of instance variable values. We learned that adding a new value was usually very fast but that Ruby was somewhat slower while saving every third or fourth instance variable because it had to allocate a larger array.</p><p>Taking a broader look across Ruby’s C source code base, we find that this technique is unusual. Instead, Ruby often uses a data structure called a <span class="emphasis"><em>hash table</em></span>. Unlike the simple array we saw in <a class="xref" href="ch05.html#experiment_5-1_how_long_does_it_take_to" title="Experiment 5-1: How Long Does It Take to Save a New Instance Variable?">Experiment 5-1: How Long Does It Take to Save a New Instance Variable?</a>, hash tables can automatically expand to accommodate more values; the client of a hash table doesn’t need to worry about how much space is available or about allocating more memory for it.</p><p>Among other things, Ruby uses a hash table to hold the data you save in the hash objects you create in your Ruby script. Ruby also saves much of its internal data in hash tables. Every time you create a method or a constant, Ruby inserts a new value in a hash table, and Ruby saves many of the special variables we saw in <a class="xref" href="ch03.html#experiment_3-2_exploring_special_variabl" title="Experiment 3-2: Exploring Special Variables">Experiment 3-2: Exploring Special Variables</a> in hash tables. Additionally, Ruby saves instance variables for generic objects, such as integers or symbols, in hash tables. Thus, the hash table is the workhorse of Ruby internals.</p><p>In this chapter I’ll begin by explaining how hash tables work: what happens inside the table when you save a new value with a key and what happens when you later retrieve that value using the same key. I’ll also explain how hash tables automatically expand to accommodate more values. Finally, we’ll look at how hash functions work in Ruby.</p><div class="sidebar"><a id="roadmap-id00024"/><p class="title">Roadmap</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch07.html#hash_tables_in_ruby" title="Hash Tables in Ruby">Hash Tables in Ruby</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch07.html#saving_a_value_in_a_hash_table" title="Saving a Value in a Hash Table">Saving a Value in a Hash Table</a></p></li><li class="listitem"><p><a class="xref" href="ch07.html#retrieving_a_value_from_a_hash_table" title="Retrieving a Value from a Hash Table">Retrieving a Value from a Hash Table</a></p></li></ul></div></li><li class="listitem"><p><span class="strong"><strong><a class="xref" href="ch07.html#experiment_7-1_retrieving_a_value_from_h" title="Experiment 7-1: Retrieving a Value from Hashes of Varying Sizes">Experiment 7-1: Retrieving a Value from Hashes of Varying Sizes</a></strong></span></p></li><li class="listitem"><p><a class="xref" href="ch07.html#how_hash_tables_expand_to_accommodate_mo" title="How Hash Tables Expand to Accommodate More Values">How Hash Tables Expand to Accommodate More Values</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch07.html#hash_collisions" title="Hash Collisions">Hash Collisions</a></p></li><li class="listitem"><p><a class="xref" href="ch07.html#rehashing_entries" title="Rehashing Entries">Rehashing Entries</a></p></li><li class="listitem"><p><a class="xref" href="ch07.html#how_does_ruby_rehash_entries_in_a_hash_t" title="How Does Ruby Rehash Entries in a Hash Table?">How Does Ruby Rehash Entries in a Hash Table?</a></p></li></ul></div></li><li class="listitem"><p><span class="strong"><strong><a class="xref" href="ch07.html#experiment_7-2_inserting_one_new_element" title="Experiment 7-2: Inserting One New Element into Hashes of Varying Sizes">Experiment 7-2: Inserting One New Element into Hashes of Varying Sizes</a></strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch07.html#where_do_the_magic_numbers_57_and_67_com" title="Where Do the Magic Numbers 57 and 67 Come From?">Where Do the Magic Numbers 57 and 67 Come From?</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch07.html#how_ruby_implements_hash_functions" title="How Ruby Implements Hash Functions">How Ruby Implements Hash Functions</a></p></li><li class="listitem"><p><span class="strong"><strong><a class="xref" href="ch07.html#experiment_7-3_using_objects_as_keys_in" title="Experiment 7-3: Using Objects as Keys in a Hash">Experiment 7-3: Using Objects as Keys in a Hash</a></strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch07.html#hash_optimization_in_ruby_2dot0" title="Hash Optimization in Ruby 2.0">Hash Optimization in Ruby 2.0</a></p></li></ul></div></li><li class="listitem"><p><a class="xref" href="ch07.html#summary-id00028" title="Summary">Summary</a></p></li></ul></div></div><div class="sect1" title="Hash Tables in Ruby"><div class="titlepage"><div><div><h1 class="title"><a id="hash_tables_in_ruby"/>Hash Tables in Ruby</h1></div></div></div><p><a class="indexterm" id="iddle1073"/><a class="indexterm" id="iddle1128"/><a class="indexterm" id="iddle1379"/><a class="indexterm" id="iddle1383"/><a class="indexterm" id="iddle1396"/><a class="indexterm" id="iddle1909"/><a class="indexterm" id="iddle1945"/><a class="indexterm" id="iddle1964"/><a class="indexterm" id="iddle2010"/><a class="indexterm" id="iddle2011"/><span class="emphasis"><em>Hash tables</em></span> are a commonly used, well-known, age-old concept in computer science. They organize values into groups, or <span class="emphasis"><em>bins</em></span>, based on an integer value calculated from each value—a <span class="emphasis"><em>hash</em></span>. When you need to find a value, you can figure out which bin it’s in by recalculating its hash value, thus speeding up the search.</p><div class="informalfigure"><a id="med_id00162a"/><div class="mediaobject"><a id="med_id00162"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1854143.png.jpg"/><div class="caption"><p><span class="emphasis"><em>Every time you write a method, Ruby creates an entry in a hash table.</em></span></p></div></div></div><div class="sect2" title="Saving a Value in a Hash Table"><div class="titlepage"><div><div><h2 class="title"><a id="saving_a_value_in_a_hash_table"/>Saving a Value in a Hash Table</h2></div></div></div><p><a class="xref" href="ch07.html#ruby_hash_object_with_an_empty_hash_ta" title="Figure 7-1. A Ruby hash object with an empty hash table">Figure 7-1</a> shows a single hash object and its hash table.</p><div class="figure"><a id="ruby_hash_object_with_an_empty_hash_ta"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00163"/><img alt="A Ruby hash object with an empty hash table" src="httpatomoreillycomsourcenostarchimages1854145.png.jpg"/></div></div><p class="title">Figure 7-1. A Ruby hash object with an empty hash table</p></div><p>On the left is the <code class="literal">RHash</code> (short for <span class="emphasis"><em>Ruby hash</em></span>) structure. On the right, you see the hash table used by this hash, represented by the <code class="literal">st_table</code> structure. This C structure contains the basic information about the hash table, including the number of entries saved in the table, the number of bins, and a pointer to the bins. Each <code class="literal">RHash</code> structure contains a pointer to a corresponding <code class="literal">st_table</code> structure. The empty bins on the lower right are there because Ruby 1.8 and 1.9 initially create 11 bins for a new, empty hash. (Ruby 2.0 works somewhat differently; see <a class="xref" href="ch07.html#hash_optimization_in_ruby_2dot0" title="Hash Optimization in Ruby 2.0">Hash Optimization in Ruby 2.0</a>.)</p><p>The best way to understand how a hash table works is by stepping through an example. Suppose I add a new key/value to a hash called <code class="literal">my_hash</code>:</p><a id="pro_id00039"/><pre class="programlisting">my_hash[:key] = "value"</pre><p>While executing this line of code, Ruby creates a new structure called an <code class="literal">st_table_entry</code> that it will save into the hash table for <code class="literal">my_hash</code>, as shown in <a class="xref" href="ch07.html#ruby_hash_object_containing_a_single_v" title="Figure 7-2. A Ruby hash object containing a single value">Figure 7-2</a>.</p><div class="figure"><a id="ruby_hash_object_containing_a_single_v"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00164"/><img alt="A Ruby hash object containing a single value" src="httpatomoreillycomsourcenostarchimages1854147.png.jpg"/></div></div><p class="title">Figure 7-2. A Ruby hash object containing a single value</p></div><p><a class="indexterm" id="iddle1386"/>Here you can see Ruby saved the new key/value pair under the third bucket, number 2. Ruby did this by taking the given key—in this example, the symbol <code class="literal">:key</code>—and passing it to an internal hash function that returns a pseudorandom integer:</p><a id="pro_id00040"/><pre class="programlisting">some_value = internal_hash_function(:key)</pre><p>Next, Ruby takes the hash value—in this example, <code class="literal">some_value</code>—and calculates the modulus by the number of bins, which is the remainder after dividing by the number of bins.</p><a id="pro_id00041"/><pre class="programlisting">some_value % 11 = 2</pre><div class="note" title="Note"><h3 class="title"><a id="ch07note01"/>Note</h3><p><span class="emphasis"><em>In <a class="xref" href="ch07.html#ruby_hash_object_containing_a_single_v" title="Figure 7-2. A Ruby hash object containing a single value">Figure 7-2</a>, I assume that the actual hash value for <code class="literal">:key</code> divided by 11 leaves a remainder of 2. Later in this chapter, I’ll explore in more detail the hash functions that Ruby actually uses.</em></span></p></div><p>Now let’s add a second element to the hash:</p><a id="pro_id00042"/><pre class="programlisting">my_hash[:key2] = "value2"</pre><p>This time let’s imagine that the hash value of <code class="literal">:key2</code> divided by 11 yields a remainder of 5.</p><a id="pro_id00043"/><pre class="programlisting">internal_hash_function(:key2) % 11 = 5</pre><p><a class="xref" href="ch07.html#ruby_hash_object_containing_two_values" title="Figure 7-3. A Ruby hash object containing two values">Figure 7-3</a> shows that Ruby places a second <code class="literal">st_table_entry</code> structure under bin number 5, the sixth bin.</p><div class="figure"><a id="ruby_hash_object_containing_two_values"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00165"/><img alt="A Ruby hash object containing two values" src="httpatomoreillycomsourcenostarchimages1854149.png.jpg"/></div></div><p class="title">Figure 7-3. A Ruby hash object containing two values</p></div></div><div class="sect2" title="Retrieving a Value from a Hash Table"><div class="titlepage"><div><div><h2 class="title"><a id="retrieving_a_value_from_a_hash_table"/>Retrieving a Value from a Hash Table</h2></div></div></div><p><a class="indexterm" id="iddle1394"/><a class="indexterm" id="iddle1906"/>The benefit of using a hash table becomes clear when you ask Ruby to retrieve the value for a given key. For example:</p><a id="pro_id00044"/><pre class="programlisting">p my_hash[:key]
 =&gt; "value"</pre><p>If Ruby had saved all of the keys and values in an array or linked list, it would have to iterate over all the elements in that array or list, looking for <code class="literal">:key</code>. This might take a very long time, depending on the number of elements. But using a hash table, Ruby can jump straight to the key it needs to find by recalculating the hash value for that key.</p><p>To recalculate the hash value for a particular key, Ruby simply calls the hash function again:</p><a id="pro_id00045"/><pre class="programlisting">some_value = internal_hash_function(:key)</pre><p>Then, it redivides the hash value by the number of bins to get the remainder, or the modulus.</p><a id="pro_id00046"/><pre class="programlisting">some_value % 11 = 2</pre><p><a class="indexterm" id="iddle1274"/><a class="indexterm" id="iddle1395"/><a class="indexterm" id="iddle1701"/>At this point, Ruby knows to look in bin number 2 for the entry with the key of <code class="literal">:key</code>. Ruby can later find the value for <code class="literal">:key2</code> by repeating the same hash calculation.</p><a id="pro_id00047"/><pre class="programlisting">internal_hash_function(:key2) % 11 = 5</pre><div class="note" title="Note"><h3 class="title"><a id="ch07note02"/>Note</h3><p><span class="emphasis"><em>The C library used by Ruby to implement hash tables was written in the 1980s by Peter Moore from the University of California, Berkeley. Later, it was modified by the Ruby core team. You can find Moore’s hash table code in the C code files</em></span> st.c <span class="emphasis"><em>and</em></span> include/ruby/st.h. <span class="emphasis"><em>All of the function and structure names in that code use the naming convention <code class="literal">st_</code>. The definition of the <code class="literal">RHash</code> structure that represents every Ruby Hash object is in the</em></span> include/ruby/ruby.h <span class="emphasis"><em>file. Along with <code class="literal">RHash</code>, this file contains all of the other primary object structures used in the Ruby source code: <code class="literal">RString</code>, <code class="literal">RArray</code>, <code class="literal">RValue</code>, and so on.</em></span></p></div></div></div><div class="sect1" title="Experiment 7-1: Retrieving a Value from Hashes of Varying Sizes"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_7-1_retrieving_a_value_from_h"/>Experiment 7-1: Retrieving a Value from Hashes of Varying Sizes</h1></div></div></div><p>This experiment will create hashes of wildly different sizes, from 1 to 1 million elements, and then measure how long it takes to find and return a value from each of these hashes. <a class="xref" href="ch07.html#measuring_how_long_it_takes_to_retrieve" title="Example 7-1. Measuring how long it takes to retrieve an element from hashes of wildly different sizes">Example 7-1</a> shows the experiment code.</p><div class="example"><a id="measuring_how_long_it_takes_to_retrieve"/><p class="title">Example 7-1. Measuring how long it takes to retrieve an element from hashes of wildly different sizes</p><div class="example-contents"><pre class="programlisting">    require 'benchmark'

<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> 21.times do |exponent|

      target_key = nil

<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   size = 2**exponent
      hash = {}
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>   (1..size).each do |n|
        index = rand
<img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/>     target_key = index if n &gt; size/2 &amp;&amp; target_key.nil?
<img alt="" src="httpatomoreillycomsourcenostarchimages1854043.png.jpg"/>     hash[index] = rand
      end

      GC.disable

      Benchmark.bm do |bench|
        bench.report("retrieving an element
                      from a hash with #{size} elements 10000 times") do
          10000.times do
<img alt="" src="httpatomoreillycomsourcenostarchimages1854045.png.jpg"/>         val = hash[target_key]
          end
        end
      end

      GC.enable
    end</pre></div></div><p>At <span class="inlinemediaobject"><a id="inline_id00224"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> the outer loop iterates over powers of two, calculating different values for <code class="literal">size</code> at <span class="inlinemediaobject"><a id="inline_id00225"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>. These sizes will vary from 1 to about 1 million. Next, the inner loop at <span class="inlinemediaobject"><a id="inline_id00226"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> inserts that number of elements into a new empty hash at <span class="inlinemediaobject"><a id="inline_id00227"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854043.png.jpg"/></span>.</p><p>After disabling garbage collection to avoid skewing the results, <a class="xref" href="ch07.html#experiment_7-1_retrieving_a_value_from_h" title="Experiment 7-1: Retrieving a Value from Hashes of Varying Sizes">Experiment 7-1: Retrieving a Value from Hashes of Varying Sizes</a> uses the benchmark library to measure how long it takes to retrieve a value 10,000 times from each hash at <span class="inlinemediaobject"><a id="inline_id00228"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854045.png.jpg"/></span>. The line of code at <span class="inlinemediaobject"><a id="inline_id00229"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span> saves one of the random key values to use below at <span class="inlinemediaobject"><a id="inline_id00230"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854045.png.jpg"/></span> as <code class="literal">target_key</code>.</p><p>The results in <a class="xref" href="ch07.html#time_to_retrieve_10comma000_values_left" title="Figure 7-4. Time to retrieve 10,000 values (ms) vs. hash size for Ruby 2.0">Figure 7-4</a> show that Ruby can find and return a value from a hash containing over 1 million elements just as fast as it can return one from a small hash.</p><div class="figure"><a id="time_to_retrieve_10comma000_values_left"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00166"/><img alt="Time to retrieve 10,000 values (ms) vs. hash size for Ruby 2.0" src="httpatomoreillycomsourcenostarchimages1854151.png"/></div></div><p class="title">Figure 7-4. Time to retrieve 10,000 values (ms) vs. hash size for Ruby 2.0</p></div><p>Clearly Ruby’s hash function is very fast, and once Ruby identifies the bin containing the target key, it can very quickly find the corresponding value and return it. What’s remarkable here is that the chart is more or less flat.</p></div><div class="sect1" title="How Hash Tables Expand to Accommodate More Values"><div class="titlepage"><div><div><h1 class="title"><a id="how_hash_tables_expand_to_accommodate_mo"/>How Hash Tables Expand to Accommodate More Values</h1></div></div></div><p><a class="indexterm" id="iddle1264"/><a class="indexterm" id="iddle1384"/><a class="indexterm" id="iddle1385"/><a class="indexterm" id="iddle2072"/>If there are millions of <code class="literal">st_table_entry</code> structures, why does distributing them among 11 bins help Ruby search quickly? Because even if the hash function is fast, and even if Ruby distributes the values evenly among the 11 bins in the hash table, Ruby still has to search among almost 100,000 elements in each bin to find the target key if there are 1 million elements overall.</p><p>Something else must be going on here. It seems that Ruby must add more bins to the hash table as more and more elements are added. Let’s look again at how Ruby’s internal hash table code works. Continuing with the example from <a class="xref" href="ch07.html#ruby_hash_object_with_an_empty_hash_ta" title="Figure 7-1. A Ruby hash object with an empty hash table">Figure 7-1</a> through <a class="xref" href="ch07.html#ruby_hash_object_containing_two_values" title="Figure 7-3. A Ruby hash object containing two values">Figure 7-3</a>, suppose I keep adding more and more elements to my hash.</p><a id="pro_id00048"/><pre class="programlisting">my_hash[:key3] = "value3"
my_hash[:key4] = "value4"
my_hash[:key5] = "value5"
my_hash[:key6] = "value6"</pre><p>As we add more elements, Ruby continues to create more <code class="literal">st_table_entry</code> structures and add them to different bins.</p><div class="sect2" title="Hash Collisions"><div class="titlepage"><div><div><h2 class="title"><a id="hash_collisions"/>Hash Collisions</h2></div></div></div><p>Eventually two or more elements might be saved into the same bin. When this happens, we have a <span class="emphasis"><em>hash collision</em></span>. This means that Ruby is no longer able to uniquely identify and retrieve a key based solely on the hash function.</p><p><a class="xref" href="ch07.html#hash_table_containing_44_values" title="Figure 7-5. A hash table containing 44 values">Figure 7-5</a> shows the linked list Ruby uses to track the entries in each bin. Each <code class="literal">st_table_entry</code> structure contains a pointer to the next entry in the same bin. As you add more entries to the hash, the linked lists get longer and longer.</p><div class="figure"><a id="hash_table_containing_44_values"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00167"/><img alt="A hash table containing 44 values" src="httpatomoreillycomsourcenostarchimages1854153.png.jpg"/></div></div><p class="title">Figure 7-5. A hash table containing 44 values</p></div><p><a class="indexterm" id="iddle1070"/><a class="indexterm" id="iddle1234"/><a class="indexterm" id="iddle1253"/><a class="indexterm" id="iddle1382"/><a class="indexterm" id="iddle1393"/><a class="indexterm" id="iddle1632"/><a class="indexterm" id="iddle1903"/>To retrieve a value, Ruby needs to iterate over the linked list and compare each key with the target. This isn’t a serious problem as long as the number of entries in a single bin doesn’t grow too large. For integers or symbols, which are typically used as hash keys, this is a simple numerical comparison. However, if you use a more complex data type, such as a custom object, Ruby calls the <code class="literal">eql?</code> method on the keys to check whether each key in the list is the target. As you might guess, <code class="literal">eql?</code> returns <span class="emphasis"><em>true</em></span> if two values are equal and <span class="emphasis"><em>false</em></span> if they are not.</p></div><div class="sect2" title="Rehashing Entries"><div class="titlepage"><div><div><h2 class="title"><a id="rehashing_entries"/>Rehashing Entries</h2></div></div></div><p>To keep these linked lists from growing out of control, Ruby measures the <span class="emphasis"><em>density</em></span>, or average number of entries per bin. In <a class="xref" href="ch07.html#hash_table_containing_44_values" title="Figure 7-5. A hash table containing 44 values">Figure 7-5</a> you can see that the average number of entries per bin is about 4. This means that the hash value modulus 11 has started to return repeated values for different keys and hash values; thus, there have been some hash collisions.</p><p>Once the density exceeds 5, a constant value in Ruby’s C source code, Ruby allocates more bins and then <span class="emphasis"><em>rehashes</em></span>, or redistributes, the existing entries across the new bin set. If we keep adding more key/value pairs, for example, Ruby eventually discards the array of 11 bins and allocates an array of 19 bins, as shown in <a class="xref" href="ch07.html#hash_table_containing_65_values" title="Figure 7-6. A hash table containing 65 values">Figure 7-6</a>.</p><div class="figure"><a id="hash_table_containing_65_values"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00168"/><img alt="A hash table containing 65 values" src="httpatomoreillycomsourcenostarchimages1854155.png.jpg"/></div></div><p class="title">Figure 7-6. A hash table containing 65 values</p></div><p>In this figure the bin density has dropped to about 3.</p><p>By monitoring bin density, Ruby guarantees that the linked lists remain short and that retrieving a hash element is always fast. After calculating the hash value, Ruby just needs to step through one or two elements to find the target key.</p><div class="sidebar"><a id="how_does_ruby_rehash_entries_in_a_hash_t"/><p class="title">How Does Ruby Rehash Entries in a Hash Table?</p><p><a class="indexterm" id="iddle1902"/>You can find the <code class="literal">rehash</code> function (the code that loops through the <code class="literal">st_table_entry</code> structures and recalculates which bin to put the entry into) in the <span class="emphasis"><em>st.c</em></span> source file. To keep things simple, <a class="xref" href="ch07.html#c_code_inside_ruby_1dot8dot7_that_re" title="Example 7-2. The C code inside Ruby 1.8.7 that rehashes a hash table">Example 7-2</a> shows the version of <code class="literal">rehash</code> from Ruby 1.8.7. While Ruby 1.9 and 2.0 work largely the same way, their C rehash code is somewhat more complex.</p><div class="example"><a id="c_code_inside_ruby_1dot8dot7_that_re"/><p class="title">Example 7-2. The C code inside Ruby 1.8.7 that rehashes a hash table</p><div class="example-contents"><pre class="programlisting">    static void
    rehash(table)
        register st_table *table;
    {
        register st_table_entry *ptr, *next, **new_bins;
        int i, old_num_bins = table-&gt;num_bins, new_num_bins;
        unsigned int hash_val;
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>     new_num_bins = new_size(old_num_bins+1);
        new_bins = (st_table_entry**)Calloc(new_num_bins,
                                            sizeof(st_table_entry*));
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>     for(i = 0; i &lt; old_num_bins; i++) {
            ptr = table-&gt;bins[i];
            while (ptr != 0) {
                next = ptr-&gt;next;
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>             hash_val = ptr-&gt;hash % new_num_bins;
<img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/>             ptr-&gt;next = new_bins[hash_val];
                new_bins[hash_val] = ptr;
                ptr = next;
            }
        }
<img alt="" src="httpatomoreillycomsourcenostarchimages1854043.png.jpg"/>     free(table-&gt;bins);
        table-&gt;num_bins = new_num_bins;
        table-&gt;bins = new_bins;
    }</pre></div></div><p>In this listing, the <code class="literal">new_size</code> method call at <span class="inlinemediaobject"><a id="inline_id00236"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> returns the new bin count. Once Ruby has the new bin count, it allocates the new bins and then iterates over all the existing <code class="literal">st_table_entry</code> structures (all the key/value pairs in the hash) beginning at <span class="inlinemediaobject"><a id="inline_id00237"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>. For each <code class="literal">st_table_entry</code> Ruby recalculates the bin position using the same modulus formula at <span class="inlinemediaobject"><a id="inline_id00238"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span>: <code class="literal">hash_val = ptr-&gt;hash % new_num_bins</code>. Then, Ruby saves each entry in the linked list for that new bin at <span class="inlinemediaobject"><a id="inline_id00239"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span>. Finally, Ruby updates the <code class="literal">st_table</code> structure and frees the old bins at <span class="inlinemediaobject"><a id="inline_id00240"/><img alt="" src="httpatomoreillycomsourcenostarchimages1854043.png.jpg"/></span>.</p></div></div></div><div class="sect1" title="Experiment 7-2: Inserting One New Element into Hashes of Varying Sizes"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_7-2_inserting_one_new_element"/>Experiment 7-2: Inserting One New Element into Hashes of Varying Sizes</h1></div></div></div><p><a class="indexterm" id="iddle1273"/><a class="indexterm" id="iddle1388"/>One way to test whether this rehashing, or redistribution, of entries really occurs is to measure the amount of time Ruby takes to save one new element into existing hashes of different sizes. As we add more elements to the same hash, we should eventually see evidence that Ruby is taking extra time to rehash the elements.</p><p>The code for this experiment is shown in <a class="xref" href="ch07.html#adding_one_more_element_to_hashes_of_dif" title="Example 7-3. Adding one more element to hashes of different sizes">Example 7-3</a>.</p><div class="example"><a id="adding_one_more_element_to_hashes_of_dif"/><p class="title">Example 7-3. Adding one more element to hashes of different sizes</p><div class="example-contents"><pre class="programlisting">    require 'benchmark'

<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> 100.times do |size|

      hashes = []
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   10000.times do
        hash = {}
        (1..size).each do
          hash[rand] = rand
        end
        hashes &lt;&lt; hash
      end

      GC.disable

      Benchmark.bm do |bench|
        bench.report("adding element number #{size+1}") do
          10000.times do |n|
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>         hashes[n][size] = rand
          end
        end
      end

      GC.enable
    end</pre></div></div><p>At <span class="inlinemediaobject"><a id="inline_id00244"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> the outer loop iterates over hash sizes from 0 to 100, and at <span class="inlinemediaobject"><a id="inline_id00245"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> the inner loop creates 10,000 hashes of the given size. After disabling garbage collection, this experiment uses the benchmark library to measure how long it takes Ruby to insert a single new value at <span class="inlinemediaobject"><a id="inline_id00246"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span> into all 10,000 hashes of the given size.</p><p>The results are surprising! <a class="xref" href="ch07.html#time_to_add_10comma000_keysolidusvalue_p" title="Figure 7-7. Time to add 10,000 key/value pairs vs. hash size (Ruby 1.8)">Figure 7-7</a> shows the results for Ruby 1.8.</p><div class="figure"><a id="time_to_add_10comma000_keysolidusvalue_p"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00169"/><img alt="Time to add 10,000 key/value pairs vs. hash size (Ruby 1.8)" src="httpatomoreillycomsourcenostarchimages1854157.png.jpg"/></div></div><p class="title">Figure 7-7. Time to add 10,000 key/value pairs vs. hash size (Ruby 1.8)</p></div><p>Interpreting these data values from left to right, we see the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>It takes about 7 ms to insert the first element into an empty hash (10,000 times).</p></li><li class="listitem"><p>As the hash size increases from 2 to 3 and then up to about 60 or 65, the amount of time required to insert a new element slowly increases.</p></li><li class="listitem"><p>It takes around 11 to 12 ms to insert each new key/value pair into a hash that contains 64, 65, or 66 elements (10,000 times).</p></li><li class="listitem"><p>A huge spike! Inserting the 67th key/value pair takes over twice as much time: about 26 ms instead of 11 ms for 10,000 hashes!</p></li><li class="listitem"><p>After inserting the 67th element, the time required to insert additional elements drops to about 10 ms or 11 ms and then slowly increases again from there.</p></li></ul></div><p>What’s going on here? Well, Ruby spends the extra time required to insert that 67th key/value pair reallocating the bin array from 11 to 19 bins and then reassigning the <code class="literal">st_table_entry</code> structures to the new bin array.</p><p><a class="xref" href="ch07.html#time_required_to_add_10comma000_keysolid" title="Figure 7-8. Time required to add 10,000 key/value pairs vs. hash size (Ruby 2.0)">Figure 7-8</a> shows the same graph for Ruby 2.0. This time the bin density threshold is different. Instead of taking extra time to reallocate the elements into bins on the 67th insert, Ruby 2.0 does it when the 57th element is inserted. Later Ruby 2.0 performs another reallocation after the 97th element is inserted.</p><div class="figure"><a id="time_required_to_add_10comma000_keysolid"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00170"/><img alt="Time required to add 10,000 key/value pairs vs. hash size (Ruby 2.0)" src="httpatomoreillycomsourcenostarchimages1854159.png.jpg"/></div></div><p class="title">Figure 7-8. Time required to add 10,000 key/value pairs vs. hash size (Ruby 2.0)</p></div><p>The two smaller spikes on the 1st and 7th insert in this figure are curious. While not as pronounced as the spikes at the 57th and 97th elements, these smaller spikes are nonetheless noticeable. As it turns out, Ruby 2.0 contains another optimization that speeds up hash access even more for small hashes that contain less than 7 elements. I’ll discuss this further in <a class="xref" href="ch07.html#hash_optimization_in_ruby_2dot0" title="Hash Optimization in Ruby 2.0">Hash Optimization in Ruby 2.0</a>.</p><div class="sidebar"><a id="where_do_the_magic_numbers_57_and_67_com"/><p class="title">Where Do the Magic Numbers 57 and 67 Come From?</p><p><a class="indexterm" id="iddle1392"/><a class="indexterm" id="iddle1833"/>To see where these magic numbers come from (57, 67, and so on), look at the top of the <span class="emphasis"><em>st.c</em></span> code file for your version of Ruby. You should find a list of prime numbers like the ones shown in <a class="xref" href="ch07.html#ruby_uses_an_algorithm_based_on_prime_nu" title="Example 7-4. Ruby uses an algorithm based on prime numbers to determine the number of buckets required in each hash table.">Example 7-4</a>.</p><div class="example"><a id="ruby_uses_an_algorithm_based_on_prime_nu"/><p class="title">Example 7-4. Ruby uses an algorithm based on prime numbers to determine the number of buckets required in each hash table.</p><div class="example-contents"><pre class="programlisting">    /*
    Table of prime numbers 2^n+a, 2&lt;=n&lt;=30.
    */
    static const unsigned int primes[] = {
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>   8 + 3,
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>   16 + 3,
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/>   32 + 5,
      64 + 3,
      128 + 3,
      256 + 27,
      512 + 9,
    --<span class="emphasis"><em>snip</em></span>--</pre></div></div><p>This C array lists some prime numbers that occur near powers of 2. Peter Moore’s hash table code uses this table to decide how many bins to use in the hash table. For example, the first prime number in the list above is 11 at <span class="inlinemediaobject"><a id="inline_id00250"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>, which is why Ruby hash tables start with 11 bins. Later, as the number of elements increases, the number of bins increases to 19 at <span class="inlinemediaobject"><a id="inline_id00251"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>, then to 37 at <span class="inlinemediaobject"><a id="inline_id00252"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span>, and so on.</p><p>Ruby always sets the number of hash table bins to a prime number in order to make it more likely that the hash values will be evenly distributed among the bins. Mathematically, prime numbers help here because they are less likely to share a common factor with the hash values, should a poor hash function return not entirely random values. Remember Ruby divides the hash values by the number of bins while calculating which bin to place the value into. If the hash values and bin count shared a factor, or even worse if the hash values were multiples of the bin count, the bin number (modulus) might always be the same. This would lead to the table entries being unevenly distributed among the bins.</p><p>Elsewhere in the <span class="emphasis"><em>st.c</em></span> file, you should see this C constant:</p><a id="pro_id00049"/><pre class="programlisting">#define ST_DEFAULT_MAX_DENSITY 5</pre><p>This constant defines the maximum allowed density, or the average number of elements per bin.</p><p>Finally, you should see the code that decides when to perform a bin reallocation by finding where the constant <code class="literal">ST_DEFAULT_MAX_DENSITY</code> is used in <span class="emphasis"><em>st.c</em></span>. For Ruby 1.8, you’ll find this code:</p><a id="pro_id00050"/><pre class="programlisting">if (table-&gt;num_entries/(table-&gt;num_bins) &gt; ST_DEFAULT_MAX_DENSITY) {
  rehash(table);</pre><p><a class="indexterm" id="iddle1387"/><a class="indexterm" id="iddle1405"/>Ruby 1.8 rehashes from 11 to 19 bins when the value <code class="literal">num_entries/11</code> is greater than 5—that is, when it equals 66. As this check is performed before a new element is added, the condition becomes true when you add the 67th element because <code class="literal">num_entries</code> would then be 66.</p><p>For Ruby 1.9 and Ruby 2.0, you’ll find this code instead:</p><a id="pro_id00051"/><pre class="programlisting">if ((table)-&gt;num_entries &gt;
    ST_DEFAULT_MAX_DENSITY * (table)-&gt;num_bins) {
  rehash(table);</pre><p>You can see that Ruby 2.0 rehashes for the first time when <code class="literal">num_entries</code> is greater than 5*11, or when you insert the 57th element.</p></div></div><div class="sect1" title="How Ruby Implements Hash Functions"><div class="titlepage"><div><div><h1 class="title"><a id="how_ruby_implements_hash_functions"/>How Ruby Implements Hash Functions</h1></div></div></div><p>Now for a closer look at the actual hash function Ruby uses to assign keys and values to bins in hash tables. This function is central to the way the hash object is implemented—if it works well, Ruby hashes are fast, but a poor hash function can cause severe performance problems. Furthermore, Ruby uses hash tables internally to store its own information, in addition to the data values you save in hash objects. Clearly having a good hash function is very important!</p><div class="informalfigure"><a id="med_id00171a"/><div class="mediaobject"><a id="med_id00171"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1854161.png.jpg"/><div class="caption"><p><span class="emphasis"><em>Hash functions allow Ruby to find which bin contains a given key and value.</em></span></p></div></div></div><p>Let’s review how Ruby uses hash values. Remember that when you save a new element in a hash—a new key/value pair—Ruby assigns that element to a bin inside the internal hash table used by that hash object, as shown in <a class="xref" href="ch07.html#ruby_hash_object_containing_a_si-id00025" title="Figure 7-9. A Ruby hash object containing a single value (repeated from Figure 7-2)">Figure 7-9</a>.</p><p>Ruby calculates the modulus of the key’s hash value based on the number of bins.</p><a id="pro_id00052"/><pre class="programlisting">bin_index = internal_hash_function(key) % bin_count</pre><p>Using the same example values we used earlier, this formula becomes:</p><a id="pro_id00053"/><pre class="programlisting">2 = hash(:key) % 11</pre><div class="figure"><a id="ruby_hash_object_containing_a_si-id00025"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00172"/><img alt="A Ruby hash object containing a single value (repeated from )" src="httpatomoreillycomsourcenostarchimages1854163.png.jpg"/></div></div><p class="title">Figure 7-9. A Ruby hash object containing a single value (repeated from <a class="xref" href="ch07.html#ruby_hash_object_containing_a_single_v" title="Figure 7-2. A Ruby hash object containing a single value">Figure 7-2</a>)</p></div><p><a class="indexterm" id="iddle1381"/><a class="indexterm" id="iddle1636"/>This formula works well because Ruby’s hash values are basically random integers for any given input data. To get a feel for how Ruby’s hash function works, call the <code class="literal">hash</code> method, as shown in <a class="xref" href="ch07.html#displaying_the_hash_value_for_different" title="Example 7-5. Displaying the hash value for different Ruby objects">Example 7-5</a>.</p><div class="example"><a id="displaying_the_hash_value_for_different"/><p class="title">Example 7-5. Displaying the hash value for different Ruby objects</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>irb</strong></span>
&gt; <span class="strong"><strong>"abc".hash</strong></span>
 =&gt; 3277525029751053763
&gt; <span class="strong"><strong>"abd".hash</strong></span>
 =&gt; 234577060685640459
&gt; <span class="strong"><strong>1.hash</strong></span>
 =&gt; -3466223919964109258
&gt; <span class="strong"><strong>2.hash</strong></span>
 =&gt; -2297524640777648528</pre></div></div><p>Here, even similar values have very different hash values. And if we call <code class="literal">hash</code> again, we always get the same integer value for the same input data.</p><a id="pro_id00054"/><pre class="programlisting">&gt; <span class="strong"><strong>"abc".hash</strong></span>
 =&gt; 3277525029751053763
&gt; <span class="strong"><strong>"abd".hash</strong></span>
 =&gt; 234577060685640459</pre><p><a class="indexterm" id="iddle1014"/><a class="indexterm" id="iddle1275"/><a class="indexterm" id="iddle1397"/><a class="indexterm" id="iddle1712"/><a class="indexterm" id="iddle1747"/>Here’s how Ruby’s hash function actually works for most Ruby objects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>When you call <code class="literal">hash</code>, Ruby finds the default implementation in the <code class="literal">Object</code> class. You can override this if you want to.</p></li><li class="listitem"><p>The C code used by the <code class="literal">Object</code> class’s implementation of the <code class="literal">hash</code> method gets the C pointer value for the target object—that is, the actual memory address of that object’s <code class="literal">RValue</code> structure. This is essentially a unique ID for that object.</p></li><li class="listitem"><p>Ruby passes the pointer value through a complex C function (the hash function), which scrambles the bits in the value, producing a pseudo-random integer in a repeatable way.</p></li></ul></div><p>In the case of strings and arrays, Ruby actually iterates through all of the characters in the string or the elements in the array and calculates a cumulative hash value. This guarantees that the hash will always be the same for any instance of a string or array and that it will change if any of the values in the string or array change. Integers and symbols are another special case. Ruby just passes their values right to the hash function.</p><p>To calculate hashes from values, Ruby 1.9 and 2.0 use a hash function called <span class="emphasis"><em>MurmurHash</em></span>, which was invented by Austin Appleby in 2008. The name <span class="emphasis"><em>Murmur</em></span> comes from the machine language operations used in the algorithm: <span class="emphasis"><em>multiply</em></span> and <span class="emphasis"><em>rotate</em></span>. (To learn how the Murmur algorithm actually works, read its C code in the <span class="emphasis"><em>st.c</em></span> Ruby source code file. Or read Austin’s web page on Murmur: <span class="emphasis"><em><a class="ulink" href="http://sites.google.com/site/murmurhash/">http://sites.google.com/site/murmurhash/</a></em></span>.)</p><p>Ruby 1.9 and 2.0 initialize MurmurHash using a random seed value that is reinitialized each time you restart Ruby. This means that if you stop and restart Ruby, you’ll get different hash values for the same input data. It also means that if you try this yourself, you’ll get different values than those above, but the hash values will always be the same within the same Ruby process.</p></div><div class="sect1" title="Experiment 7-3: Using Objects as Keys in a Hash"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_7-3_using_objects_as_keys_in"/>Experiment 7-3: Using Objects as Keys in a Hash</h1></div></div></div><p>Because hash values are pseudorandom numbers, once Ruby divides them by the bin count, say 11, the remaining values (the modulus values) are random numbers between 0 and 10. This means that the <code class="literal">st_table_entry</code> structures are evenly distributed over the available bins as they are saved in the hash table, which ensures that Ruby will be able to quickly find any given key. The number of entries per bin will always be small.</p><p>But what if Ruby’s hash function didn’t return random integers but rather returned the same integer for every input data value? What would happen?</p><p>In that case, every time you added a key/value to a hash, it would always be assigned to the same bin. Ruby would end up with all of the entries in a single long list under that one bin, with no entries in any other bin, as shown in <a class="xref" href="ch07.html#hash_table_created_with_a_very_poor_ha" title="Figure 7-10. A hash table created with a very poor hash function">Figure 7-10</a>.</p><div class="figure"><a id="hash_table_created_with_a_very_poor_ha"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00173"/><img alt="A hash table created with a very poor hash function" src="httpatomoreillycomsourcenostarchimages1854165.png.jpg"/></div></div><p class="title">Figure 7-10. A hash table created with a very poor hash function</p></div><p>If you tried to retrieve a value from this hash, Ruby would have to look through this long list, one element at a time, to find the requested key. In this scenario, loading a value from the hash would be very, very slow.</p><p>To prove this is the case—and to illustrate just how important Ruby’s hash function really is—we’ll use objects with poor hash functions as keys in a hash. We’ll repeat <a class="xref" href="ch07.html#experiment_7-1_retrieving_a_value_from_h" title="Experiment 7-1: Retrieving a Value from Hashes of Varying Sizes">Experiment 7-1: Retrieving a Value from Hashes of Varying Sizes</a> here, but we’ll use instances of a class I defined as the key values instead of random numbers. <a class="xref" href="ch07.html#measuring_how_long_it_takes_to_r-id00026" title="Example 7-6. Measuring how long it takes to retrieve an element from hashes of wildly different sizes. This is the same as Example 7-1, but using instances of KeyObject as keys.">Example 7-6</a> shows the code from <a class="xref" href="ch07.html#experiment_7-1_retrieving_a_value_from_h" title="Experiment 7-1: Retrieving a Value from Hashes of Varying Sizes">Experiment 7-1: Retrieving a Value from Hashes of Varying Sizes</a>, updated in two places.</p><div class="example"><a id="measuring_how_long_it_takes_to_r-id00026"/><p class="title">Example 7-6. Measuring how long it takes to retrieve an element from hashes of wildly different sizes. This is the same as <a class="xref" href="ch07.html#measuring_how_long_it_takes_to_retrieve" title="Example 7-1. Measuring how long it takes to retrieve an element from hashes of wildly different sizes">Example 7-1</a>, but using instances of <code class="literal">KeyObject</code> as keys.</p><div class="example-contents"><pre class="programlisting">    require 'benchmark'

<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> class KeyObject
      def eql?(other)
        super
      end
    end

    21.times do |exponent|

      target_key = nil

      size = 2**exponent
      hash = {}
      (1..size).each do |n|
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>     index = KeyObject.new
        target_key = index if n &gt; size/2 &amp;&amp; target_key.nil?
        hash[index] = rand
      end

      GC.disable

      Benchmark.bm do |bench|
        bench.report("retrieving an element
                       from a hash with #{size} elements 10000 times") do
          10000.times do
            val = hash[target_key]
          end
        end
      end

      GC.enable

    end</pre></div></div><p>At <span class="inlinemediaobject"><a id="inline_id00255"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> we define an empty class called <code class="literal">KeyObject</code>. Note that I implemented the <code class="literal">eql?</code> method; this allows Ruby to search for the target key properly when I retrieve a value. However, in this example, I don’t have any interesting data in <code class="literal">KeyObject</code>, so I simply call <code class="literal">super</code> and use the default implementation of <code class="literal">eql?</code> in the <code class="literal">Object</code> class.</p><p>Then, at <span class="inlinemediaobject"><a id="inline_id00256"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> we use new instances of <code class="literal">KeyObject</code> as the keys for my hash values. <a class="xref" href="ch07.html#time_to_retrieve_10comma000_values_vsdot" title="Figure 7-11. Time to retrieve 10,000 values vs. hash size, using objects as keys (Ruby 2.0)">Figure 7-11</a> shows the results of this test.</p><div class="figure"><a id="time_to_retrieve_10comma000_values_vsdot"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00174"/><img alt="Time to retrieve 10,000 values vs. hash size, using objects as keys (Ruby 2.0)" src="httpatomoreillycomsourcenostarchimages1854167.png"/></div></div><p class="title">Figure 7-11. Time to retrieve 10,000 values vs. hash size, using objects as keys (Ruby 2.0)</p></div><p>As you can see, the results are very similar to those in <a class="xref" href="ch07.html#time_to_retrieve_10comma000_values_left" title="Figure 7-4. Time to retrieve 10,000 values (ms) vs. hash size for Ruby 2.0">Figure 7-4</a>. The chart is more or less flat. It takes about the same amount of time to retrieve a value from a hash with 1 million elements as it does for a hash with just 1 element. No surprise there; using objects as keys hasn’t slowed down Ruby at all.</p><p>Now let’s change the <code class="literal">KeyObject</code> class and try again. <a class="xref" href="ch07.html#keyobject_now_has_a_very_poor_hash_funct" title="Example 7-7. KeyObject now has a very poor hash function.">Example 7-7</a> shows the same code with a new hash function added at <span class="inlinemediaobject"><a id="inline_id00257"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>.</p><div class="example"><a id="keyobject_now_has_a_very_poor_hash_funct"/><p class="title">Example 7-7. <code class="literal">KeyObject</code> now has a very poor hash function.</p><div class="example-contents"><pre class="programlisting">    require 'benchmark'

    class KeyObject
      def hash
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>     4
      end
      def eql?(other)
        super
      end
    end

    21.times do |exponent|

      target_key = nil

      size = 2**exponent
      hash = {}
      (1..size).each do |n|
        index = KeyObject.new
        target_key = index if n &gt; size/2 &amp;&amp; target_key.nil?
        hash[index] = rand
      end

      GC.disable

      Benchmark.bm do |bench|
        bench.report("retrieving an element
                      from a hash with #{size} elements 10000 times") do
          10000.times do
            val = hash[target_key]
          end
        end
      end

      GC.enable
    end</pre></div></div><p>I’ve purposefully written a very poor hash function. Instead of returning a pseudorandom integer, the hash function in <a class="xref" href="ch07.html#keyobject_now_has_a_very_poor_hash_funct" title="Example 7-7. KeyObject now has a very poor hash function.">Example 7-7</a> always returns the integer 4 at <span class="inlinemediaobject"><a id="inline_id00259"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>, regardless of which <code class="literal">KeyObject</code> object instance you call it on. Now Ruby will always get 4 when it calculates the hash value. It will have to assign all of the hash elements to bin number 4 in the internal hash table, as in <a class="xref" href="ch07.html#hash_table_created_with_a_very_poor_ha" title="Figure 7-10. A hash table created with a very poor hash function">Figure 7-10</a>.</p><p><a class="indexterm" id="iddle1390"/>Let’s try this to see what happens! <a class="xref" href="ch07.html#time_to_retrieve_10comma000_valu-id00027" title="Figure 7-12. Time to retrieve 10,000 values vs. hash size, using a poor hash function (Ruby 2.0)">Figure 7-12</a> shows the results of running the code from <a class="xref" href="ch07.html#keyobject_now_has_a_very_poor_hash_funct" title="Example 7-7. KeyObject now has a very poor hash function.">Example 7-7</a>.</p><div class="figure"><a id="time_to_retrieve_10comma000_valu-id00027"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00175"/><img alt="Time to retrieve 10,000 values vs. hash size, using a poor hash function (Ruby 2.0)" src="httpatomoreillycomsourcenostarchimages1854169.png.jpg"/></div></div><p class="title">Figure 7-12. Time to retrieve 10,000 values vs. hash size, using a poor hash function (Ruby 2.0)</p></div><p><a class="xref" href="ch07.html#time_to_retrieve_10comma000_valu-id00027" title="Figure 7-12. Time to retrieve 10,000 values vs. hash size, using a poor hash function (Ruby 2.0)">Figure 7-12</a> is very different from <a class="xref" href="ch07.html#time_to_retrieve_10comma000_values_vsdot" title="Figure 7-11. Time to retrieve 10,000 values vs. hash size, using objects as keys (Ruby 2.0)">Figure 7-11</a>! Notice the scale of the graph. The y-axis shows milliseconds, and the x-axis shows the number of elements in the hash on a logarithmic scale. But this time, notice that we have thousands of milliseconds—which means actual seconds—on the y-axis!</p><p>With one or a few elements, we can retrieve the 10,000 values very quickly—so quickly that the time is too small to appear on this graph. In fact, it takes about the same 1.5 ms. However, when the number of elements increases past 100 and especially 1,000, the time required to load the 10,000 values increases linearly with the hash size. For a hash containing about 10,000 elements, it takes over 1.6 full seconds to load the 10,000 values. If we continued the test with larger hashes, it would take minutes or even hours to load the values.</p><p>What’s happening here is that all of the hash elements are saved into the same bin, forcing Ruby to search through the list one key at a time.</p><div class="sect2" title="Hash Optimization in Ruby 2.0"><div class="titlepage"><div><div><h2 class="title"><a id="hash_optimization_in_ruby_2dot0"/>Hash Optimization in Ruby 2.0</h2></div></div></div><p>Starting with version 2.0, Ruby introduced a new optimization to make hashes work even faster. For hashes that contain 6 or fewer elements, Ruby <a class="indexterm" id="iddle1391"/><a class="indexterm" id="iddle1765"/>now avoids calculating the hash value entirely and simply saves the hash data in an array. These are known as <span class="emphasis"><em>packed hashes</em></span>. <a class="xref" href="ch07.html#internallycomma_ruby_2dot0_saves_small_h" title="Figure 7-13. Internally, Ruby 2.0 saves small hashes with 6 or fewer elements as arrays.">Figure 7-13</a> shows a packed hash.</p><div class="figure"><a id="internallycomma_ruby_2dot0_saves_small_h"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00176"/><img alt="Internally, Ruby 2.0 saves small hashes with 6 or fewer elements as arrays." src="httpatomoreillycomsourcenostarchimages1854171.png.jpg"/></div></div><p class="title">Figure 7-13. Internally, Ruby 2.0 saves small hashes with 6 or fewer elements as arrays.</p></div><p>Ruby 2.0 doesn’t use the <code class="literal">st_table_entry</code> structure for small hashes, nor does it create a table of bins. Instead, it creates an array and saves the key/value pairs directly into this array. The array is large enough to fit 6 key/value pairs; once you insert a 7th key and value, Ruby discards the array, creates the bin array, and moves all 7 elements into <code class="literal">st_table_entry</code> structures as usual by calculating hash values. This explains the small spike we saw inserting the 7th element in <a class="xref" href="ch07.html#time_required_to_add_10comma000_keysolid" title="Figure 7-8. Time required to add 10,000 key/value pairs vs. hash size (Ruby 2.0)">Figure 7-8</a>. <code class="literal">real_entries</code> saves the number of values saved in the array between 0 and 6.</p><p>In a packed hash, there are only 6 or fewer elements; thus, it’s faster for Ruby to iterate over the key values looking for a target value than it would be to calculate a hash value and use a bin array. <a class="xref" href="ch07.html#for_small_hashescomma_ruby_2dot0_iterate" title="Figure 7-14. For small hashes, Ruby 2.0 iterates over the array to find a given key.">Figure 7-14</a> shows how Ruby 2.0 retrieves an element from a packed hash.</p><p>To find the value for a given key of <code class="literal">target</code>, Ruby iterates through the array and calls the <code class="literal">eql?</code> method on each key value if the values are objects. For simple values, such as integers or symbols, Ruby just uses a numerical comparison. Ruby 2.0 never calls the hash function at all for packed hashes.</p><div class="figure"><a id="for_small_hashescomma_ruby_2dot0_iterate"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00177"/><img alt="For small hashes, Ruby 2.0 iterates over the array to find a given key." src="httpatomoreillycomsourcenostarchimages1854173.png.jpg"/></div></div><p class="title">Figure 7-14. For small hashes, Ruby 2.0 iterates over the array to find a given key.</p></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00028"/>Summary</h1></div></div></div><p>Understanding hash tables is key to understanding how Ruby works internally because the speed and flexibility of hash tables allow Ruby to use them in many ways.</p><p>At the beginning of this chapter, we learned how hash tables are able to return values quickly, regardless of how many elements are in the table. Next, we learned how Ruby automatically increases the size of a hash table as you add more and more elements to it. The user of the hash table doesn’t need to worry about how fast or large the table is. Hash tables will always be fast and will automatically expand as necessary.</p><p>Finally, we looked at the importance of Ruby’s hash function. The hash table’s algorithm depends on the underlying hash function. With an effective hash function, values are evenly distributed across the bins in the hash table with few collisions, allowing them to be saved and retrieved quickly. However, with a poor hash function, values would be saved in the same bin, leading to poor performance.</p></div></div></body></html>