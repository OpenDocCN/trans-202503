<html><head></head><body>
<h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_89"/><span class="big"><strong>5</strong></span><br/><strong>LISTS AND DATA FRAMES</strong></h2>&#13;
<div class="image"><img src="../images/common-01.jpg" alt="image"/></div>&#13;
<p class="noindent">Vectors, matrices, and arrays are efficient and convenient data storage structures in R, but they have one distinct limitation: they can store only one type of data. In this chapter, you’ll explore two more data structures, lists and data frames, which can store multiple types of values at once.</p>&#13;
<h3 class="h3" id="ch05lev1sec19"><strong>5.1 Lists of Objects</strong></h3>&#13;
<p class="noindent">The <em>list</em> is an incredibly useful data structure. It can be used to group together any mix of R structures and objects. A single list could contain a numeric matrix, a logical array, a single character string, and a factor object. You can even have a list as a component of another list. In this section, you’ll see how to create, modify, and access components of these flexible structures.</p>&#13;
<h4 class="h4" id="ch05lev2sec49"><strong><em>5.1.1 Definition and Component Access</em></strong></h4>&#13;
<p class="noindent">Creating a list is much like creating a vector. You supply the elements that you want to include to the <code>list</code> function, separated by commas.</p>&#13;
<pre><span epub:type="pagebreak" id="page_90"/>R&gt; foo &lt;- list(matrix(data=1:4,nrow=2,ncol=2),c(T,F,T,T),"hello")<br/>R&gt; foo<br/>[[1]]<br/>     [,1] [,2]<br/>[1,]    1    3<br/>[2,]    2    4<br/><br/>[[2]]<br/>[1]  TRUE FALSE  TRUE  TRUE<br/><br/>[[3]]<br/>[1] "hello"</pre>&#13;
<p class="indent">In the list <code>foo</code>, you’ve stored a 2 × 2 numeric matrix, a logical vector, and a character string. These are printed in the order they were supplied to <code>list</code>. Just as with vectors, you can use the <code>length</code> function to check the number of components in a list.</p>&#13;
<pre>R&gt; length(x=foo)<br/>[1] 3</pre>&#13;
<p class="indent">You can retrieve components from a list using indexes, which are entered in double square brackets.</p>&#13;
<pre>R&gt; foo[[1]]<br/>     [,1] [,2]<br/>[1,]    1    3<br/>[2,]    2    4<br/>R&gt; foo[[3]]<br/>[1] "hello"</pre>&#13;
<p class="indent">This action is known as a <em>member reference</em>. When you’ve retrieved a component this way, you can treat it just like a stand-alone object in the workspace; there’s nothing special that needs to be done.</p>&#13;
<pre>R&gt; foo[[1]] + 5.5<br/>     [,1] [,2]<br/>[1,]  6.5  8.5<br/>[2,]  7.5  9.5<br/>R&gt; foo[[1]][1,2]<br/>[1] 3<br/>R&gt; foo[[1]][2,]<br/>[1] 2 4<br/>R&gt; cat(foo[[3]],"you!")<br/>hello you!</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_91"/>To overwrite a member of <code>foo</code>, you use the assignment operator.</p>&#13;
<pre>R&gt; foo[[3]]<br/>[1] "hello"<br/>R&gt; foo[[3]] &lt;- paste(foo[[3]],"you!")<br/>R&gt; foo<br/>[[1]]<br/>     [,1] [,2]<br/>[1,]    1    3<br/>[2,]    2    4<br/><br/>[[2]]<br/>[1]  TRUE FALSE  TRUE  TRUE<br/><br/>[[3]]<br/>[1] "hello you!"</pre>&#13;
<p class="indent">Suppose now you want to access the second and third components of <code>foo</code> and store them as one object. Your first instinct might be to try something like this:</p>&#13;
<pre>R&gt; foo[[c(2,3)]]<br/>[1] TRUE</pre>&#13;
<p class="indent">But R hasn’t done what you wanted. Instead, it returned the third element of the second component. This is because using double square brackets on a list is always interpreted with respect to a single member. Fortunately, member referencing with the double square brackets is not the only way to access components of a list. You can also use single square bracket notation. This is referred to as <em>list slicing</em>, and it lets you select multiple list items at once.</p>&#13;
<pre>R&gt; bar &lt;- foo[c(2,3)]<br/>R&gt; bar<br/>[[1]]<br/>[1]  TRUE FALSE  TRUE  TRUE<br/><br/>[[2]]<br/>[1] "hello you!"</pre>&#13;
<p class="indent">Note that the result <code>bar</code> is itself a list with the two components stored in the order in which they were requested.</p>&#13;
<h4 class="h4" id="ch05lev2sec50"><strong><em>5.1.2 Naming</em></strong></h4>&#13;
<p class="noindent">You can <em>name</em> list components to make the elements more recognizable and easy to work with. Just like the information stored about factor levels (as you saw in <a href="ch04.xhtml#ch04lev2sec46">Section 4.3.1</a>), a name is an R <em>attribute</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_92"/>Let’s start by adding names to the list <code>foo</code> from earlier.</p>&#13;
<pre>R&gt; names(foo) &lt;- c("mymatrix","mylogicals","mystring")<br/>R&gt; foo<br/>$mymatrix<br/>     [,1] [,2]<br/>[1,]    1    3<br/>[2,]    2    4<br/><br/>$mylogicals<br/>[1]  TRUE FALSE  TRUE  TRUE<br/><br/>$mystring<br/>[1] "hello you!"</pre>&#13;
<p class="indent">This has changed how the object is printed to the console. Where earlier it printed <code>[[1]]</code>, <code>[[2]]</code>, and <code>[[3]]</code> before each component, now it prints the names you specified: <code>$mymatrix</code>, <code>$mylogicals</code>, and <code>$mystring</code>. You can now perform member referencing using these names and the dollar operator, rather than the double square brackets.</p>&#13;
<pre>R&gt; foo$mymatrix<br/>     [,1] [,2]<br/>[1,]    1    3<br/>[2,]    2    4</pre>&#13;
<p class="indent">This is the same as calling <code>foo[[1]]</code>. In fact, even when an object is named, you can still use the numeric index to obtain a member.</p>&#13;
<pre>R&gt; foo[[1]]<br/>     [,1] [,2]<br/>[1,]    1    3<br/>[2,]    2    4</pre>&#13;
<p class="indent">Subsetting named members also works the same way.</p>&#13;
<pre>R&gt; all(foo$mymatrix[,2]==foo[[1]][,2])<br/>[1] TRUE</pre>&#13;
<p class="indent">This confirms (using the <code>all</code> function you saw in <a href="ch04.xhtml#ch04lev2sec38">Section 4.1.2</a>) that these two ways of extracting the second column of the matrix in <code>foo</code> provide an identical result.</p>&#13;
<p class="indent">To name the components of a list as it’s being created, assign a label to each component in the <code>list</code> command. Using some components of <code>foo</code>, create a new, named list.</p>&#13;
<pre>R&gt; baz &lt;- list(tom=c(foo[[2]],T,T,T,F),dick="g'day mate",harry=foo$mymatrix*2)<br/>R&gt; baz<br/>$tom<br/>[1]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE<br/><br/>$dick<br/>[1] "g'day mate"<br/><br/>$harry<br/>     [,1] [,2]<br/>[1,]    2    6<br/>[2,]    4    8</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_93"/>The object <code>baz</code> now contains the three named components <code>tom</code>, <code>dick</code>, and <code>harry</code>.</p>&#13;
<pre>R&gt; names(baz)<br/>[1] "tom"   "dick"  "harry"</pre>&#13;
<p class="indent">If you want to rename these members, you can simply assign a character vector of length 3 to <code>names(baz)</code>, the same way you did for <code>foo</code> earlier.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>When using the</em> <code><span class="codeitalic">names</code></span> <em>function, the component names are always provided and returned as character strings in double quotes. However, if you’re specifying names when a list is created (inside the</em> <code><span class="codeitalic">list</code></span> <em>function) or using names to extract members with the dollar operator, the names are entered without quotes (in other words, they are</em> not <em>given as strings).</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch05lev2sec51"><strong><em>5.1.3 Nesting</em></strong></h4>&#13;
<p class="noindent">As noted earlier, a member of a list can itself be a list. When nesting lists like this, it’s important to keep track of the depth of any member for subsetting or extraction later.</p>&#13;
<p class="indent">Note that you can add components to any existing list by using the dollar operator and a <em>new</em> name. Here’s an example using <code>foo</code> and <code>baz</code> from earlier:</p>&#13;
<pre>R&gt; baz$bobby &lt;- foo<br/>R&gt; baz<br/>$tom<br/>[1]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE<br/><br/>$dick<br/>[1] "g'day mate"<br/><br/>$harry<br/>     [,1] [,2]<br/>[1,]    2    6<br/>[2,]    4    8<br/><br/>$bobby<br/><span epub:type="pagebreak" id="page_94"/>$bobby$mymatrix<br/>     [,1] [,2]<br/>[1,]    1    3<br/>[2,]    2    4<br/><br/>$bobby$mylogicals<br/>[1]  TRUE FALSE  TRUE  TRUE<br/><br/>$bobby$mystring<br/>[1] "hello you!"</pre>&#13;
<p class="indent">Here you’ve defined a fourth component to the list <code>baz</code> called <code>bobby</code>. The member <code>bobby</code> is assigned the entire list <code>foo</code>. As you can see by printing the new <code>baz</code>, there are now three components in <code>bobby</code>. Naming and indexes are now both layered, and you can use either (or combine them) to retrieve members of the inner list.</p>&#13;
<pre>R&gt; baz$bobby$mylogicals[1:3]<br/>[1]  TRUE FALSE  TRUE<br/>R&gt; baz[[4]][[2]][1:3]<br/>[1]  TRUE FALSE  TRUE<br/>R&gt; baz[[4]]$mylogicals[1:3]<br/>[1]  TRUE FALSE  TRUE</pre>&#13;
<p class="indent">These all instruct R to return the first three elements of the logical vector stored as the second component (<code>[[2]]</code>, also named <code>mylogicals</code>) of the list <code>bobby</code>, which in turn is the fourth component of the list <code>baz</code>. As long as you’re aware of what is returned at each layer of a subset, you can continue to subset as needed using names and numeric indexes. Consider the third line in this example. The first layer of the subset is <code>baz[[4]]</code>, which is a list with three components. The second layer of subsetting extracts the component <code>mylogicals</code> from that list by calling <code>baz[[4]]$mylogicals</code>. This component represents a vector of length 4, so the third layer of subsetting retrieves the first three elements of that vector with the line <code>baz[[4]]$mylogicals[1:3]</code>.</p>&#13;
<p class="indent">Lists are often used to return output from various R functions. But they can quickly become rather large objects in terms of system resources to store. It’s generally recommended that when you have only one type of data, you should stick to using basic vector, matrix, or array structures to record and store the observations.</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch5exc1"/><strong>Exercise 5.1</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Create a list that contains, in this order, a sequence of 20 evenly spaced numbers between −4 and 4; a 3 × 3 matrix of the logical vector <code>c(F,T,T,T,F,T,T,F,F)</code> filled column-wise; a character vector <span epub:type="pagebreak" id="page_95"/>with the two strings <code>"don"</code> and <code>"quixote"</code>; and a factor vector containing the observations <code>c("LOW","MED","LOW","MED","MED","HIGH")</code>. Then, do the following:</p>&#13;
<ol type="i">&#13;
<li><p class="noindent">Extract row elements <code>2</code> and <code>1</code> of columns <code>2</code> and <code>3</code>, in that order, of the logical matrix.</p></li>&#13;
<li><p class="noindent">Use <code>sub</code> to overwrite <code>"quixote"</code> with <code>"Quixote"</code> and <code>"don"</code> with <code>"Don"</code> inside the list. Then, using the newly overwritten list member, concatenate to the console screen the following statement exactly:</p>&#13;
<pre>"Windmills! ATTACK!"<br/>    -\Don Quixote/-</pre></li>&#13;
<li><p class="noindent">Obtain all values from the sequence between −4 and 4 that are greater than 1.</p></li>&#13;
<li><p class="noindent">Using <code>which</code>, determine which indexes in the factor vector are assigned the <code>"MED"</code> level.</p></li>&#13;
</ol></li>&#13;
<li><p class="noindents">Create a new list with the factor vector from (a) as a component named <code>"facs"</code>; the numeric vector <code>c(3,2.1,3.3,4,1.5,4.9)</code> as a component named <code>"nums"</code>; and a nested list comprised of the first three members of the list from (a) (use list slicing to obtain this), named <code>"oldlist"</code>. Then, do the following:</p>&#13;
<ol type="i">&#13;
<li><p class="noindents">Extract the elements of <code>"facs"</code> that correspond to elements of <code>"nums"</code> that are greater than or equal to 3.</p></li>&#13;
<li><p class="noindents">Add a new member to the list named <code>"flags"</code>. This member should be a logical vector of length 6, obtained as a twofold repetition of the third column of the logical matrix in the <code>"oldlist"</code> component.</p></li>&#13;
<li><p class="noindents">Use <code>"flags"</code> and the logical negation operator <code>!</code> to extract the entries of <code>"num"</code> corresponding to <code>FALSE</code>.</p></li>&#13;
<li><p class="noindents">Overwrite the character string vector component of <code>"oldlist"</code> with the single character string <code>"Don Quixote"</code>.</p></li>&#13;
</ol></li>&#13;
</ol>&#13;
</div>&#13;
<h3 class="h3" id="ch05lev1sec20"><strong>5.2 Data Frames</strong></h3>&#13;
<p class="noindent">A <em>data frame</em> is R’s most natural way of presenting a data set with a collection of recorded observations for one or more variables. Like lists, data frames have no restriction on the data types of the variables; you can store numeric data, factor data, and so on. The R data frame can be thought of as a list with some extra rules attached. The most important distinction is that in a data frame (unlike a list), the members must all be vectors of equal length.</p>&#13;
<p class="indent">The data frame is one of the most important and frequently used tools in R for statistical data analysis. In this section, you’ll look at how to create data frames and learn about their general characteristics.</p>&#13;
<h4 class="h4" id="ch05lev2sec52"><span epub:type="pagebreak" id="page_96"/><strong><em>5.2.1 Construction</em></strong></h4>&#13;
<p class="noindent">To create a data frame from scratch, use the <code>data.frame</code> function. You supply your data, grouped by variable, as vectors of the same length—the same way you would construct a named list. Consider the following example data set:</p>&#13;
<pre>R&gt; mydata &lt;- data.frame(person=c("Peter","Lois","Meg","Chris","Stewie"),<br/>                        age=c(42,40,17,14,1),<br/>                        sex=factor(c("M","F","F","M","M")))<br/>R&gt; mydata<br/>  person age sex<br/>1  Peter  42   M<br/>2   Lois  40   F<br/>3    Meg  17   F<br/>4  Chris  14   M<br/>5 Stewie   1   M</pre>&#13;
<p class="indent">Here, you’ve constructed a data frame with the first name, age in years, and sex of five individuals. The returned object should make it clear why vectors passed to <code>data.frame</code> must be of equal length: vectors of differing lengths wouldn’t make sense in this context. If you pass vectors of unequal length to <code>data.frame</code>, then R will attempt to recycle any shorter vectors to match the longest, throwing your data off and potentially allocating observations to the wrong variable. Notice that data frames are printed to the console in rows and columns—they look more like a matrix than a named list. This natural spreadsheet style makes it easy to read and manipulate data sets. Each row in a data frame is called a <em>record</em>, and each column is a <em>variable</em>.</p>&#13;
<p class="indent">You can extract portions of the data by specifying row and column index positions (much as with a matrix). Here’s an example:</p>&#13;
<pre>R&gt; mydata[2,2]<br/>[1] 40</pre>&#13;
<p class="indent">This gives you the element at row 2, column 2—the age of Lois. Now extract the third, fourth, and fifth elements of the third column:</p>&#13;
<pre>R&gt; mydata[3:5,3]<br/>[1] F M M<br/>Levels: F M</pre>&#13;
<p class="indent">This returns a factor vector with the sex of Meg, Chris, and Stewie. The following extracts the entire third and first columns (in that order):</p>&#13;
<pre>R&gt; mydata[,c(3,1)]<br/>  sex person<br/>1   M  Peter<br/>2   F   Lois<br/>3   F    Meg<br/><span epub:type="pagebreak" id="page_97"/>4   M  Chris<br/>5   M Stewie</pre>&#13;
<p class="indent">This results in another data frame giving the sex and then the name of each person.</p>&#13;
<p class="indent">You can also use the names of the vectors that were passed to <code>data.frame</code> to access variables even if you don’t know their column index positions, which can be useful for large data sets. You use the same dollar operator you used for member-referencing named lists.</p>&#13;
<pre>R&gt; mydata$age<br/>[1] 42 40 17 14  1</pre>&#13;
<p class="indent">You can subset this returned vector, too:</p>&#13;
<pre>R&gt; mydata$age[2]<br/>[1] 40</pre>&#13;
<p class="indent">This returns the same thing as the earlier call of <code>mydata[2,2]</code>.</p>&#13;
<p class="indent">You can report the size of a data frame—the number of records and variables—just as you’ve seen for the dimensions of a matrix (first shown in <a href="ch03.xhtml#ch03lev2sec26">Section 3.1.3</a>).</p>&#13;
<pre>R&gt; nrow(mydata)<br/>[1] 5<br/>R&gt; ncol(mydata)<br/>[1] 3<br/>R&gt; dim(mydata)<br/>[1] 5 3</pre>&#13;
<p class="indent">The <code>nrow</code> function retrieves the number of rows (records), <code>ncol</code> retrieves the number of columns (variables), and <code>dim</code> retrieves both.</p>&#13;
<p class="indent">R’s default behavior for character vectors passed to <code>data.frame</code> is to convert each variable into a factor object. Observe the following:</p>&#13;
<pre>R&gt; mydata$person<br/>[1] Peter  Lois  Meg     Chris  Stewie<br/>Levels: Chris Lois Meg Peter Stewie</pre>&#13;
<p class="indent">Notice that this variable has levels, which shows it’s being treated as a factor. But this isn’t what you intended when you defined <code>mydata</code> earlier—you explicitly defined <code>sex</code> to be a factor but left <code>person</code> as a vector of character strings. To prevent this automatic conversion of character strings to factors when using <code>data.frame</code>, set the optional argument <code>stringsAsFactors</code> to <code>FALSE</code> (otherwise, it defaults to <code>TRUE</code>). Reconstructing <code>mydata</code> with this in place looks like this:</p>&#13;
<pre>R&gt; mydata &lt;- data.frame(person=c("Peter","Lois","Meg","Chris","Stewie"),<br/>                        age=c(42,40,17,14,1),<br/><span epub:type="pagebreak" id="page_98"/>                        sex=factor(c("M","F","F","M","M")),<br/>                        stringsAsFactors=FALSE)<br/>R&gt; mydata<br/>  person age sex<br/>1  Peter  42   M<br/>2   Lois  40   F<br/>3    Meg  17   F<br/>4  Chris  14   M<br/>5 Stewie   1   M<br/>R&gt; mydata$person<br/>[1] "Peter"  "Lois"   "Meg"   "Chris"  "Stewie"</pre>&#13;
<p class="indent">You now have <code>person</code> in the desired, nonfactor form.</p>&#13;
<h4 class="h4" id="ch05lev2sec53"><strong><em>5.2.2 Adding Data Columns and Combining Data Frames</em></strong></h4>&#13;
<p class="noindent">Say you want to add data to an existing data frame. This could be a set of observations for a new variable (adding to the number of columns), or it could be more records (adding to the number of rows). Once again, you can use some of the functions you’ve already seen applied to matrices.</p>&#13;
<p class="indent">Recall the <code>rbind</code> and <code>cbind</code> functions from <a href="ch03.xhtml#ch03lev2sec25">Section 3.1.2</a>, which let you append rows and columns, respectively. These same functions can be used to extend data frames intuitively. For example, suppose you had another record to include in <code>mydata</code>: the age and sex of another individual, Brian. The first step is to create a new data frame that contains Brian’s information.</p>&#13;
<pre>R&gt; newrecord &lt;- data.frame(person="Brian",age=7,<br/>                           sex=factor("M",levels=levels(mydata$sex)))<br/>R&gt; newrecord<br/>  person age sex<br/>1  Brian   7   M</pre>&#13;
<p class="indent">To avoid any confusion, it’s important to make sure the variable names and the data types match the data frame you’re planning to add this to. Note that for a factor, you can extract the levels of the existing factor variable using <code>levels</code>.</p>&#13;
<p class="indent">Now, you can simply call the following:</p>&#13;
<pre>R&gt; mydata &lt;- rbind(mydata,newrecord)<br/>R&gt; mydata<br/>  person age sex<br/>1  Peter  42   M<br/>2   Lois  40   F<br/>3    Meg  17   F<br/>4  Chris  14   M<br/>5 Stewie   1   M<br/>6  Brian   7   M</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_99"/>Using <code>rbind</code>, you combined <code>mydata</code> with the new record and overwrote <code>mydata</code> with the result.</p>&#13;
<p class="indent">Adding a variable to a data frame is also quite straightforward. Let’s say you’re now given data on the classification of how funny these six individuals are, defined as a “degree of funniness.” The degree of funniness can take three possible values: <code>Low</code>, <code>Med</code> (medium), and <code>High</code>. Suppose Peter, Lois, and Stewie have a high degree of funniness, Chris and Brian have a medium degree of funniness, and Meg has a low degree of funniness. In R, you’d have a factor vector like this:</p>&#13;
<pre>R&gt; funny &lt;- c("High","High","Low","Med","High","Med")<br/>R&gt; funny &lt;- factor(x=funny,levels=c("Low","Med","High"))<br/>R&gt; funny<br/>[1] High High Low  Med  High Med<br/>Levels: Low Med High</pre>&#13;
<p class="indent">The first line creates the basic character vector as <code>funny</code>, and the second line overwrites <code>funny</code> by turning it into a factor. The order of these elements must correspond to the records in your data frame. Now, you can simply use <code>cbind</code> to append this factor vector as a column to the existing <code>mydata</code>.</p>&#13;
<pre>R&gt; mydata &lt;- cbind(mydata,funny)<br/>R&gt; mydata<br/>  person age sex funny<br/>1  Peter  42   M  High<br/>2   Lois  40   F  High<br/>3    Meg  17   F   Low<br/>4  Chris  14   M   Med<br/>5 Stewie   1   M  High<br/>6  Brian   7   M   Med</pre>&#13;
<p class="indent">The <code>rbind</code> and <code>cbind</code> functions aren’t the only ways to extend a data frame. One useful alternative for adding a variable is to use the dollar operator, much like adding a new member to a named list, as in <a href="ch05.xhtml#ch05lev2sec51">Section 5.1.3</a>. Suppose now you want to add another variable to <code>mydata</code> by including a column with the age of the individuals in months, not years, calling this new variable <code>age.mon</code>.</p>&#13;
<pre>R&gt; mydata$age.mon &lt;- mydata$age*12<br/>R&gt; mydata<br/>  person age sex funny age.mon<br/>1  Peter  42   M  High     504<br/>2   Lois  40   F  High     480<br/>3    Meg  17   F   Low     204<br/>4  Chris  14   M   Med     168<br/>5 Stewie   1   M  High      12<br/>6  Brian   7   M   Med      84</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_100"/>This creates a new <code>age.mon</code> column with the dollar operator and at the same time assigns it the vector of ages in years (already stored as <code>age</code>) multiplied by 12.</p>&#13;
<h4 class="h4" id="ch05lev2sec54"><strong><em>5.2.3 Logical Record Subsets</em></strong></h4>&#13;
<p class="noindent">In <a href="ch04.xhtml#ch04lev2sec41">Section 4.1.5</a>, you saw how to use logical flag vectors to subset data structures. This is a particularly useful technique with data frames, where you’ll often want to examine a subset of entries that meet certain criteria. For example, when working with data from a clinical drug trial, a researcher might want to examine the results for just male participants and compare them to the results for females. Or the researcher might want to look at the characteristics of individuals who responded most positively to the drug.</p>&#13;
<p class="indent">Let’s continue to work with <code>mydata</code>. Say you want to examine all records corresponding to males. From <a href="ch04.xhtml#ch04lev2sec46">Section 4.3.1</a>, you know that the following line will identify the relevant positions in the <code>sex</code> factor vector:</p>&#13;
<pre>R&gt; mydata$sex=="M"<br/>[1]  TRUE FALSE FALSE  TRUE  TRUE  TRUE</pre>&#13;
<p class="indent">This flags the male records. You can use this with the matrix-like syntax you saw in <a href="ch05.xhtml#ch05lev2sec52">Section 5.2.1</a> to get the male-only subset.</p>&#13;
<pre>R&gt; mydata[mydata$sex=="M",]<br/>  person age sex funny age.mon<br/>1  Peter  42   M  High     504<br/>4  Chris  14   M   Med     168<br/>5 Stewie   1   M  High      12<br/>6  Brian   7   M   Med      84</pre>&#13;
<p class="indent">This returns data for all variables for only the male participants. You can use the same behavior to pick and choose which variables to return in the subset. For example, since you know you are selecting the males only, you could omit <code>sex</code> from the result using a negative numeric index in the column dimension.</p>&#13;
<pre>R&gt; mydata[mydata$sex=="M",-3]<br/>  person age funny age.mon<br/>1  Peter  42  High     504<br/>4  Chris  14   Med     168<br/>5 Stewie   1  High      12<br/>6  Brian   7   Med      84</pre>&#13;
<p class="indent">If you don’t have the column number or if you want to have more control over the returned columns, you can use a character vector of variable names instead.</p>&#13;
<pre><span epub:type="pagebreak" id="page_101"/>R&gt; mydata[mydata$sex=="M",c("person","age","funny","age.mon")]<br/>  person age funny age.mon<br/>1  Peter  42  High     504<br/>4  Chris  14   Med     168<br/>5 Stewie   1  High      12<br/>6  Brian   7   Med      84</pre>&#13;
<p class="indent">The logical conditions you use to subset a data frame can be as simple or as complicated as you need them to be. The logical flag vector you place in the square brackets just has to match the number of records in the data frame. Let’s extract from <code>mydata</code> the full records for individuals who are more than 10 years old OR have a high degree of funniness.</p>&#13;
<pre>R&gt; mydata[mydata$age&gt;10|mydata$funny=="High",]<br/>  person age sex funny age.mon<br/>1  Peter  42   M  High     504<br/>2   Lois  40   F  High     480<br/>3    Meg  17   F   Low     204<br/>4  Chris  14   M   Med     168<br/>5 Stewie   1   M  High      12</pre>&#13;
<p class="indent">Sometimes, asking for a subset will yield no records. In this case, R returns a data frame with zero rows, which looks like this:</p>&#13;
<pre>R&gt; mydata[mydata$age&gt;45,]<br/>[1] person  age     sex     funny   age.mon<br/>&lt;0 rows&gt; (or 0-length row.names)</pre>&#13;
<p class="indent">In this example, no records are returned from <code>mydata</code> because there are no individuals older than 45. To check whether a subset will contain any records, you can use <code>nrow</code> on the result—if this is equal to zero, then no records have satisfied the specified condition(s).</p>&#13;
<div class="ex">&#13;
<p class="ext"><a id="ch5exc2"/><strong>Exercise 5.2</strong></p>&#13;
<ol type="a">&#13;
<li><p class="noindents">Create and store this data frame as <code>dframe</code> in your R workspace:</p>&#13;
<table class="topbot1">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><code><span class="codestrong">person</code></span></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><code><span class="codestrong">sex</code></span></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><code><span class="codestrong">funny</code></span></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>Stan</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>M</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>High</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>Francine</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>F</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>Med</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>Steve</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>M</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>Low</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>Roger</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>M</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>High</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>Hayley</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>F</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>Med</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>Klaus</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>M</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>Med</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_102"/>The variables <code>person</code>, <code>sex</code>, and <code>funny</code> should be identical in nature to the variables in the <code>mydata</code> object studied throughout <a href="ch05.xhtml#ch05lev1sec20">Section 5.2</a>. That is, <code>person</code> should be a character vector, <code>sex</code> should be a factor with levels <code>F</code> and <code>M</code>, and <code>funny</code> should be a factor with levels <code>Low</code>, <code>Med</code>, and <code>High</code>.</p></li>&#13;
<li><p class="noindents">Stan and Francine are 41 years old, Steve is 15, Hayley is 21, and Klaus is 60. Roger is extremely old—1,600 years. Append these data as a new numeric column variable in <code>dframe</code> called <code>age</code>.</p></li>&#13;
<li><p class="noindents">Use your knowledge of reordering the column variables based on column index positions to overwrite <code>dframe</code>, bringing it in line with <code>mydata</code>. That is, the first column should be <code>person</code>, the second column <code>age</code>, the third column <code>sex</code>, and the fourth column <code>funny</code>.</p></li>&#13;
<li><p class="noindents">Turn your attention to <code>mydata</code> as it was left after you included the <code>age.mon</code> variable in <a href="ch05.xhtml#ch05lev2sec53">Section 5.2.2</a>. Create a new version of <code>mydata</code> called <code>mydata2</code> by deleting the <code>age.mon</code> column.</p></li>&#13;
<li><p class="noindents">Now, combine <code>mydata2</code> with <code>dframe</code>, naming the resulting object <code>mydataframe</code>.</p></li>&#13;
<li><p class="noindents">Write a single line of code that will extract from <code>mydataframe</code> just the names and ages of any records where the individual is female and has a level of funniness equal to <code>Med</code> OR <code>High</code>.</p></li>&#13;
<li><p class="noindents">Use your knowledge of handling character strings in R to extract all records from <code>mydataframe</code> that correspond to people whose names start with <em>S</em>. Hint: Recall <code>substr</code> from <a href="ch04.xhtml#ch04lev2sec45">Section 4.2.4</a> (note that <code>substr</code> can be applied to a vector of multiple character strings).</p></li>&#13;
</ol>&#13;
</div>&#13;
<h5 class="h5" id="ch05lev3sec12"><strong>Important Code in This Chapter</strong></h5>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Function/operator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Brief description</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>First occurrence</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>list</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Create a list</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch05.xhtml#ch05lev2sec49">Section 5.1.1</a>, <a href="ch05.xhtml#page_89">p. 89</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>[[ ]]</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Unnamed member reference</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch05.xhtml#ch05lev2sec49">Section 5.1.1</a>, <a href="ch05.xhtml#page_90">p. 90</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>[ ]</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">List slicing (multiple members)</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch05.xhtml#ch05lev2sec49">Section 5.1.1</a>, <a href="ch05.xhtml#page_91">p. 91</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>$</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Get named member/variable</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch05.xhtml#ch05lev2sec50">Section 5.1.2</a>, <a href="ch05.xhtml#page_92">p. 92</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>data.frame</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Create a data frame</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch05.xhtml#ch05lev2sec52">Section 5.2.1</a>, <a href="ch05.xhtml#page_96">p. 96</a></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><code>[ , ]</code></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Extract data frame row/columns</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><a href="ch05.xhtml#ch05lev2sec52">Section 5.2.1</a>, <a href="ch05.xhtml#page_96">p. 96</a></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</body></html>