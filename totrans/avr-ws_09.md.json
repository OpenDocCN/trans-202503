["```\n\n     #include <avr/eeprom.h>\n\n```", "```\n\n     eeprom_write_byte((uint8_t*)\n     `a, b` \n     );\n\n```", "```\n\n     eeprom_update_byte((uint8_t*)\n     `a, b` \n     );\n\n```", "```\n\n     uint8_t\n     `i` \n     = eeprom_read_byte((uint8_t*)\n     `a` \n     );\n\n```", "```\n\n     // Project 38 - Experimenting with the ATtiny85's EEPROM\n\n     #include <avr/io.h>\n\n     #include <util/delay.h>\n\n     ❶ #include <avr/eeprom.h>\n\n     int main(void)\n\n     {\n\n     DDRB = 0b00001111; // Set PORTB3–0 to output for LEDs\n\n     int a;\n\n     while (1)\n\n     {\n\n     // Write 0–15 to locations 0-15\n\n     for (a=0; a<16; a++)\n\n     {\n\n     ❷ eeprom_update_byte((uint8_t*)a, a);\n\n     }\n\n     // Read locations 0-15, display data on LEDs\n\n     for (a=0; a<16; a++)\n\n     {\n\n     ❸ PORTB = eeprom_read_byte((uint8_t*)a);\n\n     _delay_ms(250);\n\n     }\n\n     // Turn off LEDs\n\n     PORTB = 0b00000000;\n\n     }\n\n     }\n\n```", "```\n\n     #include <avr/eeprom.h>\n\n```", "```\n\n     eeprom_write_word((uint16_t*)\n     `a, b` \n     );\n\n```", "```\n\n     eeprom_update_word((uint16_t*)\n     `a, b` \n     );\n\n```", "```\n\n     uint16_t\n     `i` \n     = eeprom_read_word((uint16_t*)\n     `a` \n     );\n\n     // For values between 0 and 65535\n\n     int16_t\n     `i` \n     = eeprom_read_word((int16_t*)\n     `a` \n     );\n\n     // For values between -32768 and 32767\n\n```", "```\n\n      // Project 39 - A Simple EEPROM Datalogger\n\n      #include <avr/io.h>\n\n      #include <util/delay.h>\n\n      #include <avr/eeprom.h>\n\n      #include <math.h>\n\n      #include <stdio.h>\n\n      #include <stlib.h>\n\n      #define USART_BAUDRATE 4800\n\n      #define UBRR_VALUE 12\n\n      ❶ #define logDelay 1000\n\n      char newline[4] = \"\\r\\n\";\n\n      ❷ void USARTInit(void)\n\n      {\n\n      // Set baud rate registers\n\n      UBRR0H = (uint8_t)(UBRR_VALUE>>8);\n\n      UBRR0L = (uint8_t)UBRR_VALUE;\n\n      // Set data type to 8 data bits, no parity, 1 stop bit\n\n      UCSR0C |= (1<<UCSZ01)|(1<<UCSZ00);\n\n      // Enable transmission and reception\n\n      UCSR0B |= (1<<RXEN0)|(1<<TXEN0);\n\n      }\n\n      ❸ void USARTSendByte(unsigned char u8Data)\n\n      {\n\n      // Wait while previous byte is sent\n\n      while(!(UCSR0A&(1<<UDRE0))){};\n\n      // Transmit data\n\n      UDR0 = u8Data;\n\n      }\n\n      ❹ uint8_t USARTReceiveByte()\n\n      // Receives a byte of data from the computer into the USART register\n\n      {\n\n      // Wait for byte from computer\n\n      while(!(UCSR0A&(1<<RXC0))){};\n\n      // Return byte\n\n      return UDR0;\n\n      }\n\n      ❺ void sendString(char myString[])\n\n      {\n\n      uint8_t a = 0;\n\n      while (myString[a])\n\n      {\n\n      USARTSendByte(myString[a]);\n\n      a++;\n\n      }\n\n      }\n\n      ❻ void logData()\n\n      {\n\n      uint16_t portData = 0;\n\n      uint16_t location = 0;\n\n      char z1[] =  \"Logging data . . .\";\n\n      sendString(z1);\n\n      for (location=0; location<1024; location++)\n\n      {\n\n      if (PINB == 0b0000001) // If PORTB0 is HIGH\n\n      {\n\n      eeprom_update_word((uint16_t*)location, 1);\n\n      } else\n\n      {\n\n      eeprom_update_word((uint16_t*)location, 0);\n\n      }\n\n      location++;            // Skip an EEPROM location as we're using words\n\n      USARTSendByte(‘.’);\n\n      _delay_ms(logDelay);\n\n      }\n\n      sendString(newline);\n\n      }\n\n      ❼ void dumpData()\n\n      {\n\n      uint8_t portData = 0;\n\n      uint16_t location = 0;\n\n      char t[10] = \"\";         // For our dtostrf\n\n      char z1[] = \"Dumping data . . .\";\n\n      sendString(z1);\n\n      sendString(newline);\n\n      for (location=0; location<1024; location++)\n\n      {\n\n      // Retrieve data from EEPROM location\n\n      portData=eeprom_read_word((uint16_t*)location);\n\n      dtostrf((float)portData,12,0,t);\n\n      sendString(t);\n\n      sendString(newline);\n\n      location++;        // Skip an EEPROM location as we're using words\n\n      }\n\n      sendString(newline);\n\n      }\n\n      ❽ void eraseData()\n\n      {\n\n      uint16_t location = 0;\n\n      char msg2[] = \"Erasing data . . .\";\n\n      char msg3[] = \" finished.\";\n\n      sendString(msg2);\n\n      for (location=0; location<1024; location++)\n\n      {\n\n      eeprom_write_byte((uint16_t*)location, 0); // Write 0 to EEPROM location\n\n      USARTSendByte(‘*’);\n\n      }\n\n      sendString(msg3);\n\n      sendString(newline);\n\n      }\n\n      int main(void)\n\n      {\n\n      DDRB = 0b11111111;        // Set PORTB0 as input\n\n      char msg1[44] = \"Enter 1 to start, 2 to dump, 3 to erase: \";\n\n      uint8_t option;\n\n      USARTInit();\n\n      while (1)\n\n      {\n\n      ❾ sendString(msg1);\n\n      option = USARTReceiveByte();\n\n      USARTSendByte(option);\n\n      sendString(newline);\n\n      switch (option)\n\n      {\n\n      case 49 : logData(); break;\n\n      case 50 : dumpData(); break;\n\n      case 51 : eraseData(); break;\n\n      }\n\n      }\n\n      }\n\n```", "```\n\n     #include <avr/eeprom.h>\n\n```", "```\n\n     eeprom_write_float((float*)\n     `a, b` \n     );\n\n```", "```\n\n     eeprom_update_float((float*)\n     `a, b` \n     );\n\n```", "```\n\n     float\n     `i` \n     = eeprom_read_float((float*)\n     `a` \n     );\n\n```", "```\n\n      // Project 40 - Temperature Logger with EEPROM\n\n      #include <avr/io.h>\n\n      #include <util/delay.h>\n\n      #include <avr/eeprom.h>\n\n      #include <math.h>\n\n      #include <stdio.h>\n\n      #define USART_BAUDRATE 4800\n\n      #define UBRR_VALUE 12\n\n      ❶ #define logDelay 1000\n\n      char newline[4] = \"\\r\\n\";\n\n      ❷ void startADC()\n\n      // Set up the ADC\n\n      {\n\n      ADMUX |= (1 << REFS0);                 // Use AVcc pin with ADC\n\n      ADMUX |= (1 << MUX2) | (1 << MUX0);    // Use ADC5 (pin 28)\n\n      ADCSRA |= (1 << ADPS1) | (1 << ADPS0); // Prescaler for 1MHz (/8)\n\n      ADCSRA |= (1 << ADEN);                 // Enable ADC\n\n      }\n\n      ❸ void USARTInit(void)\n\n      {\n\n      // Set baud rate registers\n\n      UBRR0H = (uint8_t)(UBRR_VALUE>>8);\n\n      UBRR0L = (uint8_t)UBRR_VALUE;\n\n      // Set data type to 8 data bits, no parity, 1 stop bit\n\n      UCSR0C |= (1<<UCSZ01)|(1<<UCSZ00);\n\n      // Enable transmission and reception\n\n      UCSR0B |= (1<<RXEN0)|(1<<TXEN0);\n\n      }\n\n      void USARTSendByte(unsigned char u8Data)\n\n      {\n\n      // Wait while previous byte is sent\n\n      while(!(UCSR0A&(1<<UDRE0))){};\n\n      // Transmit data\n\n      UDR0 = u8Data;\n\n      }\n\n      uint8_t USARTReceiveByte()\n\n      // Receives a byte of data from the computer into the USART register\n\n      {\n\n      // Wait for byte from computer\n\n      while(!(UCSR0A&(1<<RXC0))){};\n\n      // Return byte\n\n      return UDR0;\n\n      }\n\n      void sendString(char myString[])\n\n      {\n\n      uint8_t a = 0;\n\n      while (myString[a])\n\n      {\n\n      USARTSendByte(myString[a]);\n\n      a++;\n\n      }\n\n      }\n\n      ❹ float readTemperature()\n\n      {\n\n      float temperature;\n\n      float voltage;\n\n      uint8_t ADCvalue;\n\n      // Get reading from TMP36 via ADC\n\n      ADCSRA |= (1 << ADSC);         // Start ADC measurement\n\n      while (ADCSRA & (1 << ADSC) ); // Wait until conversion is complete\n\n      _delay_ms(10);\n\n      // Get value from ADC register, place in ADCvalue\n\n      ADCvalue = ADC;\n\n      // Convert reading to temperature value (Celsius)\n\n      voltage = (ADCvalue * 5);\n\n      voltage = voltage / 1024;\n\n      temperature = ((voltage - 0.5) * 100);\n\n      return temperature;\n\n      }\n\n      ❺ void logData()\n\n      {\n\n      float portData = 0;\n\n      uint16_t location = 0;\n\n      char z1[] =  \"Logging data . . .\";\n\n      sendString(z1);\n\n      for (location=0; location<1021; location=location+4)\n\n      {\n\n      portData=readTemperature();\n\n      eeprom_update_float((float*)location,portData);\n\n      USARTSendByte(‘.’);\n\n      }\n\n      sendString(newline);\n\n      _delay_ms(logDelay);\n\n      }\n\n      ❻ void dumpData()\n\n      {\n\n      float portData = 0;\n\n      uint16_t location = 0;\n\n      char t[10] = \"\";                 // For our dtostrf\n\n      char msg1[14] = \"Temperature: \"; // Make sure you have \" instead of \"\n\n      char msg2[12] = \" degrees C \";\n\n      char msg3[] = \"Dumping data . . .\";\n\n      char msg4[] = \". . . finished.\";\n\n      sendString(msg3);\n\n      sendString(newline);\n\n      for (location=0; location<1021; location=location+4)\n\n      {\n\n      sendString(msg1);\n\n      portData=eeprom_read_float((float*)location); // HERE\n\n      dtostrf(portData,8,4,t);\n\n      sendString(t);\n\n      sendString(msg2);\n\n      sendString(newline);\n\n      }\n\n      sendString(msg4);\n\n      sendString(newline);\n\n      }\n\n      ❼ void eraseData()\n\n      {\n\n      int16_t location = 0;\n\n      char msg1[] = \"Erasing data . . .\";\n\n      char msg2[] = \" finished.\";\n\n      sendString(msg1);\n\n      for (location=0; location<1024; location++)\n\n      {\n\n      eeprom_write_byte((uint8_t*)location, 0);\n\n      USARTSendByte(‘*’);\n\n      }\n\n      sendString(msg2);\n\n      sendString(newline);\n\n      }\n\n      int main(void)\n\n      {\n\n      ❽ char msg1[44] = \"Enter 1 to start, 2 to dump, 3 to erase: \";\n\n      uint8_t option;\n\n      DDRD = 0b00000000;               // Set PORTD to inputs\n\n      startADC();\n\n      USARTInit();\n\n      while (1)\n\n      {\n\n      sendString(msg1);\n\n      option = USARTReceiveByte();\n\n      USARTSendByte(option);\n\n      sendString(newline);\n\n      switch (option)\n\n      {\n\n      case 49 : logData(); break;\n\n      case 50 : dumpData(); break;\n\n      case 51 : eraseData(); break;\n\n      }\n\n      }\n\n      }\n\n```"]