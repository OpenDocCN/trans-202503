<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="189" id="Page_189"/>6</span><br/>
<span class="ChapterTitle">Bench Time: Fault Injection Lab</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">Fault injection is a wonderful method of attacking embedded systems, and this chapter focuses on its practical aspects. We describe not only how to perform the actual injection, but how to get started on your own. While you could perform fault injections on a huge world of devices, we concentrate on a few specific examples here.</p>
<p>We present our fault injection attacks in three acts, and these acts will be relatively reproducible. With the same hardware, you should expect to be able to achieve the given results. The first act demonstrates how to use a spark to inject a fault into a device. We write a program that includes a simple loop and then show how to inject a glitch into the loop. The second act applies two different fault injection methods: crowbar injection and mux (multiplexor) injection. Finally, the third act applies fault injection to corrupt the otherwise perfect and secure math that underpins modern cryptography.</p>
<p><span epub:type="pagebreak" title="190" id="Page_190"/><a href="#figure6-1" id="figureanchor6-1">Figure 6-1</a> is a diagram showing all of these acts (this same diagram appears in Chapter 4 as Figure 4-3).</p>
<figure>
<img src="image_fi/278748c06/f06001.png" alt="f06001"/>
<figcaption><p><a id="figure6-1">Figure 6-1</a>: The connections between PC, fault injector, and target</p></figcaption>
</figure>
<p>Remember when reading through the examples that all these acts will have the same components. A <em>target</em> will be running some code that we will insert the fault into, but the three acts will all use different targets. The <em>fault injector</em> will be how we insert the fault; we’ll show you a few different fault injectors as well in the different acts. Finally, a <em>PC</em> will be involved to monitor or control the entire operation.</p>
<p>The actual connections between devices will vary between the acts. In the first act, for example, we won’t need precise timing. This means the “trigger” signal in <a href="#figure6-1">Figure 6-1</a> may be optional; one of the fault injectors we’ll use won’t have any sort of trigger at all. In later acts, we’ll have more precise timing requirements, so the trigger signal will be used to delay the fault such that it is inserted at a very specific point in time.</p>
<h2 id="h1-278748c06-0001">Act 1: A Simple Loop</h2>
<p class="BodyFirst">We’ll start with the most basic glitch you can perform to show how you might start fault injection on a new target. A typical task when facing a new device is to run very simple loop code (see <a href="#listing6-1" id="listinganchor6-1">Listing 6-1</a>) on the target device.</p>
<pre><code>void glitch_infinite(void)
{
    char str[64];
    unsigned int k = 0;
    //Declared volatile to avoid optimizing away loop.
    //This also adds lots of SRAM access
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> volatile uint16_t i, j;
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> volatile uint32_t cnt;
    while(1) {
<span epub:type="pagebreak" title="191" id="Page_191"/>        cnt = 0;
      <span class="CodeAnnotationCode" aria-label="annotation3">3</span> trigger_high();
      <span class="CodeAnnotationCode" aria-label="annotation4">4</span> for(i = 0; i &lt; 200; i++){
            for(j = 0; j &lt; 200; j++){
                cnt++;
            }
        }
        trigger_low();
      <span class="CodeAnnotationCode" aria-label="annotation5">5</span> sprintf(str, "%lu %d %d %d\n", cnt, i, j, k++);
        uart_puts(str);
    }
}</code></pre>
<p class="CodeListingCaption"><a id="listing6-1">Listing 6-1</a>: This simple C code is a good first example to glitch.</p>
<p>This code has several features designed to make glitching easy. Three variables, at <span class="CodeAnnotation" aria-label="annotation1">1</span> and <span class="CodeAnnotation" aria-label="annotation2">2</span>, are declared <code>volatile</code>, providing lots of static RAM (SRAM) access and thereby an attack surface. An optional <code>trigger_high()</code> command <span class="CodeAnnotation" aria-label="annotation3">3</span> can be used to trigger external hardware to insert a glitch. The double-loop structure <span class="CodeAnnotation" aria-label="annotation4">4</span> offers many opportunities for glitching to affect the program. If a variable is corrupted or an instruction is skipped, the result will be that the variables <code>i</code>, <code>j</code>, and <code>cnt</code> could all have incorrect values. Their values are printed <span class="CodeAnnotation" aria-label="annotation5">5</span> so you can see the results of your fault injection.</p>
<p>The <code>cnt</code> variable is the most likely to be noticeably corrupted. If the value of <code>j</code> is corrupted, for example, it will be observed as a corrupt value only if the corruption happens to occur on the last iteration of the outer loop over <code>i</code>. This simple loop not only shows whether you’re injecting faults, but you also can see various types of faults by observing how the output changes.</p>
<p>You may need to modify the code in <a href="#listing6-1">Listing 6-1</a> slightly to compile on your target platform, but it’s designed to have minimal requirements besides a simple string print command.</p>
<p>How do you actually perform an attack on a simple loop? This is a lab chapter after all. We’ll show you three methods of performing the attack, all for around $50 worth of hardware, but you might already have some of the needed gear on hand anyway. The first method uses an Arduino as a target device and a BBQ lighter to insert a fault. The next two methods will be based on voltage glitching; we’ll show you how to generate a voltage glitch using both a crowbar and a multiplexor circuit. To drive these circuits, we’ll make use of the ChipWhisperer-Nano (or ChipWhisperer-Lite) in this lab, but you can drive the circuits from other pulse sources. Let’s get faultin’ (as they say).</p>
<h3 id="h2-278748c06-0001">A BBQ Lighter of Pain</h3>
<p class="BodyFirst">This method is probably the more dangerous one, but for absolute cheapness, it’s hard to beat. We need to compile the code from <a href="#listing6-1">Listing 6-1</a> onto an Arduino. That code is almost ready as is. You need to set up the serial port first, and then replace the <code>puts()</code> call with <code>Serial.write()</code>. You may want to adjust the loop iteration counters to make the output slower as well (see <a href="#figure6-2" id="figureanchor6-2">Figure 6-2</a>). The program also marks successful glitches for you.</p>
<span epub:type="pagebreak" title="192" id="Page_192"/><figure>
<img src="image_fi/278748c06/f06002.png" alt="f06002"/>
<figcaption><p><a id="figure6-2">Figure 6-2</a>: Implementing the code on an Arduino Metro Mini</p></figcaption>
</figure>
<p>We’re using the Arduino Metro Mini for this example, Adafruit part number 2590, because it has an ATmega328P in a QFN package. We need the QFN package because it has the least amount of material between the top of the chip surface (where we are generating our electromagnetic glitch pulse) and the die itself. An ATmega328P in a DIP package, for example, will be too thick, and you likely won’t have as much success, if any at all.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Warning</span></h2>
<p>	The Arduino is connected via USB to your computer, and you probably want to avoid damaging your computer, so let’s use a USB isolator.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The isolator on the right in <a href="#figure6-3" id="figureanchor6-3">Figure 6-3</a> is from Adafruit, part number 2107, but you could use any other isolator or even just an isolated serial port. The fault injection method also can easily damage your target device since you’ll be playing with very high voltages!</p>
<span epub:type="pagebreak" title="193" id="Page_193"/><figure>
<img src="image_fi/278748c06/f06003.png" alt="f06003"/>
<figcaption><p><a id="figure6-3">Figure 6-3</a>: An isolator from Adafruit (PCB on the right) and our target (PCB on the left)</p></figcaption>
</figure>
<p>Alright, enough warning. If you rip open a BBQ lighter, you will find the piezoelectric ignitor, as shown in <a href="#figure6-4" id="figureanchor6-4">Figure 6-4</a>.</p>
<figure>
<img src="image_fi/278748c06/f06004.png" alt="f06004"/>
<figcaption><p><a id="figure6-4">Figure 6-4</a>: A piezoelectric ignitor generates a high voltage.</p></figcaption>
</figure>
<p>This element generates a high voltage (careful not to shock yourself) when the plunger on the right end is depressed into the housing until a click is heard. If you carefully bend the high voltage wire (that is, the wire that would go to the BBQ lighter end) to be near the end cap, it will generate a spark. In our case, we’ve routed the two wires to make a small spark gap, maybe in the 0.5 mm to 2 mm range. The gap is held in place by some polyimide tape.</p>
<p>This alone is enough to provide a fault injection mechanism. We’ll try to force the spark to be generated somewhere “interesting” in our attack on an Arduino. The spark gap is placed above a surface mount Arduino package (see <a href="#figure6-5" id="figureanchor6-5">Figure 6-5</a>).</p>
<p>The polyimide tape (Adafruit part number 3057, and often sold under the Kapton brand name) on top of the chip insulates it. If the spark connects to the microcontroller pins, you’ll kill the device instantly, and if your isolator isn’t working or you exceed the voltage limits, you may also kill the computer.</p>
<span epub:type="pagebreak" title="194" id="Page_194"/><figure>
<img src="image_fi/278748c06/f06005.png" alt="f06005"/>
<figcaption><p><a id="figure6-5">Figure 6-5</a>: Polyimide tape helps (but doesn’t fully stop) our device from blowing up due to the high voltage.</p></figcaption>
</figure>
<p>Next, run the program and start sparking. With any luck, you’ll get some corrupted output, as shown on the screen in <a href="#figure6-2">Figure 6-2</a>. You also may see some resets if the overall counter resets back to zero. While still a bit of a fault, this is not the interesting kind of fault you’ll want. A reset means your fault is too powerful; try adding some spacing between the spark gap or changing the location.</p>
<p>This act has briefly shown how a simple loop and a spark can insert a fault into a device. Where timing is not important, such sparks can result in useful attacks. In Arun Magesh’s blog post “Bypassing Android MDM Using Electromagnetic Fault Injection by a Gas Lighter for $1.5,” this type of attack is used on a smartphone.</p>
<h2 id="h1-278748c06-0002">Act 2: Inserting Useful Glitches</h2>
<p class="BodyFirst">Maybe you aren’t willing to kill your target device or computer, in which case, you’ll need some more subtle fault injection methods. In this act, we describe using a fault injection attack on a read protection configuration word stored in flash in a device. If we manage to change this configuration word, it allows reading out flash contents we should normally not have access to.</p>
<p>The two less-aggressive-yet-not-less-effective fault injection methods we apply in this second act are crowbar glitching and mux (multiplexor) fault <span epub:type="pagebreak" title="195" id="Page_195"/>injection. We also introduce a new glitching target: the Olimex LPC-P1114 development board. The development board’s user manual will help you understand the modifications and interconnections we describe here.</p>
<p>The glitching method used in this act can achieve the same glitch using the simple loop test code in the Arduino microprocessor that we glitched in the previous section. If you want to test a glitch setup, we recommend starting with the simple loop code from <a href="#listing6-1">Listing 6-1</a> being compiled for the target. To avoid such repetition in this book, however, we’ll jump directly to the end goal, which is corruption of the security configuration. Now let’s walk through how to actually see some sort of useful glitch!</p>
<h3 id="h2-278748c06-0002">Crowbar Glitching to Fault a Configuration Word</h3>
<p class="BodyFirst">We’ll apply the crowbar glitching method to fault a configuration word on the microcontroller (see Chapter 5 for an introduction to crowbar glitching). This will build on Chris Gerlinsky’s presentation “Breaking Code Read Protection on the NXP LPC-Family Microcontrollers” (REcon Brussels 2017), which covered the initial work, including details of how the fault works and can be generated. Here, we show a slightly easier method of injecting the fault, which is to attach a “crowbar” across the power supply. This method has been demonstrated to work against a variety of devices, including more advanced targets like the Raspberry Pi and field-programmable gate array (FPGA) boards. For more details, see Colin O’Flynn’s “Fault Injection Using Crowbars on Embedded Systems” (IACR Cryptology ePrint Archive, 2016), which introduced the crowbar fault injection method.</p>
<p>The end goal is to attack the code read-protection, which is the mechanism that prevents someone from copying the binary code out of the device. In the LPC device, the code read-protection is a special word in memory that defines what level of protection the microcontroller has. These code read-protection bytes are part of the “option bytes” that contain various configurations for the microcontroller. <a href="#table6-1" id="tableanchor6-1">Table 6-1</a> lists the potential valid values for the option bytes as related to the code read-protection.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-1">Table 6-1</a>: Valid Values for the Option Bytes as Related to the Code Read-Protection</p></figcaption>
<table id="table-278748c06-0001" border="1">
<thead>
<tr>
<td><b>Mode</b></td>
<td>Option bytes value<b/></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>NO_ISP</td>
<td>0x4E697370</td>
<td>Disables the “ISP Entry” pin.</td>
</tr>
<tr>
<td>CRP1</td>
<td>0x12345678</td>
<td>SWD interface is disabled. Partial flash updates are allowed only via ISP.</td>
</tr>
<tr>
<td>CRP2</td>
<td>0x87654321</td>
<td>SWD interface is disabled. Must perform full chip erase before most other commands are available.</td>
</tr>
<tr>
<td>CRP3</td>
<td>0x43218765</td>
<td>SWD interface is disabled; ISP interface is disabled. Device is inaccessible unless user implements call to bootloader via alternate method.</td>
</tr>
<tr>
<td>UNLOCKED</td>
<td>Any other value</td>
<td>No protection enabled (full JTAG and bootloader access).</td>
</tr>
</tbody>
</table>
</figure>
<p><span epub:type="pagebreak" title="196" id="Page_196"/>The critical flaw in the design is that the “unlocked” level is the default, and only when the word is set to one of several specific values do you have code read-protection. This means if you were to corrupt the value of the code read-protection word in flash, you have no code protection at all! We can use a glitch to corrupt this value as it is being read from flash. Let’s see what you need for this.</p>
<h4 id="h3-278748c06-0001">Setting Up the Equipment</h4>
<p class="BodyFirst">First, we need a target device (mounted on a target board) on which to attempt to break the code read-protection, and, second, we need a tool capable of inserting the faults to cause the program to read a value incorrectly and remove the read-protection.</p>
<p><a href="#figure6-6" id="figureanchor6-6">Figure 6-6</a> shows a sample setup. The LPC1114 target board is at the top of the photograph, and the ChipWhisperer-Nano (used for performing fault injection) is at the bottom of the photograph, which is where you can see the interconnection between the two (more details on this interconnection shortly).</p>
<figure>
<img src="image_fi/278748c06/f06006.png" alt="f06006"/>
<figcaption><p><a id="figure6-6">Figure 6-6</a>: The LPC1114 processor target with a ChipWhisperer-Nano for performing fault injection</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="197" id="Page_197"/>Besides the ChipWhisperer-Nano providing the programming and timing of the injected fault, its only real feature we are using is a simple “crowbar” mechanism, which you could substitute if you wish to with an external MOSFET or similar.</p>
<h4 id="h3-278748c06-0002">ChipWhisperer-Nano vs. ChipWhisperer-Lite</h4>
<p class="BodyFirst">We’re using the ChipWhisperer-Nano due its lower cost ($50), even though it has more limited resolution on the glitch timing than what the ChipWhisperer-Lite ($250) has. The ChipWhisperer-Lite tends to be more reliable for this attack.</p>
<p>If you use the ChipWhisperer-Nano connected as shown in <a href="#figure6-6">Figure 6-6</a>, remember that the ChipWhisperer-Nano has a built-in STM32F0 microcontroller that’s used as a target. You can remove the target side (it’s designed to be scored and broken off), but the less-destructive option is simply to erase it. For the attack we are about to do, the physical presence of the STM32F0 target doesn’t affect our usage. We just need to ensure it’s not running code that would get in the way of our I/O lines.</p>
<p>Here’s a short example of how to do this in Python using the Jupyter Notebook interface (see the notebook for this chapter at <a href="https://nostarch.com/hardwarehacking/" class="LinkURL">https://nostarch.com/hardwarehacking/</a> for more detail):</p>
<pre><code>PLATFORM="CWNANO"
%run "Helper_Scripts/Setup_Generic.ipynb"
p = prog()
p.scope = scope
p.open() #Open and find attached STM32F0 target
p.find()
p.erase() #Erase it!
p.close()
target.dis()
scope.dis()</code></pre>
<p>In this case, we just erase the flash of the device using the bootloader interface to ensure the serial data lines are free. If we had code running on the ChipWhisperer-Nano target, it might corrupt our bootloader access.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	This example uses a Jupyter Notebook, and labs in later chapters will as well. Jupyter is simply an interface for executing Python code. It runs the code interactively, and you can view plotting and output inline. This feature makes it very handy for the sort of experimentation that we need to do when we aren’t running a program from start to end, because we might not be sure yet how the full program is going to even work. We can run portions of the program at once, for example. Any time we reference the Jupyter Notebook, we’re simply referring to Python code.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-278748c06-0003">Modifications and Interconnections</h4>
<p class="BodyFirst">The nice thing about this attack is how dead simple we can make it. We need to create a momentary short across the power supply to the LPC1114 target, so we make a few modifications on the LPC1114 development <span epub:type="pagebreak" title="198" id="Page_198"/>board’s PCB. Basically, we need a connection from the crowbar mechanism to the power rails, and we must remove the capacitors that otherwise would smooth out glitches on those power rails. We aim for a circuit, as shown in the schematic in <a href="#figure6-7" id="figureanchor6-7">Figure 6-7</a>.</p>
<figure>
<img src="image_fi/278748c06/f06007.png" alt="f06007"/>
<figcaption><p><a id="figure6-7">Figure 6-7</a>: Schematic showing part of the LPC1114 development kit</p></figcaption>
</figure>
<p>The schematic shows the GLITCH connection to indicate how we insert the fault. The actual Q1 component is built into the ChipWhisperer-Nano in the example we are providing, but if you want to implement this function separately, you could route the power to a similar fault injection module, <span epub:type="pagebreak" title="199" id="Page_199"/>such as a MOSFET driven by a signal generator. <a href="#figure6-8" id="figureanchor6-8">Figure 6-8</a> shows the physical implementation.</p>
<figure>
<img src="image_fi/278748c06/f06008.png" alt="f06008"/>
<figcaption><p><a id="figure6-8">Figure 6-8</a>: The LPC1114 development board modified for fault injection</p></figcaption>
</figure>
<p>The following list provides the step-by-step instructions for making the modifications on the development board shown in <a href="#figure6-8">Figure 6-8</a>:</p>
<ol class="decimal">
<li value="1">Remove the decoupling capacitor C4 <span class="CodeAnnotation" aria-label="annotation1">1</span>.</li>
<li value="2">Remove the decoupling capacitor C1 <span class="CodeAnnotation" aria-label="annotation2">2</span>.</li>
<li value="3">Disconnect the 3.3 V CORE_E VDD from the LPC1114 by cutting through trace jumper <span class="CodeAnnotation" aria-label="annotation3">3</span>.</li>
<li value="4">Disconnect the 3.3 V IO_E VDD from the LPC1114 by cutting through trace jumper <span class="CodeAnnotation" aria-label="annotation4">4</span>.</li>
<li value="5">Insert a 12 Ω resistor across the trace jumper <span class="CodeAnnotation" aria-label="annotation3">3</span>. The PCB power supply VDD now runs through this resistor to the LPC1114.</li>
<li value="6">Connect the “chip side” of the 3.3 V CORE_E VDD and 3.3 V IO_E VDD power supplies together using a link <span class="CodeAnnotation" aria-label="annotation5">5</span>, going from a pad of the trace jumper <span class="CodeAnnotation" aria-label="annotation4">4</span> and a pad of the capacitor placement C4 <span class="CodeAnnotation" aria-label="annotation1">1</span>.</li>
<li value="7">Connect the 3.3 V CORE_E VDD and 3.3 V IO_E VDD power supplies to a connector <span class="CodeAnnotation" aria-label="annotation7">7</span> together using a link <span class="CodeAnnotation" aria-label="annotation6">6</span> (here the connector is an SMA connector, but any type works).</li>
<li value="8">Set PIO0_1 to ground just by mounting the header at BLD_E <span class="CodeAnnotation" aria-label="annotation9">9</span>.</li>
<li value="9">Set PIO0_3 to GND, which requires soldering a wire (the short orange wire <span class="CodeAnnotation" aria-label="annotationa">a</span>) to ground.</li>
<li value="10">Add a three-pin header at <span class="CodeAnnotation" aria-label="annotation8">8</span> and route the RST connection to all of these three pins.</li>
<li value="11">Connect the nReset OUT line from the ChipWhisperer at J3-5 and the Trigger In line at J3-16 to the RST input on the development board with the header you mounted at <span class="CodeAnnotation" aria-label="annotation8">8</span>.</li>
<li value="12"><span epub:type="pagebreak" title="200" id="Page_200"/>Connect GND from the ChipWhisperer at J3-2 to pin UEXT-2 on the development board.</li>
<li value="13">Connect VCC from the ChipWhisperer at J3-3 to pin UEXT-1 on the development board.</li>
<li value="14">Connect TXD from the ChipWhisperer at J3-10 to pin UEXT-3 on the development board.</li>
<li value="15">Connect RXD from the ChipWhisperer at J3-12 to pin UEXT-4 on the development board.</li>
</ol>
<p><a href="#table6-2" id="tableanchor6-2">Table 6-2</a> provides a summary of the interconnections between the target and the ChipWhisperer-Nano. (You should also be able to determine the interconnections for a standalone type of attack from this list.)</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-2">Table 6-2</a>: Interconnections of ChipWhisperer-Nano Board to Glitch Generator</p></figcaption>
<table id="table-278748c06-0002" border="1">
<thead>
<tr>
<td><b>LPC1114 development board</b></td>
<td><b>ChipWhisperer-Nano</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>UEXT-1</td>
<td>J3-3</td>
<td>VCC</td>
</tr>
<tr>
<td>UEXT-2</td>
<td>J3-2</td>
<td>GND</td>
</tr>
<tr>
<td>UEXT-3</td>
<td>J3-10</td>
<td>TXD</td>
</tr>
<tr>
<td>UEXT-4</td>
<td>J3-12</td>
<td>RXD</td>
</tr>
<tr>
<td>RST</td>
<td>J3-5</td>
<td>Reset OUT</td>
</tr>
<tr>
<td>RST</td>
<td>J3-16</td>
<td>Trigger in</td>
</tr>
<tr>
<td>VCC_CORE</td>
<td>Glitch connector middle pin</td>
<td>VCC glitch inserted here</td>
</tr>
<tr>
<td>GND</td>
<td>Glitch connected side pin</td>
<td>Second GND (for glitch)</td>
</tr>
</tbody>
</table>
</figure>
<p>The RST line on the development board is both an output (gets toggled to reset the device) and an input (serves as a reference for when to insert the fault), which is required because the ChipWhisperer-Nano uses GPIO4 as the trigger input.</p>
<h4 id="h3-278748c06-0004">The Timing Is Everything</h4>
<p class="BodyFirst">As the LPC1114 device is coming out of reset, it will read the configuration word from flash memory, and we need to insert our fault at that moment. If we can corrupt the read of the memory, the device will come up as unlocked, which isn’t what the designer intended.</p>
<p>We use the reset pin to time the fault. The rising edge of the reset pin (since the reset is active-low) indicates when the boot sequence begins. If you were controlling everything from a single device (such as your own FPGA or microcontroller), you could, of course, time the glitch based on when you drove the reset pin high.</p>
<p>The reset pin tells us only when the device begins the boot process, but not the finishing time and not at what point the value of the code read-protection is fetched from flash memory. We’ll need to sweep the glitch <span epub:type="pagebreak" title="201" id="Page_201"/>insertion from the start of the boot until the boot is finished to target every possible clock cycle when the flash read could be happening.</p>
<p>While the reset pin gives us the starting time, we would like to have a finishing time when we know the device is finished booting (and if we didn’t break code protection by then, the glitch was clearly ineffective). To determine this “ending time,” we could write a simple program that toggles an I/O pin and load it onto the microcontroller. When the I/O pin starts toggling, we know the microcontroller is running our own code and the booting has completed.</p>
<p>The boot time is thus the time between the reset pin becoming inactive (going high) and the I/O pin toggling. Somewhere between the reset pin going high and the I/O pin toggling is when the microcontroller boot code must be reading the read-protect value from flash memory and acting on the value. Our glitch must be targeted somewhere in that time frame.</p>
<h4 id="h3-278748c06-0005">Bootloader Protocol</h4>
<p class="BodyFirst">To understand how to find a useful glitch, here’s a short primer on the bootloader in this device. We’ll use the bootloader to determine whether things are actually going according to plan.</p>
<p>The bootloader protocol is very simple. A serial protocol is used to communicate with the device, allowing us to experiment with the bootloader via a serial terminal. The communication works as follows: we send some setup information followed by a read/write to memory to load and verify code.</p>
<p>The protocol automatically determines the baud rate during the first character’s transfer. The rest of the setup confirms baud rate synchronization and informs the bootloader of the external crystal speed in case it’s needed for any additional setup. You can see some of the setup commands in the output example from <a href="#listing6-3" id="listinganchor6-3">Listing 6-3</a>, which we’ll look at next.</p>
<p>Several commands erase, read, and write memory, but we care only about a memory read attempt, because if the device is locked, a memory read will fail. We can perform a memory read with <code>R 0 4\r\n</code>, which attempts to read 4 bytes from address 0. If the device is locked, we’ll get a response of <code>19</code>, which is the error code for access not being allowed. Ultimately, we need to script a method of continuously testing to see whether the device is unlocked.</p>
<p>With that, we now need to corrupt the “option bytes” that store the code read-protection codes. They aren’t continuously checked, but they are read only upon reset. As mentioned, we need to time our attack from reset.</p>
<h4 id="h3-278748c06-0006">Device Setup</h4>
<p class="BodyFirst">First, we need to get communication working with the bootloader. While we could implement the entire bootloader protocol, instead we’re going to use an existing library called <code>nxpprog</code> (available at <a href="https://github.com/ulfen/nxpprog/" class="LinkURL">https://github.com/ulfen/nxpprog/</a>) that can talk to these devices.</p>
<p>The following examples reference the companion Jupyter Notebook provided as part of this book’s resources, which implements the full attack and provides required setup details. Suggested installation instructions also <span epub:type="pagebreak" title="202" id="Page_202"/>are available online. We’ll walk through the code and attack here, though, so you can see how it works without needing to install anything.</p>
<p>The <code>nxpprog</code> library requires the <code>isp_mode()</code>, <code>write()</code>, and <code>readline()</code> support functions. The <code>isp_mode()</code> function enters the in-system programming (ISP) mode by setting an entry pin and resetting the device. In this example, the ISP mode entry pin is soldered to GND to force ISP mode entry (refer to <a href="#figure6-8">Figure 6-8</a>). The <code>isp_mode()</code> function simply resets the device, which begins a new bootloader iteration. The other two functions talk on the serial port to the bootloader. If a ChipWhisperer device is used, this routes data out from the ChipWhisperer. See the Jupyter Notebook for more details on those functions.</p>
<p><a href="#listing6-2" id="listinganchor6-2">Listing 6-2</a> shows an example of attempting to connect to the device and read the output:</p>
<pre><code>nxpdev = CWDevice(scope, target, print_debug=True)

#Need to enter ISP mode before initializing programmer object
nxpdev.isp_mode()
nxpp = nxpprog.NXP_Programmer("lpc1114", nxpdev, 12000)

#Examples of stuff you can do:
print(nxpp.get_serial_number())
print(nxpp.read_block(0, 4))</code></pre>
<p class="CodeListingCaption"><a id="listing6-2">Listing 6-2</a>: Using <code>nxpprog</code> to connect and read memory</p>
<p><a href="#listing6-3">Listing 6-3</a> contains the expected output with debug information showing the serial port <code>read</code> and <code>write</code> instructions.</p>
<pre><code>Write: ?
Read: Synchronized
Write: b'Synchronized\r\n'
Read: Synchronized
Read: OK
Write: b'12000\r\n'
Read: 12000
Read: OK
Write: b'A 0\r\n'
Read: A 0
Read: 0
Write: b'U 23130\r\n'
Read: 0
Write: b'N\r\n'
Read: 0
Read: 218316836
Read: 2935817382
Read: 1480765853
Read: 4110424384
218316836 2935817382 1480765853 4110424384
Write: b'R 0 4\r\n'
Read: 19
<b>OSError</b>: 'R 0 4' error: 19 - CODE_READ_PROTECTION_ENABLED: Code read protection enabled</code></pre>
<p class="CodeListingCaption"><a id="listing6-3">Listing 6-3</a>: The output of running the <code>nxpprog</code> connect script from <a href="#listing6-2">Listing 6-2</a></p>
<p><span epub:type="pagebreak" title="203" id="Page_203"/>In this case, we get a <code>CODE_READ_PROTECTION_ENABLED</code> error, which is what we are looking for. If we had used a new development board, however, it wouldn’t yet have code read-protection enabled. This means in order to imitate the real world, we need to turn that on before we can continue with the tutorial.</p>
<p>The read-protect code bytes are located at address 0x2FC and consist of 4 bytes. To program the code protection, we need to erase an entire page of memory (4,096 bytes) and reprogram the new page with our configuration word set to enable read-protection. In a real situation, we would need to know what should be programmed in all other bytes in the page, but if we don’t need to run the code and instead are simply performing a proof of concept, we can program in zeros (or any other data).</p>
<p><a href="#listing6-4" id="listinganchor6-4">Listing 6-4</a> shows how the sample implementation defaults to opening the <em>lpc1114_first4096.bin</em> file:</p>
<pre><code>def set_crp(nxpp, value, image=None):
    """
    Set CRP value - requires the first 4096 bytes of FLASH due to
    page size!
    """

    if image is None:
        f = open(r"external/lpc1114_first4096.bin", "rb")
        image = f.read()
        f.close()

    image = list(image)
    image[0x2fc] = (value &gt;&gt; 0)  &amp; 0xff
    image[0x2fd] = (value &gt;&gt; 8)  &amp; 0xff
    image[0x2fe] = (value &gt;&gt; 16) &amp; 0xff
    image[0x2ff] = (value &gt;&gt; 24) &amp; 0xff

    print("Programming flash...")
    nxpp.prog_image(bytes(image), 0)
    print("Done!")</code></pre>
<p class="CodeListingCaption"><a id="listing6-4">Listing 6-4</a>: Erase and reprogram an entire page of memory.</p>
<p>If you don’t have this file, you could simply set the value of <code>image = [0]*4096</code>, which would overwrite the flash page with zeros (0s). This means the code will no longer run, but we don’t care about the code running; we care only about whether we can bypass the code read-protection.</p>
<p><a href="#listing6-5" id="listinganchor6-5">Listing 6-5</a> uses the data from <a href="#listing6-4">Listing 6-4</a> to lock the device so we can perform an attack as it would be done in the real world:</p>
<pre><code>nxpdev = CWDevice(scope, target, print_debug=True)

#Need to enter ISP mode before initializing programmer object
nxpdev.isp_mode()
nxpp = nxpprog.NXP_Programmer("lpc1114", nxpdev, 12000)
set_crp(nxpp, 0x12345678)</code></pre>
<p class="CodeListingCaption"><a id="listing6-5">Listing 6-5</a>: Locking the device using the ISP API interface</p>
<p><span epub:type="pagebreak" title="204" id="Page_204"/>Now that we have a locked device, we can begin to investigate further and scope our attack.</p>
<h4 id="h3-278748c06-0007">Using Power Analysis to Determine Fault Injection Timing</h4>
<p class="BodyFirst">In this case, we’re going to cheat and begin with a “good” power waveform to see around what time we should be inserting our glitch. <a href="#figure6-8">Figure 6-8</a> shows that we inserted a 12 Ω shunt resistor. Its function is not only to facilitate fault injection, but also to allow us to look at the power waveforms. In our crowbar attack example, we connect an oscilloscope across the shunt resistor and record the DC level of the power rail, as shown in the middle trace in <a href="#figure6-9" id="figureanchor6-9">Figure 6-9</a>.</p>
<figure>
<img src="image_fi/278748c06/f06009.png" alt="f06009"/>
<figcaption><p><a id="figure6-9">Figure 6-9</a>: Power rail traces while booting</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="205" id="Page_205"/>Halfway along this trace is the glitch that the crowbar injected. The bottom row shows a zoomed-in look at the variations on the power rail on either side of the glitch, which we call the power trace. The top row shows a trace of the LPC1114’s reset output. The variations in the power trace make it possible to see different operations executed on the CPU. The specific part that we want to interrupt is the process of loading the word that locks the flash from memory.</p>
<p>In this scenario, using the power trace is critical for understanding what sort of glitch parameters cause the device to misbehave. One thing we want to watch out for is too strong a glitch, which resets the device and restarts the device again; that would not be very informative for us!</p>
<p>Beyond looking at the power trace on an oscilloscope, <a href="#listing6-6" id="listinganchor6-6">Listing 6-6</a> shows a simple script that enables the ChipWhisperer-Nano to capture the power trace.</p>
<pre><code>import matplotlib.pylab as plt

#Enter ISP Mode
nxpdev.isp_mode()

#Sample at 20 MS/s (maximum for CW-Nano)
scope.adc.clk_freq = 20E6
scope.adc.samples = 2000

#Reset again and perform a power capture
scope.io.nrst = 'low'
scope.arm()
time.sleep(0.05)
scope.io.nrst = 'high'
scope.capture()

#Plot Waveform
trace = scope.get_last_trace()
plt.plot(trace)
plt.show()</code></pre>
<p class="CodeListingCaption"><a id="listing6-6">Listing 6-6</a>: Python script to capture boot power trace</p>
<p>The trace is shown in <a href="#figure6-10" id="figureanchor6-10">Figure 6-10</a>. The higher-end ChipWhisperer-Lite and ChipWhisperer-Pro will provide a more detailed power trace, but even this $50 ChipWhisperer-Nano has enough for us to see the details of the boot process.</p>
<span epub:type="pagebreak" title="206" id="Page_206"/><figure>
<img src="image_fi/278748c06/f06010.png" alt="f06010"/>
<figcaption><p><a id="figure6-10">Figure 6-10</a>: Power trace of the LPC1114’s boot process, as measured in <a href="#listing6-6">Listing 6-6</a></p></figcaption>
</figure>
<p>What does this information provide? First, it enables us to examine and characterize the effect of a potentially useful glitch. Second, we use the ChipWhisperer-Nano to trigger the glitch insertion by running the code in <a href="#listing6-7" id="listinganchor6-7">Listing 6-7</a> (if you’re using ChipWhisperer-Lite, see the companion notebook).</p>
<pre><code>#ChipWhisperer-Nano uses count of fixed-frequency oscillator, so these values
#don't directly correlate with the timing of the power analysis graphs.
scope.glitch.repeat = 15
scope.glitch.ext_offset = 1400</code></pre>
<p class="CodeListingCaption"><a id="listing6-7">Listing 6-7</a>: Turning on a glitch on the ChipWhisperer-Nano</p>
<p>In the code from <a href="#listing6-7">Listing 6-7</a>, the <code>scope.glitch.repeat</code> parameter is how many cycles the glitch is “applied” for (the glitch width from Chapter 5). The <code>scope.glitch.ext_offset</code> parameter is the offset from the trigger event until the glitch is inserted, which defines the timing of where the glitch occurs. The parameters are somewhat “unitless” here because the numbers represent a number of cycles’ delay based on the microcontroller’s internal oscillator. We rarely care about the “actual” values; we just want to be able to re-create them.</p>
<p>Once the <code>repeat</code> (glitch width) and <code>ext_offset</code> (glitch offset) settings are locked in, they will automatically be applied on the next trigger. If we run <a href="#listing6-6">Listing 6-6</a> again (after first having run <a href="#listing6-7">Listing 6-7</a>), we now get a power waveform with a glitch inserted at some point. <a href="#figure6-11" id="figureanchor6-11">Figure 6-11</a> shows the results.</p>
<p>In this example, it looks like we’re using too aggressive of a glitch inserted around clock cycle 250. The glitch is probably too wide. After the glitch is inserted, the device seems to have muted. The power trace no longer looks like it’s executing code, which is bad since we have probably tripped a brown-out detector or otherwise reset the device. We’ll need to adjust parameters and try again.</p>
<span epub:type="pagebreak" title="207" id="Page_207"/><figure>
<img src="image_fi/278748c06/f06011.png" alt="f06011"/>
<figcaption><p><a id="figure6-11">Figure 6-11</a>: A glitch inserted around cycle 250 has caused the device to reset.</p></figcaption>
</figure>
<p>Compare this to when we change the value of <code>scope.glitch.repeat</code> in <a href="#listing6-7">Listing 6-7</a>, setting the <code>repeat</code> to 10. <a href="#figure6-12" id="figureanchor6-12">Figure 6-12</a> shows the power trace.</p>
<figure>
<img src="image_fi/278748c06/f06012.png" alt="f06012"/>
<figcaption><p><a id="figure6-12">Figure 6-12</a>: A glitch inserted around cycle 250 has not interrupted the normal boot.</p></figcaption>
</figure>
<p>We still see the glitch inserted around cycle 250, but it seems that the device has continued to execute code! We want to sweep around glitch widths just between those that are too wide (causing a reset) and those that seem to let the device run as normal. This power analysis measurement allows us to characterize the board and understand what glitch widths we need for the next step. In this case, a width (<code>scope.glitch.repeat</code> setting) of 14 was about the upper limit before the device often would reset. This means for the sample board, we’d try widths in the range of 9 to 14 first (the lower end is somewhat arbitrary; you might need to reduce the lower end even further, but at some point, the glitch is too narrow and has no effect). Again, these units are relatively arbitrary; we don’t care about the exact measurement because we simply found the range between where the device reset and where the device seemed to operate normally. You may find these numbers vary on your target and setup. </p>
<p><span epub:type="pagebreak" title="208" id="Page_208"/>If you are trying to re-create this glitch insertion using some other signal generator besides the ChipWhisperer-Nano, you can easily check with an oscilloscope to see whether the device is resetting after your glitch or is continuing to boot. Using this method, it’s easy to tune the glitch parameters to reduce the search space.</p>
<p>In future chapters, we’ll look at power analysis and how to use it to show where in the device program certain values are being processed. Performing a “power analysis attack” is possible on the configuration word in that we can measure when these words are actually loaded. If you’re interested in seeing that code, the LPC1114 example as part of ChipWhisperer-Jupyter repository on GitHub (<a href="https://github.com/newaetech/chipwhisperer-jupyter/" class="LinkURL">https://github.com/newaetech/chipwhisperer-jupyter/</a>) goes into more details.</p>
<h4 id="h3-278748c06-0008">From Fault Attack to Memory Dump</h4>
<p class="BodyFirst">Now that we can see the device booting, we are basically ready to insert a fault. All we’ll do is make a script to sweep the timing of the glitch and see whether the device comes up as unlocked. If the device does come up unlocked, we can take the full step of dumping the entire flash memory.</p>
<p><a href="#listing6-8" id="listinganchor6-8">Listing 6-8</a> shows the important parts (see the Jupyter Notebook for the full example). Here we specify an offset range that we can sweep along to find the useful information. You should know that the 100 percent success of the code depends on your physical connections; you may need to run this multiple times before it works. We’ve also cheated by giving a very narrow range of the offset, which helps by allowing us to repeat the attack multiple times.</p>
<pre><code>import time
print("Attempting to glitch LPC Target")

nxpdev = CWDevice(scope, target)

Range = namedtuple("Range", ["min", "max", "step"])

# Empirically these seemed to work OK, we want to hit around
# time 51.8 to 51.9 μs from reset. CW-Nano doesn't have as meaningful
# timebase as CW-Lite, so we just sweep larger ranges...
offset_range = Range(5600, 6050, 1)
repeat_range = Range(9, 15, 1)

scope.glitch.repeat = repeat_range.min

done = False
while done == False:
    scope.glitch.ext_offset = offset_range.min
    if scope.glitch.repeat &gt;= repeat_range.max:
        scope.glitch.repeat = repeat_range.min
    while scope.glitch.ext_offset &lt; offset_range.max:

        scope.io.nrst = 'low'
        time.sleep(0.05)
        scope.arm()
<span epub:type="pagebreak" title="209" id="Page_209"/>        scope.io.nrst = 'high'
        target.ser.flush()

        print("Glitch offset %4d, width %d........"%
                (scope.glitch.ext_offset, scope.glitch.repeat), end="")

        time.sleep(0.05)
        try:
            nxpp = nxpprog.NXP_Programmer("lpc1114", nxpdev, 12000)

            try:
              <span class="CodeAnnotationCode" aria-label="annotation1">1</span> data = nxpp.read_block(0, 4)
                print("[SUCCESS]\n")
                print("  Glitch OK! Add code to dump here.")
                done = True
                break

            except IOError as e:
                #print(e)
                print("[NORMAL]")

        except IOError:
            print("[FAILED]")
            pass

        scope.glitch.ext_offset += offset_range.step

    scope.glitch.repeat += repeat_range.step</code></pre>
<p class="CodeListingCaption"><a id="listing6-8">Listing 6-8</a>: Sweeping the glitch width and offset while attempting to read the CRP status</p>
<p>After each glitch attempt, an attempt is made to read from memory <span class="CodeAnnotation" aria-label="annotation1">1</span>. If successful, the entire flash memory is read out, and you then have complete access to and control over the LPC1114 processor. If you don’t have success, first check the timing using a power trace. We empirically found that around 51µs was required on the LPC1114, but that will change with voltage, temperature, and production batch.</p>
<p>Also check what the glitch waveform looks like, which will vary with longer or shorter wires. Because the ChipWhisperer-Nano has more limited resolution on the glitch width and offset, the attack is less successful with any given hardware setup than on the ChipWhisperer-Lite. You may find you need to use longer or shorter wires, for example, to adjust the glitch parameters physically. But before you go to the effort of further tuning, let it run for some time. Letting the attack run for an hour or two may result in a successful parameter set, as shown in <a href="#listing6-9" id="listinganchor6-9">Listing 6-9</a>.</p>
<pre><code>Attempting to glitch LPC Target
Glitch offset 5700, width 9........[NORMAL]
Glitch offset 5701, width 9........[NORMAL]
Glitch offset 5702, width 9........[NORMAL]
Glitch offset 5703, width 9........[NORMAL]
Glitch offset 5704, width 9........[NORMAL]
Glitch offset 5705, width 9........[NORMAL]
<span epub:type="pagebreak" title="210" id="Page_210"/>Glitch offset 5706, width 9........[NORMAL]
Glitch offset 5707, width 9........[NORMAL]
   ---<var>MANY MORE TESTS</var>---
Glitch offset 5729, width 9........[SUCCESS]

  Glitch OK! Beginning dump...
00 08 00 10 D1 1D 00 00 CB 1F 00 00 CB 1F 00 00
CB 1F 00 00 CB 1F 00 00 CB 1F 00 00 38 3B FF EF
00 00 00 00 00 00 00 00 00 00 00 00 CB 1F 00 00
CB 1F 00 00 00 00 00 00 CB 1F 00 00 CB 1F 00 00</code></pre>
<p class="CodeListingCaption"><a id="listing6-9">Listing 6-9</a>: Output of running script with a successful glitch</p>
<p>Once the attack is successful, it’s simply a matter of performing the flash read, which requires looping through all memory to read out the chip. Using the <code>nxpprog</code> library makes this even easier; see the companion GitHub repository for this book for examples of achieving this task, this is linked from <a href="https://nostarch.com/hardwarehacking" class="LinkURL">https://nostarch.com/hardwarehacking</a>. You could also unlock the device by reprogramming the configuration words, which should even allow you to attack a device with a full lock that disables the ISP and JTAG.</p>
<p>Never mind all the possibilities; simply receiving the success message indicates that you were able to corrupt the configuration word and thus bypass read protection! If you are relying on such security methods, it’s a useful exercise to perform to help you understand how others might bypass them.</p>
<h3 id="h2-278748c06-0003">Mux Fault Injection</h3>
<p class="BodyFirst">We’ve gone through an example using a crowbar, but it’s also useful to look at other methods of performing the voltage fault injection. The most common of these other methods is to use a multiplexor (mux) that switches between the regular operating voltage and the “glitch” voltage. The only problem with using the mux is that it may increase the chance of damaging the target. If you are glitching the device to a negative voltage, for example, you might discover that the negative voltage is too far out of spec. In our case, we’ll use in-range voltages to avoid that risk.</p>
<h4 id="h3-278748c06-0009">Mux Hardware Setup</h4>
<p class="BodyFirst">We discussed the mux as a fault injection method for the voltage-switching-based injector in Chapter 5, so see that chapter for details of how to build the fault injector circuitry using a multiplexor.</p>
<p>To use a multiplexor for this example, we use the same LPC1114 development board as shown in <a href="#figure6-8">Figure 6-8</a>, but this time without the 12 Ω shunt resistor that connected the input voltage to the core voltage. Remove it if it is already mounted. The trace must be cut so that the core voltage for the microcontroller is now coming entirely from an external source. We’ll be connecting the mux output to the core voltage of the LPC1114 development board, meaning that LPC1114 is always being powered from the mux output.</p>
<p><span epub:type="pagebreak" title="211" id="Page_211"/>In this example, we’re going for a two-chip solution using a complementary pair of analog switches: the TS12A4514 is normally open, and the TS12A4515 is a normally closed switch. <a href="#figure6-13" id="figureanchor6-13">Figure 6-13</a> shows the schematic for this solution.</p>
<figure>
<img src="image_fi/278748c06/f06013.png" alt="f06013"/>
<figcaption><p><a id="figure6-13">Figure 6-13</a>: Schematic showing a simple multiplexor for mux glitching</p></figcaption>
</figure>
<p>The TS12A4514 feeds the standard 3.3 V VCC from the ChipWhisperer-Nano through to the LPC1114, while the TS12A4515 feeds through a lesser voltage, as determined by the voltage set by the variable resistor VR1. This means with each toggle of the ChipWhisperer-Nano’s I/O pin, we toggle each analog switch at pin 6 and cause the voltage fed through to the LPC1114 to switch between the standard VCC on the TS12A4514 and the adjusted VCC on the TS12A4515. In comparison with the crowbar glitch schematic in <a href="#figure6-7">Figure 6-7</a>, only connections to VDD change; the serial and triggering connections remain the same.</p>
<p><span epub:type="pagebreak" title="212" id="Page_212"/>In our build, we stacked a TS12A4514 (bottom) and TS12A4515 (top) and soldered them together. The two switched voltage pins (pin 8 of U2 and U3) are the only pins not soldered together, as they have different connections; see <a href="#figure6-14" id="figureanchor6-14">Figure 6-14</a> for details.</p>
<figure>
<img src="image_fi/278748c06/f06014.png" alt="f06014"/>
<figcaption><p><a id="figure6-14">Figure 6-14</a>: A TS12A4514 (bottom) and TS12A4515 (top) stacked (hacked) together</p></figcaption>
</figure>
<p><a href="#figure6-15" id="figureanchor6-15">Figure 6-15</a> shows the mux-based fault injection setup; we’ll go through the low-level details of each part next.</p>
<figure>
<img src="image_fi/278748c06/f06015.png" alt="f06015"/>
<figcaption><p><a id="figure6-15">Figure 6-15</a>: The complete setup for performing a mux attack</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="213" id="Page_213"/>First, note that the 12 Ω resistor has been removed from the target <span class="CodeAnnotation" aria-label="annotation1">1</span>, as previously mentioned. For the switching-based glitch using a multiplexor, we need to specify two voltages: the regular voltage and the “glitch” voltage. In this case, to make life a bit easier, we’ll use similar voltages to those we used in the previous crowbar section. The regular voltage is the standard 3.3 V supply, taken off the JTAG connector from the LPC1114 board. The glitch voltage is similar to the crowbar setup where we tried to bring the power supply to ground (0 V). Going right to 0 V might reset the device too quickly, so instead we put a variable resistor (VR1) in the path. Because the target device typically has some capacitance on the positive rails, using a resistor means the volage is not driven down to 0 V (GND) as quickly. In the figure, we’re using a standard variable resistor <span class="CodeAnnotation" aria-label="annotation3">3</span>.</p>
<p>On the ChipWhisperer-Nano, we unsolder the two solder jumpers on the target side <span class="CodeAnnotation" aria-label="annotation2">2</span>. This step is required because we’ll now be using the glitch output to drive the mux, but we’ll still want to use the measurement capability. By default, the glitch output and measurement are tied together on the target board. This setup was okay in the previous section when the glitch output was directly connected to the target voltage. Now we need to decouple the measurement and glitch from each other. Separating off the target side of the ChipWhisperer-Nano would accomplish the same goal and ensure no conflict of the I/O lines. Simply unsoldering the solder jumpers, however, may be less aggressive in case you still want to use the included target.</p>
<p>To trigger the mux switch, we simply need a digital I/O signal that sweeps along a timeline, thereby inserting a voltage switch at different points in the target’s boot sequence. We could use an external FPGA or signal generator, but in this example, we’ll use the same ChipWhisperer-Nano or ChipWhisperer-Lite glitch output that we used in the crowbar example. The glitch trigger output only drives low, so a 1 k<span class="NSSymbol">Ω</span> resistor pulls the line high when it is not being driven low. We can use this glitch trigger output as an input to the mux select line, remembering that it is “active-low” when we want to insert a glitch the line drives low.</p>
<p>The TS12A4515P switches the preset glitch voltage (as set by VR1) through to the LPC1114 power rail when its input (at the combined pins 6) from the ChipWhisperer-Nano glitch trigger is low. Conversely, the TS12A4514P switches the normal 3.3 V VCC through to the LPC1114 power rail when its input (also at combined pins 6) from the ChipWhisperer-Nano glitch trigger is high. Whenever the glitch output trigger from the ChipWhisperer is low, the glitch voltage is switched through to the LPC1114 power rail by the mux, at any time and for any length of time, as programmed in and controlled by the ChipWhisperer.</p>
<p>To view the mux output together with the boot waveforms in progress at and around the time of the glitch, similar to what’s shown in <a href="#figure6-9">Figure 6-9</a>, you can measure pin 1 of the mux. This is essential for tuning the glitch moment and width. In this example, instead of relying on an oscilloscope, we set the ChipWhisperer-Nano to capture the power line signal, as in the crowbar example. One caveat of the ChipWhisperer-Nano is that it has a fixed input gain; you may find that the power line signal is swamping the <span epub:type="pagebreak" title="214" id="Page_214"/>input, making it difficult to observe. For this reason, a 220 <span class="NSSymbol">Ω</span> resistor (R3) has been inserted, which forms a voltage divider with the ChipWhisperer-Nano measurement input. You may need to adjust this resistor depending on the multiplexor you’re using. The ChipWhisperer-Lite allows adjusting the gain, so it does not require this same change and can directly observe the LPC1114 core voltage.</p>
<h4 id="h3-278748c06-0010">Tuning Glitch Settings</h4>
<p class="BodyFirst">As in the crowbar fault injection example, we’ll need to adjust the glitch settings. Previously, we had to adjust only the glitch width; now we also need to adjust the glitch voltage. In doing so, to keep things simple, we use a variable resistor to adjust the glitch “strength” rather than applying a specific voltage setting. We tune this resistor, view or capture a power measurement again during the boot process, and see how inserting various different glitch voltages affects it.</p>
<p>If you’re using the ChipWhisperer-Nano, this means running the script shown in <a href="#listing6-6">Listing 6-6</a>. As before, you can see how to adjust the glitch width in <a href="#listing6-7">Listing 6-7</a>. Switching between a very narrow glitch (<code>scope.glitch.repeat = 1</code>) and a wider glitch (<code>scope.glitch.repeat = 50</code>) should result in the narrow glitch not resetting the target and the wider glitch resetting the target.</p>
<p>You can also adjust resistor VR1 to see how it affects the results. You should find that a larger VR1 value allows you to use a wider glitch setting before the device resets. Again, see Figures 6-11 and 6-12 for examples of what the power trace looks like in both reset and non-reset situations. The addition of the resistor gives us another item to tweak. Imagine if the setting of <code>scope.glitch.repeat = 6</code> allowed the device to work normally and <code>scope.glitch.repeat = 7</code> always caused a reset. We want a setting that <em>almost</em> resets the device. A reset isn’t useful, but you could tweak the resistor value to the point where it doesn’t always reset the device.</p>
<p>As a sanity check, first connect both mux inputs to +3.3 V, and you should see that the target won’t glitch. Then connect one of the mux inputs directly to GND, and you should find that even narrow glitches cause the target to reset. From there, use the variable resistor to find the ideal in-between setting.</p>
<p>Once you’ve found a good setting for the voltage that has been set by the variable resistor (in our experiment, the “good” setting was a resistance of 34 <span class="NSSymbol">Ω</span>), you can again find the setting for the glitch width where the target is becoming unstable and resetting. When we dialed in the resistance setting, we were using a very wide glitch, so now we want to fine-tune the width to reduce our search space as well.</p>
<p>Compared to the crowbar glitch, we found a slightly narrower glitch was required. <a href="#listing6-10" id="listinganchor6-10">Listing 6-10</a> shows an example of the successful dump output; note that the timing offset is about the same as that determined by the crowbar insertion but that the width is different.</p>
<pre><code>Attempting to glitch LPC Target
Glitch offset 5700, width 5........[NORMAL]
   ---<var>MANY MORE TESTS</var>---
<span epub:type="pagebreak" title="215" id="Page_215"/>Glitch offset 5722, width 5........[NORMAL]
Glitch offset 5723, width 5........[NORMAL]
Glitch offset 5724, width 5........[NORMAL]
Glitch offset 5725, width 5........[NORMAL]
Glitch offset 5726, width 5........[NORMAL]
Glitch offset 5727, width 5........[NORMAL]
Glitch offset 5728, width 5........[SUCCESS]

  Glitch OK! Beginning dump...
00 08 00 10 D1 1D 00 00 CB 1F 00 00 CB 1F 00 00
CB 1F 00 00 CB 1F 00 00 CB 1F 00 00 38 3B FF EF
00 00 00 00 00 00 00 00 00 00 00 00 CB 1F 00 00
CB 1F 00 00 00 00 00 00 CB 1F 00 00 CB 1F 00 00
CB 1F 00 00 CB 1F 00 00 CB 1F 00 00 CB 1F 00 00
CB 1F 00 00 CB 1F 00 00 CB 1F 00 00 CB 1F 00 00
CB 1F 00 00 CB 1F 00 00 CB 1F 00 00 CB 1F 00 00</code></pre>
<p class="CodeListingCaption"><a id="listing6-10">Listing 6-10</a>: Using a mux results in the same successful glitch output as when using a crowbar.</p>
<p>If you do adjust the regular operating voltage, the timing of the glitch will change. The operating voltage of the device changes the internal oscillator frequency slightly (in addition to natural variations between devices). This means that running the target at 2.5 V instead of 3.3 V will likely have a pronounced effect on the moment in the boot process where the glitch ends up being inserted.</p>
<h2 id="h1-278748c06-0003">Act 3: Differential Fault Analysis</h2>
<p class="BodyFirst">Whereas the previous acts used fault injection to impact a result, this act uses fault injection to corrupt the otherwise perfect and secure math that underpins modern cryptography. In particular, we are going to attack RSA using a particularly common RSA implementation. These types of faults make it possible to use a <em>differential fault analysis (DFA)</em> attack. DFA attacks rely on an attacker being able to run the cryptographic operation while a fault is inserted and to compare the result of the faulty operation with the normal operation.</p>
<h3 id="h2-278748c06-0004">A Bit of RSA Math</h3>
<p class="BodyFirst">The 2001 paper “On the Importance of Eliminating Errors in Cryptographic Computations,” by Dan Boneh, Richard A. DeMillo, and Richard J. Lipton, introduced the Bellcore DFA attack on RSA. It must be one of the most effective DFA attacks, so in this act, we’ll take you on the ride called “Single Fault, All Key Bits.” Although this is a magical outcome, it is not super complicated mathematically. The Bellcore attack focuses on a particular variant of RSA, called the <em>RSA-CRT (Chinese Remainder Theorem)</em>. RSA-CRT was invented to speed up calculating RSA signatures by doing the RSA modular integer arithmetic on smaller numbers, while (of course) leading to the same result.</p>
<p>First, we’ll discuss textbook RSA and then show how RSA-CRT is implemented. We’ll discuss RSA again in Chapter 8 when we introduce the power <span epub:type="pagebreak" title="216" id="Page_216"/>analysis attack. Understanding how RSA works for a fault attack needs more details than for power analysis, so this section goes a little deeper than what you’ll need for Chapter 8 (in case the following math throws you off). Since this is a hardware book, refer to your favorite crypto textbook for more details. If you don’t yet have a favorite, Jean-Philippe Aumasson’s <em>Serious Cryptography</em> (No Starch Press, 2018) is a good candidate, and it covers RSA in Chapter 10. The following math has tons of cryptographic and number theory background, but all you really need is high-school-level algebra to understand why the attacks work.</p>
<p>The workings of RSA start off with two prime numbers, <em>p</em> and <em>q</em>, which together form the basis for the <em>private key</em>. The <em>public key</em> is simply <em>n</em>, with <em>n</em><var> </var>=<var> </var><em>pq</em>. The secrecy of <em>p</em><var> </var>and <em>q</em> is due to the inherent difficulty in factorization of very large numbers, meaning no known efficient algorithms exist for recovering <em>p</em> and <em>q</em> from only <em>n</em>. The next component of RSA is in choosing a number called the<em> public exponent</em> <em>e</em>. A common choice is 2<sup>16 </sup>+ 1. The <em>private exponent</em> <em>d</em> is now calculated as <em>d</em><var> </var>=<var> </var><em>e</em><sup>–1</sup> mod<var> </var><span class="NSSymbol">λ</span>(<em>n</em>), where <span class="NSSymbol">λ</span> is Carmichael’s totient function (its implementation isn’t relevant for the following attack, so you can simply nod knowingly about the existence of this function).</p>
<p>If you’re using RSA to sign a given message, the message <em>m</em> is what the RSA signature protects. RSA signing is done by calculating <em>s</em><var> </var>=<var> </var><em>m</em><sup><em>d</em></sup><var> </var>mod<var> </var><em>n</em>. The message <em>m</em> is simply an integer (number). In practice, we have a <em>padding scheme</em> that converts from a typical string or binary message to the integer <em>m</em>.</p>
<p>RSA is pretty computationally expensive. Consider that the private exponent is, for modern-day security, at least 2,048 bits long and that the complexity of the modular exponentiation <em>m</em><sup><em>d</em></sup> mod <em>n</em> increases with the cube of the number of bits in <em>n</em>.</p>
<p>Enter the Chinese Remainder Theorem. The idea is to split the calculation into two parts, leveraging the fact that <em>n</em> is a product of two primes. The private key in RSA-CRT is based on the primes <em>p</em> and <em>q</em>, mentioned previously. We could represent this key, still based only on the values of <em>p</em> and <em>q</em>, as three numbers: <em>d</em><sub><em>P</em></sub><var> </var>=<var> </var><em>d</em><var> </var>mod<var> </var><em>p </em>– 1,<var> </var><em>d</em><sub><em>Q</em></sub><var> </var>=<var> </var><em>d</em><var> </var>mod<var> </var><em>q </em>– 1, and <em>q</em><sub>inv</sub> =<var> </var><em>q</em><sup>–1</sup><var> </var>mod<var> </var><em>p</em>. With this implementation, we now can calculate a signature as follows:</p>
<p class="equation"><em>s</em><sub><em>P</em></sub> = <em>m</em><sup><em>d</em></sup><sup><sub><em>P</em></sub></sup>mod <em>p</em></p>
<p class="equation"><em>s</em><sub><em>Q</em></sub> = <em>m</em><sup><em>d</em></sup><sup><sub><em>Q</em></sub></sup>mod <em>q</em></p>
<p class="equation"><em>s</em> = <em>s</em><sub><em>Q</em></sub> + <em>q</em>(<em>q</em><sub>inv</sub>(<em>s</em><sub><em>P</em></sub> – <em>s</em><sub><em>Q</em></sub>)mod <em>p</em>)</p>
<p>Since the moduli (<em>p </em>and <em>q</em>) are now half the number of bits, calculating a signature is roughly four times faster (that’s good). Also, a differential fault analysis (DFA) attack can now be performed with just one fault (that’s bad). To appreciate why, consider that we inject a fault, any fault, during the calculation of <em>s</em><sub><em>P</em></sub>, and let’s call the faulty result <em>s'</em><sub><em>P</em></sub>. We’ll also have a corrupted signature as a result, <em>s'</em>. Next, we can do a bit of algebraic magic:</p>
<p class="equation"><em>s'</em> = <em>s</em><sub><em>Q </em></sub>+ <em>q</em>(<em>q</em><sub>inv</sub>(<em>s'</em><sub><em>P</em></sub> – <em>s</em><sub><em>Q</em></sub>)mod <em>p</em>)</p>
<p class="BodyContinued"><span epub:type="pagebreak" title="217" id="Page_217"/>Then, we subtract <em>s'</em> from <em>s</em>:</p>
<p class="equation"><em>s</em> – <em>s'</em> = <em>s</em><sub><em>Q</em></sub> + <em>q</em>(<em>q</em><sub>inv</sub>(<em>s</em><sub><em>P</em></sub> – <em>s</em><sub><em>Q</em></sub>)mod <em>p</em>) – <em>s</em><sub><em>Q</em></sub> – <em>q</em>(<em>q</em><sub>inv</sub>(<em>s'</em><sub><em>P</em></sub> – <em>s</em><sub><em>Q</em></sub>)mod <em>p</em>)</p>
<p class="BodyContinued">and we remove <em>s</em><sub><em>Q</em></sub> from both sides:</p>
<p class="equation"><em>s</em> – <em>s</em>' = <em>q</em>(<em>q</em><sub>inv</sub>(<em>s</em><sub><em>P</em></sub> – <em>s</em><sub><em>Q</em></sub>)mod <em>p</em>) – <em>q</em>(<em>q</em><sub>inv</sub>(<em>s'</em><sub><em>P</em></sub> – <em>s</em><sub><em>Q</em></sub>)mod <em>p</em>)</p>
<p class="BodyContinued">Next, we recognize that <em>q</em> times some integer, minus <em>q</em> times some other integer, can be written as</p>
<p class="equation"><em>s</em> – <em>s'</em> = <em>qk</em><sub>1</sub> – <em>qk</em><sub>2</sub> = <em>kq</em></p>
<p class="BodyContinued">where <em>k</em><sub>1</sub>, <em>k</em><sub>2</sub>,<em> </em>and<em> k</em> are some (unknown) integers. This is for a fault in <em>s</em><sub><em>P</em></sub>. If you happen to fault during the calculation of <em>s</em><sub><em>Q</em></sub>, you end up with <em>s </em>– <em>s'</em> =<var> </var><em>kp</em>.</p>
<p>Next, we use an efficient algorithm for calculating the <em>greatest common divisor (GCD)</em>. The GCD of two integers <em>i</em> and <em>j</em> gives the largest positive integer that divides into both numbers. For example, the GCD of 36 and 24 is 12, because 12 divides into both 36 and 24. No number greater than 12 divides both 36 and 24. We’ll write this as GCD(36, 24) = 12.</p>
<p>A prime number, by definition, can be divided only by itself and 1. In RSA, the modulus of <em>n</em> = <em>pq</em>, so it’s divisible only by 1, <em>p</em>, and <em>q</em>. Since GCD(<em>q</em>, <em>n</em>) = GCD(<em>q</em>, <em>pq</em>) =<var> </var><em>q</em>, the GCD of <em>n</em> and any integer <em>kq</em> (with <em>k</em> less than <em>p</em>) is <em>q</em>.</p>
<p>From our attack, we can calculate <em>s </em>–<em> s'</em>, and we know it’s a multiple <em>k</em> of <em>q</em> (with <em>k</em> less than <em>p</em>). We calculate GCD(<em>s </em>–<em> s'</em>, <em>n</em>) = GCD(<em>kq</em>, <em>pq</em>) =<var> </var><em>q</em>. This works because <em>p</em> and <em>q</em> are primes, so no other divisors exist for <em>n</em>. Now, since we have <em>q</em>, we easily calculate <em>p</em> =<var> </var><em>n</em> ÷ <em>q</em>, and we have both private primes and thus the RSA private key!</p>
<p>Note that for this attack to work, we need both <em>s</em> and <em>s'</em>, which means signing the same message <em>m </em>twice and corrupting one of the two signature calculations. Doing that may not always be possible in practice, because padding schemes like <em>Optimal Asymmetric Encryption Padding (OAEP)</em>, such as used in the PKCS#1 cryptographic standard, randomizes part of the message <em>m</em> on the signer’s end. Luckily, Arjen Lenstra, a famous cryptographer, wrote a memo to the Bellcore authors showing a successful attack that requires only the corrupted signature.</p>
<p>The solution is fairly similar to the preceding one, where we did some algebra to derive a value for which the GCD with <em>n</em> gives one of the primes. The difference with before is that we don’t have an <em>s</em>, only an <em>s'</em>. We can use our previously derived equation that relates them:</p>
<p class="equation"><em>s</em> − <em>s</em>′ = <em>kq</em></p>
<p class="equation"><em>s</em> = <em>s</em>′ + <em>kq</em></p>
<p class="BodyContinued">So, we’ll substitute the <em>s</em> as follows in the RSA message equation:</p>
<p class="equation"><em>m</em> = <em>s</em><sup><em>e</em></sup>mod <em>n</em> = (<em>s</em>′ + <em>kq</em>)<sup><em>e</em></sup>mod <em>n</em></p>
<p class="equation"><span epub:type="pagebreak" title="218" id="Page_218"/>Next, we use the binomial theorem to do some rewriting. The binomial theorem states the following:</p>
<figure class="graphic">
<img src="image_fi/278748c06/e06001.png" alt="e06001"/></figure>

<p class="BodyContinued">So, we’ll write</p>
<figure class="graphic">
<img src="image_fi/278748c06/e06002.png" alt="e06002"/></figure>

<p class="BodyContinued">and we’ll bring out the expression for <em>i</em> = 0:</p>
<figure class="graphic">
<img src="image_fi/278748c06/e06003.png" alt="e06003"/></figure>

<figure class="graphic">
<img src="image_fi/278748c06/e06004.png" alt="e06004"/></figure>

<p class="BodyContinued">We’ll also divide one of the <em>kq</em> terms out of the summation:</p>
<figure class="graphic">
<img src="image_fi/278748c06/e06005.png" alt="e06005"/></figure>

<p class="BodyContinued">We replace the summation with <em>x</em>, where <em>x</em> is some integer:</p>
<p class="equation"><em>m</em> = [<em>s</em>'<sup><em>e</em></sup> + <em>kqx</em>]mod <em>n</em></p>
<p class="equation"><em>m</em> − <em>s</em><sup>'<em>e</em></sup> = <em>kqx</em> mod <em>n</em></p>
<p class="BodyContinued">We then find <em>q </em>with the following:</p>
<p class="equation">GCD(<em>m</em> − <em>s</em>'<sup><em>e</em></sup>, <em>n</em>) = GCD(<em>kqx</em>, <em>n</em>) = GCD(<em>kqx</em>, <em>pq</em>) = <em>q</em></p>
<p class="BodyContinued">Since <em>p</em><var> </var>=<var> </var><em>n </em>÷ <em>q</em>, we have the full private key. As before, this works symmetrically for a fault in <em>s</em><sub><em>Q</em></sub>.</p>
<h3 id="h2-278748c06-0005">Getting a Correct Signature from the Target</h3>
<p class="BodyFirst">For this example, we’ll use this chapter’s Jupyter Notebook, which has an RSA-CRT fault simulator and can also run on the ChipWhisperer-Lite with a 32-bit ARM (NAE-CWLITE-ARM) target. You can configure your choice at the top of the notebook. For the hardware, it walks you through loading the firmware, getting a signature from the device, and verifying it is correct.</p>
<p><span epub:type="pagebreak" title="219" id="Page_219"/>You can use whatever other target you want; all you need to do is build a fault injection setup with the target and implement an RSA-CRT on the target. The RSA-CRT takes in a message <em>m</em> and returns the signature <em>s</em>. You can modify the code from the notebook for your firmware and build setup.</p>
<h4 id="h3-278748c06-0011">Injecting the Fault in the Simulator</h4>
<p class="BodyFirst">For the simulator in the notebook, we implement the RSA-CRT computation as described in the earlier formulae. Just like on the real hardware, we’re signing a PKCS#1 v1.5 padded hash of the message. Luckily, this standard’s fairly simple. PKCS#1 v1.5 padding looks like this:</p>
<pre><code>|00|01|ff...|00|<var>hash_prefix</var>|<var>message_hash</var>|</code></pre>
<p>Here, the <code>ff...</code> part is a string of <code>ff</code> bytes long enough to make the size of the padded message the same size as <em>n</em>, while <var>hash_prefix</var> is an identifier number for the hash algorithm used on <var>message_hash</var>. In our case, SHA-256 has the hash prefix of <code>3031300d060960864801650304020105000420</code>.</p>
<p>Altogether, the padded and hashed message “Hello World!” looks like this:</p>
<pre><code>|00|01|ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff|003031300d060960864801650304020105000420|7f83b165ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069|</code></pre>
<p>Now that we have the final message, we push that through the RSA-CRT computation, but not without first simulating some faults. For this, we flip a number of bits in <em>s</em><sub><em>P</em></sub> at random to obtain <em>s'</em><sub><em>P</em></sub>. As the preceding attack explains, it’s not important what the fault really is. We could have also set <em>s</em><sub><em>P</em></sub> to the binary expansion of π, 0, or our pet’s birthday. Next, we calculate the faulty signature <em>s'</em>.</p>
<h4 id="h3-278748c06-0012">Injecting the Fault on Hardware</h4>
<p class="BodyFirst">For hardware, the relaxed conditions on when and where to fault also help us: any fault will do, as long as it’s sometime during the calculation of <em>s</em><sub><em>P</em></sub> or <em>s</em><sub><em>Q</em></sub>. Since these calculations take up almost the entire RSA-CRT calculation, most of the time between receiving the message and calculating the signature is spent on the calculation of <em>s</em><sub><em>P</em></sub><em> </em>and <em>s</em><sub><em>Q</em></sub>. This means you can try your luck and blindly inject faults somewhere within the time window of the signature calculation.</p>
<p>If you want a bit more visibility as to what you’re doing, take a power trace to see the timing of the RSA operation. For example, the power trace in <a href="#figure6-16" id="figureanchor6-16">Figure 6-16</a> is from an STM32F30, where the operation is split into two main sub-operations.</p>
<span epub:type="pagebreak" title="220" id="Page_220"/><figure>
<img src="image_fi/278748c06/f06016.png" alt="f06016"/>
<figcaption><p><a id="figure6-16">Figure 6-16</a>: MBED-TLS running an RSA signature operation</p></figcaption>
</figure>
<p>You can see the two halves of the signature calculation split around cycle 500,000, separated by a small blip. This pattern is very common for RSA-CRT, and, in fact, seeing it can make it obvious that a device is running RSA-CRT without any internal knowledge of the device. We’ll look more at power analysis in the next chapter as well as how to use it to recover secret information from a device.</p>
<p>With the timing down, we can inject faults. In the notebook for this exercise, we’ve selected a range between 7,000,000 and 7,100,000 in which to inject faults, which is somewhere in the middle of the second half of the signature computation. From earlier characterization of the device, we know some possible fault parameters we could use, and we hardcode these in the notebook. If we are unsure on the timing, we can simply sweep through some approximate timings, as this snippet of code shows:</p>
<pre><code>from tqdm import tnrange
for i in tnrange(7000000, 7100000):
    scope.glitch.ext_offset = i
    target.flush()
    scope.arm() # arm the glitch to occur at ext_offset
    target.write("t\n") # this starts signature operation and triggers counter
    scope.capture() # wait for trigger/counter to finish
<var>    --snip--</var></code></pre>
<p>We use a loop to get the target to perform signature operations while we inject faults. We would then need to check the result to see whether the target returned something that looks like a corrupted signature, rather than a target crash or hard error. The code to check whether the output is valid for each timing is in the companion notebook.</p>
<p><span epub:type="pagebreak" title="221" id="Page_221"/>We identify candidate signature corruptions by the fact that the signature returned from the device has the correct length but does not pass RSA verification. If it has an incorrect length, we most likely corrupted something besides the signature calculation, so we can discard those instances.</p>
<p>In the notebook, we cheat and simply check to see whether the “expected” output does not appear in the signature (the expected output being the result of a correct signature). It’s an even easier way of checking whether the signature doesn’t validate.</p>
<p>After running this code, we’ll have captured a faulty signature that we can use to recover the primes. Usually, this method will work. If you encounter a corner case where it doesn’t, it’s easy to grab another faulty signature and try again.</p>
<p>If you aren’t going the ChipWhisperer route and have your own setup or target, make sure to characterize first: find fault injection parameters that will result in some visible corruption of the signature. The telltale sign of a useful corruption is when the data returned for the signature changes without the length of the signature changing. The amusing part of this attack is that a successful characterization will already yield a corrupted signature, which means we’re done with the fault injection part.</p>
<h4 id="h3-278748c06-0013">Completing the Attack</h4>
<p class="BodyFirst">Once we have the glitched signature, either from hardware or the RSA-CRT simulator, we’ve still got a little work to do. Let’s assume we have a variable called <code>s_crt</code> that is the correct signature and a variable called <code>s_crt_x</code> that is the corrupted signature. These are just big numbers. As an example, the value of <code>s_crt_x</code> when printed in hex looks like this:</p>
<pre><code>1187B790564D43D48CD140A7FF890EEA713D1603D8CBC57CF070EE951479C75E93FE98AD04F535109D957F9AB9
AA25DB2FB1A5521C68C986A270782B7A579A12B9AE79DF2F59ED9E6694C64C40AAD9FE46B203DB75792016EE
A315F7CAA8F9AAC0FD89052FFAC29C022E32B541B150419E2B6604DDA6BF2582F62C9F7876393D</code></pre>
<p>Earlier, we had the simple equation for calculating the primes <em>p</em> and <em>q</em> out of the corrupted signature and either the correct signature or the message. The notebook implements both methods for recovering the primes using the GCD. As you’ll see, this computation takes only a fraction of a second to complete before printing out the private primes.</p>
<p>Let’s take one of the implementations from the notebook for finding the private primes using the corrupted signature and the correct signature:</p>
<pre><code># Recover p and q from corrupted signature and correct signature
calc_q = gcd(s_crt_x - s_crt, N)
calc_p = N // calc_q
print("Recovered p using s: {}".format(hex(calc_p)))
print("Recovered q using s: {}".format(hex(calc_q)))
print("pq == N?             {}".format(calc_q * calc_p == N))</code></pre>
<p><span epub:type="pagebreak" title="222" id="Page_222"/>The output of this block shows the calculated values of <code>p</code> and <code>q</code>. To confirm that they’re correct, we simply check whether multiplying them together gives us the (public and, thus, known) value of <code>N</code>. The following shows an example of running the preceding code:</p>
<pre><code>Recovered p using s: 0xc36d0eb7fcd285223cfb5aaba5bda3d82c01cad19ea484a87ea4377637e75500fcb2005c5c7dd6ec4ac023cda285d796c3d9e75e1efc42488bb4f1d13ac30a57
Recovered q using s: 0xc000df51a7c77ae8d7c7370c1ff55b69e211c2b9e5db1ed0bf61d0d9899620f4910e4168387e3c30aa1e00c339a795088452dd96a9a5ea5d9dca68da636032af
pq == N?             True</code></pre>
<p>Et voilà! We’ve factored <code>N</code> from one corrupted signature and know the private primes <code>p</code> and <code>q</code>. All it took was a single fault inserted at almost an arbitrary time during the signature operation.</p>
<p>Hardened implementations have one more trick that we should bypass in real life, however: the actual <code>mbedTLS</code> library checks whether it’s returning a faulty signature, which it does simply by checking that the signature works as expected. In the sample firmware, we’ve commented out that line. In reality, you would use fault injection to bypass the check. Although a double-fault sounds tricky, it’s made easier because the initial fault (in the RSA operation) requires almost no precision on the timing, so the only complicated part is timing the fault on the signature validation check.</p>
<h2 id="h1-278748c06-0004">Summary</h2>
<p class="BodyFirst">In this chapter, we walked through three different examples of performing fault injection attacks, starting with the most basic scenario of a fault attack on a loop and finishing with how you can dump RSA keys using fault attacks.</p>
<p>Keep in mind that fault injection in practice is a stochastic process. The specific type of fault and resulting effect will vary considerably, and even can change with different device lock codes and as manufacturers work to protect devices against fault attacks.</p>
<p>If you are performing the experiments in this chapter yourself, don’t despair if things don’t work reliably the first time. Try multiple methods of performing the fault injection, and more important, experiment with some of the simple examples first to see what variety of faults you can inject.</p>
<p>In the next chapter, we’ll step things up and attack an off-the-shelf device. </p>
</section>
</body></html>