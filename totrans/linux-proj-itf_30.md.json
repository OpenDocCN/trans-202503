["```\n`threads/thread_incr.c`\n#include <pthread.h>\n#include \"tlpi_hdr.h\"\n\nstatic int glob = 0;\n\nstatic void *                   /* Loop ’arg’ times incrementing ’glob’ */\nthreadFunc(void *arg)\n{\n    int loops = *((int *) arg);\n    int loc, j;\n\n    for (j = 0; j < loops; j++) {\n        loc = glob;\n        loc++;\n        glob = loc;\n    }\n\n    return NULL;\n}\n\nint\nmain(int argc, char *argv[])\n{\n    pthread_t t1, t2;\n    int loops, s;\n\n    loops = (argc > 1) ? getInt(argv[1], GN_GT_0, \"num-loops\") : 10000000;\n\n    s = pthread_create(&t1, NULL, threadFunc, &loops);\n    if (s != 0)\n        errExitEN(s, \"pthread_create\");\n    s = pthread_create(&t2, NULL, threadFunc, &loops);\n    if (s != 0)\n        errExitEN(s, \"pthread_create\");\n\n    s = pthread_join(t1, NULL);\n    if (s != 0)\n        errExitEN(s, \"pthread_join\");\n    s = pthread_join(t2, NULL);\n    if (s != 0)\n        errExitEN(s, \"pthread_join\");\n\n    printf(\"glob = %d\\n\", glob);\n    exit(EXIT_SUCCESS);\n}\n     `threads/thread_incr.c`\n```", "```\n$ `./thread_incr 1000`\nglob = 2000\n```", "```\n$ `./thread_incr 10000000`\nglob = 16517656\n```", "```\n$ `./thread_incr 10000000`\nglob = 10880429\n$ `./thread_incr 10000000`\nglob = 13493953\n```", "```\nglob++;             /* or: ++glob; */\n```", "```\npthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;\n```", "```\n#include <pthread.h>\n\nint `pthread_mutex_lock`(pthread_mutex_t **mutex*);\nint `pthread_mutex_unlock`(pthread_mutex_t **mutex*);\n```", "```\n$ `./thread_incr_mutex 10000000`\nglob = 20000000\n```", "```\n`threads/thread_incr_mutex.c`\n#include <pthread.h>\n#include \"tlpi_hdr.h\"\n\nstatic int glob = 0;\nstatic pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;\n\nstatic void *                   /* Loop ’arg’ times incrementing ’glob’ */\nthreadFunc(void *arg)\n{\n    int loops = *((int *) arg);\n    int loc, j, s;\n\n    for (j = 0; j < loops; j++) {\n        s = pthread_mutex_lock(&mtx);\n        if (s != 0)\n            errExitEN(s, \"pthread_mutex_lock\");\n\n        loc = glob;\n        loc++;\n        glob = loc;\n\n        s = pthread_mutex_unlock(&mtx);\n        if (s != 0)\n            errExitEN(s, \"pthread_mutex_unlock\");\n    }\n\n    return NULL;\n}\n\nint\nmain(int argc, char *argv[])\n{\n    pthread_t t1, t2;\n    int loops, s;\n\n    loops = (argc > 1) ? getInt(argv[1], GN_GT_0, \"num-loops\") : 10000000;\n\n    s = pthread_create(&t1, NULL, threadFunc, &loops);\n    if (s != 0)\n        errExitEN(s, \"pthread_create\");\n    s = pthread_create(&t2, NULL, threadFunc, &loops);\n    if (s != 0)\n        errExitEN(s, \"pthread_create\");\n\n    s = pthread_join(t1, NULL);\n    if (s != 0)\n        errExitEN(s, \"pthread_join\");\n    s = pthread_join(t2, NULL);\n    if (s != 0)\n        errExitEN(s, \"pthread_join\");\n\n    printf(\"glob = %d\\n\", glob);\n    exit(EXIT_SUCCESS);\n}\n     `threads/thread_incr_mutex.c`\n```", "```\n#include <pthread.h>\n\nint `pthread_mutex_init`(pthread_mutex_t **mutex*, const pthread_mutexattr_t **attr*);\n```", "```\n#include <pthread.h>\n\nint `pthread_mutex_destroy`(pthread_mutex_t **mutex*);\n```", "```\npthread_mutex_t mtx;\n    pthread_mutexattr_t mtxAttr;\n    int s, type;\n\n    s = pthread_mutexattr_init(&mtxAttr);\n    if (s != 0)\n        errExitEN(s, \"pthread_mutexattr_init\");\n\n    s = pthread_mutexattr_settype(&mtxAttr, PTHREAD_MUTEX_ERRORCHECK);\n    if (s != 0)\n        errExitEN(s, \"pthread_mutexattr_settype\");\n\n    s = pthread_mutex_init(&mtx, &mtxAttr);\n    if (s != 0)\n        errExitEN(s, \"pthread_mutex_init\");\n\n    s = pthread_mutexattr_destroy(&mtxAttr);        /* No longer needed */\n    if (s != 0)\n        errExitEN(s, \"pthread_mutexattr_destroy\");\n```", "```\nstatic pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;\n\nstatic int avail = 0;\n```", "```\n/* Code to produce a unit omitted */\n\ns = pthread_mutex_lock(&mtx);\nif (s != 0)\n    errExitEN(s, \"pthread_mutex_lock\");\n\navail++;    /* Let consumer know another unit is available */\n\ns = pthread_mutex_unlock(&mtx);\nif (s != 0)\n    errExitEN(s, \"pthread_mutex_unlock\");\n```", "```\nfor (;;) {\n    s = pthread_mutex_lock(&mtx);\n    if (s != 0)\n        errExitEN(s, \"pthread_mutex_lock\");\n\n    while (avail > 0) {         /* Consume all available units */\n        /* Do something with produced unit */\n        avail--;\n    }\n\n    s = pthread_mutex_unlock(&mtx);\n    if (s != 0)\n        errExitEN(s, \"pthread_mutex_unlock\");\n}\n```", "```\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n```", "```\n#include <pthread.h>\n\nint `pthread_cond_signal`(pthread_cond_t **cond*);\nint `pthread_cond_broadcast`(pthread_cond_t **cond*);\nint `pthread_cond_wait`(pthread_cond_t **cond*, pthread_mutex_t **mutex*);\n```", "```\n#include <pthread.h>\n\nint `pthread_cond_timedwait`(pthread_cond_t **cond*, pthread_mutex_t **mutex*,\n                           const struct timespec **abstime*);\n```", "```\nstatic pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n\nstatic int avail = 0;\n```", "```\ns = pthread_mutex_lock(&mtx);\nif (s != 0)\n    errExitEN(s, \"pthread_mutex_lock\");\n\navail++;                /* Let consumer know another unit is available */\n\ns = pthread_mutex_unlock(&mtx);\nif (s != 0)\n    errExitEN(s, \"pthread_mutex_unlock\");\n\ns = pthread_cond_signal(&cond);         /* Wake sleeping consumer */\nif (s != 0)\n    errExitEN(s, \"pthread_cond_signal\");\n```", "```\ns = pthread_mutex_lock(&mtx);\nif (s != 0)\n    errExitEN(s, \"pthread_mutex_lock\");\n\nwhile (/* Check that shared variable is not in state we want */)\n    pthread_cond_wait(&cond, &mtx);\n\n/* Now shared variable is in desired state; do some work */\n\ns = pthread_mutex_unlock(&mtx);\nif (s != 0)\n    errExitEN(s, \"pthread_mutex_unlock\");\n```", "```\nfor (;;) {\n    s = pthread_mutex_lock(&mtx);\n    if (s != 0)\n        errExitEN(s, \"pthread_mutex_lock\");\n\n    while (avail == 0) {            /* Wait for something to consume */\n        s = pthread_cond_wait(&cond, &mtx);\n        if (s != 0)\n            errExitEN(s, \"pthread_cond_wait\");\n    }\n\n    while (avail > 0) {             /* Consume all available units */\n        /* Do something with produced unit */\n        avail--;\n    }\n\n    s = pthread_mutex_unlock(&mtx);\n    if (s != 0)\n        errExitEN(s, \"pthread_mutex_unlock\");\n\n    /* Perhaps do other work here that doesn’t require mutex lock */\n}\n```", "```\n$ `./thread_multijoin 1 1 2 3 3`              *Create 5 threads*\nThread 0 terminating\nThread 1 terminating\nReaped thread 0 (numLive=4)\nReaped thread 1 (numLive=3)\nThread 2 terminating\nReaped thread 2 (numLive=2)\nThread 3 terminating\nThread 4 terminating\nReaped thread 3 (numLive=1)\nReaped thread 4 (numLive=0)\n```", "```\n`threads/thread_multijoin.c`\n#include <pthread.h>\n#include \"tlpi_hdr.h\"\n\nstatic pthread_cond_t threadDied = PTHREAD_COND_INITIALIZER;\nstatic pthread_mutex_t threadMutex = PTHREAD_MUTEX_INITIALIZER;\n                /* Protects all of the following global variables */\n\nstatic int totThreads = 0;      /* Total number of threads created */\nstatic int numLive = 0;         /* Total number of threads still alive or\n                                   terminated but not yet joined */\nstatic int numUnjoined = 0;     /* Number of terminated threads that\n                                   have not yet been joined */\nenum tstate {                   /* Thread states */\n    TS_ALIVE,                   /* Thread is alive */\n    TS_TERMINATED,              /* Thread terminated, not yet joined */\n    TS_JOINED                   /* Thread terminated, and joined */\n};\n\nstatic struct {                 /* Info about each thread */\n    pthread_t tid;              /* ID of this thread */\n    enum tstate state;          /* Thread state (TS_* constants above) */\n    int sleepTime;              /* Number seconds to live before terminating */\n} *thread;\n\nstatic void *                   /* Start function for thread */\nthreadFunc(void *arg)\n{\n    int idx = *((int *) arg);\n    int s;\n\n    sleep(thread[idx].sleepTime);       /* Simulate doing some work */\n    printf(\"Thread %d terminating\\n\", idx);\n\n    s = pthread_mutex_lock(&threadMutex);\n    if (s != 0)\n        errExitEN(s, \"pthread_mutex_lock\");\n\n    numUnjoined++;\n    thread[idx].state = TS_TERMINATED;\n\n    s = pthread_mutex_unlock(&threadMutex);\n    if (s != 0)\n        errExitEN(s, \"pthread_mutex_unlock\");\n    s = pthread_cond_signal(&threadDied);\n    if (s != 0)\n        errExitEN(s, \"pthread_cond_signal\");\n\n    return NULL;\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int s, idx;\n\n    if (argc < 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s nsecs...\\n\", argv[0]);\n\n    thread = calloc(argc - 1, sizeof(*thread));\n    if (thread == NULL)\n        errExit(\"calloc\");\n\n    /* Create all threads */\n\n    for (idx = 0; idx < argc - 1; idx++) {\n        thread[idx].sleepTime = getInt(argv[idx + 1], GN_NONNEG, NULL);\n        thread[idx].state = TS_ALIVE;\n        s = pthread_create(&thread[idx].tid, NULL, threadFunc, &idx);\n        if (s != 0)\n            errExitEN(s, \"pthread_create\");\n    }\n\n    totThreads = argc - 1;\n    numLive = totThreads;\n\n    /* Join with terminated threads */\n\n    while (numLive > 0) {\n        s = pthread_mutex_lock(&threadMutex);\n        if (s != 0)\n            errExitEN(s, \"pthread_mutex_lock\");\n\n        while (numUnjoined == 0) {\n            s = pthread_cond_wait(&threadDied, &threadMutex);\n            if (s != 0)\n                errExitEN(s, \"pthread_cond_wait\");\n        }\n\n        for (idx = 0; idx < totThreads; idx++) {\n            if (thread[idx].state == TS_TERMINATED){\n                s = pthread_join(thread[idx].tid, NULL);\n                if (s != 0)\n                    errExitEN(s, \"pthread_join\");\n\n                thread[idx].state = TS_JOINED;\n                numLive--;\n                numUnjoined--;\n\n                printf(\"Reaped thread %d (numLive=%d)\\n\", idx, numLive);\n            }\n        }\n\n        s = pthread_mutex_unlock(&threadMutex);\n        if (s != 0)\n            errExitEN(s, \"pthread_mutex_unlock\");\n    }\n\n    exit(EXIT_SUCCESS);\n}\n      `threads/thread_multijoin.c`\n```", "```\n#include <pthread.h>\n\nint `pthread_cond_init`(pthread_cond_t **cond*, const pthread_condattr_t **attr*);\n```", "```\n#include <pthread.h>\n\nint `pthread_cond_destroy`(pthread_cond_t **cond*);\n```", "```\n    initialize(tree);\n    add(tree, char *key, void *value);\n    delete(tree, char *key)\n    Boolean lookup(char *key, void **value)\n    ```"]