- en: '14'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FIREFLY
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Firefly is a minimalist programming language for animation and sound. Firefly
    targets the BBC micro:bit, but you don’t need one to have fun with the language—the
    console version will work just fine. The inspiration for the language comes from
    the 5×5 grid of LEDs that form the display of the micro:bit. The language manipulates
    a “firefly” that lives on the grid. As it flies, it leaves a luminous trail of
    light behind it. Oh, the firefly also sings, because why not?
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces the philosophy and design of the language, followed
    by its implementation. The chapter ends with a section on configuring a micro:bit,
    should you wish to use one for the experiments of [Chapter 15](ch15.xhtml#ch15).
    Again, you don’t need a micro:bit; you can run everything just fine at the command
    line using the console version of the interpreter. However, the micro:bit isn’t
    too expensive, and it’s a fun little device that itself runs Python. Also, console
    fireflies don’t know how to sing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Philosophy and Design**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our environment is this: a small firefly is flying around a tiny 5×5 grid.
    As it flies, it leaves behind a luminous trail and sometimes sings.'
  prefs: []
  type: TYPE_NORMAL
- en: To be more specific, a Firefly program manipulates a 5×5 grid of single digits.
    On the micro:bit, these become intensities of the 5×5 grid of LEDs. The firefly
    can sing by making the micro:bit sound a note of a particular pitch and duration.
  prefs: []
  type: TYPE_NORMAL
- en: A Firefly program is a series of single-character instructions that either move
    the firefly around the grid, set the way its luminous trail acts, or make the
    firefly sing a note. The Firefly language also supports what is known as *double
    buffering*, meaning instead of one 5×5 grid of digits, there are two 5×5 grids.
    The program controls which grid is shown to the user and which grid the firefly
    is making a trail on (drawing to). Double buffering is a common computer animation
    technique in which the user sees one display while the program is updating the
    other and then the view switches. Doing this prevents the user from watching the
    display draw and makes for smooth animation. Don’t worry if double buffering is
    a new concept; we’ll detail it in [Chapter 15](ch15.xhtml#ch15) when we use it.
  prefs: []
  type: TYPE_NORMAL
- en: A Firefly program instructs the firefly by directing its movements and when
    and how it should sing. If you’ve never heard a singing firefly, you’re in good
    company because I haven’t either. Still, it’s fun to pretend.
  prefs: []
  type: TYPE_NORMAL
- en: The firefly is constrained to move on a 5×5 grid. The upper-left corner of the
    grid is position (0,0), and the lower-right corner is position (4,4). Positions
    are given as the row number before the column number. The firefly moves one position
    at a time, either north (`N`), south (`S`), east (`E`), or west (`W`). When it
    moves off one edge of the grid, it wraps around to the other side. For instance,
    moving east from position (1,4) puts the firefly at position (1,0). Likewise,
    a firefly moving south from (4,2) arrives at position (0,2).
  prefs: []
  type: TYPE_NORMAL
- en: When the firefly moves, it leaves behind a trail, meaning it sets the position
    it *just left* to some value. On the micro:bit, the value is the LED’s intensity
    at that position where 0 is off and 9 is maximum brightness. The console interpreter
    shows 0 as space and anything else as the numeric value of the position, but if
    desired, the console will show 0 as `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if the firefly is currently at position (2,2) and the intensity is
    set to 3, an instruction telling the firefly to move one position to the west,
    that is, to (2,1), will set position (2,2) to intensity 3\. There is also an instruction
    telling the firefly to stay put, so it is possible to update a position value
    in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 5×5 grid is all the memory we have. It’s also the display: we see the value
    of each grid cell as a number (console) or brightness of the LED (micro:bit).
    Therefore, a Firefly program has no variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Using memory as the display isn’t novel, but it puts us in good company. The
    Manchester Baby, the world’s first stored-program computer with random access
    memory, circa 1948, also used memory as its display (see [Figure 14-1](ch14.xhtml#ch014fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/14fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: The memory/display of the Manchester Baby*'
  prefs: []
  type: TYPE_NORMAL
- en: The Baby’s memory is literally the cathode-ray tube shown in the photograph.
    If a bit was on, one pattern was displayed, and if the bit was off, a slightly
    different pattern was shown. [Figure 14-1](ch14.xhtml#ch014fig1) shows a working
    replica of the original Baby built at the University of Manchester in 1998 in
    celebration of the original Baby’s 50th anniversary.
  prefs: []
  type: TYPE_NORMAL
- en: The Baby had memory for 32 instructions of 32 bits each. It was a von Neumann
    machine, meaning program memory and data storage were mixed as they are in a modern
    desktop computer. Firefly is more like a Harvard architecture machine, as memory
    for data and program instructions is separate. Many microcontrollers use a Harvard
    architecture. In our case, the display is the data memory and a Python string
    represents program memory.
  prefs: []
  type: TYPE_NORMAL
- en: We have two versions of the Firefly interpreter to work with. The console version
    is intended for program creation. It knows how to parse input text to remove whitespace
    and comments. It also supports program tracing. When the program is working as
    it should, a utility converts the source code to a form we can load onto the micro:bit.
    The micro:bit runs a single Python program. For Firefly, the program is the interpreter
    with the source code we want to execute embedded in it as a string constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the simplest way to understand Firefly is to detail its instructions.
    Knowing what the instructions do tells us how to use them. Firefly instructions
    are single characters and case insensitive. The instructions fall into distinct
    groups: movement, display, music, and whatever’s left. Most instructions relate
    to movement, so we’ll begin with those.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Movement***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Firefly move instructions fall into two groups: those that move the firefly
    and those that define what happens to the position the firefly leaves when it
    moves. We’ll refer to these latter instructions as setting the *mode*. Movement
    is north, south, east, or west, with the option to stay put (see [Table 14-1](ch14.xhtml#ch014tab1)).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 14-1:** Firefly Movement Commands'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Effect** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| N | Move north |'
  prefs: []
  type: TYPE_TB
- en: '| S | Move south |'
  prefs: []
  type: TYPE_TB
- en: '| E | Move east |'
  prefs: []
  type: TYPE_TB
- en: '| W | Move west |'
  prefs: []
  type: TYPE_TB
- en: '| T | Stay put (“tick” of the clock) |'
  prefs: []
  type: TYPE_TB
- en: What happens to the position after the firefly moves is the mode given in [Table
    14-2](ch14.xhtml#ch014tab2). Note that when the program begins, the firefly is
    in move-only mode at position (2,2).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 14-2:** Firefly Intensity (Mode) Commands'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Effect** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0–9 | Constant intensity value |'
  prefs: []
  type: TYPE_TB
- en: '| I | Increment the current value |'
  prefs: []
  type: TYPE_TB
- en: '| D | Decrement the current value |'
  prefs: []
  type: TYPE_TB
- en: '| M | Move only; no change in value |'
  prefs: []
  type: TYPE_TB
- en: '| R | Random value 1 through 9 |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s consider a program that begins with the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the firefly will move south twice to be at position (4,2), set the intensity
    to 5, and then move north five times to arrive back at position (4,2) with a vertical
    trail of five 5s behind it so that the display looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 | 0 | 5 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 5 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 5 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 5 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 5 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '[Figure 14-2](ch14.xhtml#ch014fig2) illustrates the process.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/14fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: How the firefly moves*'
  prefs: []
  type: TYPE_NORMAL
- en: The first command, `S`, moves the firefly south from (2,2) to (3,2), as shown
    with the arrow. The next `S` moves the firefly to (4,2). The `5` sets the trail
    to intensity 5\. Lastly, the five `N` commands move the firefly as shown, leaving
    a trail behind it and finishing at position (4,2).
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is no way to ask what the current value of a position is. When
    the program starts, all positions are 0\. If the move mode is increment, adding
    1 to the current position’s value wraps around, so 9 becomes 0\. Similarly, if
    the mode is decrement, 0 wraps around to become 9\. Use mode `R` to set the value
    to a random integer between 1 and 9.
  prefs: []
  type: TYPE_NORMAL
- en: '***Display***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Double buffering maintains two 5×5 memory grids. Only one grid is shown at a
    time, and it’s possible to create any combination of the grid shown and the grid
    the firefly is making a trail on. We’ll call our two grids A and B. When the program
    starts, grid A is shown and the firefly draws on grid A. The display instructions
    are in [Table 14-3](ch14.xhtml#ch014tab3).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 14-3:** Firefly Display Commands'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Effect** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| X | Show grid A |'
  prefs: []
  type: TYPE_TB
- en: '| Y | Show grid B |'
  prefs: []
  type: TYPE_TB
- en: '| A | Draw on grid A |'
  prefs: []
  type: TYPE_TB
- en: '| B | Draw on grid B |'
  prefs: []
  type: TYPE_TB
- en: '| C | Clear active grid |'
  prefs: []
  type: TYPE_TB
- en: '| V | Clear grid A |'
  prefs: []
  type: TYPE_TB
- en: '| Z | Clear grid B |'
  prefs: []
  type: TYPE_TB
- en: The instruction `C` clears the grid currently being displayed, but `V` and `Z`
    clear their respective grids regardless of which one is currently displayed. Therefore,
    to show grid A but make the firefly draw on grid B, execute `XB`, and then, when
    the firefly is done drawing, show grid B with `Y`. We’ll explore animation more
    in [Chapter 15](ch15.xhtml#ch15).
  prefs: []
  type: TYPE_NORMAL
- en: '***Music***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To make the firefly sing, we need the three instructions in [Table 14-4](ch14.xhtml#ch014tab4).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 14-4:** Firefly Music Commands'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Effect** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| J | Set note duration |'
  prefs: []
  type: TYPE_TB
- en: '| G | Set octave |'
  prefs: []
  type: TYPE_TB
- en: '| F | Play a note |'
  prefs: []
  type: TYPE_TB
- en: Each instruction uses the value of the firefly’s current position for the duration,
    octave, or note.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the hood, these instructions use the `play` function in the MicroPython
    `music` module. The easiest instructions to understand are duration and octave.
    The micro:bit range is such that octave 4 includes middle C, which is the default
    value. So, to set the octave to 4, we first need to set the firefly’s current
    position and then the octave: `4TG`. The `4` sets the mode to 4, meaning the firefly’s
    trail uses intensity 4\. Next, we keep the firefly in place with `T`. Lastly,
    we set the octave with `G`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that durations are relative, with a duration of 4 being a reasonable value
    for a quarter note. Therefore, a duration of 2 implies an eighth note and 8 a
    half note. Durations, and octaves, are persistent, meaning that once set, their
    value will stay until changed. To set the duration to quarter notes, use something
    like `4TJ`.
  prefs: []
  type: TYPE_NORMAL
- en: To play a note, we need `F`. The firefly’s current position indicates the actual
    note according to [Table 14-5](ch14.xhtml#ch014tab5).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 14-5:** Firefly Note Commands'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Value** | **Note** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Rest |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | C |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | D |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | E |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | F |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | G |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | A |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | B |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Rest (same as 0) |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | C (same as 1) |'
  prefs: []
  type: TYPE_TB
- en: As an example, to play middle C as a quarter note, we would need something like
    `1TF` to set the move mode, or intensity, to 1 (“move” by staying in place); this
    sets the current position to 1, and `F` to play the note. This assumes that the
    octave and duration are both their default values of 4\. As Firefly memory holds
    only a single digit at a time, we are limited to the C major scale with no sharps
    or flats.
  prefs: []
  type: TYPE_NORMAL
- en: Our singing firefly will have several opportunities to serenade us in [Chapter
    15](ch15.xhtml#ch15).
  prefs: []
  type: TYPE_NORMAL
- en: '***What’s Left***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Only three instructions remain. The first is `H`, which stops the program. Similar
    to `H` is `L`, which enters an eternal loop (that is, sleeps the program). The
    difference between the two is most noticeable with the micro:bit. If `H` is executed,
    the program stops and Python clears the display. If we execute `L` instead, the
    program sleeps “forever” and the display remains active.
  prefs: []
  type: TYPE_NORMAL
- en: The final instruction is `P`, which pauses for 0.1 seconds before continuing.
    Use `P` to add timing effects. We’ll see `P` in [Chapter 15](ch15.xhtml#ch15)
    when we implement a tea timer and a counter.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 14-6](ch14.xhtml#ch014tab6) serves as a reference for all Firefly instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 14-6:** The Firefly Instruction Set'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Effect** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| N | Move north |'
  prefs: []
  type: TYPE_TB
- en: '| S | Move south |'
  prefs: []
  type: TYPE_TB
- en: '| E | Move east |'
  prefs: []
  type: TYPE_TB
- en: '| W | Move west |'
  prefs: []
  type: TYPE_TB
- en: '| T | Stay put (“tick” of the clock) |'
  prefs: []
  type: TYPE_TB
- en: '| 0–9 | Constant intensity value |'
  prefs: []
  type: TYPE_TB
- en: '| I | Increment the current value |'
  prefs: []
  type: TYPE_TB
- en: '| D | Decrement the current value |'
  prefs: []
  type: TYPE_TB
- en: '| M | Move only, no change in value |'
  prefs: []
  type: TYPE_TB
- en: '| R | Random value 1 through 9 |'
  prefs: []
  type: TYPE_TB
- en: '| X | Show grid A |'
  prefs: []
  type: TYPE_TB
- en: '| Y | Show grid B |'
  prefs: []
  type: TYPE_TB
- en: '| A | Draw on grid A |'
  prefs: []
  type: TYPE_TB
- en: '| B | Draw on grid B |'
  prefs: []
  type: TYPE_TB
- en: '| C | Clear active grid |'
  prefs: []
  type: TYPE_TB
- en: '| V | Clear grid A |'
  prefs: []
  type: TYPE_TB
- en: '| Z | Clear grid B |'
  prefs: []
  type: TYPE_TB
- en: '| J | Set note duration |'
  prefs: []
  type: TYPE_TB
- en: '| G | Set octave |'
  prefs: []
  type: TYPE_TB
- en: '| F | Play a note |'
  prefs: []
  type: TYPE_TB
- en: '| P | Pause for 0.1 seconds |'
  prefs: []
  type: TYPE_TB
- en: '| L | Loop forever |'
  prefs: []
  type: TYPE_TB
- en: '| H | Halt |'
  prefs: []
  type: TYPE_TB
- en: Now, let’s get down to business and actually implement the language.
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Firefly is written in Python, both for simplicity and because the micro:bit
    runs only a single Python program. We’ll list Python code for the micro:bit version
    here, but show example Firefly code for the console version in [Chapter 15](ch15.xhtml#ch15).
    Doing this lets us use whitespace and comments. In [Chapter 15](ch15.xhtml#ch15),
    we’ll walk through the development process, which typically involves both the
    console and micro:bit interpreters.
  prefs: []
  type: TYPE_NORMAL
- en: Firefly programs are ultimately a string of uppercase letters and digits. For
    the micro:bit, the string is literally embedded within the Python code for the
    interpreter after all whitespace has been removed. The micro:bit does have a flat
    file system, but it’s simpler to embed the Firefly code at the top of the interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: The console interpreter allows whitespace and comments beginning with an exclamation
    point (`!`) and running to the end of the current line. The console interpreter
    also supports execution tracing, which we’ll see in [Chapter 15](ch15.xhtml#ch15).
  prefs: []
  type: TYPE_NORMAL
- en: '***Interpreter Structure and Main Loop***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Firefly interpreter consists of a set of global variables, including the
    displays, a few functions to handle specific Firefly instructions, and the main
    loop that executes character after character of the program string. The implementation
    is deliberately not object oriented, in part to possibly reduce overhead and preserve
    room on the micro:bit for Firefly code, and in part to be old-school about things
    as a change of pace. Therefore, the interpreter begins with a series of declarations
    and necessary imports (see [Listing 14-1](ch14.xhtml#ch014list1)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-1: Firefly interpreter preamble*'
  prefs: []
  type: TYPE_NORMAL
- en: The global variable `PRG` holds the Firefly program to execute. The example
    program in [Listing 14-1](ch14.xhtml#ch014list1) plays a simple scale.
  prefs: []
  type: TYPE_NORMAL
- en: Necessary Python imports come next. The first two functions are exclusive to
    MicroPython, which runs on the micro:bit; they handle the LED display and playing
    musical notes, respectively. The `time` and `random` modules are standard Python
    fare. We use `sleep` to implement the `P` instruction and `randint` for the `R`
    movement mode.
  prefs: []
  type: TYPE_NORMAL
- en: The Firefly display, a 5×5 grid of single-digit values, is stored in a Python
    `bytearray`. There are two of them, `A` and `B`. The display currently shown is
    the array assigned to `D`, with `A` being the default. Likewise, the array currently
    drawn to by the moving firefly is in `C`, which is also `A` by default. `M` holds
    the current movement mode with `"M"`, which is the default value and means “move
    with no trail.”
  prefs: []
  type: TYPE_NORMAL
- en: The display is in `A` or `B` with `I` as the index or current position of the
    firefly. When needed, this index is converted into row and column. The default
    note duration is in `dur` and the default note octave is in `oc`. When the program
    starts, the actual micro:bit display is cleared (`display.clear()`).
  prefs: []
  type: TYPE_NORMAL
- en: After the preamble in [Listing 14-1](ch14.xhtml#ch014list1) come seven function
    definitions. We’ll get to these in the following sections. The main loop comes
    last. Note that there is no `main` function, as the interpreter runs as a script.
    The main loop is in [Listing 14-2](ch14.xhtml#ch014list2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-2: Firefly interpreter main loop*'
  prefs: []
  type: TYPE_NORMAL
- en: The main loop runs as long as `R` is `True`. This means that a Firefly program
    will begin again after the last instruction. It also means that memory will not
    be erased. This is the only looping supported by Firefly. We’ll see how to use
    it in [Chapter 15](ch15.xhtml#ch15) when we implement a counter.
  prefs: []
  type: TYPE_NORMAL
- en: The inner `for` loop is over the characters representing the Firefly program
    (`PRG`). Interpretation is a straightforward nested `if` statement. Certain instructions
    are handled directly in the `for` loop, like setting the movement mode to increment
    (`I`) or decrement (`D`). If the current character, `c`, is a digit (in `DIGITS`),
    the move mode is set to that digit value, `M=c`.
  prefs: []
  type: TYPE_NORMAL
- en: The only way to exit a Firefly program completely is to execute `H`, which sets
    `R` to `False` and then uses `break` to exit the inner `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Movement instructions (`MOVES`), display instructions (`BUFS`), and playing
    a note (`F`) all call out to external functions to perform actions.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the note duration (`J`) and note octave (`G`) instructions. They set
    the `dur` or `oc` global variables to `C[I]`. The index, `I`, represents the firefly’s
    current position in the range [0,24], and `C` is assigned the `bytearray` for
    the memory the firefly is currently drawing to, either `A` or `B`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A call to `Update` happens after each instruction is executed to update the
    micro:bit display. This is what the `Update` function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A simple loop over the 25 elements of the `bytearray` assigned to global variable
    `D` determines the brightness of each of the LEDs in the 5×5 display. Note the
    conversion from a linear index (`i`) to display column (`i%5`) and row (`i//5`)
    for the currently active memory (`D`).
  prefs: []
  type: TYPE_NORMAL
- en: The final set of instructions—the bottom of the main loop shown in [Listing
    14-2](ch14.xhtml#ch014list2)—resets the display at the end of the program and
    then executes again from the beginning. Note that the default firefly position
    of (2,2) is set, as is showing and drawing on the first memory, `A`. However,
    the memories themselves are *not* reset to 0.
  prefs: []
  type: TYPE_NORMAL
- en: '***Movement***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Memory is not updated unless the firefly “moves.” What happens when the firefly
    moves is determined by the value of global variable `M`, which holds the current
    move mode. [Listing 14-3](ch14.xhtml#ch014list3) shows how movement is processed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-3: Firefly interpreter movement*'
  prefs: []
  type: TYPE_NORMAL
- en: First, the current mode is applied to the *current* firefly position ➊. Incrementing
    the position wraps around after 9 while decrementing wraps the other way if below
    0\. If the mode is `R`, a random integer is assigned to the current memory location,
    `C[I]`. Lastly, if the mode is a digit, that value is used to update memory.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the interpreter converts the linear index into memory, `I`, to a row (`i`)
    and column (`j`) format so that we can apply the actual movement command ➋. Integer
    division by 5 maps `I` to 0 through 4 to give us the row. The modulo, that is,
    what’s left over after integer division by 5, gives us the remainder representing
    the column.
  prefs: []
  type: TYPE_NORMAL
- en: The current move is now applied ➌. Note that `Move` is called only if the instruction
    is a move instruction. The cardinal directions update the row and column position
    accordingly, wrapping around as needed so that moving east when in column 4 moves
    back around to column 0, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There are two special move commands, `T` and `L`. The former acts like a tick
    of a clock. The firefly doesn’t actually move to a new position, hence `pass`,
    but the interpreter does update the current position. The latter instruction,
    `L`, is specifically for the micro:bit. It enters an infinite loop that sleeps
    for 1,000 seconds before waking up briefly, only to sleep again. As stated above,
    a Firefly program executes `H` to halt the program and the interpreter exits.
    On the micro:bit, when a program exits, the display is cleared. Calling `L` instead
    of `H` preserves the display.
  prefs: []
  type: TYPE_NORMAL
- en: After the move command is executed, `i` and/or `j` have been updated. Before
    returning to the main loop, a new value for `I` is calculated by multiplying the
    row number (`i`) by 5, which is the number of elements per row, and adding the
    column number (`j`).
  prefs: []
  type: TYPE_NORMAL
- en: '***Display***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Four functions control the display, as shown in [Listing 14-4](ch14.xhtml#ch014list4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 14-4: Firefly interpreter display*'
  prefs: []
  type: TYPE_NORMAL
- en: Three of the functions in [Listing 14-4](ch14.xhtml#ch014list4), `Clear`, `ClearA`,
    and `ClearB`, simply zero the display memory. The first function zeroes the current
    display, and the last two zero a given display, that is, `A` or `B`. Simply assigning
    a new `bytearray` to these global variables will not work because that would break
    the link with `A` and `B`, which are `bytearray` objects, while `C` and `D` act
    more like pointers that reference `A` or `B`. Recall that `C` references the memory
    the firefly is updating and `D` references the memory currently displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The `Display` function updates the displayed or drawn-to memory based on the
    argument, `c`. Specifying `"A"` as the argument makes `C` reference `*A*` . Likewise,
    passing `"B"` points `C` at `B`. Passing `"X"` changes the displayed memory to
    `A` and passing `"Y"` points the display to `B`. Note that the `global` statements
    used by these functions to update the global variables properly. Most Python programs
    use objects, so the `global` keyword is seldom used. We decided on a strictly
    imperative implementation of Firefly, thereby requiring `global` statements.
  prefs: []
  type: TYPE_NORMAL
- en: '***Music***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ve surveyed the main interpreter loop, movement, and display. Now let’s finish
    Firefly by implementing the music instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The `J` and `G` instructions, which set the note duration and octave, respectively,
    are in the main loop (see [Listing 14-1](ch14.xhtml#ch014list1)). The play instruction,
    `F`, calls `*Play*` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`Play` translates the current firefly position into a note string and then
    plays the note using the current octave and duration via the MicroPython `music`
    function, `play`. There are 10 possible values for a memory location, so the note
    is modulo 8 to handle cases where the memory value is 8 or 9 by wrapping around
    to 0 and 1 instead.'
  prefs: []
  type: TYPE_NORMAL
- en: With `Play`, our micro:bit implementation of Firefly is complete. As mentioned
    earlier, the console version has extra code to handle console cursor positioning,
    execution tracing, and to capture SIGINT via CTRL-C; please do take a look at
    how those features are implemented by reading through *firefly.py*, which is the
    name of the console version of the interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: We’re almost ready for some Firefly programming. However, if we’re using an
    actual micro:bit, we should become at least familiar enough with it to configure
    a speaker and power it up. We’ll save programming the micro:bit for [Chapter 15](ch15.xhtml#ch15).
    For now, let’s take a crash course in micro:bit hardware.
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuring the Micro:bit**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The BBC micro:bit (*[https://microbit.org/](https://microbit.org/)*) is a small,
    single-board computer. Out of the box, it runs MicroPython (see the documentation
    at *[https://microbit-micropython.readthedocs.io/en/v2-docs/](https://microbit-micropython.readthedocs.io/en/v2-docs/)*).
    The micro:bit is intended to introduce as many people as possible to programming
    via an inexpensive computer system. There are two versions available: the older
    v1 which has 16KB of RAM, and the newer v2 with 128KB of RAM. Both versions are
    geared toward hardware projects, and a plethora of accessories exist (*[https://microbit.org/buy/accessories/](https://microbit.org/buy/accessories/)*).
    To learn more about the impressive amount of hardware supported by the micro:bit
    itself, see [https://tech.microbit.org/hardware/](https://tech.microbit.org/hardware/).
    Lastly, to learn more about implementing hardware projects with the micro:bit,
    see Simon Monk’s excellent book *Micro:bit for Mad Scientists* (No Starch Press,
    2019).'
  prefs: []
  type: TYPE_NORMAL
- en: '***Micro:bit Hardware Overview***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 14-3](ch14.xhtml#ch014fig3) details the micro:bit and its features.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/14fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: A hardware overview of the micro:bit (version 2)*'
  prefs: []
  type: TYPE_NORMAL
- en: Of primary interest to us is the 5×5 LED display, the speaker, and the Micro-USB
    connector to program the device. If you have the older version 1 device, there
    is no built-in speaker. In that case, you’ll need to attach an external speaker;
    see the following section.
  prefs: []
  type: TYPE_NORMAL
- en: The micro:bit comes with a small battery pack for two AAA batteries. However,
    it runs just fine from the Micro-USB connector when attached to a computer or
    a 5V power supply. However, early versions of the micro:bit, those before version
    1.3B, should not be run from an external 5V supply. If your micro:bit has a speaker,
    it’s good to go. If it doesn’t, check the version, which is visible on the back
    in small print near the right side of the edge connector, to make sure it is at
    least version 1.3B or 1.5.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using an External Speaker***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Skip this section if your micro:bit is version 2 with a built-in speaker. For
    version 1 devices, we’ll need to add an external speaker, but have no fear: doing
    so is painless. Let’s walk through the process.'
  prefs: []
  type: TYPE_NORMAL
- en: First, you need a speaker of some sort. If you have an old speaker from a defunct
    electronics device, like an old radio, you can use it. In years past, most tinkerers
    had many such speakers pulled from dead transistor radios. However, in this day
    and age, it’s more likely you don’t have a bare speaker lying around. But not
    all is lost! It turns out that a pair of headphones will work just fine.
  prefs: []
  type: TYPE_NORMAL
- en: The micro:bit edge connector is the interface between the micro:bit and external
    hardware devices. To connect a speaker, attach one wire to connector 0 (the one
    with the “0” on it), and the other wire to the connector marked “GND.” If using
    headphones, connect the headphone plug’s tip to connector 0 and the part of the
    plug farthest from the tip to the GND connector. The connections are easiest to
    make with alligator clips, but if you don’t have those handy, bare wires twisted
    together and wrapped around the connectors going through the holes on the micro:bit
    will do the trick. [Figure 14-4](ch14.xhtml#ch014fig4) shows how to connect a
    generic speaker using alligator clips. The inset shows how to connect headphones.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/14fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Connecting an external speaker or headphones*'
  prefs: []
  type: TYPE_NORMAL
- en: Some speakers are marked with plus (+) and minus (–) connections. If so, connect
    the white wire in [Figure 14-4](ch14.xhtml#ch014fig4) to the + connection and
    the red to the – connection. Don’t worry if the speaker isn’t marked for polarity;
    it will still work whichever way you connect the wires. For the headphones, the
    part of the plug farthest from the tip is usually ground, so connect the red wire
    to it and the white to the tip.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced us to Firefly, its design, and the rationale behind
    it. We then walked through the implementation as we’ll soon run it on the micro:bit
    and concluded by configuring the micro:bit for our Firefly experiments. Firefly
    is about as simple as a programming language gets. Now, let’s watch some fireflies
    and see what they can do.
  prefs: []
  type: TYPE_NORMAL
