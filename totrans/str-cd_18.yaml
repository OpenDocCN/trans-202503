- en: '14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '14'
- en: FIREFLY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: FIREFLY
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common01.jpg)'
- en: Firefly is a minimalist programming language for animation and sound. Firefly
    targets the BBC micro:bit, but you don’t need one to have fun with the language—the
    console version will work just fine. The inspiration for the language comes from
    the 5×5 grid of LEDs that form the display of the micro:bit. The language manipulates
    a “firefly” that lives on the grid. As it flies, it leaves a luminous trail of
    light behind it. Oh, the firefly also sings, because why not?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 萤火虫是一种用于动画和声音的极简主义编程语言。萤火虫主要面向BBC的micro:bit，但你并不需要一个micro:bit就能玩得开心——控制台版本也能正常运行。这门语言的灵感来自于micro:bit上形成显示屏的5×5
    LED网格。该语言操作的是一个“萤火虫”，它在网格上飞行。当它飞行时，会留下光亮的轨迹。哦，萤火虫还会唱歌，因为为什么不呢？
- en: This chapter introduces the philosophy and design of the language, followed
    by its implementation. The chapter ends with a section on configuring a micro:bit,
    should you wish to use one for the experiments of [Chapter 15](ch15.xhtml#ch15).
    Again, you don’t need a micro:bit; you can run everything just fine at the command
    line using the console version of the interpreter. However, the micro:bit isn’t
    too expensive, and it’s a fun little device that itself runs Python. Also, console
    fireflies don’t know how to sing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了该语言的哲学和设计，并随后介绍了它的实现。章节最后将介绍如何配置micro:bit，以便你希望在[第15章](ch15.xhtml#ch15)的实验中使用它。再次强调，你并不需要一个micro:bit；你可以通过使用解释器的控制台版本在命令行上顺利运行所有内容。不过，micro:bit并不贵，它是一个有趣的小设备，并且它本身可以运行Python。而且，控制台版的萤火虫可不会唱歌。
- en: '**Philosophy and Design**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**哲学与设计**'
- en: 'Our environment is this: a small firefly is flying around a tiny 5×5 grid.
    As it flies, it leaves behind a luminous trail and sometimes sings.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的环境是这样的：一只小萤火虫在一个微小的5×5网格上飞行。随着它飞行，会留下光亮的轨迹，有时它还会唱歌。
- en: To be more specific, a Firefly program manipulates a 5×5 grid of single digits.
    On the micro:bit, these become intensities of the 5×5 grid of LEDs. The firefly
    can sing by making the micro:bit sound a note of a particular pitch and duration.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，一段萤火虫程序操作的是一个5×5的数字网格。在micro:bit上，这些数字变成了5×5 LED网格的亮度。萤火虫可以通过让micro:bit发出某个特定音高和时长的音符来“唱歌”。
- en: A Firefly program is a series of single-character instructions that either move
    the firefly around the grid, set the way its luminous trail acts, or make the
    firefly sing a note. The Firefly language also supports what is known as *double
    buffering*, meaning instead of one 5×5 grid of digits, there are two 5×5 grids.
    The program controls which grid is shown to the user and which grid the firefly
    is making a trail on (drawing to). Double buffering is a common computer animation
    technique in which the user sees one display while the program is updating the
    other and then the view switches. Doing this prevents the user from watching the
    display draw and makes for smooth animation. Don’t worry if double buffering is
    a new concept; we’ll detail it in [Chapter 15](ch15.xhtml#ch15) when we use it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一段萤火虫程序是一系列单字符指令，这些指令要么移动萤火虫在网格上飞行，要么设置它的光亮轨迹如何变化，或者让萤火虫发出音符。萤火虫语言还支持一种叫做*双缓冲*的技术，这意味着它不仅仅是一个5×5的数字网格，而是有两个5×5的网格。程序控制哪个网格展示给用户，哪个网格上则是萤火虫在留下轨迹（即绘制）。双缓冲是计算机动画中常用的一种技术，用户看到一个显示画面，而程序则在更新另一个画面，然后切换视图。这样做可以避免用户看到绘制过程，提供更平滑的动画效果。如果你对双缓冲概念不太熟悉，别担心；我们将在[第15章](ch15.xhtml#ch15)中详细讲解它的应用。
- en: A Firefly program instructs the firefly by directing its movements and when
    and how it should sing. If you’ve never heard a singing firefly, you’re in good
    company because I haven’t either. Still, it’s fun to pretend.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一段萤火虫程序通过指导萤火虫的移动以及它何时、如何发声来指示萤火虫的行为。如果你从未听过萤火虫唱歌，你并不孤单，因为我也没听过。不过，假装它会唱歌还是挺有趣的。
- en: The firefly is constrained to move on a 5×5 grid. The upper-left corner of the
    grid is position (0,0), and the lower-right corner is position (4,4). Positions
    are given as the row number before the column number. The firefly moves one position
    at a time, either north (`N`), south (`S`), east (`E`), or west (`W`). When it
    moves off one edge of the grid, it wraps around to the other side. For instance,
    moving east from position (1,4) puts the firefly at position (1,0). Likewise,
    a firefly moving south from (4,2) arrives at position (0,2).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 萤火虫被限制在一个5×5的网格上移动。网格的左上角是位置 (0,0)，右下角是位置 (4,4)。位置的表示方式是先给出行号，再给出列号。萤火虫一次只能移动一个位置，可以向北（`N`）、向南（`S`）、向东（`E`）或向西（`W`）移动。当它越过网格的一边时，会绕回到另一边。例如，从位置
    (1,4) 向东移动，萤火虫将到达位置 (1,0)。同样，从位置 (4,2) 向南移动，萤火虫将到达位置 (0,2)。
- en: When the firefly moves, it leaves behind a trail, meaning it sets the position
    it *just left* to some value. On the micro:bit, the value is the LED’s intensity
    at that position where 0 is off and 9 is maximum brightness. The console interpreter
    shows 0 as space and anything else as the numeric value of the position, but if
    desired, the console will show 0 as `0`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当萤火虫移动时，它会留下一个轨迹，意味着它会将它*刚刚离开的*位置设置为某个值。在 micro:bit 上，值是该位置的LED强度，0表示关闭，9表示最大亮度。控制台解释器显示0为空格，其他值显示为位置的数字值，但如果需要，控制台将显示0为
    `0`。
- en: Therefore, if the firefly is currently at position (2,2) and the intensity is
    set to 3, an instruction telling the firefly to move one position to the west,
    that is, to (2,1), will set position (2,2) to intensity 3\. There is also an instruction
    telling the firefly to stay put, so it is possible to update a position value
    in place.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果萤火虫当前位于位置 (2,2)，且强度设置为3，则一条指令让萤火虫向西移动一个位置，也就是移动到 (2,1)，将会把位置 (2,2) 的强度设置为3。同时，也有指令让萤火虫保持原地不动，因此可以在当前位置更新位置值。
- en: 'The 5×5 grid is all the memory we have. It’s also the display: we see the value
    of each grid cell as a number (console) or brightness of the LED (micro:bit).
    Therefore, a Firefly program has no variables.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 5×5的网格就是我们所拥有的所有内存。它也是显示器：我们可以看到每个网格单元的值，可以是数字（控制台）或LED的亮度（micro:bit）。因此，萤火虫程序没有变量。
- en: Using memory as the display isn’t novel, but it puts us in good company. The
    Manchester Baby, the world’s first stored-program computer with random access
    memory, circa 1948, also used memory as its display (see [Figure 14-1](ch14.xhtml#ch014fig1)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内存作为显示并不新颖，但这让我们与优秀的前辈为伍。曼彻斯特婴儿，世界上第一台具有随机存取内存的存储程序计算机，诞生于1948年，它也使用内存作为显示（见[图
    14-1](ch14.xhtml#ch014fig1)）。
- en: '![Image](Images/14fig01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/14fig01.jpg)'
- en: '*Figure 14-1: The memory/display of the Manchester Baby*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-1：曼彻斯特婴儿的内存/显示*'
- en: The Baby’s memory is literally the cathode-ray tube shown in the photograph.
    If a bit was on, one pattern was displayed, and if the bit was off, a slightly
    different pattern was shown. [Figure 14-1](ch14.xhtml#ch014fig1) shows a working
    replica of the original Baby built at the University of Manchester in 1998 in
    celebration of the original Baby’s 50th anniversary.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 婴儿的内存实际上就是照片中显示的阴极射线管。如果某个位打开，就显示一种模式；如果该位关闭，则显示另一种稍微不同的模式。[图 14-1](ch14.xhtml#ch014fig1)
    展示了1998年曼彻斯特大学为庆祝原始婴儿50周年而制作的工作原型。
- en: The Baby had memory for 32 instructions of 32 bits each. It was a von Neumann
    machine, meaning program memory and data storage were mixed as they are in a modern
    desktop computer. Firefly is more like a Harvard architecture machine, as memory
    for data and program instructions is separate. Many microcontrollers use a Harvard
    architecture. In our case, the display is the data memory and a Python string
    represents program memory.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 婴儿拥有32条32位指令的内存。它是一台冯·诺依曼机器，这意味着程序内存和数据存储是混合的，就像现代桌面计算机一样。而萤火虫更像是一台哈佛架构的计算机，因为数据内存和程序指令的内存是分开的。许多微控制器使用哈佛架构。在我们的例子中，显示是数据内存，而Python字符串表示程序内存。
- en: We have two versions of the Firefly interpreter to work with. The console version
    is intended for program creation. It knows how to parse input text to remove whitespace
    and comments. It also supports program tracing. When the program is working as
    it should, a utility converts the source code to a form we can load onto the micro:bit.
    The micro:bit runs a single Python program. For Firefly, the program is the interpreter
    with the source code we want to execute embedded in it as a string constant.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个版本的萤火虫解释器可供使用。控制台版本用于程序创建。它知道如何解析输入文本以去除空格和注释。它还支持程序跟踪。当程序正常工作时，一个实用程序将源代码转换为可加载到微控制器的形式。微控制器运行一个单独的Python程序。对于萤火虫，程序是解释器，其中包含我们想要执行的源代码作为字符串常量。
- en: 'Perhaps the simplest way to understand Firefly is to detail its instructions.
    Knowing what the instructions do tells us how to use them. Firefly instructions
    are single characters and case insensitive. The instructions fall into distinct
    groups: movement, display, music, and whatever’s left. Most instructions relate
    to movement, so we’ll begin with those.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 或许理解萤火虫最简单的方法是详细说明其指令。了解指令的作用告诉我们如何使用它们。萤火虫的指令是单个字符且不区分大小写。这些指令可以分为不同的组别：移动、显示、音乐以及其他。大多数指令与移动有关，因此我们从这些指令开始讨论。
- en: '***Movement***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***移动***'
- en: 'Firefly move instructions fall into two groups: those that move the firefly
    and those that define what happens to the position the firefly leaves when it
    moves. We’ll refer to these latter instructions as setting the *mode*. Movement
    is north, south, east, or west, with the option to stay put (see [Table 14-1](ch14.xhtml#ch014tab1)).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 萤火虫的移动指令分为两组：移动萤火虫的指令以及定义萤火虫移动后位置变化的指令。我们将后者称为设置*模式*。移动可以是北、南、东或西，并可以选择留在原地（见[表
    14-1](ch14.xhtml#ch014tab1)）。
- en: '**Table 14-1:** Firefly Movement Commands'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 14-1：萤火虫移动命令**'
- en: '| **Instruction** | **Effect** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **效果** |'
- en: '| --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| N | Move north |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| N | 向北移动 |'
- en: '| S | Move south |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| S | 向南移动 |'
- en: '| E | Move east |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| E | 向东移动 |'
- en: '| W | Move west |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| W | 向西移动 |'
- en: '| T | Stay put (“tick” of the clock) |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| T | 留在原地（时钟的“滴答”声） |'
- en: What happens to the position after the firefly moves is the mode given in [Table
    14-2](ch14.xhtml#ch014tab2). Note that when the program begins, the firefly is
    in move-only mode at position (2,2).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 萤火虫移动后位置的模式见[表 14-2](ch14.xhtml#ch014tab2)。注意，当程序开始时，萤火虫处于仅移动模式，位于位置（2,2）。
- en: '**Table 14-2:** Firefly Intensity (Mode) Commands'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 14-2：萤火虫强度（模式）命令**'
- en: '| **Instruction** | **Effect** |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **效果** |'
- en: '| --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0–9 | Constant intensity value |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 0–9 | 恒定的强度值 |'
- en: '| I | Increment the current value |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| I | 增加当前值 |'
- en: '| D | Decrement the current value |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| D | 减少当前值 |'
- en: '| M | Move only; no change in value |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| M | 仅移动；值不变 |'
- en: '| R | Random value 1 through 9 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| R | 随机值 1 到 9 |'
- en: 'Let’s consider a program that begins with the following instructions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个以以下指令开始的程序：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, the firefly will move south twice to be at position (4,2), set the intensity
    to 5, and then move north five times to arrive back at position (4,2) with a vertical
    trail of five 5s behind it so that the display looks like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，萤火虫将向南移动两次到达（4,2），设置强度为5，然后向北移动五次返回到位置（4,2），在其后留下垂直轨迹，看起来像这样：
- en: '| 0 | 0 | 5 | 0 | 0 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 5 | 0 | 0 |'
- en: '| 0 | 0 | 5 | 0 | 0 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 5 | 0 | 0 |'
- en: '| 0 | 0 | 5 | 0 | 0 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 5 | 0 | 0 |'
- en: '| 0 | 0 | 5 | 0 | 0 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 5 | 0 | 0 |'
- en: '| 0 | 0 | 5 | 0 | 0 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 5 | 0 | 0 |'
- en: '[Figure 14-2](ch14.xhtml#ch014fig2) illustrates the process.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-2](ch14.xhtml#ch014fig2)说明了这个过程。'
- en: '![Image](Images/14fig02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/14fig02.jpg)'
- en: '*Figure 14-2: How the firefly moves*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：萤火虫的移动方式*'
- en: The first command, `S`, moves the firefly south from (2,2) to (3,2), as shown
    with the arrow. The next `S` moves the firefly to (4,2). The `5` sets the trail
    to intensity 5\. Lastly, the five `N` commands move the firefly as shown, leaving
    a trail behind it and finishing at position (4,2).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个指令 `S` 将萤火虫从（2,2）向南移动到（3,2），如箭头所示。接下来的 `S` 将萤火虫移动到（4,2）。数字 `5` 设置轨迹强度为5。最后的五个
    `N` 指令按照示例移动萤火虫，留下轨迹，并最终停留在位置（4,2）。
- en: Note that there is no way to ask what the current value of a position is. When
    the program starts, all positions are 0\. If the move mode is increment, adding
    1 to the current position’s value wraps around, so 9 becomes 0\. Similarly, if
    the mode is decrement, 0 wraps around to become 9\. Use mode `R` to set the value
    to a random integer between 1 and 9.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，无法查询当前位置的当前值。当程序启动时，所有位置的值为 0。如果移动模式是递增，向当前位置的值添加 1 会环绕，9 变为 0。同样，如果模式是递减，0
    会环绕变为 9。使用模式 `R` 将值设置为 1 到 9 之间的随机整数。
- en: '***Display***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***显示***'
- en: Double buffering maintains two 5×5 memory grids. Only one grid is shown at a
    time, and it’s possible to create any combination of the grid shown and the grid
    the firefly is making a trail on. We’ll call our two grids A and B. When the program
    starts, grid A is shown and the firefly draws on grid A. The display instructions
    are in [Table 14-3](ch14.xhtml#ch014tab3).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 双缓冲维护两个 5×5 的内存网格。一次只能显示一个网格，并且可以创建显示网格和萤火虫在其上绘制轨迹的网格的任何组合。我们将这两个网格称为 A 和 B。当程序启动时，显示网格
    A，并且萤火虫在网格 A 上绘制。显示指令在 [表 14-3](ch14.xhtml#ch014tab3) 中。
- en: '**Table 14-3:** Firefly Display Commands'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 14-3：** 萤火虫显示命令'
- en: '| **Instruction** | **Effect** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **效果** |'
- en: '| --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| X | Show grid A |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| X | 显示网格 A |'
- en: '| Y | Show grid B |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| Y | 显示网格 B |'
- en: '| A | Draw on grid A |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| A | 在网格 A 上绘制 |'
- en: '| B | Draw on grid B |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| B | 在网格 B 上绘制 |'
- en: '| C | Clear active grid |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| C | 清除活动网格 |'
- en: '| V | Clear grid A |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| V | 清除网格 A |'
- en: '| Z | Clear grid B |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| Z | 清除网格 B |'
- en: The instruction `C` clears the grid currently being displayed, but `V` and `Z`
    clear their respective grids regardless of which one is currently displayed. Therefore,
    to show grid A but make the firefly draw on grid B, execute `XB`, and then, when
    the firefly is done drawing, show grid B with `Y`. We’ll explore animation more
    in [Chapter 15](ch15.xhtml#ch15).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 指令 `C` 清除当前显示的网格，但 `V` 和 `Z` 会清除它们各自的网格，无论当前显示的是哪一个。因此，要显示网格 A 但让萤火虫在网格 B 上绘制，执行
    `XB`，然后，当萤火虫绘制完成后，使用 `Y` 显示网格 B。我们将在 [第 15 章](ch15.xhtml#ch15) 中进一步探索动画。
- en: '***Music***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***音乐***'
- en: To make the firefly sing, we need the three instructions in [Table 14-4](ch14.xhtml#ch014tab4).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要让萤火虫发声，我们需要 [表 14-4](ch14.xhtml#ch014tab4) 中的三条指令。
- en: '**Table 14-4:** Firefly Music Commands'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 14-4：** 萤火虫音乐命令'
- en: '| **Instruction** | **Effect** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **效果** |'
- en: '| --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| J | Set note duration |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| J | 设置音符时值 |'
- en: '| G | Set octave |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| G | 设置八度 |'
- en: '| F | Play a note |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| F | 播放音符 |'
- en: Each instruction uses the value of the firefly’s current position for the duration,
    octave, or note.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个指令使用萤火虫当前位置的值来确定时值、八度或音符。
- en: 'Under the hood, these instructions use the `play` function in the MicroPython
    `music` module. The easiest instructions to understand are duration and octave.
    The micro:bit range is such that octave 4 includes middle C, which is the default
    value. So, to set the octave to 4, we first need to set the firefly’s current
    position and then the octave: `4TG`. The `4` sets the mode to 4, meaning the firefly’s
    trail uses intensity 4\. Next, we keep the firefly in place with `T`. Lastly,
    we set the octave with `G`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，这些指令使用 MicroPython `music` 模块中的 `play` 函数。最容易理解的指令是时值和八度。micro:bit 的范围是八度
    4 包含中音 C，这是默认值。因此，要将八度设置为 4，我们首先需要设置萤火虫的当前位置，然后设置八度：`4TG`。`4` 将模式设置为 4，意味着萤火虫的轨迹使用强度
    4。接下来，我们使用 `T` 保持萤火虫在当前位置。最后，我们使用 `G` 设置八度。
- en: Note that durations are relative, with a duration of 4 being a reasonable value
    for a quarter note. Therefore, a duration of 2 implies an eighth note and 8 a
    half note. Durations, and octaves, are persistent, meaning that once set, their
    value will stay until changed. To set the duration to quarter notes, use something
    like `4TJ`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，时值是相对的，时值为 4 是四分音符的合理值。因此，时值为 2 表示八分音符，时值为 8 表示半音符。时值和八度是持久的，意味着一旦设置，它们的值将保持直到被更改。要将时值设置为四分音符，可以使用类似
    `4TJ` 的指令。
- en: To play a note, we need `F`. The firefly’s current position indicates the actual
    note according to [Table 14-5](ch14.xhtml#ch014tab5).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要播放音符，我们需要使用 `F`。萤火虫当前位置的值表示根据 [表 14-5](ch14.xhtml#ch014tab5) 中的音符。
- en: '**Table 14-5:** Firefly Note Commands'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 14-5：** 萤火虫音符命令'
- en: '| **Value** | **Note** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **值** | **音符** |'
- en: '| --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | Rest |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 休止符 |'
- en: '| 1 | C |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 1 | C |'
- en: '| 2 | D |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 2 | D |'
- en: '| 3 | E |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 3 | E |'
- en: '| 4 | F |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 4 | F |'
- en: '| 5 | G |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 5 | G |'
- en: '| 6 | A |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 6 | A |'
- en: '| 7 | B |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 7 | B |'
- en: '| 8 | Rest (same as 0) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 休止符（与 0 相同） |'
- en: '| 9 | C (same as 1) |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 9 | C（与 1 相同） |'
- en: As an example, to play middle C as a quarter note, we would need something like
    `1TF` to set the move mode, or intensity, to 1 (“move” by staying in place); this
    sets the current position to 1, and `F` to play the note. This assumes that the
    octave and duration are both their default values of 4\. As Firefly memory holds
    only a single digit at a time, we are limited to the C major scale with no sharps
    or flats.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，要播放中音C作为四分音符，我们需要类似`1TF`的代码来将移动模式或强度设置为1（“通过停留在原地”进行移动）；这将当前位置设置为1，`F`用来播放音符。假设八度和时值都保持默认值4。由于Firefly内存一次只能保存一个数字，我们只能使用没有升降音的C大调音阶。
- en: Our singing firefly will have several opportunities to serenade us in [Chapter
    15](ch15.xhtml#ch15).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的歌唱萤火虫将在[第15章](ch15.xhtml#ch15)中有几个机会为我们献唱。
- en: '***What’s Left***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***剩余部分***'
- en: Only three instructions remain. The first is `H`, which stops the program. Similar
    to `H` is `L`, which enters an eternal loop (that is, sleeps the program). The
    difference between the two is most noticeable with the micro:bit. If `H` is executed,
    the program stops and Python clears the display. If we execute `L` instead, the
    program sleeps “forever” and the display remains active.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 只剩下三条指令。第一条是`H`，它停止程序。与`H`类似的是`L`，它进入一个永久循环（即让程序进入休眠状态）。两者的区别在于micro:bit上最为明显。如果执行`H`，程序停止，Python会清除显示。如果我们执行`L`，程序将“永远”休眠，显示保持活动状态。
- en: The final instruction is `P`, which pauses for 0.1 seconds before continuing.
    Use `P` to add timing effects. We’ll see `P` in [Chapter 15](ch15.xhtml#ch15)
    when we implement a tea timer and a counter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条指令是`P`，它在继续之前暂停0.1秒。使用`P`可以添加时间效果。当我们实现茶时计和计数器时，会在[第15章](ch15.xhtml#ch15)看到`P`的使用。
- en: '[Table 14-6](ch14.xhtml#ch014tab6) serves as a reference for all Firefly instructions.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[表14-6](ch14.xhtml#ch014tab6)作为所有Firefly指令的参考。'
- en: '**Table 14-6:** The Firefly Instruction Set'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**表14-6：** Firefly指令集'
- en: '| **Instruction** | **Effect** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **效果** |'
- en: '| --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| N | Move north |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| N | 向北移动 |'
- en: '| S | Move south |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| S | 向南移动 |'
- en: '| E | Move east |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| E | 向东移动 |'
- en: '| W | Move west |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| W | 向西移动 |'
- en: '| T | Stay put (“tick” of the clock) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| T | 保持原地（时钟的“滴答”） |'
- en: '| 0–9 | Constant intensity value |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 0–9 | 固定强度值 |'
- en: '| I | Increment the current value |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| I | 增加当前值 |'
- en: '| D | Decrement the current value |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| D | 当前值减一 |'
- en: '| M | Move only, no change in value |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| M | 仅移动，不改变值 |'
- en: '| R | Random value 1 through 9 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| R | 随机值1到9 |'
- en: '| X | Show grid A |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| X | 显示网格A |'
- en: '| Y | Show grid B |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| Y | 显示网格B |'
- en: '| A | Draw on grid A |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| A | 在网格A上绘制 |'
- en: '| B | Draw on grid B |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| B | 在网格B上绘制 |'
- en: '| C | Clear active grid |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| C | 清除活动网格 |'
- en: '| V | Clear grid A |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| V | 清除网格A |'
- en: '| Z | Clear grid B |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| Z | 清除网格B |'
- en: '| J | Set note duration |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| J | 设置音符时值 |'
- en: '| G | Set octave |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| G | 设置八度 |'
- en: '| F | Play a note |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| F | 播放音符 |'
- en: '| P | Pause for 0.1 seconds |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| P | 暂停0.1秒 |'
- en: '| L | Loop forever |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| L | 永久循环 |'
- en: '| H | Halt |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| H | 停止 |'
- en: Now, let’s get down to business and actually implement the language.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始动手，真正实现这个语言。
- en: '**Implementation**'
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实现**'
- en: Firefly is written in Python, both for simplicity and because the micro:bit
    runs only a single Python program. We’ll list Python code for the micro:bit version
    here, but show example Firefly code for the console version in [Chapter 15](ch15.xhtml#ch15).
    Doing this lets us use whitespace and comments. In [Chapter 15](ch15.xhtml#ch15),
    we’ll walk through the development process, which typically involves both the
    console and micro:bit interpreters.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Firefly是用Python编写的，既为了简便，又因为micro:bit只能运行一个Python程序。我们将在这里列出micro:bit版本的Python代码，但在[第15章](ch15.xhtml#ch15)中显示控制台版本的Firefly代码。这样做可以让我们使用空格和注释。在[第15章](ch15.xhtml#ch15)中，我们将带你走过开发过程，这通常包括控制台和micro:bit解释器。
- en: Firefly programs are ultimately a string of uppercase letters and digits. For
    the micro:bit, the string is literally embedded within the Python code for the
    interpreter after all whitespace has been removed. The micro:bit does have a flat
    file system, but it’s simpler to embed the Firefly code at the top of the interpreter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Firefly程序最终是一串大写字母和数字。对于micro:bit来说，这串字符串实际上嵌入在Python解释器的代码中，所有空格被去除后。micro:bit确实有一个扁平文件系统，但将Firefly代码嵌入到解释器顶部会更简单。
- en: The console interpreter allows whitespace and comments beginning with an exclamation
    point (`!`) and running to the end of the current line. The console interpreter
    also supports execution tracing, which we’ll see in [Chapter 15](ch15.xhtml#ch15).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台解释器允许空格和以感叹号（`!`）开头的注释，注释会持续到当前行的末尾。控制台解释器还支持执行跟踪，我们将在[第15章](ch15.xhtml#ch15)看到。
- en: '***Interpreter Structure and Main Loop***'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***解释器结构与主循环***'
- en: The Firefly interpreter consists of a set of global variables, including the
    displays, a few functions to handle specific Firefly instructions, and the main
    loop that executes character after character of the program string. The implementation
    is deliberately not object oriented, in part to possibly reduce overhead and preserve
    room on the micro:bit for Firefly code, and in part to be old-school about things
    as a change of pace. Therefore, the interpreter begins with a series of declarations
    and necessary imports (see [Listing 14-1](ch14.xhtml#ch014list1)).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Firefly 解释器由一组全局变量组成，包括显示屏、处理特定 Firefly 指令的几个函数以及执行程序字符串中一个个字符的主循环。该实现故意没有采用面向对象的方式，部分原因是为了可能减少开销并为
    micro:bit 上的 Firefly 代码保留空间，部分原因是为了作为一种变换节奏的方式而采用复古风格。因此，解释器从一系列声明和必要的导入开始（见[列表
    14-1](ch14.xhtml#ch014list1)）。
- en: '[PRE1]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 14-1: Firefly interpreter preamble*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 14-1：Firefly 解释器前言*'
- en: The global variable `PRG` holds the Firefly program to execute. The example
    program in [Listing 14-1](ch14.xhtml#ch014list1) plays a simple scale.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量`PRG`保存待执行的 Firefly 程序。[列表 14-1](ch14.xhtml#ch014list1)中的示例程序播放一个简单的音阶。
- en: Necessary Python imports come next. The first two functions are exclusive to
    MicroPython, which runs on the micro:bit; they handle the LED display and playing
    musical notes, respectively. The `time` and `random` modules are standard Python
    fare. We use `sleep` to implement the `P` instruction and `randint` for the `R`
    movement mode.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是必要的 Python 导入。前两个函数是专门为运行在 micro:bit 上的 MicroPython 定制的，分别处理 LED 显示屏和播放音符。`time`和`random`模块是标准的
    Python 模块。我们使用`sleep`来实现`P`指令，使用`randint`来实现`R`移动模式。
- en: The Firefly display, a 5×5 grid of single-digit values, is stored in a Python
    `bytearray`. There are two of them, `A` and `B`. The display currently shown is
    the array assigned to `D`, with `A` being the default. Likewise, the array currently
    drawn to by the moving firefly is in `C`, which is also `A` by default. `M` holds
    the current movement mode with `"M"`, which is the default value and means “move
    with no trail.”
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Firefly 显示屏是一个 5×5 的单数字值网格，存储在 Python 的`bytearray`中。共有两个显示屏，`A`和`B`。当前显示的是分配给`D`的数组，默认情况下是`A`。同样，当前由移动的萤火虫绘制的数组在`C`中，默认也是`A`。`M`保存当前的移动模式，默认值是`"M"`，表示“无尾迹移动”。
- en: The display is in `A` or `B` with `I` as the index or current position of the
    firefly. When needed, this index is converted into row and column. The default
    note duration is in `dur` and the default note octave is in `oc`. When the program
    starts, the actual micro:bit display is cleared (`display.clear()`).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 显示屏在`A`或`B`中，`I`表示火萤的索引或当前位置。当需要时，这个索引会转换成行和列。默认的音符时值保存在`dur`中，默认的音符八度保存在`oc`中。当程序开始时，实际的
    micro:bit 显示屏会被清空（`display.clear()`）。
- en: After the preamble in [Listing 14-1](ch14.xhtml#ch014list1) come seven function
    definitions. We’ll get to these in the following sections. The main loop comes
    last. Note that there is no `main` function, as the interpreter runs as a script.
    The main loop is in [Listing 14-2](ch14.xhtml#ch014list2).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 14-1](ch14.xhtml#ch014list1)的前言之后，紧接着是七个函数定义。我们将在接下来的章节中介绍这些函数。主循环在最后出现。请注意，这里没有`main`函数，因为解释器作为脚本运行。主循环位于[列表
    14-2](ch14.xhtml#ch014list2)中。
- en: '[PRE2]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 14-2: Firefly interpreter main loop*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 14-2：Firefly 解释器主循环*'
- en: The main loop runs as long as `R` is `True`. This means that a Firefly program
    will begin again after the last instruction. It also means that memory will not
    be erased. This is the only looping supported by Firefly. We’ll see how to use
    it in [Chapter 15](ch15.xhtml#ch15) when we implement a counter.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环在`R`为`True`时运行。这意味着在执行完最后一条指令后，Firefly 程序将重新开始。这也意味着内存不会被擦除。这是 Firefly 唯一支持的循环方式。当我们在[第
    15 章](ch15.xhtml#ch15)中实现计数器时，我们将看到如何使用它。
- en: The inner `for` loop is over the characters representing the Firefly program
    (`PRG`). Interpretation is a straightforward nested `if` statement. Certain instructions
    are handled directly in the `for` loop, like setting the movement mode to increment
    (`I`) or decrement (`D`). If the current character, `c`, is a digit (in `DIGITS`),
    the move mode is set to that digit value, `M=c`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 内部的`for`循环遍历表示 Firefly 程序（`PRG`）的字符。解释过程是一个直接的嵌套`if`语句。某些指令会直接在`for`循环中处理，比如将移动模式设置为递增（`I`）或递减（`D`）。如果当前字符`c`是数字（在`DIGITS`中），则将移动模式设置为该数字值，`M=c`。
- en: The only way to exit a Firefly program completely is to execute `H`, which sets
    `R` to `False` and then uses `break` to exit the inner `for` loop.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 完全退出萤火虫程序的唯一方法是执行 `H`，该指令将 `R` 设置为 `False`，然后使用 `break` 退出内层 `for` 循环。
- en: Movement instructions (`MOVES`), display instructions (`BUFS`), and playing
    a note (`F`) all call out to external functions to perform actions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 移动指令（`MOVES`）、显示指令（`BUFS`）和播放音符（`F`）都调用外部函数来执行动作。
- en: Notice the note duration (`J`) and note octave (`G`) instructions. They set
    the `dur` or `oc` global variables to `C[I]`. The index, `I`, represents the firefly’s
    current position in the range [0,24], and `C` is assigned the `bytearray` for
    the memory the firefly is currently drawing to, either `A` or `B`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意音符时长（`J`）和音符八度（`G`）指令。它们将全局变量 `dur` 或 `oc` 设置为 `C[I]`。索引 `I` 代表萤火虫当前在范围 [0,24]
    内的位置，`C` 被赋值为萤火虫当前绘制的内存的 `bytearray`，可以是 `A` 或 `B`。
- en: 'A call to `Update` happens after each instruction is executed to update the
    micro:bit display. This is what the `Update` function looks like:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每执行一条指令后，都会调用 `Update` 函数来更新 micro:bit 显示器。`Update` 函数的实现如下：
- en: '[PRE3]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A simple loop over the 25 elements of the `bytearray` assigned to global variable
    `D` determines the brightness of each of the LEDs in the 5×5 display. Note the
    conversion from a linear index (`i`) to display column (`i%5`) and row (`i//5`)
    for the currently active memory (`D`).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对全局变量 `D` 所分配的 `bytearray` 中 25 个元素的简单循环决定了 5×5 显示屏中每个 LED 的亮度。注意，从线性索引（`i`）到当前活动内存（`D`）的显示列（`i%5`）和行（`i//5`）的转换。
- en: The final set of instructions—the bottom of the main loop shown in [Listing
    14-2](ch14.xhtml#ch014list2)—resets the display at the end of the program and
    then executes again from the beginning. Note that the default firefly position
    of (2,2) is set, as is showing and drawing on the first memory, `A`. However,
    the memories themselves are *not* reset to 0.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一组指令——[清单 14-2](ch14.xhtml#ch014list2) 中显示的主循环底部——在程序结束时重置显示器，然后再次从头执行。请注意，默认的萤火虫位置为（2，2），并且显示并绘制在第一个内存
    `A` 上。然而，内存本身并未重置为 0。
- en: '***Movement***'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***移动***'
- en: Memory is not updated unless the firefly “moves.” What happens when the firefly
    moves is determined by the value of global variable `M`, which holds the current
    move mode. [Listing 14-3](ch14.xhtml#ch014list3) shows how movement is processed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 除非萤火虫“移动”，否则内存不会被更新。当萤火虫移动时，发生的事情由全局变量 `M` 的值决定，`M` 存储当前的移动模式。[清单 14-3](ch14.xhtml#ch014list3)
    显示了如何处理移动。
- en: '[PRE4]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 14-3: Firefly interpreter movement*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-3：萤火虫解释器的移动*'
- en: First, the current mode is applied to the *current* firefly position ➊. Incrementing
    the position wraps around after 9 while decrementing wraps the other way if below
    0\. If the mode is `R`, a random integer is assigned to the current memory location,
    `C[I]`. Lastly, if the mode is a digit, that value is used to update memory.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将当前模式应用于*当前*的萤火虫位置 ➊。位置递增后会在 9 后环绕，而递减则会在小于 0 时反向环绕。如果模式是 `R`，则一个随机整数会被分配到当前内存位置
    `C[I]`。最后，如果模式是数字，则该值用于更新内存。
- en: Next, the interpreter converts the linear index into memory, `I`, to a row (`i`)
    and column (`j`) format so that we can apply the actual movement command ➋. Integer
    division by 5 maps `I` to 0 through 4 to give us the row. The modulo, that is,
    what’s left over after integer division by 5, gives us the remainder representing
    the column.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，解释器将线性索引 `I` 转换为内存中的行（`i`）和列（`j`）格式，以便我们可以应用实际的移动指令 ➋。通过整数除法 5，将 `I` 映射到
    0 到 4，得到行位置。模运算，即整数除法后剩余的部分，给出代表列的余数。
- en: The current move is now applied ➌. Note that `Move` is called only if the instruction
    is a move instruction. The cardinal directions update the row and column position
    accordingly, wrapping around as needed so that moving east when in column 4 moves
    back around to column 0, and so on.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用当前的移动指令 ➌。请注意，只有在指令是移动指令时，才会调用 `Move`。主方向会相应更新行和列的位置，并在需要时进行环绕。例如，当处于第 4
    列时，向东移动会回绕到第 0 列，依此类推。
- en: There are two special move commands, `T` and `L`. The former acts like a tick
    of a clock. The firefly doesn’t actually move to a new position, hence `pass`,
    but the interpreter does update the current position. The latter instruction,
    `L`, is specifically for the micro:bit. It enters an infinite loop that sleeps
    for 1,000 seconds before waking up briefly, only to sleep again. As stated above,
    a Firefly program executes `H` to halt the program and the interpreter exits.
    On the micro:bit, when a program exits, the display is cleared. Calling `L` instead
    of `H` preserves the display.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个特殊的移动命令，`T`和`L`。前者类似于时钟的滴答。萤火虫实际上并不移动到新的位置，因此`pass`，但解释器会更新当前位置。后者指令`L`专门用于micro:bit。它进入一个无限循环，在休眠1,000秒后短暂唤醒，然后再次休眠。如上所述，Firefly程序执行`H`来停止程序，解释器退出。在micro:bit上，当程序退出时，显示被清除。调用`L`而不是`H`会保留显示。
- en: After the move command is executed, `i` and/or `j` have been updated. Before
    returning to the main loop, a new value for `I` is calculated by multiplying the
    row number (`i`) by 5, which is the number of elements per row, and adding the
    column number (`j`).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行移动命令后，`i`和/或`j`已经更新。在返回主循环之前，通过将行号(`i`)乘以每行的元素数5，并添加列号(`j`)，计算出`I`的新值。
- en: '***Display***'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***显示***'
- en: Four functions control the display, as shown in [Listing 14-4](ch14.xhtml#ch014list4).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 四个函数控制显示，如[列表14-4](ch14.xhtml#ch014list4)所示。
- en: '[PRE5]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 14-4: Firefly interpreter display*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14-4：Firefly解释器显示*'
- en: Three of the functions in [Listing 14-4](ch14.xhtml#ch014list4), `Clear`, `ClearA`,
    and `ClearB`, simply zero the display memory. The first function zeroes the current
    display, and the last two zero a given display, that is, `A` or `B`. Simply assigning
    a new `bytearray` to these global variables will not work because that would break
    the link with `A` and `B`, which are `bytearray` objects, while `C` and `D` act
    more like pointers that reference `A` or `B`. Recall that `C` references the memory
    the firefly is updating and `D` references the memory currently displayed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[清除](ch14.xhtml#ch014list4)列表14-4中的三个功能，`Clear`，`ClearA`和`ClearB`，简单地将显示内存清零。第一个功能将当前显示清零，而最后两个则将给定的显示清零，即`A`或`B`。简单地将新的`bytearray`分配给这些全局变量是行不通的，因为这会打破与`A`和`B`的链接，它们是`bytearray`对象，而`C`和`D`则更像是引用`A`或`B`的指针。请记住，`C`引用着萤火虫正在更新的内存，而`D`则引用当前显示的内存。'
- en: The `Display` function updates the displayed or drawn-to memory based on the
    argument, `c`. Specifying `"A"` as the argument makes `C` reference `*A*` . Likewise,
    passing `"B"` points `C` at `B`. Passing `"X"` changes the displayed memory to
    `A` and passing `"Y"` points the display to `B`. Note that the `global` statements
    used by these functions to update the global variables properly. Most Python programs
    use objects, so the `global` keyword is seldom used. We decided on a strictly
    imperative implementation of Firefly, thereby requiring `global` statements.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Display`函数根据参数`c`更新显示或绘制到内存。将参数设为`"A"`使`C`引用`*A*`。类似地，传递`"B"`将`C`指向`B`。传递`"X"`将显示内存更改为`A`，传递`"Y"`则将显示指向`B`。注意，这些函数使用`global`语句来正确更新全局变量。大多数Python程序使用对象，因此很少使用`global`关键字。我们决定严格实现Firefly的命令式实现，因此需要`global`语句。'
- en: '***Music***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***音乐***'
- en: We’ve surveyed the main interpreter loop, movement, and display. Now let’s finish
    Firefly by implementing the music instructions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经调查了主解释器循环、移动和显示。现在让我们通过实现音乐指令来完成Firefly。
- en: The `J` and `G` instructions, which set the note duration and octave, respectively,
    are in the main loop (see [Listing 14-1](ch14.xhtml#ch014list1)). The play instruction,
    `F`, calls `*Play*` .
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`J`和`G`指令分别设置音符持续时间和八度，位于主循环中（见[列表14-1](ch14.xhtml#ch014list1)）。播放指令`F`调用`*Play*`。'
- en: '[PRE6]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`Play` translates the current firefly position into a note string and then
    plays the note using the current octave and duration via the MicroPython `music`
    function, `play`. There are 10 possible values for a memory location, so the note
    is modulo 8 to handle cases where the memory value is 8 or 9 by wrapping around
    to 0 and 1 instead.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Play`将当前萤火虫位置转换为音符字符串，然后通过MicroPython的`music`函数`play`以当前八度和持续时间播放音符。内存位置有10个可能的值，因此音符对8取模，以处理内存值为8或9的情况，将其循环至0和1。'
- en: With `Play`, our micro:bit implementation of Firefly is complete. As mentioned
    earlier, the console version has extra code to handle console cursor positioning,
    execution tracing, and to capture SIGINT via CTRL-C; please do take a look at
    how those features are implemented by reading through *firefly.py*, which is the
    name of the console version of the interpreter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Play`，我们的 micro:bit 实现的 Firefly 编程已经完成。如前所述，控制台版本包含额外的代码来处理控制台光标位置、执行追踪，并通过
    CTRL-C 捕获 SIGINT；请务必查看这些功能是如何实现的，阅读 *firefly.py* 文件，这是控制台版本解释器的名称。
- en: We’re almost ready for some Firefly programming. However, if we’re using an
    actual micro:bit, we should become at least familiar enough with it to configure
    a speaker and power it up. We’ll save programming the micro:bit for [Chapter 15](ch15.xhtml#ch15).
    For now, let’s take a crash course in micro:bit hardware.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们差不多可以开始 Firefly 编程了。然而，如果我们使用的是实际的 micro:bit，至少应该熟悉如何配置扬声器并给它供电。我们将把编程 micro:bit
    的内容留到[第 15 章](ch15.xhtml#ch15)。现在，让我们快速了解一下 micro:bit 硬件。
- en: '**Configuring the Micro:bit**'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**配置 Micro:bit**'
- en: 'The BBC micro:bit (*[https://microbit.org/](https://microbit.org/)*) is a small,
    single-board computer. Out of the box, it runs MicroPython (see the documentation
    at *[https://microbit-micropython.readthedocs.io/en/v2-docs/](https://microbit-micropython.readthedocs.io/en/v2-docs/)*).
    The micro:bit is intended to introduce as many people as possible to programming
    via an inexpensive computer system. There are two versions available: the older
    v1 which has 16KB of RAM, and the newer v2 with 128KB of RAM. Both versions are
    geared toward hardware projects, and a plethora of accessories exist (*[https://microbit.org/buy/accessories/](https://microbit.org/buy/accessories/)*).
    To learn more about the impressive amount of hardware supported by the micro:bit
    itself, see [https://tech.microbit.org/hardware/](https://tech.microbit.org/hardware/).
    Lastly, to learn more about implementing hardware projects with the micro:bit,
    see Simon Monk’s excellent book *Micro:bit for Mad Scientists* (No Starch Press,
    2019).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: BBC micro:bit (*[https://microbit.org/](https://microbit.org/)*) 是一款小型单板计算机。开箱即用，它运行
    MicroPython（详细文档见 *[https://microbit-micropython.readthedocs.io/en/v2-docs/](https://microbit-micropython.readthedocs.io/en/v2-docs/)*）。micro:bit
    旨在通过一款廉价的计算机系统让尽可能多的人接触编程。它有两个版本：旧版 v1，配备 16KB 内存；新版 v2 配备 128KB 内存。两个版本都适合硬件项目，并且有大量配件可供选择
    (*[https://microbit.org/buy/accessories/](https://microbit.org/buy/accessories/)*)。想了解更多有关
    micro:bit 本身支持的丰富硬件，请访问 [https://tech.microbit.org/hardware/](https://tech.microbit.org/hardware/)。最后，想要了解如何使用
    micro:bit 实现硬件项目，可以参考 Simon Monk 的优秀著作 *Micro:bit for Mad Scientists*（No Starch
    Press, 2019）。
- en: '***Micro:bit Hardware Overview***'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***micro:bit 硬件概述***'
- en: '[Figure 14-3](ch14.xhtml#ch014fig3) details the micro:bit and its features.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-3](ch14.xhtml#ch014fig3) 详细介绍了 micro:bit 及其功能。'
- en: '![Image](Images/14fig03.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/14fig03.jpg)'
- en: '*Figure 14-3: A hardware overview of the micro:bit (version 2)*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-3：micro:bit（版本 2）的硬件概述*'
- en: Of primary interest to us is the 5×5 LED display, the speaker, and the Micro-USB
    connector to program the device. If you have the older version 1 device, there
    is no built-in speaker. In that case, you’ll need to attach an external speaker;
    see the following section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要关注的是 5×5 LED 显示屏、扬声器和用于编程设备的 Micro-USB 连接器。如果你使用的是旧版 1 设备，那么没有内置扬声器。在这种情况下，你需要连接一个外部扬声器；请参阅下一个章节。
- en: The micro:bit comes with a small battery pack for two AAA batteries. However,
    it runs just fine from the Micro-USB connector when attached to a computer or
    a 5V power supply. However, early versions of the micro:bit, those before version
    1.3B, should not be run from an external 5V supply. If your micro:bit has a speaker,
    it’s good to go. If it doesn’t, check the version, which is visible on the back
    in small print near the right side of the edge connector, to make sure it is at
    least version 1.3B or 1.5.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: micro:bit 配备了一个小型电池包，支持两颗 AAA 电池。然而，当连接到计算机或 5V 电源时，它也能正常工作。早期版本的 micro:bit，特别是
    1.3B 之前的版本，不应通过外部 5V 电源供电。如果你的 micro:bit 配有扬声器，那么就可以正常使用。如果没有扬声器，请检查版本号，版本号通常可以在连接器右侧附近的背面小字中找到，确保其至少为
    1.3B 或 1.5。
- en: '***Using an External Speaker***'
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用外部扬声器***'
- en: 'Skip this section if your micro:bit is version 2 with a built-in speaker. For
    version 1 devices, we’ll need to add an external speaker, but have no fear: doing
    so is painless. Let’s walk through the process.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 micro:bit 是带内置扬声器的版本 2，可以跳过此部分。对于版本 1 设备，我们需要添加外部扬声器，但不用担心：这个过程很简单。让我们一起看看如何操作。
- en: First, you need a speaker of some sort. If you have an old speaker from a defunct
    electronics device, like an old radio, you can use it. In years past, most tinkerers
    had many such speakers pulled from dead transistor radios. However, in this day
    and age, it’s more likely you don’t have a bare speaker lying around. But not
    all is lost! It turns out that a pair of headphones will work just fine.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要某种扬声器。如果你有一只来自废弃电子设备的旧扬声器，比如旧收音机，可以使用它。过去，许多动手爱好者会从报废的晶体管收音机中取出很多这种扬声器。然而，在如今的时代，你可能没有一只裸露的扬声器。可是，并非一切都失去了！原来，一副耳机也可以完全适用。
- en: The micro:bit edge connector is the interface between the micro:bit and external
    hardware devices. To connect a speaker, attach one wire to connector 0 (the one
    with the “0” on it), and the other wire to the connector marked “GND.” If using
    headphones, connect the headphone plug’s tip to connector 0 and the part of the
    plug farthest from the tip to the GND connector. The connections are easiest to
    make with alligator clips, but if you don’t have those handy, bare wires twisted
    together and wrapped around the connectors going through the holes on the micro:bit
    will do the trick. [Figure 14-4](ch14.xhtml#ch014fig4) shows how to connect a
    generic speaker using alligator clips. The inset shows how to connect headphones.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: micro:bit边缘连接器是micro:bit与外部硬件设备之间的接口。要连接扬声器，将一根线连接到标有“0”的连接器，另一根线连接到标有“GND”的连接器。如果使用耳机，将耳机插头的尖端连接到连接器0，插头最远端连接到GND连接器。使用鳄鱼夹连接最为简单，但如果你没有这些工具，扭在一起并绕过micro:bit插孔的裸线也能完成连接。[图14-4](ch14.xhtml#ch014fig4)展示了如何使用鳄鱼夹连接普通扬声器。插图显示了如何连接耳机。
- en: '![Image](Images/14fig04.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/14fig04.jpg)'
- en: '*Figure 14-4: Connecting an external speaker or headphones*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-4：连接外部扬声器或耳机*'
- en: Some speakers are marked with plus (+) and minus (–) connections. If so, connect
    the white wire in [Figure 14-4](ch14.xhtml#ch014fig4) to the + connection and
    the red to the – connection. Don’t worry if the speaker isn’t marked for polarity;
    it will still work whichever way you connect the wires. For the headphones, the
    part of the plug farthest from the tip is usually ground, so connect the red wire
    to it and the white to the tip.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有些扬声器上标有正极（+）和负极（–）连接。如果是这样，将[图14-4](ch14.xhtml#ch014fig4)中的白色线连接到+端子，红色线连接到–端子。如果扬声器没有极性标记，也不用担心；无论如何连接线，它都会正常工作。对于耳机，插头最远端通常是接地端，因此将红色线连接到它，白色线连接到插头尖端。
- en: '**Summary**'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter introduced us to Firefly, its design, and the rationale behind
    it. We then walked through the implementation as we’ll soon run it on the micro:bit
    and concluded by configuring the micro:bit for our Firefly experiments. Firefly
    is about as simple as a programming language gets. Now, let’s watch some fireflies
    and see what they can do.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们介绍了Firefly，它的设计以及背后的理念。然后我们讲解了实现过程，因为我们很快就要在micro:bit上运行它，并且最后配置了micro:bit以便进行Firefly实验。Firefly是目前最简单的编程语言之一。现在，让我们观察一些萤火虫，看看它们能做些什么。
