- en: '14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FIREFLY
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Firefly is a minimalist programming language for animation and sound. Firefly
    targets the BBC micro:bit, but you don’t need one to have fun with the language—the
    console version will work just fine. The inspiration for the language comes from
    the 5×5 grid of LEDs that form the display of the micro:bit. The language manipulates
    a “firefly” that lives on the grid. As it flies, it leaves a luminous trail of
    light behind it. Oh, the firefly also sings, because why not?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces the philosophy and design of the language, followed
    by its implementation. The chapter ends with a section on configuring a micro:bit,
    should you wish to use one for the experiments of [Chapter 15](ch15.xhtml#ch15).
    Again, you don’t need a micro:bit; you can run everything just fine at the command
    line using the console version of the interpreter. However, the micro:bit isn’t
    too expensive, and it’s a fun little device that itself runs Python. Also, console
    fireflies don’t know how to sing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '**Philosophy and Design**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our environment is this: a small firefly is flying around a tiny 5×5 grid.
    As it flies, it leaves behind a luminous trail and sometimes sings.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: To be more specific, a Firefly program manipulates a 5×5 grid of single digits.
    On the micro:bit, these become intensities of the 5×5 grid of LEDs. The firefly
    can sing by making the micro:bit sound a note of a particular pitch and duration.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: A Firefly program is a series of single-character instructions that either move
    the firefly around the grid, set the way its luminous trail acts, or make the
    firefly sing a note. The Firefly language also supports what is known as *double
    buffering*, meaning instead of one 5×5 grid of digits, there are two 5×5 grids.
    The program controls which grid is shown to the user and which grid the firefly
    is making a trail on (drawing to). Double buffering is a common computer animation
    technique in which the user sees one display while the program is updating the
    other and then the view switches. Doing this prevents the user from watching the
    display draw and makes for smooth animation. Don’t worry if double buffering is
    a new concept; we’ll detail it in [Chapter 15](ch15.xhtml#ch15) when we use it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: A Firefly program instructs the firefly by directing its movements and when
    and how it should sing. If you’ve never heard a singing firefly, you’re in good
    company because I haven’t either. Still, it’s fun to pretend.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The firefly is constrained to move on a 5×5 grid. The upper-left corner of the
    grid is position (0,0), and the lower-right corner is position (4,4). Positions
    are given as the row number before the column number. The firefly moves one position
    at a time, either north (`N`), south (`S`), east (`E`), or west (`W`). When it
    moves off one edge of the grid, it wraps around to the other side. For instance,
    moving east from position (1,4) puts the firefly at position (1,0). Likewise,
    a firefly moving south from (4,2) arrives at position (0,2).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 萤火虫被限制在一个5×5的网格上移动。网格的左上角是位置 (0,0)，右下角是位置 (4,4)。位置的表示方式是先给出行号，再给出列号。萤火虫一次只能移动一个位置，可以向北（`N`）、向南（`S`）、向东（`E`）或向西（`W`）移动。当它越过网格的一边时，会绕回到另一边。例如，从位置
    (1,4) 向东移动，萤火虫将到达位置 (1,0)。同样，从位置 (4,2) 向南移动，萤火虫将到达位置 (0,2)。
- en: When the firefly moves, it leaves behind a trail, meaning it sets the position
    it *just left* to some value. On the micro:bit, the value is the LED’s intensity
    at that position where 0 is off and 9 is maximum brightness. The console interpreter
    shows 0 as space and anything else as the numeric value of the position, but if
    desired, the console will show 0 as `0`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当萤火虫移动时，它会留下一个轨迹，意味着它会将它*刚刚离开的*位置设置为某个值。在 micro:bit 上，值是该位置的LED强度，0表示关闭，9表示最大亮度。控制台解释器显示0为空格，其他值显示为位置的数字值，但如果需要，控制台将显示0为
    `0`。
- en: Therefore, if the firefly is currently at position (2,2) and the intensity is
    set to 3, an instruction telling the firefly to move one position to the west,
    that is, to (2,1), will set position (2,2) to intensity 3\. There is also an instruction
    telling the firefly to stay put, so it is possible to update a position value
    in place.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果萤火虫当前位于位置 (2,2)，且强度设置为3，则一条指令让萤火虫向西移动一个位置，也就是移动到 (2,1)，将会把位置 (2,2) 的强度设置为3。同时，也有指令让萤火虫保持原地不动，因此可以在当前位置更新位置值。
- en: 'The 5×5 grid is all the memory we have. It’s also the display: we see the value
    of each grid cell as a number (console) or brightness of the LED (micro:bit).
    Therefore, a Firefly program has no variables.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 5×5的网格就是我们所拥有的所有内存。它也是显示器：我们可以看到每个网格单元的值，可以是数字（控制台）或LED的亮度（micro:bit）。因此，萤火虫程序没有变量。
- en: Using memory as the display isn’t novel, but it puts us in good company. The
    Manchester Baby, the world’s first stored-program computer with random access
    memory, circa 1948, also used memory as its display (see [Figure 14-1](ch14.xhtml#ch014fig1)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内存作为显示并不新颖，但这让我们与优秀的前辈为伍。曼彻斯特婴儿，世界上第一台具有随机存取内存的存储程序计算机，诞生于1948年，它也使用内存作为显示（见[图
    14-1](ch14.xhtml#ch014fig1)）。
- en: '![Image](Images/14fig01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/14fig01.jpg)'
- en: '*Figure 14-1: The memory/display of the Manchester Baby*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-1：曼彻斯特婴儿的内存/显示*'
- en: The Baby’s memory is literally the cathode-ray tube shown in the photograph.
    If a bit was on, one pattern was displayed, and if the bit was off, a slightly
    different pattern was shown. [Figure 14-1](ch14.xhtml#ch014fig1) shows a working
    replica of the original Baby built at the University of Manchester in 1998 in
    celebration of the original Baby’s 50th anniversary.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 婴儿的内存实际上就是照片中显示的阴极射线管。如果某个位打开，就显示一种模式；如果该位关闭，则显示另一种稍微不同的模式。[图 14-1](ch14.xhtml#ch014fig1)
    展示了1998年曼彻斯特大学为庆祝原始婴儿50周年而制作的工作原型。
- en: The Baby had memory for 32 instructions of 32 bits each. It was a von Neumann
    machine, meaning program memory and data storage were mixed as they are in a modern
    desktop computer. Firefly is more like a Harvard architecture machine, as memory
    for data and program instructions is separate. Many microcontrollers use a Harvard
    architecture. In our case, the display is the data memory and a Python string
    represents program memory.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 婴儿拥有32条32位指令的内存。它是一台冯·诺依曼机器，这意味着程序内存和数据存储是混合的，就像现代桌面计算机一样。而萤火虫更像是一台哈佛架构的计算机，因为数据内存和程序指令的内存是分开的。许多微控制器使用哈佛架构。在我们的例子中，显示是数据内存，而Python字符串表示程序内存。
- en: We have two versions of the Firefly interpreter to work with. The console version
    is intended for program creation. It knows how to parse input text to remove whitespace
    and comments. It also supports program tracing. When the program is working as
    it should, a utility converts the source code to a form we can load onto the micro:bit.
    The micro:bit runs a single Python program. For Firefly, the program is the interpreter
    with the source code we want to execute embedded in it as a string constant.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个版本的萤火虫解释器可供使用。控制台版本用于程序创建。它知道如何解析输入文本以去除空格和注释。它还支持程序跟踪。当程序正常工作时，一个实用程序将源代码转换为可加载到微控制器的形式。微控制器运行一个单独的Python程序。对于萤火虫，程序是解释器，其中包含我们想要执行的源代码作为字符串常量。
- en: 'Perhaps the simplest way to understand Firefly is to detail its instructions.
    Knowing what the instructions do tells us how to use them. Firefly instructions
    are single characters and case insensitive. The instructions fall into distinct
    groups: movement, display, music, and whatever’s left. Most instructions relate
    to movement, so we’ll begin with those.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 或许理解萤火虫最简单的方法是详细说明其指令。了解指令的作用告诉我们如何使用它们。萤火虫的指令是单个字符且不区分大小写。这些指令可以分为不同的组别：移动、显示、音乐以及其他。大多数指令与移动有关，因此我们从这些指令开始讨论。
- en: '***Movement***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***移动***'
- en: 'Firefly move instructions fall into two groups: those that move the firefly
    and those that define what happens to the position the firefly leaves when it
    moves. We’ll refer to these latter instructions as setting the *mode*. Movement
    is north, south, east, or west, with the option to stay put (see [Table 14-1](ch14.xhtml#ch014tab1)).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 萤火虫的移动指令分为两组：移动萤火虫的指令以及定义萤火虫移动后位置变化的指令。我们将后者称为设置*模式*。移动可以是北、南、东或西，并可以选择留在原地（见[表
    14-1](ch14.xhtml#ch014tab1)）。
- en: '**Table 14-1:** Firefly Movement Commands'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 14-1：萤火虫移动命令**'
- en: '| **Instruction** | **Effect** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **效果** |'
- en: '| --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| N | Move north |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| N | 向北移动 |'
- en: '| S | Move south |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| S | 向南移动 |'
- en: '| E | Move east |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| E | 向东移动 |'
- en: '| W | Move west |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| W | 向西移动 |'
- en: '| T | Stay put (“tick” of the clock) |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| T | 留在原地（时钟的“滴答”声） |'
- en: What happens to the position after the firefly moves is the mode given in [Table
    14-2](ch14.xhtml#ch014tab2). Note that when the program begins, the firefly is
    in move-only mode at position (2,2).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 萤火虫移动后位置的模式见[表 14-2](ch14.xhtml#ch014tab2)。注意，当程序开始时，萤火虫处于仅移动模式，位于位置（2,2）。
- en: '**Table 14-2:** Firefly Intensity (Mode) Commands'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 14-2：萤火虫强度（模式）命令**'
- en: '| **Instruction** | **Effect** |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **效果** |'
- en: '| --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0–9 | Constant intensity value |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 0–9 | 恒定的强度值 |'
- en: '| I | Increment the current value |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| I | 增加当前值 |'
- en: '| D | Decrement the current value |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| D | 减少当前值 |'
- en: '| M | Move only; no change in value |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| M | 仅移动；值不变 |'
- en: '| R | Random value 1 through 9 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| R | 随机值 1 到 9 |'
- en: 'Let’s consider a program that begins with the following instructions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个以以下指令开始的程序：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, the firefly will move south twice to be at position (4,2), set the intensity
    to 5, and then move north five times to arrive back at position (4,2) with a vertical
    trail of five 5s behind it so that the display looks like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，萤火虫将向南移动两次到达（4,2），设置强度为5，然后向北移动五次返回到位置（4,2），在其后留下垂直轨迹，看起来像这样：
- en: '| 0 | 0 | 5 | 0 | 0 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 5 | 0 | 0 |'
- en: '| 0 | 0 | 5 | 0 | 0 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 5 | 0 | 0 |'
- en: '| 0 | 0 | 5 | 0 | 0 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 5 | 0 | 0 |'
- en: '| 0 | 0 | 5 | 0 | 0 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 5 | 0 | 0 |'
- en: '| 0 | 0 | 5 | 0 | 0 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 5 | 0 | 0 |'
- en: '[Figure 14-2](ch14.xhtml#ch014fig2) illustrates the process.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14-2](ch14.xhtml#ch014fig2)说明了这个过程。'
- en: '![Image](Images/14fig02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/14fig02.jpg)'
- en: '*Figure 14-2: How the firefly moves*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 14-2：萤火虫的移动方式*'
- en: The first command, `S`, moves the firefly south from (2,2) to (3,2), as shown
    with the arrow. The next `S` moves the firefly to (4,2). The `5` sets the trail
    to intensity 5\. Lastly, the five `N` commands move the firefly as shown, leaving
    a trail behind it and finishing at position (4,2).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个指令 `S` 将萤火虫从（2,2）向南移动到（3,2），如箭头所示。接下来的 `S` 将萤火虫移动到（4,2）。数字 `5` 设置轨迹强度为5。最后的五个
    `N` 指令按照示例移动萤火虫，留下轨迹，并最终停留在位置（4,2）。
- en: Note that there is no way to ask what the current value of a position is. When
    the program starts, all positions are 0\. If the move mode is increment, adding
    1 to the current position’s value wraps around, so 9 becomes 0\. Similarly, if
    the mode is decrement, 0 wraps around to become 9\. Use mode `R` to set the value
    to a random integer between 1 and 9.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '***Display***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Double buffering maintains two 5×5 memory grids. Only one grid is shown at a
    time, and it’s possible to create any combination of the grid shown and the grid
    the firefly is making a trail on. We’ll call our two grids A and B. When the program
    starts, grid A is shown and the firefly draws on grid A. The display instructions
    are in [Table 14-3](ch14.xhtml#ch014tab3).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 14-3:** Firefly Display Commands'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Effect** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| X | Show grid A |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| Y | Show grid B |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| A | Draw on grid A |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| B | Draw on grid B |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| C | Clear active grid |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| V | Clear grid A |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| Z | Clear grid B |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: The instruction `C` clears the grid currently being displayed, but `V` and `Z`
    clear their respective grids regardless of which one is currently displayed. Therefore,
    to show grid A but make the firefly draw on grid B, execute `XB`, and then, when
    the firefly is done drawing, show grid B with `Y`. We’ll explore animation more
    in [Chapter 15](ch15.xhtml#ch15).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '***Music***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To make the firefly sing, we need the three instructions in [Table 14-4](ch14.xhtml#ch014tab4).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 14-4:** Firefly Music Commands'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Effect** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| J | Set note duration |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| G | Set octave |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| F | Play a note |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: Each instruction uses the value of the firefly’s current position for the duration,
    octave, or note.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the hood, these instructions use the `play` function in the MicroPython
    `music` module. The easiest instructions to understand are duration and octave.
    The micro:bit range is such that octave 4 includes middle C, which is the default
    value. So, to set the octave to 4, we first need to set the firefly’s current
    position and then the octave: `4TG`. The `4` sets the mode to 4, meaning the firefly’s
    trail uses intensity 4\. Next, we keep the firefly in place with `T`. Lastly,
    we set the octave with `G`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Note that durations are relative, with a duration of 4 being a reasonable value
    for a quarter note. Therefore, a duration of 2 implies an eighth note and 8 a
    half note. Durations, and octaves, are persistent, meaning that once set, their
    value will stay until changed. To set the duration to quarter notes, use something
    like `4TJ`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: To play a note, we need `F`. The firefly’s current position indicates the actual
    note according to [Table 14-5](ch14.xhtml#ch014tab5).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 14-5:** Firefly Note Commands'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '| **Value** | **Note** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| 0 | Rest |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| 1 | C |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| 2 | D |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| 3 | E |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| 4 | F |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| 5 | G |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| 6 | A |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| 7 | B |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| 8 | Rest (same as 0) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| 9 | C (same as 1) |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: As an example, to play middle C as a quarter note, we would need something like
    `1TF` to set the move mode, or intensity, to 1 (“move” by staying in place); this
    sets the current position to 1, and `F` to play the note. This assumes that the
    octave and duration are both their default values of 4\. As Firefly memory holds
    only a single digit at a time, we are limited to the C major scale with no sharps
    or flats.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Our singing firefly will have several opportunities to serenade us in [Chapter
    15](ch15.xhtml#ch15).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '***What’s Left***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Only three instructions remain. The first is `H`, which stops the program. Similar
    to `H` is `L`, which enters an eternal loop (that is, sleeps the program). The
    difference between the two is most noticeable with the micro:bit. If `H` is executed,
    the program stops and Python clears the display. If we execute `L` instead, the
    program sleeps “forever” and the display remains active.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The final instruction is `P`, which pauses for 0.1 seconds before continuing.
    Use `P` to add timing effects. We’ll see `P` in [Chapter 15](ch15.xhtml#ch15)
    when we implement a tea timer and a counter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 14-6](ch14.xhtml#ch014tab6) serves as a reference for all Firefly instructions.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 14-6:** The Firefly Instruction Set'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Effect** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| N | Move north |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| S | Move south |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| E | Move east |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| W | Move west |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| T | Stay put (“tick” of the clock) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| 0–9 | Constant intensity value |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| I | Increment the current value |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| D | Decrement the current value |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| M | Move only, no change in value |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| R | Random value 1 through 9 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| X | Show grid A |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| Y | Show grid B |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| A | Draw on grid A |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| B | Draw on grid B |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| C | Clear active grid |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| V | Clear grid A |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| Z | Clear grid B |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| J | Set note duration |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| G | Set octave |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '| F | Play a note |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| P | Pause for 0.1 seconds |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '| L | Loop forever |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| H | Halt |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: Now, let’s get down to business and actually implement the language.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation**'
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Firefly is written in Python, both for simplicity and because the micro:bit
    runs only a single Python program. We’ll list Python code for the micro:bit version
    here, but show example Firefly code for the console version in [Chapter 15](ch15.xhtml#ch15).
    Doing this lets us use whitespace and comments. In [Chapter 15](ch15.xhtml#ch15),
    we’ll walk through the development process, which typically involves both the
    console and micro:bit interpreters.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Firefly programs are ultimately a string of uppercase letters and digits. For
    the micro:bit, the string is literally embedded within the Python code for the
    interpreter after all whitespace has been removed. The micro:bit does have a flat
    file system, but it’s simpler to embed the Firefly code at the top of the interpreter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The console interpreter allows whitespace and comments beginning with an exclamation
    point (`!`) and running to the end of the current line. The console interpreter
    also supports execution tracing, which we’ll see in [Chapter 15](ch15.xhtml#ch15).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '***Interpreter Structure and Main Loop***'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***解释器结构与主循环***'
- en: The Firefly interpreter consists of a set of global variables, including the
    displays, a few functions to handle specific Firefly instructions, and the main
    loop that executes character after character of the program string. The implementation
    is deliberately not object oriented, in part to possibly reduce overhead and preserve
    room on the micro:bit for Firefly code, and in part to be old-school about things
    as a change of pace. Therefore, the interpreter begins with a series of declarations
    and necessary imports (see [Listing 14-1](ch14.xhtml#ch014list1)).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Firefly 解释器由一组全局变量组成，包括显示屏、处理特定 Firefly 指令的几个函数以及执行程序字符串中一个个字符的主循环。该实现故意没有采用面向对象的方式，部分原因是为了可能减少开销并为
    micro:bit 上的 Firefly 代码保留空间，部分原因是为了作为一种变换节奏的方式而采用复古风格。因此，解释器从一系列声明和必要的导入开始（见[列表
    14-1](ch14.xhtml#ch014list1)）。
- en: '[PRE1]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 14-1: Firefly interpreter preamble*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 14-1：Firefly 解释器前言*'
- en: The global variable `PRG` holds the Firefly program to execute. The example
    program in [Listing 14-1](ch14.xhtml#ch014list1) plays a simple scale.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量`PRG`保存待执行的 Firefly 程序。[列表 14-1](ch14.xhtml#ch014list1)中的示例程序播放一个简单的音阶。
- en: Necessary Python imports come next. The first two functions are exclusive to
    MicroPython, which runs on the micro:bit; they handle the LED display and playing
    musical notes, respectively. The `time` and `random` modules are standard Python
    fare. We use `sleep` to implement the `P` instruction and `randint` for the `R`
    movement mode.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是必要的 Python 导入。前两个函数是专门为运行在 micro:bit 上的 MicroPython 定制的，分别处理 LED 显示屏和播放音符。`time`和`random`模块是标准的
    Python 模块。我们使用`sleep`来实现`P`指令，使用`randint`来实现`R`移动模式。
- en: The Firefly display, a 5×5 grid of single-digit values, is stored in a Python
    `bytearray`. There are two of them, `A` and `B`. The display currently shown is
    the array assigned to `D`, with `A` being the default. Likewise, the array currently
    drawn to by the moving firefly is in `C`, which is also `A` by default. `M` holds
    the current movement mode with `"M"`, which is the default value and means “move
    with no trail.”
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Firefly 显示屏是一个 5×5 的单数字值网格，存储在 Python 的`bytearray`中。共有两个显示屏，`A`和`B`。当前显示的是分配给`D`的数组，默认情况下是`A`。同样，当前由移动的萤火虫绘制的数组在`C`中，默认也是`A`。`M`保存当前的移动模式，默认值是`"M"`，表示“无尾迹移动”。
- en: The display is in `A` or `B` with `I` as the index or current position of the
    firefly. When needed, this index is converted into row and column. The default
    note duration is in `dur` and the default note octave is in `oc`. When the program
    starts, the actual micro:bit display is cleared (`display.clear()`).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 显示屏在`A`或`B`中，`I`表示火萤的索引或当前位置。当需要时，这个索引会转换成行和列。默认的音符时值保存在`dur`中，默认的音符八度保存在`oc`中。当程序开始时，实际的
    micro:bit 显示屏会被清空（`display.clear()`）。
- en: After the preamble in [Listing 14-1](ch14.xhtml#ch014list1) come seven function
    definitions. We’ll get to these in the following sections. The main loop comes
    last. Note that there is no `main` function, as the interpreter runs as a script.
    The main loop is in [Listing 14-2](ch14.xhtml#ch014list2).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 14-1](ch14.xhtml#ch014list1)的前言之后，紧接着是七个函数定义。我们将在接下来的章节中介绍这些函数。主循环在最后出现。请注意，这里没有`main`函数，因为解释器作为脚本运行。主循环位于[列表
    14-2](ch14.xhtml#ch014list2)中。
- en: '[PRE2]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 14-2: Firefly interpreter main loop*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 14-2：Firefly 解释器主循环*'
- en: The main loop runs as long as `R` is `True`. This means that a Firefly program
    will begin again after the last instruction. It also means that memory will not
    be erased. This is the only looping supported by Firefly. We’ll see how to use
    it in [Chapter 15](ch15.xhtml#ch15) when we implement a counter.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环在`R`为`True`时运行。这意味着在执行完最后一条指令后，Firefly 程序将重新开始。这也意味着内存不会被擦除。这是 Firefly 唯一支持的循环方式。当我们在[第
    15 章](ch15.xhtml#ch15)中实现计数器时，我们将看到如何使用它。
- en: The inner `for` loop is over the characters representing the Firefly program
    (`PRG`). Interpretation is a straightforward nested `if` statement. Certain instructions
    are handled directly in the `for` loop, like setting the movement mode to increment
    (`I`) or decrement (`D`). If the current character, `c`, is a digit (in `DIGITS`),
    the move mode is set to that digit value, `M=c`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 内部的`for`循环遍历表示 Firefly 程序（`PRG`）的字符。解释过程是一个直接的嵌套`if`语句。某些指令会直接在`for`循环中处理，比如将移动模式设置为递增（`I`）或递减（`D`）。如果当前字符`c`是数字（在`DIGITS`中），则将移动模式设置为该数字值，`M=c`。
- en: The only way to exit a Firefly program completely is to execute `H`, which sets
    `R` to `False` and then uses `break` to exit the inner `for` loop.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 完全退出萤火虫程序的唯一方法是执行 `H`，该指令将 `R` 设置为 `False`，然后使用 `break` 退出内层 `for` 循环。
- en: Movement instructions (`MOVES`), display instructions (`BUFS`), and playing
    a note (`F`) all call out to external functions to perform actions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 移动指令（`MOVES`）、显示指令（`BUFS`）和播放音符（`F`）都调用外部函数来执行动作。
- en: Notice the note duration (`J`) and note octave (`G`) instructions. They set
    the `dur` or `oc` global variables to `C[I]`. The index, `I`, represents the firefly’s
    current position in the range [0,24], and `C` is assigned the `bytearray` for
    the memory the firefly is currently drawing to, either `A` or `B`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意音符时长（`J`）和音符八度（`G`）指令。它们将全局变量 `dur` 或 `oc` 设置为 `C[I]`。索引 `I` 代表萤火虫当前在范围 [0,24]
    内的位置，`C` 被赋值为萤火虫当前绘制的内存的 `bytearray`，可以是 `A` 或 `B`。
- en: 'A call to `Update` happens after each instruction is executed to update the
    micro:bit display. This is what the `Update` function looks like:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每执行一条指令后，都会调用 `Update` 函数来更新 micro:bit 显示器。`Update` 函数的实现如下：
- en: '[PRE3]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A simple loop over the 25 elements of the `bytearray` assigned to global variable
    `D` determines the brightness of each of the LEDs in the 5×5 display. Note the
    conversion from a linear index (`i`) to display column (`i%5`) and row (`i//5`)
    for the currently active memory (`D`).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对全局变量 `D` 所分配的 `bytearray` 中 25 个元素的简单循环决定了 5×5 显示屏中每个 LED 的亮度。注意，从线性索引（`i`）到当前活动内存（`D`）的显示列（`i%5`）和行（`i//5`）的转换。
- en: The final set of instructions—the bottom of the main loop shown in [Listing
    14-2](ch14.xhtml#ch014list2)—resets the display at the end of the program and
    then executes again from the beginning. Note that the default firefly position
    of (2,2) is set, as is showing and drawing on the first memory, `A`. However,
    the memories themselves are *not* reset to 0.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一组指令——[清单 14-2](ch14.xhtml#ch014list2) 中显示的主循环底部——在程序结束时重置显示器，然后再次从头执行。请注意，默认的萤火虫位置为（2，2），并且显示并绘制在第一个内存
    `A` 上。然而，内存本身并未重置为 0。
- en: '***Movement***'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***移动***'
- en: Memory is not updated unless the firefly “moves.” What happens when the firefly
    moves is determined by the value of global variable `M`, which holds the current
    move mode. [Listing 14-3](ch14.xhtml#ch014list3) shows how movement is processed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 除非萤火虫“移动”，否则内存不会被更新。当萤火虫移动时，发生的事情由全局变量 `M` 的值决定，`M` 存储当前的移动模式。[清单 14-3](ch14.xhtml#ch014list3)
    显示了如何处理移动。
- en: '[PRE4]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 14-3: Firefly interpreter movement*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-3：萤火虫解释器的移动*'
- en: First, the current mode is applied to the *current* firefly position ➊. Incrementing
    the position wraps around after 9 while decrementing wraps the other way if below
    0\. If the mode is `R`, a random integer is assigned to the current memory location,
    `C[I]`. Lastly, if the mode is a digit, that value is used to update memory.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将当前模式应用于*当前*的萤火虫位置 ➊。位置递增后会在 9 后环绕，而递减则会在小于 0 时反向环绕。如果模式是 `R`，则一个随机整数会被分配到当前内存位置
    `C[I]`。最后，如果模式是数字，则该值用于更新内存。
- en: Next, the interpreter converts the linear index into memory, `I`, to a row (`i`)
    and column (`j`) format so that we can apply the actual movement command ➋. Integer
    division by 5 maps `I` to 0 through 4 to give us the row. The modulo, that is,
    what’s left over after integer division by 5, gives us the remainder representing
    the column.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，解释器将线性索引 `I` 转换为内存中的行（`i`）和列（`j`）格式，以便我们可以应用实际的移动指令 ➋。通过整数除法 5，将 `I` 映射到
    0 到 4，得到行位置。模运算，即整数除法后剩余的部分，给出代表列的余数。
- en: The current move is now applied ➌. Note that `Move` is called only if the instruction
    is a move instruction. The cardinal directions update the row and column position
    accordingly, wrapping around as needed so that moving east when in column 4 moves
    back around to column 0, and so on.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用当前的移动指令 ➌。请注意，只有在指令是移动指令时，才会调用 `Move`。主方向会相应更新行和列的位置，并在需要时进行环绕。例如，当处于第 4
    列时，向东移动会回绕到第 0 列，依此类推。
- en: There are two special move commands, `T` and `L`. The former acts like a tick
    of a clock. The firefly doesn’t actually move to a new position, hence `pass`,
    but the interpreter does update the current position. The latter instruction,
    `L`, is specifically for the micro:bit. It enters an infinite loop that sleeps
    for 1,000 seconds before waking up briefly, only to sleep again. As stated above,
    a Firefly program executes `H` to halt the program and the interpreter exits.
    On the micro:bit, when a program exits, the display is cleared. Calling `L` instead
    of `H` preserves the display.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个特殊的移动命令，`T`和`L`。前者类似于时钟的滴答。萤火虫实际上并不移动到新的位置，因此`pass`，但解释器会更新当前位置。后者指令`L`专门用于micro:bit。它进入一个无限循环，在休眠1,000秒后短暂唤醒，然后再次休眠。如上所述，Firefly程序执行`H`来停止程序，解释器退出。在micro:bit上，当程序退出时，显示被清除。调用`L`而不是`H`会保留显示。
- en: After the move command is executed, `i` and/or `j` have been updated. Before
    returning to the main loop, a new value for `I` is calculated by multiplying the
    row number (`i`) by 5, which is the number of elements per row, and adding the
    column number (`j`).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行移动命令后，`i`和/或`j`已经更新。在返回主循环之前，通过将行号(`i`)乘以每行的元素数5，并添加列号(`j`)，计算出`I`的新值。
- en: '***Display***'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***显示***'
- en: Four functions control the display, as shown in [Listing 14-4](ch14.xhtml#ch014list4).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 四个函数控制显示，如[列表14-4](ch14.xhtml#ch014list4)所示。
- en: '[PRE5]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 14-4: Firefly interpreter display*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表14-4：Firefly解释器显示*'
- en: Three of the functions in [Listing 14-4](ch14.xhtml#ch014list4), `Clear`, `ClearA`,
    and `ClearB`, simply zero the display memory. The first function zeroes the current
    display, and the last two zero a given display, that is, `A` or `B`. Simply assigning
    a new `bytearray` to these global variables will not work because that would break
    the link with `A` and `B`, which are `bytearray` objects, while `C` and `D` act
    more like pointers that reference `A` or `B`. Recall that `C` references the memory
    the firefly is updating and `D` references the memory currently displayed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[清除](ch14.xhtml#ch014list4)列表14-4中的三个功能，`Clear`，`ClearA`和`ClearB`，简单地将显示内存清零。第一个功能将当前显示清零，而最后两个则将给定的显示清零，即`A`或`B`。简单地将新的`bytearray`分配给这些全局变量是行不通的，因为这会打破与`A`和`B`的链接，它们是`bytearray`对象，而`C`和`D`则更像是引用`A`或`B`的指针。请记住，`C`引用着萤火虫正在更新的内存，而`D`则引用当前显示的内存。'
- en: The `Display` function updates the displayed or drawn-to memory based on the
    argument, `c`. Specifying `"A"` as the argument makes `C` reference `*A*` . Likewise,
    passing `"B"` points `C` at `B`. Passing `"X"` changes the displayed memory to
    `A` and passing `"Y"` points the display to `B`. Note that the `global` statements
    used by these functions to update the global variables properly. Most Python programs
    use objects, so the `global` keyword is seldom used. We decided on a strictly
    imperative implementation of Firefly, thereby requiring `global` statements.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Display`函数根据参数`c`更新显示或绘制到内存。将参数设为`"A"`使`C`引用`*A*`。类似地，传递`"B"`将`C`指向`B`。传递`"X"`将显示内存更改为`A`，传递`"Y"`则将显示指向`B`。注意，这些函数使用`global`语句来正确更新全局变量。大多数Python程序使用对象，因此很少使用`global`关键字。我们决定严格实现Firefly的命令式实现，因此需要`global`语句。'
- en: '***Music***'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***音乐***'
- en: We’ve surveyed the main interpreter loop, movement, and display. Now let’s finish
    Firefly by implementing the music instructions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经调查了主解释器循环、移动和显示。现在让我们通过实现音乐指令来完成Firefly。
- en: The `J` and `G` instructions, which set the note duration and octave, respectively,
    are in the main loop (see [Listing 14-1](ch14.xhtml#ch014list1)). The play instruction,
    `F`, calls `*Play*` .
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`J`和`G`指令分别设置音符持续时间和八度，位于主循环中（见[列表14-1](ch14.xhtml#ch014list1)）。播放指令`F`调用`*Play*`。'
- en: '[PRE6]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`Play` translates the current firefly position into a note string and then
    plays the note using the current octave and duration via the MicroPython `music`
    function, `play`. There are 10 possible values for a memory location, so the note
    is modulo 8 to handle cases where the memory value is 8 or 9 by wrapping around
    to 0 and 1 instead.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Play`将当前萤火虫位置转换为音符字符串，然后通过MicroPython的`music`函数`play`以当前八度和持续时间播放音符。内存位置有10个可能的值，因此音符对8取模，以处理内存值为8或9的情况，将其循环至0和1。'
- en: With `Play`, our micro:bit implementation of Firefly is complete. As mentioned
    earlier, the console version has extra code to handle console cursor positioning,
    execution tracing, and to capture SIGINT via CTRL-C; please do take a look at
    how those features are implemented by reading through *firefly.py*, which is the
    name of the console version of the interpreter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: We’re almost ready for some Firefly programming. However, if we’re using an
    actual micro:bit, we should become at least familiar enough with it to configure
    a speaker and power it up. We’ll save programming the micro:bit for [Chapter 15](ch15.xhtml#ch15).
    For now, let’s take a crash course in micro:bit hardware.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuring the Micro:bit**'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The BBC micro:bit (*[https://microbit.org/](https://microbit.org/)*) is a small,
    single-board computer. Out of the box, it runs MicroPython (see the documentation
    at *[https://microbit-micropython.readthedocs.io/en/v2-docs/](https://microbit-micropython.readthedocs.io/en/v2-docs/)*).
    The micro:bit is intended to introduce as many people as possible to programming
    via an inexpensive computer system. There are two versions available: the older
    v1 which has 16KB of RAM, and the newer v2 with 128KB of RAM. Both versions are
    geared toward hardware projects, and a plethora of accessories exist (*[https://microbit.org/buy/accessories/](https://microbit.org/buy/accessories/)*).
    To learn more about the impressive amount of hardware supported by the micro:bit
    itself, see [https://tech.microbit.org/hardware/](https://tech.microbit.org/hardware/).
    Lastly, to learn more about implementing hardware projects with the micro:bit,
    see Simon Monk’s excellent book *Micro:bit for Mad Scientists* (No Starch Press,
    2019).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '***Micro:bit Hardware Overview***'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 14-3](ch14.xhtml#ch014fig3) details the micro:bit and its features.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/14fig03.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: A hardware overview of the micro:bit (version 2)*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Of primary interest to us is the 5×5 LED display, the speaker, and the Micro-USB
    connector to program the device. If you have the older version 1 device, there
    is no built-in speaker. In that case, you’ll need to attach an external speaker;
    see the following section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The micro:bit comes with a small battery pack for two AAA batteries. However,
    it runs just fine from the Micro-USB connector when attached to a computer or
    a 5V power supply. However, early versions of the micro:bit, those before version
    1.3B, should not be run from an external 5V supply. If your micro:bit has a speaker,
    it’s good to go. If it doesn’t, check the version, which is visible on the back
    in small print near the right side of the edge connector, to make sure it is at
    least version 1.3B or 1.5.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '***Using an External Speaker***'
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Skip this section if your micro:bit is version 2 with a built-in speaker. For
    version 1 devices, we’ll need to add an external speaker, but have no fear: doing
    so is painless. Let’s walk through the process.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: First, you need a speaker of some sort. If you have an old speaker from a defunct
    electronics device, like an old radio, you can use it. In years past, most tinkerers
    had many such speakers pulled from dead transistor radios. However, in this day
    and age, it’s more likely you don’t have a bare speaker lying around. But not
    all is lost! It turns out that a pair of headphones will work just fine.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The micro:bit edge connector is the interface between the micro:bit and external
    hardware devices. To connect a speaker, attach one wire to connector 0 (the one
    with the “0” on it), and the other wire to the connector marked “GND.” If using
    headphones, connect the headphone plug’s tip to connector 0 and the part of the
    plug farthest from the tip to the GND connector. The connections are easiest to
    make with alligator clips, but if you don’t have those handy, bare wires twisted
    together and wrapped around the connectors going through the holes on the micro:bit
    will do the trick. [Figure 14-4](ch14.xhtml#ch014fig4) shows how to connect a
    generic speaker using alligator clips. The inset shows how to connect headphones.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/14fig04.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: Connecting an external speaker or headphones*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Some speakers are marked with plus (+) and minus (–) connections. If so, connect
    the white wire in [Figure 14-4](ch14.xhtml#ch014fig4) to the + connection and
    the red to the – connection. Don’t worry if the speaker isn’t marked for polarity;
    it will still work whichever way you connect the wires. For the headphones, the
    part of the plug farthest from the tip is usually ground, so connect the red wire
    to it and the white to the tip.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced us to Firefly, its design, and the rationale behind
    it. We then walked through the implementation as we’ll soon run it on the micro:bit
    and concluded by configuring the micro:bit for our Firefly experiments. Firefly
    is about as simple as a programming language gets. Now, let’s watch some fireflies
    and see what they can do.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
