- en: '**2**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**BEYOND BASIC STATIC ANALYSIS: X86 DISASSEMBLY**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To thoroughly understand a malicious program, we often need to go beyond basic
    static analysis of its sections, strings, imports, and images. This involves reverse
    engineering a program’s assembly code. Indeed, disassembly and reverse engineering
    lie at the heart of deep static analysis of malware samples.
  prefs: []
  type: TYPE_NORMAL
- en: Because reverse engineering is an art, technical craft, and science, a thorough
    exploration is beyond the scope of this chapter. My goal here is to introduce
    you to reverse engineering so that you can apply it to malware data science. Understanding
    this methodology is essential for successfully applying machine learning and data
    analysis to malware.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter I start with the concepts you’ll need to understand x86 disassembly.
    Later in the chapter I show how malware authors attempt to bypass disassembly
    and discuss ways to mitigate these anti-analysis and anti-detection maneuvers.
    But first, let’s review some common disassembly methods as well as the basics
    of x86 assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disassembly Methods**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Disassembly* is the process by which we translate malware’s binary code into
    valid x86 assembly language. Malware authors generally write malware programs
    in a high-level language like C or C++ and then use a compiler to compile the
    source code into x86 binary code. Assembly language is the human-readable representation
    of this binary code. Therefore, disassembling a malware program into assembly
    language is necessary to understand how it behaves at its core.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, disassembly is no easy feat because malware authors regularly
    employ tricks to thwart would-be reverse engineers. In fact, perfect disassembly
    in the face of deliberate obfuscation is an unsolved problem in computer science.
    Currently, only approximate, error-prone methods exist for disassembling such
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the case of *self-modifying code*, or binary code that
    modifies itself as it executes. The only way to disassemble this code properly
    is to understand the program logic by which the code modifies itself, but that
    can be exceedingly complex.
  prefs: []
  type: TYPE_NORMAL
- en: Because perfect disassembly is currently impossible, we must use imperfect methods
    to accomplish this task. The method we’ll use is *linear disassembly*, which involves
    identifying the contiguous sequence of bytes in the Portable Executable (PE) file
    that corresponds to its x86 program code and then decoding these bytes. The key
    limitation of this approach is that it ignores subtleties about how instructions
    are decoded by the CPU in the course of program execution. Also, it doesn’t account
    for the various obfuscations malware authors sometimes use to make their programs
    harder to analyze.
  prefs: []
  type: TYPE_NORMAL
- en: The other methods of reverse engineering, which we won’t cover here, are the
    more complex disassembly methods used by industrial-grade disassemblers such as
    IDA Pro. These more advanced methods actually simulate or reason about program
    execution to discover which assembly instructions a program might reach as a result
    of a series of conditional branches.
  prefs: []
  type: TYPE_NORMAL
- en: Although this type of disassembly can be more accurate than linear disassembly,
    it’s far more CPU intensive than linear disassembly methods, making it less suitable
    for data science purposes where the focus is on disassembling thousands or even
    millions of programs.
  prefs: []
  type: TYPE_NORMAL
- en: Before you can begin analysis using linear disassembly, however, you’ll need
    to review the basic components of assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: '**Basics of x86 Assembly Language**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Assembly language is the lowest-level human-readable programming language for
    a given architecture, and it maps closely to the binary instruction format of
    a particular CPU architecture. A line of assembly language is almost always equivalent
    to a single CPU instruction. Because assembly is so low level, you can often retrieve
    it easily from a malware binary by using the right tools.
  prefs: []
  type: TYPE_NORMAL
- en: Gaining basic proficiency in reading disassembled malware x86 code is easier
    than you might think. This is because most malware assembly code spends most of
    its time calling into the operating system by way of the Windows operating system’s
    *dynamic-link libraries (DLLs)*, which are loaded into program memory at runtime.
    Malware programs use DLLs to do most of the real work, such as modifying the system
    registry, moving and copying files, making network connections and communicating
    via network protocols, and so on. Therefore, following malware assembly code often
    involves understanding the ways in which function calls are made from assembly
    and understanding what various DLL calls do. Of course, things can get much more
    complicated, but knowing this much can reveal a lot about the malware.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections I introduce some important assembly language concepts.
    I also explain some abstract concepts like control flow and control flow graphs.
    Finally, we disassemble the *ircbot.exe* program and explore how its assembly
    and control flow can give us insight into its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two major dialects of x86 assembly: Intel and AT&T. In this book
    I use Intel syntax, which can be obtained from all major disassemblers and is
    the syntax used in the official Intel documentation of the x86 CPU.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by taking a look at CPU registers.
  prefs: []
  type: TYPE_NORMAL
- en: '***CPU Registers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Registers* are small data storage units on which x86 CPUs perform computations.
    Because registers are located on the CPU itself, register access is orders of
    magnitude faster than memory access. This is why core computational operations,
    such as arithmetic and condition testing instructions, all target registers. It’s
    also why the CPU uses registers to store information about the status of running
    programs. Although many registers are available to experienced x86 assembly programmers,
    we’ll just focus on a few important ones here.'
  prefs: []
  type: TYPE_NORMAL
- en: '**General-Purpose Registers**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: General-purpose registers are like scratch space for assembly programmers. On
    a 32-bit system, each of these registers contains 32, 16, or 8 bits of space against
    which we can perform arithmetic operations, bitwise operations, byte order–swapping
    operations, and more.
  prefs: []
  type: TYPE_NORMAL
- en: In common computational workflows, programs move data into registers from memory
    or from external hardware devices, perform some operations on this data, and then
    move the data back out to memory for storage. For example, to sort a long list,
    a program typically pulls list items in from an array in memory, compares them
    in the registers, and then writes the comparison results back out to memory.
  prefs: []
  type: TYPE_NORMAL
- en: To understand some of the nuances of the general-purpose register model in the
    Intel 32-bit architecture, take a look at [Figure 2-1](ch02.xhtml#ch02fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0014-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: Registers in the x86 architecture*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The vertical axis shows the layout of the general-purpose registers, and the
    horizontal axis shows how EAX, EBX, ECX, and EDX are subdivided. EAX, EBX, ECX,
    and EDX are 32-bit registers that have smaller, 16-bit registers inside them:
    AX, BX, CX, and DX. As you can see in the figure, these 16-bit registers can be
    subdivided into upper and lower 8-bit registers: AH, AL, BH, BL, CH, CL, DH, and
    DL. Although it’s sometimes useful to address the subdivisions in EAX, EBX, ECX,
    and EDX, you’ll mostly see direct references to EAX, EBX, ECX, and EDX.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack and Control Flow Registers**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The stack management registers store critical information about the *program
    stack*, which is responsible for storing local variables for functions, arguments
    passed into functions, and control information relating to the program control
    flow. Let’s go over some of these registers.
  prefs: []
  type: TYPE_NORMAL
- en: In simple terms, the ESP register points to the top of the stack for the currently
    executing function, whereas the EBP register points to the bottom of the stack
    for the currently executing function. This is crucial information for modern programs,
    because it means that by referencing data relative to the stack rather than using
    its absolute address, procedural and object-oriented code can access local variables
    more gracefully and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Although you won’t see direct references to the EIP register in x86 assembly
    code, it’s important in security analysis, particularly in the context of vulnerability
    research and buffer-overflow exploit development. This is because EIP contains
    the memory address of the currently executing instruction. Attackers can use buffer-overflow
    exploits to corrupt the value of the EIP register indirectly and take control
    of program execution.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to its role in exploitation, EIP is also important in the analysis
    of malicious code deployed by malware. Using a debugger we can inspect EIP’s value
    at any moment, which helps us understand what code malware is executing at any
    particular time.
  prefs: []
  type: TYPE_NORMAL
- en: EFLAGS is a status register that contains CPU *flags*, which are bits that store
    status information about the state of the currently executing program. The EFLAGS
    register is central to the process of making *conditional branches*, or changes
    in execution flow resulting from the outcome of if/then-style program logic, within
    x86 programs. Specifically, whenever an x86 assembly program checks whether some
    value is greater or less than zero and then jumps to a function based on the outcome
    of this test, the EFLAGS register plays an enabling role, as described in more
    detail in “[Basic Blocks and Control Flow Graphs](ch02.xhtml#lev30)” on [page
    19](ch02.xhtml#page_19).
  prefs: []
  type: TYPE_NORMAL
- en: '***Arithmetic Instructions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Instructions* operate on general-purpose registers. You can perform simple
    computations with the general-purpose registers using arithmetic instructions.
    For example, `add`, `sub`, `inc`, `dec`, and `mul` are examples of arithmetic
    instructions you’ll encounter frequently in malware reverse engineering. [Table
    2-1](ch02.xhtml#ch02tab1) lists some examples of basic instructions and their
    syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Arithmetic Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instructions** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `add ebx, 100` | Adds 100 to the value in EBX and then stores the result
    in EBX |'
  prefs: []
  type: TYPE_TB
- en: '| `sub ebx, 100` | Subtracts 100 from the value in EBX and then stores the
    result in EBX |'
  prefs: []
  type: TYPE_TB
- en: '| `inc ah` | Increments the value in AH by 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `dec al` | Decrements the value in AL by 1 |'
  prefs: []
  type: TYPE_TB
- en: The `add` instruction adds two integers and stores the result in the first operand
    specified, whether this is a memory location or a register according to the following
    syntax. Keep in mind only one argument can be a memory location. The `sub` instruction
    is similar to `add`, except it subtracts integers. The `inc` instruction increments
    a register or memory location’s integer value, whereas `dec` decrements a register
    or memory location’s integer value.
  prefs: []
  type: TYPE_NORMAL
- en: '***Data Movement Instructions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The x86 processor provides a robust set of instructions for moving data between
    registers and memory. These instructions provide the underlying mechanisms that
    allow us to manipulate data. The staple memory movement instruction is the `mov`
    instruction. [Table 2-2](ch02.xhtml#ch02tab2) shows how you can use the `mov`
    instruction to move data around.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-2:** Data Movement Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instructions** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `mov ebx,eax` | Moves the value in register EAX into register EBX |'
  prefs: []
  type: TYPE_TB
- en: '| `mov eax, [0x12345678]` | Moves the data at memory address 0x12345678 into
    the EAX register |'
  prefs: []
  type: TYPE_TB
- en: '| `mov edx, 1` | Moves the value 1 into the register EDX |'
  prefs: []
  type: TYPE_TB
- en: '| `mov [0x12345678], eax` | Moves the value in EAX into the memory location
    0x12345678 |'
  prefs: []
  type: TYPE_TB
- en: Related to the `mov` instruction, the `lea` instruction loads the absolute memory
    address specified into the register used for getting a pointer to a memory location.
    For example, `lea edx, [esp-4]` subtracts 4 from the value in ESP and loads the
    resulting value into EDX.
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack Instructions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *stack* in x86 assembly is a data structure that allows you to push and
    pop values onto and off of it. This is similar to how you would add and remove
    plates on and off the top of a stack of plates.
  prefs: []
  type: TYPE_NORMAL
- en: Because control flow is often expressed through C-style function calls in x86
    assembly and because these function calls use the stack to pass arguments, allocate
    local variables, and remember what part of the program to return to after a function
    finishes executing, the stack and control flow need to be understood together.
  prefs: []
  type: TYPE_NORMAL
- en: The `push` instruction pushes values onto the program stack when the programmer
    wants to save a register value onto the stack, and the `pop` instruction deletes
    values from the stack and places them into a designated register.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `push` instruction uses the following syntax to perform its operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the program points the stack pointer (the register ESP) to
    a new memory address, thereby making room for the value (1), which is now stored
    at the top location on the stack. Then it copies the value from the argument to
    the memory location the CPU has just made room for on the top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s contrast this with `pop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The program uses `pop` to pop the top value off the stack and move it into a
    specified register. In this example, `pop eax` pops the top value off the stack
    and moves it into `eax`.
  prefs: []
  type: TYPE_NORMAL
- en: An unintuitive but important detail to understand about the x86 program stack
    is that it grows downward in memory, so that the highest value on the stack is
    actually stored at the lowest address in stack memory. This becomes very important
    to remember when you analyze assembly code that references data stored on the
    stack, as it can quickly get confusing unless you know the stack’s memory layout.
  prefs: []
  type: TYPE_NORMAL
- en: Because the x86 stack grows downward in memory, when the `push` instruction
    allocates space on the program stack for a new value, it decrements the value
    of ESP so that it points to a lower location in memory and then copies a value
    from the target register into that memory location, starting at the top address
    of the stack and growing up. Conversely, the `pop` instruction actually copies
    the top value off of the stack and then increments the value of ESP so it points
    to a higher memory location.
  prefs: []
  type: TYPE_NORMAL
- en: '**Control Flow Instructions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An x86 program’s *control flow* defines the network of possible instruction
    execution sequences a program may execute, depending on the data, device interactions,
    and other inputs the program might receive. Control flow instructions define a
    program’s control flow. They are more complicated than stack instructions but
    still quite intuitive. Because control flow is often expressed through C-style
    function calls in x86 assembly, the stack and control flow are closely related.
    They’re also related because these function calls use the stack to pass arguments,
    allocate local variables, and remember what part of the program to return to after
    a function finishes executing.
  prefs: []
  type: TYPE_NORMAL
- en: The `call` and `ret` control flow instructions are the most important in terms
    of how programs call functions in x86 assembly and how programs return from functions
    after these functions are done executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `call` instruction calls a function. Think of this as a function you might
    write in a higher-level language like C to allow the program to return to the
    instruction after the `call` instruction is invoked and the function has finished
    executing. You can invoke the `call` instruction using the following syntax, where
    address denotes the memory location where the function’s code begins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `call` instruction does two things. First, it pushes the address of the
    instruction that will execute after the function call returns onto the top of
    the stack so that the program knows what address to return to after the called
    function finishes executing. Second, `call` replaces the current value of EIP
    with the value specified by the address operand. Then, the CPU begins execution
    at the new memory location pointed to by EIP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as `call` initiates a function call, the `ret` instruction completes it.
    You can use the `ret` instruction on its own and without any parameter, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When invoked, `ret` pops the top value off the stack, which we expect to be
    the saved program counter value (EIP) that the `call` instruction pushed onto
    the stack when the `call` instruction was invoked. Then it places the popped program
    counter value back into EIP and resumes execution.
  prefs: []
  type: TYPE_NORMAL
- en: The `jmp` instruction is another important control flow construction, which
    operates more simply than `call`. Instead of worrying about saving EIP, `jmp`
    simply tells the CPU to move to the memory address specified as its parameter
    and begin execution there. For example, `jmp 0x12345678` tells the CPU to start
    executing the program code stored at memory location 0x12345678 on the next instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be wondering how you can make `jmp` and `call` instructions execute
    in a conditional way, such as “if the program has received a network packet, execute
    the following function.” The answer is that x86 assembly doesn’t have high-level
    constructs like if, then, else, else if, and so on. Instead, branching to an address
    within a program’s code typically requires two instructions: a `cmp` instruction,
    which checks the value in some register against some test value and stores the
    result of that test in the EFLAGS register, and a conditional branch instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: Most conditional branch instructions start with a *j*, which allows the program
    to jump to a memory address, and are post-fixed with letters that stand for the
    condition being tested. For example, `jge` tells the program to jump if greater
    than or equal to. This means that the value in the register being tested must
    be greater than or equal to the test value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cmp` instruction uses the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As stated earlier, `cmp` compares the value in the specified general-purpose
    register with value and then stores the result of that comparison in the EFLAGS
    register.
  prefs: []
  type: TYPE_NORMAL
- en: 'The various conditional `jmp` instructions are then invoked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we can prefix *j* to any number of conditional test instructions.
    For example, to jump only if the value tested is greater than or equal to the
    value in the register, use the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that unlike the case of the `call` and `ret` instructions, the `jmp` family
    of instructions never touches the program stack. In fact, in the case of the `jmp`
    family of instructions, the x86 program is responsible for tracking its own execution
    flow and potentially saving or deleting information about what addresses it has
    visited and where it should return to after a particular sequence of instructions
    has executed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Blocks and Control Flow Graphs**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Although x86 programs look sequential when we scroll through their code in a
    text editor, they actually have loops, conditional branches, and unconditional
    branches (control flow). All of these give each x86 program a *network* structure.
    Let’s use the simple toy assembly program in [Listing 2-1](ch02.xhtml#ch02list1)
    to see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-1: Assembly program for understanding control flow graph*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this program initializes a counter to the value 10, stored in
    register EAX ➊. Next, it does a loop in which the value in EAX is decremented
    by 1 ➋ on each iteration. Finally, once EAX has reached a value of 0 ➌, the program
    breaks out of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: In the language of control flow graph analysis, we can think of these instructions
    as comprising three basic blocks. A *basic block* is a sequence of instructions
    that we know will always execute contiguously. In other words, a basic block always
    ends with either a branching instruction or an instruction that is the target
    of a branch, and it always begins with either the first instruction of the program,
    called the program’s *entry point*, or a branch target.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 2-1](ch02.xhtml#ch02list1), you can see where the basic blocks of
    our simple program begin and end. The first basic block is composed of the instruction
    `mov eax, 10` under `setup:`. The second basic block is composed of lines beginning
    with `sub eax, 1` through `jne $loopstart` under `loopstart:`, and the third starts
    at `mov eax, 1` under `loopend:`. We can visualize the relationships between the
    basic blocks using the graph in [Figure 2-2](ch02.xhtml#ch02fig2). (We use the
    term *graph* synonymously with the term *network*; in computer science, these
    terms are interchangeable.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0019-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: A visualization of the control flow graph of our simple assembly
    program*'
  prefs: []
  type: TYPE_NORMAL
- en: If one basic block can ever flow into another basic block, we connect it, as
    shown in [Figure 2-2](ch02.xhtml#ch02fig2). The figure shows that the `setup`
    basic block leads to the `loopstart` basic block, which repeats 10 times before
    it transitions to the `loopend` basic block. Real-world programs have control
    flow graphs such as these, but they’re much more complicated, with thousands of
    basic blocks and thousands of interconnections.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disassembling ircbot.exe Using pefile and capstone**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you have a good understanding of the basics of assembly language,
    let’s disassemble the first 100 bytes of *ircbot.exe*’s assembly code using linear
    disassembly. To do this, we’ll use the open source Python libraries `pefile` (introduced
    in [Chapter 1](ch01.xhtml#ch01)) and `capstone`, which is an open source disassembly
    library that can disassemble 32-bit x86 binary code. You can install both of these
    libraries with `pip` using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once these two libraries are installed, we can leverage them to disassemble
    *ircbot.exe* using the code in [Listing 2-2](ch02.xhtml#ch02list2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-2: Disassembling* ircbot.exe'
  prefs: []
  type: TYPE_NORMAL
- en: 'This should produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Don’t worry about understanding all of the instructions in the disassembly
    output: that would involve an understanding of assembly that goes beyond the scope
    of this book. However, you should feel comfortable with many of the instructions
    in the output and have some sense of what they do. For example, the malware pushes
    the value in register EBP onto the stack ➊, saving its value. Then it proceeds
    to move the value in ESP into EBP and pushes some numerical values onto the stack.
    The program moves some data in memory into the EAX register ➋, and it adds the
    value -0x5c to the value in the ESP register ➌. Finally, the program uses the
    `call` instruction to call a function stored at the memory address 0x496308 ➍.'
  prefs: []
  type: TYPE_NORMAL
- en: Because this is not a book on reverse engineering, I won’t go into any more
    depth here about what the code means. What I’ve presented is a start to understanding
    how assembly language works. For more information on assembly language, I recommend
    the Intel programmer’s manual at *[http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html](http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Factors That Limit Static Analysis**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter and [Chapter 1](ch01.xhtml#ch01), you learned about a variety
    of ways in which static analysis techniques can be used to elucidate the purpose
    and methods of a newly discovered malicious binary. Unfortunately, static analysis
    has limitations that render it less useful in some circumstances. For example,
    malware authors can employ certain offensive tactics that are far easier to implement
    than to defend against. Let’s take a look at some of these offensive tactics and
    see how to defend against them.
  prefs: []
  type: TYPE_NORMAL
- en: '***Packing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Malware *packing* is the process by which malware authors compress, encrypt,
    or otherwise mangle the bulk of their malicious program so that it appears inscrutable
    to malware analysts. When the malware is run, it unpacks itself and then begins
    execution. The obvious way around malware packing is to actually run the malware
    in a safe environment, a dynamic analysis technique I’ll cover in [Chapter 3](ch03.xhtml#ch03).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Software packing is also used by benign software installers for legitimate
    reasons. Benign software authors use packing to deliver their code because it
    allows them to compress program resources to reduce software installer download
    sizes. It also helps them thwart reverse engineering attempts by business competitors,
    and it provides a convenient way to bundle many program resources within a single
    installer file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Resource Obfuscation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another anti-detection, anti-analysis technique malware authors use is *resource
    obfuscation*. They obfuscate the way program resources, such as strings and graphical
    images, are stored on disk, and then deobfuscate them at runtime so they can be
    used by the malicious program. For example, a simple obfuscation would be to add
    a value of 1 to all bytes in images and strings stored in the PE resources section
    and then subtract 1 from all of this data at runtime. Of course, any number of
    obfuscations are possible here, all of which make life difficult for malware analysts
    attempting to make sense of a malware binary using static analysis.
  prefs: []
  type: TYPE_NORMAL
- en: As with packing, one way around resource obfuscation is to just run the malware
    in a safe environment. When this is not an option, the only mitigation for resource
    obfuscation is to actually figure out the ways in which malware has obfuscated
    its resources and to manually deobfuscate them, which is what professional malware
    analysts often do.
  prefs: []
  type: TYPE_NORMAL
- en: '***Anti-disassembly Techniques***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A third group of anti-detection, anti-analysis techniques used by malware authors
    are *anti-disassembly* techniques. These techniques are designed to exploit the
    inherent limitations of state-of-the-art disassembly techniques to hide code from
    malware analysts or make malware analysts think that a block of code stored on
    disk contains different instructions than it actually does.
  prefs: []
  type: TYPE_NORMAL
- en: An example of an anti-disassembly technique involves branching to a memory location
    that the malware author’s disassemblers will interpret as a different instruction,
    essentially hiding the malware’s true instructions from reverse engineers. Anti-disassembly
    techniques have huge potential and there’s no perfect way to defend against them.
    In practice, the two main defenses against these techniques are to run malware
    samples in a dynamic environment and to manually figure out where anti-disassembly
    strategies manifest within a malware sample and how to bypass them.
  prefs: []
  type: TYPE_NORMAL
- en: '***Dynamically Downloaded Data***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A final class of anti-analysis techniques malware authors use involves externally
    sourcing data and code. For example, a malware sample may load code dynamically
    from an external server at malware startup time. If this is the case, static analysis
    will be useless against such code. Similarly, malware may source decryption keys
    from external servers at startup time and then use these keys to decrypt data
    or code that will be used in the malware’s execution.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, if the malware is using an industrial-strength encryption algorithm,
    static analysis will not be sufficient to recover the encrypted data and code.
    Such anti-analysis and anti-detection techniques are quite powerful, and the only
    way around them is to acquire the code, data, or private keys on the external
    servers by some means and then use them in one’s analysis of the malware in question.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter introduced x86 assembly code analysis and demonstrated how we can
    perform disassembly-based static analysis on *ircbot.exe* using open source Python
    tools. Although this is not meant to be a complete primer on x86 assembly, you
    should now feel comfortable enough that you have a starting place for figuring
    out what’s going on in a given malware assembly dump. Finally, you learned ways
    in which malware authors can defend against disassembly and other static analysis
    techniques, and how you can mitigate these anti-analysis and anti-detection strategies.
    In [Chapter 3](ch03.xhtml#ch03), you’ll learn to conduct dynamic malware analysis
    that makes up for many of the weaknesses of static malware analysis.
  prefs: []
  type: TYPE_NORMAL
