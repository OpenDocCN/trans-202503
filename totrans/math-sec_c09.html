<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 9: Computational Geometry for Safety Resource Distribution</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:1ff3c234-c763-4a12-a0c7-4ddf7c732e40" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_161" title="161"/>9</span><br/>
<span class="ChapterTitle">Computational Geometry for Safety Resource Distribution</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">In enterprise security work, you’ll often be asked to assist with a wide variety of infrastructure planning and deployment tasks that have more to do with providing safety than the traditional CIA (confidentiality, integrity, availability) triad we commonly think of as guiding information security. But fear not—with the mathematical tools you’re collecting, you’ll be able to adapt to the changing challenges and thrive under them. In this chapter we’ll focus on one of the most commonly applied tools from computational geometry, and one of my personal favorite algorithms: Voronoi tessellation.</p>
<p>We’re going to help the city of Portland, Oregon, plan the location of a new fire station using the locations of the current stations to inform our risk assessment. I picked this project because it shows how applied security concepts can scale; the same type of analysis can be applied to police stations, hospitals, burger joints, or any other public resource distributed throughout a city, state, country, or geographic region, making this one of the most flexible analysis tools in your arsenal.</p>
<p><span epub:type="pagebreak" id="Page_162" title="162"/>This is the high-level plan: first we’ll create a polygon that represents the city, and then we’ll place points within the polygon representing the locations of the current fire stations. We’ll split up the city into smaller polygons that represent the areas closest to a given fire station. Finally, we’ll compare the areas of the smaller polygons to determine which fire station is responsible for covering the most area, and make our recommendation for the new fire station accordingly to improve response time in that area. Along the way, we’ll examine Voronoi tessellations and discuss some of the limitations of our implementation. By the end of this chapter, you should have a solid understanding of how to use computational geometry for resource distribution plans. You should also feel comfortable retrieving and manipulating geospatial information using the OpenStreetMaps API, which will allow you to scale your resource planning to whatever geographic size you need.</p>
<h2 id="h1-502567c09-0001">Using Voronoi Tessellation for Resource Distribution</h2>
<p class="BodyFirst">You already saw tessellation in action when we placed the security assets around the park in <span class="xref" itemid="xref_target_Chapter 7"><a href="c07.xhtml">Chapter 7</a></span>. In that case we divided the plane into triangles based on the vertices of the polygon, then placed a point in some of these regions representing the guard. We would expect the guard to respond to any incident that was within their zone. A <em>Voronoi tessellation</em> works in reverse, where we have a set of points (called <em>seeds</em> or <em>generators</em>) distributed throughout a plane, and we want to split up the area into regions that contain a single point. Take a look at <a href="#figure9-1" id="figureanchor9-1">Figure 9-1</a>, which shows an example of a Voronoi tessellation. </p>
<figure>
<img alt="" class="" src="image_fi/502567c09/f09001.png"/>
<figcaption><p><a id="figure9-1">Figure 9-1</a>: Randomly generated Voronoi tessellation</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure9-1">Figure 9-1</a> is in the 2nd cell of the <em>MapBox_Tessellation.ipynb</em> notebook.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The gray circles represent 10 randomly selected (<em>x</em>, <em>y</em>) coordinates that serve as the generators for our Voronoi tessellation. Each line segment represents the place in the plane that is equidistant from two or more generators. Points along the lines are the same distance from more than one <span epub:type="pagebreak" id="Page_163" title="163"/>generator point, so we mark them as the border between generators. After marking all the borders between generators, we end up with a polygonal mosaic. Each polygon represents a subregion of the plane. In each polygon region there’s exactly one generator point, so we can classify any arbitrary point in the plane that doesn’t fall on a border line segment based on which generator point is closest.</p>
<p>In the park example from <span class="xref" itemid="xref_target_Chapter 7"><a href="c07.xhtml">Chapter 7</a></span>, this would be like spreading the guards through the park and then dividing up the park into areas of responsibility based on their positions. Approaching the problem this way is useful in a lot of cases, especially when examining the distribution of resources that are already in place or can’t be moved easily.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	One of the most famous uses of the Voronoi tessellation came before it was formally defined and named, when British physician John Snow used the concept in 1854 to illustrate how the majority of people who died in the Broad Street cholera outbreak lived closer to the infected Broad Street pump than to any other water pump.<sup class="endnote"><a href="b01.xhtml#c09-endnote-001" id="c09-noteref-001">1</a></sup></p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Formally speaking, a Voronoi tessellation divides a plane into regions of space where all the points in one region are closer to the generator for that region than any other generator. Points that are equidistant from two or more generators define the boundary between the regions. To perform the Voronoi tessellation for the fire station project, we need to define a <em>metric space X</em>, which is simply a set (in this case, of generator points in a plane defined by a 2D polygon) and a metric function that operates on the set (here, a function <em>d</em> to calculate distance between points). Our metric space—that is, the plane we’ll be tessellating—is bounded by the shape of the city limits. The generator points will be the locations of the current stations that divide the city up into areas of responsibility. Both the boundary data and the generating points need to be in the same coordinate system. Rather than having to manually project the coordinates, like we did in the previous project, we’ll take advantage of a purpose-built library called geovoronoi, which handles the back-and-forth projections under the hood. </p>
<h2 class="HeadProject" id="h1-502567c09-0002"><span>The Proof of Concept: Analyzing Fire Station Coverage</span></h2>
<p class="BodyFirst">The proof of concept for this project is pretty straightforward. Our goal is to produce an application that shows the current division of fire service coverage for the city of Portland, using a Voronoi tessellation to define the service areas programmatically. We want our program to find the largest service area and produce this as the recommended area to split up. To achieve this, we need to define three pieces of information. First, we need shape data representing the area we plan to analyze, in this case Portland. I’ve included a copy of this data in the file <em>portland_geodata.json</em> in the book’s supplemental materials. You can also get the data from web services like OpenStreetMap API, which is how I retrieved it initially. The second thing we need is the location of our generator points, which, for this project, are the addresses of the various fire stations around Portland. I’ve included the 10 addresses I used for this analysis in the file <em/><span epub:type="pagebreak" id="Page_164" title="164"/>station_addresses_portland.csv in the supplemental materials. Third, we need to define the function we’ll use to measure distance between points when performing the Voronoi tessellation. </p>
<p>Once we’ve defined these three pieces of information, we’re ready to perform the Voronoi analysis. Then it’s just a matter of finding the generated region with the largest area; for this, we’ll again rely on Shapely. We’re going to start by discussing the distance function. Loading the area shape and generator points are interesting data retrieval tasks, but the distance function defines how the borders between regions will be calculated, so it’s where the bulk of the math magic happens.</p>
<h3 id="h2-502567c09-0001">Defining the Distance Function</h3>
<p class="BodyFirst">The metric space contains the distance function<em> d</em>(<em>p</em>, <em>q</em>), which is used to determine the distance between points in the plane. This is how the algorithm decides which points belong to which regions. There are several choices for the distance function: Manhattan distance, Chebychev distance, sum of absolute difference, sum of squared difference, and more. Each has advantages and disadvantages, so we’ll stick with the most basic and intuitive option, Euclidean distance or, colloquially, “as the crow flies.”</p>
<p>The Euclidean distance between points <em>p</em> and <em>q</em> is the length of the line segment connecting them (<span class="math" title="overline {pq} "><span class="MathOverline"><span class="mi">pq</span><span class="mo"/></span></span>). If we treat the latitude and longitude as Cartesian coordinates, we can approach the problem as a 2D Euclidean geometry question, which we can solve using the Pythagorean theorem:</p>
<figure class="graphic equation">
<img alt="" class="" src="image_fi/502567c09/m09001.png"/></figure>

<p>Here <em>n</em> is the number of dimensions the problem is mapped to, or more generally the length of the vector that defines a point. So, if you were working in 10 dimensions, each point would be defined by a vector of length 10. In our case, we have two dimensions, so <em>n</em> = 2. We simply need to square the difference between the end point and the beginning point, sum the squared difference across both dimensions, and then find the square root of the result.</p>
<p>There is a drawback to Euclidean distance in this scenario: in reality, you can rarely move straight through a geographic area without worrying about obstructions like trees and buildings. Furthermore, vehicles like fire engines are confined to streets and subject to traffic and other conditions that dictate the path they take to their destination. I encourage you to expand on my simplification to make the results more accurate and useful in your own implementation. For now, we’ve defined everything we need to start diving into the question. It’s time to start collecting the data required to define our geometric plane, starting with the shape of the city limits.</p>
<h3 id="h2-502567c09-0002">Determining the City Shape</h3>
<p class="BodyFirst">To get the polygon that represents the bounds of the plane, I like to use a web tool from the OpenStreetMap team called Nominatim (<a class="LinkURL" href="https://nominatim.org">https://nominatim.org</a>). Its simple and free interface allows you to get several important pieces of information, like the place ID, the localized spellings of the name, and more. You <span epub:type="pagebreak" id="Page_165" title="165"/>can view the information on the website directly or request a JSON response to parse in your own programs, as we do here. <a href="#listing9-1" id="listinganchor9-1">Listing 9-1</a> shows how to request the information.</p>
<pre><code>import urllib, requests, json
base = "https://nominatim.openstreetmap.org/search.php"
f = {"q": "Portland OR", "polygon_geojson":1, "format":"json"}
q = urllib.parse.urlencode(f)
resp = requests.get("%s?%s" % (base, q))
resp_data = json.loads(resp.text)[0]</code></pre>
<p class="CodeListingCaption"><a id="listing9-1">Listing 9-1</a>: Retrieving the JSON data for Portland, Oregon, via Nominatim</p>
<p>When we call the Nominatim API, the <code>q</code> parameter holds the query string we’re searching; here, we set it to a string containing the city name and state abbreviation, <code>"Portland OR"</code>. The <code>polygon_geojson</code> parameter tells the API to return the geoJSON representation of the polygon indicating the boundaries of the city. This is the part we’re most interested in at the moment, since it gets the shape data we need to define the city limits. The <code>format</code> parameter tells the API how we want the response data encoded. Whenever JSON is an option, it’s a good choice for Python, as it handles the parsed data like a dictionary. We have to encode the parameter dictionary into a string that can be appended to the URL, using the <code>urllib.parse.urlencode</code> function. We then submit the query string as part of a GET request and parse the data using the function <code>json.loads</code> on the text value of the response. The value should come back as a list with one or more entries representing the places that match our query. In this case, there should be only one result, representing the city of Portland. <a href="#figure9-2" id="figureanchor9-2">Figure 9-2</a> shows the polygon.</p>
<figure>
<img alt="" class="keyline" src="image_fi/502567c09/f09002.png"/>
<figcaption><p><a id="figure9-2">Figure 9-2</a>: The city of Portland as a polygon</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" id="Page_166" title="166"/><h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure9-2">Figure 9-2</a> is in the 14th cell of the <em>MapBox_Tessellation.ipynb</em> notebook. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The gray area represents the municipal boundaries of the city. This is the section that must be protected by the city’s fire service. We need to convert the coordinates into a shape, but first let’s format the data as geoJSON, as shown in <a href="#listing9-2" id="listinganchor9-2">Listing 9-2</a>.</p>
<pre><code>city_gj = {
  "type": "FeatureCollection",
  "features": [
      {
          "type": "Feature",
          "geometry": resp_data["geojson"],
          "properties": {
            "name": "City Boundary"
          }
      }
  ]
}</code></pre>
<p class="CodeListingCaption"><a id="listing9-2">Listing 9-2</a>: Converting the coordinates to a geoJSON feature collection</p>
<p>The data structure here is the top-level definition of a geoJSON object, which has the type property <code>FeatureCollection</code> to indicate that there can be a list of features nested under the appropriately named <code>features</code> key. Each feature is a nested JSON object with the type <code>Feature</code>. Each feature needs a set of coordinates that define its geometry; here we use <code>resp_data["geojson"]</code>, the geoJSON that was returned from the API in <a href="#listing9-1">Listing 9-1</a>. We can also add further properties to store custom information that can be used for organization or to inform our analysis. The <code>properties</code> key is followed by a nested dictionary of property and value definitions, where the dictionary’s key represents the property name and the value represents the property value. Keys are restricted to string literals, but the values can be any legal JSON object, so you can get pretty creative with the property information you attach to the features. </p>
<p>The next step, shown in <a href="#listing9-3" id="listinganchor9-3">Listing 9-3</a>, is to convert the resulting geoJSON information into <code>shape</code> objects stored together in a <code>GeometryCollection</code>. </p>
<pre><code>from shapely.geometry import GeometryCollection, shape
city_shape = GeometryCollection(
    [shape(f["geometry"]).buffer(0) for f in city_gj["features"]]
)
city_shape = [geom for geom in city_shape][0]</code></pre>
<p class="CodeListingCaption"><a id="listing9-3">Listing 9-3</a>: Converting the city geometry into a collection of Shapely shapes</p>
<p><span epub:type="pagebreak" id="Page_167" title="167"/>First we create a <code>GeometryCollection</code> by passing in a list of geometric objects making up the collection. We use a list comprehension to loop over each feature in the <code>city_gj</code> variable created in <a href="#listing9-2">Listing 9-2</a>. For each feature, we pass the geometry parameter to the <code>shape</code> constructor. The result is a <code>shape</code> object representing the coordinates of the geoJSON feature. Some cities are represented by more than one polygon, so this function will loop over all of the polygons that make up the city and convert each one into a <code>shape</code> object. The <code>city_shape</code> is now a <code>GeometryCollection</code> containing a single <code>MultiPolygon</code> object. We can access the <code>MultiPolygon</code> with another list comprehension. Since there’s only one item, we can extract it from the list using index <code>0</code>. If you had more <code>MultiPolygon</code> objects to process, you’d want to loop over each individually. The <code>MultiPolygon</code> data in the <code>city_shape</code> variable now represents the plane we’ll be tessellating using the metric space we’ve defined. Now it’s time to get the locations for the stations to create our list of generators.</p>
<h3 id="h2-502567c09-0003">Gathering the Locations of Existing Fire Stations</h3>
<p class="BodyFirst">As I mentioned previously, we’ll be using the geographic location of the existing fire stations as the regional generators in our analysis. The file <em>station_addresses_portland.csv</em>, provided in the book’s supplemental materials, contains the names and addresses of 10 fire stations within the city limits. The pandas library offers a convenient function for loading data from a CSV file into a <code>DataFrame</code>, shown in <a href="#listing9-4" id="listinganchor9-4">Listing 9-4</a>.</p>
<pre><code>import pandas as pd
stations_df = pd.read_csv("station_addresses_portland.csv", names=[
    "name", "street", "city", "state", "zip"
])
stations_df["addr"] = stations_df.apply(row_to_str, axis=1)</code></pre>
<p class="CodeListingCaption"><a id="listing9-4">Listing 9-4</a>: Loading the data into a <code>DataFrame</code> the quick-and-dirty way</p>
<p> Although there are libraries specifically for handling CSV data, I prefer to leverage pandas’s built-in <code>read_csv</code> function, as it is flexible and comes packaged in a library I already use often. When I was preparing the data for this project, I compiled the station address list manually, using Google Maps. I didn’t bother to include a header, which is why we pass in a list of columns using the <code>names</code> parameter. In an actual consultation, I’d expect the client to provide the addresses for you, so you’ll likely need to adjust the file parsing to match the data format you’re provided. Next we create a convenient <code>addr</code> column to hold the whole street address as a string by applying a function called <code>row_to_str</code>, which simply returns the concatenation of the <code>street</code>, <code>city</code>, <code>state</code>, and <code>zip</code> columns separated by a space character. We pass <code>axis=1</code> to tell pandas we want to apply the function to the whole row, instead of all the values in a column. We’ll use the <code>addr</code> column to make it easier to search the geolocation API.</p>
<p><span epub:type="pagebreak" id="Page_168" title="168"/>Once we’ve gathered the addresses into a <code>DataFrame</code>, we can again leverage the OpenStreetMaps API (via the geocoder library) to turn these into geodesic points. In <a href="#listing9-5" id="listinganchor9-5">Listing 9-5</a> we define the <code>locate</code> function to turn a single address into location info.</p>
<pre><code>import geocoder
def locate(addr):
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> g = geocoder.osm(addr)
    data = g.json
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> if data is None:
        return None
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> return {
        "address": data["address"],
        "lat": data["lat"],
        "lon": data["lng"],
        "osm_id": data["osm_id"]
    }</code></pre>
<p class="CodeListingCaption"><a id="listing9-5">Listing 9-5</a>: Converting an address to a geodesic point</p>
<p>The main work of calling the API is abstracted away for us by the <code>geocoder.osm</code> function <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Passing in a query string (in this case, the address) returns an object containing the API’s response. The library supplies a convenient <code>json</code> parameter on the response object. If the JSON response is <code>None</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span>, we return <code>None</code> to indicate that the API couldn’t locate anything for the input query. If a JSON object is returned, we grab a subset of the data containing the important information from the response, such as the latitude and longitude, and return it as a dictionary <span aria-label="annotation3" class="CodeAnnotation">❸</span>. We also record the <code>osm_id</code>, so we can use it to shortcut future lookups or choose between multiple results for a query. </p>
<p>To collect the points for all the stations, we’ll call the <code>locate</code> function in a loop over the addresses and store the results as a list. Since we previously created a <code>DataFrame</code> from the station data (the <code>stations_df</code> variable from <a href="#listing9-4">Listing 9-4</a>), we can leverage pandas’s <code>apply</code> function to handle the messy work behind the scenes. We’ll then convert the location information into its own <code>GeoDataFrame</code> object. <a href="#listing9-6" id="listinganchor9-6">Listing 9-6</a> shows how to handle the conversion.</p>
<pre><code>import geopandas as gpd
locations = stations_df["addr"].apply(locate)
locations = [a for a in list(locations) if a is not None]
loc_df = pd.DataFrame(locations)
geo_df = gpd.GeoDataFrame(
    loc_df,
    geometry=gpd.points_from_xy(loc_df.lat, loc_df.lon)
)</code></pre>
<p class="CodeListingCaption"><a id="listing9-6">Listing 9-6</a>: Creating a <code>DataFrame</code> from the station locations</p>
<p><span epub:type="pagebreak" id="Page_169" title="169"/>After we call <code>apply</code>, the <code>locations</code> variable contains a list of dictionary objects, one for each station, to hold the geodesic coordinates we need for our analysis. We filter out any instances where the location is <code>None</code> and then use this data to create a location <code>DataFrame</code> named <code>loc_df</code>. Finally, we can convert this regular pandas <code>DataFrame</code> into a more suitable <code>GeoDataFrame</code> object from the GeoPandas library. <a href="#figure9-3" id="figureanchor9-3">Figure 9-3</a> shows the results plotted on the map. </p>
<figure>
<img alt="" class="keyline" src="image_fi/502567c09/f09003.png"/>
<figcaption><p><a id="figure9-3">Figure 9-3</a>: The fire station locations as points</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure9-3">Figure 9-3</a> is in the 15th cell of the <em>MapBox_Tessellation.ipynb</em> notebook.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The dark circles inside the previously defined polygon show the station locations. If you count the locations on the map, only 8 of the 10 stations are present. The <code>locate</code> function failed to locate coordinates for two of the addresses. If this project were meant for production, we’d probably want to have multiple sources from which to retrieve the coordinates to increase the likelihood of success. You could also look them up manually or ask a client to provide the missing information. For now, we’ll just drop these two from the analysis and move on. </p>
<p>Now that we’ve collected all the necessary data, we’re ready to perform the actual tessellation. </p>
<h3 id="h2-502567c09-0004"><span epub:type="pagebreak" id="Page_170" title="170"/>Performing the Voronoi Analysis</h3>
<p class="BodyFirst">As usual, there are several options for performing a Voronoi tessellation in Python, but the easiest by far when working with geographic information is a library named geovoronoi, which handles the coordinate projection and boundary work for us. It takes a list of coordinates and calculates the Voronoi regions using SciPy behind the scenes. At the edges of a typical Voronoi diagram, the region boundaries continue out to infinity, which isn’t always the desired behavior, so the geovoronoi library allows us to take the shape of the surrounding area (in this case, the shape of a city as a polygon) to cut the Voronoi regions so that they fit into the provided shape, making the regions at the edges finite. The library also uses Shapely for managing the shape manipulation operations, making it a perfect fit for this project. </p>
<p><a href="#listing9-7" id="listinganchor9-7">Listing 9-7</a> shows how to use the library along with the previously collected data to create the tessellation.</p>
<pre><code>import numpy as np
from geovoronoi import voronoi_regions_from_coords
points = np.array([[p.y, p.x] for p in list(geo_df["geometry"])])
poly_shapes, pts, poly_to_pt = voronoi_regions_from_coords(
    points, city_shape
)</code></pre>
<p class="CodeListingCaption"><a id="listing9-7">Listing 9-7</a>: Converting an address to a geodesic point</p>
<p>The first step is to convert the points representing the fire stations into a NumPy array using a list comprehension to iterate over the <code>geometry</code> column of the previously created <code>geo_df</code> <code>DataFrame</code> object. We can then call the <code>voronoi_regions_from_coords</code> function from the geovoronoi library with the array of points (<code>points</code>) as the first argument and the boundary polygon (<code>city_shape</code>) as the second. </p>
<p>The result of the function is a tuple containing three useful pieces of information. The <code>poly_shapes</code> variable holds a list of Shapely <code>Polygon</code> objects representing the shape of the Voronoi regions created during the tessellation algorithm. The <code>pts</code> variable holds a set of <code>Point</code> objects representing the coordinates of the generators. These are for convenience if you haven’t already created them using GeoPandas or some other method. The <code>poly_to_pt</code> variable holds a nested list for each region in <code>poly_shapes</code> that contains a list of indices into <code>pts</code>. The indices indicate the generators that belong to this Voronoi region. Usually, this is only a single point for our problem, because multiple fire stations shouldn’t share the same location, but there may be cases where this isn’t true and multiple generator points have the exact same location. In these situations, all of the points will be indexed in <code>poly_to_pt</code>. </p>
<p><a href="#figure9-4" id="figureanchor9-4">Figure 9-4</a> shows the regions that were created along with the generators for each region.</p>
<span epub:type="pagebreak" id="Page_171" title="171"/><figure>
<img alt="" class="keyline" src="image_fi/502567c09/f09004.png"/>
<figcaption><p><a id="figure9-4">Figure 9-4</a>: A Voronoi tessellation showing each station’s area of responsibility</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate <a href="#figure9-4">Figure 9-4</a> is in the 19th cell of the <em>MapBox_Tessellation.ipynb</em> notebook. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The eight regions are divided by the black outlines. The area inside each polygon can be viewed as the naive area of responsibility (AOR) for the fire station that generated the region. It is naive because it doesn’t take into account obstructions (like the water) that might make a different station the better choice to respond. Still, the information is a good starting point for you to build on. We can already see how the distribution of the stations near the center of the city leaves the edge stations with the largest AORs. Visually, the top-left AOR appears to be the largest, but we can easily verify this using the <code>area</code> parameter, as shown in <a href="#listing9-8" id="listinganchor9-8">Listing 9-8</a>.</p>
<pre><code>winning = 0
winner = -1
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> for i in range(len(poly_shapes)):
    ps = poly_shapes[i]
    if ps.area == winning:
      <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> if isinstance(winning, int):
            winner = [winner, i]
        elif isinstance(winning, list):
            winner.append(i)
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> elif ps.area &gt; winning:
        winner = i
        winning = ps.area</code></pre>
<p class="CodeListingCaption"><a id="listing9-8">Listing 9-8</a>: Finding the largest AOR</p>
<p><span epub:type="pagebreak" id="Page_172" title="172"/>We begin by looping over each shape in the <code>poly_shapes</code> variable, iterating over the length of the list <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Looping this way allows us to keep track of the index as the function progresses. There may be cases (albeit unlikely) where more than one region has the same area. In such a case, we convert the <code>winner</code> variable into a list and keep track of the ties <span aria-label="annotation2" class="CodeAnnotation">❷</span>. In the more likely scenario, the two areas aren’t equal, so we check if the current area is greater than the current winning area <span aria-label="annotation3" class="CodeAnnotation">❸</span>. If so, we update the <code>winning</code> amount and the <code>winner</code> index. Once all regions have been checked, the <code>winner</code> variable will contain one or more region indices, which we can use to look up the shape (or shapes) in <code>poly_shapes</code>. We can also use it to look up the station (or stations) in <code>poly_to_pt</code>. </p>
<p><a href="#figure9-5" id="figureanchor9-5">Figure 9-5</a> shows the region plotted to the map along with the station location responsible for it. </p>
<figure>
<img alt="" class="keyline" src="image_fi/502567c09/f09005.png"/>
<figcaption><p><a id="figure9-5">Figure 9-5</a>: The largest region and its generator location</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	The code to generate the overlay in <a href="#figure9-5">Figure 9-5</a> is in the 23rd cell of the <em>MapBox_Tessellation.ipynb</em> notebook.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Once again, the darker gray area represents the region of interest and the dark gray circle shows the location of the responding fire station. Therefore, you could reasonably argue that placing another station somewhere within that region would improve response time and resource availability in that area.</p>
<p>You can run the proof-of-concept code by navigating to the chapter’s supplemental materials directory and running the <em>Emergency_service_poc.py</em> script like so:</p>
<pre><code>python Emergency_service_poc.py</code></pre>
<p><span epub:type="pagebreak" id="Page_173" title="173"/>Once the code finishes loading the data and performing the Voronoi analysis, it will open a browser tab to <em>http://127.0.0.1</em>, which displays the solution using Plotly and the MapBox API.</p>
<h2 id="h1-502567c09-0003">Limitations of the Algorithm</h2>
<p class="BodyFirst">In this chapter we’ve focused solely on the geographic portion of the problem, which is an excellent starting point. The narrow scope does present some limitations, though. I’ve already mentioned the limitations of the distance function, but there are other factors to consider if you’re asked to make a recommendation like this in the real world. </p>
<p>For one, not all fire stations are equipped the same. Some have more trucks, some have different types of specialty equipment (like a plane for surveying large wooded areas, or a boat for doing harbor patrols), and so on. The diversity of equipment means that different stations may be better equipped to handle different problems. Putting a specially equipped station in a region where it isn’t needed would be a terrible waste of resources. Another problem with the distribution of resources is that some stations are more equipped to deal with larger regions. For example, a station with a large area but 10 fire trucks at its disposal may be able to patrol its region more effectively than a station with a medium-sized region but only two trucks. You can improve upon this analysis by adding more information about the resources and specializations for the stations. You would want to ask your contacts in the city about the equipment plan for the new station and then factor that in when creating the Voronoi regions.</p>
<p>The final consideration is that fire stations don’t see these boundaries. A fire in one region may bring responders from nearby regions as well. The fire department does a lot to try to distribute the load for any given area across two or more stations so that large fires can be controlled more quickly. The larger the fire, the more resources it will take to battle, and therefore it may be necessary to direct resources from one region to assist in another. Strictly dividing the region into AORs may lead you to suggest a station location that perfectly distributes the AORs but nevertheless doesn’t allow the new station to assist the existing stations in a meaningful way. </p>
<p>To avoid this limitation, I suggest performing multiple analyses. For each station in the data, you can check how each other station affects its region by removing them one at a time from the list and recalculating the regions. This is similar to asking, “How would the responsibilities for station A change if station B weren’t able to respond?” By overlaying the resulting regions, you’ll see which stations take on the most shared responsibility because that region will have the largest overall change in area after all the other stations have been removed. A station with a lot of shared responsibility may suffer from equipment fatigue or physical exhaustion, so you may suggest that another station located somewhere closer to the overworked station could distribute the load better. Again, the station with the most shared responsibilities may have the proper equipment and personnel to handle the extra work.</p>
<p><span epub:type="pagebreak" id="Page_174" title="174"/>All of this is meant to show you that, although Voronoi diagrams are extremely useful, they’re not always the final answer. As with all analyses, the more accuracy and detail you add to your model, the more applicable the results will be to the real world. When performing any type of resource analysis, it’s just as important to understand how those resources interact with their region as with each other. Doing so will allow you to make intelligent choices for your model and overcome some of the limitations of this basic framework.</p>
<h2 id="h1-502567c09-0004">Summary</h2>
<p class="BodyFirst">In this chapter, we’ve covered one of the most famous computational geometry algorithms, the Voronoi tessellation. We’ve seen how it can be applied to real-world problems related to the distribution of resources and how it can be scaled to fit the problem. We’ve also discussed some of the limitations to this implementation and ways you can improve upon it yourself. My hope is that you’ll take this framework and expand upon it to suit your own projects.</p>
<p>There’s a lot of excellent research material available on the different applications of these tessellations, from security to neurology and everywhere in between. I recommend you read the research paper “Rationalizing Police Patrol Beats Using Voronoi Tessellations”<sup class="endnote"><a href="b01.xhtml#c09-endnote-002" id="c09-noteref-002">2</a></sup> for another example of applying this analysis to improve emergency services. As a security analyst, you’ll find plenty of opportunities to show off your resource distribution knowledge. In the final part of the book, we’ll revisit tessellations to plan the distribution of security resources for the art gallery problem.</p>
<p>In the next chapter, we’ll conclude our look into the world of computational geometry for security with one of my favorite projects of all time, facial recognition systems. Although the size and geometry are drastically different from anything we’ve dealt with so far, the basic ideas are the same. We’ll continue to use Shapely to handle the geometry, but now we’ll add some machine learning to the mix, giving us the tools needed to build the highly sophisticated analysis required to recognize facial features programmatically.</p>
</section>
</body>
</html>