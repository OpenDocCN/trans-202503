<html><head></head><body>
<h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_41"/><strong><span class="big">2</span><br/>AN AUTOMATED AGITATOR FOR PCB ETCHING</strong></h2>&#13;
<div class="image1"><img alt="image" src="../images/common-01.jpg"/></div>&#13;
<p class="noindent">This project uses the Arduino microcontroller to sense change in a motor’s current drain (the rate at which the motor uses electricity) and then reverse the direction of the motor. There are numerous applications for the measurement and use of current drain, and this project provides an example method that can prove useful in the development of future electronics projects.</p>&#13;
<p class="indent">“<a href="ch00.xhtml#ch00lev1sec5">Making Your Own PCBs</a>” on <a href="ch00.xhtml#page_13">page 13</a> illustrates different ways to design and make circuit boards at home for a very modest cost using readily available and environmentally safe household products. Part of this process includes etching the copper off a clad board. The process is more efficient when the board is agitated in the etching solution, resulting in a laminar flow of liquid across the surface of the board in both directions. Depending on the chemical activity of the etchant and thickness of copper to be etched, this process can take anywhere from 10 or 15 minutes to well <span epub:type="pagebreak" id="page_42"/>over half an hour! Standing there stirring the pot is pretty boring, but you can create a device that dunks the board in and out of the solution for you (see <a href="ch02.xhtml#ch02fig1">Figure 2-1</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/f02-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig1"/><em>Figure 2-1: Illustration of the motor, crank, and etching vessels set up to dip a circuit board in and out of the etchant. While there are many ways to agitate a circuit board, dipping it into and out of the etching solution works well, especially for small boards</em>.</p>&#13;
<p class="indent">In this project, the Arduino is measuring the current from the motor. When the motor’s rotation reaches the limit pin, it begins to stall, increasing the current drain. The Arduino reacts to the increase in current by reversing the motor.</p>&#13;
<div class="box1">&#13;
<p class="boxtitle"><strong>INSPIRATION BEHIND THE AUTOMATIC MOTOR REVERSAL PROJECT</strong></p>&#13;
<p class="noindent">This project has its roots in a problem my friend had with a model train set accessory. The accessory included a tramway to take make-believe skiers up and down a miniature mountain. The original mechanism failed, so I created a little circuit to drive a DC motor that moved the skiers up and down. My idea was that when the tramcar reached either the top or bottom of its run, the motor would slow down or stall, resulting in an increase in current drain. That excessive current drain would reverse the motor by changing the polarity and thereby send the car back the other way. To date, the skiers are still at the bottom of the mountain because my friend and I never installed the board, but the core circuit works well and promises other interesting applications.</p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_43"/>The ability to receive an input, process the information, and produce an output is <em>the</em> fundamental function of any microcontroller. In this case, the Arduino starts the motor turning, waits until it detects the motor drawing more current than usual, and then reverses the motor’s rotational direction. This simple function has a number of different applications: you could use the voltage drop to provide a safety turn-off for an overloaded motor, create a system to limit motion, and more.</p>&#13;
<h3 class="h3" id="ch02lev1sec1"><strong>Required Tools</strong></h3>&#13;
<p class="indent">One 6-32 tap</p>&#13;
<p class="indent">Drill and drill bits</p>&#13;
<p class="indent">Needle-nose pliers</p>&#13;
<h3 class="h3" id="ch02lev1sec2"><strong>Parts List</strong></h3>&#13;
<p class="indent">One Arduino Nano or clone</p>&#13;
<p class="indento">One SN754410 quad H-bridge IC, with socket if desired (Note that if you use the socket, you lose whatever value the PCB offers as a heat sink.)</p>&#13;
<p class="indent">One printed circuit board (PCB) or perf board</p>&#13;
<p class="indento">One current-limiting resistor (You should have a selection available for experimentation, from 1 ohm to 10 ohm. A 1/8 W resistor will work for smaller motors, but get a 1/4 or 1/2 W resistor for larger loads.)</p>&#13;
<p class="indent">Two 330-ohm, 1/8 W resistors</p>&#13;
<p class="indent">Two LEDs, one red, one green</p>&#13;
<p class="indent">One LM7805 voltage regulator</p>&#13;
<p class="indent">One plastic enclosure (I recommend the Hammond 1591 XXATBU.)</p>&#13;
<p class="indent">Two 2-pin female headers to connect the motor to the shield</p>&#13;
<p class="indent">Four 4-pin female headers to plug the Nano into</p>&#13;
<p class="indent">One small solder lug</p>&#13;
<p class="indent">One 3.5 mm, 2-conductor jack and plug</p>&#13;
<p class="indent">One SPST toggle switch</p>&#13;
<p class="indent">One plug-in wall adapter with an output of 5 to 12V at 200 mA or better</p>&#13;
<p class="indent">One gear head motor (I used a 6V motor, the Amico 20 RPM 6VDC.)</p>&#13;
<p class="indent">Two M3×0.5 mm screws with threaded spacers</p>&#13;
<p class="indent">Limit wires, preferably 0.039 piano wire or spring wire</p>&#13;
<p class="indent">Scrap brass or aluminum</p>&#13;
<p class="indent">One 4-40 or 6-32 screw</p>&#13;
<h3 class="h3" id="ch02lev1sec3"><strong><span epub:type="pagebreak" id="page_44"/>Downloads</strong></h3>&#13;
<p class="noindent">Before you start this project, check the following resource files for this book at <em><a href="https://www.nostarch.com/arduinoplayground/">https://www.nostarch.com/arduinoplayground/</a></em>:</p>&#13;
<p class="indentt"><strong>Sketch</strong> <em>Reverse.ino</em></p>&#13;
<p class="indent"><strong>Shield</strong> <em>Reverse.pcb</em></p>&#13;
<p class="indent"><strong>Template</strong> <em>MotorMount.pdf</em></p>&#13;
<h3 class="h3" id="ch02lev1sec4"><strong>How Automatic Motor Reversal Works</strong></h3>&#13;
<p class="noindent">The Arduino is perfect for this project because it can control the whole system, and it simplifies the problem of accommodating different motors with different current requirements. Implementing the project in discrete components would require several more components than the equivalent Arduino circuit. Further, changing values for different motors or different reversal thresholds would mean changing a lot of hardware, but with Arduino, you just have to make a simple program change. The Arduino also provides the flexibility to add delays at each end of the run if desired.</p>&#13;
<p class="indent">The motor circuit you’ll connect to the Arduino uses a resistor between the power supply and the motor (see <a href="ch02.xhtml#ch02fig2">Figure 2-2</a>). When the motor slows or stalls, the current increases, creating a voltage drop across the resistor.</p>&#13;
<div class="image"><img alt="image" src="../images/f02-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig2"/><em>Figure 2-2: A voltage is created across the resistor between the positive supply and the input to the motor. It is this voltage that triggers the operation of the circuit</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_45"/>The voltage drop across resistor R is the real-world input to the microcontroller. In this project, that voltage drop is fed to the Arduino Nano’s two analog input pins that straddle the dropping resistor. The microcontroller digests this input and creates an output designated by your program.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>You could implement the circuit with only a single analog input, but that would curtail some of the flexibility of the circuit—particularly if you use motors that run at different voltages</em>.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch02lev1sec5"><strong>The Schematic</strong></h3>&#13;
<p class="noindent">The agitator circuit feeds the voltage that appears across resistor R1 into two of the Arduino’s analog input pins, A0 and A1, setting up the real-world input (see <a href="ch02.xhtml#ch02fig3">Figure 2-3</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/f02-03.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig3"/><em>Figure 2-3: The completed schematic for this project shows the 5.6-ohm voltage-drop resistor (R1), the two LEDs (D), the 330-ohm current-limiting resistors (R2 and R3), and the quad H-bridge (SN754410), of which half is used</em>.</p>&#13;
<p class="indent">All grounds in this circuit are connected together, and the voltage across pins A0 and A1 is the voltage your program will use to decide when to reverse the motor’s direction. Note that this voltage is not referenced to either the positive or negative rail, but it must be between 0 and 5V to prevent damage to the microcontroller. If you get stuck on wiring the H-Bridge, see “<a href="ch02.xhtml#ch02lev1sec7">Using an H-Bridge</a>” on <a href="ch02.xhtml#page_48">page 48</a>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_46"/>The analog-to-digital converter (ADC) behind each analog pin provides 10 bits of resolution, which means the converter can deliver up to 1,024—that is, 210—different values, from 0 to 1,023, depending on the input.</p>&#13;
<p class="indent">Thus, if the power supply is 5V, each increment is roughly</p>&#13;
<p class="center">5V ÷ 1023 ≈ 0.0048V.</p>&#13;
<h3 class="h3" id="ch02lev1sec6"><strong>Determining the Reversal Threshold</strong></h3>&#13;
<p class="noindent">In order to write a program that tells the Arduino when to reverse your motor, you have to determine that point yourself, with some math and a little bit of faith.</p>&#13;
<p class="indent">First, determine the current drain of the motor you’re using. It’s usually printed on the motor’s label. The motor I used has a current drain of about 40 milliamps (mA), or 40 thousandths of an ampere (see <a href="ch02.xhtml#ch02fig4">Figure 2-4</a>). Now we get into the heavy math. You’re going to have to use a formula known as <em>Ohm’s law</em> to determine the voltage threshold to set in the sketch.</p>&#13;
<div class="image"><img alt="image" src="../images/f02-04.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig4"/><em>Figure 2-4: I used an Asian import motor, shown here with one limit pin installed, that has demonstrated reliability and performance. The screws are M3×0.05</em>.</p>&#13;
<p class="indent">I used a 5.6-ohm resistor in series with my motor circuit. Using Ohm’s law, which states that voltage equals current times resistance (<em>V</em> = <em>IR</em>, with voltage in volts, current in amperes, and resistance in ohms), we’re able to calculate that 40 mA times the resistance of 5.6 ohm is about 0.224V:</p>&#13;
<div class="imageo"><img alt="image" src="../images/e0046-01.jpg"/></div>&#13;
<p class="indent">Now, go back to the ADC. It has 1,024 units to represent 5V, so each unit represents 0.0049V. A little arithmetic reveals that the 0.224V dropped represents about 46 units out of the 1,024:</p>&#13;
<div class="imageo"><img alt="image" src="../images/e0046-02.jpg"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_47"/>There are some estimates you have to take on faith—at least until you confirm with a test. This is one. As a motor is slowed or stalled, the current drain increases. Depending on the motor, the increase in current is typically somewhere between two and four times the normal current drain, but possibly more.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>With no load (or minimal load), current drain on the motor is minimal. With a usual running load, current can be four to five times the no-load current. With a heavy load, current can be as much as 10 times that, depending on the motor design</em>.</p>&#13;
</div>&#13;
<p class="indent">So according to our good-faith model, a good place to start setting the threshold for reversing the motor would be in the area of 90 to 100 units of the ADC’s 1,024 units.</p>&#13;
<p class="indent">Alternatively, you could use a digital multimeter to measure the exact current drain first (see <a href="ch02.xhtml#ch02fig5">Figure 2-5</a>). To use a multimeter to measure current drain, set its indicator to 200 mA to start; you may need to set it as high as 10 A if the motor doesn’t move when you build the circuit described here.</p>&#13;
<div class="image"><img alt="image" src="../images/f02-05.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig5"/><em>Figure 2-5: Multimeters are handy for many projects and useful to have around the house. They’re available from a variety of sources at a range of prices. I use this cheap one from Electronic Goldmine, but if you plan to do high-voltage experiments, invest in a really good multimeter</em>.</p>&#13;
<p class="indent">Build the circuit as shown in <a href="ch02.xhtml#ch02fig6">Figure 2-6</a>, and then connect the red lead of the multimeter to the power supply. Connect the black lead of the multimeter to the motor lead to complete the circuit. If the reading is negative, reverse the red and black leads of the multimeter. Depending on your power supply voltage and the motor’s voltage requirement, you may also need to connect the motor to power through a voltage regulator circuit, as described in “<a href="ch02.xhtml#ch02lev3sec3">The Voltage Regulator</a>” on <a href="ch02.xhtml#page_58">page 58</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_48"/><img alt="image" src="../images/f02-06.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig6"/><em>Figure 2-6: Connection diagram for measuring the current drain of the motor</em></p>&#13;
<p class="indent">To check the current drain, hold the shaft of the motor to slow it, and watch the readout on the multimeter. You can get an accurate indication of the number of ADC steps by plugging your readout in to Ohm’s law, calculating the voltage, and converting into steps, as I did.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">NOTE</span></strong></p>&#13;
<p class="notep"><em>In the sketch, I use a value of 100 as the threshold for reversing. You could also calculate the absolute value of the voltage drop by multiplying 100 by 0.0049V:</em></p>&#13;
<p class="center">100 steps × 0.0049V per step = 0.49V</p>&#13;
</div>&#13;
<p class="indent">Remember, the exact threshold depends on the type of motor you use. Different motors will have different current capabilities and may even require a different value resistor. Also, note that the value of current drain is not precise. The nature of permanent magnet motors is such that the current drain under load will be a range, not an exact number.</p>&#13;
<p class="indent">As the current increases, the voltage drop increases until it reaches the point where the microcontroller is instructed to do something. At that point, the difference in analog voltage that appears between A0 and A1 is above the preset threshold, which will set the Arduino into action. Once the threshold is reached, the Arduino tells the H-bridge to reverse the current to the motor.</p>&#13;
<h3 class="h3" id="ch02lev1sec7"><strong>Using an H-Bridge</strong></h3>&#13;
<p class="noindent">You’ll likely encounter an H-bridge driver in future projects because it’s a very versatile part and can serve numerous functions. There is quite a selection of H-bridge chips available, but I’ve been using the Texas Instruments SN754410 quad H-bridge. It’s popular because it operates over a wide voltage range and is extremely flexible—and inexpensive. The logic operates at <span epub:type="pagebreak" id="page_49"/>a 5V level, while the drive can be as much as 36V with a continuous output of 1 A (and a peak output of 2 A), making it capable of driving a wide variety of hobby motors, solenoids, and even relays. It comes in a standard 16-pin dual inline package (DIP). The DIP package was a longtime standard but is slowly being replaced by newer types (see “<a href="ch00.xhtml#ch00lev1sec7">Using SOICs</a>” on <a href="ch00.xhtml#page_20">page 20</a>). It’s the conventional centipede-looking circuit.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch02fig7">Figure 2-7</a> shows the pinout for the SN754410 H-bridge, and <a href="ch02.xhtml#ch02tab1">Table 2-1</a> shows its function table. You’ll find more information in Texas Instruments’ data sheet at <em><a href="http://www.ti.com/lit/ds/slrs007b/slrs007b.pdf">http://www.ti.com/lit/ds/slrs007b/slrs007b.pdf</a></em>.</p>&#13;
<div class="image"><img alt="image" src="../images/f02-07.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig7"/><em>Figure 2-7: The pinout for the SN754410 quad H-bridge chip used in this project. Note that pin 1 is in the top-left corner of the chip when viewed from the top with the notch pointing up</em>.</p>&#13;
<p class="tabcaption"><a id="ch02tab1"/><strong>Table 2-1:</strong> Function Table for the SN754410</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td class="table" style="vertical-align: top;"><p class="table_th"><strong>Inputs</strong></p></td>&#13;
<td class="table" style="vertical-align: top;"><p class="table_th"> </p></td>&#13;
<td class="table" style="vertical-align: top;"><p class="tablel"><strong>Output (Y)</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table" style="vertical-align: top;"><p class="table_th"><strong>A</strong></p></td>&#13;
<td class="table" style="vertical-align: top;"><p class="table_th"><strong>EN</strong></p></td>&#13;
<td class="table" style="vertical-align: top;"><p class="table_th"> </p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table" style="vertical-align: top;"><p class="table">H</p></td>&#13;
<td class="table" style="vertical-align: top;"><p class="table">H</p></td>&#13;
<td class="table" style="vertical-align: top;"><p class="tablel">H</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table" style="vertical-align: top;"><p class="table">L</p></td>&#13;
<td class="table" style="vertical-align: top;"><p class="table">H</p></td>&#13;
<td class="table" style="vertical-align: top;"><p class="tablel">L</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table" style="vertical-align: top;"><p class="table">X</p></td>&#13;
<td class="table" style="vertical-align: top;"><p class="table">L</p></td>&#13;
<td class="table" style="vertical-align: top;"><p class="tablel">Z</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">According to the data sheet, in this function table, <em>H</em> stands for <em>high level, L</em> stands for <em>low level, X</em> means the level is irrelevant to the circuit behavior, and <em>Z</em> indicates high impedance, which turns the motor off.</p>&#13;
<p class="indent">The H-bridge is an elegant motor-control solution for several reasons. It allows you to reverse the polarity from a single supply, and it provides for different logic and control voltages. In addition, if both inputs of the dual H-bridge are either high or low, there will be no output. The sketch takes advantage of that in a function written to stop the motor. Other projects in this volume also use this capability.</p>&#13;
<h3 class="h3" id="ch02lev1sec8"><span epub:type="pagebreak" id="page_50"/><strong>The Breadboard</strong></h3>&#13;
<p class="noindent">For most Arduino projects, I suggest building the circuit on a breadboard first to make sure you’re going in the right direction and to prove your initial hypothesis. Use a standard breadboard and the plug-in wires that are sold as accessories for the breadboard (see <a href="ch02.xhtml#ch02fig8">Figure 2-8</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/f02-08.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig8"/><em>Figure 2-8: Typical small breadboard and plug-in wires</em></p>&#13;
<p class="indent">Before you begin building the circuit on the breadboard, look over your Arduino. Many Arduino boards come complete with the male headers already soldered in place. However, that’s not always the case; some Asian suppliers include the headers loose with the processor board. If your board lacks headers, see “<a href="ch00.xhtml#ch00lev1sec1">Preparing the Arduino Board</a>” on <a href="ch00.xhtml#page_2">page 2</a> for complete instructions on attaching them.</p>&#13;
<p class="indent">Most breadboards include a red and blue stripe on the entire length of each side of the board; the holes next to these stripes are used for power (+) and ground (−), respectively. Before you hook up the circuit, use a wire to connect the red column on the right to the red column on the left. Connect the blue columns to each other, too.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">WARNING</span></strong></p>&#13;
<p class="notep"><em>Do</em> not <em>connect the red column to the blue column! This will cause a short circuit and will burn out the electronics</em>.</p>&#13;
</div>&#13;
<p class="indent"><a href="ch02.xhtml#ch02fig9">Figure 2-9</a> shows my breadboard for this project, and the schematic from <a href="ch02.xhtml#ch02fig3">Figure 2-3</a> lays out the connections.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_51"/><img alt="image" src="../images/f02-09.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig9"/><em>Figure 2-9: This is the breadboard I used as a proof-of-concept to make sure everything worked as anticipated</em>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="bgblack">WARNING</span></strong></p>&#13;
<p class="notep"><em>Don’t plug the Arduino in to the computer while it is actually receiving power from the voltage regulator. This could burn out the Arduino</em>.</p>&#13;
</div>&#13;
<p class="indento1">I suggest prototyping your circuit as follows:</p>&#13;
<ol>&#13;
<li><p class="noindent">Insert the Nano board into the breadboard, leaving a couple of rows of holes at one end.</p></li>&#13;
<li><p class="noindent">Place a wire from the pin labeled <em>5V</em> on the Nano (pin 27) to the red positive rail on the breadboard.</p></li>&#13;
<li><p class="noindent">Place a wire from GND on the Nano (pin 29) to the blue negative rail on the breadboard.</p></li>&#13;
<li><p class="noindent">Find three consecutive holes on the board where they will not connect to anything and insert the three leads of the LM7805 into them.</p></li>&#13;
<li><p class="noindent">The input lead of the LM7805 will go to the 9V power supply, the ground of the LM7805 will go to the blue negative rail, and the output of the chip will go to the red positive rail. (See <a href="ch02.xhtml#ch02fig10">Figure 2-10</a> for the LM7805 pinout.)</p>&#13;
<div class="image"><img alt="image" src="../images/f02-10.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig10"/><em>Figure 2-10: Pinout of the LM7805 regulator</em></p>&#13;
</li>&#13;
<li><p class="noindent">Insert the H-bridge into the breadboard with the notch facing the Nano, and leave a couple of rows between the H-bridge and the Nano.</p></li>&#13;
<li><p class="noindent"><span epub:type="pagebreak" id="page_52"/>Use a wire to connect pin 1 and pin 16 of the H-bridge together (see <a href="ch02.xhtml#ch02fig7">Figure 2-7</a>). Then, use another wire to connect pin 1 to the positive connection on the breadboard. This connection from pins 1 and 16 provides the voltage to run the logic on the H-bridge and also to enable the section of the H-bridge used.</p></li>&#13;
<li><p class="noindent">Use a wire to connect pins 4 and 5 of the H-bridge, and then connect them to the negative terminal on the breadboard. Running a wire from either pin 4 or pin 5 to ground will do the trick.</p></li>&#13;
<li><p class="noindent">Similarly, connect pins 12 and 13 of the H-bridge together, and connect them to ground.</p></li>&#13;
<li><p class="noindent">Use a wire to connect one side of the motor (it doesn’t matter which) to pin 3 of the H-bridge, and connect pin 6 of the H-bridge to the other side of the motor.</p></li>&#13;
<li><p class="noindent">Connect digital pin D12 of the Nano to pin 2 of the H-bridge.</p></li>&#13;
<li><p class="noindent">Connect digital pin D13 of the Nano to pin 7 of the H-bridge.</p></li>&#13;
<li><p class="noindent">Connect one side of the 5.6-ohm resistor (R1) to pin 8 of the H-bridge.</p></li>&#13;
<li><p class="noindent">Connect the other side of resistor R1 to the red positive rail on the breadboard.</p></li>&#13;
<li><p class="noindent">Insert a wire from pin 8 of the H-bridge to analog pin A0 of the Nano.</p></li>&#13;
<li><p class="noindent">Insert a wire from the positive (red) connector to analog pin A1 of the Nano.</p></li>&#13;
<li><p class="noindent">Insert the positive side (long lead) of one LED to D12 of the Nano.</p></li>&#13;
<li><p class="noindent">Insert the negative side of the LED into an empty row on the breadboard.</p></li>&#13;
<li><p class="noindent">From that row with the negative side of the LED, connect a 300-ohm resistor (R2) to the blue negative rail.</p></li>&#13;
<li><p class="noindent">Insert the positive side (long lead) of the second LED to D13 of the Nano.</p></li>&#13;
<li><p class="noindent">Insert the negative side of the second LED into an empty row on the breadboard.</p></li>&#13;
<li><p class="noindent">From that row with the negative side of the second LED, connect a 330-ohm resistor (R3) to the blue negative rail.</p></li>&#13;
</ol>&#13;
<p class="indentt">The VCC2 supply drives the output to the motor. It goes from the positive side of the supply—the output pin of the regulator in the schematic—through resistor R1 to pin 8 of the H-bridge. VCC2 becomes the low-voltage side of resistor R1; it will have a lower voltage as the load on the motor increases because the other end of the resistor is attached to the positive of the power supply. The VCC2 supply voltage can be anywhere from the 5V that the logic uses to the 36V limit of the H-bridge. For this project, I simply tied the voltage-drop resistor directly to the 5V supply, which worked well with a 6V motor.</p>&#13;
<p class="indent">The Nano’s D12 and D13 output pins drive the A inputs of the H-bridge, while A0 and A1 inputs straddle the voltage-drop resistor, R1. <span epub:type="pagebreak" id="page_53"/>It’s this voltage-drop value that tells the Arduino to change the outputs to instruct the H-bridge to reverse the motor. When output D13 is high and D12 is low, output pin 2Y on the H-bridge becomes positive while 1Y remains negative. When D12 is high and D13 is low, the reverse happens, and 1Y becomes positive while 2Y stays negative. When both pins have high or low output, they are at the same potential (or voltage), and the motor is not driven. (Refer to the function table in the H-bridge chip’s data sheet, or see <a href="ch02.xhtml#ch02tab1">Table 2-1</a>.)</p>&#13;
<h3 class="h3" id="ch02lev1sec9"><strong>The Sketch</strong></h3>&#13;
<p class="noindent">The following sketch is written so that when the motor reaches its limits in one direction, both outputs go low, and when it reaches its limits in the other direction, both outputs go high. When both outputs are either high or low, there is no potential across the motor and it is stopped for a specified delay time. After the delay is satisfied, the motor starts in the other direction. Because LEDs are wired to pins D12 and D13, you’ll also get a visual indication. Both LEDs are illuminated when the motor pauses in one direction, and both LEDs are off whe the motor pauses in the other direction.</p>&#13;
<p class="programs">     /* Sketch for the Automatic Motor Reversal Project<br/>     */<br/>     <br/>     //Identify pins that will not change<br/>     const int ledPin1 = 12; //LED1 in schematic<br/>     const int ledPin2 = 13; //LED2 in schematic<br/>     const int analog0 = A0;<br/>     const int analog1 = A1;<br/>     int analogValue0 = 0; //Identify variables for analog inputs<br/>     int analogValue1 = 0;<br/>     int analogdifference = 0;<br/>     int threshold = 100; //The threshold value calculated to stop the motor<br/>     <br/>     int reading;<br/>     int state;<br/>     int previous = LOW;<br/>     int count = 0;<br/>     int numberstops = 250;<br/>     int time = 0; //The last time the motor reversed<br/><br/>     //Amount of time to wait to get rid of the jitters when the motor reverses<br/>     int debounce = 400;<br/><br/><span class="ent">➊</span>   void setup() { //This is the setup routine<br/>     //Initializes pins as input or output<br/>       pinMode(analog0, INPUT);<br/>       pinMode(analog1, INPUT);<br/>       pinMode(ledPin1, OUTPUT);<br/>       pinMode(ledPin2, OUTPUT);<br/><span epub:type="pagebreak" id="page_54"/>       Serial.begin(9600); //Was used in setting up the parameters<br/>     }<br/><br/><span class="ent">➋</span>   void loop() { //This begins the processing section<br/>         //Enter an endless do-nothing loop after the counter reaches the limit<br/>         while(count &gt; numberstops) {<br/>             digitalWrite(ledPin1, LOW);<br/>             digitalWrite(ledPin2, LOW);<br/>         }<br/><br/>     analogValue0 = (analogRead(analog0)); //Read the analog values<br/>     analogValue1 = (analogRead(analog1));<br/><br/><span class="ent">➌</span>   //Setting up the analog difference<br/>     analogdifference = analogValue1 - analogValue0; //This is the voltage drop<br/>     //analogValue1 will be greater than analogValue0<br/><br/>     //These were added to view what was happening on the serial monitor<br/>     Serial.print("count =      ");<br/>     Serial.println(count);<br/>     Serial.print("analogdifference =      ");<br/>     Serial.println(analogdifference);<br/>     Serial.println();<br/>     Serial.print("numberstops =      ");<br/>     Serial.println(numberstops);<br/><br/>     //This comparator looks at the difference or drop across the resistor<br/><span class="ent">➍</span>   if(analogdifference &gt; threshold) {<br/>        reading = HIGH;<br/>     }<br/>     else {<br/>        reading = LOW;<br/>     }<br/>     <br/><br/>     //Toggles the output and includes the debounce<br/><span class="ent">➎</span>   if(reading == HIGH &amp;&amp; previous == LOW &amp;&amp; millis() - time &gt; debounce) {<br/>        if(state == HIGH) {<br/>           state = LOW;<br/>        }<br/>        else {<br/>           state = HIGH;<br/>        }<br/>        //Increments the counter each time the motor reverses<br/><span class="ent">➏</span>   count++;<br/>        time = millis(); <br/>     }<br/><br/>     //Writes the state to the output pins that drive the H-Bridge<br/>     digitalWrite(ledPin1, state);<br/>     digitalWrite(ledPin2, !state);<span epub:type="pagebreak" id="page_55"/><br/>     previous = reading;<br/>  }</p>&#13;
<p class="indent">This sketch sets up human-understandable aliases for the pins the project uses and adds convenient constants and variables for referencing analog inputs and other key values. After the sketch defines and initializes the input and output pins at <span class="ent">➊</span>, it starts the main loop at <span class="ent">➋</span>.</p>&#13;
<p class="indent">Inside the main loop, the sketch finds the voltage drop across the resistor in terms of analog steps <span class="ent">➌</span>. At <span class="ent">➍</span>, the sketch determines whether the reading was high or low. Threshold values from 100 to 120 work reliably for the 6V, 20 RPM motor I used, but you may need to experiment to find the right value for your motor. See “<a href="ch02.xhtml#ch02lev1sec6">Determining the Reversal Threshold</a>” on <a href="ch02.xhtml#page_46">page 46</a> for more on how to estimate the threshold value. The reading at <span class="ent">➎</span> dictates whether to reverse the motor.</p>&#13;
<div class="box1">&#13;
<p class="boxtitle"><strong>THE DROPPING RESISTOR IS KEY TO SENSING CURRENT</strong></p>&#13;
<p class="noindent">I’ve tried this reversing circuit with several similar motors, and I’ve only ever needed to make a slight adjustment to the threshold value in the sketch. But for a motor with extremely high or low current drain, you may need to anticipate a much different value for analogdifference and/or use a different dropping resistor, which was R1 in the schematic. You might need to reduce the value of the dropping resistor to something like 2.2 ohms, which then requires a reduction in the value you compare analogdifference to.</p>&#13;
<p class="indent">For most small motors, the lower the value of the dropping resistor—which is usually between 1 and 10 ohms—the better, as the analog difference tends to be more stable. For other motors, experiment to find the resistor value that works best.</p>&#13;
</div>&#13;
<p class="indent">When the sketch checks <span class="literal">reading</span> to see whether the motor needs reversing, it also uses the <span class="literal">debounce</span> value to assure that a high reading wasn’t caused by electrical noise created by the motor’s commutator or brushes during a legitimate reversal. I set <span class="literal">debounce</span> to 400, but you may have to adjust that for different motors. For larger motors specifically, this may need to be set a little higher.</p>&#13;
<p class="indent">This sketch also includes a few functions that aren’t strictly necessary to reversing the motor but are helpful when using the motor as a PCB agitator. These aspects of the project may appeal to you in other applications, too, so let’s look at them in more detail.</p>&#13;
<p class="indent">One of the things that I added was a counter to track the number of times that the motor reversed. In the sketch, the count increment appears at <span class="ent">➏</span> as <span class="literal">count++</span>. In the project, when a certain value of <span class="literal">count</span> is reached, the <span epub:type="pagebreak" id="page_56"/>motor stops (if <span class="literal">count = numberstops</span>). If you wanted to set off an alarm, such as an audible noisemaker, to tell you it’s finished, that can easily be accomplished by adding a line to write to one of the digital outputs. I set a maximum <span class="literal">count</span> value in the sketch, using <span class="literal">numberstops = 250</span>, so the motor will reverse 250 times and then stop. That provides a little more than 15 minutes of etching time with the motor I’ve selected running at 5V, which should be enough to etch most circuit boards.</p>&#13;
<p class="indent">When the maximum count is reached, the sketch enters the <span class="literal">while</span> loop at the beginning, stopping the agitation. This basically stalls the processor, and you have to hit the power switch to restart, or reset, the agitator. The placement of this loop near the beginning of the software is just a reminder that it’s there.</p>&#13;
<p class="indent">The thinking behind the count, optional alarm, and stop capabilities is that a reminder to check on your board is helpful. If the board has completed etching, continued agitation would speed undercutting of the traces, which is not a good thing because it weakens (and can break!) small copper traces. On the other hand, if it fails to etch in a reasonable time, you might need to refresh the etchant.</p>&#13;
<div class="box1">&#13;
<p class="boxtitle"><strong>MOD: ADJUSTABLE STOP AMOUNT</strong></p>&#13;
<p class="noindent">If setting a fixed stop maximum in a sketch doesn’t leave you satisfied, try connecting a potentiometer between power and ground with the adjust pin, which is usually the center pin on the potentiometer, to the A2 input pin of the Arduino. Then, set numberstops equal to the value of A2, which should range from 0 to 1,023, depending on the position of the potentiometer wiper.</p>&#13;
<p class="indent">Here’s how the sketch would differ. First, change</p>&#13;
<p class="programs">int numberstops = 250;</p>&#13;
<p class="noindent">to</p>&#13;
<p class="programs">int numberstops = setNumber;</p>&#13;
<p class="indent">Then, add the following:</p>&#13;
<p class="programs">int setNumber;<br/>int analogPin2 = A2;<br/>int analogValue2;<br/>setNumber = analogRead(analogPin2);</p>&#13;
<p class="indent">Because the timing is relative, you could use a 270-degree rotation linear potentiometer and make some rough markings on the enclosure to indicate the number of counts.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch02lev1sec10"><span epub:type="pagebreak" id="page_57"/><strong>The Shield</strong></h3>&#13;
<p class="noindent">For this project, I recommend making a small PCB <em>shield</em>, which is basically a host board designed to plug into the Arduino Nano. With a shield, your motor reversal project can remain compact, and you can design and build it with a minimum of effort.</p>&#13;
<h4 class="h4" id="ch02lev2sec1"><strong><em>PCB Layout</em></strong></h4>&#13;
<p class="noindent">You could just solder the parts for your project directly to a piece of perforated project board, but I believe creating and populating the shield takes less time than putting the parts on a perforated board and wiring them by hand. You’ll also gain invaluable experience by preparing, etching, drilling, and assembling your own PCB. And in the end, some projects are complex enough that wiring by hand just won’t be an attractive option. (See <a href="ch05.xhtml#ch05fig13">Figure 5-13</a> on <a href="ch05.xhtml#page_148">page 148</a> for an example.)</p>&#13;
<p class="indent">To make my printed circuit layouts, I use a free software program called ExpressPCB. <a href="ch02.xhtml#ch02fig11">Figure 2-11</a> shows my layout of the PCB.</p>&#13;
<div class="image"><img alt="image" src="../images/f02-11.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig11"/><em>Figure 2-11: This is the actual PCB pattern I used in the project. The Arduino Nano can be soldered directly to the board or can plug in if you use header connectors</em>.</p>&#13;
<p class="indent">If you don’t want to lay out your own PCB but still want to make the board, download the <em>Reverse.pcb</em> file from <em><a href="https://www.nostarch.com/arduinoplayground/">https://www.nostarch.com/arduinoplayground/</a></em> and follow the directions in “<a href="ch00.xhtml#ch00lev1sec5">Making Your Own PCBs</a>” on <a href="ch00.xhtml#page_13">page 13</a>. When you’ve made your PCB, just solder all the components to it in the right places, and you’ll be done with the shield.</p>&#13;
<h4 class="h4" id="ch02lev2sec2"><span epub:type="pagebreak" id="page_58"/><strong><em>Shield Design Notes</em></strong></h4>&#13;
<p class="noindent">If you lay out your own shield, there are a few design factors you should definitely keep in mind.</p>&#13;
<h5 class="h5" id="ch02lev3sec1"><strong>Analog Inputs</strong></h5>&#13;
<p class="noindent">Be certain to connect the A1 and A0 inputs to the correct sides of resistor R1, according to the schematic in <a href="ch02.xhtml#ch02fig3">Figure 2-3</a>. A1 should attach to the power supply side and A0 to the H-bridge side. In the sketch, to compare the analog values, we take the difference as <span class="literal">analogdifference = analogValue1 – analogValue0</span>, with <span class="literal">analogValue1</span> as the input at the high end of the resistor. In this case, <span class="literal">analogValue0</span> is A0, and <span class="literal">analogValue1</span> is A1.</p>&#13;
<h5 class="h5" id="ch02lev3sec2"><strong>Grounding and Heat Sink</strong></h5>&#13;
<p class="noindent">Pins 4, 5, 12, and 13 are ground on the H-bridge, and they are also a heat sink to keep the chip from overheating. A small area on the proposed shield is included to increase the heat sink area. If you’re using a relatively small motor—such as the 6V, 20 mA unit—no more heat sinking is required. If you’re using a much larger motor or driving a heavy load, consider using the second side of the PCB as a heat sink.</p>&#13;
<h5 class="h5" id="ch02lev3sec3"><strong>The Voltage Regulator</strong></h5>&#13;
<p class="noindent">This project uses its own 5V regulator to supply power to the Nano. A 9V, 200 mA plug-in wall adapter is connected to the voltage regulator LM7805 on the shield, which reduces the voltage from about 9V to 5V. An external regulator is included so a more powerful regulator than the one built into the Nano can be used. Make sure to connect the pins of the regulator correctly (see <a href="ch02.xhtml#ch02fig10">Figure 2-10</a>).</p>&#13;
<p class="indent">You could feed a 7.5V DC or 9V DC wall supply directly to the VIN pin of the Nano and use the onboard regulator, which worked with my motor. But if you use a larger motor—or higher-current LEDs—it might tax the onboard regulator and could conceivably burn it out.</p>&#13;
<p class="indent">The higher the voltage of the power supply, the more work the regulator has to do to bring it down to 5V. Overtaxing the regulator could cause it to heat up and fail. For example, feeding the regulator 12V is probably at the high end for 5V regulation. A 9V input is better, and a 7.5V input is better yet. If the regulator chip gets warm, add a heat sink to the tab. A small piece of aluminum is often sufficient, but a regular heat sink can be used. And while it’s good to have the supply voltage as close to the output voltage as possible, remember that the regulator needs at least 1V above the regulated output to work, so it must be fed with at least 6V, which is a 5V-regulated output plus 1V. Input voltages above 12V are feasible, too, but just be sure not to exceed the limits of the device.</p>&#13;
<div class="box1">&#13;
<p class="boxtitle"><span epub:type="pagebreak" id="page_59"/><strong>MOD: USING A HIGHER VOLTAGE</strong></p>&#13;
<p class="noindent">If you use a higher-voltage motor for this project, it will turn faster, have more torque, and so on. But you <em>can’t</em> simply connect the higher voltage to the high end of the dropping resistor connected to pin 8 of the H-bridge. That would cause the voltage between both A0 and A1 and ground to exceed 5V, which is hazardous to the health of the ATmega328 microcontroller on the Arduino. (This is the only time that the voltage referenced to ground is important.) Thus, a modification is required. Look at R1 in the schematic in <a href="ch02.xhtml#ch02fig12">Figure 2-12</a>. The supply first goes to resistor R2; R2 joins with resistor R3, which goes to ground.</p>&#13;
<div class="image"><img alt="image" src="../images/f02-12.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig12"/><em>Figure 2-12: If you elect to use a higher voltage and drive a faster motor, you will have to modify the circuit by adding voltage dividers in front of both the A0 and A1 inputs</em>.</p>&#13;
<p class="indent">To avoid damage to the Nano processor, you will want to keep the voltage that appears at that joining point under 5V, referenced to ground. The easiest way to do this is to use a voltage divider. Two resistor pairs divide the higher voltage: the first pair is R2 and R3; the second is R4 and R5. The value of these resistors should be such that the output at the joining of each pair—R1 and R2, and R4 and R5—is somewhat less than 5V for whatever value of input voltage you use.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_60"/>Use this formula:</p>&#13;
<div class="imageo"><img alt="image" src="../images/e0060-01.jpg"/></div>&#13;
<p class="noindent">and the schematic in <a href="ch02.xhtml#ch02fig13">Figure 2-13</a> to determine the values of the resistors to use in a voltage-divider circuit.</p>&#13;
<p class="indent">For example, if you start with 9V and arbitrarily select a 10-kilohm resistor in series, you would have to shunt it with a 12.5-kilohm resistor to ground, according to the calculator. The closest resistor I had was 12 kilohm, and it worked fine. If you can’t find a standard resistor to fit your needs, you can also combine two standard values in parallel to achieve the value you want with this formula:</p>&#13;
<div class="imageo"><img alt="image" src="../images/e0060-02.jpg"/></div>&#13;
<div class="image"><img alt="image" src="../images/f02-13.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig13"/><em>Figure 2-13: A basic voltage divider. To find the resistors you should use, plug the values from your own divider into the formula as if your divider were this circuit</em>.</p>&#13;
<p class="indent">If you don’t want to do the algebra yourself, you could use one of the convenient online voltage-divider calculators such as <em><a href="http://www.sengpielaudio.com/calculator-paralresist.htm">http://www.sengpielaudio.com/calculator-paralresist.htm</a></em> or <em><a href="http://www.raltron.com/cust/tools/voltage_divider.asp">http://www.raltron.com/cust/tools/voltage_divider.asp</a></em>. SparkFun also has an excellent tutorial on voltage dividing, with a calculator of its own: <em><a href="http://learn.sparkfun.com/tutorials/voltage-dividers/">http://learn.sparkfun.com/tutorials/voltage-dividers/</a></em>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch02lev3sec4"><strong>Directional LEDs</strong></h5>&#13;
<p class="noindent">Of course, what Arduino project would be complete without blinking LEDs? As you’ll see in the schematic and on the shield PCB, I included two LEDs: a red one for clockwise rotation and a green one for counterclockwise rotation. But which direction belongs to which LED is your choice: simply reverse the motor leads to change the LED status.</p>&#13;
<h3 class="h3" id="ch02lev1sec11"><strong>Construction</strong></h3>&#13;
<p class="noindent">For this project, you’ll use the motor-reverse technique to create an agitator that accelerates the etching of PCBs. To do this, you’ll suspend a PCB from an Arduino-driven motor over etching solution, as shown in <a href="ch02.xhtml#ch02fig1">Figure 2-1</a>. A small enclosure will contain the Arduino Nano, the shield, the motor with limit wires, direction LEDs, a power switch, and the power jack.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_61"/>After assembling the box, you just have to mount it somewhere above your etching setup and attach the reverser, either directly to the PCB or to a tray. I clamped my box to a cabinet door above my workspace, with a place for the etching vessel below (see <a href="ch02.xhtml#ch02fig14">Figure 2-14</a>). The entire system can be assembled and disassembled quickly.</p>&#13;
<div class="image"><img alt="image" src="../images/f02-14.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig14"/><em>Figure 2-14: For larger PCBs, try etching in a tray for a more conventional approach. Just attach the motor reverser to your tray to agitate the board rather than using the reverser to dip the board in and out of the solution</em>.</p>&#13;
<p class="indent">Construction of the rest of this project takes a little bit of patience and perhaps some ingenuity in scavenging some of the parts required. You will need a couple of M3 screws to mount the motor to the motor plate—in this case, a small aluminum L bracket—and some limit wires, preferably made of 0.039 piano or spring wire. You’ll also need a small block of scrap brass or aluminum—round or rectangular, doesn’t matter—to attach to the motor shaft and crank, a long 4-40 or 6-32 screw to act as the crank, and an M3 spacer and solder lug to attach the agitator line to the crank. <a href="ch02.xhtml#ch02fig15">Figure 2-15</a> shows the nearly-finished, unmounted product.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_62"/><img alt="image" src="../images/f02-15.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig15"/><em>Figure 2-15: Wire up your components and lay them out for a final test before you put them in an enclosure. For the test, I held the motor in a clamp so the crank was free to move. The regulator heat sink obscures much of the shield</em>.</p>&#13;
<h4 class="h4" id="ch02lev2sec3"><strong><em>The Limit Wires</em></strong></h4>&#13;
<p class="noindent">The limit wires will create resistance to the motor’s rotation by essentially bumping into the motor crank. The point in the rotation where they strike the crank is the limit of rotation. When the crank runs up against the limit wire, the wires prevent the motor from turning and initiate the reversal.</p>&#13;
<p class="indent">I recommend piano or spring wire to provide a little spring as the crank hits it at the extent of rotation. Use a pair of needle-nose pliers to bend two pieces of the limit wire into shape (see <a href="ch02.xhtml#ch02fig16">Figure 2-16</a>). These wires will fit on the motor mount screws outside of the motor mounting bracket. You can change the limit of rotation by loosening the screw and rotating the wire.</p>&#13;
<div class="image"><img alt="image" src="../images/f02-16.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig16"/><em>Figure 2-16: This is how the limit pins are formed. A good pair of needle-nose pliers does the trick</em>.</p>&#13;
<h4 class="h4" id="ch02lev2sec4"><span epub:type="pagebreak" id="page_63"/><strong><em>The Crank Bushing</em></strong></h4>&#13;
<p class="noindent">The crank bushing is simply what transfers the rotation of the motor to the crank. <a href="ch02.xhtml#ch02fig17">Figure 2-17</a> details the construction of the bushing, the spacer, and the solder lug.</p>&#13;
<div class="image"><img alt="image" src="../images/f02-17.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig17"/><em>Figure 2-17: The detail of the drive mechanism that transfers the rotation of the motor to the lifting motion of the agitator</em></p>&#13;
<p class="indent">While there can be a number of different variations in your approach to assembling this part of the project, here’s the sequence I used to put it together:</p>&#13;
<ol>&#13;
<li><p class="noindent">Drill a hole for the motor shaft through the center of the bushing, which can be a small piece of brass or aluminum round stock about 0.5 inches in diameter and 0.75 inches long. A rectangular piece will work just as well. Use a drill that is as close to the size of the motor shaft as possible. For example, if your motor shaft is 0.157 inches in diameter like the one I used, then a 11/64-inch drill bit is close enough. It isn’t important to get the hole exactly on center—just close.</p></li>&#13;
<li><p class="noindent">In the bushing, perpendicular to the motor shaft hole, use a #36 drill to drill a hole. Then, tap the hole you drilled so a long 6-32 screw can serve double duty as a setscrew and crank. You can also use a separate setscrew to move the crank farther from the motor, as I did in <a href="ch02.xhtml#ch02fig18">Figure 2-18</a>.</p></li>&#13;
<li><p class="noindent">Thread the crank screw into the bushing so it bears tightly against the motor shaft, and use a locking nut to hold the screw in place (see <a href="ch02.xhtml#ch02fig18">Figure 2-18</a>).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_64"/><img alt="image" src="../images/f02-18.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig18"/><em>Figure 2-18: A photograph detailing the head of the crank. Note the solder lug used to hold the wire and the alligator stop clip on the left side</em>.</p>&#13;
</li>&#13;
<li><p class="noindent">At the end of the crank, you are ultimately going to attach the line that will pull the PCB in and out of the etchant. This fitting can be just a nut, or even an alligator clip, attached to the crank. However, in the detail, I used an M3 hex female-female spacer that was 7 mm long. I drilled clean through the spacer to one side, starting on one of the flat surfaces with the same #36 drill. I then tapped the hole with the 6-32 tap and threaded it onto the crank.</p></li>&#13;
<li><p class="noindent">Take an M3×0.5 mm machine screw and put it through the solder lug (see <a href="ch02.xhtml#ch02fig19">Figure 2-19</a> for the lug itself and <a href="ch02.xhtml#ch02fig18">Figure 2-18</a> for the lug in place). Screw it into the standoff all the way so it binds on the crank screw.</p>&#13;
<div class="image"><img alt="image" src="../images/f02-19.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig19"/><em>Figure 2-19: The solder lug used to hold the wire that holds the etching board. If you can’t purchase something similar, you can easily make one with a piece of scrap metal or plastic</em>.</p>&#13;
</li>&#13;
</ol>&#13;
<p class="indent">My local Ace Hardware store had all of the accessories I needed, with the exception of the M3 spacer, which I got from eBay. You should be able to find the same items at Home Depot or Lowe’s.</p>&#13;
<h4 class="h4" id="ch02lev2sec5"><strong><em>Packaging</em></strong></h4>&#13;
<p class="noindent">The shield and Nano fit in a standard plastic enclosure (see <a href="ch02.xhtml#ch02fig20">Figure 2-20</a>). Drill holes in the enclosure for the 3.5 mm power jack, the SPST switch that serves as a power switch and reset, the indicator LEDs, and the motor wires.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_65"/><img alt="image" src="../images/f02-20.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig20"/><em>Figure 2-20: Completed enclosure with motor, limit wires, direction LEDs, power switch (reset), and power jack. The LEDs light up, with one for each direction. When the motor pauses in one direction, both LEDs turn on; when it pauses in the other direction, both LEDs turn off</em>.</p>&#13;
<p class="indent">Most 3.5 mm jacks use approximately a 1/4-inch hole, which is the same sized hole as the switch. If you want a tight fit, 15/64 inches is closer. Whether you use a 5 mm or 10 mm LED will dictate the size of the holes required for those. It’s been my experience that different brands tend to have slightly different diameters, so you might want to try a smaller drill first and test whether the LED fits. The arbitrary English-sized drill bits for the 5 mm and 10 mm LEDs are 3/8 inches and 3/16 inches, respectively. If you have a set of tapered reamers, you can start with a smaller hole and ream it out to make a tight fit for the LEDs.</p>&#13;
<p class="indent">Mount the motor on a small piece of aluminum angle, readily available at most hardware stores. I purchased a 1-inch section of 1.5×1.5–inch aluminum angle and cut it down to size with a hacksaw. If you’re using the motor I use, you can copy the template in <a href="ch02.xhtml#ch02fig21">Figure 2-21</a> or download and print it from <em><a href="https://www.nostarch.com/arduinoplayground/">https://www.nostarch.com/arduinoplayground/</a></em>, cut it out, tape it to the aluminum angle <span epub:type="pagebreak" id="page_66"/>bracket, and carefully mark the hole positions on the bracket with a center punch or nail. Now, drill the holes—1/8 inches for the motor mount and 5/16 inches for the center hole. If you use a different motor, you will have to measure and mark out the mounting holes.</p>&#13;
<div class="image"><img alt="image" src="../images/f02-21.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig21"/><em>Figure 2-21: Template for the motor mount</em></p>&#13;
<p class="indent">Just use some double-sided foam tape to secure the shield to the enclosure if you think you’ll want to use it in another project. Otherwise, attach it to the inside with standoffs and screws in any size you like.</p>&#13;
<h3 class="h3" id="ch02lev1sec12"><strong>The Etching Process</strong></h3>&#13;
<p class="noindent">There are a number of techniques for making PCBs. The most common is a subtractive approach, which involves starting with a copper clad board, or a copper foil bonded to an electrically insulating substrate, from which the copper is selectively removed to leave a pattern on the board. While the copper can be mechanically milled off, the most common approach is to selectively etch the pattern on the board chemically.</p>&#13;
<p class="indent">In the chemical etching process, the circuit pattern is printed on the blank board with a chemical resist so that the copper is removed by the etchant in the areas not treated with the resist. The etchant is a chemically active material that attacks the untreated copper on the clad board, leaving you with only the copper you need for your circuit. I describe how to etch circuits step-by-step in “<a href="ch00.xhtml#ch00lev1sec5">Making Your Own PCBs</a>” on <a href="ch00.xhtml#page_13">page 13</a>, and this project makes that process easier.</p>&#13;
<p class="indent">Our goal is to suspend an unetched circuit board over the etchant in the vessel and keep it in the etchant for the maximum time as the agitator goes up and down, resulting in a laminar flow of etchant across the surface of the circuit board. I suggest using a nylon cable tie to hold the circuit board during the etching process, as nylon is relatively impervious to the etchant. You could attach the tie, in turn, to the motor shaft with an alligator clip so the board is easy to remove (see <a href="ch02.xhtml#ch02fig22">Figure 2-22</a>).</p>&#13;
<p class="indent">I used a 250 mL beaker as an etching vessel. For very small boards, this works extremely well. For larger boards, I recommend a large measuring cup, such as a 2 qt Pyrex cup. A 600 mL beaker works for intermediatesized boards. For even larger boards, you can use a tray, as illustrated in <a href="ch02.xhtml#ch02fig14">Figure 2-14</a>.</p>&#13;
<p class="indent">The switch and power input are located on the left-hand side of the enclosure. To hold the board being etched, I suspended a wire through the solder lug and attached that wire to the board with a small alligator clip. On the back of the lug, you can either tie a small knot in the wire or attach a clip of some sort to make sure the wire doesn’t fall through the lug and into the acid. In my setup, a clamp (behind the motor in the photo) holds the enclosure to an overhanging door.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_67"/><img alt="image" src="../images/f02-22.jpg"/></div>&#13;
<p class="figcap"><a id="ch02fig22"/><em>Figure 2-22: This Arduino-based etcher-agitator etches a board. The etchant should turn emerald as the copper is etched. The board is held by a wire tie that is attached to a wire by an alligator clip. The wire goes through a hole on the crank and is held in place with another alligator clip. One of the LEDs is lit</em>.</p>&#13;
<p class="indent">Note that the etching vessel is sitting on a hot plate. Though etching will occur at room temperature, it’s accelerated somewhat by heating. Be careful not to get the etchant too hot: if you set the hot plate on low to keep the liquid at about 100 to 120°F, it will speed etching without softening the resist.<span epub:type="pagebreak" id="page_68"/></p>&#13;
</body></html>