<html><head></head><body>
<h2 class="h2" id="ch18"><span epub:type="pagebreak" id="page_351"/><strong><span class="big">18</span><br/>APPROACHES TO ANALYZING HIDDEN FILESYSTEMS</strong></h2>
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>
<p class="noindent">So far in this book, you’ve learned how bootkits penetrate and persist on the victim’s computer by using sophisticated techniques to avoid detection. One common characteristic of these advanced threats is the use of a custom hidden storage system for storing modules and configuration information on the compromised machine.</p>
<p class="indent">Many of the hidden filesystems in malware are custom or altered versions of standard filesystems, meaning that performing forensic analysis on a computer compromised with a rootkit or bootkit often requires a custom toolset. In order to develop these tools, researchers must learn the layout of the hidden filesystem and the algorithms used to encrypt data by performing in-depth analyses and reverse engineering.</p>
<p class="indent">In this chapter, we’ll look more closely at hidden filesystems and methods to analyze them. We’ll share our experiences of performing long-term forensic analyses of the rootkits and bootkits described in this <span epub:type="pagebreak" id="page_352"/>book. We’ll also discuss approaches to retrieving data from hidden storage and share solutions to common problems that arise through this kind of analysis. Finally, we’ll introduce the custom HiddenFsReader tool we developed, whose purpose is to dump the contents of the hidden filesystems in specific malware.</p>
<h3 class="h3" id="ch18lev1sec1"><strong>Overview of Hidden Filesystems</strong></h3>
<p class="noindent"><a href="ch18.xhtml#ch18fig01">Figure 18-1</a> illustrates an overview of the typical hidden filesystem. We can see the malicious payload that communicates with the hidden storage injected into the user-mode address space of a victim process. The payload often uses the hidden storage to read and update its configuration information or to store data like stolen credentials.</p>
<div class="image"><a id="ch18fig01"/><img src="../images/18fig01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 18-1: Typical malicious hidden filesystem implementation</em></p>
<p class="indent">The hidden storage service is provided through the kernel-mode module, and the interface exposed by the malware is visible only to the payload module. This interface usually isn’t available to other software on the system and cannot be accessed via standard methods such as Windows File Explorer.</p>
<p class="indent">Data stored by the malware on the hidden filesystem persists in an area of the hard drive that isn’t being used by the OS in order not to conflict with it. In most cases, this area is at the end of the hard drive, because there is usually some unallocated space. However, in some cases, such as the Rovnix bootkit discussed in <a href="ch11.xhtml#ch11">Chapter 11</a>, malware can store its hidden filesystem in unallocated space at the beginning of the hard drive.</p>
<p class="indent">The main goal of any researcher performing forensic analysis is to retrieve this hidden stored data, so next we’ll discuss a few approaches for doing so.</p>
<h3 class="h3" id="ch18lev1sec2"><span epub:type="pagebreak" id="page_353"/><strong>Retrieving Bootkit Data from a Hidden Filesystem</strong></h3>
<p class="noindent">We can obtain forensic information from a bootkit-infected computer by retrieving the data when the infected system is offline or by reading the malicious data from a live infected system.</p>
<p class="indent">Each approach has its pros and cons, which we’ll consider as we discuss the two methods.</p>
<h4 class="h4" id="ch18lev2sec1"><strong><em>Retrieving Data from an Offline System</em></strong></h4>
<p class="noindent">Let’s start with getting data from the hard drive when the system is offline (that is, the malware is inactive). We can achieve this through an offline analysis of the hard drive, but another option is to boot the noninfected instance of the operating system using a live CD. This ensures the computer uses the noncompromised bootloader installed on the live CD, so the bootkit won’t be executed. This approach assumes that a bootkit has not been able to execute before the legitimate bootloader and cannot detect an attempt to boot from an external device to wipe the sensitive data beforehand.</p>
<p class="indent">The significant advantage of this method over an online analysis is that you don’t need to defeat the malware’s self-defense mechanisms that protect the hidden storage contents. As we’ll see in later sections, bypassing the malware’s protection isn’t a trivial task and requires certain expertise.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Once you get access to the data stored on the hard drive, you can proceed with dumping the image of the malicious hidden filesystem and decrypting and parsing it. Different types of malware require different approaches for decrypting and parsing the hidden filesystems, as we’ll discuss in the section “<a href="ch18.xhtml#ch18lev1sec3">Parsing the Hidden Filesystem Image</a>” on <a href="ch18.xhtml#page_360">page 360</a>.</em></p>
</div>
<p class="indent">However, the downside of this method is that it requires both physical access to the compromised computer and the technical know-how to boot the computer from a live CD and dump the hidden filesystem. Meeting both of these requirements might be problematic.</p>
<p class="indent">If analyzing on an inactive machine isn’t possible, we have to use the active approach.</p>
<h4 class="h4" id="ch18lev2sec2"><strong><em>Reading Data on a Live System</em></strong></h4>
<p class="noindent">On a live system with an active instance of the bootkit, we need to dump the contents of the malicious hidden filesystem.</p>
<p class="indent">Reading the malicious hidden storage on a system actively running malware, however, has one major difficulty: the malware may attempt to counteract the read attempts and forge the data being read from the hard drive to impede forensic analysis. Most of the rootkits we’ve discussed in this book—TDL3, TDL4, Rovnix, Olmasco, and so on—monitor access to the hard drive and block access to the regions with the malicious data.</p>
<p class="indent">To be able to read malicious data from the hard drive, you have to overcome the malware’s self-defense mechanisms. We’ll look at some approaches <span epub:type="pagebreak" id="page_354"/>to this in a moment, but first we’ll examine the storage device driver stack in Windows, and how the malware hooks into it, to better understand how the malware protects the malicous data. This information is also useful for understanding certain approaches to removing malicious hooks.</p>
<h4 class="h4" id="ch18lev2sec3"><strong><em>Hooking the Miniport Storage Driver</em></strong></h4>
<p class="noindent">We touched upon the architecture of the storage device driver stack in Microsoft Windows and how malware hooks into it in <a href="ch01.xhtml#ch01">Chapter 1</a>. This method outlived the TDL3 and was adopted by later malware, including bootkits we’ve studied in this book. Here we’ll go into more detail.</p>
<p class="indent">TDL3 hooked the miniport storage driver located at the very bottom of the storage device driver stack, as indicated in <a href="ch18.xhtml#ch18fig02">Figure 18-2</a>.</p>
<div class="image"><a id="ch18fig02"/><img src="../images/18fig02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 18-2: Device storage driver stack</em></p>
<p class="indent">Hooking into the driver stack at this level allows the malware to monitor and modify I/O requests going to and from the hard drive, giving it access to its hidden storage.</p>
<p class="indent">Hooking at the very bottom of the driver stack and directly communicating with the hardware also allows the malware to bypass the security software that operates at the level of the filesystem or disk class driver. As we touched upon in <a href="ch01.xhtml#ch01">Chapter 1</a>, when an I/O operation is performed on the hard drive, the OS generates an input/output request packet (IRP)—a special data structure in the operating system kernel that describes I/O operation—which is passed through the whole device stack from top to the bottom.</p>
<p class="indent"><span epub:type="pagebreak" id="page_355"/>Security software modules responsible for monitoring hard drive I/O operations can inspect and modify IRP packets, but because the malicious hooks are installed at the level below security software, they’re invisible to these security tools.</p>
<p class="indent">There are several other levels a bootkit might hook, such as the user-mode API, filesystem driver, and disk class driver, but none of them allow the malware to be as stealthy and powerful as the miniport storage level.</p>
<h5 class="h5" id="ch18lev3sec1"><strong>The Storage Device Stack Layout</strong></h5>
<p class="noindent">We won’t cover all possible miniport storage hooking methods in this section. Instead, we’ll focus on the most common approaches that we’ve come across in the course of our malware analyses.</p>
<p class="indent">First, we’ll take a closer look at the storage device, shown in <a href="ch18.xhtml#ch18fig03">Figure 18-3</a>.</p>
<div class="image"><a id="ch18fig03"/><img src="../images/18fig03.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 18-3: Miniport storage device organization</em></p>
<p class="indent">The IRP goes from the top of the stack to the bottom. Each device in the stack can either process and complete the I/O request or forward it to the device one level below.</p>
<p class="indent">The <code>DEVICE_OBJECT</code> <span class="ent">➊</span> is a system data structure used by the operating system to describe a device in the stack, and it contains a pointer <span class="ent">➋</span> to the corresponding <code>DRIVER_OBJECT</code>, another system data structure that describes a loaded driver in the system. In this case, the <code>DEVICE_OBJECT</code> contains a pointer to the miniport storage driver.</p>
<p class="indent">The layout of the <code>DRIVER_OBJECT</code> structure is shown in <a href="ch18.xhtml#ch18list01">Listing 18-1</a>.</p>
<pre>typedef struct _DRIVER_OBJECT {<br/>
   SHORT Type;<br/>
   SHORT Size;<br/>
<span class="ent">➊</span> PDEVICE_OBJECT DeviceObject;<br/>
   ULONG Flags;<br/>
<span class="ent">➋</span> PVOID DriverStart;<br/>
<span class="ent">➌</span> ULONG DriverSize;<br/>
   PVOID DriverSection;<br/>
   PDRIVER_EXTENSION DriverExtension;<br/>
<span class="ent">➍</span> UNICODE_STRING DriverName;<br/>
   PUNICODE_STRING HardwareDatabase;<br/>
   PFAST_IO_DISPATCH FastIoDispatch;<br/>
<span class="ent">➎</span> LONG * DriverInit;<br/>
   PVOID DriverStartIo;<br/>
   PVOID DriverUnload;<br/>
<span epub:type="pagebreak" id="page_356"/><span class="ent">➏</span> LONG * MajorFunction[28];<br/>
} DRIVER_OBJECT, *PDRIVER_OBJECT;</pre>
<p class="listing" id="ch18list01"><em>Listing 18-1: The layout of the <code>DRIVER_OBJECT</code> structure</em></p>
<p class="indent">The <code>DriverName</code> field <span class="ent">➍</span> contains the name of the driver described by the structure; <code>DriverStart</code> <span class="ent">➋</span> and <code>DriverSize</code> <span class="ent">➌</span>, respectively, contain the starting address and size in the driver memory; <code>DriverInit</code> <span class="ent">➎</span> contains a pointer to the driver’s initialization routine; and <code>DeviceObject</code> <span class="ent">➊</span> contains a pointer to the list of <code>DEVICE_OBJECT</code> structures related to the driver. From the malware’s point of view, the most important field is <code>MajorFunction</code> <span class="ent">➏</span>, which is located at the end of the structure and contains the addresses of the handlers implemented in the driver for various I/O operations.</p>
<p class="indent">When an I/O packet arrives at a device object, the operating system checks the <code>DriverObject</code> field in the corresponding <code>DEVICE_OBJECT</code> structure to get the address of <code>DRIVER_OBJECT</code> in memory. Once the kernel has the <code>DRIVER_OBJECT</code> structure, it fetches the address of a corresponding I/O handler from the <code>MajorFunction</code> array relevant to the type of I/O operation. With this information, we can identify parts of the storage device stack that can be hooked by the malware. Let’s look at a couple of different methods.</p>
<h5 class="h5" id="ch18lev3sec2"><strong>Direct Patching of the Miniport Storage Driver Image</strong></h5>
<p class="noindent">One way to hook the miniport storage driver is to directly modify the driver’s image in memory. Once the malware obtains the address of the hard disk miniport device object, it looks at the <code>DriverObject</code> to locate the corresponding <code>DRIVER_OBJECT</code> structure. The malware then fetches the address of the hard disk I/O handler from the <code>MajorFunction</code> array and patches the code at that address, as shown in <a href="ch18.xhtml#ch18fig04">Figure 18-4</a> (the sections in gray are those modified by the malware).</p>
<div class="image"><a id="ch18fig04"/><img src="../images/18fig04.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 18-4: Hooking the storage driver stack by patching the miniport driver</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_357"/>When the device object receives an I/O request, the malware is executed. The malicious hook can now reject I/O operations to block access to the protected area of the hard drive, or it can modify I/O requests to return forged data and fool the security software.</p>
<p class="indent">For example, this type of hook is used by the Gapz bootkit discussed in <a href="ch12.xhtml#ch12">Chapter 12</a>. In the case of Gapz, the malware hooks two routines on the hard disk miniport driver that are responsible for handling the <code>IRP_MJ_INTERNAL_DEVICE_CONTROL</code> and <code>IRP_MJ_DEVICE_CONTROL</code> I/O requests to protect them from being read or overwritten.</p>
<p class="indent">However, this approach is not particularly stealthy. Security software can detect and remove the hooks by locating an image of the hooked driver on a filesystem and mapping it into memory. It then compares the code sections of the driver loaded into the kernel to a version of the driver manually loaded from the file, and it notes any differences in the code sections that could indicate the presence of malicious hooks in the driver.</p>
<p class="indent">The security software can then remove the malicious hooks and restore the original code by overwriting the modified code with the code taken from the file. This method assumes that the driver on the filesystem is genuine and not modified by the malware.</p>
<h5 class="h5" id="ch18lev3sec3"><strong>DRIVER_OBJECT Modification</strong></h5>
<p class="noindent">The hard drive miniport driver can also be hooked through the modification of the <code>DRIVER_OBJECT</code> structure. As mentioned, this data structure contains the location of the driver image in memory and the address of the driver’s dispatch routines in the <code>MajorFunction</code> array.</p>
<p class="indent">Therefore, modifying the <code>MajorFunction</code> array allows the malware to install its hooks without touching the driver image in memory. For instance, instead of patching the code directly in the image as in the previous method, the malware could replace entries in the <code>MajorFunction</code> array related to <code>IRP_MJ_INTERNAL_DEVICE_CONTROL</code> and <code>IRP_MJ_DEVICE_CONTROL</code> I/O requests with the addresses of the malicious hooks. As a result, the operating system kernel would be redirected to the malicious code whenever it tried to resolve the addresses of handlers in the <code>DRIVER_OBJECT</code> structure. This approach is demonstrated in <a href="ch18.xhtml#ch18fig05">Figure 18-5</a>.</p>
<p class="indent">Because the driver’s image in memory remains unmodified, this approach is stealthier than the previous method, but it isn’t invulnerable to discovery. Security software can still detect the presence of the hooks by locating the driver image in memory and checking the addresses of the <code>IRP_MJ_INTERNAL_DEVICE_CONTROL</code> and <code>IRP_MJ_DEVICE_CONTROL</code> I/O requests handlers: if these addresses don’t belong to the address range of the miniport driver image in memory, it indicates that there are hooks in the device stack.</p>
<div class="image"><span epub:type="pagebreak" id="page_358"/><a id="ch18fig05"/><img src="../images/18fig05.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 18-5: Hooking the storage driver stack by patching the miniport <code>DRIVER_OBJECT</code></em></p>
<p class="indent">On the other hand, removing these hooks and restoring the original values of the <code>MajorFunction</code> array is much more difficult than with the previous method. With this approach, the <code>MajorFunction</code> array is initialized by the driver itself during execution of its initialization routine, which receives a pointer to the partially initialized corresponding <code>DRIVER_OBJECT</code> structure as an input parameter and completes the initialization by filling the <code>MajorFunction</code> array with pointers to the dispatch handlers.</p>
<p class="indent">Only the miniport driver is aware of the handler addresses. The security software has no knowledge of them, making it much more difficult to restore the original addresses in the <code>DRIVER_OBJECT</code> structure.</p>
<p class="indent">One approach that the security software may use to restore the original data is to load the miniport driver image in an emulated environment, create a <code>DRIVER_OBJECT</code> structure, and execute the driver’s entry point (the initialization routine) with the <code>DRIVER_OBJECT</code> structure passed as a parameter. Upon exiting the initialization routine, the <code>DRIVER_OBJECT</code> should contain the valid <code>MajorFunction</code> handlers, and the security software can use this information to calculate the addresses of the I/O dispatch routines in the driver’s image and restore the modified <code>DRIVER_OBJECT</code> structure.</p>
<p class="indent">Emulation of the driver can be tricky, however. If a driver’s initialization routine implements simple functionality (for example, initializing the <code>DRIVER_OBJECT</code> structure with the valid handler addresses), this approach would work, but if it implements complex functionality (such as calling system services or a system API, which are harder to emulate), emulation may fail and terminate before the driver initializes the data structure. In such cases, the security software won’t be able to recover the addresses of the original handlers and remove the malicious hooks.</p>
<p class="indent">Another approach to this problem is to generate a database of the original handler addresses and use it to recover them. However, this solution <span epub:type="pagebreak" id="page_359"/>lacks generality. It may work well for the most frequently used miniport drivers but fail for rare or custom drivers that were not included in the database.</p>
<h5 class="h5" id="ch18lev3sec4"><strong>DEVICE_OBJECT Modification</strong></h5>
<p class="noindent">The last approach for hooking the miniport driver that we’ll consider in this chapter is a logical continuation of the previous method. We know that to execute the I/O request handler in the miniport driver, the OS kernel must fetch the address of the <code>DRIVER_OBJECT</code> structure from the miniport <code>DEVICE_OBJECT</code>, then fetch the handler address from the <code>MajorFunction</code> array, and finally execute the handler.</p>
<p class="indent">So, another way of installing the hook is to modify the <code>DriverObject</code> field in the related <code>DEVICE_OBJECT</code>. The malware needs to create a rogue <code>DRIVER_OBJECT</code> structure and initialize its <code>MajorFunction</code> array with the address of the malicious hooks, after which the operating system kernel will use the malicious <code>DRIVER_OBJECT</code> structure to get the address of the I/O request handler and execute the malicious hook (<a href="ch18.xhtml#ch18fig06">Figure 18-6</a>).</p>
<div class="image"><a id="ch18fig06"/><img src="../images/18fig06.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 18-6: Hooking the storage driver stack by hijacking miniport <code>DRIVER_OBJECT</code></em></p>
<p class="indent">This approach is used by TDL3/TDL4, Rovnix, and Olmasco, and it has similar advantages and drawbacks as the previous approach. However, its hooks are even harder to remove because the whole <code>DRIVER_OBJECT</code> is different, meaning security software would need to make extra efforts to locate the original <code>DRIVER_OBJECT</code> structure.</p>
<p class="indent">This concludes our discussion of device driver stack hooking techniques. As we’ve seen, there’s no simple generic solution for removing the malicious hooks in order to read the malicious data from the protected areas of an infected machine’s hard drive. Another reason for the difficulty is that there are many different implementations of miniport storage drivers, and since they communicate directly with the hardware, each storage device vendor provides custom drivers for its hardware, so approaches that work for a certain class of miniport drivers will fail for others.</p>
<h3 class="h3" id="ch18lev1sec3"><span epub:type="pagebreak" id="page_360"/><strong>Parsing the Hidden Filesystem Image</strong></h3>
<p class="noindent">Once the rootkit’s self-defense protection is deactivated, we can read data from the malicious hidden storage, which yields the image of the malicious filesystem. The next logical step in forensic analysis is to parse the hidden filesystem and extract meaningful information.</p>
<p class="indent">To be able to parse a dumped filesystem, we need to know which type of malware it corresponds to. Each threat has its own implementation of the hidden storage, and the only way to reconstruct its layout is to engineer the malware to understand the code responsible for maintaining it. In some cases, the layout of the hidden storage can change from one version to another within the same malware family.</p>
<p class="indent">The malware may also encrypt or obfuscate its hidden storage to make it harder to perform forensic analysis, in which case we’d need to find the encryption keys.</p>
<p class="indent"><a href="ch18.xhtml#ch18tab01">Table 18-1</a> provides a summary of hidden filesystems related to the malware families we’ve discussed in previous chapters. In this table, we consider only the basic characteristics of the hidden filesystem, such as layout type, encryption used, and whether it implements compression.</p>
<p class="tabcap" id="ch18tab01"><strong>Table 18-1:</strong> Comparison of Hidden Filesystem Implementations</p>
<table class="topbot-d">
<colgroup>
<col style="width:20%"/>
<col style="width:20%"/>
<col style="width:20%"/>
<col style="width:20%"/>
<col style="width:20%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Functionality/malware</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>TDL4</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Rovnix</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Olmasco</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Gapz</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">Filesystem type</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Custom</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">FAT16</p>
<p class="taba">modification</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Custom</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Custom</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba">Encryption</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">XOR/RC4</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Custom (XOR+ROL)</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">RC6</p>
<p class="taba">modification</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">RC4</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba">Compression</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">No</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">Yes</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">No</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">Yes</p></td>
</tr>
</tbody>
</table>
<p class="indent">As we can see, each implementation is different, creating difficulties for forensic analysts and investigators.</p>
<h3 class="h3" id="ch18lev1sec4"><strong>The HiddenFsReader Tool</strong></h3>
<p class="noindent">In the course of our research on advanced malware threats, we’ve reverse engineered many different malware families and have managed to gather extensive information on various implementations of hidden filesystems that may be very useful to the security research community. For this reason, we’ve implemented a tool named HiddenFsReader (<em><a href="http://download.eset.com/special/ESETHfsReader.exe/">http://download.eset.com/special/ESETHfsReader.exe/</a></em>) that automatically looks for hidden malicious containers on a computer and extracts the information contained within.</p>
<p class="indent"><a href="ch18.xhtml#ch18fig07">Figure 18-7</a> depicts the high-level architecture of the HiddenFsReader.</p>
<div class="image"><span epub:type="pagebreak" id="page_361"/><a id="ch18fig07"/><img src="../images/18fig07.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 18-7: High-level architecture of HiddenFsReader</em></p>
<p class="indent">The HiddenFsReader consists of two components: a user-mode application and a kernel-mode driver. The kernel-mode driver essentially implements the functionality for disabling rootkit/bootkit self-defense mechanisms, and the user-mode application provides the user with an interface to gain low-level access to the hard drive. The application uses this interface to read actual data from the hard drive, even if the system is infected with an active instance of the malware.</p>
<p class="indent">The user-mode application itself is responsible for identifying hidden filesystems read from the hard drive, and it also implements decryption functionality to obtain the plaintext data from the encrypted hidden storage.</p>
<p class="indent">The following threats and their corresponding hidden filesystems are supported in the latest release of the HiddenFsReader at the time of writing:</p>
<ul>
<li class="noindent">Win32/Olmarik (TDL3/TDL3+/TDL4)</li>
<li class="noindent">Win32/Olmasco (MaxXSS)</li>
<li class="noindent">Win32/Sirefef (ZeroAccess)</li>
<li class="noindent">Win32/Rovnix</li>
<li class="noindent">Win32/Xpaj</li>
<li class="noindent">Win32/Gapz</li>
<li class="noindent">Win32/Flamer</li>
<li class="noindent">Win32/Urelas (GBPBoot)</li>
<li class="noindent">Win32/Avatar</li>
</ul>
<p class="indent"><span epub:type="pagebreak" id="page_362"/>These threats employ custom hidden filesystems to store the payload and configuration data, better protecting against security software and making forensic analysis harder. We haven’t discussed all of these threats in this book, but you can find information on them in the list of references available at <em><a href="https://nostarch.com/rootkits/">https://nostarch.com/rootkits/</a></em>.</p>
<h3 class="h3" id="ch18lev1sec5"><strong>Conclusion</strong></h3>
<p class="noindent">The implementation of a custom hidden filesystem is common for advanced threats like rootkits and bootkits. Hidden storage is used to keep configuration information and payloads secret, rendering traditional approaches to forensic analysis ineffective.</p>
<p class="indent">Forensic analysts must disable the threat’s self-defense mechanisms and reverse engineer the malware. In this way, they can reconstruct the hidden filesystem’s layout and identify the encryption scheme and key used to protect the malicious data. This requires extra time and effort on a per-threat basis, but this chapter has explored some of the possible approaches to tackling these problems. In <a href="ch19.xhtml#ch19">Chapter 19</a>, we will continue to explore forensic analysis of malware, focusing specifically on UEFI rootkits. We will provide information on UEFI firmware acquisition and analysis with respect to malware targeting UEFI firmware.</p>
</body></html>