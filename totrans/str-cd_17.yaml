- en: '13'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: USING FILSKA
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 12](ch12.xhtml#ch12), we designed and implemented Filska. Now, let’s
    use it to write some programs. We’ll develop six Filska programs of increasing
    complexity to gain experience thinking in the restricted world Filska offers us.
  prefs: []
  type: TYPE_NORMAL
- en: To be more specific, this rather long chapter comprises disconnected sections,
    each implementing a particular Filska example. You need not read straight through
    because no section builds necessarily upon any previous section. Instead, the
    goal of the chapter is to present case studies in using Filska, all with the hope
    of helping you think about how to code in Filska and, more importantly, how to
    think in new ways to help you be more creative in your own coding tasks, regardless
    of the language. So put on your dancing shoes, turn the fiddle music up to 11,
    and get ready to have some (possibly) high-spirited fun.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hello, World!**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’d be remiss if we didn’t start with the expected “Hello, world!” example.
    The most obvious way to write it in Filska is to load the respective ASCII codes
    for each character into subprogram memory and call `chr` to output the string
    one character at a time. However, this is also quite boring and not the least
    bit mathematical, so we’ll forgo the obvious and instead embrace the obfuscated.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hello, Math!***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s develop the necessary sequence of characters as a series of simple math
    operations. We’ll use the X register and output it as a character when needed.
    Therefore, we need a subprogram to output the X register as a character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The above fits the bill. The first instruction moves X to the subprogram memory,
    and the second dumps the ASCII character it represents to the console. The final
    instruction returns to `main` and, as it is the final instruction, the next call
    from `main` to `dump` will loop around and begin again with `txm`, as we desire.
  prefs: []
  type: TYPE_NORMAL
- en: We can now dump ASCII characters in X to the console. Next we need our sequence
    of operations on X. The ASCII code for `H` is 72, so we’ll start there and move
    from the current character to the next via additions of positive and negative
    offsets. The sequence we need is
  prefs: []
  type: TYPE_NORMAL
- en: '| *X* ← 8*X* ←*X* × 9*X* ←*X* *–* 3*X* ←*X* + 7*X* ←*X* + 0*X* ←*X* + 3*X*
    ←*X* *–* 35*X* ←*X* *–* 12*X* ←*X* + 55*X* ←*X* *–* 8*X* ←*X* + 3*X* ←*X* *–*
    6*X* ←*X* *–* 8*X* ←*X* *–* 35 |'
  prefs: []
  type: TYPE_TB
- en: Note that here we output X with `dump` after each operation except the first.
  prefs: []
  type: TYPE_NORMAL
- en: We have an assignment, a multiplication, and a bunch of additions. So we need
    `set`, `mul`, and `add` along with `jmp` to call `dump`. Translating the sequence
    into code gives us [Listing 13-1](ch13.xhtml#ch013list1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-1: A first version of “Hello, world!” in Filska*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-1](ch13.xhtml#ch013list1) is in the file *hello.filska*. The code
    uses `*main*` ’s memory to hold the offset and X to hold the running total. Each
    operation on X is followed by a call to `*dump*` . The final three instructions
    output a newline character and then halt. As we might expect, removing `*hlt*`
    makes the code dump `*HELLO*,` `WORLD!` forever.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hello, Poly!***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 13-1](ch13.xhtml#ch013list1) is indeed obfuscated, but we can do better
    while still dumping `HELLO, WORLD!` to the console. The ASCII values we need to
    dump as characters are'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Can we create a mathematical function, *y* = *f* (*x*), to generate this sequence
    for *x* ∈ [0, 12]? If we had such a function, we could generate `HELLO,` `WORLD!`
    character by character with repeated calls to *f* (*x*) for *x* = 0, 1, *…*, 12.
  prefs: []
  type: TYPE_NORMAL
- en: A good candidate for such a function is a polynomial. We remember these from
    our high school algebra days as sums of terms where each term is a coefficient
    multiplying some power of *x*. Let’s use a polynomial for *f* (*x*). The degree
    of the polynomial is the highest power of *x* present. We need to pick a degree
    for the polynomial and then find the set of coefficients. For example, if we decide
    to use a third-degree polynomial, we get
  prefs: []
  type: TYPE_NORMAL
- en: '*y* = *p*[0]*x*³ + *p*[1]*x*² + *p*[2]*x* + *p*[3]'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that *x*¹ = *x* and *x*⁰ = 1\. The *p*s are the coefficients, and we
    need to find them somehow after picking the degree.
  prefs: []
  type: TYPE_NORMAL
- en: What we are talking about here is known as *curve fitting*, which is the process
    of finding the equation of a curve that best fits a set of data. For us, our dataset
    is the sequence of ASCII characters we want to generate along with the input *x*
    value, a sequence of points, (*x*, *y*), so that 72 = *f* (0), 69 = *f* (1), and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use a polynomial for *f* (*x*), but we still need to pick a degree and
    then learn how to fit a polynomial of that degree to the dataset. It’s known that
    an *n –* 1 degree polynomial can perfectly fit a dataset with *n* points. Generally,
    this isn’t what is wanted. The point of fitting the function is to explain the
    trend of the data using the function to make meaningful predictions at points
    not measured. However, we actually *do* want to hit each data point exactly. Therefore,
    let’s use a 12th degree polynomial to fit our 13 points (see Equation 13.1). We
    now need to find the coefficients of
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/13eqa01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Great! How do we find the coefficients? The answer is to use *least-squares
    fitting*, a method for finding the values for *p* that minimize the square of
    the difference between the data points and the function value at those data points.
    Implementing a routine to do least-squares fitting to a polynomial is beyond the
    scope of this book. Fortunately, we can use the power of NumPy to do it for us.
    Incidentally, we’ll encounter least-squares fitting of data later in this chapter
    when we write a Filska program to fit data to a line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the Python program in *hello.py*. We won’t show the code here, but
    please do review it. The code uses NumPy, specifically the `np.polyfit` routine,
    to fit the dataset and generate the coefficients we need. The same code also calculates
    the difference between the dataset and the polynomial values at the given *x*
    values, and generates a plot of the resulting polynomial. NumPy found the following
    coefficients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, each `P` is the coefficient for the corresponding power of *x*. The polynomial
    is sensitive enough that all digits displayed are necessary. Our Filska program
    will use these constants in all their glory.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-1](ch13.xhtml#ch013fig1) shows us what the polynomial looks like.
    The circles are the actual data points we want the polynomial to output, and the
    curve is the polynomial itself (Equation 13.1).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/13fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: The polynomial of Equation 13.1 and the actual data points to
    output*'
  prefs: []
  type: TYPE_NORMAL
- en: A glance at [Figure 13-1](ch13.xhtml#ch013fig1) shows that the 12th degree polynomial
    fit is hitting all the points we want it to hit, but the function itself acts
    wildly outside of those points, so it wouldn’t be a good fit to the dataset if
    we were looking to learn something about the general trend of the data. Thankfully,
    we aren’t. Instead, we’re looking to build a needlessly complicated implementation
    of `HELLO, WORLD!` so we are doing just fine with our 12th degree polynomial.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hello, Poly Implementation!***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start designing the Filska code. We need the equivalent of the Python
    code in [Listing 13-2](ch13.xhtml#ch013list2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-2: Python code to generate HELLO, WORLD! with a polynomial*'
  prefs: []
  type: TYPE_NORMAL
- en: The function `f(x)` implements the polynomial returning the *y* for any given
    *x*. The *x* values we need are the numbers from 0 through 12\. Looking at the
    `for` loop, each *x* is given to *f* (*x*) to create a *y* output, which is a
    floating-point number we need to round to the nearest integer. Rounding means
    *y* = 72*.*04 leads to *d* = 72 and *y* = 72*.*54 produces *d* = 73\. It’s *d*
    we’ll treat as the ASCII character code to output, which is precisely what the
    `print` statement is doing via `chr`. To round *y* to get integer *d*, we use
    the standard trick of adding 0.5 followed by `floor` to arrive at *d*. Without
    this rounding, the output will not be `HELLO, WORLD!` but `HDKKN+VNQLD!`
  prefs: []
  type: TYPE_NORMAL
- en: To generate Filska code equivalent to [Listing 13-2](ch13.xhtml#ch013list2),
    we need a subprogram implementing *f* (*x*) and a main loop over the integers
    from 0 through 12\. After passing each integer to *f* (*x*) and rounding, we emit
    the result as a character. The complete code is in *hello2.filska*. We’ll present
    the important parts in [Listing 13-3](ch13.xhtml#ch013list3), but please review
    the entire file to see all the source code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-3: The main loop of hello2.filska*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-3](ch13.xhtml#ch013list3) presents `main` and `dump`. Let’s begin
    with `dump`. We’ve seen this subprogram before in [Listing 13-1](ch13.xhtml#ch013list1).
    It takes the contents of a register, here Y, and dumps it as a character to the
    console before returning to `main`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `main` subprogram of [Listing 13-3](ch13.xhtml#ch013list3) implements the
    loop over *x* values. In this case, we’ll use the X register as *x*, so we initialize
    it to 0 ➊. Next, we transfer control to the `calc` subprogram ➋. This subprogram
    implements *y* = *f* (*x*) and returns *y* in the Y register. We’ll get to `calc`’s
    implementation momentarily. With Y, the ASCII value we want for the current X,
    we call `dump` to display the character at the console.
  prefs: []
  type: TYPE_NORMAL
- en: We want *x* from 0 through 12, so we increment memory, which holds our counter
    ➌, and check to see if we’ve hit 13 characters ➍. If memory equals 13, the `tst`
    returns true and we jump ahead two instructions. Otherwise, *x* < 13 and we go
    back to the `tmx` instruction to move the new *x* value from memory to the X register.
    The program ends when *x* = 13 by outputting a newline character and calling `hlt`.
  prefs: []
  type: TYPE_NORMAL
- en: All we have left to implement is `calc`, the subprogram mapping X to Y via the
    polynomial. [Listing 13-2](ch13.xhtml#ch013list2) points the way for us. We need
    something like `f(x)`, which calculates the polynomial term by term. If we create
    a sequence of Filska instructions that find *px*^(*n*) for some power, *n*, and
    some coefficient, *p*, we need only accumulate the terms for all powers and coefficients
    to arrive at *y*. We also need to round *y*, but that comes after we calculate
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than show all of `calc`, we’ll show how we start accumulating the proper
    terms of the polynomial, how we end, and how we round before returning to `main`.
    See [Listing 13-4](ch13.xhtml#ch013list4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-4: The calc subprogram of hello2.filska*'
  prefs: []
  type: TYPE_NORMAL
- en: The code is sectioned into blocks that each raise X to some power, multiply
    it by the proper coefficient, and add the product to the total in Y. The first
    block starts the chain, and the last block concludes it. Let’s start with the
    highest power of X, which is 12 ➊.
  prefs: []
  type: TYPE_NORMAL
- en: To calculate *y* = *f* (*x*), we’ll use subprogram memory and Z as scratch space
    and accumulate the value of the polynomial term by term in Y. To start, we move
    12 into M then to Z. Recall that `set` applies to only the current subprogram’s
    memory. Next, we calculate *x*^(12) by raising X to the Z power, putting the result
    back into Z. This is the `pow` instruction. Now we need to multiply *x*^(12) by
    the proper coefficient, so we set M to the necessary value, multiply by Z, and
    store the result in Y as the first term of the polynomial.
  prefs: []
  type: TYPE_NORMAL
- en: The next term of the polynomial is calculated similarly ➋. The difference here
    is using 11 as the exponent, multiplying by the proper coefficient for *x*^(11),
    and adding the product to Y via the `mul,m=mz` and `add,y=my` instructions. The
    polynomial’s remaining terms are found in precisely the same way, by replacing
    the exponent with 10, then 9, and so on down to 0, multiplying by the appropriate
    coefficients each time.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, Y holds the answer. All that remains is to round it to the nearest
    integer ➌. We add 0.5 to Y, leaving the answer in M. Then, we call `*flr*` , move
    the result back to Y, and jump back to `main` to output Y as a character.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we developed two obfuscated ways to dump the string `HELLO,
    WORLD!` to the console. How many more can you think of? If you create a novel
    approach, please share it with me, and I’ll put it on the book’s GitHub site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move on to our next example: one that introduces us to execution tracing
    with Filska.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fibonacci, Anyone?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we spent far too much energy developing cute ways to
    output the string `HELLO, WORLD!`. This section will work with a more straightforward
    example and use it to explore execution tracing. Our goal is to generate as many
    terms of the Fibonacci sequence as can fit properly in a Python float.
  prefs: []
  type: TYPE_NORMAL
- en: The Fibonacci sequence uses the recurrence relation
  prefs: []
  type: TYPE_NORMAL
- en: '*F*[1] = 1,    *F*[2] = 1'
  prefs: []
  type: TYPE_NORMAL
- en: '*F**[n]* = *F*[*n**–*1] + *F*[*n**–*2]'
  prefs: []
  type: TYPE_NORMAL
- en: so that *F*[3] = *F*[2] + *F*[1] = 1 + 1 = 2, and *F*[4] = *F*[3] + *F*[2] =
    2 + 1 = 3, and so on. The first few terms of the Fibonacci sequence are
  prefs: []
  type: TYPE_NORMAL
- en: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, …
  prefs: []
  type: TYPE_NORMAL
- en: The Fibonacci sequence is named after Leonardo Bonacci, sometimes referred to
    as Leonardo of Pisa or, most commonly, as Fibonacci. The sequence was known outside
    of Europe for well over a millennia when Fibonacci used it as an idealized example
    of rabbit population growth in his 1202 text *Liber Abaci* (*The Book of Calculation*).
  prefs: []
  type: TYPE_NORMAL
- en: Many books have been written about the Fibonacci sequence and all the places
    it appears in mathematics. There is even an academic publication, *The* Fibonacci
    Quarterly, with issues going back to 1963 (see *[https://www.fq.math.ca/](https://www.fq.math.ca/)*).
    Here we’ll relate only a few interesting observations about the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The Fibonacci sequence is intimately related to *ϕ* (phi), also known as the
    golden ratio
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0349-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where the golden ratio is a solution to
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0349-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For example, if we set *y* = 1, we get
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0349-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '*x*² *–* *x* *–* 1 = 0'
  prefs: []
  type: TYPE_NORMAL
- en: with the positive solution, via the quadratic formula, as
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0349-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: which is *ϕ*. Like the Fibonacci sequence, *ϕ* shows up everywhere in mathematics
    and nature. A link to the Fibonacci sequence comes from the fact that as *n* →*∞*,
    the ratio of the *n* + 1th Fibonacci number to the *n*th approaches *ϕ*
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0349-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where the last ratio is *ϕ* to the precision of a Python float.
  prefs: []
  type: TYPE_NORMAL
- en: With *ϕ* in hand, we can calculate the *n*th Fibonacci number directly via
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0350-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: which works in code for small values of *n*, but fails when *n* gets large because
    of precision issues.
  prefs: []
  type: TYPE_NORMAL
- en: We could fill the remainder of this book with fascinating facts and observations
    about the Fibonacci sequence, but we’ll bring things back to coding and implement
    the sequence in Filska (see [Listing 13-5](ch13.xhtml#ch013list5)). The code itself
    is in *fib.filska*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-5: Generating the Fibonacci sequence*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 13-5](ch13.xhtml#ch013list5) we initialize a counter in Z set to
    78 ➊. Therefore, we’ll output 78 Fibonacci numbers, counting Z down by 1 each
    time until it is 0\. Why 78? Because *F*[78] = 8,944,394,323,791,464 is the largest
    Fibonacci number that fits in a 64-bit float. Were Filska extended to operate
    on integers as Python integers instead of Python floats, we could generate Fibonacci
    numbers until we run out of memory.
  prefs: []
  type: TYPE_NORMAL
- en: To get the first two numbers, we decrement Z twice and print the constant `1`
    twice. Boring, but effective. Then, we use the X and Y registers to
  prefs: []
  type: TYPE_NORMAL
- en: hold the previous two Fibonacci numbers and their sum to generate the next.
    The recurrence loop begins by calculating the next Fibonacci number ➋. X and Y
    are updated by shifting the current value of Y to X and the new Fibonacci value
    in M to Y. We then decrement Z and branch forward to `hlt` if it is 0; otherwise,
    the loop repeats ➋. [Listing 13-5](ch13.xhtml#ch013list5) is straightforward;
    therefore, it’s a good example for execution tracing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run *fib.filska* with tracing, use a command line like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `-t` flag is the signal to trace execution, one instruction at a time. Doing
    this presents us with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'and a prompt waiting for us to hit ENTER or `q` to quit. Let’s break down the
    status line:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Displayed Text | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CP:MAIN` | Current subprogram name |'
  prefs: []
  type: TYPE_TB
- en: '| `PC:000` | Current program counter |'
  prefs: []
  type: TYPE_TB
- en: '| `X:0.000000` | Register values |'
  prefs: []
  type: TYPE_TB
- en: '| `Y:0.000000` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `Z:0.000000` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `M:0.000000` | Local memory value |'
  prefs: []
  type: TYPE_TB
- en: '| `Z:0` | “Zero” flag |'
  prefs: []
  type: TYPE_TB
- en: '| `E:0` | “Equal” flag |'
  prefs: []
  type: TYPE_TB
- en: '| `L:0` | “Less than” flag |'
  prefs: []
  type: TYPE_TB
- en: '| `G:0` | “Greater than” flag |'
  prefs: []
  type: TYPE_TB
- en: The next instruction is `set,78`. Hitting ENTER gives us
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: showing us that local memory is now 78 and that the next instruction is `dec`.
    If we press ENTER exactly seven times from this instruction, we pass through to
    the `jmp,nl` instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: telling us that we are about to execute the first instruction of subprogram
    `nl`. How do we know it’s the first instruction? Because the program counter,
    `PC`, is 0\. Note also that the X register is 1, set previously by the `tmx` instruction
    in `main`.
  prefs: []
  type: TYPE_NORMAL
- en: After three more presses of ENTER, we get
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: which shows us back in `main` and about to execute instruction 8 to move the
    1 from memory to Y.
  prefs: []
  type: TYPE_NORMAL
- en: Six more presses of ENTER later, and the one after that gives
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `add` instruction has set local memory to 2: *M* ←*X* + *Y*.'
  prefs: []
  type: TYPE_NORMAL
- en: Repeated ENTER keypresses trace through the remainder of the recurrence loop
    to `tst` on Z equal to 0 and then follow `gto` back to `add`, looping until Z
    is eventually 0.
  prefs: []
  type: TYPE_NORMAL
- en: The tracing functionality is quite useful when developing Filska programs. Also
    helpful is working with code in small pieces—usually individual subprograms—to
    get them running as they should.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of this chapter presents several other Filska programs for fun
    and learning. Let’s see how Filska generates random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Random Numbers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Filska’s `rnd` instruction sets subprogram memory to a random floating-point
    number, [0,1). In reality, of course, this number isn’t random, but a pseudorandom
    approximation. Also, it’s cheating because `rnd` is using Python’s `random` module
    under the hood. Python’s `random` module uses the Mersenne Twister pseudorandom
    number generator, a pretty good generator that is sufficient for all but the most
    demanding of tasks. One measure of a pseudorandom generator’s quality is its *period*,
    that is, how many numbers it can generate before the sequence begins to repeat.
    For the Mersenne Twister, the period is 2^(19937) *–* 1, which should be good
    enough for most anyone.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll develop code to generate pseudorandom numbers with Filska
    *without* cheating, that is, without the `rnd` instruction. Instead, we’ll implement
    the Park and Miller linear congruential generator, also known as MINSTD. This
    linear congruential generator is a simple algorithm with a period of about 2^(31).
    Far less than the Mersenne Twister period, but still quite sufficient for many
    noncritical tasks like games.
  prefs: []
  type: TYPE_NORMAL
- en: '***Implementing MINSTD***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most pseudorandom number generators are iterative, meaning the previous pseudorandom
    value is used to generate the next. The first value in the sequence is generated
    from a user-supplied seed value. Fixing the seed value fixes the sequence of values
    generated. In this way, it’s possible to create a deterministic sequence of values
    that pass randomness tests, as strange as that sounds.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*There exist pseudorandom generators capable of generating the *n*th value
    of the sequence for a specified seed *without* generating the* n – *1 values before
    it. To find such a generator, search for “counter-based random number generator.”*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Park and Miller algorithm runs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select a seed value and call it *x*[0].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Generate the next seed value: *x*[*i*+1] ← 48271*x**[i]* mod (2^(31) *–* 1).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Return the floating-point version: *x*[*i*+1]/(2^(31) *–* 1).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use *x*[*i*+1] as *x*[*i*] for the next pseudorandom value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The algorithm is a recurrence relation similar to what we used above for generating
    Fibonacci numbers. Therefore, we expect an initialization section followed by
    a loop that spits out the next number in the sequence as a float. For the seed,
    *x*[0], we are free to pick any integer in [1, 2^(31) *–* 1). We’ll use 8,675,309,
    but you can replace it with any number you wish to get a different sequence of
    values. The code we need is in *random.filska* (see [Listing 13-6](ch13.xhtml#ch013list6)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-6: Park and Miller LCG in Filska*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-6](ch13.xhtml#ch013list6) initializes X with the desired seed,
    stores the multiplier (48,271) in memory, and starts the loop to calculate the
    next seed value. The recurrence relation is implemented in stages. First, the
    seed in X is multiplied by 48,271, with the result back in X. Then 2^(31) *–*
    1 is loaded into memory, followed by the modulo operation, again with the result
    in X. X is now the next value in the sequence. The floating-point version is output
    by `make_float`, which divides X by 2^(31) *–* 1, dumping the result to the console
    along with a newline to get one pseudorandom float per line. Back in `main`, the
    loop continues, so the program dumps floats forever.'
  prefs: []
  type: TYPE_NORMAL
- en: Run the program and direct output to a file, say *numbers.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Allow the program to run for maybe 15 minutes, or until there are more than
    1 million lines in the file. We need many values to get meaningful statistics
    on the quality of the output, and the more the merrier. When you get tired of
    waiting, use CTRL-C to exit the program.
  prefs: []
  type: TYPE_NORMAL
- en: '***Evaluating MINSTD***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We now have a large text file of floating-point values. They certainly look
    random enough, but are they? How can we tell? The honest answer is that we can’t.
    We cannot *prove* these are random values, and in fact, we know that they aren’t
    because we used a deterministic method to generate them. John von Neumann, one
    of the founders of computer science, famously quipped that anyone considering
    deterministic methods for generating random numbers is “in a state of sin.” Still,
    we’d like to think the sequence we just generated is at least random-ish, meaning
    knowing one value doesn’t help us much in guessing the next value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it happens, there are many highly sophisticated ways to test for randomness.
    None are conclusive, but as a group, they lend credence to a belief that a sequence
    of values is random for all practical purposes. The tests are extensive, far beyond
    what we need, but fortunately for us, there is one that is simple, easy to evaluate,
    and included with standard Linux distributions. To boot, it has a cool, Tolkienesque
    name: `ent`.'
  prefs: []
  type: TYPE_NORMAL
- en: However, `ent` only works with random *bytes*, not floating-point numbers. That’s
    okay; a snippet of Python converts our file of random floats into a file of random
    bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We assume the captured floats are in the file *numbers.txt*. The byte version
    is stored in *random.dat*. The array `d` contains the floats read from *numbers.txt*.
    The loop generates a list, `b`, of integers found by multiplying the float value
    by 256 and dropping any fractional part via `floor`. Lastly, the list of integers
    is formed into a byte array and dumped into the output file.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s run `ent` on *random.dat*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: producing
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The values you see when you run the code will be slightly different because
    the number of randoms generated before hitting CTRL-C will be different, or if
    you change the seed value.
  prefs: []
  type: TYPE_NORMAL
- en: 'What to make of `ent`’s output? We’ll skip the chi-square part and consider
    the other metrics: entropy/compression, arithmetic mean value, estimate of *π*,
    and the serial correlation.'
  prefs: []
  type: TYPE_NORMAL
- en: The *entropy* is a measure of the information content, in this case as bits
    per byte. There are eight bits in a byte, so the maximum possible entropy is 8.0\.
    This means there is no way to simplify the file’s representatio, as there is no
    redundancy. Our file has an entropy of 7.999803 bits per byte, meaning it’s close
    to maximum randomness. This is essentially what the statement about optimum compression
    is saying.
  prefs: []
  type: TYPE_NORMAL
- en: If the file consists of purely random bytes, we expect as many bytes to be above
    the median value of 127.5 / 2 as below, so the arithmetic mean should be 127.5\.
    Our file has a mean value of 127.5722, which, again, is pretty close to what we’d
    expect from a random sequence.
  prefs: []
  type: TYPE_NORMAL
- en: A Monte Carlo process simulates something. In this case, it’s using the random
    bytes to simulate dart throws then asking how many darts land inside a circle
    of radius 1 and how many land inside a square of side 1 circumscribed over the
    circle. The ratio of darts landing within the circle to those landing within the
    square leads to an estimate of *π*. Here, the estimate is in the ballpark but
    not too impressive. Also, there are only 1 million or so values in the file. Most
    randomness tests want hundreds of millions to billions of examples before making
    a statement, so we are doing well here, too.
  prefs: []
  type: TYPE_NORMAL
- en: The final test is a serial correlation test. The earlier tests looked at the
    values without caring about their ordering in the file. The serial test pays attention
    to the order. It’s looking to see if knowing the value of one byte gives you knowledge
    about the value of the next byte. For a random sequence, there should be no such
    correlation. Here we get a slight negative correlation, which, again, is a reasonable
    statement that we’ve generated a (mostly) random sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The results above give us confidence that our Filska pseudorandom number generator
    is working correctly. Let’s move on to our next example, one that also generates
    data to be captured in a file.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Simple Fractal**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 10](ch10.xhtml#ch10) we briefly encountered the Sierpiński triangle.
    Let’s see how to generate the points of this fractal in Filska. The algorithm
    is
  prefs: []
  type: TYPE_NORMAL
- en: 'Define three triangle vertices: (*x*[0], *y*[0]), (*x*[1], *y*[1]), and (*x*[2],
    *y*[2]).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose one vertex at random, say (*x*, *y*) = (*x*[0], *y*[0]).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select another vertex at random, say (*x*[1], *y*[1]).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update ![Image](Images/f0356-01.jpg).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output (*x*, *y*) to be plotted later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat from Step 3 for the desired number of points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In essence, we plot the midpoint between the current point and a randomly selected
    vertex of the triangle and repeat until we generate as many points as we wish
    to plot. Once again, this is a recurrence relation where the *n* + 1th point is
    constructed from the *n*th point, only now we are working in two dimensions, not
    one (see [Listing 13-7](ch13.xhtml#ch013list7)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-7: Pseudocode for the Sierpiński triangle*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make the algorithm explicit with pseudocode. First, we’ll pick the vertices
    of the triangle: (0,0); (0.5,1); (1,0). Then, we need to code [Listing 13-7](ch13.xhtml#ch013list7)
    where `rnd` returns a random float, [0, 1). We initialize *x* and *y* to the point
    (1,0). Any of the three points would do.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we start a loop for the desired number of points, `N`. The three cases
    select one of the three vertex points with equal probability. If the random value
    in `r` is below one-third, we’ve selected the first point, (0,0), so the midpoint
    is the average of both the *x* and *y* values plus 0 and 0\. Similarly, if `r`
    is 0*.*333333 ≤*r* < 0*.*666666, we select the vertex at (0.5,1). Lastly, if `r`
    is ≥ 0*.*666666, we use the vertex at (1,0). After updating *x* and *y*, we print
    them as a pair and repeat the loop.
  prefs: []
  type: TYPE_NORMAL
- en: The midpoint formulas simplify as shown in [Listing 13-7](ch13.xhtml#ch013list7).
    Observe that each pass through the loop updates *x* and *y* by first dividing
    by 2 (multiplying by 0.5) and then adding an offset depending upon the selected
    vertex. If the vertex is (0,0), the offset is 0 for both *x* and *y*. If the vertex
    is (0.5,1), the offset is 0.25 in *x* and 0.5 in *y*. Lastly, for (1,0), the offset
    is 0.5 in *x* and 0 for *y*.
  prefs: []
  type: TYPE_NORMAL
- en: This observation means the loop can be rewritten first to divide *x* and *y*
    by 2, and then we can add the offset—there is no need to have code that calculates
    the repeated instances of `0.5*x` and `0.5*y` as shown in [Listing 13-7](ch13.xhtml#ch013list7).
    This simplification helps considerably when writing the Filska implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our implementation uses three subprograms: `main`, `loop`, and `print`. Also,
    we’ll store the current *x* value in the X register and, not surprisingly, the
    current *y* value in the Y register. We’ll use `main` to initialize X and Y, set
    up the counter for the desired number of output points, which we’ll store in Z,
    and then transfer execution to `loop` (see [Listing 13-8](ch13.xhtml#ch013list8)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-8: The main loop of sierpinski.filska*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll use `print` to display the X and Y registers as an (*x*, *y*) pair
    on the same line (see [Listing 13-9](ch13.xhtml#ch013list9)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-9: The print subprogram of sierpinski.filska*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-9](ch13.xhtml#ch013list9) first moves X to local memory to print
    it. Then it prints two spaces (character 32) before printing Y and a newline.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-10](ch13.xhtml#ch013list10) contains the bulk of the program. It’s
    the body of the loop in [Listing 13-7](ch13.xhtml#ch013list7).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-10: The loop subprogram of sierpinski.filska*'
  prefs: []
  type: TYPE_NORMAL
- en: First, we divide the X and Y registers by 2 ➊. Then, we use `loop`’s memory
    to hold a random value ➋.
  prefs: []
  type: TYPE_NORMAL
- en: If the random value is less than 0.333333, the `tst,l,10` instruction ➌ is true
    and execution moves to the `jmp` to `print` ➐. This is the (0,0) vertex where
    there is no offset to add. If memory is less than 0.666666 ➍, execution moves
    to adding an offset of 0.25 to X and 0.5 to Y ➏. This is the (0.5,1) vertex case.
    Lastly, if memory is greater than or equal to 0.666666, we have the (1,0) case
    so we need only add an offset of 0.5 to X ➎. After printing the new X and Y values
    ➐, the Z register is decremented and tested for 0 ➑. If Z is 0, `hlt` stops the
    program. If not, the `loop` subprogram is run from the beginning courtesy of the
    `jpr` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s run the program and capture the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, *points.txt* becomes a collection of 60,000 (*x*, *y*) pairs.
  prefs: []
  type: TYPE_NORMAL
- en: To see the fractal, we need to plot the points. A few lines of Python will do
    the trick.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The result should look very much like [Figure 13-2](ch13.xhtml#ch013fig2). Note
    that [Figure 13-2](ch13.xhtml#ch013fig2) uses 600,000 points, 10 times as many
    as *sierpinski.filska* generates by default.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/13fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: The Sierpiński triangle with 600,000 points*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting to the Roots of the Problem**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In algebra class, we all spent far too much time factoring quadratic equations
    of the form *ax*² + *bx* + *c* to find the roots, that is, the values of *x* such
    that *ax*² + *bx* + *c* = 0\. After much consternation and many practice problems,
    we were told of the formula to find the roots directly. This is the quadratic
    formula, which we used above to find the value of *ϕ*, the golden ratio.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0360-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The value under the square root is known as the *discriminant*, Δ = *b*² – 4*ac*.
    The sign of the discriminant tells us something useful about the roots.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0360-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For the first case, the discriminant is negative, and the square root of a negative
    number is imaginary. For the second case, the square root is 0, and the single
    root is *x* = *–b*/(2*a*). For the third case, the discriminant is positive, the
    square root exists, and there are two distinct real roots.
  prefs: []
  type: TYPE_NORMAL
- en: The file *roots.filska* contains a complete program to calculate the roots of
    an arbitrary quadratic polynomial. Let’s run it a few times to see what it outputs.
    Then, we’ll examine the portions of the code related to the discriminant and the
    roots themselves. The remainder of the code handles text output. It is primarily
    a series of `set` and `chr` instructions, which are essential to the nice formatting
    of the program, but not helpful in learning how to implement the calculations
    in Filska.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-11](ch13.xhtml#ch013list11) shows the output for three separate
    runs of *roots.filska*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-11: Three runs of roots.filska*'
  prefs: []
  type: TYPE_NORMAL
- en: The prompts ask the user to enter the coefficients of the quadratic, the *a*,
    *b*, and *c* values. In the first case, we are asking for the roots of *x*² +
    2*x* + 4 and are told they are complex because the discriminant is negative. In
    the second case, we want the roots of *x*² + 4*x* + 2, which are real. The last
    case is asking about *–* 4*x*² + 12*x –* 9, which leads to a zero discriminant
    and only one root.
  prefs: []
  type: TYPE_NORMAL
- en: 'The flow of this program is quite linear: the user enters the coefficients,
    the discriminant is calculated, and, based on the value of the discriminant, the
    proper roots are calculated. If you look at *roots.filska*, you’ll see that the
    key subprograms are `main`, `positive`, `equal`, and `negative`, along with three
    subprograms to get the coefficients: `getA`, `getB`, and `getC`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-12](ch13.xhtml#ch013list12) presents the `main` subprogram.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-12: The main subprogram*'
  prefs: []
  type: TYPE_NORMAL
- en: From the comments, we see that `main` asks for *a*, *b*, and *c* and then calculates
    the discriminant (`D`) before using its value to jump to either `positive`, `equal`,
    or `negative`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with the last three instructions in `main`. At first glance, it
    seems odd to put them one after the other, but that’s merely an illusion caused
    by thinking in terms of functions. We need to consider them in relation to the
    `cmp` and `tst` instructions above.
  prefs: []
  type: TYPE_NORMAL
- en: The `cmp` instruction compares `main`’s memory, the discriminant, to 0 ➌. If
    the discriminant is greater than 0, we transfer control to the `positive` subprogram
    by branching three instructions forward using `tst,g,3`. Similarly, we transfer
    control to `equal` if the discriminant is 0 and `negative` if the discriminant
    is less than 0\. All three of these subprograms eventually execute `hlt` and none
    return control to `main`.
  prefs: []
  type: TYPE_NORMAL
- en: Filska is quite limited in the data it can track, an intentional design goal
    to make us think more about how to arrange our programs, so we need to consider
    which values must be stored and when. We should ask the user for the coefficients
    of the quadratic. We also need to keep them somewhere and get them back on demand.
    We have the three registers, but if we store the coefficients in them, we have
    only the single memory location of each subprogram to use for calculations. We
    need the registers to transfer data between subprograms and to participate in
    calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to create a subprogram that acts as a small object. The subprogram
    can store a value passed to it and then return the value on demand. Think of the
    subprogram as an instance of a simple class that we might express in Python as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Instances of this class are given a value to store when they are created, and
    later return that value when asked using the `Get` method. This is what we need:
    to assign a value once and then retrieve it multiple times later on.'
  prefs: []
  type: TYPE_NORMAL
- en: In Filska, we get the same effect with a subprogram using its memory to store
    the value. Consider `getA`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The first three lines of `getA` print `A?` and then ask for a number from the
    user with `ipt`. Whatever number the user enters is stored in local memory. Then,
    control is transferred back to `main` via `jmp`. The next transfer from `main`
    back to `getA` begins with the `tmx` instruction to put the user’s value in the
    X register and then transfer back to `main`. However, any future transfer back
    to `getA` will begin with the `gto` instruction jumping back 2 to start again
    at `tmx`. This loop repeats indefinitely: `getA` will now only load X with the
    user’s value. We have a “write once, read many” place to hold a number—precisely
    what we need.'
  prefs: []
  type: TYPE_NORMAL
- en: Looking again at [Listing 13-12](ch13.xhtml#ch013list12), we see the first three
    transfers to get the coefficients ➊. This is followed later, during the calculation
    of the discriminant, by transfers to `getA`, `getB`, and `getC` when those values
    are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Calculation of the discriminant is an exercise in juggling data values so that
    we do not run out of places to put them (see [Listing 13-12](ch13.xhtml#ch013list12)
    ➋). Let’s walk through the code. We need to calculate *b*² *–* 4*ac* and begin
    by calculating *–* 4*ac*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We store *–* 4*ac* temporarily in Z. Now we need to find *b*² and add *–* 4*ac*
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We now have the discriminant in Y. To calculate the roots, let’s rewrite the
    quadratic equation using the discriminant, Δ.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0363-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Writing the equation in this form buys us something: we need only *a*, *b*,
    and Δ to calculate the roots. Good! We have three registers available, so let’s
    use Z for *a*, X for *b*, and Y for Δ.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, the last instruction moves the discriminant to `main`’s memory for the
    `cmp` instruction of [Listing 13-12](ch13.xhtml#ch013list12) ➌.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining subprograms, `positive`, `equal`, and `negative`, and the subprograms
    used by them, calculate and output the specific roots. As mentioned, many of the
    instructions relate to formatting the output. You can review those instructions
    on your own, but let’s conclude by stepping through `positive` to see how the
    calculation is done for two real roots.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Rewriting the quadratic equation one last time, we see that the two roots for
    a positive discriminant are
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0364-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: implying we need both *– b*/(2*a*) and ![Image](Images/f0394-01.jpg) so we can
    add and subtract them. The first term is built piece by piece, as indicated in
    the comments ➊. It’s left in `positive`’s memory. Then, transfer to `rest` builds
    ![Image](Images/f0394-01.jpg) in X. Notice that doing this destroys *b*, which
    was previously in X. That’s okay; we no longer need it. When `rest` transfers
    execution back to `positive`, X has the other term we need, so we first add the
    terms and call `?double` (read “print double”) to output what is in Y, subtract
    the terms, and call `?double` to get the other root. Notice also that using Y
    destroys the discriminant, but we no longer need it, either.
  prefs: []
  type: TYPE_NORMAL
- en: Whew! That was a lot of steps for something that a more powerful language could
    implement quickly. Still, the challenge, and fun, is in getting a constrained
    language to do something useful.
  prefs: []
  type: TYPE_NORMAL
- en: '**Linear Least-Squares Fit to a Line**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Previously, we fit a polynomial to a set of points to arrive at a silly way
    of printing `HELLO, WORLD!`. In this section, we’ll again use least-squares fitting,
    but this time to a line, which is far simpler. Specifically, we have a collection
    of (*x*, *y*) points, and we want to find the equation of a line that best fits
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '*y* = *b**x* + *a*'
  prefs: []
  type: TYPE_NORMAL
- en: for some *a* and *b* we need to calculate from the data.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike least-squares fitting to a polynomial or other function, fitting a line
    to a dataset has a closed-form solution; this means we can write the equations
    that give us *a* and *b* (see Equation 13.2)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/13eqa02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: for *N*, the number of points in the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Equation 13.2 appears a bit daunting at first. Don’t let it throw you. It says
    we must accumulate sums of all the *x* values and all *y* values along with the
    sums of *x*² and *x* times *y*. Once we have these sums, calculating *b* (the
    slope) and *a* (the intercept) is straightforward because the ∑ terms become simple
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this example is in *linfit.filska*. From a programming perspective,
    we’ll see a new kind of Filska subprogram, one that expands on the “write once,
    read many” idea we used in the previous section. However, before we write code,
    we must decide how we’ll get Filska to read the datafile. Normally, we’d store
    the data points as (*x*, *y*) pairs, one pair per line. However, if we use redirection
    to send the data to the Filska program, the `ipt` instruction will read only one
    value per line of the input file. Also, we need to tell Filska to stop reading
    the file so we can complete our calculations.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to put the data in the file with one value per line, first the
    *x* value and then the associated *y* value on the next line. To tell Filska we
    are done, we’ll end the file with a flag value, one that won’t show up in our
    dataset. We’ll use *–*999999, an unlikely data value.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if our dataset is
  prefs: []
  type: TYPE_NORMAL
- en: (0, 0*.*5), (1, 1*.*1), (2, 2*.*4), (3, 3*.*6)
  prefs: []
  type: TYPE_NORMAL
- en: we’ll format it for input as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: so each *x* is followed by its *y*, and the last value, `-999999`, tells us
    there’s no more data to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'As far as Equation 13.2 is concerned, we get the following sums for our example
    dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0366-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Meaning the best fit line is
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/f0366-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: or *y* = *bx* + *a* = 1*.*06*x* + 0*.*31.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see the code in action; then we’ll dive into it. I’ve included a sample
    dataset, *linfit_dataset.txt*. If you run *linfit.filska* using *linfit_dataset.txt*
    as the input you get
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: which tells us that the best-fit line is *y* = *Bx* + *A* (see [Figure 13-3](ch13.xhtml#ch013fig3)).
    The fit looks pretty good, so we have confidence that the code is working.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/13fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: Best-fit line to the sample dataset*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were using a high-level language to code this example, we’d likely store
    the dataset in some kind of array or list. Then we’d run through the list to generate
    the necessary sums. However, Filska has no arrays. So how can we do it? The solution
    comes from observing that all we need is a single pass through the dataset and
    some way of accumulating each point as we read it. There is no need to store all
    the data first and then process it, because we can process each point as it is
    read. In algorithm form, we need to code the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Read a point from the input file, (*x*, *y*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the *x* value to the running total of *x* values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add *x*² to the running total of *x*² values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add *y* to the running total of *y* values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add *xy* to the running total of *xy* values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat from Step 1 until all points have been read.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate *a* and *b* using the running totals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to track the sums of *x*, *y*, *x*², and *xy*, along with the total
    number of points read, *N*. That’s too many values to depend solely upon memory
    and the registers. Thus, we need something much like the subprograms of the previous
    section, which can be initialized, sum, and finally report their totals. Using
    the analogy of a class, as we did previously, we need something like the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This class sets its internal state to 0 when instantiated, and then adds values
    passed to `Add` and reports its current sum when `Get` is called.
  prefs: []
  type: TYPE_NORMAL
- en: We can build this structure in Filska using subprogram memory to store the sum
    and registers to provide values or return values. We’ll keep the current point’s
    *x* value in the X register and the *y* value in the Y register. We’ll use the
    Z register to tell the subprogram whether to accumulate (Z = 0) or return the
    sum (Z ≠ 0) in Y.
  prefs: []
  type: TYPE_NORMAL
- en: Now take a look at [Listing 13-13](ch13.xhtml#ch013list13), which shows the
    `sumxy` subprogram from *linfit.filska*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-13: The sumxy subprogram*'
  prefs: []
  type: TYPE_NORMAL
- en: When `sumxy` is called the first time, it sets its local memory to 0 and returns
    to `main` ➊. Subsequent calls begin with ➋ and branch depending upon Z. At this
    point, X and Y contain the respective *x* and *y* values of the current point.
    If Z is not 0, the `tst` instruction branches forward to ➍ to move local memory,
    the sum of the products of *x* and *y*, to Y.
  prefs: []
  type: TYPE_NORMAL
- en: Note two things about the code so far. First, at ➋, to test that Z is not 0,
    we have to swap memory and Z, so Z’s value is in memory, but the memory value
    is stashed in Z. After all, losing the sum in memory would make the entire subprogram
    useless. Therefore, at ➍ the swap must happen again to restore the actual sum
    of the *xy* pairs and ensure that Z is also unchanged. Second, when Z ≠ 0, the
    subprogram is in a permanent state of simply reporting its sum in Y. That means
    it no longer pays attention to Z’s state. This works for our program and frees
    Z for other uses, if necessary. The `gto` jumping back to `tmy` makes this happen.
  prefs: []
  type: TYPE_NORMAL
- en: If Z is 0, the `tst` fails, and execution continues ➌. First, Z and memory are
    swapped, as at ➍ to restore the sum. Then Z is used to hold the product of *x*
    and *y* and added to memory, thereby accumulating the product for the current
    point. Of course, using Z in this way changes its value, so before transferring
    back to `main`, we must reset Z to 0\. The `jmp` to `main` is followed by a `gto`
    to branch back the beginning of the test on Z for the next transfer to `sumxy`
    from `main`.
  prefs: []
  type: TYPE_NORMAL
- en: The pattern set up in `sumxy` is repeated for `sumx`, `sumy`, `sumx2`, and `sum`,
    where the second to last accumulates *x*² and the last counts the number of points
    processed. By controlling the state of Z, `main` moves from accumulating to calculating.
    The trigger to change state is reading the flag value of `-999999` for *x*.
  prefs: []
  type: TYPE_NORMAL
- en: The `main` subprogram of *linfit.filska* is rather long, so we’ll only examine
    pieces of it. [Listing 13-14](ch13.xhtml#ch013list14) covers the first part, which
    initializes the sums and processes the data points.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-14: Accumulating sums in main*'
  prefs: []
  type: TYPE_NORMAL
- en: The first block of code calls each of the accumulator subprograms to initialize
    them ➊. Next, the main loop starts by setting Z = 0 to put each subprogram in
    accumulator mode. The first `ipt` instruction reads an *x* value, checks to see
    if it is `-999999`, and if so, branches forward to exit the loop. The code then
    places *x* in the X register. The second `ipt` reads the *y* value and puts it
    in Y.
  prefs: []
  type: TYPE_NORMAL
- en: The second block of `jmp` instructions accumulates each of the totals ➋. Lastly,
    the `gto` branches back to the beginning of the main loop, the first `ipt` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: When the flag value of `-999999` is read, the input file has been processed,
    and execution moves to calculation mode, so it’s time for Equation 13.2\. If we
    look at Equation 13.2, we see that both *a* and *b* depend on Δ. Therefore, we
    split the calculation into finding the numerators for *a* and *b* and then dividing
    by Δ.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 13-15](ch13.xhtml#ch013list15) calculates the numerator for *a*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-15: Calculations in main*'
  prefs: []
  type: TYPE_NORMAL
- en: First, Z is set to 1 to cause the subprograms to return their sums in Y, and
    then the sequence of steps calculates what we need for *a*’s numerator in Equation
    13.2\. The `numA` subprogram, not shown, stores what’s in Z on the first call,
    returning it in Y on all future calls. A similar sequence of steps calculates
    the numerator for *b*, stored in `numB`, and Δ itself in `delta`. The final instructions
    of `main` calculate `numA` divided by `delta` and print it as *a*. Then the same
    is done for *b* using `numB`. The program ends with `hlt`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Discussion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s clear Filska is a limited language, though useful for specific tasks. Many
    programming languages develop idioms, which are snippets of code that show up
    frequently. We developed a Filska idiom above by using a subprogram as a memory
    location with additional functionality, something we showed was similar to a simple
    class in other languages. We used this idiom as a “write once, read many” memory,
    with or without additional processing, or, via a flag in a register, as a read/write
    memory, as we did for the linear least-squares fit example.
  prefs: []
  type: TYPE_NORMAL
- en: Filska does not support arrays, but it is possible to emulate them using subprograms
    as the array elements. We won’t list the code here, but do take a look at *array.filska*,
    an example that creates an array of 10 values. The demo stores values in the array
    by index and then dumps the array in order.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, what should we make of Filska? We’ve seen it implement certain algorithms,
    even ones leading to useful outcomes. Is Filska Turing complete? Although it’s
    true that most imperative programming languages are very likely Turing complete,
    Filska is perhaps not because of its severe memory constraints. Three general-purpose
    registers and one memory location per subprogram might be the limiting factor.
    However, there is no limit to the number of subprograms we can define, and the
    array demo shows how to use that feature to emulate an array that is, in theory,
    as large as we would care to make it. Therefore, we might argue we do have an
    arbitrary amount of data available. In the end, deciding whether Filska is Turing
    complete is beyond what we can reasonably address in this book. Perhaps a theoretical
    computer scientist will take up the challenge and share their results with us.
    If so, check the GitHub site for the book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter used Filska to implement a set of (hopefully) fun math-related
    examples. We got geeky and used curve fitting to produce `HELLO, WORLD!`. We explored
    the Fibonacci sequence, pseudorandom number generation, fractals, roots of equations,
    and fitting a data to a line. In each case, we needed to think carefully about
    the structure of our data and code to make the best use possible of Filska’s severe
    programming constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Filska was designed to calculate, and all of our examples involved math in some
    way. Let’s relax a bit now and consider our second esolang, one designed purely
    for fun, and one that’s considerably simpler in every way. Let’s leave math behind,
    step outside, and watch the fireflies.
  prefs: []
  type: TYPE_NORMAL
