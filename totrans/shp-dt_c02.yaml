- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Geometric Structure of Networks
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Networks, which we briefly encountered in [Chapter 1](c01.xhtml), play an increasingly
    large role in our lives; accordingly, network data plays an increasingly large
    role in data science. How do we measure the influence of a user on social media?
    Or judge the robustness of a computer network against hackers? Or identify people
    who bridge different social groups? These are all questions about the geometric
    structure of networks, and they are all examples of concepts we will explore in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin this chapter with a brief motivational section arguing why network
    data is an important topic in modern data science that greatly benefits from geometric
    reasoning. We’ll then introduce the basic concepts and definitions in network
    theory, which is rooted in the mathematical language of graph theory. The bulk
    of the chapter will be a guided tour of various quantities associated to networks
    and their vertices. We’ll conclude with a quick look at a few different types
    of random networks that have been studied extensively in the literature and are
    easy to generate in the language R.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Network Science
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Network science*, which studies entities through their relationships with
    each other, is an important interdisciplinary subject that has gained momentum
    in data science since the rise of social networks. As we saw in [Chapter 1](c01.xhtml),
    network data is “unstructured” in the usual sense of the term, but it is highly
    structured in other ways. Mathematically, networks are rooted in a subject called
    *graph theory*, which distills entities and relationships down to their abstract
    essence. Networks are geometrically rich, but their geometry is different from
    the usual Euclidean geometry of angles and straight lines. To extract insights
    from networks, we must leave the Euclidean world of spreadsheets and embrace a
    more exotic geometry where spheres look nothing like the round objects we’re used
    to seeing.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider a social media example. Users on a platform such as Facebook
    form a network, and distance can be defined by the smallest number of friendships
    connecting two individuals. This notion of distance underpins several ways of
    measuring a user’s centrality in the network, which we can use to quantify “influencers”
    in various ways. For instance, we could count the number of friends directly connected
    to a Facebook user’s account, or we could count how many friends of friends exist.
    Someone may not have many immediate connections but may have a large number of
    friends who are well connected. In other words, a user may have a large sphere
    of influence even if their immediate circle of friends is small. The geometry
    of networks also allows us to detect outliers by measuring how improbable a user’s
    network is compared to others; this helps social media platforms automatically
    detect inauthentic accounts.
  prefs: []
  type: TYPE_NORMAL
- en: A fascinating application of network-based outlier detection arose in a recent
    state supreme court case on gerrymandering. A conspicuous map of congressional
    districts in Pennsylvania prior to 2018 was widely believed to be the result of
    a partisan gerrymander favoring Republicans, but the court was not convinced until
    a team of experts brought in network science. They showed that one can view a
    districting map as a network, and by computing a random walk in the space of map
    networks to statistically probe the geometry of these networks, they found that
    the Pennsylvania map was several standard deviations away from the mean. The new
    map under consideration at the time was right in the middle of the bell curve
    of maps. They concluded that the old map was highly unlikely to have arisen organically;
    it was so unusual that it must have been deliberately engineered by the mapmakers
    (who were beholden to current Republicans in office) to increase the number of
    seats Republicans would hold. In contrast, the new map was much more typical (and
    a fair representation). The court was convinced by this network analysis and threw
    out the old map in 2018 to adopt the new one.
  prefs: []
  type: TYPE_NORMAL
- en: Even in scenarios that do not outwardly appear to be about networks, there is
    sometimes a way of viewing data as network data—and doing so avails one of a rich
    set of tools that draw from the remarkable geometry of networks.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter focuses on the geometry of networks and how it can be used to define
    a wide collection of metrics that quantify various aspects of the shape and structure
    of a network. In the next chapter, we’ll apply these metrics to explore machine
    learning and other forms of data analysis on network data. Let’s officially begin
    our journey.
  prefs: []
  type: TYPE_NORMAL
- en: The Basics of Network Theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A network conveys pairwise relationships between entities, which can be individuals,
    objects, items, and so on. The entities are represented by *vertices* (also called
    *nodes*), while a relationship between a pair of entities is represented by an
    *edge* connecting the corresponding pair of vertices. Here are a few examples
    of entities and relationships that have been studied as networks: phone calls
    and text messages between people, proteins that interact in a biological pathway,
    towns connected by roads, websites connected by page links, parts of the brain
    activated during the same task, connections between words or parts of speech in
    a language—and that’s just scratching the surface of popular examples.'
  prefs: []
  type: TYPE_NORMAL
- en: When plotting networks, the vertices are depicted as dots that are sometimes
    decorated with symbols so we know which vertex is which; the edges are usually
    straight-line segments, although sometimes it is helpful (for instance, to avoid
    artificial edge crossings) to draw some edges instead as curved arcs. All that
    matters is the collection of vertices and the edges between them—not how long
    the edges are in the plot, the angles between them, or the locations of the vertices.
    In fact, as shown in [Figure 2-1](#figure2-1), the same network can be drawn in
    rather different ways.
  prefs: []
  type: TYPE_NORMAL
- en: These have the same vertices and the same edges connecting the vertices, but
    the plotting of these relationships varies. However we visualize the relationships,
    their underlying structure does not change.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503083c02/f02001_m.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-1: Two different plots of the same network. These have the same vertices
    and the same edges connecting vertices, but the plotting of these relationships
    varies. However we visualize the relationships, their underlying structure does
    not change.'
  prefs: []
  type: TYPE_NORMAL
- en: Directed Networks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A network is *directed* if the edges represent one-way relationships (meaning
    they point from one vertex, called the *source*, to the other vertex, called the
    *target*); otherwise, the edges represent mutual relationships, and the network
    is *undirected*. For instance, for phone conversations, we could create an undirected
    network with an edge between any two people who have talked to each other, or
    we could create a directed network with edges representing outgoing calls from
    the source person to the target person.
  prefs: []
  type: TYPE_NORMAL
- en: 'Concretely, suppose we have three work colleagues: Sadako, Pedro, and Georg.
    Sadako is the project lead and, as such, makes calls to Pedro and Georg. Pedro
    calls Georg regarding a question on the engineering side of the project, but Georg
    does not call Pedro or Sadako. Pedro does not call Sadako, as he has already received
    instructions when she calls him. [Figure 2-2](#figure2-2)(a) shows the undirected
    network for these colleagues, while [Figure 2-2](#figure2-2)(b) shows the directed
    network.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503083c02/f02002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-2: A phone network among three colleagues that is (a) undirected and
    (b) directed'
  prefs: []
  type: TYPE_NORMAL
- en: Other examples of directed networks include travel routes, machine and social
    processes, needle sharing to trace epidemics, and biological process models. Mathematically
    speaking, the biggest difference between Facebook and Twitter is that Facebook
    is an undirected network (friendships are mutual), while Twitter is a directed
    network (users have both followers and accounts followed).
  prefs: []
  type: TYPE_NORMAL
- en: Networks in R
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two main ways of representing a network in a computer. An *edge list*
    simply lists, in an arbitrary order, all the edges in the network by naming the
    two vertices of each edge (if the network is directed, then the first vertex is
    considered the source and the second vertex the target). A useful package for
    working with network data in R is the igraph library (which also exists in Python
    with similar commands and syntax). To create the directed network in [Figure 2-2](#figure2-2)(b)
    from an edge list, you can use the code in [Listing 2-1](#listing2-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-1: A script that generates the directed network in [Figure 2-2](#figure2-2)(b)
    from an edge list'
  prefs: []
  type: TYPE_NORMAL
- en: The other representation of a network is a spreadsheet. If a network has *n*
    vertices, its *adjacency matrix* is the *n*×*n* matrix whose rows and columns
    are indexed by the vertices where 0 in the (*i, j*) entry means there is no edge
    from vertex *i* to vertex *j*, while 1 in this entry means there is such an edge.
    If the network is undirected, then the adjacency matrix is symmetric (equal to
    its own transpose, meaning it is unchanged when swapping its rows with its columns)
    because, in that case, having an edge from vertex *i* to vertex *j* is the same
    as having an edge from vertex *j* to vertex *i*. [Listing 2-2](#listing2-2) provides
    the R code to construct the preceding directed network from an adjacency matrix
    rather than an edge list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-2: A script that generates the directed network in [Figure 2-2](#figure2-2)(b)
    from an adjacency matrix'
  prefs: []
  type: TYPE_NORMAL
- en: 'A major advantage of the adjacency matrix approach is that it puts networks
    into the framework of linear algebra, where many powerful tools are available.
    For instance, we can use the spectral theory (eigenvalues and eigenvectors) of
    the adjacency matrix to measure centrality in a network. Adjacency matrices also
    readily generalize to *weighted networks*; by allowing arbitrary numbers as the
    entries (not just the binary 0 and 1 entries discussed so far), we can assign
    a real-number weight to each edge that conveys the strength of the relationship
    represented by that edge. In practice, this can be used to represent many different
    important notions: volume of calls between colleagues in a phone network, distances
    between locations in a transportation network, and so on. You can think of an
    unweighted network as a weighted network in which all the edges have a weight
    equal to 1\. In fact, this is why in [Listing 2-2](#listing2-2) we set the `weighted`
    parameter to `T` (true) even though we wanted to create an unweighted network—otherwise,
    igraph interprets the adjacency matrix differently.'
  prefs: []
  type: TYPE_NORMAL
- en: Paths and Distance in a Network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two vertices are said to be *neighbors* if they are connected by an edge. Two
    edges in a network are *adjacent* if they have a vertex in common. A *path* in
    a network is a sequence of adjacent edges. If the network is directed, then all
    the edges in a path must be compatibly oriented. For example, in [Figure 2-2](#figure2-2)(b),
    we have a two-edge path from Sadako to Pedro to Georg and a one-edge path from
    Pedro to Georg, but going from Pedro to Sadako to Georg is not a path since the
    edges are not oriented this way.
  prefs: []
  type: TYPE_NORMAL
- en: The *length* of a path has two different meanings, depending on whether the
    network is weighted or unweighted. In an unweighted network, the length of a path
    is the number of edges in the path; in a weighted network, the length is the sum
    of the weights of the edges in the path. The *network distance* between two vertices
    is the length of the minimal-length path connecting them, assuming there is a
    path from one to the other (if there is no path, the network distance is undefined).
    People—us included—usually just say “shortest” path instead of “minimal-length”
    path, because it sounds more natural. This is somewhat misleading for weighted
    networks, as the minimal-length path is actually the path with the lowest weight,
    which may not be the shortest path in terms of the number of edges in the path.
    However, that’s a minor imperfection in terminology we can all live with if we’re
    careful.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s consider the weighted undirected network in [Figure 2-3](#figure2-3),
    representing four towns and the length (in miles) of the roads between them.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503083c02/f02003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-3: A plot of town connectivity and miles of road between connected
    towns'
  prefs: []
  type: TYPE_NORMAL
- en: The shortest path between V2 and V3 is the 8-mile path passing through V4, rather
    than the 12-mile road directly connecting these two towns. The network distance
    between V2 and V3 is therefore 8 miles rather than 12\. Note that the physical
    lengths of the edges and paths in this plot do not in any way represent the lengths
    as defined by the weights; in other words, Euclidean distance in a network plot
    has nothing to do with network distance! The placement of the vertices in a network
    plotted by igraph is chosen for aesthetic reasons (to minimize the number of edge
    crossings, for instance) rather than to reflect edge weights. This can be tricky
    to get used to at first but over time will start to feel natural. [Listing 2-3](#listing2-3)
    provides the R code to create and plot the network in this example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-3: A script that generates the network of connected towns from [Figure
    2-3](#figure2-3) and plots it'
  prefs: []
  type: TYPE_NORMAL
- en: Network distances can play a major role in real-world problems. During the 2018
    Ebola outbreak in the eastern Democratic Republic of the Congo, limited physical
    routes between towns impacted epidemic spread, supply-chain logistics to move
    medical supplies and personnel, and population mixing between impacted towns and
    towns that didn’t have active cases at the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A word of caution about weighted networks: we tend to think of the vertices
    that are near each other (defined by network distance) as being the most closely
    related or the most strongly connected. This means that the smaller the weight
    of an edge, the stronger the relationship it represents. For this reason, you’ll
    often want to use reciprocals when setting the weights in a network. For instance,
    in a weighted phone network, rather than setting the weight between person A and
    person B to be the number of calls *c*[AB] between them, you should set it to
    be the reciprocal 1/*c*[AB] so that people who talk to each other more frequently
    will be closer to (rather than farther from) each other in the weighted network.
    In [Chapter 3](c03.xhtml), we’ll revisit the town network from [Figure 2-3](#figure2-3),
    and we’ll reciprocate the weights so that they represent proximity rather than
    distance.'
  prefs: []
  type: TYPE_NORMAL
- en: To start exploring the geometry established by network distance, we’ll turn
    now to some notions of centrality (which can also be thought of as importance
    or influence) in a network. Since we will rely on igraph throughout this chapter,
    we will no longer include `library(igraph)` in the code snippets; therefore, be
    sure to load this library before running any of the following code samples.
  prefs: []
  type: TYPE_NORMAL
- en: Network Centrality Metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Measuring the *centrality*, or importance, of each vertex in a network allows
    you to manually analyze the structure and functional behavior of networks. It
    is also frequently used for feature extraction, as centrality metrics provide
    numerical features that can be fed into traditional supervised and unsupervised
    machine learning algorithms, as we’ll see in [Chapter 3](c03.xhtml). In other
    words, centrality metrics provide a way to equip network data with more conventional
    spreadsheet structure. There are many methods for quantifying vertex centrality,
    almost all of which involve notions from the preceding section—paths, network
    distance, and the adjacency matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Centrality has many real-world applications. In epidemiology, individuals who
    are more central in contact tracing networks tend to spread disease to more people
    than less central individuals. Indeed, central individuals are typically connected
    to a wider range of people, and additionally central individuals often connect
    groups of people who otherwise would be unlikely to meet—thereby providing bridges
    between these groups across which disease can spread. In social media, central
    individuals are the “influencers” whose opinions are heard by many and spread
    widely. In marketing, central individuals can act as lucrative vectors for advertising
    campaigns. In criminology, identifying central individuals in drug distribution
    or organized crime networks allows law enforcement agencies to target their actions
    most effectively. In scientific research, centrality in citation networks helps
    reveal high-impact publications.
  prefs: []
  type: TYPE_NORMAL
- en: There are more centrality metrics than can be covered in this chapter, so we’ll
    focus on a handful of the popular ones that are implemented in the igraph library.
  prefs: []
  type: TYPE_NORMAL
- en: The Degree of a Vertex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most basic measure of centrality of a vertex is its *degree*, which by
    definition is the number of edges attached to the vertex. In a directed network,
    this can be broken down into two pieces: the *in-degree* counts the number of
    edges with this vertex as the target vertex, and the *out-degree* counts the number
    of edges with this vertex as the source vertex. In a Facebook network, your degree
    is your number of friends; in Twitter, your in-degree is your number of followers,
    and your out-degree is the number of accounts you follow. Going back to [Figure
    2-3](#figure2-3), towns V2 and V3 each have degree 2, while V1 has degree 1 and
    V4 has degree 3.'
  prefs: []
  type: TYPE_NORMAL
- en: In a weighted network, you can also measure the *strength* (also called the
    *weighted degree*) of a vertex, which is the sum of the weights of the edges attached
    to the vertex. In [Figure 2-3](#figure2-3), towns V1, V2, V3, and V4 have strengths
    4, 14, 18, and 12, respectively. Since an unweighted network can be viewed as
    a weighted network in which all edges have weight 1, the vertex degree really
    is just a special case of strength.
  prefs: []
  type: TYPE_NORMAL
- en: Despite its simplicity, the degree of a vertex is a valuable metric. It is the
    one numerical quantity most social media platforms publicly list for each account,
    and it is typically used to determine how much an influencer is paid in a marketing
    campaign to promote a product. However, it has impactful limitations. The degree
    of a vertex measures the size of that vertex’s immediate network of connections,
    but it does not capture the structure of this network nor does it look beyond
    these immediate connections. To illustrate why this matters, consider a Twitter
    user with 10,000 followers, each of whom has only a small number of followers;
    now compare this with a Twitter user who has only a few hundred followers, but
    some of these followers are highly influential users. While the first user has
    a higher degree, which user’s tweets are more likely to receive more retweets
    in the end? This example hints at how networks involve both breadth and depth,
    and degree is more focused on the former.
  prefs: []
  type: TYPE_NORMAL
- en: For another example of what degree does and does not capture, imagine two individuals
    in a contact tracing network. Suppose one user has more contacts (and hence a
    higher degree), but those contacts are mostly all connected to each other anyway,
    whereas the other individual has fewer contacts, but the contacts are spread across
    multiple communities that otherwise have almost no interaction. (We’ll see a concrete
    example of this situation later in this chapter.) Which individual poses a greater
    epidemiological risk during an outbreak?
  prefs: []
  type: TYPE_NORMAL
- en: These two limitations of degree—ignoring network depth and ignoring community-bridging
    properties—are two of the main reasons that we must push deeper into the geometry
    of networks. So, let’s take a brief march through the zoo of vertex centrality
    measures that go beyond degree.
  prefs: []
  type: TYPE_NORMAL
- en: The Closeness of a Vertex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How does one determine whether a vertex is located near the center of a network
    or whether it’s near the periphery? The *closeness* of a vertex, defined as the
    reciprocal of the sum of network distances between this vertex and each other
    vertex in the network, is designed to capture this distinction. A vertex that
    is near the center of the network will have a relatively modest distance to the
    other vertices in the network, but a more peripheral vertex will have a modest
    distance to some vertices but a large distance to the vertices on the “opposite”
    side of the network. This means the sum of distances for a central vertex is smaller
    than the sum of distances for a peripheral vertex; reciprocating this sum flips
    this around so that the closeness score is greater for a central vertex than for
    a peripheral vertex.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 2-3](#figure2-3), you might intuitively guess that V4 is the most
    central, V2 and V3 are moderately central, and V1 is the most peripheral. Indeed,
    if we ignore the edge weights and compute the closeness scores as an unweighted
    network, we get 0.20, 0.25, 0.25, and 0.33 for V1, V2, V3, and V4, respectively.
    For instance, the closeness of V2 is 1/(1 + 1 + 2). When using the edge weights,
    we get closeness scores of 0.05, 0.06, 0.04, and 0.08, so V4 is still the most
    central, but now V3 is the most peripheral; this is because the edge weights make
    V3 have a relatively large network distance from the other vertices.
  prefs: []
  type: TYPE_NORMAL
- en: The Betweenness of a Vertex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *betweenness* of a vertex measures centrality by computing how many paths
    in the network pass through the vertex; more precisely, it is the sum over all
    pairs of other vertices in the network of the fraction of shortest paths between
    the pair of vertices that pass through the vertex in question. When considering
    [Figure 2-3](#figure2-3) as an unweighted network, the betweenness of V1 is 0
    because no shortest paths between the remaining vertices pass through V1\. The
    same is true of V2 and V3\. The betweenness of V4, however, is 2 = 1 + 1 + 0,
    as there is one shortest path between V1 and V2 that passes through V4, there
    is one shortest path between V1 and V3 that passes through V4, and the shortest
    path between V2 and V3 does not pass through V4.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 2-4](#figure2-4), each vertex has a betweenness score of 0.5\. For
    instance, for V1 the one-edge path between V2 and V4 does not pass through V1,
    the one-edge path between V3 and V4 does not pass through V1, and between V2 and
    V3 there are two shortest paths, one of which passes through V1, combining to
    give a betweenness score of 0 + 0 + 1/2.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503083c02/f02004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-4: A network with four vertices connecting as a square'
  prefs: []
  type: TYPE_NORMAL
- en: If you think of a network as encoding the ways that something (materials, information,
    disease, traffic, and so on) can travel between entities, then shortest paths
    are the most efficient travel routes. Betweenness centrality measures how disruptive
    removing a vertex would be to these routes. For example, in a shipping distribution
    network, the betweenness of a vertex indicates the number of shipping routes that
    would be impacted if a particular distribution center is shut down (not counting
    routes originating or terminating at that distribution center), weighted by the
    extent of this impact. In [Figure 2-3](#figure2-3) (viewed as an unweighted network),
    removing V1 does not affect the shipping routes among the other cities (betweenness
    score of 0), but removing V4 completely takes away two shipping routes (betweenness
    score of 2). In [Figure 2-4](#figure2-4), removing V1 impacts transportation between
    V2 and V3, but it takes out only half of the shipping routes between them (betweenness
    score of 0.5). Betweenness centrality’s use in estimating disruptive potential
    has found many practical applications; for instance, it identifies important servers
    to protect in a computer network (or which ones would be most effective to target
    in an adversarial attack!).
  prefs: []
  type: TYPE_NORMAL
- en: While closeness and betweenness measure rather different aspects of the centrality
    of a vertex, they are both based on shortest paths in the network. Shortest paths
    between points have a special name in geometry, *geodesics*, and we’ll return
    to them in much more generality in Chapters [4](c04.xhtml), 5, and [6](c06.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: All the remaining centrality measures that we’ll cover in this section are based
    on the adjacency matrix, and they can be thought of as variants of the famous
    PageRank algorithm that Google initially used (and still uses in some capacity)
    to rank search results by estimating importance in the directed network whose
    vertices are websites and whose edges are links. The math involved in these next
    centrality measures is heavier, but we’ll try to highlight the main ideas and
    big picture. Practically speaking, it is far more important to develop an intuition
    for what these centrality scores convey than to understand the details of their
    computation.
  prefs: []
  type: TYPE_NORMAL
- en: Eigenvector Centrality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adjacency matrix-based centrality measures aim to capture the basic idea that
    the importance of a vertex is determined by the importance of the vertices to
    which it is connected. This is where the notion of *network depth* alluded to
    earlier comes in. On social media, for instance, it isn’t just your number of
    followers that matters, it is the number of followers your followers have, the
    number of followers they have, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make this idea precise. Suppose we want to assign an importance score
    *x*[*i*] to each vertex *i*. A simple model is to assume that the importance of
    each vertex is proportional to a weighted sum of the importances of the neighboring
    vertices:'
  prefs: []
  type: TYPE_NORMAL
- en: x[i] = c∑[^(a[ij]x[j])]
  prefs: []
  type: TYPE_NORMAL
- en: 'where the sum is over vertices *j* that are neighbors to vertex *i*, *a*[*ij*]
    is the weight of the edge between vertex *i* and vertex *j*, and *c* is a constant
    of proportionality that we’ll assume is independent of *i*. This formula can be
    expressed as the matrix equation:'
  prefs: []
  type: TYPE_NORMAL
- en: x⃗ = cAx⃗
  prefs: []
  type: TYPE_NORMAL
- en: where ***A*** is the adjacency matrix of the network. You might recall from
    linear algebra that this equation stipulates that the vector of vertex importances
    *x⃗* is an *eigenvector* for the adjacency matrix, and 1/*c* is the corresponding
    *eigenvalue*. When viewing a matrix as a linear transformation, the eigenvectors
    are the directions that get stretched but not rotated, and the eigenvalues measure
    how much these directions are stretched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Matrices typically have many different eigenvectors and eigenvalues, and the
    eigenvalues need not be real numbers, so at first glance there could be many different
    solutions to the preceding vertex assignment problem—some of which may involve
    complex values. Fortunately, however, if we disallow negative edge weights and
    importance scores, then something called the *Perron–Frobenius theorem* guarantees
    that we can find a unique real-valued solution to this vertex assignment problem.
    In other words, with this non-negativity condition there is always exactly one
    way of assigning importance scores to all the vertices in the network that satisfy
    all of our linear neighbor influence conditions. Well, almost: to get uniqueness,
    we need to normalize the importance scores (for instance, by scaling so that the
    largest importance score of any vertex in the network is 1). Doing this yields
    the *eigenvector centrality* scores for vertices.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 2-3](#figure2-3), the eigenvector centrality scores (rounded to the
    nearest one-hundredth) for V1, V2, V3, and V4, when viewed as an unweighted network,
    are 0.46, 0.85, 0.85, and 1, respectively. This matches our intuition that V4
    is the most central and V1 is the least central. When computed as a weighted network,
    using the edge weights shown in that figure, the scores are instead 0.16, 0.91,
    1, and 0.59\. So, in the weighted network, V1 is still the least central, but
    the most central is V3.
  prefs: []
  type: TYPE_NORMAL
- en: The main point of eigenvector centrality is that it is higher for vertices that
    neighbor vertices with higher eigenvector centrality scores. In social network
    terms, this means your importance is determined by the importance of your friends.
  prefs: []
  type: TYPE_NORMAL
- en: We can interpret eigenvector centrality more precisely by thinking in terms
    of random walks. Imagine you start at a random vertex and repeatedly take steps
    by choosing one of the edges attached to your current vertex at random. If the
    network is unweighted, then you choose these edges with equal probability, whereas
    if the network is weighted, then the probabilities for selecting the edges are
    proportional to the edge weights. The eigenvector centrality scores are proportional
    to the fraction of time you spend at each vertex when doing these random walks.
    For example, if the network represents the World Wide Web (where vertices are
    websites and edges are links), then eigenvector centrality conveys the amount
    of traffic each site gets if users just randomly click links.
  prefs: []
  type: TYPE_NORMAL
- en: 'One drawback with eigenvector centrality is that random walkers can never travel
    between two different parts of a network if there are no paths connecting the
    two parts. In other words, each random walker is constrained to the “island” (or,
    in more mathematical terms, *connected component*) it starts on. This is especially
    problematic for directed networks because edges can be traversed in only one direction:
    if the random walker reaches a dead end, it will remain stuck there forever. One
    way to help get our random walkers past islands and dead ends is to allow them
    to randomly jump to different locations in the network. That’s the main idea behind
    the next measure we’ll look at.'
  prefs: []
  type: TYPE_NORMAL
- en: PageRank Centrality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Google’s *PageRank centrality* is only a small modification of eigenvector centrality;
    it replaces the adjacency matrix with a scaled version before computing the eigenvector.
    The PageRank scores for V1, V2, V3, and V4 in [Figure 2-3](#figure2-3), computed
    as an unweighted network, are 0.13, 0.25, 0.25, and 0.37, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to understand PageRank is in terms of random walk probabilities.
    We play the same game as we did with eigenvector centrality, except now at each
    step there are two possibilities: the random walker either walks across one of
    the attached edges, as before, or jumps directly to a random vertex in the network.
    In the World Wide Web example, this means either people can click links or they
    can directly type URLs in their web browsers. This ability to jump helps the random
    walkers explore greater extents of the network, which helps boost the information
    captured by this centrality score compared to eigenvector centrality.'
  prefs: []
  type: TYPE_NORMAL
- en: Katz Centrality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another useful centrality measure that is also computed from the spectral theory
    of the network’s adjacency matrix is *Katz centrality* (sometimes called *Bonacich
    centrality* or *alpha centrality*), which is essentially a “higher-order” extension
    of the notion of degree. In an unweighted network, Katz centrality is a weighted
    sum of the number of vertices that can be reached by a path of length 1 (this
    coincides with the degree), the number of vertices that can be reached by a path
    of length 2, the number that can be reached by a path of length 3, and so on.
    The weights in this weighted sum are determined by the length of the path and
    by a user-specified “attenuation” parameter (called *alpha*) that ranges from
    0 to 1\. More precisely, paths of length *d* are given weight *α*^(*d*). This
    means that the farther away a vertex is, the less it contributes to the weighted
    sum.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in social networks or social media, the biggest contributor to
    your Katz centrality is your number of friends, the next biggest contributors
    are the numbers of friends these friends have, and so on. In short, Katz centrality
    is a more sophisticated version of degree that looks deeper into your network’s
    overall connectivity. It turns out that eigenvector centrality is a limit of Katz
    centrality as the attenuation parameter approaches a certain value. Be careful
    when choosing the parameter alpha, though; you should always choose it to be less
    than the reciprocal of something called the *spectral radius* of the network (which
    we’ll cover in the “Global Network Metrics” section); igraph won’t give you an
    error or even a warning message if you don’t do this—you’ll just get values that
    don’t make sense, such as negative scores for some vertices.
  prefs: []
  type: TYPE_NORMAL
- en: Hub and Authority
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another way to generalize eigenvector centrality is to provide each vertex
    with two separate importance scores rather than just one. The most popular incarnation
    of this is called *authority and hubness*. Conceptually, *authority centrality*
    measures how much knowledge of the network is stored within a vertex, while *hub
    centrality* measures how well a vertex knows where to find this knowledge (quick
    access to the information stored in nearby vertices). These two measures are interrelated:
    strong hubs tend to connect to strong authorities. Hubs usually have a high rate
    of connections among the vertices involved that allow for rapid information sharing.'
  prefs: []
  type: TYPE_NORMAL
- en: Measuring Centrality in an Example Social Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To better understand all these vertex centrality measures, it helps to consider
    a more interesting example of a network than what we’ve considered so far. The
    script in [Listing 2-4](#listing2-4) loads and then plots a network from a file
    that represents a social network of one of this book’s authors (Farrelly). You
    can find the dataset, along with the other files for the book, on the book’s web
    page: [https://nostarch.com/shapeofdata](https://nostarch.com/shapeofdata).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-4: A script that loads a social network dataset, converts it to a
    graph object, and then plots it'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-5](#figure2-5) shows the resulting network plot (which will look
    a little different each time you run this script).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503083c02/f02005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-5: A plot of Farrelly’s social network dataset, including connections
    within her medical school service groups (top cluster) and her veterans organization
    groups (bottom cluster), with vertex 7 (Farrelly herself) serving as a bridge'
  prefs: []
  type: TYPE_NORMAL
- en: One of the best ways to develop an intuition for centrality measures is to plot
    them as the vertex size parameter. (More generally, using vertex size to illustrate
    any numerical property associated to the vertices of a network is an excellent
    visualization technique—it is a network version of bubble charts.) Since the range
    of the different centrality measures varies, in what follows we rescale each one
    so that the maximum value is 20, as this seems to give fairly readable plots.
    [Listing 2-5](#listing2-5) provides the R code we use to plot each one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-5: A script that creates bubble chart network plots for each centrality
    measure on Farrelly’s social network dataset'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with closeness and betweenness, illustrated in [Figure 2-6](#figure2-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503083c02/f02006_m.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-6: Bubble charts of closeness centrality (left) and betweenness centrality
    (right) on Farrelly’s social network data'
  prefs: []
  type: TYPE_NORMAL
- en: The closeness scores here appear to capture what we were hoping they would.
    Vertices that are located more centrally in the network are larger, and vertices
    that are more peripheral are smaller. Note that this notion of centrality is based
    on the global geometry of the network. For instance, V10 has the highest closeness
    centrality score because it is central to the network overall even though it is
    peripheral to each of the two main clusters (the medical school friends and the
    veteran friends).
  prefs: []
  type: TYPE_NORMAL
- en: Betweenness centrality (which, as you recall, aims to capture locations that
    when removed would be maximally disruptive to flow across the network) provides
    V7 and V10 with much larger scores than all the other vertices—and these are the
    two vertices that bridge the two main clusters in this network. There is also
    a more modest but still relatively large betweenness score for V14, indicating
    that many (but not all) shortest paths between the two main clusters pass through
    this vertex.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s take a look at the eigenvector centrality and PageRank centrality
    scores shown in [Figure 2-7](#figure2-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503083c02/f02007_m.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-7: Bubble charts of eigenvector centrality (left) and PageRank centrality
    (right) on Farrelly’s social network data'
  prefs: []
  type: TYPE_NORMAL
- en: For both of these measures, V7 (representing Farrelly herself) has the highest
    value, and the values range across the medical school cluster in a way that—at
    least intuitively—does appear to capture a notion of centrality or importance.
    Perhaps the most striking thing about this figure is the contrast between these
    two closely related eigenvector-based measures. For eigenvector centrality, the
    values in the medical school cluster completely dwarf those of the veterans organization
    cluster, whereas PageRank centrality seems better able to reflect centrality and
    importance within each of the two clusters separately. The reason for this discrepancy
    is that random walks in which one simply chooses neighboring vertices to traverse
    with equal probability tend to meander around the highly interconnected medical
    school cluster and have a low probability of taking the one edge (from V7 to V10)
    that leads out of that cluster. With PageRank centrality, the random walks include
    a fixed probability of jumping anywhere in the network, which helps them get to
    the veterans group cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 2-8](#figure2-8) we have Katz centrality, which as you recall is
    a higher-order version of degree that takes into account not just the number of
    neighbors but the number of neighbors of neighbors, and so on. We compute this
    for two different values of the attenuation parameter alpha by specifying the
    decay rate for the influence coming from higher-order connections.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503083c02/f02008_m.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-8: Bubble charts of Katz centrality for attenuation parameter alpha
    = 0.2 (left) and alpha = 0.1 (right) on Farrelly’s social network data'
  prefs: []
  type: TYPE_NORMAL
- en: It turns out the spectral radius for this network is about 4, so we need to
    choose values of alpha that are less than 0.25 (here, 0.2 and 0.1). We see here
    that both choices identified Farrelly’s V7 as the most central vertex, but for
    the higher of these two alpha parameters (left plot), the scores remain relatively
    high near V7 before dissipating rather quickly. With the smaller alpha (right
    plot), the dissipation is less sharp, and the Katz centrality scores are more
    evenly spread out across the entirety of the network. The plot on the left is
    more likely to capture what we typically think of as centrality or importance,
    and it is usually recommended to choose an alpha very close to the reciprocal
    of the spectral radius (and definitely not the default value of 1 in igraph).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s analyze authority and hubness. In an undirected network, these
    two measures coincide, so let’s first transform our network into a directed network.
    Since we don’t have a natural direction to the friendships in this social network,
    we’ll do this artificially as follows. For each edge in this network, say between
    vertex *i* and vertex *j*, with probability one out of three, we’ll convert it
    to a one-way edge from *i* to *j*, with probability one out of three, we’ll convert
    it to a one-way edge from *j* to *i*, and with probability one out of three we’ll
    leave it as a two-way edge. [Listing 2-6](#listing2-6) shows the code to do this
    and then plot the resulting hub and authority scores.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-6: A script that turns Farrelly’s social network into a directed
    network and then plots the resulting hub and authority scores'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-9](#figure2-9) shows the resulting plots.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503083c02/f02009_m.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-9: Bubble charts of hub centrality (left) and authority centrality
    (right) on a directed version of Farrelly’s social network'
  prefs: []
  type: TYPE_NORMAL
- en: There are higher hub scores among the medical school individuals than the veterans
    group individuals due to the high level of interconnectivity of the former, with
    Farrelly’s vertex V7 serving as a prominent hub in this network. Many of the medical
    school individuals point to V5 and V3, giving these vertices large authority scores,
    while V7 has a relatively modest authority score. This suggests that V3 and V5
    are the primary sources of information within this community, and they pass this
    information along to V7, who shares it with the rest of the medical school individuals;
    in contrast, there is not much of a centralized structure or efficient flow of
    information among the veterans group’s individuals.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve explored all these centrality measures visually, let’s use a
    few of them to rank and compare the vertices in Farrelly’s social network (going
    back to the original undirected version). The code in [Listing 2-7](#listing2-7)
    can be added to that of [Listing 2-4](#listing2-4) to produce a dataset of some
    centrality measures.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-7: A script that creates a table of a few vertex centrality scores
    on Farrelly’s social network'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 2-1](#table2-1) displays these vertex scores, with the highest two entries
    in each column in bold.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-1: Centrality Measures Scored on the Vertices of Farrelly’s Social
    Network'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Vertex** | **PageRank** | **Degree** | **Hub score** | **Betweenness**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| V1 | 0.032 | 2 | 0.414 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| V2 | 0.020 | 1 | 0.168 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| V3 | **0.075** | **5** | 0.682 | 19.500 |'
  prefs: []
  type: TYPE_TB
- en: '| V4 | 0.032 | 2 | 0.370 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| V5 | 0.057 | 4 | **0.685** | 2.000 |'
  prefs: []
  type: TYPE_TB
- en: '| V6 | 0.046 | 3 | 0.505 | 1.000 |'
  prefs: []
  type: TYPE_TB
- en: '| V7 | **0.111** | **8** | **1.000** | **100.500** |'
  prefs: []
  type: TYPE_TB
- en: '| V8 | 0.044 | 3 | 0.550 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| V9 | 0.044 | 3 | 0.550 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| V10 | 0.048 | 3 | 0.306 | **90.917** |'
  prefs: []
  type: TYPE_TB
- en: '| V11 | 0.050 | 3 | 0.118 | 26.667 |'
  prefs: []
  type: TYPE_TB
- en: '| V12 | 0.022 | 1 | 0.021 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| V13 | 0.069 | 4 | 0.087 | 18.917 |'
  prefs: []
  type: TYPE_TB
- en: '| V14 | 0.067 | 4 | 0.127 | 61.083 |'
  prefs: []
  type: TYPE_TB
- en: '| V15 | 0.068 | 4 | 0.088 | 36.000 |'
  prefs: []
  type: TYPE_TB
- en: '| V16 | 0.040 | 2 | 0.024 | 23.083 |'
  prefs: []
  type: TYPE_TB
- en: '| V17 | 0.040 | 2 | 0.034 | 21.917 |'
  prefs: []
  type: TYPE_TB
- en: '| V18 | 0.065 | 3 | 0.009 | 20.250 |'
  prefs: []
  type: TYPE_TB
- en: '| V19 | 0.043 | 2 | 0.011 | 10.167 |'
  prefs: []
  type: TYPE_TB
- en: '| V20 | 0.026 | 1 | 0.002 | 0 |'
  prefs: []
  type: TYPE_TB
- en: By a considerable margin, betweenness identifies V7 and V10 as the most important
    vertices connecting the network. However, the other centrality scores for V10
    are much more modest, suggesting it mainly functions as a bridge between communities
    rather than a true center of the network. This makes sense as V10 appears fairly
    undistinguished within the veterans group. It just happens to connect to Farrelly’s
    V7 and, hence, through her to the medical school community. Farrelly’s V7, on
    the other hand, has many neighbors (as indicated by degree) and is the top-ranked
    vertex for both hub score and PageRank—this is compatible with our conceptual
    understanding of this network as conveying two separate communities in which Farrelly
    is involved.
  prefs: []
  type: TYPE_NORMAL
- en: V3 is the second-highest ranked vertex in terms of degree and PageRank; this
    person appears to be at the social center of the medical school community. V5
    has the second-highest hub score, indicating that it is close to the important
    members of the medical school community. Hub score (which coincides with authority
    here since this network is undirected) also distinguishes V12 from V20\. Both
    of these are degree-one vertices in the periphery of the veterans group’s community
    and with low PageRank and zero betweenness. However, V12 has a higher hub score
    because it is near a highly interconnected little subcommunity.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Quantities of a Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Network geometry provides more than just centrality measures for vertices. In
    this section, we’ll introduce a few other quantities of interest associated to
    the vertices in a network. Examples include transitivity scores that capture how
    likely it is that your friends know each other, efficiency scores that capture
    how much traffic is diverted when vertices are removed, and curvature scores that
    capture distortions in the fabric of the network.
  prefs: []
  type: TYPE_NORMAL
- en: The Diversity of a Vertex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While hub and authority centrality concern the potential flow of information
    through a directed network, another measure associated to the vertices in a weighted
    network concerns information in the sense of mathematical information theory.
    The *diversity* of a vertex is a scaled version of the Shannon entropy (a fractional
    measure of information content of a variable or set of variables) of the weight
    distribution of the edges attached to that vertex. As the name suggests, this
    captures the diversity of edge weights attached to each vertex. Entropy is maximal
    for a uniform distribution, so the diversity score is maximal (and scaled to 1)
    when all the edges have equal weights, and the diversity scores decrease from
    this value as the weights become more varied. One way to think about this is that
    a random walk on a weighted network (with probabilities proportional to the edge
    weights) will be least predictable at vertices with diversity scores closest to
    1 and more predictable for vertices with smaller diversity scores.
  prefs: []
  type: TYPE_NORMAL
- en: Triadic Closure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A useful notion in network theory is *triadic closure*, which is the tendency
    for triangles to form among triples of vertices that already have a pair of edges.
    In more down-to-earth terms, this is akin to asking whether two of your friends
    are likely to be friends with each other. Consider the network of friends depicted
    in [Figure 2-10](#figure2-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503083c02/f02010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-10: A network of friendships with one friendship link unknown, illustrating
    the concept of triadic closure'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, Justin and Jason are friends, as are Justin and Mick. The question is
    whether Jason and Mick are friends. This situation is called a *triangle* centered
    at Justin. If Jason and Mick are not friends, then it is called an *open* triangle,
    whereas if they are friends, then it is called a *closed* triangle. A network
    with mostly closed triangles suggests a high degree of cohesion. In social networks,
    this means individuals with a mutual friend are likely to know each other. On
    the other hand, a network with many open triangles may indicate a less cohesive
    situation but could also indicate missing data and incomplete information: people
    may not friend all of their real-world friends on social media, intelligence data
    may not contain all communication forms among a cell of terrorists, and so on.
    In any real-world setting, relationships may exist that simply haven’t been recorded
    yet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to quantify triadic closure is through *transitivity*, which assigns
    to each vertex the fraction of triangles centered at it that are closed. In a
    social network, your transitivity is the probability that two of your friends
    are friends with each other. Let’s add the following to our collection of plots
    from [Listing 2-6](#listing2-6):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Setting the parameter called `type` to `local` tells igraph to compute the transitivity
    around each vertex, and setting the parameter called `isolates` to `zero` forces
    the score for vertices of degree 1 to be 0 (which otherwise would be scored `NaN`,
    as a degree-1 vertex has no triangles centered at it). [Figure 2-11](#figure2-11)
    shows the resulting plot.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503083c02/f02011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-11: A bubble chart of transitivity on Farrelly’s social network'
  prefs: []
  type: TYPE_NORMAL
- en: This shows from another perspective that the medical school community is more
    cohesive and more tightly interconnected than the veterans’ community. It’s likely
    that medical students involved in the same sort of extracurricular activities
    in the same classes know each other and communicate. Note, however, that Farrelly’s
    V7 has a relatively low transitivity score among the medical school individuals,
    meaning several of Farrelly’s medical school friends are not friends with each
    other despite the overall closeness of that group. (The transitivity of V7 is
    also dragged down by the fact that none of Farrelly’s medical school friends are
    friends with the veterans group’s friend V10.)
  prefs: []
  type: TYPE_NORMAL
- en: The Efficiency and Eccentricity of a Vertex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall that two of the centrality measures we covered, closeness and betweenness,
    are defined in terms of the lengths of the shortest paths (or *geodesics*) in
    the network. Another interesting measure based on shortest paths, called *efficiency*,
    is defined for each vertex as follows: remove the vertex in question and then
    compute the resulting network distances between all pairs of neighbors of this
    vertex. Then, average the inverses of these distances. Removing the vertex is
    like creating a roadblock, and the neighbor-to-neighbor distances measure the
    length of the detours that must be taken because of the roadblock. Inverting these
    distances means bigger detours count toward smaller efficiencies, and vice versa.
    The efficiency measures how easily traffic can be diverted around each vertex
    in the network.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Efficiency is a useful way to probe the local geometry of the network. The
    word *local* here means we are exploring the network geometry nearby around each
    vertex; this is in contrast to closeness and betweenness that are more global
    in nature since they involve paths across the entire network. Let’s add the computation
    of efficiency to [Listing 2-6](#listing2-6). We need an additional library to
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We don’t show the bubble chart plot for this because it looks extremely similar
    to the transitivity plot in [Figure 2-11](#figure2-11). In fact, the correlation
    between the transitivity scores and the efficiency scores for this network is
    0.96\. In other networks, especially larger and more complex ones, this need not
    be the case. It is important to note that transitivity is an extremely local measure,
    as it considers only neighboring vertices and the edges among them. In contrast,
    efficiency is local in nature but can access larger pieces of the network because
    the detours caused by the roadblocks may extend beyond the set of immediate neighbors.
  prefs: []
  type: TYPE_NORMAL
- en: Another path-based vertex measure that—like closeness and betweenness—sees the
    global geometry of the network is *eccentricity*, which assigns to each vertex
    the largest network distance from that vertex to any other vertex in the network.
    This measures how peripheral each vertex is, so lower eccentricity scores generally
    indicate more central vertices. We’ll come back to this measure shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Forman–Ricci Curvature
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Ricci curvature* is a concept in geometry that measures the distortion of
    straight lines on curved surfaces and the rate at which this distortion grows
    or shrinks. You can think of it as a force of sorts that warps straight lines
    into curved paths (like a small hand weight on a wet paper towel). See [Figure
    2-12](#figure2-12) for a conceptual illustration of increasing Ricci curvature
    from left to right on the diagram.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503083c02/f02012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-12: A straight line with midpoint deformed by sliding it (from left
    to right) through spaces with increasing Ricci curvature'
  prefs: []
  type: TYPE_NORMAL
- en: One of the adaptations of this concept from continuous geometry to the realm
    of networks is called *Forman–Ricci curvature*. The first step in calculating
    Forman–Ricci curvature is to assign a number to each edge in the network that
    measures how spread out the network is in the immediate vicinity of the edge.
    The number that is used is 2 minus the sum of the degrees of the two vertices
    attached to the edge; this is the negated number of edges adjacent to the edge
    in question. For example, in Farrelly’s social network ([Figure 2-5](#figure2-5)),
    the edge between V7 and V10 has a Forman–Ricci curvature of –8 (coming from the
    six non-V10 neighbors of V7 and the two non-V7 neighbors of V10).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use these edge scores to assign scores to the vertices as follows:
    the Forman–Ricci curvature of a vertex is the sum of the Forman–Ricci curvatures
    of the edges attached to this vertex. Forman–Ricci curvature is almost always
    negative, so when visualizing it, we usually use its negation. In [Listing 2-8](#listing2-8)
    we compute the Forman–Ricci curvature for Farrelly’s social network and then plot
    it using its negation for the vertex size and edge thickness.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-8: A script that computes and plots the Forman–Ricci curvature for
    Farrelly’s social network'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-13](#figure2-13) shows the resulting plot.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503083c02/f02013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-13: The negated Forman–Ricci curvature for Farrelly’s social network'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the areas of the network with more edges have a higher negated
    Forman–Ricci curvature. This occurs both in hublike regions where the network
    fans out (like in the medical school community here surrounding Farrelly’s V7)
    and in tightly interconnected regions (like the close-knit four-vertex subcommunity
    within the veterans group’s members).
  prefs: []
  type: TYPE_NORMAL
- en: In traditional geometry, curvature is used to study how substances flow across
    objects. Similarly, Forman–Ricci curvature can be used to study network flow patterns.
    We’ll turn to the concept of network flow in [Chapter 3](c03.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Global Network Metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the metrics discussed so far are *vertex metrics*, meaning they assign a
    score to each vertex in a network, quantifying some aspect of the vertex’s role
    or position within the network. For example, you could extract your network of
    Facebook friends and use these vertex metrics to measure how central each person
    is in it. However, sometimes instead of comparing vertices within a single network,
    we need to compare different networks. For example, you might want to compare
    your Facebook friend network to the Facebook friend network of someone else—or
    you could compare your friend network on Facebook to your friend network on a
    different social media platform. In this situation, we need metrics that assign
    a single number to an entire network; these are sometimes called *global network
    metrics*, or just *global metrics* if the network context is clear. Let’s walk
    through a few important ones.
  prefs: []
  type: TYPE_NORMAL
- en: The Interconnectivity of a Network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest global metrics are the number of vertices in a network and the
    number of edges. Closely related to these (but often more useful) is the *density*,
    which is the number of edges in a network divided by the maximum number of edges
    possible on that vertex set. An undirected network with *n* vertices has at most
  prefs: []
  type: TYPE_NORMAL
- en: '![c02eq001](image_fi/503083c02/c02eq001.png)'
  prefs: []
  type: TYPE_IMG
- en: edges (not allowing loops or multiple edges), while the maximum number for a
    directed network is twice this amount. Density gives a coarse measure of how interconnected
    a network is; it is computed in igraph with the `edge_density()` function. [Figure
    2-14](#figure2-14) shows some networks with a range of densities.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503083c02/f02014_m.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-14: The three networks in the top row all have a density of 25 percent,
    while the networks in the bottom left and bottom right have densities of 50 percent
    and 75 percent, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: The average degree in a network can also be a useful global metric, but it contains
    precisely the same information as the density and is perfectly correlated with
    it. Indeed, the average degree is the sum of all vertex degrees divided by the
    number of vertices, and the sum of all vertex degrees is always twice the number
    of edges. Thus, average degree and edge density differ by a constant that depends
    only on the number of vertices in the network. Consequently, you can use one or
    the other measure, but nothing is gained by using both simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: The notion of transitivity discussed in the preceding section (quantifying triadic
    closure) has a global counterpart. When setting the type parameter to `global`
    in igraph’s `transitivity()` function, a single number is computed that gives
    the fraction of triangles in the network that are closed. This gives another way,
    different from edge density, to measure the overall interconnectedness of a network.
  prefs: []
  type: TYPE_NORMAL
- en: Spreading Processes on a Network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Networks that are more spread out tend to behave differently than ones that
    are more compact. For example, consider three friends—Amara, Imani, and Taraji—sharing
    news with each other at a lunch table. We’d expect the girls to exchange information
    more easily together at a table than they would if they were in separate classes
    texting each other or talking as they passed each other in the hallway. Let’s
    take a look at a few different ways to quantify the spread of a network.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the `type` parameter to `global` in igraph’s `efficiency()` function
    gives a global version of that metric that computes the average of the inverses
    of the network distances between all pairs of vertices in the network. No roadblocks
    are involved in this global variant of efficiency. Networks that are highly interconnected
    tend to have high global efficiency, as high interconnectivity means there are
    lots of direct routes between vertices, but, overall, it is best to think of global
    efficiency as a measure of the compactness of a network. The more spread out a
    network, the lower its global efficiency will be.
  prefs: []
  type: TYPE_NORMAL
- en: We can also compute the *diameter* of a network, which is the maximum eccentricity
    of the vertices in the network (and, hence, the “longest shortest path” between
    two vertices). The *radius* of a network is the minimum eccentricity, which measures
    how far the center of the network is from the most distant part of the network.
    In igraph, you can use the `eccentricity()` function first to score all the vertices
    and then use standard R commands to extract the maximum and minimum values from
    them. Both diameter and radius quantify some aspect of the spread of the data.
    One structure that can produce a large difference between the diameter and radius
    is a structure where there are several loose hubs connected to each other through
    a single bridging individual.
  prefs: []
  type: TYPE_NORMAL
- en: Spectral Measures of a Network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have seen that eigenvectors of the adjacency matrix and other matrices closely
    related to it play an important role in multiple vertex centrality metrics; the
    spectral theory (eigenvalues and eigenvectors) of the adjacency matrix also provides
    us with some useful global metrics. The *spectral radius* of a network (which
    came up earlier in our discussion of Katz centrality) is the largest eigenvalue
    of the adjacency matrix. A variety of properties of the spectral radius have been
    established mathematically. In essence, the spectral radius measures propagation
    across the network. It is inversely related to the robustness of the network when
    considering the spread of a harmful entity across the network, such as fake news
    or a virus. For instance, in an epidemiological model that we’ll discuss in the
    next chapter, a smaller spectral radius means disease spreading across the network
    will die out more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: To compute the spectral radius of a network in R, you can use the `spectrum()`
    function in igraph that takes advantage of the sparse structure that adjacency
    matrices usually exhibit, or you can use any of the standard eigenvector or eigenvalue
    implementations in R, such as the `eigen()` function, on the network’s adjacency
    matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Since igraph’s `spectrum()` function optionally returns all eigenvalues and
    eigenvectors of the adjacency matrix, it is easy to use it to compute other spectral
    measures—such as the *spectral gap*, which is the difference between the largest
    eigenvalue of the adjacency matrix (the spectral radius) and the second largest
    eigenvalue. The spectral gap controls the convergence time of certain algorithms
    and random processes on the network, among other things. Other useful spectral
    measures are based on a variant of the adjacency matrix called the *graph Laplacian*,
    which is obtained by negating the adjacency matrix and adding the degree of each
    vertex to the corresponding diagonal matrix entry. The multiplicity of the 0 eigenvalue
    of the graph Laplacian is the number of connected components of the network. The
    smallest nonzero eigenvalue of the graph Laplacian is called the *algebraic connectivity*;
    this is a connectivity measure of the network that conveys how difficult it is
    to fragment the network into smaller pieces. Farrelly’s social network has a relatively
    low algebraic connectivity because removing a single vertex splits the network
    into the veterans group and the medical school group.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-9](#listing2-9) shows how to compute the graph Laplacian and extract
    from it the number of connected components and the algebraic connectivity.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-9: A script that computes the graph Laplacian of a network `g` and
    then extracts from it the number of connected components and the algebraic connectivity'
  prefs: []
  type: TYPE_NORMAL
- en: For example, running this code on the two networks shown in [Figure 2-15](#figure2-15)
    gives seven connected components each and an algebraic connectivity of 0.062 for
    the network on the left and 0.09 for the network on the right.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503083c02/f02015_m.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-15: Two networks, plotted to illustrate the spectral measures associated
    with the graph Laplacian matrix. They have the same number of connected components,
    but the network on the right has a higher algebraic connectivity.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to compare scores across networks of different sizes, it is better
    to use the normalized Laplacian; to do this, simply set `normalized=T` when computing
    the graph Laplacian in the first line of [Listing 2-9](#listing2-9).
  prefs: []
  type: TYPE_NORMAL
- en: Network Models for Real-World Behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few different types of networks that serve as important models for
    real-world behavior; these provide helpful baselines against which to compare
    real-world networks and data. Let’s start with the simplest kind to construct.
  prefs: []
  type: TYPE_NORMAL
- en: Erdös–Renyi Graphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Erdös–Renyi graphs* are networks in which edges are generated randomly according
    to a uniform distribution on the set of vertex pairs. These are created in igraph
    with the `sample_gnp()` function. Both the networks in [Figure 2-15](#figure2-15)
    were produced by using `sample_gnp(50,0.05)`, which creates a network with 50
    vertices and an edge probability of 5 percent. The density of the graphs created
    this way will be close to the specified edge probability but not necessarily equal
    to it—just as repeatedly flipping a fair coin won’t always give exactly half heads
    and half tails. The networks in [Figure 2-14](#figure2-14) were also created with
    `sample_gnp()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Erdös–Renyi graphs provide a useful null hypothesis. If you believe your network
    is highly structured, then its edges should be very far from uniformly distributed,
    so the network will not look or behave like an Erdös–Renyi network. In the next
    two chapters, we’ll see how to practically implement this idea. Erdös–Renyi graphs
    do not appear often in nature, especially in socially driven settings. Real networks
    are almost always more structured than a network with purely random edges like
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Scale-Free Graphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *scale-free graph* is a network whose degree distribution asymptotically follows
    a power law, meaning there is a constant, *c,* such that the fraction of vertices
    of degree 2*d* is 1/2^(*c*) times the fraction of vertices of degree *d* (at least
    approximately, with the approximation getting more accurate as *d* increases).
    The constant *c* (called the *power*) usually lies between 2 and 3\. This power
    law property leads to the existence of many vertices whose degree is much higher
    than the average vertex degree in the network. Consequently, scale-free networks
    usually have a spoke-and-wheel shape of loosely connected hubs, like airport terminals
    connecting at a central security gate. The hubs in the network tend to rein in
    the distances between vertices, giving these networks certain “small-world” properties.
  prefs: []
  type: TYPE_NORMAL
- en: These networks have a fascinating history and well-developed theory that we
    don’t have space to get into. An interesting debate in the field has been whether
    many naturally occurring networks are scale-free—including internet pages, social
    networks, biological networks, and even airline travel networks—and if so, why
    this might be.
  prefs: []
  type: TYPE_NORMAL
- en: There are a variety of approaches for generating scale-free networks; one of
    the more popular options is conveniently implemented in igraph with the `sample_pa()`
    function. It relies on what is known as the Barabási–Albert model.
  prefs: []
  type: TYPE_NORMAL
- en: Watts–Strogatz Graphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Watts–Strogatz graphs* are networks generated by a random graph model introduced
    in 1998 that tends to produce even more small-world properties than scale-free
    networks, such as tightly interconnected communities and small network distances
    between many vertices. These networks frequently include paths that are reinforced
    by redundancy and alternate routes. They are common in biology and social processes.
    For example, brain connectivity networks at the neuron and functional area levels,
    voter networks, influencer networks on social media platforms, and food webs often
    form Watts–Strogatz networks.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we have already seen a few examples of Erdös–Renyi graphs (see Figures
    2-14 and 2-15), let’s create some networks of these other types. In [Figure 2-16](#figure2-16),
    we use `sample_pa(100,power=2.5,directed=F)` to generate a couple of scale-free
    networks, and we use `sample_smallworld(1,100,2,0.05)` to generate a couple of
    Watts–Strogatz networks. We leave it to a motivated reader to look in the igraph
    documentation to learn about the parameter choices in this latter function.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503083c02/f02016_m.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-16: Two scale-free networks (top) and two Watts–Strogatz networks
    (bottom)'
  prefs: []
  type: TYPE_NORMAL
- en: The scale-free networks in the top row each have one prominent hub, and the
    network on the left additionally has a less prominent secondary hub. Imagining
    these to be power grid connections, a storm that takes out a main hub would impact
    many more customers in the scale-free network than in the Watts–Strogatz network.
    This is why many planned real-world networks conform to a redundancy-heavy structure.
    The Watts–Strogatz networks do not exhibit strong hubs like scale-free networks,
    but they have a lot of structure not seen in the purely random Erdös–Renyi networks.
    For instance, the lengthy reinforced path structures mentioned earlier are easy
    to recognize in these bottom plots.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter opened with a brief section explaining the need for networks in
    data science and the need for geometry in network science. Next, we introduced
    networks and the objects involved in them—vertices, edges, paths, and more. We
    then defined and explored a collection of metrics that quantify various properties
    of networks and their vertices. The chapter concluded with a few random graph
    models that are useful for generating synthetic network data to which real network
    data can be compared.
  prefs: []
  type: TYPE_NORMAL
