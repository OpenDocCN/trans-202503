- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Resource Location and Traffic Routing
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 资源位置和流量路由
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: To write effective network programs, you need to understand how to use human-readable
    names to identify nodes on the internet, how those names are translated into addresses
    for network devices to use, and how traffic makes its way between nodes on the
    internet, even if they’re on opposite sides of the planet. This chapter covers
    those topics and more.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写有效的网络程序，您需要了解如何使用人类可读的名称来标识互联网节点，这些名称如何被转换成网络设备可用的地址，以及流量如何在互联网上的节点之间传递，即使它们位于地球的两端。本章将涵盖这些主题以及更多内容。
- en: We’ll first have a look at how IP addresses identify hosts on a network. Then
    we’ll discuss *routing*, or sending traffic between network hosts that aren’t
    directly connected, and cover some common routing protocols. Finally, we’ll discuss
    *domain name resolution* (the process of translating human-readable names to IP
    addresses), potential privacy implications of DNS, and the solutions to overcome
    those privacy concerns.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看看 IP 地址如何标识网络上的主机。然后我们将讨论*路由*，即在没有直接连接的网络主机之间发送流量，并介绍一些常见的路由协议。最后，我们将讨论*域名解析*（将人类可读名称转换为
    IP 地址的过程）、DNS 的潜在隐私影响以及克服这些隐私问题的解决方案。
- en: You’ll need to understand these topics to provide comprehensive network services
    and locate the resources used by your services, such as third-party application
    programming interfaces (APIs). This information should also help you debug inevitable
    network outages or performance issues your code may encounter. For example, say
    you provide a service that integrates the Google Maps API to provide interactive
    maps and navigation. Your service would need to properly locate the API endpoint
    and route traffic to it. Or your service may need to store archives in an Amazon
    Simple Storage Service (S3) bucket via the Amazon S3 API. In each example, name
    resolution and routing play an integral role.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要理解这些主题，以便提供全面的网络服务，并定位您的服务所使用的资源，例如第三方应用程序编程接口（APIs）。这些信息还应帮助您调试代码中可能遇到的网络中断或性能问题。例如，假设您提供一个服务，该服务集成了
    Google Maps API 来提供互动地图和导航。您的服务需要正确定位 API 端点并将流量路由到该端点。或者，您的服务可能需要通过 Amazon S3
    API 将档案存储在 Amazon Simple Storage Service (S3) 桶中。在每个示例中，名称解析和路由都发挥着至关重要的作用。
- en: The Internet Protocol
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互联网协议
- en: The *Internet Protocol (IP)* is a set of rules that dictate the format of data
    sent over a network—specifically, the internet. *IP addresses* identify nodes
    on a network at the internet layer of the TCP/IP stack, and you use them to facilitate
    communication between nodes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*互联网协议（IP）*是一组规则，规定了在网络上传输数据的格式——特别是互联网。*IP 地址*在 TCP/IP 协议栈的互联网层中标识网络上的节点，您可以使用它们来促进节点之间的通信。'
- en: IP addresses function in the same way as postal addresses; nodes send packets
    to other nodes by addressing packets to the destination node’s IP address. Just
    as it’s customary to include a return address on postal mail, packet headers include
    the IP address of the origin node as well. Some protocols require an acknowledgment
    of successful delivery, and the destination node can use the origin node’s IP
    address to send the delivery confirmation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: IP 地址的功能与邮政地址相似；节点通过将数据包发送到目标节点的 IP 地址来将数据包发送到其他节点。就像邮政邮件中通常会包括一个回邮地址一样，数据包头也包括了源节点的
    IP 地址。某些协议要求确认成功送达，目标节点可以使用源节点的 IP 地址来发送送达确认。
- en: 'Two versions of IP addresses are in public use: IPv4 and IPv6\. This chapter
    covers both.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种版本的 IP 地址在公共使用中：IPv4 和 IPv6。本章将涵盖这两者。
- en: IPv4 Addressing
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv4 地址
- en: '*IPv4* is the fourth version of the Internet Protocol. It was the first IP
    version in use on the internet’s precursor, ARPANET, in 1983, and the predominant
    version in use today. IPv4 addresses are 32-bit numbers arranged in four groups
    of 8 bits (called *octets*) separated by decimal points.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*IPv4* 是第四版互联网协议。它是 1983 年在互联网的前身 ARPANET 上使用的第一个 IP 版本，也是今天最常用的版本。IPv4 地址是
    32 位数字，按八位（称为*八位字节*）一组分为四组，并以十进制点分隔。'
- en: The total range of 32-bit numbers limits us to just over four billion possible
    IPv4 addresses. [Figure 2-1](#figure2-1) shows the binary and decimal representation
    of an IPv4 address.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 32 位数字的总范围限制了我们只能拥有略多于 40 亿个可能的 IPv4 地址。[图 2-1](#figure2-1)显示了 IPv4 地址的二进制和十进制表示。
- en: '![f02001](image_fi/500884c02/f02001.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![f02001](image_fi/500884c02/f02001.png)'
- en: 'Figure 2-1: Four 8-bit octets representing an IPv4 address in both binary and
    decimal formats'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1：以二进制和十进制格式表示的四个 8 位字节，构成一个 IPv4 地址
- en: The first line of [Figure 2-1](#figure2-1) illustrates an IPv4 address in binary
    form. The second line is the IPv4 address’s decimal equivalent. We usually write
    IPv4 addresses in the more readable decimal format when displaying them or when
    using them in code. We will use their binary representation when we’re discussing
    network addressing later in this section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-1](#figure2-1)的第一行展示了一个 IPv4 地址的二进制形式。第二行是该 IPv4 地址的十进制等价。我们通常在展示 IPv4
    地址时，或在代码中使用时，使用更易读的十进制格式。我们将在本节稍后讨论网络寻址时，使用它们的二进制表示。'
- en: Network and Host IDs
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络 ID 和主机 ID
- en: 'The 32 bits that compose an IPv4 address represent two components: a network
    ID and a host ID. The *network ID* informs the network devices responsible for
    shuttling packets toward their destination about the next appropriate hop in the
    transmission. These devices are called *routers*. Routers are like the mail carrier
    of a network, in that they accept data from a device, examine the network ID of
    the destination address, and determine where the data needs to be sent to reach
    its destination. You can think of the network ID as a mailing address’s ZIP (or
    postal) code.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 组成一个 IPv4 地址的 32 位表示两个组件：网络 ID 和主机 ID。*网络 ID*通知负责传送数据包到达目的地的网络设备关于下一跳的适当位置。这些设备被称为*路由器*。路由器就像网络中的邮件投递员，它们从设备接收数据，检查目的地址的网络
    ID，并决定将数据发送到何处以到达目的地。你可以把网络 ID 想象成邮寄地址中的邮政编码。
- en: Once the data reaches the destination network, the router uses the *host ID*
    to deliver the data to the specific recipient. The host ID is like your street
    address. In other words, a network ID identifies a group of nodes whose address
    is part of the same network. We’ll see what network and host IDs look like later
    in this chapter, but [Figure 2-2](#figure2-2) shows IPv4 addresses sharing the
    same network ID.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据到达目标网络，路由器使用*主机 ID*将数据传递给特定的接收方。主机 ID 就像你的街道地址。换句话说，网络 ID 标识的是一组节点，其地址属于同一网络。我们将在本章稍后看到网络和主机
    ID 的样子，但[图 2-2](#figure2-2)展示了共享相同网络 ID 的 IPv4 地址。
- en: '![f02002](image_fi/500884c02/f02002.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![f02002](image_fi/500884c02/f02002.png)'
- en: 'Figure 2-2: A group of nodes sharing the same network ID'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-2：共享相同网络 ID 的节点组
- en: '[Figure 2-3](#figure2-3) shows the breakdown of common network ID and host
    ID sizes in a 32-bit IPv4 address.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-3](#figure2-3)展示了 32 位 IPv4 地址中常见的网络 ID 和主机 ID 大小的分解。'
- en: '![f02003](image_fi/500884c02/f02003.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![f02003](image_fi/500884c02/f02003.png)'
- en: 'Figure 2-3: Common network ID and host ID sizes'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-3：常见的网络 ID 和主机 ID 大小
- en: The network ID portion of an IPv4 address always starts with the leftmost bit,
    and its size is determined by the size of the network it belongs to. The remaining
    bits designate the host ID. For example, the first 8 bits of the IPv4 address
    represent the network ID in an 8-bit network, and the remaining 24 bits represent
    the host ID.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4 地址的网络 ID 部分总是从最左边的位开始，其大小由它所属的网络的大小决定。剩余的位指定主机 ID。例如，IPv4 地址的前 8 位代表一个
    8 位网络中的网络 ID，而剩余的 24 位代表主机 ID。
- en: '[Figure 2-4](#figure2-4) shows the IP address 192.168.156.97 divided into its
    network ID and host ID. This IP address is part of a 16-bit network. This tells
    us that the first 16 bits form the network ID and the remaining 16 bits form the
    host ID.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-4](#figure2-4)展示了 IP 地址 192.168.156.97 被划分为网络 ID 和主机 ID。这一 IP 地址属于一个 16
    位网络。这告诉我们，前 16 位构成网络 ID，剩余的 16 位构成主机 ID。'
- en: '![f02004](image_fi/500884c02/f02004.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![f02004](image_fi/500884c02/f02004.png)'
- en: 'Figure 2-4: Deriving the network ID and the host ID from an IPv4 address in
    a 16-bit network'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-4：从 16 位网络中的 IPv4 地址推导出网络 ID 和主机 ID
- en: To derive the network ID for this example, you take the first 16 bits and append
    zeros for the remaining bits to produce the 32-bit network ID of 192.168.0.0\.
    You prepend zeroed bits to the last 16 bits, resulting in the 32-bit host ID of
    0.0.156.97.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了推导出这个示例的网络 ID，你需要取前 16 位，并为剩余的位补充零，形成 32 位的网络 ID 192.168.0.0。然后，你将零填充到最后 16
    位，得到 32 位的主机 ID 0.0.156.97。
- en: Subdividing IPv4 Addresses into Subnets
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv4 地址的子网划分
- en: IPv4’s network and host IDs allow you to *subdivide*, or partition, the more
    than four billion IPv4 addresses into smaller groups to keep the network secure
    and easier to manage. All IP addresses in these smaller networks, called *subnets*,
    share the same network ID but have unique host IDs. The size of the network dictates
    the number of host IDs and, therefore, the number of individual IP addresses in
    the network.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4的网络ID和主机ID允许您*细分*或划分超过40亿个IPv4地址到更小的组中，以保持网络的安全性并使其更易于管理。所有这些较小网络中的IP地址，称为*子网*，共享相同的网络ID，但具有独特的主机ID。网络的大小决定了主机ID的数量，因此也决定了网络中IP地址的数量。
- en: Identifying individual networks allows you to control the flow of information
    between networks. For example, you could split your network into a subnet meant
    for public services and another for private services. You could then allow external
    traffic to reach your public services while preventing external traffic from reaching
    your private network. As another example, your bank provides services such as
    online banking, customer support, and mobile banking. These are public services
    that you interact with after successful authentication. But you don’t have access
    to the bank’s internal network, where its systems manage electronic transfers,
    balance ledgers, serve internal email, and so on. These services are restricted
    to the bank’s employees via the private network.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 确定单独的网络可以让您控制网络之间信息流动的方式。例如，您可以将网络分为一个用于公共服务的子网和一个用于私有服务的子网。然后，您可以允许外部流量访问公共服务，同时防止外部流量访问私有网络。另一个例子是，您的银行提供在线银行、客户支持和手机银行等服务。这些是公共服务，您在成功认证后可以与之交互。但您无法访问银行的内部网络，那里管理着电子转账、余额账本、内部邮件等系统。这些服务仅通过私有网络供银行员工访问。
- en: Allocating Networks with CIDR
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用CIDR分配网络
- en: You allocate networks using a method known as *Classless Inter-Domain Routing**(CIDR)*.
    In CIDR, you indicate the number of bits in the network ID by appending a *network
    prefix* to each IP address, consisting of a forward slash and an integer. Though
    it’s appended to the end of the IP address, you call it a *prefix* rather than
    a *suffix* because it indicates how many of the IP address’s most significant
    bits, or prefixed bits, constitute the network ID. For example, you’d write the
    IP address 192.168.156.97 from [Figure 2-4](#figure2-4) as 192.168.156.97/16 in
    CIDR notation, indicating that it belongs to a 16-bit network and that the network
    ID is the first 16 bits of the IP address.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用一种叫做*无类域间路由*(CIDR)的方法来分配网络。在CIDR中，您通过将一个*网络前缀*附加到每个IP地址上，指示网络ID中有多少位，网络前缀由一个斜杠和一个整数组成。尽管它附加在IP地址的末尾，但它被称为*前缀*而不是*后缀*，因为它表示IP地址的前几个最重要的位，或者说是前缀位，构成了网络ID。例如，您可以将[图2-4](#figure2-4)中的IP地址192.168.156.97写作CIDR表示法中的192.168.156.97/16，表示它属于一个16位网络，并且网络ID是IP地址的前16位。
- en: From there, you can derive the network IP address by applying a subnet mask.
    Subnet masks encode the CIDR network prefix in its decimal representation. They
    are applied to an IP address using a bitwise AND to derive the network ID.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，您可以通过应用子网掩码推导出网络IP地址。子网掩码在其十进制表示中编码了CIDR网络前缀。它们通过位与运算（bitwise AND）应用于IP地址，以推导出网络ID。
- en: '[Table 2-1](#table2-1) details the most common CIDR network prefixes, the corresponding
    subnet mask, the available networks for each network prefix, and the number of
    usable hosts in each network.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[表2-1](#table2-1)详细列出了最常见的CIDR网络前缀、对应的子网掩码、每个网络前缀的可用网络，以及每个网络中的可用主机数量。'
- en: 'Table 2-1: CIDR Network Prefix Lengths and Their Corresponding Subnet Masks'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1：CIDR网络前缀长度及其对应的子网掩码
- en: '| **CIDR network prefix length** | **Subnet mask** | **Available networks**
    | **Usable hosts per network** |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **CIDR网络前缀长度** | **子网掩码** | **可用网络** | **每个网络的可用主机** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 8 | 255.0.0.0 | 1 | 16,777,214 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 255.0.0.0 | 1 | 16,777,214 |'
- en: '| 9 | 255.128.0.0 | 2 | 8,388,606 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 255.128.0.0 | 2 | 8,388,606 |'
- en: '| 10 | 255.192.0.0 | 4 | 4,194,302 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 255.192.0.0 | 4 | 4,194,302 |'
- en: '| 11 | 255.224.0.0 | 8 | 2,097,150 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 255.224.0.0 | 8 | 2,097,150 |'
- en: '| 12 | 255.240.0.0 | 16 | 1,048,574 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 255.240.0.0 | 16 | 1,048,574 |'
- en: '| 13 | 255.248.0.0 | 32 | 524,286 |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 255.248.0.0 | 32 | 524,286 |'
- en: '| 14 | 255.252.0.0 | 64 | 262,142 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 255.252.0.0 | 64 | 262,142 |'
- en: '| 15 | 255.254.0.0 | 128 | 131,070 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 255.254.0.0 | 128 | 131,070 |'
- en: '| 16 | 255.255.0.0 | 256 | 65,534 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 255.255.0.0 | 256 | 65,534 |'
- en: '| 17 | 255.255.128.0 | 512 | 32,766 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 17 | 255.255.128.0 | 512 | 32,766 |'
- en: '| 18 | 255.255.192.0 | 1,024 | 16,382 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 255.255.192.0 | 1,024 | 16,382 |'
- en: '| 19 | 255.255.224.0 | 2,048 | 8,190 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 19 | 255.255.224.0 | 2,048 | 8,190 |'
- en: '| 20 | 255.255.240.0 | 4,096 | 4,094 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 255.255.240.0 | 4,096 | 4,094 |'
- en: '| 21 | 255.255.248.0 | 8,192 | 2,046 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 21 | 255.255.248.0 | 8,192 | 2,046 |'
- en: '| 22 | 255.255.252.0 | 16,384 | 1,022 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 22 | 255.255.252.0 | 16,384 | 1,022 |'
- en: '| 23 | 255.255.254.0 | 32,768 | 510 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 23 | 255.255.254.0 | 32,768 | 510 |'
- en: '| 24 | 255.255.255.0 | 65,536 | 254 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 24 | 255.255.255.0 | 65,536 | 254 |'
- en: '| 25 | 255.255.255.128 | 131,072 | 126 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 25 | 255.255.255.128 | 131,072 | 126 |'
- en: '| 26 | 255.255.255.192 | 262,144 | 62 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 26 | 255.255.255.192 | 262,144 | 62 |'
- en: '| 27 | 255.255.255.224 | 524,288 | 30 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 27 | 255.255.255.224 | 524,288 | 30 |'
- en: '| 28 | 255.255.255.240 | 1,048,576 | 14 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 28 | 255.255.255.240 | 1,048,576 | 14 |'
- en: '| 29 | 255.255.255.248 | 2,097,152 | 6 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 29 | 255.255.255.248 | 2,097,152 | 6 |'
- en: '| 30 | 255.255.255.252 | 4,194,304 | 2 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 30 | 255.255.255.252 | 4,194,304 | 2 |'
- en: You may have noticed that the number of usable hosts per network is two less
    than expected in each row because each network has two special addresses. The
    first IP address in the network is the network address, and the last IP address
    is the broadcast address. (We’ll cover broadcast addresses a bit later in this
    chapter.) Take 192.168.0.0/16, for example. The first IP address in the network
    is 192.168.0.0\. This is the network address. The last IP address in the network
    is 192.168.255.255, which is the broadcast address. For now, understand that you
    do not assign the network IP address or the broadcast IP address to a host’s network
    interface. These special IP addresses are used for routing data between networks
    and broadcasting, respectively.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，每行中的每个网络可用的主机数比预期少了两个，因为每个网络都有两个特殊地址。网络中的第一个IP地址是网络地址，最后一个IP地址是广播地址。（我们将在本章稍后介绍广播地址。）以192.168.0.0/16为例。网络中的第一个IP地址是192.168.0.0，这就是网络地址。网络中的最后一个IP地址是192.168.255.255，这是广播地址。目前，理解你不会将网络IP地址或广播IP地址分配给主机的网络接口。这些特殊的IP地址分别用于在网络之间路由数据和广播。
- en: The 31- and 32-bit network prefixes are purposefully absent from [Table 2-1](#table2-1),
    largely because they are beyond the scope of this book. If you’re curious about
    31-bit network prefixes, RFC 3021 covers their application. A 32-bit network prefix
    signifies a single-host network. For example, 192.168.1.1/32 represents a subnetwork
    of one node with the address 192.168.1.1.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 31位和32位的网络前缀故意未包含在[表2-1](#table2-1)中，主要是因为它们超出了本书的范围。如果你对31位网络前缀感兴趣，可以查阅RFC
    3021了解其应用。32位网络前缀表示一个单主机网络。例如，192.168.1.1/32表示一个只有地址为192.168.1.1的单一节点子网络。
- en: Allocating Networks That Don’t Break at an Octet Boundary
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分配不在字节边界断开的网络
- en: Some network prefixes don’t break at an octet boundary. For example, [Figure
    2-5](#figure2-5) derives the network ID and host ID of 192.168.156.97 in a 19-bit
    network. The full IP address in CIDR notation is 192.168.156.97/19.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有些网络前缀不会在字节边界处断开。例如，[图2-5](#figure2-5)在19位网络中推导出192.168.156.97的网络ID和主机ID。CIDR表示法中的完整IP地址为192.168.156.97/19。
- en: '![f02005](image_fi/500884c02/f02005.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![f02005](image_fi/500884c02/f02005.png)'
- en: 'Figure 2-5: Deriving the network ID and the host ID from the IPv4 address in
    a 19-bit network'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-5：从IPv4地址中推导出网络ID和主机ID（在19位网络中）
- en: In this case, since the network prefix isn’t a multiple of 8 bits, an octet’s
    bits are split between the network ID and host ID. The 19-bit network example
    in [Figure 2-5](#figure2-5) results in the network ID of 192.168.128.0 and the
    host ID of 0.0.28.97, where the network ID borrows 3 bits from the third octet,
    leaving 13 bits for the host ID.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于网络前缀不是8位的倍数，一个字节的位被分割到网络ID和主机ID之间。在[图2-5](#figure2-5)中的19位网络示例中，网络ID为192.168.128.0，主机ID为0.0.28.97，其中网络ID从第三个字节借用了3位，剩下13位用于主机ID。
- en: Appending a zeroed host ID to the network ID results in the network address.
    In a comparable manner, appending a host ID in which all its bits are 1 to the
    network ID derives the broadcast address. But the third octet’s equaling 156 can
    be a little confusing. Let’s focus on just the third octet. The third octet of
    the network ID is 1000 0000\. The third octet of the host ID of all ones is 0001
    1111 (the first 3 bits are part of the network ID, remember). If we append the
    network ID’s third octet to the host ID’s third octet, the result is 1001 1111,
    which is the decimal 156.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将零化的主机ID附加到网络ID后，得到网络地址。以类似的方式，将所有位都是1的主机ID附加到网络ID后，得到广播地址。但第三个字节等于156可能有点令人困惑。我们只关注第三个字节。网络ID的第三个字节是1000
    0000。所有位都是1的主机ID的第三个字节是0001 1111（前3位是网络ID的一部分，记住）。如果我们将网络ID的第三个字节附加到主机ID的第三个字节，结果是1001
    1111，即十进制的156。
- en: Private Address Spaces and Localhost
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 私有地址空间与本地主机
- en: RFC 1918 details the private address spaces of 10.0.0.0/8, 172.16.0.0/12, and
    192.168.0.0/16 for use in local networks. Universities, corporations, governments,
    and residential networks can use these subnets for local addressing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: RFC 1918 详细说明了 10.0.0.0/8、172.16.0.0/12 和 192.168.0.0/16 的私有地址空间，供本地网络使用。大学、公司、政府和住宅网络可以使用这些子网进行本地寻址。
- en: In addition, each host has the 127.0.0.0/8 subnet designated as its local subnet.
    Addresses in this subnet are local to the host and simply called *localhost*.
    Even if your computer is not on a network, it should still have an address on
    the 127.0.0.0/8 subnet, most likely 127.0.0.1.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个主机都有 127.0.0.0/8 子网作为其本地子网。该子网中的地址是主机的本地地址，通常称为*localhost*。即使你的计算机不在网络上，它仍然应该有一个
    127.0.0.0/8 子网中的地址，最有可能是 127.0.0.1。
- en: Ports and Socket Addresses
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端口与套接字地址
- en: If your computer were able to communicate over the network with only one node
    at a time, that wouldn’t provide a very efficient or pleasant experience. It would
    become annoying if your streaming music stopped every time you clicked a link
    in your web browser because the browser needed to interrupt the stream to retrieve
    the requested web page. Thankfully, TCP and UDP allow us to multiplex data transmissions
    by using *ports*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的计算机只能与网络中的一个节点进行通信，这将不会提供高效或愉快的体验。如果每次你在网页浏览器中点击一个链接时，音乐流媒体就停止，因为浏览器需要中断流媒体以获取请求的网页，那将非常烦人。幸运的是，TCP
    和 UDP 允许我们通过使用*端口*来实现数据传输的复用。
- en: The operating system uses ports to uniquely identify data transmission between
    nodes for the purposes of multiplexing the outgoing application data and demultiplexing
    the incoming data back to the proper application. The combination of an IP address
    and a port number is a *socket address*, typically written in the format *address:port*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统使用端口来唯一标识节点之间的数据传输，以实现对外发应用数据的复用和对进入数据的解复用。IP 地址和端口号的组合被称为*套接字地址*，通常以*地址:端口*的格式表示。
- en: Ports are 16-bit unsigned integers. Port numbers 0 to 1023 are well-known ports
    assigned to common services by the *Internet Assigned Numbers Authority**(IANA)*.
    The IANA is a private US nonprofit organization that globally allocates IP addresses
    and port numbers. For example, HTTP uses port 80\. Port 443 is the HTTPS port.
    SSH servers typically listen on port 22\. (These well-known ports are guidelines.
    An HTTP server may listen to any port, not just port 80.)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 端口是 16 位无符号整数。端口号 0 至 1023 是由*互联网号码分配局**(IANA)* 分配给常见服务的著名端口。IANA 是一个美国非营利性私营组织，负责全球
    IP 地址和端口号的分配。例如，HTTP 使用端口 80。端口 443 是 HTTPS 端口。SSH 服务器通常监听端口 22。（这些著名端口只是指南。HTTP
    服务器可以监听任何端口，而不仅仅是端口 80。）
- en: Despite these ports being well-known, there is no restriction on which ports
    services may use. For example, an administrator who wants to obscure a service
    from attackers expecting it on port 22 may configure an SSH server to listen on
    port 22422\. The IANA designates ports 1024 to 49151 as semi-reserved for lesser
    common services. Ports 49152 to 65535 are ephemeral ports meant for client socket
    addresses as recommended by the IANA. (The port range used for client socket addresses
    is operating-system dependent.)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些端口是众所周知的，但服务使用哪些端口没有限制。例如，想要将服务隐藏在不同端口上的管理员，可以配置 SSH 服务器监听端口 22422，而不是默认的
    22 端口。IANA 将端口 1024 至 49151 定义为半保留端口，用于较不常见的服务。端口 49152 至 65535 是短暂端口，用于客户端套接字地址，这是
    IANA 的建议。（客户端套接字地址使用的端口范围依赖于操作系统。）
- en: A common example of port usage is the interaction between your web browser and
    a web server. Your web browser opens a socket with the operating system, which
    assigns an address to the socket. Your web browser sends a request through the
    socket to port 80 on the web server. The web server sends its response to the
    socket address corresponding to the socket your web browser is monitoring. Your
    operating system receives the response and passes it onto your web browser through
    the socket. Your web browser’s socket address and the web server’s socket address
    (server IP and port 80) uniquely identify this transaction. This allows your operating
    system to properly demultiplex the response and pass it along to the right application
    (that is, your web browser).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的端口使用示例是您的网页浏览器与网页服务器之间的交互。您的网页浏览器与操作系统打开一个套接字，操作系统为该套接字分配一个地址。您的网页浏览器通过该套接字向网页服务器的80端口发送请求。网页服务器将其响应发送到与您的网页浏览器监视的套接字对应的套接字地址。您的操作系统接收到响应并通过套接字将其传递给网页浏览器。您的网页浏览器的套接字地址和网页服务器的套接字地址（服务器IP和80端口）唯一标识此事务。这使得您的操作系统能够正确地进行响应的解复用，并将其传递给正确的应用程序（即您的网页浏览器）。
- en: Network Address Translation
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络地址转换
- en: The four billion IPv4 addresses may seem like a lot until you consider there
    will be an estimated 24.6 billion Internet of Things (IoT) devices by 2025, according
    to the Ericsson Mobility Report of June 2020 ([https://www.ericsson.com/en/mobility-report/reports/june-2020/iot-connections-outlook/](https://www.ericsson.com/en/mobility-report/reports/june-2020/iot-connections-outlook/)).
    In fact, we’ve already run out of unreserved IPv4 addresses. The IANA allocated
    the last IPv4 address block on January 31, 2011.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 四十亿个IPv4地址看起来可能很多，但考虑到根据2020年6月的爱立信移动报告（[https://www.ericsson.com/en/mobility-report/reports/june-2020/iot-connections-outlook/](https://www.ericsson.com/en/mobility-report/reports/june-2020/iot-connections-outlook/)），到2025年，预计将有246亿个物联网（IoT）设备，情况就不一样了。实际上，我们已经耗尽了未预留的IPv4地址。IANA于2011年1月31日分配了最后一个IPv4地址块。
- en: One way to address the IPv4 shortage is by using *network address translation
    (NAT)*, a process that allows numerous nodes to share the same public IPv4 address.
    It requires a device, such as a firewall, load balancer, or router that can keep
    track of incoming and outgoing traffic and properly route incoming traffic to
    the correct node.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 解决IPv4地址短缺的一种方式是使用*网络地址转换（NAT）*，这是一种允许多个节点共享同一公共IPv4地址的过程。它需要一个设备，例如防火墙、负载均衡器或路由器，能够跟踪进出流量，并将传入的流量正确路由到正确的节点。
- en: '[Figure 2-6](#figure2-6) illustrates the NAT process between nodes on a private
    network and the internet.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2-6](#figure2-6)展示了私有网络与互联网之间的NAT过程。'
- en: '![f02006](image_fi/500884c02/f02006.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![f02006](image_fi/500884c02/f02006.png)'
- en: 'Figure 2-6: Network address translation between a private network and the internet'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-6：私有网络与互联网之间的网络地址转换
- en: In [Figure 2-6](#figure2-6), a NAT-capable device receives a connection from
    the client socket address 10.0.0.3:50926 destined for a host on the internet.
    First, the NAT device opens its own connection to the destination host using its
    public IP 1.2.3.4, preserving the client’s socket address port. Its socket address
    for this transaction is 1.2.3.4:50926\. If a client is already using port 50926,
    the NAT device chooses a random port for its socket address. Then, the NAT device
    sends the request to the destination host and receives the response on its 1.2.3.4:50926
    socket. The NAT device knows which client receives the response because it translates
    its socket address to the client socket address that established the connection.
    Finally, the client receives the destination host’s response from the NAT device.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图2-6](#figure2-6)中，一个支持NAT的设备接收到来自客户端套接字地址10.0.0.3:50926的连接，目标是互联网上的一个主机。首先，NAT设备使用其公共IP
    1.2.3.4打开与目标主机的连接，同时保持客户端的套接字地址端口。此事务的套接字地址为1.2.3.4:50926。如果客户端已经使用了端口50926，NAT设备会为其套接字地址选择一个随机端口。然后，NAT设备将请求发送到目标主机，并在其1.2.3.4:50926套接字上接收响应。NAT设备通过将其套接字地址转换为建立连接的客户端套接字地址，知道哪个客户端接收到响应。最后，客户端从NAT设备接收到目标主机的响应。
- en: The important thing to remember with network address translation is that a node’s
    private IPv4 address behind a NAT device is not visible or directly accessible
    to other nodes outside the network address–translated network segment. If you’re
    writing a service that needs to provide a public address for its clients, you
    may not be able to rely on your node’s private IPv4 address if it’s behind a NAT
    device. Hosts outside the NAT device’s private network cannot establish incoming
    connections. Only clients in the private network may establish connections through
    the NAT device. Instead, your service must rely on the NAT device’s properly forwarding
    a port from its public IP to a socket address on your node.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 关于网络地址转换，重要的是要记住，位于NAT设备后面的节点的私有IPv4地址对网络地址转换后的网络段外的其他节点不可见或不可直接访问。如果你正在编写一个需要为客户端提供公共地址的服务，你可能无法依赖节点的私有IPv4地址，特别是在它位于NAT设备后面时。NAT设备外的主机无法建立传入连接。只有私有网络中的客户端才能通过NAT设备建立连接。相反，你的服务必须依赖于NAT设备将端口从其公共IP正确转发到你节点的套接字地址。
- en: Unicasting, Multicasting, and Broadcasting
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单播、多播和广播
- en: Sending packets from one IP address to another IP address is known as *unicast
    addressing*. But TCP/IP’s internet layer supports IP *multicasting*, or sending
    a single message to a group of nodes. You can think of it as an opt-in mailing
    list, such as a newspaper subscription.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个IP地址发送数据包到另一个IP地址被称为*单播寻址*。但TCP/IP的互联网层支持IP *多播*，即将单条消息发送给一组节点。你可以将其视为一个自愿加入的邮件列表，例如报纸订阅。
- en: From a network programming perspective, multicasting is simple. Routers and
    switches typically replicate the message for us, as shown in [Figure 2-7](#figure2-7).
    We’ll discuss multicasting later in this book.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从网络编程的角度来看，多播很简单。路由器和交换机通常为我们复制消息，如[图2-7](#figure2-7)所示。我们将在本书后面讨论多播。
- en: '![f02007](image_fi/500884c02/f02007.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![f02007](image_fi/500884c02/f02007.png)'
- en: 'Figure 2-7: The 192.168.1.10 node sending a packet to a subset of network addresses'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-7：192.168.1.10节点向一部分网络地址发送数据包
- en: '*Broadcasting* is the ability to concurrently deliver a message to all IP addresses
    in a network. To do this, nodes on a network send packets to the *broadcast address*
    of a subnet. A network switch or router then propagates the packets out to all
    IPv4 addresses in the subnet ([Figure 2-8](#figure2-8)).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*广播*是将消息同时发送给网络中所有IP地址的能力。为此，网络上的节点将数据包发送到子网的*广播地址*。然后，网络交换机或路由器将数据包传播到子网中的所有IPv4地址（[图2-8](#figure2-8)）。'
- en: '![f02008](image_fi/500884c02/f02008.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![f02008](image_fi/500884c02/f02008.png)'
- en: 'Figure 2-8: The 192.168.1.10 node sending a packet to all addresses on its
    subnet'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-8：192.168.1.10节点向其子网中的所有地址发送数据包
- en: Unlike multicasting, the nodes in the subnet don’t first need to opt in to receiving
    broadcast messages. If the node at 192.168.1.10 in [Figure 2-8](#figure2-8) sends
    a packet to the broadcast address of its subnet, the network switch will deliver
    a copy of that packet to the other five IPv4 addresses in the same subnet.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与多播不同，子网中的节点不需要首先选择接收广播消息。如果[图2-8](#figure2-8)中的192.168.1.10节点向其子网的广播地址发送数据包，网络交换机会将该数据包的副本传递给同一子网中其他五个IPv4地址。
- en: Resolving the MAC Address to a Physical Network Connection
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将MAC地址解析到物理网络连接
- en: Recall from Chapter 1 that every network interface has a MAC address uniquely
    identifying the node’s physical connection to the network. The MAC address is
    relevant to only the local network, so routers cannot use a MAC address to route
    data across network boundaries. Instead, they can route traffic across network
    boundaries by using an IPv4 address. Once a packet reaches the local network of
    a destination node, the router sends the data to the destination node’s MAC address
    and, finally, to the destination node’s physical network connection.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下第一章提到的，每个网络接口都有一个MAC地址，唯一标识节点与网络的物理连接。MAC地址只与本地网络相关，因此路由器无法使用MAC地址在网络边界之间路由数据。相反，它们可以使用IPv4地址跨越网络边界进行路由。一旦数据包到达目标节点的本地网络，路由器会将数据发送到目标节点的MAC地址，最终到达目标节点的物理网络连接。
- en: The *Address Resolution Protocol**(ARP)*,detailed in RFC 826 ([https://tools.ietf.org/html/rfc826/](https://tools.ietf.org/html/rfc826/)),
    finds the appropriate MAC address for a given IP address—a process called *resolving*
    the MAC address. Nodes maintain ARP tables that map an IPv4 address to a MAC address.
    If a node does not have an entry in its ARP table for a destination IPv4 address,
    the node will send a request to the local network’s broadcast address asking,
    “Who has this IPv4 address? Please send me your MAC address. Oh, and here is my
    MAC address.” The destination node will receive the ARP request and respond with
    an ARP reply to the originating node. The originating node will then send the
    data to the destination node’s MAC address. Nodes on the network privy to this
    conversation will typically update their ARP tables with the values.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*地址解析协议*（ARP），详见 RFC 826（[https://tools.ietf.org/html/rfc826/](https://tools.ietf.org/html/rfc826/)），用于查找给定
    IP 地址的适当 MAC 地址——这个过程被称为 *解析* MAC 地址。节点维护 ARP 表，将 IPv4 地址映射到 MAC 地址。如果一个节点的 ARP
    表中没有目标 IPv4 地址的条目，它将向本地网络的广播地址发送请求，询问：“谁拥有这个 IPv4 地址？请发送你的 MAC 地址。哦，这里是我的 MAC
    地址。”目标节点将接收 ARP 请求并以 ARP 回复回应源节点。源节点随后会将数据发送到目标节点的 MAC 地址。网络中监听此对话的其他节点通常会更新它们的
    ARP 表。'
- en: IPv6 Addressing
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPv6 地址分配
- en: Another solution to the IPv4 shortage is to migrate to the next generation of
    IP addressing, IPv6\. *IPv6 addresses* are 128-bit numbers arranged in eight colon-separated
    groups of 16 bits, or *hextets.* There are more than 340 undecillion (2^(128))
    IPv6 addresses.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 解决 IPv4 地址短缺的另一种方法是迁移到下一代 IP 地址，即 IPv6。*IPv6 地址* 是 128 位数字，按八个以冒号分隔的 16 位组排列，或称为
    *六元组*。IPv6 地址的总数超过 340 万亿（2^(128)）个。
- en: Writing IPv6 Addresses
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 IPv6 地址
- en: In binary form, IPv6 addresses are a bit ridiculous to write. In the interest
    of legibility and compactness, we write IPv6 addresses with lowercase hexadecimal
    values instead.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制形式下，IPv6 地址写起来有点荒谬。为了可读性和紧凑性，我们通常使用小写的十六进制值来表示 IPv6 地址。
- en: A hexadecimal (hex) digit represents 4 bits, or a *nibble*, of an IPv6 address.
    For example, we’d represent the two nibbles 1111 1111 in their hexadecimal equivalent
    of `ff`. [Figure 2-9](#figure2-9) illustrates the same IPv6 address in binary
    and hex.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个十六进制（hex）数字代表 IPv6 地址的 4 位，或称为 *四位组*。例如，我们可以将两个四位组 1111 1111 转换为其十六进制等效值 `ff`。[图
    2-9](#figure2-9) 展示了相同的 IPv6 地址在二进制和十六进制中的表示。
- en: '![f02009](image_fi/500884c02/f02009.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![f02009](image_fi/500884c02/f02009.png)'
- en: 'Figure 2-9: Binary and hex representations of the same IPv6 address'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-9：相同 IPv6 地址的二进制和十六进制表示
- en: Even though hexadecimal IPv6 addresses are a bit more succinct than their binary
    equivalent, we still have some techniques available to us to simplify them a bit
    more.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管十六进制的 IPv6 地址比其二进制等效地址稍显简洁，但我们仍然有一些技术可以进一步简化它们。
- en: Simplifying IPv6 Addresses
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 简化 IPv6 地址
- en: 'An IPv6 address looks something like this: fd00:4700:0010:0000:0000:0000:6814:d103\.
    That’s quite a bit harder to remember than an IPv4 address. Thankfully, you can
    improve the IPv6 address’s presentation to make it more readable by following
    a few rules.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 IPv6 地址看起来像这样：fd00:4700:0010:0000:0000:0000:6814:d103。比起 IPv4 地址，它确实更难记住。幸运的是，你可以通过遵循一些规则来改善
    IPv6 地址的表示，使其更易读。
- en: 'First, you can remove all leading zeros in each hextet. This simplifies your
    address without changing its value. It now looks like this: fd00:4700:10:0:0:0:6814:d103\.
    Better, but still long.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以去掉每个六元组中的所有前导零。这将简化你的地址，同时不会改变其值。现在它看起来像这样：fd00:4700:10:0:0:0:6814:d103。更简洁了，但还是比较长。
- en: Second, you can replace the leftmost group of consecutive, zero-value hextets
    with double colons, producing the shorter fd00:4700:10::6814:d103\. If your address
    has more than one group of consecutive zero-value hextets, you can remove only
    the leftmost group. Otherwise, it’s impossible for routers to accurately determine
    the number of hextets to insert when repopulating the full address from its compressed
    representation. For example, fd00:4700:0000:0000:ef81:0000:6814:d103 rewrites
    to fd00:4700::ef81:0:6814:d103\. The best you could do with the sixth hextet is
    to remove the leading zeros.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你可以将最左边一组连续的零值六元组替换为双冒号，从而生成更短的地址 fd00:4700:10::6814:d103。如果你的地址中有多个连续零值六元组组，你只能去掉最左边的一组。否则，路由器将无法准确确定在重新生成完整地址时需要插入多少个六元组。例如，fd00:4700:0000:0000:ef81:0000:6814:d103
    重写为 fd00:4700::ef81:0:6814:d103。对于第六个六元组，你能做的最好的优化就是去掉前导零。
- en: IPv6 Network and Host Addresses
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: IPv6 网络和主机地址
- en: Like IPv4 addresses, IPv6 addresses have a network address and a host address.
    IPv6’s host address is commonly known as the *interface ID*. The network and host
    addresses are both 64 bits, as shown in [Figure 2-10](#figure2-10). The first
    48 bits of the network address are known as the *global routing prefix**(GRP)*,
    and the last 16 bits of the network address are called the *subnet ID*. The 48-bit
    GRP is used for globally subdividing the IPv6 address space and routing traffic
    between these groups. The subnet ID is used to further subdivide each GRP-unique
    network into site-specific networks. If you run a large ISP, you are assigned
    one or more GRP-unique blocks of IPv6 addresses. You can then use the subnet ID
    in each network to further subdivide your allocated IPv6 addresses to your customers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 和 IPv4 地址一样，IPv6 地址也有网络地址和主机地址。IPv6 的主机地址通常被称为 *接口 ID*。网络地址和主机地址各占 64 位，如[图
    2-10](#figure2-10)所示。网络地址的前 48 位被称为 *全局路由前缀*（GRP），网络地址的最后 16 位被称为 *子网 ID*。48 位的
    GRP 用于全球细分 IPv6 地址空间，并在这些组之间路由流量。子网 ID 用于进一步细分每个 GRP 唯一的网络，形成特定站点的网络。如果你运营一个大型
    ISP，你会被分配一个或多个 GRP 唯一的 IPv6 地址块。然后，你可以在每个网络中使用子网 ID 来进一步细分分配给客户的 IPv6 地址。
- en: '![f02010](image_fi/500884c02/f02010.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![f02010](image_fi/500884c02/f02010.png)'
- en: 'Figure 2-10: IPv6 global routing prefix, subnet ID, and interface ID'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-10：IPv6 全局路由前缀、子网 ID 和接口 ID
- en: The GRP gets determined for you when you request a block of IPv6 addresses from
    your ISP. IANA assigns the first hextet of the GRP to a regional internet registry
    (an organization that handles the allocation of addresses for a global region).
    The regional internet registry then assigns the second GRP hextet to an ISP. The
    ISP finally assigns the third GRP hextet before assigning a 48-bit subnet of IPv6
    addresses to you.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从互联网服务提供商（ISP）请求一块 IPv6 地址时，GRP 会为你自动确定。IANA 将 GRP 的第一个十六位组分配给一个区域互联网注册机构（负责全球区域地址分配的组织）。该区域互联网注册机构随后将
    GRP 的第二个十六位组分配给一个 ISP。ISP 最后分配 GRP 的第三个十六位组，然后将一个 48 位子网的 IPv6 地址分配给你。
- en: The first hextet of an IPv6 address gives you a clue to its use. Addresses beginning
    with the prefix 2000::/3 are meant for global use, meaning every node on the internet
    will have an IPv6 address starting with 2 or 3 in the first hex. The prefix fc00::/7
    designates a unique local address like the 127.0.0.0/8 subnet in IPv4.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 地址的第一个十六位组能为你提供地址用途的线索。以前缀 2000::/3 开头的地址用于全球范围，意味着互联网上的每个节点都会有一个以 2 或
    3 开头的 IPv6 地址。前缀 fc00::/7 指定了类似 IPv4 中的 127.0.0.0/8 子网的唯一本地地址。
- en: 'Let’s assume your ISP assigned the 2600:fe56:7891::/48 netblock to you. Your
    16-bit subnet ID allows you to further subdivide your netblock into a maximum
    of 65,536 (2^(16)) subnets. Each of those subnets supports over 18 quintillion
    (2^(64)) hosts. If you assign 1 to the subnet as shown in [Figure 2-10](#figure2-10),
    you’d write the full network address as 2600:fe56:7891:1::/64 after removing leading
    zeros and compressing zero value hextets. Further subnetting your netblock may
    look like this: 2600:fe56:7891:**2**::/64, 2600:fe56:7891:**3**::/64, 2600:fe56:7891:**4**::/64.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的 ISP 分配给你 2600:fe56:7891::/48 网络块。你的 16 位子网 ID 允许你将网络块进一步细分为最多 65,536 个子网（2^(16)）。每个子网支持超过
    18 亿亿个主机（2^(64)）。如果你将子网设置为 1，如[图 2-10](#figure2-10)所示，那么完整的网络地址将是 2600:fe56:7891:1::/64，删除前导零并压缩零值十六位组后，地址为
    2600:fe56:7891:1::/64。进一步细分你的网络块可能如下所示：2600:fe56:7891:**2**::/64，2600:fe56:7891:**3**::/64，2600:fe56:7891:**4**::/64。
- en: IPv6 Address Categories
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv6 地址类别
- en: 'IPv6 addresses are divided into three categories: anycast, multicast, and unicast.
    Notice there is no broadcast type, as in IPv4\. As you’ll see, anycast and multicast
    addresses fulfill that role in IPv6.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 地址分为三类：任播（anycast）、多播（multicast）和单播（unicast）。请注意，不像 IPv4 中那样有广播类型。在 IPv6
    中，任播和多播地址承担了广播的角色。
- en: Unicast Addresses
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单播地址
- en: A *unicast* IPv6 address uniquely identifies a node. If an originating node
    sends a message to a unicast address, only the node with that address will receive
    the message, as shown in [Figure 2-11](#figure2-11).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*单播* IPv6 地址唯一地标识一个节点。如果源节点将消息发送到单播地址，只有拥有该地址的节点会收到该消息，如[图 2-11](#figure2-11)所示。'
- en: '![f02011](image_fi/500884c02/f02011.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![f02011](image_fi/500884c02/f02011.png)'
- en: 'Figure 2-11: Sending to a unicast address'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-11：发送到单播地址
- en: Multicast Addresses
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多播地址
- en: '*Multicast* addresses represent a group of nodes. Whereas IPv4 broadcast addresses
    will propagate a message out to all addresses on the network, multicast addresses
    will simultaneously deliver a message to a subset of network addresses, not necessarily
    all of them, as shown in [Figure 2-12](#figure2-12).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*多播*地址表示一组节点。IPv4 广播地址会将消息传播到网络上的所有地址，而多播地址则会同时将消息发送给网络地址的一个子集，而不一定是所有地址，正如
    [图 2-12](#figure2-12) 所示。'
- en: '![f02012](image_fi/500884c02/f02012.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![f02012](image_fi/500884c02/f02012.png)'
- en: 'Figure 2-12: Sending to a multicast address'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-12：发送到多播地址
- en: Multicast addresses use the prefix ff00::/8.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 多播地址使用前缀 ff00::/8。
- en: Anycast Addresses
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任播地址
- en: Remember that IPv4 addresses must be unique per network segment, or network
    communication issues can occur. But IPv6 includes support for multiple nodes using
    the same network address. An *anycast* address represents a group of nodes listening
    to the same address. A message sent to an anycast address goes to the nearest
    node listening to the address. [Figure 2-13](#figure2-13) represents a group of
    nodes listening to the same address, where the nearest node to the sender receives
    the message. The sender could transmit to any of the nodes represented by the
    dotted lines, but sends to the nearest node (solid line).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，IPv4 地址在每个网络段必须是唯一的，否则会发生网络通信问题。但 IPv6 支持多个节点使用相同的网络地址。*任播*地址表示一组监听相同地址的节点。发送到任播地址的消息会传递给离该地址最近的节点。[图
    2-13](#figure2-13) 展示了一组监听相同地址的节点，其中离发送方最近的节点接收消息。发送方可以将消息发送给虚线所代表的任一节点，但会选择发送给离其最近的节点（实线所示）。
- en: '![f02013](image_fi/500884c02/f02013.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![f02013](image_fi/500884c02/f02013.png)'
- en: 'Figure 2-13: Sending to an anycast address'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-13：发送到任播地址
- en: The nearest node isn’t always the most physically close node. It is up to the
    router to determine which node receives the message, usually the node with the
    least latency between the origin and the destination. Aside from reducing latency,
    anycast addressing increases redundancy and can geolocate services.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的节点并不总是物理上最接近的节点。由路由器决定哪个节点接收消息，通常是选择源和目的地之间延迟最小的节点。除了减少延迟，任播寻址还能增加冗余性，并可以进行地理定位服务。
- en: Sending traffic around the world takes a noticeable amount of time, to the point
    that the closer you are to a service provider’s servers, the better performance
    you’ll experience. Geolocating services across the internet is a common method
    of placing servers geographically close to users to make sure performance is optimal
    for all users across the globe. It’s unlikely you access servers across an ocean
    when streaming Netflix. Instead, Netflix geolocates servers close to you so that
    your experience is ideal.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 全球范围内传输数据需要一定的时间，距离服务提供商服务器越近，性能越好。通过地理定位服务来确保服务器尽可能靠近用户，是优化全球用户性能的常见方法。例如，当你观看
    Netflix 时，几乎不可能通过跨越大洋的服务器进行访问。相反，Netflix 会将服务器地理定位到离你更近的地方，从而确保你拥有最佳的观看体验。
- en: Advantages of IPv6 over IPv4
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPv6 相较于 IPv4 的优势
- en: Aside from the ridiculously large address space, IPv6 has inherent advantages
    over IPv4, particularly with regard to efficiency, autoconfiguration, and security.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了极其庞大的地址空间，IPv6 在效率、自动配置和安全性等方面也相较于 IPv4 具有固有优势。
- en: Simplified Header Format for More Efficient Routing
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为了更高效的路由，IPv6 采用了简化的报头格式。
- en: The IPv6 header is an improvement over the IPv4 header. The IPv4 header contains
    mandatory yet rarely used fields. IPv6 makes these fields optional. The IPv6 header
    is extensible, in that functionality can be added without breaking backward compatibility.
    In addition, the IPv6 header is designed for improved efficiency and reduced complexity
    over the IPv4 header.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 报头相比 IPv4 报头有所改进。IPv4 报头包含了一些强制性的但很少使用的字段，而 IPv6 将这些字段设为可选。IPv6 报头是可扩展的，意味着可以在不破坏向后兼容性的情况下增加新功能。此外，IPv6
    报头的设计更高效，且比 IPv4 报头更简化。
- en: IPv6 also lessens the loads on routers and other hops by ensuring that headers
    require minimal processing, eliminating the need for checksum calculation at every
    hop.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 还通过确保报头需要最小处理，从而减少了路由器和其他跳点的负载，避免了每个跳点都需要进行校验和计算。
- en: Stateless Address Autoconfiguration
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无状态地址自动配置
- en: Administrators manually assign IPv4 addresses to each node on a network or rely
    on a service to dynamically assign addresses. Nodes using IPv6 can automatically
    configure or derive their IPv6 addresses through *stateless address autoconfiguration**(SLAAC)*
    to reduce administrative overhead.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员手动为网络上的每个节点分配IPv4地址，或依赖于某个服务动态分配地址。使用IPv6的节点可以通过*无状态地址自动配置**(SLAAC)*自动配置或推导其IPv6地址，从而减少管理开销。
- en: When connected to an IPv6 network, a node can solicit the router for its network
    address parameters using the *Neighbor Discovery Protocol**(NDP)*. NDP leverages
    the Internet Control Message Protocol, discussed later in this chapter, for router
    solicitation. It performs the same duties as IPv4’s ARP. Once the node receives
    a reply from the router with the 64-bit network address, the node can derive the
    64-bit host portion of its IPv6 address on its own using the 48-bit MAC address
    assigned to its network interface. The node appends the 16-bit hex FFFE to the
    first three octets of the MAC address known as the *originally unique identifier
    (OUI)*. To this, the node appends the remaining three octets of the MAC address,
    the network interface controller (NIC) identifier. The result is a unique 64-bit
    interface ID, as shown in [Figure 2-14](#figure2-14). SLAAC works only in the
    presence of a router that can respond with router advertisement packets. *Router
    advertisement packets* contain information clients need to automatically configure
    their IPv6 address, including the 64-bit network address.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接到一个IPv6网络时，一个节点可以使用*邻居发现协议**(NDP)*向路由器请求其网络地址参数。NDP利用后续章节将讨论的互联网控制消息协议进行路由器请求。它执行与IPv4的ARP相同的功能。一旦节点收到路由器的回复并获得64位网络地址，节点可以使用分配给其网络接口的48位MAC地址自行推导出其IPv6地址的64位主机部分。节点将16位的十六进制FFFE附加到MAC地址的前三个八位字节，这三个字节称为*最初唯一标识符（OUI）*。接着，节点将MAC地址的剩余三个八位字节，即网络接口控制器（NIC）标识符，附加在后面。结果是一个独特的64位接口ID，如[图2-14](#figure2-14)所示。SLAAC仅在存在可以响应路由器广告包的路由器时工作。*路由器广告包*包含客户端自动配置其IPv6地址所需的信息，包括64位网络地址。
- en: '![f02014](image_fi/500884c02/f02014.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![f02014](image_fi/500884c02/f02014.png)'
- en: 'Figure 2-14: Deriving the interface ID from the MAC address'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-14：从MAC地址推导接口ID
- en: If you value your privacy, the method SLAAC uses to derive a unique interface
    ID should concern you. No matter which network your device is on, SLAAC will make
    sure the host portion of your IPv6 address contains your NIC’s MAC address. The
    MAC address is a unique fingerprint that betrays the hardware you use and allows
    anyone to track your online activity. Thankfully, many people raised these concerns,
    and SLAAC gained privacy extensions ([https://tools.ietf.org/html/rfc4941/](https://tools.ietf.org/html/rfc4941/)),
    which randomize the interface ID. Because of this randomization, it’s possible
    for more than one node on a network to generate the same interface ID. Thankfully,
    the NDP will automatically detect and fix any duplicate interface ID for you.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重视隐私，SLAAC推导唯一接口ID的方法应该引起你的关注。无论你的设备在哪个网络上，SLAAC都会确保你的IPv6地址的主机部分包含你的NIC的MAC地址。MAC地址是一个独特的指纹，它揭示了你使用的硬件，并允许任何人追踪你的在线活动。幸运的是，许多人提出了这些隐私问题，SLAAC获得了隐私扩展（[https://tools.ietf.org/html/rfc4941/](https://tools.ietf.org/html/rfc4941/)），该扩展可以随机化接口ID。由于这种随机化，网络上的多个节点有可能生成相同的接口ID。幸运的是，NDP会自动检测并修复任何重复的接口ID。
- en: Native IPsec Support
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 原生IPsec支持
- en: IPv6 has native support for *IPsec*, a technology that allows multiple nodes
    to dynamically create secure connections between each other, ensuring that traffic
    is encrypted.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6原生支持*IPsec*，这是一种允许多个节点之间动态创建安全连接的技术，确保流量加密。
- en: The Internet Control Message Protocol
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互联网控制消息协议
- en: The Internet Protocol relies on the *Internet Control Message Protocol**(ICMP)*
    to give it feedback about the local network. ICMP can inform you of network problems,
    unreachable nodes or networks, local network configuration, proper traffic routes,
    and network time-outs. Both IPv4 and IPv6 have their own ICMP implementations,
    designated ICMPv4 and ICMPv6, respectively.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议依赖于*互联网控制消息协议**(ICMP)*来反馈本地网络的信息。ICMP可以告知网络问题、无法到达的节点或网络、本地网络配置、正确的流量路由和网络超时。IPv4和IPv6都有各自的ICMP实现，分别被指定为ICMPv4和ICMPv6。
- en: Network events often result in ICMP response messages. For instance, if you
    attempt to send data to an unreachable node, a router will typically respond with
    an ICMP *destination unreachable* message informing you that your data couldn’t
    reach the destination node. A node may become unreachable if it runs out of resources
    and can no longer respond to incoming data or if data cannot route to the node.
    Disconnecting a node from a network will immediately make it unreachable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 网络事件通常会导致ICMP响应消息。例如，如果您试图向一个不可达节点发送数据，路由器通常会用ICMP *目标不可达*消息作出响应，通知您数据无法到达目标节点。如果节点耗尽资源或无法路由到节点，该节点可能会变得不可达。将节点从网络断开将立即使其不可访问。
- en: Routers use ICMP to help inform you of better routes to your destination node.
    If you send data to a router that isn’t the appropriate or best router to handle
    traffic for your destination, it may reply with an ICMP *redirect* message after
    forwarding your data onto the correct router. The ICMP redirect message is the
    router’s way of telling you to send your data to the appropriate router in the
    future.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器使用ICMP来帮助通知您更好的路由到达目标节点的方式。如果您向一个不适合或最佳的路由器发送数据，它可能会在将数据转发到正确的路由器后，用ICMP
    *重定向*消息回复。ICMP重定向消息是路由器告诉您将来将数据发送到适当路由器的方式。
- en: You can determine whether a node is online and reachable by using an ICMP *echo*
    request (also called a *ping*). If the destination is reachable and receives your
    ping, it will reply with its own ICMP *echo reply* message (also called a *pong*).
    If the destination isn’t reachable, the router will respond with a destination
    unreachable message.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用ICMP的*回显*请求（也称为*ping*）来确定节点是否在线和可达。如果目标可达并接收到您的ping，则会用自己的ICMP *回显回复*消息（也称为*pong*）进行回复。如果目标不可达，则路由器将用目标不可达消息作出响应。
- en: ICMP can also notify you when data reaches the end of its life before delivery.
    Every IP packet has a *time-to-live* value that dictates the maximum number of
    hops the packet can take before its lifetime expires. The packet’s time-to-live
    value is a counter and decrements by one for every hop it takes. You will receive
    an ICMP *time exceeded* message if the packet you sent doesn’t reach its destination
    by the time its time-to-live value reaches zero.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP还可以在数据传递前通知您其寿命已到。每个IP数据包都有一个*生存时间*值，该值规定了数据包在其寿命到期之前可以经过的最大跳数。数据包的生存时间是一个计数器，每经过一个跳数就减一。如果您发送的数据包在其生存时间值达到零之前未能到达目的地，则会收到ICMP
    *超时*消息。
- en: IPv6’s NDP relies heavily on ICMP router solicitation messages to properly configure
    a node’s NIC.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6的NDP依赖于ICMP路由器请求消息，以正确配置节点的网络接口控制器（NIC）。
- en: Internet Traffic Routing
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互联网流量路由
- en: Now that you know a bit about internet protocol addressing, let’s explore how
    packets make their way across the internet from one node to another using those
    addresses. In Chapter 1, we discussed how data travels down the network stack
    of the originating node, across a physical medium, and up the stack of the destination
    node. But in most cases, nodes won’t have a direct connection, so they’ll have
    to make use of intermediate nodes to transfer data. [Figure 2-15](#figure2-15)
    shows that process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了一些关于互联网协议地址的知识，让我们探讨一下数据包如何通过互联网从一个节点到另一个节点，利用这些地址。在第1章中，我们讨论了数据如何沿着起始节点的网络堆栈传输，通过物理介质跨越，然后通过目标节点的堆栈上升。但是在大多数情况下，节点之间没有直接连接，因此它们必须利用中间节点来传输数据。[图2-15](#figure2-15)展示了这个过程。
- en: The intermediate nodes (Nodes 1 and 2 in [Figure 2-15](#figure2-15)) are typically
    routers or firewalls that control the path data takes from one node to the other.
    *Firewalls* control the flow of traffic in and out of a network, primarily to
    secure networks behind the firewall.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 中间节点（图2-15中的节点1和2）通常是路由器或防火墙，它们控制数据从一个节点到另一个节点的路径。*防火墙*主要用于控制网络中进出流量的流向，以保护网络安全。
- en: No matter what type of node they are, intermediate nodes have a network stack
    associated with each network interface. In [Figure 2-15](#figure2-15), Node 1
    receives data on its incoming network interface. The data climbs the stack to
    Layer 3, where it’s handed off to the outgoing network interface’s stack. The
    data then makes its way to Node 2’s incoming network interface before ultimately
    being routed to the server.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 无论它们是什么类型的节点，中间节点都有一个与每个网络接口关联的网络协议栈。在[图 2-15](#figure2-15)中，节点 1 在其接收网络接口上接收到数据。数据沿着协议栈上升到第
    3 层，然后被交给发送网络接口的协议栈。接着，数据到达节点 2 的接收网络接口，最终被路由到服务器。
- en: The incoming and outgoing network interfaces in Node 1 and Node 2 may send data
    over different media types using IPv4, so they must use encapsulation to isolate
    the implementation details of each media type from the data being sent. Let’s
    assume Node 1 receives data from the client over a wireless network and it sends
    data to Node 2 over an Ethernet connection. Node 1’s incoming Layer 1 knows how
    to convert the radio signals from the wireless network into bits. Layer 1 sends
    the bits up to Layer 2\. Layer 2 converts the bits to a frame and extracts the
    packet and sends it up to Layer 3.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 节点 1 和节点 2 的接收和发送网络接口可能会通过不同的媒介类型使用 IPv4 发送数据，因此它们必须使用封装来隔离每种媒介类型的实现细节与正在发送的数据。假设节点
    1 从客户端通过无线网络接收数据，并通过以太网连接将数据发送到节点 2。节点 1 的接收第 1 层知道如何将无线网络的无线信号转换为比特。第 1 层将比特发送到第
    2 层。第 2 层将比特转换为帧，并提取数据包，将其发送到第 3 层。
- en: '![f02015](image_fi/500884c02/f02015.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![f02015](image_fi/500884c02/f02015.png)'
- en: 'Figure 2-15: Routing packets through two hops'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-15：通过两跳路由数据包
- en: Layer 3 on both the incoming and outgoing NICs speak IPv4, which routes the
    packet between the two interface network stacks. The outgoing NIC’s Layer 2 receives
    the packet from its Layer 3 and encapsulates it before sending the frame onto
    its Layer 1 as bits. The outgoing Layer 1 converts the bits into electric signals
    suitable for transmission over Ethernet. The data in transport from the client’s
    Layer 7 never changed despite the data’s traversing multiple nodes over different
    media on its way to the destination server.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是接收的还是发送的网络接口卡（NIC）的第 3 层都使用 IPv4，它将数据包在两个接口协议栈之间进行路由。发送的网络接口卡的第 2 层从其第 3
    层接收数据包，并在将帧发送到第 1 层之前对其进行封装。发送的第 1 层将比特转换为适合通过以太网传输的电信号。尽管数据在到达目标服务器的过程中经过了多个节点和不同的媒介，但客户端的第
    7 层中的数据在传输过程中始终没有发生变化。
- en: Routing Protocols
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由协议
- en: The routing overview in [Figure 2-15](#figure2-15) makes the process look easy,
    but the routing process relies on a symphony of protocols to make sure each packet
    reaches its destination no matter the physical medium traversed or network outages
    along the way. Routing protocols have their own criteria for determining the best
    path between nodes. Some protocols determine a route’s efficiency based on hop
    count. Some may use bandwidth. Others may use more complicated means to determine
    which route is the most efficient.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-15](#figure2-15)中的路由概览让这个过程看起来很简单，但路由过程依赖于一系列协议的协作，以确保每个数据包无论经过何种物理媒介或在途中是否出现网络故障，都能到达目标。路由协议有各自的标准来决定节点之间的最佳路径。有些协议基于跳数来决定路由的效率。有些可能使用带宽，而另一些则可能使用更复杂的方式来确定哪条路径最有效。'
- en: Routing protocols are either internal or external depending on whether they
    route packets within an autonomous system or outside of one. An *autonomous system*
    is an organization that manages one or more networks. An ISP is an example of
    an autonomous system. Each autonomous system is assigned an autonomous system
    number (ASN), as outlined in RFC 1930 ([https://tools.ietf.org/html/rfc1930/](https://tools.ietf.org/html/rfc1930/)).
    This ASN is used to broadcast an ISP’s network information to other autonomous
    systems using an external routing protocol. An *external routing protocol* routes
    data between autonomous systems. The only routing protocol we’ll cover is BGP
    since it is the glue of the internet, binding all ASN-assigned ISPs together.
    You don’t need to understand BGP in depth, but being familiar with it can help
    you better debug network issues related to your code and improve your code’s resiliency.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 路由协议可以分为内部路由协议和外部路由协议，具体取决于它们是否在自治系统内部或外部路由数据包。*自治系统*是管理一个或多个网络的组织。互联网服务提供商（ISP）就是一个自治系统的例子。每个自治系统都会被分配一个自治系统编号（ASN），如RFC
    1930中所述（[https://tools.ietf.org/html/rfc1930/](https://tools.ietf.org/html/rfc1930/)）。这个ASN用于通过外部路由协议向其他自治系统广播ISP的网络信息。*外部路由协议*在自治系统之间路由数据。我们将要讨论的唯一路由协议是BGP，因为它是互联网的“胶水”，将所有分配了ASN的ISP连接在一起。你不需要深入理解BGP，但熟悉它可以帮助你更好地调试与代码相关的网络问题，并提高代码的可靠性。
- en: The Border Gateway Protocol
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边界网关协议
- en: The *Border Gateway Protocol (BGP)* allows ASN-assigned ISPs to exchange routing
    information. BGP relies on trust between ISPs. That is, if an ISP says it manages
    a specific network and all traffic destined for that network should be sent to
    it, the other ISPs trust this claim and send traffic accordingly. As a result,
    BGP misconfigurations, or *route leaks*, often result in very public network outages.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*边界网关协议（BGP）*允许分配了ASN的ISP交换路由信息。BGP依赖于ISP之间的信任。也就是说，如果一个ISP声明它管理某个特定的网络，并且所有指向该网络的流量应该发送到它，其他ISP会信任这一声明并相应地转发流量。因此，BGP配置错误或*路由泄漏*往往会导致非常公开的网络故障。'
- en: In 2008, Pakistan Telecommunications Company effectively took down YouTube worldwide
    after the Pakistani Ministry of Communications demanded the country block *youtube.com*
    in protest of a YouTube video. Pakistan Telecom used BGP to send all requests
    destined for YouTube to a null route, a route that drops all data without notification
    to the sender. But Pakistan Telecom accidentally leaked its BGP route to the world
    instead of restricting it to the country. Other ISPs trusted the update and null
    routed YouTube requests from their clients, making *youtube.com* inaccessible
    for two hours all over the world.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 2008年，巴基斯坦电信公司通过BGP有效地让全球的YouTube服务中断，原因是巴基斯坦通信部要求该国封锁*youtube.com*，以抗议一段YouTube视频。巴基斯坦电信使用BGP将所有指向YouTube的请求发送到一个空路由，该路由会丢弃所有数据而不通知发送方。但巴基斯坦电信错误地将其BGP路由泄漏到了全球，而不是仅限于该国。其他ISP信任了这个更新，将来自其客户的YouTube请求都丢弃，使得*youtube.com*在全球范围内无法访问，持续了两个小时。
- en: In 2012, Google’s services were rerouted through Indonesia for 27 minutes when
    the ISP Moratel shared a BGP route directing all Google traffic to Moratel’s network
    as if Moratel was now hosting Google’s network infrastructure. There was speculation
    at the time that the route leakage was malicious, but Moratel blamed a hardware
    failure.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 2012年，Google的服务在27分钟内被重新路由到印度尼西亚，当时ISP Moratel共享了一条BGP路由，将所有Google流量指向Moratel的网络，仿佛Moratel正在托管Google的网络基础设施。当时有人猜测路由泄漏是恶意的，但Moratel归咎于硬件故障。
- en: BGP usually makes news only when something goes wrong. Other times, it plays
    the silent hero, serving a significant role in mitigating distributed denial-of-service
    (DDOS) attacks. In a *DDOS attack*, a malicious actor directs traffic from thousands
    of compromised nodes to a victim node with the aim of overwhelming the victim
    and consuming all its bandwidth, effectively denying service to legitimate clients.
    Companies that specialize in mitigating DDOS attacks use BGP to reroute all traffic
    destined for the victim node to their AS networks, filter out the malicious traffic
    from the legitimate traffic, and route the sanitized traffic back to the victim,
    nullifying the effects of the attack.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: BGP通常只有在出现问题时才成为新闻焦点。其他时候，它默默地发挥着重要作用，在减轻分布式拒绝服务（DDOS）攻击中扮演着重要角色。在*DDOS攻击*中，恶意行为者将来自成千上万个被攻陷节点的流量引导到受害者节点，目的是压垮受害者并消耗其所有带宽，实际上拒绝了合法客户的服务。专门从事DDOS攻击缓解的公司使用BGP将所有指向受害者节点的流量重新路由到他们的AS网络，过滤掉恶意流量与合法流量，最后将净化后的流量返回给受害者，从而抵消攻击的效果。
- en: Name and Address Resolution
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名称与地址解析
- en: The *Domain Name System**(DNS)* is a way of matching IP addresses to *domain
    names*, which are the names we enter in an address bar when we want to visit websites.
    Although the internet protocol uses IP addresses to locate hosts, domain names
    (like *google.com*) are easier for humans to understand and remember. If I gave
    you the IP address 172.217.6.14 to visit, you wouldn’t know who owned that IP
    address or what I was directing you to visit. But if I gave you *google.com* instead,
    you’d know exactly where I was sending you. DNS allows you to remember a hostname
    instead of its IP address in the same way that your smartphone’s contact list
    frees you from having to memorize all those phone numbers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*域名系统*(DNS)是一种将IP地址与*域名*匹配的方式，域名是我们在地址栏中输入的名称，用于访问网站。虽然互联网协议使用IP地址来定位主机，但域名（如*google.com*）更容易被人类理解和记住。如果我给你一个IP地址172.217.6.14，你可能不知道这个IP地址的所有者是谁，或者我让你访问的是哪个网站。但如果我给你*google.com*，你就完全知道我让你访问的是哪里。DNS允许你记住主机名，而不是它的IP地址，就像你智能手机的联系人列表让你无需记住所有电话号码一样。'
- en: All domains are children of a *top-level domain*, such as *.com*, *.net*, *.org*,
    and so on. Take *nostarch.com*, for instance. No Starch Press registered the *nostarch*
    domain on the *.com* top-level domain from a registrar with the authority from
    IANA to register *.com* domains. No Starch Press now has the exclusive authority
    to manage DNS records for *nostarch.com* and publish records on its DNS server.
    This includes the ability for No Starch Press to publish *subdomains*—a subdivision
    of a domain—under its domain. For example, *maps.google.com* is a subdomain of
    *google.com*. A longer example is *sub3.sub2.sub1.domain.com*, where *sub3* is
    a subdomain under *sub2.sub1.domain.com*, *sub2* is subdomain under *sub1.domain.com*,
    and *sub1* is a subdomain under *domain.com*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所有域名都是*顶级域名*的子域名，例如*.com*、*.net*、*.org*等。以*nostarch.com*为例。No Starch Press在具有IANA注册*.com*域名授权的注册商处注册了*nostarch*域名。现在，No
    Starch Press拥有独占权限来管理*nostarch.com*的DNS记录，并在其DNS服务器上发布记录。这包括No Starch Press发布*子域名*的能力——即一个域名的细分——在其域名下。例如，*maps.google.com*是*google.com*的一个子域名。更长的示例是*sub3.sub2.sub1.domain.com*，其中*sub3*是*sub2.sub1.domain.com*下的子域名，*sub2*是*sub1.domain.com*下的子域名，而*sub1*则是*domain.com*下的子域名。
- en: If you enter `https://nostarch.com` in your web browser, your computer will
    consult its configured *domain name resolver*, a server that knows how to retrieve
    the answer to your query. The resolver will start by asking one of the 13 IANA-maintained
    root name servers for the IP address of *nostarch.com*. The root name server will
    examine the top-level domain of the domain you requested and give your resolver
    the address of the *.com* name server. Your resolver will then ask the *.com*
    name server for *nostarch.com*’s IP address, which will examine the domain portion
    and direct your resolver to ask No Starch Press’s name server. Finally, your resolver
    will ask No Starch Press’s name server and receive the IP address that corresponds
    to *nostarch.com*. Your web browser will establish a connection to this IP address,
    retrieve the web page, and render it for you. This hierarchical journey of domain
    resolution allows you to zero in on a specific web server, and all you had to
    know was the domain name. No Starch Press is free to move its servers to a different
    ISP with new IP addresses, and yet you’ll still be able to visit its website by
    using *nostarch.com*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在网页浏览器中输入`https://nostarch.com`，你的计算机会查询其配置的*域名解析器*，这是一个知道如何检索你查询答案的服务器。解析器首先会向13个由IANA维护的根名称服务器之一询问*nostarch.com*的IP地址。根名称服务器会检查你请求的域的顶级域，并将*.com*名称服务器的地址提供给你的解析器。然后，解析器会向*.com*名称服务器请求*nostarch.com*的IP地址，后者会检查域名部分并指示解析器去询问No
    Starch Press的名称服务器。最后，解析器会向No Starch Press的名称服务器请求并获得与*nostarch.com*对应的IP地址。你的网页浏览器将与该IP地址建立连接，获取网页并呈现给你。这个域名解析的层级过程让你能够精确地定位到特定的网页服务器，而你只需要知道域名即可。No
    Starch Press可以自由将服务器迁移到新的ISP，并使用新的IP地址，但你仍然能够通过使用*nostarch.com*访问它的网站。
- en: Domain Name Resource Records
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 域名资源记录
- en: 'Domain name servers maintain *resource records* for the domains they serve.
    Resource records contain domain-specific information, used to satisfy domain name
    queries, like IP addresses, mail server hostnames, mail-handling rules, and authentication
    tokens. There are many resource records, but this section focuses on only the
    most common ones: address records, start-of-authority records, name server records,
    canonical name records, mail exchange records, pointer records, and text records.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 域名服务器为它们所服务的域名维护*资源记录*。资源记录包含特定于域的相关信息，用于满足域名查询，比如IP地址、邮件服务器主机名、邮件处理规则和身份验证令牌。有很多种资源记录，但本节仅关注最常见的几种：地址记录、授权起始记录、名称服务器记录、规范名称记录、邮件交换记录、指针记录和文本记录。
- en: Our exploration of each resource record will use a utility called *dig* to query
    domain name servers. This utility may be available on your operating system, but
    in case you don’t have dig installed, you can use the G Suite Toolbox Dig utility
    ([https://toolbox.googleapps.com/apps/dig/](https://toolbox.googleapps.com/apps/dig/))
    in a web browser and receive similar output. All domain names you’ll see are *fully
    qualified*, which means they end in a period, displaying the domain’s entire hierarchy
    from the root zone. The *root zone* is the top DNS namespace.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对每个资源记录的探索将使用一个名为*dig*的工具来查询域名服务器。这个工具可能已经包含在你的操作系统中，但如果你没有安装dig，可以在网页浏览器中使用G
    Suite工具箱中的Dig工具([https://toolbox.googleapps.com/apps/dig/](https://toolbox.googleapps.com/apps/dig/))，并获得类似的输出。你将看到的所有域名都是*完全限定*的，这意味着它们以句点结束，显示了域名从根区域开始的完整层级结构。*根区域*是顶级的DNS命名空间。
- en: Dig’s default output includes a bit of data relevant to your query but irrelevant
    to your study of its output. Therefore, I’ve elected to snip out header and footer
    information in dig’s output in each example to follow. Also please be aware that
    the specific output in this book is a snapshot from when I executed each query.
    It may look different when you execute these commands.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Dig的默认输出包含一些与查询相关但与研究输出无关的数据。因此，我决定在接下来的每个示例中将dig输出中的头部和尾部信息剪切掉。请注意，本书中展示的具体输出是我执行每个查询时的快照。你执行这些命令时，输出可能会有所不同。
- en: The Address Record
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 地址记录
- en: The *Address (A) record* is the most common record you’ll query. An A record
    will resolve to one or more IPv4 addresses. When your computer asks its resolver
    to retrieve the IP address for *nostarch.com*, the resolver ultimately asks the
    domain name server for the *nostarch.com* Address (A) resource record. [Listing
    2-1](#listing2-1) shows the question and answer sections when you query for the
    *google.com* A record.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*地址 (A) 记录* 是你最常查询的记录。A记录将解析为一个或多个IPv4地址。当你的计算机请求其解析器获取*nostarch.com*的IP地址时，解析器最终会向域名服务器请求*nostarch.com*的地址(A)资源记录。[清单
    2-1](#listing2-1)展示了你查询*google.com* A记录时的提问和回答部分。'
- en: '[PRE0]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 2-1: DNS answer of the *google.com* A resource record'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-1：*google.com* A资源记录的DNS响应
- en: Each section in a DNS reply begins with a header 1, prefixed with a semicolon
    to indicate that the line is a comment rather than code to be processed. Within
    the question section, you ask the domain name server for the domain name *google.com*2
    with the class `IN`3, which indicates that this record is internet related. You
    also use `A` to ask for the A record 4 specifically.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: DNS回复的每个部分都以头部1开始，前缀为分号，表示这一行是注释而不是需要处理的代码。在查询部分中，你向域名服务器请求域名*google.com*2，并使用类`IN`3，表示该记录与互联网相关。你还使用`A`专门请求A记录4。
- en: In the Answer section 5, the domain name server resolves the *google.com* A
    record to six IPv4 addresses. The first field of each returned line is the domain
    name 6 you queried. The second field is the TTL value 7 for the record. The *TTL
    value* tells domain name resolvers how long to cache or remember the record, and
    it lets you know how long you have until the cached record expires. When you request
    a DNS record, the domain name resolver will first check its cache. If the answer
    is in its cache, it will simply return the cached answer instead of asking the
    domain name server for the answer. This improves domain name resolution performance
    for records that are unlikely to change frequently. In this example, the record
    will expire in 299 seconds. The last field is the IPv4 address 8. Your web browser
    could use any one of the six IPv4 addresses to establish a connection to *google.com*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应部分5中，域名服务器将*google.com*的A记录解析为六个IPv4地址。每个返回行的第一个字段是你查询的域名6。第二个字段是记录的TTL值7。*TTL值*
    告诉域名解析器该记录应该缓存多长时间，或者记住该记录，它也告诉你缓存记录将过期的时间。当你请求DNS记录时，域名解析器会首先检查其缓存。如果答案已经在缓存中，它将直接返回缓存中的答案，而不是再次向域名服务器请求答案。这提高了对于不太可能频繁更改的记录的域名解析性能。在本例中，记录将在299秒后过期。最后一个字段是IPv4地址8。你的网页浏览器可以使用这六个IPv4地址中的任何一个与*google.com*建立连接。
- en: The AAAA resource record is the IPv6 equivalent of the A record.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: AAAA资源记录是A记录的IPv6等效项。
- en: The Start of Authority Record
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 授权起始记录
- en: The *Start of Authority (SOA) record* contains authoritative and administrative
    details about the domain, as shown in [Listing 2-2](#listing2-2). All domains
    must have an SOA record.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*授权起始记录 (SOA)* 包含有关域名的权威性和管理细节，如[清单 2-2](#listing2-2)所示。所有域名必须拥有一个SOA记录。'
- en: '[PRE1]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 2-2: DNS answer of the *google.com* SOA resource record'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-2：*google.com* SOA资源记录的DNS响应
- en: The first four fields of an SOA record are the same as those found in an A record.
    The SOA record also includes the primary name server 1, the administrator’s email
    address 2, and fields 3 used by secondary name servers outside the scope of this
    book. Domain name servers primarily consume SOA records. However, the email address
    is useful if you wish to contact the domain’s administrator.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: SOA记录的前四个字段与A记录中的字段相同。SOA记录还包括主名称服务器1、管理员的电子邮件地址2以及第3个字段，这是次级名称服务器在本书范围外使用的字段。域名服务器主要使用SOA记录。然而，如果你希望联系域名管理员，电子邮件地址非常有用。
- en: The Name Server Record
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 名称服务器记录
- en: The *Name Server (NS) record* returns the authoritative name servers for the
    domain name. *Authoritative name servers* are the name servers able to provide
    answers for the domain name. NS records will include the primary name server from
    the SOA record and any secondary name servers answering DNS queries for the domain.
    [Listing 2-3](#listing2-3) is an example of the NS records for *google.com*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*名称服务器 (NS) 记录* 返回该域名的权威名称服务器。*权威名称服务器* 是能够为域名提供解答的名称服务器。NS记录将包括来自SOA记录的主名称服务器和任何为该域名回答DNS查询的次级名称服务器。[清单
    2-3](#listing2-3)是*google.com*的NS记录示例。'
- en: '[PRE2]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 2-3: DNS answer of the *google.com* NS resource records'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-3：*google.com* NS资源记录的DNS响应
- en: Like the CNAME record, discussed next, the NS record will return a fully qualified
    domain name 1, not an IP address.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与接下来讨论的CNAME记录类似，NS记录将返回一个完全合格的域名1，而不是IP地址。
- en: The Canonical Name Record
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规范名称记录
- en: The *Canonical Name (CNAME) record* points one domain at another. [Listing 2-4](#listing2-4)
    shows a CNAME record response. CNAME records can make administration a bit easier.
    For example, you can create one named *mail.yourdomain.com* and direct it to Gmail’s
    login page. This not only is easier for your users to remember but also gives
    you the flexibility of pointing the CNAME at another email provider in the future
    without having to inform your users.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*规范名称（CNAME）记录*将一个域名指向另一个域名。[列表 2-4](#listing2-4)展示了CNAME记录的响应。CNAME记录可以使管理工作变得更加简单。例如，你可以创建一个名为*mail.yourdomain.com*的域名，并将其指向Gmail的登录页面。这不仅使得你的用户更容易记住，而且你还可以在未来将CNAME指向另一个邮件提供商，而无需通知你的用户。'
- en: '[PRE3]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 2-4: DNS answer of the *mail.google.com* CNAME resource record'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-4：*mail.google.com* CNAME资源记录的DNS回答
- en: Notice that you ask the domain name server for the A record of the subdomain
    *mail.google.com*. But in this case, you receive a CNAME instead. This tells you
    that *googlemail.l.google.com*2 is the canonical name for *mail.google.com*1.
    Thankfully, you receive the A record for *googlemail.l.google.com* with the response,
    alleviating you from having to make a second query. You now know your destination
    IP address is 172.217.3.229\. Google’s domain name server was able to return both
    the CNAME answer and the corresponding Address answer in the same reply because
    it is an authority for the CNAME answer’s domain name as well. Otherwise, you
    would expect only the CNAME answer and would then need to make a second query
    to resolve the CNAME answer’s IP address.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你向域名服务器请求子域名*mail.google.com*的A记录。但在这种情况下，你收到的是CNAME记录。这意味着*googlemail.l.google.com*2是*mail.google.com*1的规范名称。幸运的是，你收到了*googlemail.l.google.com*的A记录响应，这使得你不必再进行第二次查询。现在你知道目标IP地址是172.217.3.229。Google的域名服务器能够在同一回复中同时返回CNAME答案和相应的地址答案，因为它也对CNAME答案的域名有权威性。否则，你只会得到CNAME答案，然后需要进行第二次查询来解析CNAME答案的IP地址。
- en: The Mail Exchange Record
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 邮件交换记录
- en: The *Mail Exchange (MX) record* specifies the mail server hostnames that should
    be contacted when sending email to recipients at the domain. Remote mail servers
    will query the MX records for the domain portion of a recipient’s email address
    to determine which servers should receive mail for the recipient. [Listing 2-5](#listing2-5)
    shows the response a mail server will receive.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*邮件交换（MX）记录*指定了在向该域的收件人发送邮件时应联系的邮件服务器主机名。远程邮件服务器会查询该域部分的收件人电子邮件地址中的MX记录，以确定应将邮件发送到哪些服务器。[列表
    2-5](#listing2-5)展示了邮件服务器会收到的响应。'
- en: '[PRE4]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 2-5: DNS answer of the *google.com* MX resource records'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-5：*google.com* MX资源记录的DNS回答
- en: In addition to the domain name, TTL value, and record type, MX records contain
    the *priority field*1, which rates the priority of each mail server. The lower
    the number, the higher the priority of the mail server. Mail servers attempt to
    deliver emails to the mail server with the highest priority, then resort to the
    mail servers with the next highest priority if necessary. If more than one mail
    server shares the same priority, the mail server will pick one at random.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 除了域名、TTL值和记录类型外，MX记录还包含*优先级字段*1，用于表示每个邮件服务器的优先级。数字越低，邮件服务器的优先级越高。邮件服务器会尝试将邮件投递到优先级最高的服务器，如果需要，才会转向下一个优先级较高的服务器。如果多个邮件服务器共享相同的优先级，则会随机选择一个邮件服务器。
- en: The Pointer Record
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 指针记录
- en: The *Pointer (PTR) record* allows you to perform a reverse lookup by accepting
    an IP address and returning its corresponding domain name. [Listing 2-6](#listing2-6)
    shows the reverse lookup for 8.8.4.4.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*指针（PTR）记录*允许你通过提供IP地址并返回其对应的域名来执行反向查找。[列表 2-6](#listing2-6)展示了8.8.4.4的反向查找。'
- en: '[PRE5]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 2-6: DNS answer of the 8.8.4.4 PTR resource record'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-6：8.8.4.4 PTR资源记录的DNS回答
- en: To perform the query, you ask the domain name server for the IPv4 address in
    reverse order 1 with the special domain *in-addr.arpa* appended because the reverse
    DNS records are all under the *.arpa* top-level domain. For example, querying
    the pointer record for the IP 1.2.3.4 means you need to ask for *4.3.2.1.in-addr.arpa*.
    The query in [Listing 2-6](#listing2-6) tells you that the IPv4 address 8.8.4.4
    reverses to the domain name *google-public-dns-b.google.com*2. If you were performing
    a reverse lookup of an IPv6 address, you’d append the special domain *ip6.arpa*
    to the reversed IPv6 address as you did for the IPv4 address.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行查询，你需要向域名服务器请求反向顺序的 IPv4 地址 1，并附加特殊域名 *in-addr.arpa*，因为反向 DNS 记录都位于 *.arpa*
    顶级域下。例如，查询 IP 1.2.3.4 的指针记录意味着你需要请求 *4.3.2.1.in-addr.arpa*。[列表 2-6](#listing2-6)
    中的查询告诉你，IPv4 地址 8.8.4.4 会反向解析为域名 *google-public-dns-b.google.com* 2。如果你正在执行 IPv6
    地址的反向查找，你需要像处理 IPv4 地址那样，将特殊域名 *ip6.arpa* 附加到反向的 IPv6 地址上。
- en: The Text Record
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文本记录
- en: The *Text (TXT) record* allows the domain owner to return arbitrary text. These
    records can contain values that prove domain ownership, values that remote mail
    servers can use to authorize email, and entries to specify which IP addresses
    may send mail on behalf of the domain, among other uses. [Listing 2-7](#listing2-7)
    shows the text records associated with *google.com*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*文本（TXT）记录* 允许域名所有者返回任意文本。这些记录可以包含证明域名所有权的值、远程邮件服务器可以用来授权邮件的值，以及指定哪些 IP 地址可以代表该域名发送邮件的条目等用途。[列表
    2-7](#listing2-7) 显示了与 *google.com* 关联的文本记录。'
- en: '[PRE6]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 2-7: DNS answer of the google.com TXT resource records'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-7：google.com TXT 资源记录的 DNS 答复
- en: The domain queries and answers should start to look familiar by now. The last
    field in a TXT record is a string of the TXT record value 1. In this example,
    the field has a Facebook verification key, which proves to Facebook that Google’s
    corporate Facebook account is who they say they are and has the authority to make
    changes to Google’s content on Facebook. It also contains *Sender Policy Framework*
    rules 2, which inform remote mail servers which IP addresses may deliver email
    on Google’s behalf.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 域名查询和答案现在应该开始变得熟悉。TXT 记录中的最后一个字段是 TXT 记录值 1 的一串字符串。在这个示例中，该字段包含一个 Facebook 验证密钥，它向
    Facebook 证明 Google 的企业 Facebook 账户就是他们所说的那个，并且有权对 Google 在 Facebook 上的内容进行修改。它还包含
    *发送者策略框架* 规则 2，告知远程邮件服务器哪些 IP 地址可以代表 Google 发送电子邮件。
- en: Multicast DNS
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多播 DNS
- en: '*Multicast DNS**(mDNS)* is a protocol that facilitates name resolution over
    a local area network (LAN) in the absence of a DNS server. When a node wants to
    resolve a domain name to an IP address, it will send a request to an IP multicast
    group. Nodes listening to the group receive the query, and the node with the requested
    domain name responds to the IP multicast group with its IP address. You may have
    used mDNS the last time you searched for and configured a network printer on your
    computer.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*多播 DNS*（mDNS）是一种协议，能在没有 DNS 服务器的情况下，通过局域网（LAN）实现名称解析。当一个节点想要将域名解析为 IP 地址时，它会向一个
    IP 多播组发送请求。监听该组的节点会接收查询，请求该域名的节点会向 IP 多播组返回其 IP 地址。你可能在上次搜索和配置网络打印机时使用过 mDNS。'
- en: Privacy and Security Considerations of DNS Queries
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DNS 查询的隐私和安全考虑
- en: DNS traffic is typically unencrypted when it traverses the internet. A potential
    exception occurs if you’re connected to a virtual private network (VPN) and are
    careful to make sure all DNS traffic passes through its encrypted tunnel. Because
    of DNS’s unencrypted transport, unscrupulous ISPs or intermediate providers may
    glean sensitive information in your DNS queries and share those details with third
    parties. You can make a point of visiting HTTPS-only websites, but your DNS queries
    may betray your otherwise secure browsing habits and allow the DNS server’s administrators
    to glean the sites you visit.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 流量通常在穿越互联网时是未加密的。一个潜在的例外情况是，如果你连接到虚拟私人网络（VPN），并且确保所有的 DNS 流量都通过其加密隧道传输。由于
    DNS 的未加密传输，某些不道德的互联网服务提供商（ISP）或中间提供商可能会获取你 DNS 查询中的敏感信息，并将这些细节与第三方共享。你可以专门访问仅支持
    HTTPS 的网站，但你的 DNS 查询可能会暴露你本应安全的浏览习惯，从而使 DNS 服务器的管理员了解你访问的站点。
- en: Security is also a concern with plaintext DNS traffic. An attacker could convince
    your web browser to visit a malicious website by inserting a response to your
    DNS query. Considering the difficulty of pulling off such an attack, it’s not
    an attack you’re likely to experience, but it’s concerning nonetheless. Since
    DNS servers often cache responses, this attack usually takes place between your
    device and the DNS server it’s configured to use. RFC 7626 ([https://tools.ietf.org/html/rfc7626/](https://tools.ietf.org/html/rfc7626/))
    covers these topics in more detail.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性在明文DNS流量中也是一个问题。攻击者可以通过插入对你的DNS查询的响应，诱使你的网页浏览器访问恶意网站。考虑到实施这种攻击的难度，这不是你可能会遇到的攻击，但无论如何还是令人担忧。由于DNS服务器通常会缓存响应，这种攻击通常发生在你的设备和它所配置使用的DNS服务器之间。RFC
    7626（[https://tools.ietf.org/html/rfc7626/](https://tools.ietf.org/html/rfc7626/)）更详细地覆盖了这些话题。
- en: Domain Name System Security Extensions
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 域名系统安全扩展
- en: 'Generally, you can ensure the authenticity of data sent over a network in two
    ways: authenticating the content and authenticating the channel. *Domain Name
    System Security Extensions**(DNSSEC)* is a method to prevent the covert modification
    of DNS responses in transit by using digital signatures to authenticate the response.
    DNSSEC ensures the authenticity of data by authenticating the content. DNS servers
    cryptographically sign the resource records they serve and make those signatures
    available to you. You can then validate the responses from authoritative DNS servers
    against the signatures to make sure the responses aren’t fraudulent.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以通过两种方式确保通过网络发送数据的真实性：认证内容和认证通道。*域名系统安全扩展**（DNSSEC）*是一种通过使用数字签名来认证响应，从而防止在传输过程中对DNS响应进行隐秘修改的方法。DNSSEC通过认证内容来确保数据的真实性。DNS服务器对它们提供的资源记录进行加密签名，并将这些签名提供给你。然后，你可以根据这些签名验证来自权威DNS服务器的响应，以确保响应没有被篡改。
- en: DNSSEC doesn’t address privacy concerns. DNSSEC queries still traverse the network
    unencrypted, allowing for passive observation.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: DNSSEC没有解决隐私问题。DNSSEC查询仍然是明文传输的，允许进行被动观察。
- en: DNS over TLS
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于TLS的DNS
- en: DNS over TLS (DoT), detailed in RFC 7858 ([https://tools.ietf.org/html/rfc7858/](https://tools.ietf.org/html/rfc7858/)),
    addresses both security and privacy concerns by using *Transport Layer Security**(TLS)*
    to establish an encrypted connection between the client and its DNS server. TLS
    is a common protocol used to provide cryptographically secure communication between
    nodes on a network. Using TLS, DNS requests and responses are fully encrypted
    in transit, making it impossible for an attacker to eavesdrop on or manipulate
    responses. DoT ensures the authenticity of data by authenticating the channel.
    It does not need to rely on cryptographic signatures like DNSSEC because the entire
    conversation between the DNS server and the client is encrypted.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 基于TLS的DNS（DoT），在RFC 7858中有详细说明（[https://tools.ietf.org/html/rfc7858/](https://tools.ietf.org/html/rfc7858/)），通过使用*传输层安全协议**（TLS）*在客户端和其DNS服务器之间建立加密连接，解决了安全性和隐私问题。TLS是一种常用的协议，用于提供网络节点之间加密的安全通信。使用TLS，DNS请求和响应在传输过程中完全加密，使得攻击者无法窃听或篡改响应。DoT通过认证通道来确保数据的真实性。它不需要像DNSSEC那样依赖加密签名，因为DNS服务器和客户端之间的整个对话都是加密的。
- en: DoT uses a different network port than does regular DNS traffic.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: DoT使用与常规DNS流量不同的网络端口。
- en: DNS over HTTPS
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于HTTPS的DNS
- en: '*DNS over HTTPS (DoH)*,detailed in RFC 8484([https://tools.ietf.org/html/rfc8484/](https://tools.ietf.org/html/rfc8484/))
    aims to address DNS security and privacy concerns while using a heavily used TCP
    port. Like DoT, DoH sends data over an encrypted connection, authenticating the
    channel. DoH uses a common port and maps DNS requests and responses to HTTP requests
    and responses. Queries over HTTP can take advantage of all HTTP features, such
    as caching, compression, proxying, and redirection.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于HTTPS的DNS（DoH）*，在RFC 8484中有详细说明（[https://tools.ietf.org/html/rfc8484/](https://tools.ietf.org/html/rfc8484/)），旨在解决DNS安全性和隐私问题，同时使用一个被广泛使用的TCP端口。与DoT一样，DoH通过加密连接传输数据，认证通道。DoH使用一个常见的端口，并将DNS请求和响应映射到HTTP请求和响应。通过HTTP的查询可以利用所有HTTP特性，如缓存、压缩、代理和重定向。'
- en: What You’ve Learned
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你学到的内容
- en: We covered a lot of ground in this chapter. You learned about IP addressing,
    starting with the basics of IPv4 multicasting, broadcasting, TCP and UDP ports,
    socket addresses, network address translation, and ARP. You then learned about
    IPv6, its address categories, and its advantages over IPv4.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容涉及广泛。你学习了 IP 地址分配，从 IPv4 的多播、广播、TCP 和 UDP 端口、套接字地址、网络地址转换到 ARP 等基础知识。然后，你了解了
    IPv6、其地址类别以及相较于 IPv4 的优势。
- en: You learned about the major network-routing protocols, ICMP and DNS. I’ll again
    recommend the *TCP/IP Guide* by Charles M. Kozierok (No Starch Press, 2005) for
    its extensive coverage of the topics in this chapter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解了主要的网络路由协议，ICMP 和 DNS。我再次推荐 Charles M. Kozierok 的 *TCP/IP Guide*（No Starch
    Press，2005），它对本章主题进行了广泛的覆盖。
