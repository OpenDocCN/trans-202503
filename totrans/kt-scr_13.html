<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><section aria-labelledby="ch9" epub:type="chapter" role="doc-chapter">
<span aria-label="345" epub:type="pagebreak" id="pg_345" role="doc-pagebreak"/>
<hgroup>
<h2 class="title" id="ch9">
<span class="tpt"><span class="sans_dogma_ot_bold_b_">9</span></span>
<span class="ct"><span class="sans_dogma_ot_bold_b_">AGENT-BASED ALGORITHMS</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener1" height="380" src="../images/icon.jpg" width="381"/>
</figure>
<p class="chapterintro">In this chapter, we’ll continue to explore NIAs, focusing on two algorithms based on the collective behavior of social animals: particle swarm optimization and ant colony systems. These algorithms are designed for <span class="chapterintro_italic">agent-based models</span>, in which a swarm of simple agents work together and interact with their surroundings to create outcomes that benefit the whole colony.</p>
<p class="tx">We’ll explain the key concepts and principles behind these algorithms and implement them using pseudocode. We’ll also put these algorithms to the test by developing two Kotlin applications to solve real-world problems. The first is function minimization, which uses particle swarm optimization to find the global minimum of a given function. The second is the traveling salesman problem, which uses ant colony systems to find the shortest route that connects a large number of cities.</p>
<section aria-labelledby="sec1" epub:type="division">
<span aria-label="346" epub:type="pagebreak" id="pg_346" role="doc-pagebreak"/>
<h3 class="h"><span id="sec1"/><span id="h1-55"/><span class="sans_futura_std_bold_b_">An Overview of Particle Swarm Optimization</span></h3>
<p class="tni">The particle swarm optimization (PSO) algorithm has been used to solve a wide range of optimization problems. PSO has a few similarities with the genetic algorithm. Both methods involve working with a population (of chromosomes or particles), members of which help us look for an optimal solution until a stopping condition is met. Both methods are also stochastic and rely on underlying processes with built-in elements of randomness.</p>
<p class="tx">That’s where the similarities end. Unlike the genetic algorithm, the PSO algorithm does not depend on genetic operators such as selection, crossover, and mutation. Instead, it is driven by autonomous agents that update their positions in the decision space based on their current and past positions, as well as the best position identified by the swarm. PSO involves a deliberate effort to continuously move toward a better solution, which is very different from the passive selection-driven upgrading of chromosomes in the genetic algorithm. Individual chromosomes do not have any ability to sense their neighborhood or make decisions to update their composition as the particles do in PSO. Further, PSO is conceptually simpler and easier to implement, involves fewer parameters, and tends to converge more quickly on the global optima, compared with the genetic algorithm.</p>
<p class="tx">At its core, the PSO algorithm consists of three key steps:</p>
<p class="listnumber">  1.  Initialize the position and velocity of the particles.</p>
<p class="listnumber1">  2.  Proceed through the time steps, and update particle velocities based on the current velocity, the best-so-far individual position, and the global best position identified by the swarm up to that time step.</p>
<p class="listnumber2">  3.  Update the current position by moving to a better position.</p>
<p class="tni">These steps are repeated for a set number of times or until a stopping condition is met.</p>
<p class="tx">Let <b class="calibre6"><i class="calibre9">x</i></b><span class="epub-i-sub">i</span><sup class="calibre8">0</sup> and <b class="calibre6"><i class="calibre9">v</i></b><span class="epub-i-sub">i</span><sup class="calibre8">0</sup> be the position and velocity vectors at time <i class="calibre9">t</i> = 0, where <i class="calibre9">i</i> <span class="copyright_accent">∈</span> <b class="calibre6">I</b> denotes the <i class="calibre9">i</i>th particle in a swarm of size N (<b class="calibre6">I</b> = [1, 2, . . . , N]). Also, let <b class="calibre6"><i class="calibre9">x</i></b><span class="epub-i-sub">max</span> and <b class="calibre6"><i class="calibre9">x</i></b><span class="epub-i-sub">min</span> be the upper and lower bounds for the position vector and <i class="calibre9">r</i> be a random value between 0 and 1 selected from a uniform distribution.</p>
<p class="tx">The first step of PSO is to initialize the position and velocity vectors as shown in Equations 9.1 and 9.2.</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msubsup><mtext class="BI">x</mtext><mi>i</mi><mn>0</mn></msubsup><mo>=</mo><msub><mtext class="BI">x</mtext><mrow><mstyle mathsize="normal"><mi>m</mi><mi>i</mi><mi>n</mi></mstyle></mrow></msub><mo>+</mo><mi>r</mi><mo stretchy="false">(</mo><msub><mtext class="BI">x</mtext><mrow><mstyle mathsize="normal"><mi>m</mi><mi>a</mi><mi>x</mi></mstyle></mrow></msub><mo>−</mo><msub><mtext class="BI">x</mtext><mrow><mstyle mathsize="normal"><mi>m</mi><mi>i</mi><mi>n</mi></mstyle></mrow></msub><mo stretchy="false">)</mo></mrow></math> (9.1)<span class="sblock"/><math alttext="Equation" display="inline"><mrow><msubsup><mtext class="BI">v</mtext><mi>i</mi><mn>0</mn></msubsup><mo>=</mo><mn>0</mn></mrow></math> (9.2)</span>
<span class="mobi"><img alt="" class="img1" height="127" src="../images/eq9-1-2.jpg" width="1387"/></span></figure>
<p class="tx">In Equation 9.2, for the purposes of this chapter, we set the initial velocities to zero. The alternative is to set them to small random values. In most cases, the swarm will quickly move away from the randomly assigned initial position, and the choice of initial velocity will not have a noticeable impact on the convergence rate as long as the magnitude of the velocity stays within the decision space.</p>
<p class="tx"><span aria-label="347" epub:type="pagebreak" id="pg_347" role="doc-pagebreak"/>The second step of PSO is to update the velocity vector <span class="epub"><math alttext="Equation" display="inline"><mrow><msubsup><mstyle mathsize="normal" mathvariant="bold"><mi>v</mi></mstyle><mi>i</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow></math></span>
<span class="mobi"><img alt="" class="inline" src="../images/pg347-in-1.jpg"/></span> for the particles by using the following equation:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msubsup><mtext class="BI">v</mtext><mi>i</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mi>w</mi><msubsup><mtext class="BI">v</mtext><mi>i</mi><mi>t</mi></msubsup><mo>+</mo><mtext>c</mtext><mn>1</mn><mtext> </mtext><mtext>r</mtext><mn>1</mn><mtext> </mtext><mo stretchy="false">(</mo><msubsup><mtext class="BI">b</mtext><mi>i</mi><mi>t</mi></msubsup><mo>−</mo><msubsup><mtext class="BI">x</mtext><mi>i</mi><mi>t</mi></msubsup><mo stretchy="false">)</mo><mo>+</mo><mtext>c</mtext><mn>2</mn><mtext> </mtext><mtext>r</mtext><mn>2</mn><mtext> </mtext><mo stretchy="false">(</mo><msubsup><mtext class="BI">g</mtext><mi>s</mi><mi>t</mi></msubsup><mo>−</mo><msubsup><mtext class="BI">x</mtext><mi>i</mi><mi>t</mi></msubsup><mo stretchy="false">)</mo></mrow></math> (9.3)</span>
<span class="mobi"><img alt="" class="img1" height="42" src="../images/eq9-3.jpg" width="1388"/></span></figure>
<p class="tx">The variables and parameters in Equation 9.3 stand for the following:</p>
<p class="listhead"><i class="calibre9">w</i>             Inertia factor</p>
<p class="tni">c1            Particle memory/cognitive factor</p>
<p class="tni">c2            Swarm memory/social factor</p>
<p class="tni">r1, r2       Random values between 0 and 1 chosen from a uniform distribution</p>
<p class="tni"><span><span class="epub"><math alttext="Equation" display="inline"><mrow><msubsup><mstyle mathsize="normal" mathvariant="bold"><mi>b</mi></mstyle><mi>i</mi><mi>t</mi></msubsup></mrow></math></span>
<span class="mobi"><img alt="" class="inline1" src="../images/pg347-in-2.jpg"/></span></span>            Best position vector found by particle <i class="calibre9">i</i> up to time <i class="calibre9">t</i></p>
<p class="tni"><span><span class="epub"><math alttext="Equation" display="inline"><mrow><msubsup><mstyle mathsize="normal" mathvariant="bold"><mi>g</mi></mstyle><mi>s</mi><mi>t</mi></msubsup></mrow></math></span>
<span class="mobi"><img alt="" class="inline2" src="../images/pg347-in-3.jpg"/></span></span>            Best position vector found by the swarm up to time <i class="calibre9">t</i></p>
<p class="tni"><span><span class="epub"><math alttext="Equation" display="inline"><mrow><msubsup><mstyle mathsize="normal" mathvariant="bold"><mi>v</mi></mstyle><mi>i</mi><mi>t</mi></msubsup><mo>,</mo><msubsup><mstyle mathsize="normal" mathvariant="bold"><mi>v</mi></mstyle><mi>i</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow></math></span>
<span class="mobi"><img alt="" class="inline3" src="../images/pg347-in-4.jpg"/></span></span> Velocity vectors of particle <i class="calibre9">i</i> at time <i class="calibre9">t</i> and <i class="calibre9">t</i> + 1, respectively</p>
<p class="tabularlistlast"><span><span class="epub"><math alttext="Equation" display="inline"><mrow><msubsup><mstyle mathsize="normal" mathvariant="bold"><mi>x</mi></mstyle><mi>i</mi><mi>t</mi></msubsup></mrow></math></span>
<span class="mobi"><img alt="" class="inline4" src="../images/pg347-in-5.jpg"/></span></span>            Position vector of particle <i class="calibre9">i</i> at time <i class="calibre9">t</i></p>
<p class="tx"><a href="chapter9.xhtml#fig9-1" class="calibre2">Figure 9-1</a> provides a visual and more intuitive interpretation of Equation 9.3.</p>
<figure class="img"><img alt="" class="img1" height="734" id="fig9-1" src="../images/Figure9-1.jpg" width="1483"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 9-1: A graphical representation of the strategy for updating velocity in PSO</span></p></figcaption>
</figure>
<p class="tx">Let’s consider an arbitrary particle <i class="calibre9">i</i> whose current position is <span><span class="epub"><math alttext="Equation" display="inline"><mrow><msubsup><mi>x</mi><mi>i</mi><mi>t</mi></msubsup></mrow></math></span>
<span class="mobi"><img alt="" class="inline1" src="../images/pg347-in-6.jpg"/></span></span> (for simplicity’s sake, we’ll consider a one-dimensional problem). Because of inertia, the particle will tend to move toward the direction of its current velocity, <span><span class="epub"><math alttext="Equation" display="inline"><mrow><msubsup><mi>v</mi><mi>i</mi><mi>t</mi></msubsup></mrow></math></span>
<span class="mobi"><img alt="" class="inline1" src="../images/pg347-in-7.jpg"/></span>.</span> However, PSO relies on learning from both particle- and swarm-level best solutions found so far—<span><span class="epub"><math alttext="Equation" display="inline"><mrow><msubsup><mi>b</mi><mi>i</mi><mi>t</mi></msubsup></mrow></math></span>
<span class="mobi"><img alt="" class="inline1" src="../images/pg347-in-8.jpg"/></span></span> and <span><span class="epub"><math alttext="Equation" display="inline"><mrow><msubsup><mi>g</mi><mi>s</mi><mi>t</mi></msubsup></mrow></math></span>
<span class="mobi"><img alt="" class="inline2" src="../images/pg347-in-9.jpg"/></span></span>. As a result, the particle incorporates this information by moving a bit toward <span><span class="epub"><math alttext="Equation" display="inline"><mrow><msubsup><mi>b</mi><mi>i</mi><mi>t</mi></msubsup></mrow></math></span>
<span class="mobi"><img alt="" class="inline1" src="../images/pg347-in-10.jpg"/></span></span> <span aria-label="annotation1" class="codeannotation">❶</span> and then toward <span><span class="epub"><math alttext="Equation" display="inline"><mrow><msubsup><mi>g</mi><mi>s</mi><mi>t</mi></msubsup></mrow></math></span>
<span class="mobi"><img alt="" class="inline2" src="../images/pg347-in-11.jpg"/></span></span> <span aria-label="annotation2" class="codeannotation">❷</span>, as well as toward its own velocity <span><span class="epub"><math alttext="Equation" display="inline"><mrow><msubsup><mi>v</mi><mi>i</mi><mi>t</mi></msubsup></mrow></math></span>
<span class="mobi"><img alt="" class="inline1" src="../images/pg347-in-12.jpg"/></span></span> <span aria-label="annotation3" class="codeannotation">❸</span>. <a href="chapter9.xhtml#fig9-1" class="calibre2">Figure 9-1</a> shows the result of all these movements as <span><span class="epub"><math alttext="Equation" display="inline"><mrow><msubsup><mi>v</mi><mi>i</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow></math></span>
<span class="mobi"><img alt="" class="inline5" src="../images/pg347-in-13.jpg"/></span></span>. Equation 9.3 captures the same movements symbolically in multiple dimensions, along with the relative weights assigned to each of these components.</p>
<p class="tx">The inertia factor <i class="calibre9">w</i> is typically assigned a value between 0 and 1, where a value of 0 would imply no impact of <span class="epub"><math alttext="Equation" display="inline"><mrow><msubsup><mi>v</mi><mi>i</mi><mi>t</mi></msubsup></mrow></math></span>
<span class="mobi"><img alt="" class="inline4" src="../images/pg347-in-14.jpg"/></span> on <span class="epub"><math alttext="Equation" display="inline"><mrow><msubsup><mi>v</mi><mi>i</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow></math></span>
<span class="mobi"><img alt="" class="inline5" src="../images/pg347-in-15.jpg"/></span> and 1 would imply full <span aria-label="348" epub:type="pagebreak" id="pg_348" role="doc-pagebreak"/>impact. It is also possible to adjust the value of <i class="calibre9">w</i> over time, which can lead to better convergence properties. This scheme is implemented by initially setting <i class="calibre9">w</i> to ≥ 1 and gradually decreasing it per Equation 9.4.</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msup><mi>w</mi><mi>t</mi></msup><mo>=</mo><msub><mtext>w</mtext><mrow><mi>max</mi></mrow></msub><mo>−</mo><mfenced><mrow><mfrac><mi>t</mi><mrow><msub><mi>t</mi><mrow><mi>max</mi></mrow></msub></mrow></mfrac></mrow></mfenced><mtext> </mtext><mo stretchy="false">(</mo><msub><mtext>w</mtext><mrow><mtext>max</mtext></mrow></msub><mo>−</mo><msub><mtext>w</mtext><mrow><mi>min</mi></mrow></msub><mo stretchy="false">)</mo></mrow></math> (9.4)</span>
<span class="mobi"><img alt="" class="img1" height="82" src="../images/eq9-4.jpg" width="1386"/></span></figure>
<p class="tx">The c1 and c2 factors in Equation 9.3 are also called <i class="calibre9">acceleration coefficients</i>. Along with the random variables r1 and r2, these coefficients determine the degree of influence of the particle-best and swarm-best positions on the updated velocity of a particle.</p>
<p class="tx">As is evident from Equation 9.3, when both c1 and c2 = 0, particles will keep moving at constant velocities until they hit the boundaries of the decision space. If c1 &gt; 0 and c2 = 0, particles will behave as if they’re independent (no information gathered from the swarm). When c1 = 0 and c2 &gt; 0, the entire swarm will move toward the best position found collectively so far.</p>
<p class="tx">While the optimal values for these parameters are likely to be problem specific, the commonly used values found in the literature range from 0.5 to 2.5 for both c1 and c2. It is also common practice to keep c1 equal to c2 and ensure both values are relatively small to allow for a thorough exploration of the decision space without causing <i class="calibre9">velocity explosion</i>, which refers to excessive velocity and large jumps across the decision space. To avoid this, an upper limit for the velocity of particle <i class="calibre9">i</i> along dimension <i class="calibre9">j</i> is set as follows (for all time steps):</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mo>−</mo><msubsup><mi>v</mi><mi>j</mi><mrow><mstyle mathsize="normal"><mi>m</mi><mi>a</mi><mi>x</mi></mstyle></mrow></msubsup><mo>≤</mo><msub><mi>v</mi><mrow><mi>i</mi><mo>,</mo><mtext> </mtext><mi>j</mi></mrow></msub><mo>≤</mo><msubsup><mi>v</mi><mi>j</mi><mrow><mstyle mathsize="normal"><mi>m</mi><mi>a</mi><mi>x</mi></mstyle></mrow></msubsup></mrow></math> (9.5)</span>
<span class="mobi"><img alt="" class="img1" height="50" src="../images/eq9-5.jpg" width="1386"/></span></figure>
<p class="tni">where</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msubsup><mi>v</mi><mi>i</mi><mrow><mstyle mathsize="normal"><mi>m</mi><mi>a</mi><mi>x</mi></mstyle></mrow></msubsup><mo>=</mo><msub><mi>λ</mi><mi>j</mi></msub><mfenced><mrow><msubsup><mi>x</mi><mi>j</mi><mrow><mstyle mathsize="normal"><mi>m</mi><mi>a</mi><mi>x</mi></mstyle></mrow></msubsup><mo>−</mo><msubsup><mi>x</mi><mi>j</mi><mrow><mstyle mathsize="normal"><mi>m</mi><mi>i</mi><mi>n</mi></mstyle></mrow></msubsup></mrow></mfenced><mo>,</mo><mtext> </mtext><mtext> </mtext><msub><mi>λ</mi><mi>i</mi></msub><mo>∈</mo><mo stretchy="false">(</mo><mn>0</mn><mo>,</mo><mtext> </mtext><mn>1</mn><mo stretchy="false">)</mo></mrow></math> (9.6)</span>
<span class="mobi"><img alt="" class="img1" height="51" src="../images/eq9-6.jpg" width="1386"/></span></figure>
<p class="tx">The final step for PSO is to update the position vector of particle <i class="calibre9">i</i> for the next time step <i class="calibre9">t</i> + 1 as follows:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msubsup><mtext class="BI">x</mtext><mi>i</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup><mo>=</mo><msubsup><mtext class="BI">x</mtext><mi>i</mi><mi>t</mi></msubsup><mo>+</mo><msubsup><mtext class="BI">v</mtext><mi>i</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow></math> (9.7)</span>
<span class="mobi"><img alt="" class="img1" height="41" src="../images/eq9-7.jpg" width="1386"/></span></figure>
<p class="tx">As with velocities, the updated position vectors will also have to be checked against the specified bounds for the decision variables.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="h"><span id="sec2"/><span id="h1-56"/><span class="sans_futura_std_bold_b_">Implementing PSO for Function Minimization</span></h3>
<p class="tni">We can use the PSO algorithm to either maximize or minimize a function. In this chapter, we’ll apply PSO to function minimization. Consequently, when aiming to minimize a multivariate function by using this implementation, we don’t need to multiply the objective function value by –1, as we did for function minimization in <span><a href="chapter8.xhtml" class="calibre2">Chapter 8</a></span>.</p>
<p class="tx">In contrast to the other algorithms covered in this book, the PSO algorithm involves more interlinked steps, which makes it difficult to <span aria-label="349" epub:type="pagebreak" id="pg_349" role="doc-pagebreak"/>understand and code the algorithm without a thorough overview of the entire process. To address this, I’ll provide pseudocode outlining the entire process to guide us through actual code development. <i class="calibre9">Pseudocode</i> is a high-level description of an algorithm or a computer program. It’s written in plain language that closely resembles the structure of a programming language, but it is not meant to be executed on a computer. It allows programmers to plan out and communicate the logic of a program without getting bogged down in the details of a specific programming language.</p>
<p class="tx">Here’s the pseudocode for the PSO algorithm. Notice that we’ve used boldface to mark where loops and conditional blocks begin and end, as well as to emphasize specific tasks carried out by code segments.</p>
<pre class="calibre10"><code class="calibre11">Initialize swarm:
<b class="calibre6">for i</b> = 0 .. &lt; swarm size
        <b class="calibre6">for j</b> = 0 .. &lt; number of dimensions
                <b class="calibre6">initialize</b> position to random values per Equation 9.1
                <b class="calibre6">initialize</b> velocity to 0 per Equation 9.2
        <b class="calibre6">end for</b>
        <b class="calibre6">create</b> pBest[i] (with same position and fitness)
        <b class="calibre6">create</b> swarm[i]
        <b class="calibre6">if</b> fitness(swarm[i]) &lt; fitness(gBest)
                update gBest
        <b class="calibre6">end if</b>
<b class="calibre6">end for</b>

Iterate over a preset number of time steps:
<b class="calibre6">for time step</b> = 0 .. &lt; tmax
        <b class="calibre6">update</b> w per Equation 9.4
        <b class="calibre6">for i</b> = 0 .. &lt; swarm size
                <b class="calibre6">for j</b> = 0 .. &lt; number of dimensions
                        <b class="calibre6">update</b> velocity per Equation 9.3
                        <b class="calibre6">check</b> velocity within bounds per Equation 9.5
                        <b class="calibre6">update</b> position per Equation 9.7
                        <b class="calibre6">check</b> position within bounds
                <b class="calibre6">end for</b>
                <b class="calibre6">update</b> fitness of swarm[i]
                <b class="calibre6">if</b> fitness(swarm[i]) &lt; fitness(pBest[i])
                        <b class="calibre6">update</b> pBest[i]
                <b class="calibre6">end if</b>
                <b class="calibre6">if</b> fitness(swarm[i]) &lt; fitness(gBest)
                        <b class="calibre6">update</b> gBest
                <b class="calibre6">end if</b>
        <b class="calibre6">end for</b>
<b class="calibre6">end for</b></code></pre>
<p class="tx">We’ll follow this pseudocode closely as we develop the code for implementing the PSO algorithm in the next project.</p>
<p class="headaexercise" id="pre-36"><span aria-label="350" epub:type="pagebreak" id="pg_350" role="doc-pagebreak"/><span class="sans_dogma_ot_bold_b_15-n">Project 36: Optimize a Multivariate Function with a Particle Swarm</span></p>
<p class="tni">For this project, we’ll revisit the Eggholder function optimization problem defined in <span><a href="chapter8.xhtml" class="calibre2">Chapter 8</a></span>, this time solving it with the PSO algorithm rather than with the genetic algorithm.</p>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="h1"><span id="sec3"/><span id="h2-144"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">We’ll develop the code for the PSO algorithm following the pseudocode provided earlier and discuss its implementation in four segments: problem definition and global parameters, initializing the swarm, the <span class="sans_thesansmonocd_w5regular_">runPSO()</span> driver function, and the <span class="sans_thesansmonocd_w5regular_">main()</span> function.</p>
<section aria-labelledby="sec4" epub:type="division">
<h5 class="h2"><span id="sec4"/><span id="h3-74"/><span class="sans_futura_std_bold_b_">Problem Definition and Global Parameters</span></h5>
<p class="tni">This segment is composed of an import block, a collection of classes, global variables and parameters, and lists to save particle states and best solutions.</p>
<pre class="calibre10"><code class="calibre11">import kotlin.math.sin
import kotlin.math.pow
import kotlin.math.abs
import kotlin.math.sqrt
import kotlin.math.min
import kotlin.math.max

<span aria-label="annotation1" class="codeannotated_codeannotation">❶</span> data class Solution(
    var pos: DoubleArray,
    var fitness: Double
)

<span aria-label="annotation2" class="codeannotated_codeannotation">❷</span> data class Particle(
    val id: Int,
    val pos: DoubleArray,
    val vel: DoubleArray,
    var fitness: Double,
    val pBest: Solution
)

// problem definition
<span aria-label="annotation3" class="codeannotated_codeannotation">❸</span> val getFitness = ::eggHolder
val nDim = 2    // number of variables in the cost function
val xBbounds = arrayOf(doubleArrayOf(-512.0, 512.0),
                       doubleArrayOf(-512.0, 512.0))
val xRange = doubleArrayOf(xBbounds[0][1] - xBbounds[0][0],
                           xBbounds[1][1] - xBbounds[1][0])
val lambda = 0.5
val vMax = doubleArrayOf(lambda*xRange[0], lambda*xRange[1])

// global parameters
val TMAX = 50
val SWARMSIZE = 30
val wmax = 1.2
val wmin = 0.5
<span aria-label="351" epub:type="pagebreak" id="pg_351" role="doc-pagebreak"/>val wt = (wmax - wmin)/TMAX
var w = wmax
val c1 = 2.0       // cognitive coefficient
val c2 = 2.0       // social coefficient

// global objects and collections
val swarm = mutableListOf&lt;Particle&gt;()
val BestSolution = Solution(doubleArrayOf(0.0, 0.0), Double.MAX_VALUE)</code></pre>
<p class="tx">The first block in the code snippet imports a number of math functions from the standard Kotlin library. The next two blocks define the data classes used for this project. The <span class="sans_thesansmonocd_w5regular_">Solution()</span> class is used to store particle-best and swarm-best solutions <span aria-label="annotation1" class="codeannotation">❶</span>. The <span class="sans_thesansmonocd_w5regular_">Particle()</span> class is the primary class that is used to create a swarm <span aria-label="annotation2" class="codeannotation">❷</span>. Each particle has an identification number (<span class="sans_thesansmonocd_w5regular_">id</span>), position and velocity vectors (<span class="sans_thesansmonocd_w5regular_">pos</span> and <span class="sans_thesansmonocd_w5regular_">vel</span>), a <span class="sans_thesansmonocd_w5regular_">fitness</span> property, and a <span class="sans_thesansmonocd_w5regular_">Solution</span> property. The latter is used to store information on the best solution identified by the particle up to a certain point in time.</p>
<p class="tx">The next code block defines the <span class="sans_thesansmonocd_w5regular_">eggHolder</span> function <span aria-label="annotation3" class="codeannotation">❸</span> and its dimensions in <span class="sans_thesansmonocd_w5regular_">nDim</span> (equal to 2 for the Eggholder function). It also defines the bounds and ranges for <span class="sans_thesansmonocd_w5regular_">pos</span> and <span class="sans_thesansmonocd_w5regular_">vel</span> and then defines <span class="sans_thesansmonocd_w5regular_">vMax</span> per Equation 9.5 to ensure that updated velocities remain within the set bounds.</p>
<p class="tx">The final code block defines PSO-specific global parameters. Currently, the maximum number of time steps (iterations) is set to 50, and the swarm size is set to 30. We’ll also dynamically adjust the inertia factor <i class="calibre9">w</i> per Equation 9.4 for which <span class="sans_thesansmonocd_w5regular_">wmax</span> and <span class="sans_thesansmonocd_w5regular_">wmin</span> have been set to 1.2 and 0.5, respectively. The cognitive and social factors <span class="sans_thesansmonocd_w5regular_">c1</span> and <span class="sans_thesansmonocd_w5regular_">c2</span> have been set to 2.0. These parameter values were chosen based on the recommendations found in the relevant literature.</p>
<p class="tx">The code block ends by creating a mutable list (<span class="sans_thesansmonocd_w5regular_">swarm</span>) and initializing <span class="sans_thesansmonocd_w5regular_">BestSolution</span>, which we’ll use to store the swarm-best solution. Since we’re framing the problem as a minimization problem, the fitness value of the <span class="sans_thesansmonocd_w5regular_">BestSolution</span> has been set to <span class="sans_thesansmonocd_w5regular_">Double.MAX_VALUE</span>, which is the maximum possible of type <span class="sans_thesansmonocd_w5regular_">Double</span>.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h5 class="h2"><span id="sec5"/><span id="h3-75"/><span class="sans_futura_std_bold_b_">Initializing the Swarm</span></h5>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">initSwarm()</span> function is responsible for initializing the PSO algorithm by creating and initializing individual particles and adding them to the collection of particles (the swarm).</p>
<pre class="calibre10"><code class="calibre11">fun initSwarm() {
    println("\nStarting initialization...")

  <span aria-label="annotation1" class="code_codeannotation">❶</span> for (i in 0 until SWARMSIZE) {
        // Define local objects.
        val pos = DoubleArray(nDim)
        val vel = DoubleArray(nDim)
        val fitness: Double
        val pBest: Solution

<span aria-label="352" epub:type="pagebreak" id="pg_352" role="doc-pagebreak"/>        // Set initial positions (random, within bounds).
      <span aria-label="annotation2" class="code_codeannotation">❷</span> for (j in 0 until nDim) {
            pos[j] = xBbounds[j][0] + (xBbounds[j][1] - xBbounds[j][0]) *
                         (0..1000).random() / 1000.0
            vel[j] = 0.0
        }

       // Add new particles to the swarm.
      <span aria-label="annotation3" class="code_codeannotation">❸</span> fitness = getFitness(pos)
        pBest = Solution(pos.copyOf(), fitness)
      <span aria-label="annotation4" class="code_codeannotation">❹</span> swarm += Particle(i, pos, vel, fitness, pBest)

        // Update BestSolution.
      <span aria-label="annotation5" class="code_codeannotation">❺</span> if (fitness &lt; BestSolution.fitness) {
            BestSolution.pos = pos.copyOf()
            BestSolution.fitness = fitness
        }
    }
    println("\nBest solution after initialization:")
    println(BestSolution.toString())
}</code></pre>
<p class="tx">The function begins by printing a message indicating the start of the initialization process. It then iterates using a <span class="sans_thesansmonocd_w5regular_">for</span> loop over a specified swarm size (<span class="sans_thesansmonocd_w5regular_">SWARMSIZE</span>) <span aria-label="annotation1" class="codeannotation">❶</span>, creating individual particles with random initial positions within predefined bounds for each dimension <span aria-label="annotation2" class="codeannotation">❷</span>. The initial velocities for each particle are set to zero, per Equation 9.2.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">getFitness</span> function allows us to calculate the fitness value for each particle <span aria-label="annotation3" class="codeannotation">❸</span>. Notice that during initialization, the personal best fitness is the same as its current fitness, meaning that <span class="sans_thesansmonocd_w5regular_">pBest</span> initially has the same position and fitness as the particle. These particles are characterized by identification number (<span class="sans_thesansmonocd_w5regular_">id</span>), position (<span class="sans_thesansmonocd_w5regular_">pos</span>) and velocity (<span class="sans_thesansmonocd_w5regular_">vel</span>) vectors, a fitness value (<span class="sans_thesansmonocd_w5regular_">fitness</span>), and a personal best solution (<span class="sans_thesansmonocd_w5regular_">pBest</span>). We use these attributes to create the particles and add them to the swarm <span aria-label="annotation4" class="codeannotation">❹</span>.</p>
<p class="tx">The best solution across the entire swarm is updated if a particle’s fitness is better than the current best <span aria-label="annotation5" class="codeannotation">❺</span>. After initialization, the function prints the best solution.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h5 class="h2"><span id="sec6"/><span id="h3-76"/><span class="sans_futura_std_bold_b_">The Driver Function</span></h5>
<p class="tni">The code block for the <span class="sans_thesansmonocd_w5regular_">runPSO()</span> driver function carries out all the core tasks of PSO, including updating the velocity and position vectors and tracking the personal- and swarm-level best solutions.</p>
<pre class="calibre10"><code class="calibre11">fun runPSO() {
  <span aria-label="annotation1" class="code_codeannotation">❶</span> for (timeStep in 0 until TMAX) {
        // Update inertia factor as a function of time.
        val w = wmax - timeStep * wt

        // random coefficients for cognitive and social components
        val r1 = (0..100).random()/100.0
        val r2 = (0..100).random()/100.0

<span aria-label="353" epub:type="pagebreak" id="pg_353" role="doc-pagebreak"/>        // Iterate over each particle of the swarm.
      <span aria-label="annotation2" class="code_codeannotation">❷</span> for (i in swarm.indices) {
            // Update velocity and position vectors.
            for (j in 0 until nDim) {
                // Update velocity vector, and implement bounds.
                val C1 = w * swarm[i].vel[j]
                val C2 = c1 * r1 * (swarm[i].pBest.pos[j]-swarm[i].pos[j])
                val C3 = c2 * r2 * (BestSolution.pos[j] - swarm[i].pos[j])
                val vel = C1 + C2 + C3

                // Implement velocity bounds.
                swarm[i].vel[j] = min(max(vel, -vMax[j]), vMax[j])

                // Update position vector, and implement bounds.
                swarm[i].pos[j] += swarm[i].vel[j]
                swarm[i].pos[j] =
                     min(max(swarm[i].pos[j], xBbounds[j][0]), xBbounds[j][1])
            }

            // Evaluate particle fitness.
          <span aria-label="annotation3" class="code_codeannotation">❸</span> swarm[i].fitness = getFitness(swarm[i].pos)

            // Update the particle's best solution (pBest).
          <span aria-label="annotation4" class="code_codeannotation">❹</span> if (swarm[i].fitness &lt; swarm[i].pBest.fitness) {
                swarm[i].pBest.pos = swarm[i].pos.copyOf()
                swarm[i].pBest.fitness = swarm[i].fitness
            }

            // Update the global best solution.
          <span aria-label="annotation5" class="code_codeannotation">❺</span> if (swarm[i].fitness &lt; BestSolution.fitness) {
                BestSolution.pos = swarm[i].pos.copyOf()
                BestSolution.fitness = swarm[i].fitness
            }
        }
    }
}</code></pre>
<p class="tx">Unlike the <span class="sans_thesansmonocd_w5regular_">runGA()</span> function for implementing the genetic algorithm, the <span class="sans_thesansmonocd_w5regular_">runPSO()</span> function is self-sufficient and doesn’t rely on any helper functions other than <span class="sans_thesansmonocd_w5regular_">getFitness()</span>, which simply calculates the value of the function being minimized. It iterates over a fixed number of time steps (<span class="sans_thesansmonocd_w5regular_">TMAX</span>) <span aria-label="annotation1" class="codeannotation">❶</span>, beginning each iteration by initializing the inertia factor (<span class="sans_thesansmonocd_w5regular_">w</span>) and the random factors <span class="sans_thesansmonocd_w5regular_">r1</span> and <span class="sans_thesansmonocd_w5regular_">r2</span>.</p>
<p class="tx">For each time step, the code loops over each particle in the swarm <span aria-label="annotation2" class="codeannotation">❷</span> and updates its velocity and position vectors according to the PSO formula. The code also implements bounds for the velocity and position values, using the minimum and maximum values defined in the arrays <span class="sans_thesansmonocd_w5regular_">vMax</span> and <span class="sans_thesansmonocd_w5regular_">xBbounds</span>.</p>
<p class="tx">The code evaluates the fitness of each particle by using the <span class="sans_thesansmonocd_w5regular_">getFitness()</span> function <span aria-label="annotation3" class="codeannotation">❸</span>, which takes the position vector as an input and returns the corresponding fitness as a scalar value.</p>
<p class="tx">The code then compares each particle’s current fitness with its personal best fitness (<span class="sans_thesansmonocd_w5regular_">pBest</span>) and updates the latter if the former is lower <span aria-label="annotation4" class="codeannotation">❹</span>. It also compares the current fitness with the global best fitness (<span class="sans_thesansmonocd_w5regular_">BestSolution</span>) and <span aria-label="354" epub:type="pagebreak" id="pg_354" role="doc-pagebreak"/>updates the latter if the former is lower <span aria-label="annotation5" class="codeannotation">❺</span>. The personal and global best solutions store both the position and the fitness values.</p>
<p class="tx">The function terminates when it completes <span class="sans_thesansmonocd_w5regular_">TMAX</span> iterations. It doesn’t return anything, since the best overall solution is saved as the global object <span class="sans_thesansmonocd_w5regular_">BestSolution</span>.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h5 class="h2"><span id="sec7"/><span id="h3-77"/><span class="sans_futura_std_bold_b_">The main() Function</span></h5>
<p class="tni">This function is a short code block that prints values of key global parameters, calls other functions to initialize the swarm and run the PSO driver function, and prints the best solution found.</p>
<pre class="calibre10"><code class="calibre11">fun main() {
    println("\n*** Real-valued function optimization using PSO ***\n")
    println("Function dimensions: $nDim")
    println("Swarm size: $SWARMSIZE, Max time steps: $TMAX")
    println("w_max: $wmax  w_min: $wmin")
    println("Cognitive factor (c1): $c1")
    println("Social factor (c2): $c2")

    // Initialize the swarm.
    initSwarm()
    // Run PSO algorithm.
    runPSO()

    // Print final results.
    println("\nBest solution after $TMAX iterations:")
    println(BestSolution.toString())
}</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">main()</span> function is the entry point of the program that uses PSO to perform real-valued function optimization. It prints some information about the problem parameters, such as the function dimensions, the swarm size, the maximum time steps, and the PSO coefficients.</p>
<p class="tx">The function then calls two other functions, <span class="sans_thesansmonocd_w5regular_">initSwarm()</span> and <span class="sans_thesansmonocd_w5regular_">runPSO()</span>. The first function initializes the swarm of particles with random positions and velocities and evaluates their initial fitness values. The second function runs the PSO algorithm for a fixed number of iterations, updating the particles’ velocities, positions, and fitness values, as well as the personal and global best solutions.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">main()</span> function finally prints the best solution found by the PSO algorithm after the specified number of iterations, showing both the position vector and the fitness value of the global best solution.</p>
</section>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="h1"><span id="sec8"/><span id="h2-145"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">I’ve deliberately kept the output of the PSO program brief and to the point. By now, you should be comfortable with writing your own additional lines of code to print or save other intermediate results for further analysis or visualization. If you run the code with the same parameters used in this example, the output might look like this:</p>
<pre class="calibre10"><code class="calibre11"><span aria-label="355" epub:type="pagebreak" id="pg_355" role="doc-pagebreak"/>*** Real-valued function optimization using PSO ***

Function dimensions: 2
Swarm size: 30, Max time steps: 50
w_max: 1.2  w_min: 0.5
Cognitive factor (c1): 2.0
Social factor (c2): 2.0

Starting initialization...

BestSolution after initialization:
Solution(pos=[-429.056, 374.784], fitness=-742.3993203916232)

BestSolution after 50 iterations:
Solution(pos=[512.0, 404.2263191597745], fitness=-959.640628508424)</code></pre>
<p class="tx">The first segment of the output shows the values of key global parameters. Next, it shows the best solutions at the start and the end of the iterations. The PSO algorithm achieved a near-optimal solution for the Eggholder function within the given decision space, matching the result obtained by the genetic algorithm in <span><a href="chapter8.xhtml" class="calibre2">Chapter 8</a></span>.</p>
<p class="tx"><a href="chapter9.xhtml#fig9-2" class="calibre2">Figure 9-2</a> shows the convergence behavior of the PSO algorithm over time when applied to the Eggholder function. Unlike the genetic algorithm discussed in <span><a href="chapter8.xhtml" class="calibre2">Chapter 8</a></span>, PSO achieves optimal solutions more rapidly, requiring fewer iterations.</p>
<figure class="img"><img alt="" class="img1" height="893" id="fig9-2" src="../images/Figure9-2.jpg" width="1311"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 9-2: The convergence pattern for the Eggholder function, using the particle swarm algorithm</span></p></figcaption>
</figure>
<p class="tx"><span aria-label="356" epub:type="pagebreak" id="pg_356" role="doc-pagebreak"/>PSO seems to have an advantage over the genetic algorithm for this problem. Though the PSO algorithm had a worse initial global best fitness value of around –742, compared to –810 for the genetic algorithm, it reached the global optimum in about 40 iterations, while the genetic algorithm took 117 iterations. This suggests that the PSO algorithm can explore and exploit the search space more efficiently than the genetic algorithm for the Eggholder function. This efficiency likely stems from PSO’s unique approach to exploring the solution space through collaborative particle interactions.</p>
<p class="tx">I encourage you to use this code to solve other known test problems and further investigate how the PSO algorithm performs vis-<span class="copyright_accent">à</span>-vis the genetic algorithm.</p>
<aside aria-label="box-44" class="box2">
<p class="boxtitle" id="box-44"><span class="sans_futura_std_bold_b_">EXERCISE</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">The Mishra Bird function is given by the following equation:</span></p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>f</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>sin</mi><msub><mi>x</mi><mn>1</mn></msub><msup><mrow/><mrow><msup><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>cos</mi><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><mn>2</mn></msup></mrow></msup><mo>+</mo><mi>cos</mi><msub><mi>x</mi><mn>2</mn></msub><msup><mi>e</mi><mrow><msup><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>sin</mi><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><mn>2</mn></msup></mrow></msup><mo>+</mo><msup><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>−</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><mn>2</mn></msup></mrow></math></span>
<span class="mobi"><img alt="" class="img1" height="48" src="../images/pg356.jpg" width="1235"/></span></figure>
<p class="box1"><span class="sans_futura_std_book_">You’ll find the global minima for this function as well as the optimal solution (</span><span class="sans_futura_std_book_oblique_">x</span><span class="sans_futura_std_book_sub_">1</span><span class="sans_futura_std_book_">*,</span> <span class="sans_futura_std_book_oblique_">x</span><span class="sans_futura_std_book_sub_">2</span><span class="sans_futura_std_book_">*) within a decision space bounded by [–2<span lang="el" xml:lang="el">π</span>, 2<span lang="el" xml:lang="el">π</span>] in both</span> <span class="sans_futura_std_book_oblique_">x</span><span class="sans_futura_std_book_sub_">1</span> <span class="sans_futura_std_book_">and</span> <span class="sans_futura_std_book_oblique_">x</span><span class="sans_futura_std_book_sub_">2</span> <span class="sans_futura_std_book_">dimensions. The function’s global minimum value within the decision space is approximately −106.7645.</span></p>
<p class="box1"><span class="sans_futura_std_book_">Hint: Define a new function</span> <span class="sans_thesansmonocd_w5regular_">mishraBird()</span> <span class="sans_futura_std_book_">and assign that to</span> <span class="sans_thesansmonocd_w5regular_">getFitness</span><span class="sans_futura_std_book_">. Change the</span> <span class="sans_thesansmonocd_w5regular_">xBounds</span> <span class="sans_futura_std_book_">accordingly. You can increase</span> <span class="sans_thesansmonocd_w5regular_">TMAX</span> <span class="sans_futura_std_book_">to 100 for a quicker convergence without changing any other parameter values.</span></p>
<p class="boxlast"><span class="sans_futura_std_book_">Notice that within this decision space are two global optimal solutions for this function: (4.701056, 3.152946) and (−1.582142, −3.130247). The global minimum fitness value is −106.764537 (all values rounded to six decimal places). If you run the revised code multiple times, the algorithm will likely identify both global optimal solutions at random.</span></p>
</aside>
</section>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="h"><span id="sec9"/><span id="h1-57"/><span class="sans_futura_std_bold_b_">Ant Colony Optimization</span></h3>
<p class="tni">Ant colony optimization (ACO) refers to a family of algorithms that are based on lessons learned from real-world ants, especially from their foraging behavior. The original algorithm, known as the ant system (AS), was proposed by Marco Dorigo in 1992. Since then, the algorithm has been modified several times to help it more effectively solve a class of problems that requires finding the least-cost tour through all nodes of a weighted graph. In discrete mathematics, a graph is a set of nodes or vertices that are related, and the imaginary or real line connecting a pair of nodes is called <span aria-label="357" epub:type="pagebreak" id="pg_357" role="doc-pagebreak"/>an <i class="calibre9">edge</i>. (You can revisit <span><a href="chapter7.xhtml" class="calibre2">Chapter 7</a></span> for a review of graphs and conventional graph-search algorithms.)</p>
<p class="tx">To demonstrate the basic concept of ACO, let’s review the simple illustration in <a href="chapter9.xhtml#fig9-3" class="calibre2">Figure 9-3</a> of ants exploring the best paths to a source of food.</p>
<figure class="img"><img alt="" class="img1" height="633" id="fig9-3" src="../images/Figure9-3.jpg" width="1672"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 9-3: Ants exploring different trails leading to the food source</span></p></figcaption>
</figure>
<p class="tx">When ants start looking for a food source, they initially disperse randomly in all directions, as shown in <a href="chapter9.xhtml#fig9-3" class="calibre2">Figure 9-3(a)</a>. As they move, they lay down a scent (pheromone) to mark their trails. Once an ant finds a food source, it picks up a piece of food and brings that back to the nest by following its scent mark. It also lays down more pheromones as it returns to the nest.</p>
<p class="tx">In the meantime, other ants notice the trail. Given more than one source, each trail will develop a scent mark of greater or lesser intensity, depending on how many ants are traveling back and forth along that trail and how far the source is from the nest. In general, the stronger the scent mark of a trail, the greater the number of ants following that trail will be. Once a food source is found, ants will therefore follow the most well-defined trails, as shown in <a href="chapter9.xhtml#fig9-3" class="calibre2">Figure 9-3(b)</a>.</p>
<p class="tx">Crucially, pheromones are not permanent—they tend to decay or evaporate over time. If a trail is not frequently visited, it gradually becomes less traceable and eventually is forgotten. Additionally, the closest food source will take the least amount of time to visit, which means the corresponding trail will be traveled more frequently, which will result in a stronger concentration of pheromone—which will create a positive feedback loop and attract even more ants to choose the shortest route. Over time, most of the ants will start to use this shortest route (the optimal path), as shown in <a href="chapter9.xhtml#fig9-3" class="calibre2">Figure 9-3(c)</a>. The ant colony will have used a very simple rule to solve a very difficult combinatorial optimization problem!</p>
<p class="tx">In this ingenious natural scheme, individual agents (ants) do not have any idea about the impact of their actions on the entire colony. And yet by repeating their simple routine, they enable the colony to find its food sources as efficiently as if the whole search process were centrally coordinated.</p>
<section aria-labelledby="sec10" epub:type="division">
<span aria-label="358" epub:type="pagebreak" id="pg_358" role="doc-pagebreak"/>
<h4 class="h1"><span id="sec10"/><span id="h2-146"/><span class="sans_futura_std_bold_condensed_oblique_">The ACS Algorithm</span></h4>
<p class="tni">Based on the conceptual model presented in the previous section, we can envision the key components of ACO as creating a colony of artificial ants, moving ants from one node to the next based on pheromone intensity and the distance between the nodes, and updating the pheromone trails until the shortest route is found.</p>
<p class="tx">In this chapter, we’ll explore an enhanced version of ACO called the ant colony system (ACS). The ACS algorithm is implemented in three key steps: constructing a tour, updating a local pheromone trail, and updating a global pheromone trail. We’ll discuss each of these steps in detail shortly.</p>
<p class="tx">We’ll use the ACS algorithm to solve a particular case of the traveling salesman problem (TSP), which belongs to a class of hard-to-solve problems called the NP-hard problems. Mathematically speaking, a problem is <i class="calibre9">NP-hard</i> if it is at least as hard as the hardest problem in NP, a class of problems for which a solution can be verified in polynomial time. It is beyond the scope of this book to discuss the NP-hard problems further; instead, we will focus on how to use ACS to solve TSPs.</p>
<p class="tx">Solving a TSP entails answering the following question:</p>
<blockquote class="calibre17">
<p class="extractpara">Given a list of nodes and the distances between every pair of those nodes, what is the shortest possible route a traveler can take that passes through each node exactly once and brings the traveler back to the start node?</p>
</blockquote>
<p class="tx">In other words, we’re looking for a closed-loop solution that goes through each node and has the shortest possible length. Notice that it is theoretically possible for multiple routes to have the same shortest length of travel.</p>
<p class="tx">We’ll make two additional assumptions regarding the form of TSP we’ll try to solve:</p>
<ul class="ul1">
<li class="listbullet1">The network of nodes (graph) is fully connected, meaning a traveler can visit from any particular node to all other remaining nodes (during implementation, we’ll exclude the nodes that have already been visited).</li>
<li class="listbullet1">The distance between any pair of nodes is symmetric, meaning the distance does not change with the direction of travel (a pair of nodes are connected by a single, unique path—an edge).</li>
</ul>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="h1"><span id="sec11"/><span id="h2-147"/><span class="sans_futura_std_bold_condensed_oblique_">Symbols and Their Meanings</span></h4>
<p class="tni">ACS is a fairly complex algorithm with many parameters and variables, listed in <a href="chapter9.xhtml#tab9-1" class="calibre2">Table 9-1</a> along with the symbols used to represent them.</p>
<p class="tt" id="tab9-1"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 9-1:</span></span> <span class="sans_futura_std_book_">Symbols Used in the ACS Algorithm</span></p>
<p class="anchor"><span aria-label="359" epub:type="pagebreak" id="pg_359" role="doc-pagebreak"/></p>
<table class="basic-table">
<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Symbol</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Interpretation</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_"><span class="mobi"><img alt="" class="inline6" src="../images/pg358-in-1.jpg"/></span></span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">The neighborhood of ant</span> <span class="sans_futura_std_book_oblique_">k</span> <span class="sans_futura_std_book_">when it is at node</span> <span class="sans_futura_std_book_oblique_">i</span><span class="sans_futura_std_book_">; it is a set of nodes that an ant is allowed to visit given its current location.</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_oblique_"><span lang="el" xml:lang="el">τ</span></span><span class="sans_futura_std_book_oblique_sub_">ij</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">The pheromone intensity of edge [</span><span class="sans_futura_std_book_oblique_">i</span><span class="sans_futura_std_book_">,</span> <span class="sans_futura_std_book_oblique_">j</span><span class="sans_futura_std_book_">] connecting node</span> <span class="sans_futura_std_book_oblique_">i</span> <span class="sans_futura_std_book_">to node</span> <span class="sans_futura_std_book_oblique_">j</span><span class="sans_futura_std_book_">.</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_oblique_"><span lang="el" xml:lang="el">τ</span></span><span class="sans_futura_std_book_sub_">0</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Initial pheromone level for all edges, set to 1/(</span><span class="sans_futura_std_book_oblique_">nC</span><span class="sans_futura_std_book_sup_">nn</span><span class="sans_futura_std_book_">);</span> <span class="sans_futura_std_book_oblique_">n</span> <span class="sans_futura_std_book_">is the total number of nodes in the nearest-neighbor tour and</span> <span class="sans_futura_std_book_oblique_">C</span><span class="sans_futura_std_book_sup_">nn</span> <span class="sans_futura_std_book_">is the tour length.</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_oblique_">d</span><span class="sans_futura_std_book_oblique_sub_">ij</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">The length of the edge from node</span> <span class="sans_futura_std_book_oblique_">i</span> <span class="sans_futura_std_book_">to node</span> <span class="sans_futura_std_book_oblique_">j</span> <span class="sans_futura_std_book_">(distance between these nodes). Also,</span> <span class="sans_futura_std_book_oblique_">d</span><span class="sans_futura_std_book_oblique_sub_">ij</span> <span class="sans_futura_std_book_">=</span> <span class="sans_futura_std_book_oblique_">d</span><span class="sans_futura_std_book_oblique_sub_">ji</span><span class="sans_futura_std_book_">.</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_oblique_"><span lang="el" xml:lang="el">η</span></span><span class="sans_futura_std_book_oblique_sub_">ij</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Heuristic information defined as 1/</span><span class="sans_futura_std_book_oblique_">d</span><span class="sans_futura_std_book_oblique_sub_">ij</span><span class="sans_futura_std_book_">.</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_oblique_"><span lang="el" xml:lang="el">α</span></span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Parameter, set to 1 for ACS.</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_oblique_">ß</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Parameter [2.0–5.0], used as the exponent of</span> <span class="sans_futura_std_book_oblique_"><span lang="el" xml:lang="el">η</span></span><span class="sans_futura_std_book_">.</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_oblique_">q</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">A uniformly distributed random variable in [0, 1].</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_oblique_">q</span><span class="sans_futura_std_book_sub_">0</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">A parameter in (0, 1); an ant explores the learned knowledge based on the intensity of pheromone trails and heuristics when</span> <span class="sans_futura_std_book_oblique_">q</span> <span class="sans_futura_std_book_">≤</span> <span class="sans_futura_std_book_oblique_">q</span><span class="sans_futura_std_book_sub_">0</span><span class="sans_futura_std_book_">.</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_oblique_">p</span><span class="sans_futura_std_book_oblique_sub_">ij</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">The normalized probability for choosing edge [</span><span class="sans_futura_std_book_oblique_">i</span><span class="sans_futura_std_book_">,</span> <span class="sans_futura_std_book_oblique_">j</span><span class="sans_futura_std_book_">] during roulette wheel selection if</span> <span class="sans_futura_std_book_oblique_">q</span> <span class="sans_futura_std_book_">&gt;</span> <span class="sans_futura_std_book_oblique_">q</span><span class="sans_futura_std_book_sub_">0</span><span class="sans_futura_std_book_">.</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_oblique_"><span lang="el" xml:lang="el">ζ</span></span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Parameter, set to a small value such as 0.005; used as the weighting factor for updating the local pheromone trail.</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_oblique_"><span lang="el" xml:lang="el">ρ</span></span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Parameter, set to the recommended value of 0.1 for ACS; used as the weighting factor for updating the best-so-far global pheromone trail.</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_oblique_">C</span><span class="sans_futura_std_book_sup_">nn</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Tour length for the nearest-neighbor tour used for estimating initial pheromone concentration.</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_oblique_">C</span><span class="sans_futura_std_book_sup_">bs</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Tour length for the best-so-far solution or tour.</span></p></td>
</tr>
<tr class="calibre16">
<td class="tbl"><p class="tableheader"><span class="sans_futura_std_book_oblique_">T</span> <span class="sans_futura_std_book_sup_">bs</span></p></td>
<td class="tbl"><p class="tableheader"><span class="sans_futura_std_book_">The best-so-far tour (collection of edges that constitute the tour).</span></p></td>
</tr>
</tbody>
</table>
<p class="tx">In addition to listing the parameters and variables, <a href="chapter9.xhtml#tab9-1" class="calibre2">Table 9-1</a> also provides short descriptions of those elements. (You may need to revisit these descriptions as you read the rest of this section.)</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h4 class="h1"><span id="sec12"/><span id="h2-148"/><span class="sans_futura_std_bold_condensed_oblique_">The Steps of ACS</span></h4>
<p class="tni">In this section, we’ll explore the key steps of the ACS algorithm, expressed mathematically. This will include three steps: tour construction, updating the local pheromone trail, and updating the global pheromone trail.</p>
<section aria-labelledby="sec13" epub:type="division">
<h5 class="h2"><span id="sec13"/><span id="h3-78"/><span class="sans_futura_std_bold_b_">Step 1: Tour Construction</span></h5>
<p class="tni">The first step of ACS entails applying a pseudorandom proportional rule used by an ant to choose its next location <i class="calibre9">j</i> given its current location <i class="calibre9">i</i>, defined in Equation 9.8.</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>j</mi><mo>=</mo><mfenced close="" open="{"><mtable columnalign="left"><mtr><mtd><mtext class="I">arg</mtext><msub><mtext class="I">max</mtext><mrow><mi>l</mi><mo>∈</mo><msubsup><mi>N</mi><mi>i</mi><mi>k</mi></msubsup></mrow></msub><mfenced close="}" open="{"><mrow><msub><mi>τ</mi><mrow><mi>i</mi><mi>l</mi></mrow></msub><msubsup><mi>η</mi><mrow><mi>i</mi><mi>l</mi></mrow><mi>β</mi></msubsup></mrow></mfenced><mo>,</mo><mtext> </mtext><mtext>if</mtext><mtext> </mtext><mi>q</mi><mo>≤</mo><msub><mi>q</mi><mn>0</mn></msub></mtd></mtr><mtr><mtd><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi>J</mi><mo>,</mo><mtext> </mtext><mtext> </mtext><mtext>otherwise</mtext></mtd></mtr></mtable></mfenced></mrow></math> (9.8)</span>
<span class="mobi"><img alt="" class="img1" height="115" src="../images/eq9-8.jpg" width="1388"/></span></figure>
<p class="tx">The <i class="calibre9">argmax</i> function in Equation 9.8 chooses an argument <i class="calibre9">l</i> from the feasible set of nodes that can be visited from node <i class="calibre9">i</i>, for which the expression inside the curly brackets is maximized. This value of <i class="calibre9">l</i> is set to <i class="calibre9">j</i> as the next destination for the ant provided <i class="calibre9">q</i> ≤ <i class="calibre9">q</i><sub class="calibre19">0</sub>. The parameter <i class="calibre9">q</i><sub class="calibre19">0</sub> allows us to <span aria-label="360" epub:type="pagebreak" id="pg_360" role="doc-pagebreak"/>control the degree to which learned knowledge (pheromone trails and heuristics) is prioritized over random exploration of new routes.</p>
<p class="tx">When <i class="calibre9">q</i> &gt; <i class="calibre9">q</i><sub class="calibre19">0</sub>, the next node <i class="calibre9">j</i> is set to <i class="calibre9">J</i>, which is a random variable selected using a roulette wheel scheme. Equation 9.9 estimates the normalized probabilities for the feasible paths from node <i class="calibre9">i</i> to node <i class="calibre9">j</i> for ant <i class="calibre9">k</i>:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msubsup><mi>p</mi><mrow><mi>i</mi><mi>j</mi></mrow><mi>k</mi></msubsup><mo>=</mo><mfrac><mrow><msub><mi>τ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msubsup><mi>η</mi><mrow><mi>i</mi><mi>j</mi></mrow><mi>β</mi></msubsup></mrow><mrow><msub><mo>∑</mo><mrow><mi>l</mi><mo>∈</mo><msubsup><mi>N</mi><mi>i</mi><mi>k</mi></msubsup></mrow></msub><msub><mi>τ</mi><mrow><mi>i</mi><mi>l</mi></mrow></msub><msubsup><mi>η</mi><mrow><mi>i</mi><mi>l</mi></mrow><mi>β</mi></msubsup></mrow></mfrac><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext> </mtext><mi>j</mi><mo>∈</mo><msubsup><mtext class="B">N</mtext><mi>i</mi><mi>k</mi></msubsup></mrow></math> (9.9)</span>
<span class="mobi"><img alt="" class="img1" height="118" src="../images/eq9-9.jpg" width="1386"/></span></figure>
<p class="tx">For a refresher on the roulette wheel scheme, please review “<span>Selection</span>” on <span><a href="chapter8.xhtml#pg_312" class="calibre2">page 312</a></span> in <span><a href="chapter8.xhtml" class="calibre2">Chapter 8</a></span>. This time, we’ll implement the scheme in our final coding project.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h5 class="h2"><span id="sec14"/><span id="h3-79"/><span class="sans_futura_std_bold_b_">Step 2: Updating the Local Pheromone Trail</span></h5>
<p class="tni">As soon as an ant moves from node <i class="calibre9">i</i> to node <i class="calibre9">j</i>, the weighted average scheme in Equation 9.10 is applied to update the local pheromone trail.</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msub><mi>τ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>ζ</mi><mo stretchy="false">)</mo><mtext> </mtext><msub><mi>τ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>+</mo><mi>ζ</mi><mtext> </mtext><msub><mi>τ</mi><mn>0</mn></msub></mrow></math> (9.10)</span>
<span class="mobi"><img alt="" class="img1" height="52" src="../images/eq9-10.jpg" width="1386"/></span></figure>
<p class="tx">In the original ACO, no local updates occur, which allows one to implement the tour construction either sequentially or concurrently. When tours are built concurrently (in parallel), they can result in significant computational time savings for large real-world problems. Due to the local updating rule of ACS, it is implied that the process will be implemented sequentially. This is because the tour created by a specific ant is influenced by the preceding ants’ local updates to the pheromone trails.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h5 class="h2"><span id="sec15"/><span id="h3-80"/><span class="sans_futura_std_bold_b_">Step 3: Updating the Global Pheromone Trail</span></h5>
<p class="tni">Once all ants are done building their tours, the global pheromone update rule is applied once per iteration and only along the edges of the best-so-far tour, <i class="calibre9">T</i><sup class="calibre8">bs</sup><span>,</span> as shown in Equation 9.11.</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msub><mi>τ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>ρ</mi><mo stretchy="false">)</mo><msub><mi>τ</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>+</mo><mi>ρ</mi><mfenced><mrow><mfrac><mn>1</mn><mrow><msup><mi>C</mi><mrow><mtext>bs</mtext></mrow></msup></mrow></mfrac></mrow></mfenced><mo>,</mo><mtext> </mtext><mtext> </mtext><mtext> </mtext><mtext>for all </mtext><mo stretchy="false">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>∈</mo><msup><mi>T</mi><mrow><mtext>bs</mtext></mrow></msup></mrow></math> (9.11)</span>
<span class="mobi"><img alt="" class="img1" height="93" src="../images/eq9-11.jpg" width="1386"/></span></figure>
<p class="tx">Equation 9.11 implies that <i class="calibre9">T</i><sup class="calibre8">bs</sup> will need to be compared with the best solution identified by the colony at the end of each iteration and then be updated as needed.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h5 class="h2"><span id="sec16"/><span id="h3-81"/><span class="sans_futura_std_bold_b_">The Pseudocode</span></h5>
<p class="tni">The following pseudocode shows how the components of the ACS algorithm come together to form a sophisticated heuristic algorithm:</p>
<pre class="calibre10"><code class="calibre11"><span aria-label="361" epub:type="pagebreak" id="pg_361" role="doc-pagebreak"/>// preprocessing - read and initialize
<b class="calibre6">read</b> nodes from file (name, number, coordinates)
<b class="calibre6">calculate</b> edge lengths (Euclidian distance)
<b class="calibre6">calculate</b> nearest-neighbor tour length (C<span class="sans_thesansmonocd_w5regular_sup_">nn</span>)
<b class="calibre6">initialize</b> pheromone levels to <span class="sans_futura_std_book_"><span lang="el" xml:lang="el">τ</span></span>0 = 1/(nC<span class="sans_thesansmonocd_w5regular_sup_">nn</span>)

// Iteratively apply ACS steps.
<b class="calibre6">while</b> stopping condition not met:
        <b class="calibre6">initialize</b> ants (assign id numbers and initial positions)
        <b class="calibre6">for ant</b> = 0 .. &lt; number of ants
                <b class="calibre6">set</b> cities to visit for each ant
                <b class="calibre6">while number</b> of cities to visit &gt; 0:
                        <b class="calibre6">construct tour</b> per Equation 9.8 &amp; Equation 9.9
                        <b class="calibre6">perform</b> local pheromone update per Equation 9.10
                <b class="calibre6">end while</b>
                // Complete the loop.
                <b class="calibre6">return</b> to the start node
                <b class="calibre6">update</b> ant properties
                <b class="calibre6">perform</b> local pheromone update per Equation 9.10
        <b class="calibre6">end for</b>
        <b class="calibre6">update</b> best-so-far solution
        <b class="calibre6">perform</b> global pheromone update per Equation 9.11
<b class="calibre6">end while</b>

// postprocessing
<b class="calibre6">print</b> results</code></pre>
<p class="tx">We’ll follow this pseudocode to develop a complete ACS application in Kotlin in the next project.</p>
<p class="headaexercise" id="pre-37"><span class="sans_dogma_ot_bold_b_15-n">Project 37: Solve the Traveling Salesman Problem with an Ant Colony System</span></p>
<p class="tni">In this project, we’ll solve the well-known test problem Berlin52. This is a combinatorial optimization problem that involves finding the shortest route through 52 destinations in Berlin, Germany. The dataset for this problem was retrieved from TSPLIB, which is a collection of traveling salesman problems with known global optimal solutions. See “<span>Resources</span>” on <span><a href="#pg_377" class="calibre2">page 377</a></span> for the download link for these problems, which you can try solving by using the ACS algorithm and other NIAs discussed in this book.</p>
</section>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h4 class="h1"><span id="sec17"/><span id="h2-149"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">The Berlin52 TSP requires datasets for 52 different locations. It’s more convenient to create a separate datafile for this project (for example, a file in CSV format) and read the location data from the file at runtime. So we’ll adopt that approach for this project.</p>
<p class="tx">We’ll discuss the code segments in four primary blocks: problem definition and global parameters, the <span class="sans_thesansmonocd_w5regular_">main()</span> block, the <span class="sans_thesansmonocd_w5regular_">runACS()</span> driver function and its helper functions, and additional intermediate and postprocessing of results.</p>
<section aria-labelledby="sec18" epub:type="division">
<span aria-label="362" epub:type="pagebreak" id="pg_362" role="doc-pagebreak"/>
<h5 class="h2"><span id="sec18"/><span id="h3-82"/><span class="sans_futura_std_bold_b_">Problem Definition and Global Declarations</span></h5>
<p class="tni">This segment specifies the import block and defines the input file location, global variables and parameters, and a collection of classes, lists, and arrays required to implement the ASC algorithm.</p>
<pre class="calibre10"><code class="calibre11">// import block
import java.io.File
import kotlin.math.pow
import kotlin.math.sqrt

// Input file location: change the datafile location as needed.
<span aria-label="annotation1" class="code_codeannotation">❶</span> const val datafile = "<var class="calibre18">berlin52.csv</var>"

<span aria-label="annotation2" class="codeannotated_codeannotation">❷</span> // global parameters

val numCities = 52     // Set the number of cities.
val numAnts = 30       // Typically set to 10-30.
val rho = 0.1          // rho = 0.1 is recommended for ACS.
var pheromone0 = 0.0   // 1/(n*Cnn) for ACS
val q0 = 0.8           // argmax parameter (0.5-0.9)
val zeta = 0.005       // Set to a small value.
val alpha = 1.0        // alpha = 1 for ACS.
val beta = 2.0         // Set to 2-5.
val iterMax = 300      // maximum number of iterations
val maxRounds = 50     // number of times the entire process is repeated

<span aria-label="annotation3" class="codeannotated_codeannotation">❸</span> // classes and collections

data class City(
    val name: String,
    val node: Int,
    val x: Double,
    val y:Double
)

class Ant(val id: Int, val start: Int) {

    var currentNode = start

    val citiesToVisit = mutableListOf&lt;Int&gt;()
    val pathNodes = ArrayList&lt;Pair&lt;Int, Int&gt;&gt;()
    val pathSegments = mutableListOf&lt;Double&gt;()

    // Set fitness to a very high value for function minimization.
    var fitness = Double.POSITIVE_INFINITY

    fun setCitiesToVisit() {
        for (i in 0 until numCities) {
            if (i != this.start)
                this.citiesToVisit += i
        }
    }
}

<span aria-label="363" epub:type="pagebreak" id="pg_363" role="doc-pagebreak"/>data class ArgMax(
    val index: Int,
    val value: Double
)

data class Solution(
    val iteration: Int,
    val antID: Int,
    val pathNodes: ArrayList&lt;Pair&lt;Int, Int&gt;&gt;,
    val segments: List&lt;Double&gt;,
    val fitness: Double
)

val cities = mutableListOf&lt;City&gt;()
val ants = mutableListOf&lt;Ant&gt;()
val antSolutions  = mutableListOf&lt;Solution&gt;()
val bestSolutions = mutableListOf&lt;Solution&gt;()

val edges = Array(numCities) {DoubleArray(numCities)}
val pheromone = Array(numCities) {DoubleArray(numCities)}
val prob = Array(numCities) {DoubleArray(numCities)}
var bestOverallTour = ArrayList&lt;Pair&lt;Int, Int&gt;&gt;()

var bestOverallFitness = Double.POSITIVE_INFINITY
var optimaCount = 0</code></pre>
<p class="tx">The code segment begins by importing the required methods from the standard Kotlin and Java libraries. We’ll use <span class="sans_thesansmonocd_w5regular_">java.io.File</span> to read data from an input file from a specified location (in this case, from <i class="calibre9">berlin52.csv</i>) <span aria-label="annotation1" class="codeannotation">❶</span>. (The input file you’ll use will likely have a different location, so you must change the input file location as needed.)</p>
<p class="tx">The input file for the Berlin52 TSP follows a set format. The first value in the initial line contains a brief title describing the problem, while subsequent values serve as column headers for the data points. From the second line to the last, city-specific information is presented in groups of four comma-separated values (hence the file extension <i class="calibre9">.csv</i>): city name, city identification, x-coordinate, and y-coordinate, respectively. Each row contains data for a particular city or location.</p>
<p class="tx">In this case, the datafile consists of 53 lines, including the introductory line that provides descriptive information. <a href="chapter9.xhtml#tab9-2" class="calibre2">Table 9-2</a> shows how the file will look when you open it with Microsoft Excel or another spreadsheet program.</p>
<p class="tt" id="tab9-2"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 9-2:</span></span> <span class="sans_futura_std_book_">Input File Format for the Berlin52 TSP</span></p>
<p class="anchor"><span aria-label="364" epub:type="pagebreak" id="pg_364" role="doc-pagebreak"/></p>
<table class="basic-table">
<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Berlin52</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">ID</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">X</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Y</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tb1"><span class="sans_futura_std_book_">C1</span></p></td>
<td class="tbf"><p class="tb1"><span class="sans_futura_std_book_">0</span></p></td>
<td class="tbf"><p class="tb1"><span class="sans_futura_std_book_">565</span></p></td>
<td class="tbf"><p class="tb1"><span class="sans_futura_std_book_">575</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">C2</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">1</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">25</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">185</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">C3</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">2</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">345</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">750</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">C4</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">3</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">945</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">685</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">C5</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">4</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">845</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">655</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">C6</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">5</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">880</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">660</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">...</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">...</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">...</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">...</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">C50</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">49</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">595</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">360</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">C51</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">50</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">1340</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">725</span></p></td>
</tr>
<tr class="calibre14">
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">C52</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">51</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">1740</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">245</span></p></td>
</tr>
</tbody>
</table>
<p class="tx">The next code block declares all the global parameters <span aria-label="annotation2" class="codeannotation">❷</span>. For example, the number of cities (<span class="sans_thesansmonocd_w5regular_">numCities</span>) is set to 52, the number of ants (<span class="sans_thesansmonocd_w5regular_">numAnts</span>) is set to 30, the maximum number of iterations per round (<span class="sans_thesansmonocd_w5regular_">iterMax</span>) is set to 300, and the number of times the entire process is repeated (<span class="sans_thesansmonocd_w5regular_">maxRounds</span>) is set to 50. The comments next to the parameters indicate suggested ranges or values for these parameters.</p>
<p class="tx">Next, we define the classes and collections used in this project <span aria-label="annotation3" class="codeannotation">❸</span>. The <span class="sans_thesansmonocd_w5regular_">City</span> data class stores information on the locations to visit, including their names, ID numbers, and coordinates.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">Ant</span> class is used to create the ant colony, which is at the heart of ACS. The <span class="sans_thesansmonocd_w5regular_">Ant</span> class has several properties required for managing and monitoring ant movements. In particular, <span class="sans_thesansmonocd_w5regular_">citiesToVisit</span> dynamically keeps track of the remaining cities to visit, <span class="sans_thesansmonocd_w5regular_">pathNodes</span> stores the start and the end nodes for each path (edge) already traversed, and <span class="sans_thesansmonocd_w5regular_">pathSegments</span> stores the corresponding edge lengths. This class also has a method called <span class="sans_thesansmonocd_w5regular_">setCitiesToVisit()</span> that defines the initial list of cities each ant can visit.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">ArgMax</span> class is used during the tour construction phase. The <span class="sans_thesansmonocd_w5regular_">Solution</span> class stores information on completed tours, including the nodes and edges comprising a tour and its fitness value (length of the tour).</p>
<p class="tx">These classes are followed by a block that initializes a number of collections, arrays, and parameters. For example, <span class="sans_thesansmonocd_w5regular_">cities</span> is used to build a list of locations to visit, and <span class="sans_thesansmonocd_w5regular_">ants</span> is used to create the ant colony. Others are used to store ant solutions (<span class="sans_thesansmonocd_w5regular_">antSolutions</span>), best solutions (<span class="sans_thesansmonocd_w5regular_">bestSolutions</span>), and the best overall tour (<span class="sans_thesansmonocd_w5regular_">bestOverallTour</span>).</p>
<p class="tx">We use two-dimensional arrays to store information on the edges (<span class="sans_thesansmonocd_w5regular_">edges</span>) and corresponding pheromone levels (<span class="sans_thesansmonocd_w5regular_">pheromone</span>) and edge probabilities (<span class="sans_thesansmonocd_w5regular_">prob</span>). The final two lines set the default values for the best overall fitness (<span class="sans_thesansmonocd_w5regular_">bestOverallFitness</span>) and the counter variable <span class="sans_thesansmonocd_w5regular_">optimaCount</span>.</p>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h5 class="h2"><span id="sec19"/><span id="h3-83"/><span class="sans_futura_std_bold_b_">The main() Block</span></h5>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">main()</span> block is a minimal block with a few function calls and print functionalities.</p>
<pre class="calibre10"><code class="calibre11">fun main() {
    println("\n*** Solving Berlin52 TSP Using the Ant Colony System ***\n")
    // Conduct preprocessing.
<span aria-label="365" epub:type="pagebreak" id="pg_365" role="doc-pagebreak"/>    readCities()
    calculateEdges()
    calculatePheromone0()

    // Repeat the process maxRounds number of times.

  <span aria-label="annotation1" class="code_codeannotation">❶</span> for (round in 1..maxRounds) {
      <span aria-label="annotation2" class="code_codeannotation">❷</span> initializePheromone()
            runACS()
        processInterimResults(round)
        // Prepare for next iteration.
      <span aria-label="annotation3" class="code_codeannotation">❸</span> bestSolutions.clear()
    }

    // Print the best overall solution.
    printBestOverallFitnessAndTour()
    println("\noptimaCount: $optimaCount")
}</code></pre>
<p class="tx">The function starts by printing a problem-specific message on the console and then moves on to the preprocessing block. It calls the <span class="sans_thesansmonocd_w5regular_">readCities()</span> function to read off the location data from the input file. The <span class="sans_thesansmonocd_w5regular_">calculateEdges()</span> function uses the location coordinates to estimate the distances between pairs of nodes. The <span class="sans_thesansmonocd_w5regular_">calculatePheromone0()</span> function finds the nearest-neighbor tour length <i class="calibre9">C</i><sup class="calibre8">nn</sup> and uses that to estimate the initial pheromone levels <i class="calibre9"><span lang="el" xml:lang="el">τ</span></i><sub class="calibre19">0</sub> for all edges.</p>
<p class="tx">Next, we introduce a <span class="sans_thesansmonocd_w5regular_">for</span> loop <span aria-label="annotation1" class="codeannotation">❶</span> to carry out the entire ACS process a set number of times (<span class="sans_thesansmonocd_w5regular_">maxRounds</span>). The Berlin52 TSP is a challenging problem, and the ACS algorithm may not be able to locate the global optimal solution during each round of the ACS process, which involves <span class="sans_thesansmonocd_w5regular_">iterMax</span> attempts.</p>
<p class="tx">Inside the <span class="sans_thesansmonocd_w5regular_">for</span> loop, the <span class="sans_thesansmonocd_w5regular_">initializePheromone()</span> function <span aria-label="annotation2" class="codeannotation">❷</span> sets the initial pheromone level for all edges of the graph. Next, the driver function <span class="sans_thesansmonocd_w5regular_">runACS()</span> carries out the search for the optimal route. The <span class="sans_thesansmonocd_w5regular_">processInterimResults()</span> function updates the best overall fitness and best overall tour values, then prints the best solution for each round of search. Finally, the list of best solutions is cleared before starting the next round <span aria-label="annotation3" class="codeannotation">❸</span>.</p>
<p class="tx">The success rate of the ACS algorithm depends on the combination of global parameter values and the random initialization of the ants and their start nodes (in addition to the random selection of edges that happens during the implementation of the algorithm). In general, when a heuristic algorithm gets stuck at a local optimum even after attempting to find the global optimal solution a reasonable number of times, it may be beneficial to restart the entire process by resetting the initial conditions and changing the global parameters if needed, rather than increasing the number of iterations. The <span class="sans_thesansmonocd_w5regular_">for</span> loop in the <span class="sans_thesansmonocd_w5regular_">main()</span> block helps us automatically reset and restart the ACS process and carry it out <span class="sans_thesansmonocd_w5regular_">maxRounds</span> times.</p>
<p class="tx">Notice that we need to read the input data, calculate edge lengths, and calculate the initial pheromone level only once. Thus, those tasks are completed before initiating the <span class="sans_thesansmonocd_w5regular_">for</span> loop inside the <span class="sans_thesansmonocd_w5regular_">main()</span> block. However, we need to reset the pheromone levels to <i class="calibre9"><span lang="el" xml:lang="el">τ</span></i><sub class="calibre19">0</sub> each time we call the <span class="sans_thesansmonocd_w5regular_">runACS()</span> function.</p>
<p class="tx"><span aria-label="366" epub:type="pagebreak" id="pg_366" role="doc-pagebreak"/>The <span class="sans_thesansmonocd_w5regular_">main()</span> block ends with printing the best overall fitness and tour (from all rounds and iterations). It also prints the number of times the algorithm was successful in finding the global optimal solution.</p>
</section>
<section aria-labelledby="sec20" epub:type="division">
<h5 class="h2"><span id="sec20"/><span id="h3-84"/><span class="sans_futura_std_bold_b_">The readCities() Function</span></h5>
<p class="tni">The sole purpose of this function is to read the location data from an input file.</p>
<pre class="calibre10"><code class="calibre11">fun readCities() {
    // Open input file and read location data.
  <span aria-label="annotation1" class="code_codeannotation">❶</span> val file = File(datafile)
  <span aria-label="annotation2" class="code_codeannotation">❷</span> val lines = file.readLines().filterNot{it.isEmpty()}

    for (i in lines.indices) {
      <span aria-label="annotation3" class="code_codeannotation">❸</span> val items = lines[i].split(",")
        if (i == 0) {
            println("Reading data for " + items[0] + "-TSP")
        } else {
            // Read Name, ID, x, y.
          <span aria-label="annotation4" class="code_codeannotation">❹</span> cities += City(
                items[0],
                items[1].trim().toInt(),
                items[2].trim().toDouble(),
                items[3].trim().toDouble()
            )
        }
    }
}</code></pre>
<p class="tx">The Java <span class="sans_thesansmonocd_w5regular_">File</span> class <span aria-label="annotation1" class="codeannotation">❶</span> opens the input file from a location specified in the datafile string. The entire content of the datafile is read into memory as an array of strings (<span class="sans_thesansmonocd_w5regular_">lines</span>) <span aria-label="annotation2" class="codeannotation">❷</span>. We are applying <span class="sans_thesansmonocd_w5regular_">.filterNot{it.isEmpty()}</span> to <span class="sans_thesansmonocd_w5regular_">file.readLines()</span> to make reading the file safer with respect to empty lines.</p>
<p class="tx">Then, each line is split by using a comma (<span class="sans_thesansmonocd_w5regular_">,</span>) as the separator <span aria-label="annotation3" class="codeannotation">❸</span> (recall that the input file was created as a comma-separated value, or CSV, file). Finally, different parts of the split line are used to create a list of nodes (<span class="sans_thesansmonocd_w5regular_">cities</span>) by using the <span class="sans_thesansmonocd_w5regular_">City</span> class <span aria-label="annotation4" class="codeannotation">❹</span>.</p>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h5 class="h2"><span id="sec21"/><span id="h3-85"/><span class="sans_futura_std_bold_b_">The calculateEdges() Function</span></h5>
<p class="tni">The purpose of this function is to calculate and save the edge lengths (path segments) of a tour.</p>
<pre class="calibre10"><code class="calibre11">fun calculateEdges() {
    // Assume symmetry: edges[i][j] = edges[j][i].
    for (i in 0 until cities.size) {
        for (j in i until cities.size) {
            if (i == j) {
              <span aria-label="annotation1" class="code_codeannotation">❶</span> edges[i][j] = 0.0
            } else {
<span aria-label="367" epub:type="pagebreak" id="pg_367" role="doc-pagebreak"/>              <span aria-label="annotation2" class="code_codeannotation">❷</span> edges[i][j] = sqrt((cities[i].x - cities[j].x).pow(2) +
                      (cities[i].y - cities[j].y).pow(2))
              <span aria-label="annotation3" class="code_codeannotation">❸</span> edges[j][i] = edges[i][j]
            }
        }
    }
}</code></pre>
<p class="tx">The edge lengths are saved in a two-dimensional array, where the diagonal elements (<span class="sans_thesansmonocd_w5regular_">i</span> = <span class="sans_thesansmonocd_w5regular_">j</span>) are set to <span class="sans_thesansmonocd_w5regular_">0.0</span> <span aria-label="annotation1" class="codeannotation">❶</span> (the distance of a node from itself is zero), and the off-diagonal elements are set to Euclidian distances between a pair of nodes <span aria-label="annotation2" class="codeannotation">❷</span>. We’re assuming that a pair of nodes is connected by a single edge or path. This allows us to calculate only the upper triangle of the matrix and set the lower triangle values by using the property of symmetry <span aria-label="annotation3" class="codeannotation">❸</span>.</p>
</section>
<section aria-labelledby="sec22" epub:type="division">
<h5 class="h2"><span id="sec22"/><span id="h3-86"/><span class="sans_futura_std_bold_b_">The calculatePheromone0() Function</span></h5>
<p class="tni">This function calculates the nearest-neighbor tour length <i class="calibre9">C</i><sup class="calibre8">nn</sup> and uses that to estimate the initial pheromone level, <span class="sans_thesansmonocd_w5regular_">pheromone0</span>.</p>
<pre class="calibre10"><code class="calibre11">fun calculatePheromone0() {
    // Start at node 0 (first city in the dataset).
  <span aria-label="annotation1" class="code_codeannotation">❶</span> var i = 0 // Start node for the nearest-neighbor tour.
    val citiesToVisitList = (1 until numCities).toMutableList()
    var nearestNeighborTourLength = 0.0

    // Build the nearest-neighbor tour.
  <span aria-label="annotation2" class="code_codeannotation">❷</span> while (citiesToVisitList.size &gt; 0) {
        // Set initial search parameters.
        var nearestNode = -9999 // Use an unlikely value.
        var nearestNodeDistance = Double.MAX_VALUE

        for (j in citiesToVisitList) {
            if (edges[i][j] &lt; nearestNodeDistance) {
                nearestNodeDistance = edges[i][j]
                nearestNode = j
            }
        }

      <span aria-label="annotation3" class="code_codeannotation">❸</span> nearestNeighborTourLength += nearestNodeDistance
      <span aria-label="annotation4" class="code_codeannotation">❹</span> citiesToVisitList.remove(nearestNode)
        i = nearestNode
    }
    // Add the edge connecting the last city visited and the starting city.
  <span aria-label="annotation5" class="code_codeannotation">❺</span> nearestNeighborTourLength += edges[i][0]

    // Calculate initial pheromone value per ACS.
  <span aria-label="annotation6" class="code_codeannotation">❻</span> pheromone0 = 1.0/(numCities * nearestNeighborTourLength)
}</code></pre>
<p class="tx">This function finds the nearest-neighbor tour by starting the tour from node 0 <span aria-label="annotation1" class="codeannotation">❶</span> and moving to the nearest nodes with a <span class="sans_thesansmonocd_w5regular_">while</span> loop <span aria-label="annotation2" class="codeannotation">❷</span> until all <span aria-label="368" epub:type="pagebreak" id="pg_368" role="doc-pagebreak"/>nodes or cities are visited. At each step, the shortest edge is identified and added to the nearest-neighbor tour length <span aria-label="annotation3" class="codeannotation">❸</span>. Once the node is added to the tour, it is removed from the list of cities to visit <span aria-label="annotation4" class="codeannotation">❹</span>. The tour is closed by connecting the last node visited to the start node and adding the corresponding edge length to the total tour length <span aria-label="annotation5" class="codeannotation">❺</span>. Finally, the initial pheromone level <span class="sans_thesansmonocd_w5regular_">pheromone0</span> is calculated as equal to 1/(<i class="calibre9">nC</i><sup class="calibre8">nn</sup>) <span aria-label="annotation6" class="codeannotation">❻</span>.</p>
</section>
<section aria-labelledby="sec23" epub:type="division">
<h5 class="h2"><span id="sec23"/><span id="h3-87"/><span class="sans_futura_std_bold_b_">The initializePheromone() Function</span></h5>
<p class="tni">This function sets initial pheromone levels for all edges of the graph to <span class="sans_thesansmonocd_w5regular_">pheromone0</span>.</p>
<pre class="calibre10"><code class="calibre11">fun initializePheromone() {
    // All edges have the same initial pheromone level.
    for (i in 0 until numCities) {
        for (j in i until numCities)
            if (i != j) {
                pheromone[i][j] = pheromone0
                pheromone[j][i] = pheromone0
            } else pheromone[i][j] = 0.0
    }
}</code></pre>
<p class="tx">The pheromone levels are stored in a two-dimensional array (a matrix), and the property of symmetry is used to calculate the lower triangle elements of the matrix by setting <i class="calibre9"><span lang="el" xml:lang="el">τ</span></i><span class="epub-i-sub">ji</span> = <i class="calibre9"><span lang="el" xml:lang="el">τ</span></i><span class="epub-i-sub">ij</span>. Notice that when <i class="calibre9">i</i> = <i class="calibre9">j</i>, the node is simply referring to itself, and the corresponding diagonal elements are set to 0.0. These values are not required or used by the ACS algorithm.</p>
</section>
<section aria-labelledby="sec24" epub:type="division">
<h5 class="h2"><span id="sec24"/><span id="h3-88"/><span class="sans_futura_std_bold_b_">The runACS() Function</span></h5>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">runACS()</span> function creates the ant colony, coordinates the tour construction for individual ants, saves intermediate results, and implements the global pheromone update rule. We’ll begin by providing an overview of the key elements of this function, which will be followed by discussions on the individual helper functions.</p>
<pre class="calibre10"><code class="calibre11">fun runACS() {
    var iter = 1
    while(iter &lt;= iterMax) {
        // Create a new ant colony.
      <span aria-label="annotation1" class="code_codeannotation">❶</span> initializeAnts()

        // Generate tours for all ants.
        for (ant in ants) {
          <span aria-label="annotation2" class="code_codeannotation">❷</span> ant.setCitiesToVisit()
          <span aria-label="annotation3" class="code_codeannotation">❸</span> buildAntTour(ant)
          <span aria-label="annotation4" class="code_codeannotation">❹</span> antSolutions += Solution(
                                iter,
                                ant.id,
                                ant.pathNodes,
                                ant.pathSegments,
<span aria-label="369" epub:type="pagebreak" id="pg_369" role="doc-pagebreak"/>                                ant.fitness)
        }

        // Get the solution with minimum fitness.
      <span aria-label="annotation5" class="code_codeannotation">❺</span> val bestAntSolution =
            antSolutions.minWith(compareBy {it.fitness})
      <span aria-label="annotation6" class="code_codeannotation">❻</span> bestSolutions += bestAntSolution
      <span aria-label="annotation7" class="code_codeannotation">❼</span> globalPheromoneUpdate()

        // Clear previously saved states of ants and solutions.
        ants.clear()
        antSolutions.clear()

        // Advance the counter.
      <span aria-label="annotation8" class="code_codeannotation">❽</span> iter += 1
    }
}</code></pre>
<p class="tx">The code segment begins by setting the iteration counter <span class="sans_thesansmonocd_w5regular_">iter</span> to <span class="sans_thesansmonocd_w5regular_">1</span>. A <span class="sans_thesansmonocd_w5regular_">while</span> loop is used to repeat the search <span class="sans_thesansmonocd_w5regular_">iterMax</span> times. Inside the loop, <span class="sans_thesansmonocd_w5regular_">initializeAnts()</span> creates the ant colony for a specific iteration <span aria-label="annotation1" class="codeannotation">❶</span>.</p>
<p class="tx">Once the ant colony is initiated, a tour for each ant is constructed inside a <span class="sans_thesansmonocd_w5regular_">for</span> loop. The process starts with setting a list of cities to visit for each ant <span aria-label="annotation2" class="codeannotation">❷</span> by invoking the <span class="sans_thesansmonocd_w5regular_">setCitiesToVisit()</span> method of the <span class="sans_thesansmonocd_w5regular_">Ant</span> class. The actual tour is built by the <span class="sans_thesansmonocd_w5regular_">buildAntTour()</span> function <span aria-label="annotation3" class="codeannotation">❸</span>.</p>
<p class="tx">Once the optimal tour for an individual ant is completed, relevant information is saved in <span class="sans_thesansmonocd_w5regular_">antSolutions</span> <span aria-label="annotation4" class="codeannotation">❹</span>. The best of all ant solutions (for the current iteration) is found by using the <span class="sans_thesansmonocd_w5regular_">minWith()</span> function of Kotlin <span aria-label="annotation5" class="codeannotation">❺</span>, which is then added to the <span class="sans_thesansmonocd_w5regular_">bestSolutions</span> list <span aria-label="annotation6" class="codeannotation">❻</span>. At this stage, the <span class="sans_thesansmonocd_w5regular_">globalPheromoneUpdate()</span> function is called to apply the global pheromone update rule <span aria-label="annotation7" class="codeannotation">❼</span>. Next, <span class="sans_thesansmonocd_w5regular_">ants</span> and <span class="sans_thesansmonocd_w5regular_">antSolutions</span> are cleared in preparation for the next iteration. Finally, <span class="sans_thesansmonocd_w5regular_">iter</span> is incremented by 1 <span aria-label="annotation8" class="codeannotation">❽</span>; the process will exit the <span class="sans_thesansmonocd_w5regular_">while</span> loop when <span class="sans_thesansmonocd_w5regular_">iter</span> &gt; <span class="sans_thesansmonocd_w5regular_">iterMax</span>.</p>
</section>
<section aria-labelledby="sec25" epub:type="division">
<h5 class="h2"><span id="sec25"/><span id="h3-89"/><span class="sans_futura_std_bold_b_">The initializeAnts() Function</span></h5>
<p class="tni">The code snippet for the <span class="sans_thesansmonocd_w5regular_">initializeAnts()</span> function is very short.</p>
<pre class="calibre10"><code class="calibre11">fun initializeAnts() {
    // Create a list of nodes (cities) to set start nodes for ants.
    val cityList = (0 until numCities).toList()
    // While creating a new Ant, set its start node randomly.
    for (i in 0 until numAnts) ants += Ant(i, cityList.random())
}</code></pre>
<p class="tx">This code begins by creating a list of indices, each designating a city or node. Next, it creates the ants one by one and assigns each ant a start node selected randomly from the list of cities to visit.</p>
<p class="tx">This scheme allows multiple ants to have the same start node, while some nodes may not have any ants assigned to them. This flexibility is beneficial when the number of ants differs from the number of nodes.</p>
</section>
<section aria-labelledby="sec26" epub:type="division">
<span aria-label="370" epub:type="pagebreak" id="pg_370" role="doc-pagebreak"/>
<h5 class="h2"><span id="sec26"/><span id="h3-90"/><span class="sans_futura_std_bold_b_">The buildAntTour() Function</span></h5>
<p class="tni">This function identifies the next node to visit, updates relevant ant properties to reflect that choice, and recursively builds the entire tour. It also calculates the ant fitness when the tour is complete and applies the local pheromone update for each edge traveled.</p>
<pre class="calibre10"><code class="calibre11">fun buildAntTour(ant: Ant) {

  <span aria-label="annotation1" class="code_codeannotation">❶</span> var i = ant.currentNode

    while (ant.citiesToVisit.size &gt; 0) {
        // Find the next node to visit per ACS.
      <span aria-label="annotation2" class="code_codeannotation">❷</span> val nextNode = selectNodeToVisit(i, ant)

        // edge-specific local pheromone update per ACS
      <span aria-label="annotation3" class="code_codeannotation">❸</span> pheromone[i][nextNode] =
                 (1- zeta) * pheromone[i][nextNode] +
                 (zeta * pheromone0)
        ant.currentNode = nextNode
        ant.pathNodes += Pair(i, nextNode)
        ant.pathSegments += edges[i][nextNode]
        i = ant.currentNode
      <span aria-label="annotation4" class="code_codeannotation">❹</span> ant.citiesToVisit.remove(nextNode)
    }
    // Close the loop by adding the last Pair() of nodes to the path
    // and adding the last path segment to the tour.
    ant.pathNodes += Pair(ant.currentNode, ant.start)
    ant.pathSegments += edges[ant.currentNode][ant.start]

    // Calculate the fitness of the entire loop (closed path).
  <span aria-label="annotation5" class="code_codeannotation">❺</span> ant.fitness = ant.pathSegments.sum()

    // edge-specific local pheromone update for the last path segment
  <span aria-label="annotation6" class="code_codeannotation">❻</span> pheromone[ant.currentNode][ant.start] =
        (1- zeta) * pheromone[ant.currentNode][ant.start] +
        (zeta * pheromone0)
}</code></pre>
<p class="tx">The function starts with setting the current location index <span class="sans_thesansmonocd_w5regular_">i</span> to the ant’s <span class="sans_thesansmonocd_w5regular_">currentNode</span> property (which is initially the same as <span class="sans_thesansmonocd_w5regular_">startNode</span>) <span aria-label="annotation1" class="codeannotation">❶</span>. Subsequent nodes to visit are found by using a <span class="sans_thesansmonocd_w5regular_">while</span> loop until the list of cities to visit is exhausted. The process of selecting the next node is quite involved and is implanted by <span class="sans_thesansmonocd_w5regular_">selectNodeToVisit()</span> <span aria-label="annotation2" class="codeannotation">❷</span>, a function we’ll discuss in more detail shortly.</p>
<p class="tx">After locating <span class="sans_thesansmonocd_w5regular_">nextNode</span>, the local pheromone update rule is applied <span aria-label="annotation3" class="codeannotation">❸</span>, and the <span class="sans_thesansmonocd_w5regular_">currentNode</span> property of the ant is set to <span class="sans_thesansmonocd_w5regular_">nextNode</span>. At this time, relevant ant properties are updated based on the move from node <span class="sans_thesansmonocd_w5regular_">i</span> to <span class="sans_thesansmonocd_w5regular_">nextNode</span>. Before repeating the iteration for the next node or city to visit, the current node index <span class="sans_thesansmonocd_w5regular_">i</span> is updated to <span class="sans_thesansmonocd_w5regular_">currentNode</span> (that is, to the most recent <span class="sans_thesansmonocd_w5regular_">nextNode</span>) and then <span class="sans_thesansmonocd_w5regular_">nextNode</span> is removed from the list of cities to visit <span aria-label="annotation4" class="codeannotation">❹</span>.</p>
<p class="tx"><span aria-label="371" epub:type="pagebreak" id="pg_371" role="doc-pagebreak"/>Once the ant is done visiting all the cities it is allowed to visit, the tour is closed by connecting the last city visited to the city from which the ant started its tour. This is done by updating the ant’s <span class="sans_thesansmonocd_w5regular_">pathNodes</span> and <span class="sans_thesansmonocd_w5regular_">pathSegments</span> properties. When the tour is complete, its fitness (length) is calculated <span aria-label="annotation5" class="codeannotation">❺</span>, and the local pheromone update rule is applied one more time for the last segment of the tour <span aria-label="annotation6" class="codeannotation">❻</span>.</p>
</section>
<section aria-labelledby="sec27" epub:type="division">
<h5 class="h2"><span id="sec27"/><span id="h3-91"/><span class="sans_futura_std_bold_b_">The selectNodeToVisit() Function</span></h5>
<p class="tni">This function implements the most mathematically involved part of the ACS algorithm that uses both an argmax type function and the roulette wheel scheme to decide which node to visit next.</p>
<pre class="calibre10"><code class="calibre11">fun selectNodeToVisit(i: Int, ant: Ant): Int {

    var chosenNode = -9999 // Use an unlikely value.
    val argmaxList = mutableListOf&lt;ArgMax&gt;()

    // Calculate edge probabilities and argMaxList elements.
    var sum = 0.0
  <span aria-label="annotation1" class="code_codeannotation">❶</span> for (j in ant.citiesToVisit) {
        prob[i][j] = (pheromone[i][j]).pow(alpha) /
                     (edges[i][j]).pow(beta)
        sum += prob[i][j]
        argmaxList += ArgMax(j, prob[i][j])
    }

    // Calculate normalized values of the edge probabilities.
  <span aria-label="annotation2" class="code_codeannotation">❷</span> for (j in ant.citiesToVisit) {
        prob[i][j] = prob[i][j] / sum
    }

    // Use argmax or roulette wheel scheme to select j.
  <span aria-label="annotation3" class="code_codeannotation">❸</span> val q = (0 until 1000).random()/1000.0

    if (q &lt;= q0) {
        // Use accumulated experience more greedily per ACS.
        val maxArgMax = argmaxList.maxWith(compareBy {it.value})
      <span aria-label="annotation4" class="code_codeannotation">❹</span> chosenNode = maxArgMax.index
    } else {
      <span aria-label="annotation5" class="code_codeannotation">❺</span> // Use roulette wheel scheme.
        val spin = (0 until 1000).random()/1000.0
        var sumProb = 0.0
        for (j in ant.citiesToVisit) {
            sumProb += prob[i][j]
          <span aria-label="annotation6" class="code_codeannotation">❻</span> if (spin &lt;= sumProb) {
                chosenNode = j
                break
           }
        }
    }
  <span aria-label="annotation7" class="code_codeannotation">❼</span> return chosenNode
}</code></pre>
<p class="tx"><span aria-label="372" epub:type="pagebreak" id="pg_372" role="doc-pagebreak"/>The function first creates local variables for saving the chosen node (<span class="sans_thesansmonocd_w5regular_">chosenNode</span>, initially set to an unlikely value) and a mutable list to which an argmax operation will be applied per Equation 9.8. Next, edge-specific raw probabilities are calculated inside the first <span class="sans_thesansmonocd_w5regular_">for</span> loop <span aria-label="annotation1" class="codeannotation">❶</span>. This loop also populates the <span class="sans_thesansmonocd_w5regular_">argmaxList</span>, which stores the possible destination node index <i class="calibre9">j</i> as its <span class="sans_thesansmonocd_w5regular_">index</span> property and the corresponding <span class="sans_thesansmonocd_w5regular_">prob[i][j]</span> (before being normalized) as its <span class="sans_thesansmonocd_w5regular_">value</span>. The second <span class="sans_thesansmonocd_w5regular_">for</span> loop <span aria-label="annotation2" class="codeannotation">❷</span> converts the raw probabilities to normalized probabilities.</p>
<p class="tx">After the initial processing, a random number <i class="calibre9">q</i> is drawn from a uniform distribution <span aria-label="annotation3" class="codeannotation">❸</span>. If <i class="calibre9">q</i> &lt;= <i class="calibre9">q</i><sub class="calibre19">0</sub>, the argmax rule is used to choose the next node index <span aria-label="annotation4" class="codeannotation">❹</span>. Otherwise, Equation 9.9 is used to find the next node index by using the roulette wheel scheme <span aria-label="annotation5" class="codeannotation">❺</span>. In particular, when the <span class="sans_thesansmonocd_w5regular_">spin</span> value is less than or equal to the sum of normalized probabilities up to index <i class="calibre9">j</i>, we set <span class="sans_thesansmonocd_w5regular_">chosenNode</span> equal to <i class="calibre9">j</i> <span aria-label="annotation6" class="codeannotation">❻</span> and break out of the loop. Finally, the value of <span class="sans_thesansmonocd_w5regular_">chosenNode</span> is returned <span aria-label="annotation7" class="codeannotation">❼</span>.</p>
</section>
<section aria-labelledby="sec28" epub:type="division">
<h5 class="h2"><span id="sec28"/><span id="h3-92"/><span class="sans_futura_std_bold_b_">The globalPheromoneUpdate() Function</span></h5>
<p class="tni">This function applies the global pheromone update rule once all ants finish building their tours for a particular iteration.</p>
<pre class="calibre10"><code class="calibre11">fun globalPheromoneUpdate() {
    val bestSoFar =
        bestSolutions.minWith(compareBy {it.fitness})
    for (pair in bestSoFar.pathNodes) {
        val (i,j) = pair
        pheromone[i][j] = (1 - rho) * pheromone[i][j] + rho/bestSoFar.fitness
    }
}</code></pre>
<p class="tx">This function has two key steps. First, it identifies the best-so-far solution since the beginning of the iterations inside the <span class="sans_thesansmonocd_w5regular_">while</span> loop of <span class="sans_thesansmonocd_w5regular_">runACS()</span>. Next, pheromone levels are updated only for the edges (path segments) that belong to the best-so-far tour.</p>
</section>
<section aria-labelledby="sec29" epub:type="division">
<h5 class="h2"><span id="sec29"/><span id="h3-93"/><span class="sans_futura_std_bold_b_">Other Functions in the main() Block</span></h5>
<p class="tni">The other functions in the <span class="sans_thesansmonocd_w5regular_">main()</span> block are not part of the ACS algorithm. Instead, we use these functions to monitor the convergence of the algorithm and to print final values of the best overall fitness and corresponding solution at the end.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">processInterimResults()</span> function helps save and print intermediate results after the completion of each round of calculations inside the <span class="sans_thesansmonocd_w5regular_">for</span> loop of the <span class="sans_thesansmonocd_w5regular_">main()</span> function.</p>
<pre class="calibre10"><code class="calibre11">fun processInterimResults(round: Int) {
  <span aria-label="annotation1" class="code_codeannotation">❶</span> val bestSoFar =
        bestSolutions.minWith(compareBy {it.fitness})
  <span aria-label="annotation2" class="code_codeannotation">❷</span> if (bestSoFar.fitness &lt; bestOverallFitness) {
        bestOverallFitness = bestSoFar.fitness
<span aria-label="373" epub:type="pagebreak" id="pg_373" role="doc-pagebreak"/>        bestOverallTour = bestSoFar.pathNodes
    }

  <span aria-label="annotation3" class="code_codeannotation">❸</span> // Print interim results.
    println("round: $round iter: ${bestSoFar.iteration}" +
            "ant: ${bestSoFar.antID}")
    println("bestSoFar.fitness: ${bestSoFar.fitness}")

    // Count the number of times global optima are found.
  <span aria-label="annotation4" class="code_codeannotation">❹</span> if (bestSoFar.fitness - 7544.3659 &lt; 0.0001)
        optimaCount += 1
    }</code></pre>
<p class="tx">This function first sorts the <span class="sans_thesansmonocd_w5regular_">bestSolutions</span> to find the best-so-far solution based on the fitness values of the solutions <span aria-label="annotation1" class="codeannotation">❶</span>. Next, it updates the value of <span class="sans_thesansmonocd_w5regular_">bestOverallFitness</span>, the best fitness found from all rounds up to this point <span aria-label="annotation2" class="codeannotation">❷</span>. The current number of rounds, the iteration number, and the <span class="sans_thesansmonocd_w5regular_">antID</span> are then printed along with the best-so-far fitness <span aria-label="annotation3" class="codeannotation">❸</span>. This helps us monitor how the algorithm is doing as it proceeds through the number of rounds (as mentioned earlier, the maximum number of rounds is set by <span class="sans_thesansmonocd_w5regular_">maxRounds</span>).</p>
<p class="tx">Finally, we check to see if the fitness of <span class="sans_thesansmonocd_w5regular_">bestSoFar</span> matches the known global optimal fitness for the Berlin52 problem (7544.3659) and count the number of such matches <span aria-label="annotation4" class="codeannotation">❹</span> (which is later printed from the <span class="sans_thesansmonocd_w5regular_">main()</span> function).</p>
<p class="tx">The final function called from <span class="sans_thesansmonocd_w5regular_">main()</span> is <span class="sans_thesansmonocd_w5regular_">printBestOverallFitnessAndTour()</span>, which prints the optimal function value and solution found by the ACS algorithm.</p>
<pre class="calibre10"><code class="calibre11">fun printBestOverallFitnessAndTour() {
    println("\nbestOverallFitness:  $bestOverallFitness")
    println("\nbestOverallTour: ")

    for (i in bestOverallTour.indices) {
        print("${bestOverallTour[i]}".padEnd(10))
        if ((i+1) % 5 == 0) println()
    }
    println()
}</code></pre>
<p class="tx">The first line inside the function prints the value of the best overall fitness. The optimal solution in this case is a list of <span class="sans_thesansmonocd_w5regular_">Pairs</span>, where each pair consists of the start and the end nodes for the edges that belong to the best overall tour. We use a <span class="sans_thesansmonocd_w5regular_">for</span> loop and an <span class="sans_thesansmonocd_w5regular_">if</span> statement to print five pairs of nodes per line so that the entire solution can be examined easily in the console.</p>
</section>
</section>
<section aria-labelledby="sec30" epub:type="division">
<h4 class="h1"><span id="sec30"/><span id="h2-150"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">Following is a sample output from a test run of the ACS application. I encourage you to compare this output with the various print statements and functions used in the entire ACS code.</p>
<pre class="calibre10"><code class="calibre11"><span aria-label="374" epub:type="pagebreak" id="pg_374" role="doc-pagebreak"/>*** Solving Berlin52 TSP Using the Ant Colony System ***

Reading data for Berlin52 TSP

round: 1 iter: 245 ant: 11
bestSoFar.fitness: 7994.43559098265
round: 2 iter: 105 ant: 0
bestSoFar.fitness: 7544.365901904086
round: 3 iter: 270 ant: 2
bestSoFar.fitness: 7842.717484844844

<var class="calibre18">--snip--</var>

round: 49 iter: 186 ant: 14
bestSoFar.fitness: 7544.365901904086
round: 50 iter: 226 ant: 9
bestSoFar.fitness: 7721.297918696817

bestOverallFitness:  7544.365901904086

bestOverallTour:
(14, 5)   (5, 3)    (3, 24)   (24, 11)  (11, 27)
(27, 26)  (26, 25)  (25, 46)  (46, 12)  (12, 13)
(13, 51)  (51, 10)  (10, 50)  (50, 32)  (32, 42)
(42, 9)   (9, 8)    (8, 7)    (7, 40)   (40, 18)
(18, 44)  (44, 31)  (31, 48)  (48, 0)   (0, 21)
(21, 30)  (30, 17)  (17, 2)   (2, 16)   (16, 20)
(20, 41)  (41, 6)   (6, 1)    (1, 29)   (29, 22)
(22, 19)  (19, 49)  (49, 28)  (28, 15)  (15, 45)
(45, 43)  (43, 33)  (33, 34)  (34, 35)  (35, 38)
(38, 39)  (39, 36)  (36, 37)  (37, 47)  (47, 23)
(23, 4)   (4, 14)

optimaCount: 5</code></pre>
<p class="tx">We can see that on this occasion, the first instance of global optima was found in the second round (during <span class="sans_thesansmonocd_w5regular_">iter</span> = 105 and by <span class="sans_thesansmonocd_w5regular_">ant</span> number 0). A near-optimal solution with a fitness of 7548.99 was found multiple times (not shown). The best overall solution had a fitness of 7544.3659, which is the known shortest tour length for the Berlin52 problem.</p>
<p class="tx">All the nodes that belong to the optimal (best overall) tour are also shown in the output. Notice that the optimal tour is a closed loop, and it returns to the same node it starts from. The sequence of the nodes in the optimal solution may differ when you run the code. This will not affect the tour length (therefore, its fitness will remain the same).</p>
<p class="tx">The final item in the output, <span class="sans_thesansmonocd_w5regular_">optimaCount</span>, indicates that during the entire process, the global optimal solution was found 5 times out of 50 rounds (although each of those rounds might have found the global optimal solution more than once). If you plot the nodes that belong to the best overall tour by using their x- and y-coordinates, the optimal tour will look like the path shown in <a href="chapter9.xhtml#fig9-4" class="calibre2">Figure 9-4</a>.</p>
<span aria-label="375" epub:type="pagebreak" id="pg_375" role="doc-pagebreak"/>
<figure class="img"><img alt="" class="img1" height="855" id="fig9-4" src="../images/Figure9-4.jpg" width="1259"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 9-4: The optimal tour for the Berlin52 traveling salesman problem</span></p></figcaption>
</figure>
<p class="tx">To visualize the convergence patterns for the rounds that found the global optima, you can add a few additional lines of code to save the relevant data from intermediate steps and plot the data. A typical convergence plot will look like the patterns shown in <a href="chapter9.xhtml#fig9-5" class="calibre2">Figure 9-5</a>.</p>
<figure class="img"><img alt="" class="img1" height="1102" id="fig9-5" src="../images/Figure9-5.jpg" width="1573"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 9-5: Convergence patterns for the Berlin52 problem</span></p></figcaption>
</figure>
<p class="tx"><span aria-label="376" epub:type="pagebreak" id="pg_376" role="doc-pagebreak"/>Before concluding this project, I want to make a couple of points regarding the success rate of the ACS algorithm and the accuracy of the solution generated by the code we developed. These comments will clarify some questions that you may have when you run the code on your device or compare the results with the same published elsewhere.</p>
<p class="tx">First, recalling that the NIAs used in this book are stochastic, the <span class="sans_thesansmonocd_w5regular_">optimaCount</span> will vary each time you run the program. For the given set of values for the global parameters, I found the average <span class="sans_thesansmonocd_w5regular_">optimaCount</span> to be around 5 (based on 10 runs). However, if you change the values of the global parameters, this average success rate will change. I encourage you to play with those parameters to develop an understanding of their relative influence in finding the global optima.</p>
<p class="tx">Second, you may find in the literature that the optimal (shortest) tour length for the Berlin52 problem is 7542, which is slightly different from the optimal value we found, 7544.3659. This does not indicate any issues with the ACS algorithm or with the code developed in this project; it is due to the fact that some algorithms convert the nodal (intercity) distances to the nearest integer values before solving the problem, for mathematical efficiency. Therefore, those methods essentially solve a slightly different problem. However, our ACS application has identified the exact same optimal route as reported in the literature.</p>
<p class="tx">Ant colony optimization is an area of active research, just like other NIAs. New modifications are being proposed and tested to improve the convergence and accuracy of this algorithm. I strongly encourage you to consult recently published literature if you are interested in using ACS or similar algorithms to solve large real-world routing problems.</p>
</section>
</section>
<section aria-labelledby="sec31" epub:type="division">
<h3 class="h"><span id="sec31"/><span id="h1-58"/><span class="sans_futura_std_bold_b_">Summary</span></h3>
<p class="tni">This chapter completes your introduction to the fascinating world of NIAs and their applications. You discovered two more powerful tools—particle swarm optimization and ant colony systems—and you learned how to harness the power of these algorithms in Kotlin. You put your skills to the test with two real-world optimization problems: finding the global minimum of a complex mathematical function and solving the traveling salesman problem for a network of 52 locations in Berlin. You explored how the algorithms converged to the optimal solutions over time and how to measure their performance. And of course, you challenged yourself with exercises to reinforce your learning.</p>
</section>
<section aria-labelledby="sec32" epub:type="division">
<h3 class="h"><span id="sec32"/><span id="h1-59"/><span class="sans_futura_std_bold_b_">Resources</span></h3>
<p class="reference">Brownlee, Jason. <i class="calibre9">Clever Algorithms: Nature-Inspired Programming Recipes</i>. Electronic version, June 16, 2012. <i class="calibre9"><a href="https://github.com/clever-algorithms/CleverAlgorithms" class="calibre2">https://github.com/clever-algorithms/CleverAlgorithms</a></i>.</p>
<p class="reference">Clerc, Maurice. <i class="calibre9">Particle Swarm Optimization</i>. London: ISTE, 2006.</p>
<p class="reference"><span aria-label="377" epub:type="pagebreak" id="pg_377" role="doc-pagebreak"/>Dorigo, Marco, and Thomas St<span class="copyright_accent">ü</span>tzle. <i class="calibre9">Ant Colony Optimization</i>. Cambridge, MA: MIT Press, 2004.</p>
<p class="reference">Olsson, Andrea E., ed. <i class="calibre9">Particle Swarm Optimization: Theory, Techniques and Applications</i>. New York: Nova Science, 2011.</p>
<p class="reference">Parsopoulos, Konstantinos E. “Particle Swarm Methods.” In <i class="calibre9">Handbook of Heuristics</i>, edited by Rafael Mart<span class="copyright_accent">í</span>, Panos M. Pardalos, and Mauricio G. C. Resende, 639–685. Cham, Switzerland: Springer, 2018.</p>
<p class="reference">Solnon, Christine. <i class="calibre9">Ant Colony Optimization and Constraint Programming</i>. London: ISTE, 2013.</p>
<p class="reference">TSPLIB. Symmetric Traveling Salesman Problem (TSP). Accessed June 15, 2024. <i class="calibre9"><a href="http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/" class="calibre2">http://<wbr/>comopt<wbr/>.ifi<wbr/>.uni<wbr/>-heidelberg<wbr/>.de<wbr/>/software<wbr/>/TSPLIB95<wbr/>/</a></i>.</p>
<p class="reference">Yang, Xin-She. <i class="calibre9">Nature-Inspired Optimization Algorithms</i>. 2nd ed. London: Academic Press, 2021.</p>
</section>
</section>
</div></body></html>