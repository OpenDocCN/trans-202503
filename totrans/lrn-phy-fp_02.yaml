- en: '1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CALCULATING WITH HASKELL
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll see how Haskell can be used as a scientific calculator.
    Multiple scientific functions are available by default in this calculator. In
    [Chapter 2](ch02.xhtml), we’ll write functions of our own that we can load and
    use. This chapter introduces some features and details of the language that will
    be useful later. Let’s start with a kinematics problem.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: A Kinematics Problem
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose we have a car on an air track. The car accelerates at a rate of 0.4
    m/s². At time *t* = 0, the car is stationary. How much time will it take for this
    car to travel 2 meters?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: The acceleration is constant, so we can use the position-time equation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/003equ01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
- en: Because the car starts at rest, we know *v*(0) = 0\. Let’s assume that the car
    starts at position zero, the origin, so that *x*(0) = 0\. We’re looking for the
    time *t* at which *x*(*t*) = 2 m. A little algebra tells us that
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/004equ01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
- en: We could solve this using pen and paper, or we could use a calculator. In this
    chapter, we’ll be using Haskell as our calculator.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll start a step-by-step explanation of how to use Haskell
    as a calculator. To close out this section, we’ll just show what you’d enter to
    calculate the time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, it takes about 3.2 seconds for the car to travel 2 meters. Now,
    let’s look at how to start up the interactive Haskell “calculator.”
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The Interactive Compiler
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The kinematics example gives us an excuse to introduce the interactive version
    of the Glasgow Haskell Compiler (GHC). The interactive version of GHC is called
    GHCi, and we can use it as a calculator. GHCi is included with the Glasgow Haskell
    Compiler, which is freely available at [*https://www.haskell.org*](https://www.haskell.org).
    The method of starting GHCi may depend on the operating system your computer uses.
    Typically, you can click an icon, choose GHCi from a menu, or enter `ghci` in
    a command line.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: When GHCi starts, we get a prompt at which we can enter expressions. The first
    prompt we get from GHCi is `Prelude>`. The Prelude is a collection of constants,
    functions, and operators available by default, and we can immediately use it to
    construct expressions. GHCi indicates that the Prelude has been loaded for us
    by including the name `Prelude` in the prompt. GHCi is now waiting for us to enter
    an expression. If you type `2/3`, followed by ENTER, GHCi will evaluate this expression
    and print a result.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the expression `2/3`, Haskell interprets the `2` and `3` as numbers and the
    `/` as a binary operator for division. GHCi performs the requested division and
    returns the result.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Numeric Functions
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Haskell provides functions in the Prelude to perform many of the tasks you
    expect from calculators. Here’s an example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is the natural logarithm function applied to the number 2\. The Haskell
    language does not need parentheses to apply a function. *Function application*
    (also known as *function use* or *function evaluation*) is such a basic idea in
    Haskell that the juxtaposition of two expressions is taken to mean that the first
    expression is a function and the second is an argument, and that the function
    is applied to the argument. Therefore, we can type the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Table 1-1](ch01.xhtml#ch1tab1) gives a list of numeric functions available
    in the Prelude.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 1-1:** Some Common Numeric Functions'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
- en: '| `exp` | exp *x* = *e^x* |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
- en: '| `sqrt` | Square root |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: '| `abs` | Absolute value |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: '| `log` | Natural logarithm (log base *e*) |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: '| `sin` | Argument in radians |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| `cos` | Argument in radians |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| `tan` | Argument in radians |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| `asin` | Arcsine (inverse sine) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| `acos` | Arccosine |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| `atan` | Arctangent |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| `sinh` | sinh *x* = (*e^x* – *e^(–x))/2* |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| `cosh` | cosh *x* = (*e^x* + *e^(–x))/2* |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| `tanh` | tanh *x* = (*e^x* – *e^(–x)*)/(*e^x* + *e ^(–x)*) |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| `asinh` | Inverse hyperbolic sine |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| `acosh` | Inverse hyperbolic cosine |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| `atanh` | Inverse hyperbolic tangent |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: Haskell also provides the constant *π* in the Prelude.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is a trigonometric function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that trigonometric functions in Haskell expect an argument in radians.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s calculate cos ![Image](Images/006equ01.jpg).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The computer did not give us what we expect here; cos ![Image](Images/006equ01.jpg)
    = 0, not –0.5\. The reason is that function application in Haskell has higher
    *precedence* than division, so Haskell interprets what we typed as
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: rather than dividing *π* by 2 first and then taking the cosine. We can get what
    we want by supplying parentheses.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Is the result the computer gave ![Image](Images/006equ02.jpg) Not exactly. Here
    we see an example of an approximately computed result. My computer gave something
    times 10^(–17), which is as close to zero as the computer can get here. It’s good
    to remember that when doing numerical work, the computer (like your calculator)
    is not giving exact results most of the time. It is giving us approximate results.
    We must be vigilant in making sure that the results it gives are valuable to us
    by interpreting them correctly. After we discuss Haskell’s system of types in
    [Chapter 3](ch03.xhtml), we’ll say more about when we can and when we cannot expect
    the computer to produce exact results.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Haskell Prelude provides several *binary operators*, shown in [Table 1-2](ch01.xhtml#ch1tab2).
    Binary operators act on two inputs, or *arguments*, to produce a result. For example,
    the addition operator (+) is a binary operator because it takes two inputs and
    adds them. In computer science generally, an operator placed before its arguments
    is called a prefix operator, an operator placed after its arguments is called
    a postfix operator, and an operator placed between its arguments is called an
    infix operator. In Haskell, the term *operator* implies infix operator, although
    in [Chapter 6](ch06.xhtml) we’ll see how to turn an infix operator into a prefix
    operator.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 1-2](ch01.xhtml#ch1tab2) shows common Haskell operators, along with
    their precedence and associativity, which are explained next. The operators for
    addition, subtraction, multiplication, and division work pretty much as you would
    expect.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 1-2:** Precedence and Associativity for Common Operators'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Operator(s)** | **Precedence** | **Associativity** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| Composition | `.` | 9 | Right |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| Exponentiation | `^, ^^, **` | 8 | Right |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| Multiplication, division | `*, /` | 7 | Left |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| Addition, subtraction | `+, -` | 6 | Left |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| List operators | `:, ++` | 5 | Right |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| Equality, inequality | `==, /=` | 4 |  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| Comparison | `<, >, <=, >=` | 4 |  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| Logical AND | `&&` | 3 | Right |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| Logical OR | `&#124;&#124;` | 2 | Right |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| Application | `$` | 0 | Right |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: The table also shows three different operators for exponentiation. This proliferation
    is related to Haskell’s type system, which we’ll say more about in [Chapters 3](ch03.xhtml)
    and [8](ch08.xhtml).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The caret operator (`^`) can only handle nonnegative integer exponents. The
    expression `x^n` means the product of `n` factors of `x`. The double caret (`^^`)
    can handle any integer exponent. The `**` operator can handle any real exponent.
    For now, I recommend using `**` for exponentiation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The equality, inequality, and comparison operators can be used between numeric
    expressions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The result of a comparison is a Boolean expression, either `True` or `False`.
    [Chapter 5](ch05.xhtml) covers the list operators `:` and `++` from [Table 1-2](ch01.xhtml#ch1tab2).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Precedence and Associativity
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we saw earlier when we tried to take the cosine of *π*/2, function application
    takes precedence over infix operators. In addition, some operators take precedence
    over other operators. In the expression
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: the multiplication of 2 and 3 will occur before the addition with 1\. This is
    consistent with usual mathematical convention. To carry this out, binary operators
    in Haskell have a precedence associated with them that describes which operations
    should be carried out first. Binary operators have a precedence from 0 to 9\.
    An operation with a higher precedence number means that operation will be carried
    out first. For example, addition and subtraction have a precedence of 6 in Haskell,
    while the precedence of multiplication and division is 7 and the precedence of
    exponentiation is 8\. The OR operation `||` between Boolean values has a precedence
    of 2, and the AND operation `&&` has a precedence of 3.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The far-right column of [Table 1-2](ch01.xhtml#ch1tab2) lists the *associativity*
    of some operators. Consider the expression `8 - 3 - 2`. There are two ways in
    which this expression might be interpreted. The standard mathematical convention
    is that the expression is shorthand for (8 – 3) – 2, which evaluates to 3\. But
    another interpretation is that the expression is shorthand for 8 – (3 – 2), which
    evaluates to 7\. Clearly, it’s important for us to understand which of these two
    interpretations is correct for the original expression, and that is where associativity
    comes in. Looking at [Table 1-2](ch01.xhtml#ch1tab2), we see that subtraction
    is left associative. This means that the leftmost subtraction is carried out first,
    resulting in the first interpretation given earlier (resulting in 3, not 7). Precedence
    and associativity allow us to unambiguously determine which operators act first.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The purpose in learning the precedence and associativity rules is so we can
    avoid using parentheses as much as possible. Multiple levels of nested expressions
    make things hard to read. My advice is to never try to use more than two levels
    of nested parentheses. In addition to knowing the precedence and associativity
    rules, there are other ways to avoid the use of parentheses, such as defining
    a local variable. We’ll discuss these later.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add parentheses to the following expression to indicate the order in which
    Haskell’s precedence and associativity rules would evaluate the expression.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Function application takes precedence over all operators, so sin pi is the first
    thing calculated.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, exponentiation is the operator in the expression with the highest precedence
    in [Table 1-2](ch01.xhtml#ch1tab2). Exponentiation occurs twice, and because it
    is right associative, the rightmost exponentiation occurs next.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next is the left exponentiation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next is division. There are three divisions. The rightmost division is unproblematic,
    but we need to resolve the two divisions on the left of the expression by associativity
    rules. Division is left associative.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note we have inserted two sets of parentheses in the last step. One is for the
    rightmost division and one is for the leftmost division. Now we can put parentheses
    in for the final division, which occurs before the comparison.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The last operator to act is the comparison operator `>`. There is no need to
    put parentheses around the entire expression, so we are done. The fully parenthesized
    expression is
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The Application Operator
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The operator `$` in [Table 1-2](ch01.xhtml#ch1tab2) is called the function application
    operator. No operator is required to apply a function. Juxtaposition of two expressions
    means that the first is a function and the second is an argument, and that the
    function is to be applied to the argument.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The function application operator does nothing but apply the function on its
    left to the expression on its right.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The key to its use lies in the fact that it has a precedence of 0\. This means
    that the operator `$` changes application from the *first* thing to be done to
    the *last* thing to be done. In this way, the `$` serves as a kind of one-symbol
    parentheses. Instead of putting parentheses around `pi / 2` in the example above,
    we can use the single-symbol function application operator. Because it has right
    associativity, the function application operator is a frequent Haskell idiom that
    makes nested applications (``h `$` g `$` f x``) easier to read.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Functions with Two Arguments
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of the functions in [Table 1-1](ch01.xhtml#ch1tab1) take one real number
    as input and give a real number as output (assuming the input is in the domain
    of the function). There are also a couple of useful numeric functions that take
    two real numbers as input. These are listed in [Table 1-3](ch01.xhtml#ch1tab3).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 1-3:** Numeric Functions with Two Arguments'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Example** |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| `logBase` | `logBase 10 100 = 2` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| `atan2` | `atan2 1 0 = π`/2 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: 'Let’s look at these functions in action:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `logBase` function takes two arguments: the first is the base of the logarithm
    and the second is the number we wish to take the log of.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'The `atan2` function solves a problem you may have run into if you’ve tried
    to use the inverse tangent function to convert from Cartesian to polar coordinates.
    Consider the following equations for polar coordinates (*r, θ*) in terms of Cartesian
    coordinates (*x, y*):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/010equ01.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: Suppose that we’re trying to find the polar coordinates associated with the
    point ![Image](Images/010equ02a.jpg). The answer needs to be a point in the third
    quadrant because *x* and *y* are both negative. This means *θ* should be in the
    range *π* < *θ* < 3*π*/2 (or – *π* < *θ* < –*π*/2). But if we mechanically apply
    the formula above for *θ*, we’ll calculate ![Image](Images/010equ02.jpg), which
    our calculator or computer will tell us is *π*/3\. The problem is the domain of
    the inverse tangent function, and a solution is to use the `atan2` function instead
    of the `atan` function. The result of `atan2` *y x* will give the angle, in radians,
    in the correct quadrant.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Note how the two arguments are given to the functions `logBase` and `atan2`.
    In particular, there is no comma between the two argument values, as would be
    required in traditional mathematical notation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Numbers in Haskell
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A few details about numbers in Haskell are not intuitive for someone coming
    to the language for the first time. In this section, we point out some issues
    related to negative numbers, decimals, and exponential notation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Negative Numbers in Haskell
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you try the code
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'you will get an error, although the meaning of the expression seems clear enough:
    we want to multiply 5 by – 1\. The trouble here is that the minus sign acts as
    both a binary operator (as in the expression 3 – 2) and a unary operator (as in
    the expression – 2). Binary operators play an important role in Haskell, and the
    syntax of the language supports their use in a consistent, unified way. Unary
    operators in Haskell are much more of a special case; in fact, the minus sign
    is the only one. Because of decisions the Haskell designers made (see *[https://wiki.haskell.org/Unary_operator](https://wiki.haskell.org/Unary_operator)*),
    negative numbers are sometimes not recognized as readily as you might expect.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The solution is simply to enclose negative numbers in parentheses. For example,
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: evaluates to – 5.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Decimal Numbers in Haskell
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A number containing a decimal point must have digits (0 through 9) both before
    and after the decimal point. Thus, we must write `0.1` and not `.1`; instead of
    `5.`, we must write either `5.0` or `5` without a decimal point. The reason is
    that the dot character serves another role in the language (namely function composition,
    mentioned in the top line of [Table 1-2](ch01.xhtml#ch1tab2), which we’ll study
    further in [Chapter 2](ch02.xhtml)). The rule requiring digits before and after
    a decimal point helps the compiler distinguish the meaning of the dot character.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Exponential Notation
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use exponential notation to describe numbers in Haskell that are very
    big or very small. Here are a few examples:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mathematical notation** | **Haskell notation** |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| 3.00 × 10⁸ | 3.00e8 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| 6.63 × 10^(–34) | 6.63e-34 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: Haskell will also use exponential notation to show you numbers that turn out
    to be very big or very small.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression** |  | **Evaluates to** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| 8**8 | ⇝ | 1.6777216e7 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 8**8 | ⇝ | 1.6777216e7 |'
- en: '| 8**(-8) | ⇝ | 5.960464477539063e-8 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 8**(-8) | ⇝ | 5.960464477539063e-8 |'
- en: Approximate Calculation
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 近似计算
- en: Most of the calculations we will do are not exact calculations. When we ask
    the computer to find the square root of 5,
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的大多数计算都不是精确计算。当我们要求计算机找到5的平方根时，
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: it gives a very accurate result, but it is not an exact result. This is because
    the computer uses a finite number of bits to represent this number and cannot
    represent every conceivable number.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 它给出了一个非常精确的结果，但并不是一个精确的结果。这是因为计算机使用有限的位数来表示这个数字，不能表示每一个可以想象的数字。
- en: If you evaluate `sqrt 5 ^ 2` in GHCi, you may not get exactly 5.0 as a result.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在GHCi中计算`sqrt 5 ^ 2`，你可能得不到精确的5.0作为结果。
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The computer does not represent ![Image](Images/root5.jpg) exactly. We can
    even ask the following in GHCi:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机并没有精确表示![图片](Images/root5.jpg)。我们甚至可以在GHCi中询问如下：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: My computer gives `False` because of the approximate calculation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我的电脑给出`False`是因为近似计算。
- en: Another source of non-exactness in calculation comes from the computer’s use
    of a binary (base 2) internal representation of numbers. When I multiply 3 × 0.2,
    I don’t get exactly 0.6\. Why? The reason is that 0.2, which has a nice finite
    decimal (base 10) representation, has a repeating binary (base 2) representation.
    Just like the fraction 1/3 has an infinite repeating representation in base 10
    (0.333333\. . .), the fraction 1/5 has an infinite repeating representation in
    base 2\. [Table 1-4](ch01.xhtml#ch1tab4) shows representations of some simple
    fractions in decimal (base 10) and binary (base 2).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 计算中另一个导致不精确的来源是计算机使用二进制（基2）内部表示数字。当我将3乘以0.2时，我得不到精确的0.6。为什么？原因在于0.2虽然在十进制（基10）中有一个漂亮的有限小数表示，但它在二进制（基2）中有一个无限循环的表示。就像分数1/3在十进制中有一个无限循环的表示（0.333333...），分数1/5在二进制中也有一个无限循环的表示。[表格
    1-4](ch01.xhtml#ch1tab4)展示了一些简单分数在十进制（基10）和二进制（基2）中的表示。
- en: '**Table 1-4:** Representations of Numbers in Base 10 and Base 2'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 1-4：** 十进制和二进制表示的数字'
- en: '| **Number** | **Decimal** | **Binary** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **数字** | **十进制** | **二进制** |'
- en: '| --- | --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1/2 | 0.5 | 0.1 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 1/2 | 0.5 | 0.1 |'
- en: '| 1/3 | 0.333333... | 0.01010101... |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 1/3 | 0.333333... | 0.01010101... |'
- en: '| 1/4 | 0.25 | 0.01 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 1/4 | 0.25 | 0.01 |'
- en: '| 1/5 | 0.2 | 0.001100110011... |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 1/5 | 0.2 | 0.001100110011... |'
- en: The computer converts every number that we supply in decimal into its internal
    binary form and only keeps a finite number of digits (bits, really). Most of the
    time, we don’t need to be concerned with this, but it explains why some calculations
    that seem like they should be exactly calculable are not. One moral of this story
    is never to do equality checking of numbers when either number has been approximately
    calculated.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机将我们提供的每个数字从十进制转换为其内部的二进制形式，并只保留有限的位数（实际上是位）。大多数时候，我们不需要担心这个问题，但它解释了为什么一些看起来应该是精确可计算的计算并不是这样。这个故事的一个教训是：当某个数字经过近似计算时，永远不要进行相等性检查。
- en: Errors
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误
- en: People make mistakes. This is as it should be. When you enter something the
    computer does not understand, it will give you an error message. These messages
    can appear intimidating, but they are a great opportunity for learning, and it’s
    worthwhile to learn how to read them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 人们会犯错误。这是正常的。当你输入电脑无法理解的内容时，它会给你错误信息。这些信息可能看起来很吓人，但它们是一个很好的学习机会，值得学会如何阅读这些错误信息。
- en: We saw a “Precedence parsing error” in “Numbers in Haskell” when we tried to
    multiply 5 by – 1 without enclosing the – 1 in parentheses. Another error you’re
    bound to run into sooner or later is “No instance for Show.”
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试将5乘以–1而没有将–1用括号括起来时，我们在“《Haskell中的数字》”中看到一个“优先级解析错误”。另一个你迟早会遇到的错误是“No instance
    for Show”。
- en: There are some completely legitimate, well-defined expressions in Haskell that
    have no good way of being shown on the screen. Functions are the most common example.
    Because a function can accept a wide variety of inputs and produce a wide variety
    of outputs, there is in general no good way of displaying the “value” of a function.
    If you ask GHCi to tell you what the square root function “is,” it will complain
    that it knows no way to show it to you by saying that is has “No instance for
    Show.”
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell中有一些完全合法、定义明确的表达式，无法很好地显示在屏幕上。函数就是最常见的例子。因为一个函数可以接受多种输入并产生多种输出，一般来说，没有一种好的方法来显示函数的“值”。如果你请求GHCi告诉你平方根函数“是什么”，它会抱怨没有办法显示给你看，表示它“没有Show实例”。
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This message is not due to an error at all. The `sqrt` function is a completely
    legitimate Haskell expression. GHCi is merely saying that it knows no way to display
    it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Getting Help and Quitting
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To ask GHCi for help, enter `:help` (or `:h`). To leave GHCi, enter `:quit`
    (or `:q`).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Commands that start with a colon do not belong to the Haskell programming language
    proper but rather to the GHCi interactive compiler, and they control its operation.
    We will see more of these commands that start with colons later.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: More Information
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about the Haskell programming language (of which GHCi is a popular
    implementation), you can visit the website [https://www.haskell.org](https://www.haskell.org).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The *[haskell.org](http://haskell.org)* website has links to many online and
    paper sources for learning the language. Some particularly good ones are *Learn
    You a Haskell for Great Good!* [**[1](bib.xhtml#bib1)**] ([http://learnyouahaskell.com](http://learnyouahaskell.com))
    and *Real World Haskell* [**[2](bib.xhtml#bib2)**] ([http://book.realworldhaskell.org](http://book.realworldhaskell.org)).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we saw how to use GHCi as a calculator. GHCi comes equipped
    with an array of scientific functions and operators. The operators have precedence
    and associativity rules that determine the order in which they are carried out.
    These rules are useful to know and use so we can reduce the number of parentheses
    in our expressions. Function application has higher precedence than any operator.
    Negative numbers sometimes need parentheses around them to be parsed correctly.
    Numbers with a decimal point require a digit both before and after it. Many calculations
    the computer makes are approximate. Errors should be thought of as helpful hints;
    it is a useful attitude to be curious about errors. Patience and persistence in
    the face of errors are part of the path to understanding.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll show how to define our own functions and load them
    into GHCi.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 1.1.** Evaluate `sin 30` in GHCi. Why is it not equal to 0.5?'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 1.2.** Add parentheses to the following expressions to indicate
    the order in which Haskell’s precedence and associativity rules would evaluate
    the expressions:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: (a) `2 ^ 3 ^ 4`
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: (b) `2 / 3 / 4`
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: (c) `7 - 5 / 4`
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: (d) `log 49/7`
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 1.3.** Use GHCi to find log[2] 32.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 1.4.** Use the `atan2` function in GHCi to find the polar coordinates
    (*r,θ*) associated with Cartesian coordinates (*x, y*) = (–3,4).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 1.5.** Find a new example of a calculation in which the computer
    produces a result that is just a little bit different from the exact result.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 1.6.** Why is there no associativity listed for the equality, inequality,
    and comparison operators in [Table 1-2](ch01.xhtml#ch1tab2)? (Hint: write down
    the simplest expression you can think of that would require the associativity
    rules to resolve the precedence of comparison operators and try to make sense
    of it.)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
