- en: '1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '1'
- en: CALCULATING WITH HASKELL
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Haskell 进行计算
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common.jpg)'
- en: In this chapter, we’ll see how Haskell can be used as a scientific calculator.
    Multiple scientific functions are available by default in this calculator. In
    [Chapter 2](ch02.xhtml), we’ll write functions of our own that we can load and
    use. This chapter introduces some features and details of the language that will
    be useful later. Let’s start with a kinematics problem.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何将 Haskell 用作科学计算器。这个计算器默认提供了多个科学函数。在[第 2 章](ch02.xhtml)中，我们将编写我们自己的函数，这些函数可以加载并使用。本章介绍了一些后续章节中会有用的语言特性和细节。让我们从一个运动学问题开始。
- en: A Kinematics Problem
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个运动学问题
- en: Suppose we have a car on an air track. The car accelerates at a rate of 0.4
    m/s². At time *t* = 0, the car is stationary. How much time will it take for this
    car to travel 2 meters?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一辆车在气轨上。该车的加速度为 0.4 m/s²。在时间 *t* = 0 时，车辆是静止的。那么，这辆车行驶 2 米需要多长时间？
- en: The acceleration is constant, so we can use the position-time equation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于加速度是恒定的，因此我们可以使用位置-时间方程。
- en: '![Image](Images/003equ01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/003equ01.jpg)'
- en: Because the car starts at rest, we know *v*(0) = 0\. Let’s assume that the car
    starts at position zero, the origin, so that *x*(0) = 0\. We’re looking for the
    time *t* at which *x*(*t*) = 2 m. A little algebra tells us that
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因为车从静止开始，我们知道 *v*(0) = 0。假设这辆车从位置零（原点）开始，那么 *x*(0) = 0。我们正在寻找时间 *t*，使得 *x*(*t*)
    = 2 米。一点代数运算告诉我们：
- en: '![Image](Images/004equ01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/004equ01.jpg)'
- en: We could solve this using pen and paper, or we could use a calculator. In this
    chapter, we’ll be using Haskell as our calculator.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用笔和纸来解决这个问题，或者使用计算器。在本章中，我们将使用 Haskell 作为我们的计算器。
- en: In the next section, we’ll start a step-by-step explanation of how to use Haskell
    as a calculator. To close out this section, we’ll just show what you’d enter to
    calculate the time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将逐步解释如何使用 Haskell 作为计算器。为了结束这一部分，我们将展示如何输入内容来计算时间。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, it takes about 3.2 seconds for the car to travel 2 meters. Now,
    let’s look at how to start up the interactive Haskell “calculator.”
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，车行驶 2 米大约需要 3.2 秒。现在，让我们看看如何启动交互式 Haskell “计算器”。
- en: The Interactive Compiler
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交互式编译器
- en: The kinematics example gives us an excuse to introduce the interactive version
    of the Glasgow Haskell Compiler (GHC). The interactive version of GHC is called
    GHCi, and we can use it as a calculator. GHCi is included with the Glasgow Haskell
    Compiler, which is freely available at [*https://www.haskell.org*](https://www.haskell.org).
    The method of starting GHCi may depend on the operating system your computer uses.
    Typically, you can click an icon, choose GHCi from a menu, or enter `ghci` in
    a command line.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运动学例子为我们提供了一个机会，可以介绍格拉斯哥 Haskell 编译器（GHC）的交互式版本。GHC 的交互式版本叫做 GHCi，我们可以将其用作计算器。GHCi
    随格拉斯哥 Haskell 编译器一起提供，Haskell 编译器可以从[*https://www.haskell.org*](https://www.haskell.org)免费下载。启动
    GHCi 的方法可能取决于你计算机所使用的操作系统。通常，你可以点击一个图标，从菜单中选择 GHCi，或者在命令行中输入 `ghci`。
- en: When GHCi starts, we get a prompt at which we can enter expressions. The first
    prompt we get from GHCi is `Prelude>`. The Prelude is a collection of constants,
    functions, and operators available by default, and we can immediately use it to
    construct expressions. GHCi indicates that the Prelude has been loaded for us
    by including the name `Prelude` in the prompt. GHCi is now waiting for us to enter
    an expression. If you type `2/3`, followed by ENTER, GHCi will evaluate this expression
    and print a result.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当 GHCi 启动时，我们会看到一个提示符，在此处可以输入表达式。GHCi 给出的第一个提示符是 `Prelude>`。Prelude 是一个包含常量、函数和运算符的集合，默认情况下可以直接使用，我们可以立即使用它来构建表达式。GHCi
    通过在提示符中显示 `Prelude` 来指示 Prelude 已经为我们加载好了。现在，GHCi 正在等待我们输入表达式。如果你输入 `2/3`，然后按下
    ENTER，GHCi 将评估这个表达式并打印结果。
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the expression `2/3`, Haskell interprets the `2` and `3` as numbers and the
    `/` as a binary operator for division. GHCi performs the requested division and
    returns the result.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式 `2/3` 中，Haskell 将 `2` 和 `3` 解释为数字，而 `/` 被当作二元运算符表示除法。GHCi 执行所请求的除法并返回结果。
- en: Numeric Functions
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数值函数
- en: 'Haskell provides functions in the Prelude to perform many of the tasks you
    expect from calculators. Here’s an example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 在 Prelude 中提供了执行许多计算任务的函数。这里是一个例子：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is the natural logarithm function applied to the number 2\. The Haskell
    language does not need parentheses to apply a function. *Function application*
    (also known as *function use* or *function evaluation*) is such a basic idea in
    Haskell that the juxtaposition of two expressions is taken to mean that the first
    expression is a function and the second is an argument, and that the function
    is applied to the argument. Therefore, we can type the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用于数字 2 的自然对数函数。Haskell 语言在应用函数时不需要括号。*函数应用*（也叫 *函数使用* 或 *函数求值*）是 Haskell
    中一个非常基础的概念，即两个表达式并列时，表示第一个表达式是一个函数，第二个是该函数的参数，函数被应用到这个参数上。因此，我们可以输入如下代码：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Table 1-1](ch01.xhtml#ch1tab1) gives a list of numeric functions available
    in the Prelude.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-1](ch01.xhtml#ch1tab1) 列出了 Prelude 中可用的常见数值函数。'
- en: '**Table 1-1:** Some Common Numeric Functions'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-1：** 一些常见的数值函数'
- en: '| **Function** | **Description** |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `exp` | exp *x* = *e^x* |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `exp` | exp *x* = *e^x* |'
- en: '| `sqrt` | Square root |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `sqrt` | 平方根 |'
- en: '| `abs` | Absolute value |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `abs` | 绝对值 |'
- en: '| `log` | Natural logarithm (log base *e*) |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `log` | 自然对数（以 *e* 为底的对数） |'
- en: '| `sin` | Argument in radians |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `sin` | 弧度制下的正弦函数 |'
- en: '| `cos` | Argument in radians |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `cos` | 弧度制下的余弦函数 |'
- en: '| `tan` | Argument in radians |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `tan` | 弧度制下的正切函数 |'
- en: '| `asin` | Arcsine (inverse sine) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `asin` | 反正弦（反弧度） |'
- en: '| `acos` | Arccosine |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `acos` | 反余弦 |'
- en: '| `atan` | Arctangent |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `atan` | 反正切函数 |'
- en: '| `sinh` | sinh *x* = (*e^x* – *e^(–x))/2* |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `sinh` | sinh *x* = (*e^x* – *e^(–x))/2* |'
- en: '| `cosh` | cosh *x* = (*e^x* + *e^(–x))/2* |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `cosh` | cosh *x* = (*e^x* + *e^(–x))/2* |'
- en: '| `tanh` | tanh *x* = (*e^x* – *e^(–x)*)/(*e^x* + *e ^(–x)*) |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `tanh` | tanh *x* = (*e^x* – *e^(–x)*)/(*e^x* + *e^(–x)*) |'
- en: '| `asinh` | Inverse hyperbolic sine |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `asinh` | 反双曲正弦函数 |'
- en: '| `acosh` | Inverse hyperbolic cosine |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `acosh` | 反双曲余弦函数 |'
- en: '| `atanh` | Inverse hyperbolic tangent |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `atanh` | 反双曲正切函数 |'
- en: Haskell also provides the constant *π* in the Prelude.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 还在 Prelude 中提供了常数 *π*。
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is a trigonometric function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个三角函数：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that trigonometric functions in Haskell expect an argument in radians.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Haskell 中的三角函数需要以弧度作为参数。
- en: Now, let’s calculate cos ![Image](Images/006equ01.jpg).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来计算 cos ![Image](Images/006equ01.jpg)。
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The computer did not give us what we expect here; cos ![Image](Images/006equ01.jpg)
    = 0, not –0.5\. The reason is that function application in Haskell has higher
    *precedence* than division, so Haskell interprets what we typed as
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机没有给出我们预期的结果；cos ![Image](Images/006equ01.jpg) 应该是 0，而不是 –0.5。原因在于，Haskell
    中函数应用的优先级高于除法，因此 Haskell 将我们输入的内容解释为
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: rather than dividing *π* by 2 first and then taking the cosine. We can get what
    we want by supplying parentheses.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是先将 *π* 除以 2，再取余弦。我们可以通过加括号来得到我们想要的结果。
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Is the result the computer gave ![Image](Images/006equ02.jpg) Not exactly. Here
    we see an example of an approximately computed result. My computer gave something
    times 10^(–17), which is as close to zero as the computer can get here. It’s good
    to remember that when doing numerical work, the computer (like your calculator)
    is not giving exact results most of the time. It is giving us approximate results.
    We must be vigilant in making sure that the results it gives are valuable to us
    by interpreting them correctly. After we discuss Haskell’s system of types in
    [Chapter 3](ch03.xhtml), we’ll say more about when we can and when we cannot expect
    the computer to produce exact results.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机给出的结果是 ![Image](Images/006equ02.jpg)，对吗？不完全是。这里我们看到的是一个近似计算结果的示例。我的计算机给出的结果是某个值乘以
    10^(–17)，这几乎等于零，这是计算机所能达到的最接近零的值。值得记住的是，在进行数值计算时，计算机（就像你的计算器）大多数时候不会给出精确的结果，而是给出近似值。我们必须保持警惕，确保我们通过正确解释这些结果，得到有价值的信息。我们将在
    [第 3 章](ch03.xhtml) 讨论 Haskell 的类型系统后，进一步说明什么时候我们可以期待计算机给出精确的结果，什么时候不能。
- en: Operators
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运算符
- en: The Haskell Prelude provides several *binary operators*, shown in [Table 1-2](ch01.xhtml#ch1tab2).
    Binary operators act on two inputs, or *arguments*, to produce a result. For example,
    the addition operator (+) is a binary operator because it takes two inputs and
    adds them. In computer science generally, an operator placed before its arguments
    is called a prefix operator, an operator placed after its arguments is called
    a postfix operator, and an operator placed between its arguments is called an
    infix operator. In Haskell, the term *operator* implies infix operator, although
    in [Chapter 6](ch06.xhtml) we’ll see how to turn an infix operator into a prefix
    operator.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell Prelude 提供了几个 *二元运算符*，如 [表 1-2](ch01.xhtml#ch1tab2) 所示。二元运算符作用于两个输入，或
    *参数*，以产生一个结果。例如，加法运算符（+）是一个二元运算符，因为它接受两个输入并将它们相加。在计算机科学中，一般将放置在参数之前的运算符称为前缀运算符，放置在参数之后的运算符称为后缀运算符，而放置在参数之间的运算符称为中缀运算符。在
    Haskell 中，术语 *运算符* 暗示的是中缀运算符，尽管在 [第六章](ch06.xhtml)中我们将看到如何将中缀运算符转化为前缀运算符。
- en: '[Table 1-2](ch01.xhtml#ch1tab2) shows common Haskell operators, along with
    their precedence and associativity, which are explained next. The operators for
    addition, subtraction, multiplication, and division work pretty much as you would
    expect.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-2](ch01.xhtml#ch1tab2) 展示了常见的 Haskell 运算符，并列出了它们的优先级和结合性，接下来将对此进行解释。加法、减法、乘法和除法运算符的运作方式几乎和你预期的一样。'
- en: '**Table 1-2:** Precedence and Associativity for Common Operators'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-2：** 常见运算符的优先级与结合性'
- en: '| **Operation** | **Operator(s)** | **Precedence** | **Associativity** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **运算符** | **优先级** | **结合性** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Composition | `.` | 9 | Right |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 组合 | `.` | 9 | 右结合 |'
- en: '| Exponentiation | `^, ^^, **` | 8 | Right |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 指数运算 | `^, ^^, **` | 8 | 右结合 |'
- en: '| Multiplication, division | `*, /` | 7 | Left |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 乘法、除法 | `*, /` | 7 | 左结合 |'
- en: '| Addition, subtraction | `+, -` | 6 | Left |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 加法、减法 | `+, -` | 6 | 左结合 |'
- en: '| List operators | `:, ++` | 5 | Right |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 列表运算符 | `:, ++` | 5 | 右结合 |'
- en: '| Equality, inequality | `==, /=` | 4 |  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 等式、不等式 | `==, /=` | 4 |  |'
- en: '| Comparison | `<, >, <=, >=` | 4 |  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 比较 | `<, >, <=, >=` | 4 |  |'
- en: '| Logical AND | `&&` | 3 | Right |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑与 | `&&` | 3 | 右结合 |'
- en: '| Logical OR | `&#124;&#124;` | 2 | Right |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑或 | `&#124;&#124;` | 2 | 右结合 |'
- en: '| Application | `$` | 0 | Right |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 应用 | `$` | 0 | 右结合 |'
- en: The table also shows three different operators for exponentiation. This proliferation
    is related to Haskell’s type system, which we’ll say more about in [Chapters 3](ch03.xhtml)
    and [8](ch08.xhtml).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 表格还展示了三种不同的指数运算符。这些差异与 Haskell 的类型系统有关，更多内容将在 [第三章](ch03.xhtml) 和 [第八章](ch08.xhtml)中讨论。
- en: The caret operator (`^`) can only handle nonnegative integer exponents. The
    expression `x^n` means the product of `n` factors of `x`. The double caret (`^^`)
    can handle any integer exponent. The `**` operator can handle any real exponent.
    For now, I recommend using `**` for exponentiation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 照Caret运算符（`^`）仅能处理非负整数指数。表达式 `x^n` 表示 `x` 的 `n` 次方的乘积。双Caret运算符（`^^`）可以处理任何整数指数。`**`
    运算符可以处理任何实数指数。现在，我建议使用 `**` 进行指数运算。
- en: The equality, inequality, and comparison operators can be used between numeric
    expressions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 等式、不等式和比较运算符可以用于数字表达式之间。
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The result of a comparison is a Boolean expression, either `True` or `False`.
    [Chapter 5](ch05.xhtml) covers the list operators `:` and `++` from [Table 1-2](ch01.xhtml#ch1tab2).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 比较的结果是一个布尔表达式，可能是 `True` 或 `False`。[第五章](ch05.xhtml)涵盖了 [表 1-2](ch01.xhtml#ch1tab2)
    中的列表运算符 `:` 和 `++`。
- en: Precedence and Associativity
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 优先级与结合性
- en: As we saw earlier when we tried to take the cosine of *π*/2, function application
    takes precedence over infix operators. In addition, some operators take precedence
    over other operators. In the expression
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前看到的，当我们尝试计算 *π*/2 的余弦值时，函数应用的优先级高于中缀运算符。此外，一些运算符的优先级高于其他运算符。在表达式中：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: the multiplication of 2 and 3 will occur before the addition with 1\. This is
    consistent with usual mathematical convention. To carry this out, binary operators
    in Haskell have a precedence associated with them that describes which operations
    should be carried out first. Binary operators have a precedence from 0 to 9\.
    An operation with a higher precedence number means that operation will be carried
    out first. For example, addition and subtraction have a precedence of 6 in Haskell,
    while the precedence of multiplication and division is 7 and the precedence of
    exponentiation is 8\. The OR operation `||` between Boolean values has a precedence
    of 2, and the AND operation `&&` has a precedence of 3.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 2 和 3 的乘法会先于与 1 的加法进行。这与通常的数学惯例一致。为了实现这一点，Haskell 中的二元运算符有一个与之相关的优先级，用来描述哪些操作应该先执行。二元运算符的优先级范围从
    0 到 9。优先级数字越高，表示该操作会先执行。例如，加法和减法在 Haskell 中的优先级是 6，而乘法和除法的优先级是 7，指数运算的优先级是 8。布尔值之间的“或”操作
    `||` 的优先级是 2，而“与”操作 `&&` 的优先级是 3。
- en: The far-right column of [Table 1-2](ch01.xhtml#ch1tab2) lists the *associativity*
    of some operators. Consider the expression `8 - 3 - 2`. There are two ways in
    which this expression might be interpreted. The standard mathematical convention
    is that the expression is shorthand for (8 – 3) – 2, which evaluates to 3\. But
    another interpretation is that the expression is shorthand for 8 – (3 – 2), which
    evaluates to 7\. Clearly, it’s important for us to understand which of these two
    interpretations is correct for the original expression, and that is where associativity
    comes in. Looking at [Table 1-2](ch01.xhtml#ch1tab2), we see that subtraction
    is left associative. This means that the leftmost subtraction is carried out first,
    resulting in the first interpretation given earlier (resulting in 3, not 7). Precedence
    and associativity allow us to unambiguously determine which operators act first.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-2](ch01.xhtml#ch1tab2)的最右列列出了某些运算符的*结合性*。考虑表达式 `8 - 3 - 2`。这个表达式可能有两种解释方式。标准的数学惯例是，表达式是(8
    – 3) – 2的简写，计算结果为 3。但另一种解释是，表达式是 8 – (3 – 2)的简写，计算结果为 7。显然，我们必须理解原始表达式的正确解释是哪种，这就是结合性规则的作用。查看[表
    1-2](ch01.xhtml#ch1tab2)，我们可以看到减法是左结合的。这意味着最左边的减法最先执行，从而得出第一个解释（结果为 3，而不是 7）。优先级和结合性帮助我们明确地确定哪些运算符首先执行。'
- en: The purpose in learning the precedence and associativity rules is so we can
    avoid using parentheses as much as possible. Multiple levels of nested expressions
    make things hard to read. My advice is to never try to use more than two levels
    of nested parentheses. In addition to knowing the precedence and associativity
    rules, there are other ways to avoid the use of parentheses, such as defining
    a local variable. We’ll discuss these later.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 学习优先级和结合性规则的目的是让我们尽量避免使用括号。多个嵌套的表达式会让代码难以阅读。我的建议是，尽量不要尝试使用超过两层的嵌套括号。除了了解优先级和结合性规则外，还有其他避免使用括号的方法，比如定义局部变量。我们稍后会讨论这些方法。
- en: Let’s add parentheses to the following expression to indicate the order in which
    Haskell’s precedence and associativity rules would evaluate the expression.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为以下表达式添加括号，以表示 Haskell 中的优先级和结合性规则将如何计算该表达式。
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Function application takes precedence over all operators, so sin pi is the first
    thing calculated.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应用的优先级高于所有运算符，因此 `sin pi` 是第一个计算的部分。
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, exponentiation is the operator in the expression with the highest precedence
    in [Table 1-2](ch01.xhtml#ch1tab2). Exponentiation occurs twice, and because it
    is right associative, the rightmost exponentiation occurs next.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，指数运算是[表 1-2](ch01.xhtml#ch1tab2)中具有最高优先级的运算符。指数运算出现了两次，由于它是右结合的，因此最右边的指数运算最先执行。
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next is the left exponentiation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是左侧的指数运算。
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next is division. There are three divisions. The rightmost division is unproblematic,
    but we need to resolve the two divisions on the left of the expression by associativity
    rules. Division is left associative.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是除法。表达式中有三个除法。最右边的除法没有问题，但我们需要通过结合性规则解决表达式左边的两个除法。除法是左结合的。
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note we have inserted two sets of parentheses in the last step. One is for the
    rightmost division and one is for the leftmost division. Now we can put parentheses
    in for the final division, which occurs before the comparison.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在最后一步插入了两组括号。一个是用于最右边的除法，另一个是用于最左边的除法。现在我们可以为最终的除法加上括号，它发生在比较之前。
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The last operator to act is the comparison operator `>`. There is no need to
    put parentheses around the entire expression, so we are done. The fully parenthesized
    expression is
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后执行的运算符是比较运算符`>`。无需将整个表达式放在括号中，因此我们完成了。完全括号化的表达式是
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The Application Operator
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 应用运算符
- en: The operator `$` in [Table 1-2](ch01.xhtml#ch1tab2) is called the function application
    operator. No operator is required to apply a function. Juxtaposition of two expressions
    means that the first is a function and the second is an argument, and that the
    function is to be applied to the argument.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-2](ch01.xhtml#ch1tab2)中的运算符`$`称为函数应用运算符。应用函数时不需要运算符。两个表达式并列时，意味着第一个是一个函数，第二个是一个参数，且函数要应用于该参数。'
- en: The function application operator does nothing but apply the function on its
    left to the expression on its right.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应用运算符的作用只是将其左侧的函数应用于右侧的表达式。
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The key to its use lies in the fact that it has a precedence of 0\. This means
    that the operator `$` changes application from the *first* thing to be done to
    the *last* thing to be done. In this way, the `$` serves as a kind of one-symbol
    parentheses. Instead of putting parentheses around `pi / 2` in the example above,
    we can use the single-symbol function application operator. Because it has right
    associativity, the function application operator is a frequent Haskell idiom that
    makes nested applications (``h `$` g `$` f x``) easier to read.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用的关键在于它的优先级为0。这意味着运算符`$`改变了应用顺序，从*首先*要做的事情变成*最后*要做的事情。这样，`$`就充当了一种单符号括号的作用。我们不需要像上面的例子中那样将`pi
    / 2`放在括号中，而是可以使用这个单符号的函数应用运算符。因为它具有右结合性，函数应用运算符成为Haskell中的常用习惯用法，使得嵌套应用（``h `$`
    g `$` f x``）更容易阅读。
- en: Functions with Two Arguments
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有两个参数的函数
- en: All of the functions in [Table 1-1](ch01.xhtml#ch1tab1) take one real number
    as input and give a real number as output (assuming the input is in the domain
    of the function). There are also a couple of useful numeric functions that take
    two real numbers as input. These are listed in [Table 1-3](ch01.xhtml#ch1tab3).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1-1](ch01.xhtml#ch1tab1)中的所有函数都接受一个实数作为输入，并返回一个实数作为输出（假设输入在函数的定义域内）。还有一些有用的数值函数，它们接受两个实数作为输入。这些函数列在[表
    1-3](ch01.xhtml#ch1tab3)中。'
- en: '**Table 1-3:** Numeric Functions with Two Arguments'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-3：** 两个参数的数值函数'
- en: '| **Function** | **Example** |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **示例** |'
- en: '| --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `logBase` | `logBase 10 100 = 2` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `logBase` | `logBase 10 100 = 2` |'
- en: '| `atan2` | `atan2 1 0 = π`/2 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `atan2` | `atan2 1 0 = π`/2 |'
- en: 'Let’s look at these functions in action:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些函数的实际应用：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `logBase` function takes two arguments: the first is the base of the logarithm
    and the second is the number we wish to take the log of.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`logBase`函数接受两个参数：第一个是对数的底数，第二个是我们希望计算对数的数字。'
- en: 'The `atan2` function solves a problem you may have run into if you’ve tried
    to use the inverse tangent function to convert from Cartesian to polar coordinates.
    Consider the following equations for polar coordinates (*r, θ*) in terms of Cartesian
    coordinates (*x, y*):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`atan2`函数解决了一个问题，如果你曾尝试使用反正切函数从笛卡尔坐标转换到极坐标，你可能会遇到这个问题。考虑以下极坐标(*r, θ*)与笛卡尔坐标(*x,
    y*)之间的方程：'
- en: '![Image](Images/010equ01.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/010equ01.jpg)'
- en: Suppose that we’re trying to find the polar coordinates associated with the
    point ![Image](Images/010equ02a.jpg). The answer needs to be a point in the third
    quadrant because *x* and *y* are both negative. This means *θ* should be in the
    range *π* < *θ* < 3*π*/2 (or – *π* < *θ* < –*π*/2). But if we mechanically apply
    the formula above for *θ*, we’ll calculate ![Image](Images/010equ02.jpg), which
    our calculator or computer will tell us is *π*/3\. The problem is the domain of
    the inverse tangent function, and a solution is to use the `atan2` function instead
    of the `atan` function. The result of `atan2` *y x* will give the angle, in radians,
    in the correct quadrant.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在尝试找到与点 ![Image](Images/010equ02a.jpg) 相关的极坐标。答案需要是第三象限中的一个点，因为 *x* 和 *y*
    都是负数。这意味着 *θ* 应该在 *π* < *θ* < 3*π*/2（或 – *π* < *θ* < –*π*/2）范围内。但是，如果我们机械地使用上述公式计算
    *θ*，我们会得到 ![Image](Images/010equ02.jpg)，而我们的计算器或计算机会告诉我们它是 *π*/3\. 问题在于反正切函数的定义域，解决方案是使用
    `atan2` 函数，而不是 `atan` 函数。`atan2` *y x* 的结果将给出正确象限中的角度（以弧度表示）。
- en: Note how the two arguments are given to the functions `logBase` and `atan2`.
    In particular, there is no comma between the two argument values, as would be
    required in traditional mathematical notation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何将两个参数传递给 `logBase` 和 `atan2` 函数。特别是，两个参数值之间没有逗号，这在传统的数学表示法中是必须的。
- en: Numbers in Haskell
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Haskell 中的数字
- en: A few details about numbers in Haskell are not intuitive for someone coming
    to the language for the first time. In this section, we point out some issues
    related to negative numbers, decimals, and exponential notation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Haskell 中数字的一些细节对于第一次接触这门语言的人来说并不直观。在本节中，我们将指出一些与负数、小数和指数表示法相关的问题。
- en: Negative Numbers in Haskell
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Haskell 中的负数
- en: If you try the code
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试运行以下代码
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'you will get an error, although the meaning of the expression seems clear enough:
    we want to multiply 5 by – 1\. The trouble here is that the minus sign acts as
    both a binary operator (as in the expression 3 – 2) and a unary operator (as in
    the expression – 2). Binary operators play an important role in Haskell, and the
    syntax of the language supports their use in a consistent, unified way. Unary
    operators in Haskell are much more of a special case; in fact, the minus sign
    is the only one. Because of decisions the Haskell designers made (see *[https://wiki.haskell.org/Unary_operator](https://wiki.haskell.org/Unary_operator)*),
    negative numbers are sometimes not recognized as readily as you might expect.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你将遇到一个错误，尽管表达式的含义看起来足够清楚：我们想将 5 乘以 – 1\. 问题在于，减号既充当二元运算符（如表达式 3 – 2 中），也充当一元运算符（如表达式
    – 2 中）。二元运算符在 Haskell 中起着重要作用，且语言的语法支持以一致、统一的方式使用它们。而一元运算符在 Haskell 中则更多是特殊情况；事实上，减号是唯一的一个。一些
    Haskell 设计者的决策（参见 *[https://wiki.haskell.org/Unary_operator](https://wiki.haskell.org/Unary_operator)*）导致负数有时不会像你期望的那样被及时识别。
- en: The solution is simply to enclose negative numbers in parentheses. For example,
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是简单地将负数用括号括起来。例如，
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: evaluates to – 5.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 计算结果为 – 5。
- en: Decimal Numbers in Haskell
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Haskell 中的小数
- en: A number containing a decimal point must have digits (0 through 9) both before
    and after the decimal point. Thus, we must write `0.1` and not `.1`; instead of
    `5.`, we must write either `5.0` or `5` without a decimal point. The reason is
    that the dot character serves another role in the language (namely function composition,
    mentioned in the top line of [Table 1-2](ch01.xhtml#ch1tab2), which we’ll study
    further in [Chapter 2](ch02.xhtml)). The rule requiring digits before and after
    a decimal point helps the compiler distinguish the meaning of the dot character.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 包含小数点的数字必须在小数点前后都有数字（0 到 9）。因此，我们必须写成 `0.1`，而不能写成 `.1`；而不是 `5.`，我们必须写成 `5.0`
    或 `5`（不带小数点）。原因是点字符在语言中有另一个作用（即函数组合，这在 [表 1-2](ch01.xhtml#ch1tab2) 的顶部行中提到，我们将在
    [第二章](ch02.xhtml)中进一步学习）。这一规则要求小数点前后有数字，帮助编译器区分点字符的含义。
- en: Exponential Notation
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 指数表示法
- en: 'You can use exponential notation to describe numbers in Haskell that are very
    big or very small. Here are a few examples:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用指数表示法来描述在 Haskell 中非常大或非常小的数字。以下是一些例子：
- en: '| **Mathematical notation** | **Haskell notation** |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **数学表示法** | **Haskell 表示法** |'
- en: '| --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 3.00 × 10⁸ | 3.00e8 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 3.00 × 10⁸ | 3.00e8 |'
- en: '| 6.63 × 10^(–34) | 6.63e-34 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 6.63 × 10^(–34) | 6.63e-34 |'
- en: Haskell will also use exponential notation to show you numbers that turn out
    to be very big or very small.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 还会使用指数表示法来展示那些非常大或非常小的数字。
- en: '| **Expression** |  | **Evaluates to** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** |  | **计算结果** |'
- en: '| --- | --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 8**8 | ⇝ | 1.6777216e7 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 8**8 | ⇝ | 1.6777216e7 |'
- en: '| 8**(-8) | ⇝ | 5.960464477539063e-8 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 8**(-8) | ⇝ | 5.960464477539063e-8 |'
- en: Approximate Calculation
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 近似计算
- en: Most of the calculations we will do are not exact calculations. When we ask
    the computer to find the square root of 5,
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的大多数计算都不是精确计算。当我们要求计算机找到5的平方根时，
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: it gives a very accurate result, but it is not an exact result. This is because
    the computer uses a finite number of bits to represent this number and cannot
    represent every conceivable number.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 它给出了一个非常精确的结果，但并不是一个精确的结果。这是因为计算机使用有限的位数来表示这个数字，不能表示每一个可以想象的数字。
- en: If you evaluate `sqrt 5 ^ 2` in GHCi, you may not get exactly 5.0 as a result.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在GHCi中计算`sqrt 5 ^ 2`，你可能得不到精确的5.0作为结果。
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The computer does not represent ![Image](Images/root5.jpg) exactly. We can
    even ask the following in GHCi:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机并没有精确表示![图片](Images/root5.jpg)。我们甚至可以在GHCi中询问如下：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: My computer gives `False` because of the approximate calculation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我的电脑给出`False`是因为近似计算。
- en: Another source of non-exactness in calculation comes from the computer’s use
    of a binary (base 2) internal representation of numbers. When I multiply 3 × 0.2,
    I don’t get exactly 0.6\. Why? The reason is that 0.2, which has a nice finite
    decimal (base 10) representation, has a repeating binary (base 2) representation.
    Just like the fraction 1/3 has an infinite repeating representation in base 10
    (0.333333\. . .), the fraction 1/5 has an infinite repeating representation in
    base 2\. [Table 1-4](ch01.xhtml#ch1tab4) shows representations of some simple
    fractions in decimal (base 10) and binary (base 2).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 计算中另一个导致不精确的来源是计算机使用二进制（基2）内部表示数字。当我将3乘以0.2时，我得不到精确的0.6。为什么？原因在于0.2虽然在十进制（基10）中有一个漂亮的有限小数表示，但它在二进制（基2）中有一个无限循环的表示。就像分数1/3在十进制中有一个无限循环的表示（0.333333...），分数1/5在二进制中也有一个无限循环的表示。[表格
    1-4](ch01.xhtml#ch1tab4)展示了一些简单分数在十进制（基10）和二进制（基2）中的表示。
- en: '**Table 1-4:** Representations of Numbers in Base 10 and Base 2'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 1-4：** 十进制和二进制表示的数字'
- en: '| **Number** | **Decimal** | **Binary** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **数字** | **十进制** | **二进制** |'
- en: '| --- | --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1/2 | 0.5 | 0.1 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 1/2 | 0.5 | 0.1 |'
- en: '| 1/3 | 0.333333... | 0.01010101... |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 1/3 | 0.333333... | 0.01010101... |'
- en: '| 1/4 | 0.25 | 0.01 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 1/4 | 0.25 | 0.01 |'
- en: '| 1/5 | 0.2 | 0.001100110011... |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 1/5 | 0.2 | 0.001100110011... |'
- en: The computer converts every number that we supply in decimal into its internal
    binary form and only keeps a finite number of digits (bits, really). Most of the
    time, we don’t need to be concerned with this, but it explains why some calculations
    that seem like they should be exactly calculable are not. One moral of this story
    is never to do equality checking of numbers when either number has been approximately
    calculated.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机将我们提供的每个数字从十进制转换为其内部的二进制形式，并只保留有限的位数（实际上是位）。大多数时候，我们不需要担心这个问题，但它解释了为什么一些看起来应该是精确可计算的计算并不是这样。这个故事的一个教训是：当某个数字经过近似计算时，永远不要进行相等性检查。
- en: Errors
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误
- en: People make mistakes. This is as it should be. When you enter something the
    computer does not understand, it will give you an error message. These messages
    can appear intimidating, but they are a great opportunity for learning, and it’s
    worthwhile to learn how to read them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 人们会犯错误。这是正常的。当你输入电脑无法理解的内容时，它会给你错误信息。这些信息可能看起来很吓人，但它们是一个很好的学习机会，值得学会如何阅读这些错误信息。
- en: We saw a “Precedence parsing error” in “Numbers in Haskell” when we tried to
    multiply 5 by – 1 without enclosing the – 1 in parentheses. Another error you’re
    bound to run into sooner or later is “No instance for Show.”
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试将5乘以–1而没有将–1用括号括起来时，我们在“《Haskell中的数字》”中看到一个“优先级解析错误”。另一个你迟早会遇到的错误是“No instance
    for Show”。
- en: There are some completely legitimate, well-defined expressions in Haskell that
    have no good way of being shown on the screen. Functions are the most common example.
    Because a function can accept a wide variety of inputs and produce a wide variety
    of outputs, there is in general no good way of displaying the “value” of a function.
    If you ask GHCi to tell you what the square root function “is,” it will complain
    that it knows no way to show it to you by saying that is has “No instance for
    Show.”
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在Haskell中有一些完全合法、定义明确的表达式，无法很好地显示在屏幕上。函数就是最常见的例子。因为一个函数可以接受多种输入并产生多种输出，一般来说，没有一种好的方法来显示函数的“值”。如果你请求GHCi告诉你平方根函数“是什么”，它会抱怨没有办法显示给你看，表示它“没有Show实例”。
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This message is not due to an error at all. The `sqrt` function is a completely
    legitimate Haskell expression. GHCi is merely saying that it knows no way to display
    it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个消息完全不是错误。`sqrt` 函数是一个完全合法的 Haskell 表达式。GHCi 只是说它不知道如何显示它。
- en: Getting Help and Quitting
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取帮助和退出
- en: To ask GHCi for help, enter `:help` (or `:h`). To leave GHCi, enter `:quit`
    (or `:q`).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要请求 GHCi 的帮助，输入 `:help`（或 `:h`）。要退出 GHCi，输入 `:quit`（或 `:q`）。
- en: Commands that start with a colon do not belong to the Haskell programming language
    proper but rather to the GHCi interactive compiler, and they control its operation.
    We will see more of these commands that start with colons later.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以冒号开头的命令并不属于 Haskell 编程语言本身，而是属于 GHCi 交互式编译器，它们控制 GHCi 的操作。稍后我们会看到更多以冒号开头的命令。
- en: More Information
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多信息
- en: To learn more about the Haskell programming language (of which GHCi is a popular
    implementation), you can visit the website [https://www.haskell.org](https://www.haskell.org).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Haskell 编程语言（GHCi 是一个流行的实现）的信息，可以访问 [https://www.haskell.org](https://www.haskell.org)
    网站。
- en: The *[haskell.org](http://haskell.org)* website has links to many online and
    paper sources for learning the language. Some particularly good ones are *Learn
    You a Haskell for Great Good!* [**[1](bib.xhtml#bib1)**] ([http://learnyouahaskell.com](http://learnyouahaskell.com))
    and *Real World Haskell* [**[2](bib.xhtml#bib2)**] ([http://book.realworldhaskell.org](http://book.realworldhaskell.org)).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*[haskell.org](http://haskell.org)* 网站提供了许多学习语言的在线和纸质资源的链接。其中一些特别好的资源是 *Learn
    You a Haskell for Great Good!* [**[1](bib.xhtml#bib1)**] ([http://learnyouahaskell.com](http://learnyouahaskell.com))
    和 *Real World Haskell* [**[2](bib.xhtml#bib2)**] ([http://book.realworldhaskell.org](http://book.realworldhaskell.org))。'
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw how to use GHCi as a calculator. GHCi comes equipped
    with an array of scientific functions and operators. The operators have precedence
    and associativity rules that determine the order in which they are carried out.
    These rules are useful to know and use so we can reduce the number of parentheses
    in our expressions. Function application has higher precedence than any operator.
    Negative numbers sometimes need parentheses around them to be parsed correctly.
    Numbers with a decimal point require a digit both before and after it. Many calculations
    the computer makes are approximate. Errors should be thought of as helpful hints;
    it is a useful attitude to be curious about errors. Patience and persistence in
    the face of errors are part of the path to understanding.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将 GHCi 用作计算器。GHCi 配备了一系列科学函数和运算符。运算符有优先级和结合性规则，决定它们执行的顺序。了解并使用这些规则可以减少表达式中的括号数量。函数应用的优先级高于任何运算符。负数有时需要括号围住才能正确解析。带小数点的数字需要在小数点前后都有数字。计算机进行的许多计算都是近似的。错误应该被看作是有用的提示；保持对错误的好奇心是一种有益的态度。面对错误时的耐心和坚持是通向理解的道路的一部分。
- en: In the next chapter, we’ll show how to define our own functions and load them
    into GHCi.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将展示如何定义自己的函数并将其加载到 GHCi 中。
- en: Exercises
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: '**Exercise 1.1.** Evaluate `sin 30` in GHCi. Why is it not equal to 0.5?'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 1.1.** 在 GHCi 中计算 `sin 30`。为什么它不等于 0.5？'
- en: '**Exercise 1.2.** Add parentheses to the following expressions to indicate
    the order in which Haskell’s precedence and associativity rules would evaluate
    the expressions:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 1.2.** 在以下表达式中添加括号，表示 Haskell 的优先级和结合性规则将如何计算这些表达式：'
- en: (a) `2 ^ 3 ^ 4`
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: (a) `2 ^ 3 ^ 4`
- en: (b) `2 / 3 / 4`
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: (b) `2 / 3 / 4`
- en: (c) `7 - 5 / 4`
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: (c) `7 - 5 / 4`
- en: (d) `log 49/7`
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: (d) `log 49/7`
- en: '**Exercise 1.3.** Use GHCi to find log[2] 32.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 1.3.** 使用 GHCi 计算 log[2] 32。'
- en: '**Exercise 1.4.** Use the `atan2` function in GHCi to find the polar coordinates
    (*r,θ*) associated with Cartesian coordinates (*x, y*) = (–3,4).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 1.4.** 在 GHCi 中使用 `atan2` 函数计算与笛卡尔坐标 (*x, y*) = (–3,4) 相关的极坐标 (*r,θ*)。'
- en: '**Exercise 1.5.** Find a new example of a calculation in which the computer
    produces a result that is just a little bit different from the exact result.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 1.5.** 找一个新的计算示例，其中计算机得到的结果与精确结果有一点点不同。'
- en: '**Exercise 1.6.** Why is there no associativity listed for the equality, inequality,
    and comparison operators in [Table 1-2](ch01.xhtml#ch1tab2)? (Hint: write down
    the simplest expression you can think of that would require the associativity
    rules to resolve the precedence of comparison operators and try to make sense
    of it.)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 1.6.** 为什么在 [表 1-2](ch01.xhtml#ch1tab2) 中没有列出等号、不等号和比较操作符的结合性？（提示：写出你能想到的最简单的表达式，它需要结合性规则来解决比较操作符的优先级问题，然后尝试理解它。）'
