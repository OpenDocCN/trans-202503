- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">TESTING
    WITH THE JEST FRAMEWORK</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">使用JEST框架进行测试</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/Drop-image.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Drop-image.jpg)'
- en: Whenever you modify your code, you risk causing unforeseen side effects in another
    part of your application. As a result, guaranteeing the integrity and stability
    of a code base can be challenging. To do so, developers follow two main strategies.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你修改代码时，你都面临着可能在应用程序的另一部分引发无法预见的副作用的风险。因此，保证代码库的完整性和稳定性可能具有挑战性。为了做到这一点，开发者遵循两种主要策略。
- en: In the first, an architectural pattern, we split our code into small, self-contained
    React components. By nature, these components don’t interfere with one another.
    Hence, changing one shouldn’t lead to any side effects. In the second, we perform
    automated unit testing, which this chapter covers using the Jest framework.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种策略是一种架构模式，我们将代码拆分为小的、自包含的React组件。这些组件本质上不会相互干扰。因此，修改其中一个不应该导致任何副作用。第二种策略是进行自动化单元测试，本章将介绍如何使用Jest框架进行测试。
- en: In the following sections, we discuss the essentials of automated unit testing
    and the benefits of using it. You’ll learn how to write a test suite in Jest and
    use its reports to improve your code. You’ll also handle dependencies by using
    code doubles. Lastly, you’ll explore other kinds of tests you might want to run
    against your application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论自动化单元测试的基本要素以及使用它的好处。你将学习如何在Jest中编写测试套件，并利用其报告来改进代码。你还将通过使用代码替身来处理依赖关系。最后，你将探索可能想要在应用程序中运行的其他类型的测试。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Test-Driven Development and Unit Testing</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">测试驱动开发和单元测试</samp>
- en: Developers sometimes use the technique of *test-driven development (TDD)*, in
    which they write their automated tests before implementing the actual code to
    be tested. They first create a test to evaluate that the smallest possible unit
    of code would work as expected. Such a test is called a *unit test*. Next, they
    write the minimum amount of code necessary to pass the test.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者有时使用*测试驱动开发（TDD）*的技术，在实际编写待测试的代码之前先编写自动化测试。他们首先创建一个测试来评估最小的代码单元是否按预期工作。这样的测试被称为*单元测试*。接着，他们编写通过测试所需的最少量代码。
- en: This approach has distinct benefits. First, it lets you focus on your app’s
    requirements by explicitly defining the code’s functionality and edge cases. Therefore,
    you have a clear picture of its desired behavior, and you can identify unclear
    or missing specifications sooner rather than later. When you write tests after
    completing the functionality, they might reflect the behavior you implemented
    rather than the behavior you require.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有明显的好处。首先，它让你通过明确地定义代码的功能和边界情况，集中精力于应用程序的需求。因此，你能清楚地了解其期望的行为，并且能更早地发现不明确或缺失的规范。当你在完成功能后编写测试时，它们可能反映的是你实现的行为，而不是你所需要的行为。
- en: Second, limiting yourself to writing only necessary code prevents your functions
    from becoming too complex and splits your application into small, understandable
    sections. Testable code is maintainable code. In addition, the technique ensures
    that your tests cover a large portion of the app’s code, a metric called *code
    coverage*, and by running the tests frequently during development, you’ll instantly
    recognize bugs introduced by new lines of code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，限制自己只编写必要的代码可以防止你的函数变得过于复杂，并将你的应用程序拆分成小而易于理解的部分。可测试的代码是可维护的代码。此外，这种技术确保你的测试覆盖了应用程序代码的很大一部分，这个指标称为*代码覆盖率*，并且通过在开发过程中频繁运行测试，你会立刻识别出新代码行引入的错误。
- en: Depending on the situation, the *unit* targeted by a unit test can be a module,
    a function, or a line of code. The tests aim to verify that each unit works in
    isolation. The single lines inside each test function are the test *steps*, and
    the whole test function is called a test *case*. Test *suites* aggregate test
    cases into logical blocks. To be considered reproducible, the test must return
    the same results every time we run it. As we will explore in this chapter, this
    means that we must run the tests in a controlled environment with a defined dataset.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 根据情况，单元测试所针对的*单元*可以是一个模块、一个函数或一行代码。测试的目的是验证每个单元在独立情况下是否正常工作。每个测试函数中的单行代码就是测试的*步骤*，整个测试函数被称为一个测试*用例*。测试*套件*将多个测试用例聚合成逻辑块。要被认为是可重复的，测试必须在每次运行时返回相同的结果。正如我们在本章中将要探讨的那样，这意味着我们必须在一个控制的环境中运行测试，并使用定义好的数据集。
- en: Facebook developed the Jest testing framework in conjunction with React, but
    we can use it with any Node.js project. It has a defined syntax for setting up
    and writing tests. Its *test runner* executes these tests, automatically replaces
    any dependencies in our code, and generates a test-coverage report. Additional
    npm modules provide custom code for testing DOM or React components and, of course,
    adding TypeScript types.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook 与 React 一起开发了 Jest 测试框架，但我们可以在任何 Node.js 项目中使用它。它有一套定义好的语法来设置和编写测试。其*测试运行器*执行这些测试，自动替换代码中的任何依赖项，并生成测试覆盖率报告。额外的
    npm 模块提供了测试 DOM 或 React 组件的自定义代码，当然，也可以添加 TypeScript 类型。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Using Jest</samp>
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用 Jest</samp>
- en: 'To use Jest in a project, we must install its required packages, create a directory
    for all test files, and add an npm script that will run the tests. Execute the
    following in your Next.js application’s root directory to install the framework,
    as well as type definitions from DefinitelyTyped as development dependencies:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中使用 Jest，我们必须安装所需的包，创建一个用于存放所有测试文件的目录，并添加一个 npm 脚本来运行测试。在 Next.js 应用程序的根目录中执行以下命令，安装框架以及来自
    DefinitelyTyped 的类型定义作为开发依赖：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then create the directory in which to save your tests. Jest uses the *__tests__*
    folder by default, so make one in your root directory. Next, to add the npm script
    *test* to your project, open the *package.json* file and modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">scripts</samp>
    object to match the one in [Listing 8-1](chapter8.xhtml#Lis8-1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个目录来保存你的测试。Jest 默认使用 *__tests__* 文件夹，因此在根目录下创建一个。接下来，为了将 npm 脚本 *test*
    添加到你的项目中，打开 *package.json* 文件，并修改 <samp class="SANS_TheSansMonoCd_W5Regular_11">scripts</samp>
    对象，使其与 [清单 8-1](chapter8.xhtml#Lis8-1) 中的内容匹配。
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 8-1: The package.json file with the new text command'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-1：带有新文本命令的 package.json 文件
- en: 'Now we can run tests with the <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    test</samp> command. Usually, build servers execute this command by default during
    the build process. Lastly, to enable TypeScript support in Jest, add the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ts-jest</samp> transpiler:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp> 命令运行测试。通常，构建服务器在构建过程中默认会执行此命令。最后，为了在
    Jest 中启用 TypeScript 支持，请添加 <samp class="SANS_TheSansMonoCd_W5Regular_11">ts-jest</samp>
    转译器：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Also create a *jest.config* file to add TypeScript by running <samp class="SANS_TheSansMonoCd_W5Regular_11">npx
    ts-jest config:init</samp>.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 还要创建一个 *jest.config* 文件，通过运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">npx
    ts-jest config:init</samp> 来添加 TypeScript。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating an Example Module to Test</samp>
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">创建一个示例模块以进行测试</samp>
- en: Let’s write some example code to help us understand unit testing and TDD. Say
    we want to create a new module in our app, *./helpers/sum.ts*. It should export
    a function, <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>, that returns
    the sum of its parameters. To follow a TDD pattern, we’ll begin by creating test
    cases for this module.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些示例代码，帮助我们理解单元测试和 TDD。假设我们想在应用程序中创建一个新模块，*./helpers/sum.ts*。它应该导出一个名为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> 的函数，返回其参数的总和。为了遵循 TDD
    模式，我们将首先为这个模块创建测试用例。
- en: First we need to create the function that will run our tests. Create a file
    called *sum.test.ts* in the default test directory and add the code from [Listing
    8-2](chapter8.xhtml#Lis8-2).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个函数来运行我们的测试。在默认测试目录中创建一个名为 *sum.test.ts* 的文件，并添加 [清单 8-2](chapter8.xhtml#Lis8-2)
    中的代码。
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 8-2: The empty test suite'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-2：空测试套件
- en: We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function
    we’ll write later and use Jest’s <samp class="SANS_TheSansMonoCd_W5Regular_11">describe</samp>
    function to create an empty test suite. As soon as we run the (nonexistent) tests
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp>, Jest should
    complain that there is no file called *sum.ts* in the *helpers* directory. Create
    this file and folder now, at the root directory of your project. Within the file,
    write the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function shown
    in [Listing 8-3](chapter8.xhtml#Lis8-3).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入稍后将编写的 <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> 函数，并使用 Jest
    的 <samp class="SANS_TheSansMonoCd_W5Regular_11">describe</samp> 函数创建一个空的测试套件。当我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp> 运行（不存在的）测试时，Jest
    应该会抱怨在 *helpers* 目录中没有名为 *sum.ts* 的文件。现在在你的项目根目录中创建这个文件和文件夹。在文件中编写 [Listing 8-3](chapter8.xhtml#Lis8-3)
    所示的 <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> 函数。
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 8-3: The bare bones of the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    function'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-3：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    函数的基础骨架
- en: Now run the tests again with <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    test</samp>. Because the code just exports a placeholder <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function that returns nothing, the Jest test runner again complains. This time,
    it informs us that the test suite needs to contain at least one test.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp> 运行测试。由于代码只是导出了一个返回空值的占位符
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> 函数，Jest 测试运行器再次抱怨。这次，它通知我们测试套件需要包含至少一个测试。
- en: Let’s look at the anatomy of a test case and add a few test cases to the *sum.test.ts*
    file during the process.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一个测试用例的结构，并在这个过程中向 *sum.test.ts* 文件添加一些测试用例。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Anatomy of a Test Case</samp>
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">测试用例的结构</samp>
- en: 'There are two types of unit tests: state and interaction based. An *interaction-based*
    test case verifies that the code under evaluation invokes a specific function,
    whereas a *state-based* test case checks the code’s return value or resulting
    state. Both types follow the same three steps: arrange, act, and assert.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试有两种类型：基于状态的和基于交互的。*基于交互的*测试用例验证被评估的代码是否调用了特定的函数，而*基于状态的*测试用例检查代码的返回值或结果状态。两种类型都遵循相同的三个步骤：安排、执行和断言。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Arrange</samp>
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">安排</samp>
- en: To write independent and reproducible tests, we need to first *arrange* our
    environment by defining prerequisites, such as test data. If we need these prerequisites
    for only one particular test case, we define them at the beginning of the case.
    Otherwise, we set them globally for all tests in the test suite by using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">beforeEach</samp> hook, which gets executed
    before each test case, or the <samp class="SANS_TheSansMonoCd_W5Regular_11">beforeAll</samp>
    hook, which gets executed before all tests run.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写独立且可复现的测试，我们需要首先*安排*我们的环境，定义前提条件，例如测试数据。如果我们仅在一个特定的测试用例中需要这些前提条件，我们会在该用例开始时定义它们。否则，我们通过使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">beforeEach</samp> 钩子（该钩子在每个测试用例之前执行）或
    <samp class="SANS_TheSansMonoCd_W5Regular_11">beforeAll</samp> 钩子（该钩子在所有测试运行之前执行）将它们为所有测试在测试套件中设置为全局。
- en: If, for example, we had some reason to use the same global dataset for each
    test case and knew that our test steps would modify the dataset, we would need
    to re-create the dataset before each test. The <samp class="SANS_TheSansMonoCd_W5Regular_11">beforeEach</samp>
    hook would be the perfect place to do this. On the other hand, if the test cases
    merely consume the data, we’d need to define the datasets only once and so would
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">beforeAll</samp> hook.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，如果我们有某种原因需要在每个测试用例中使用相同的全局数据集，并且知道我们的测试步骤会修改数据集，那么我们需要在每次测试前重新创建数据集。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">beforeEach</samp> 钩子是执行此操作的最佳位置。另一方面，如果测试用例只是消费数据，那么我们只需要定义一次数据集，因此可以使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">beforeAll</samp> 钩子。
- en: Let’s define two test cases and create the input values for each. Our input
    parameters will be specific to each test case, so we’ll declare them inside the
    test cases instead of using a <samp class="SANS_TheSansMonoCd_W5Regular_11">beforeEach</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">beforeAll</samp> hook. Update
    the *sum.test.ts* file with the code from [Listing 8-4](chapter8.xhtml#Lis8-4).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义两个测试用例，并为每个用例创建输入值。我们的输入参数将针对每个测试用例进行特定定义，因此我们将在测试用例内部声明它们，而不是使用 `<samp
    class="SANS_TheSansMonoCd_W5Regular_11">beforeEach</samp>` 或 `<samp class="SANS_TheSansMonoCd_W5Regular_11">beforeAll</samp>`
    钩子。使用 [Listing 8-4](chapter8.xhtml#Lis8-4) 中的代码更新 *sum.test.ts* 文件。
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 8-4: The test suite containing the arrange steps'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-4：包含安排步骤的测试套件
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">describe</samp> function creates
    our test suite, which comprises two calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp>
    function, each of which is a test case. For both, the first argument is the description
    we see on the test runner’s report.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`<samp class="SANS_TheSansMonoCd_W5Regular_11">describe</samp>` 函数创建我们的测试套件，其中包含两次调用
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp>` 函数，每次调用都代表一个测试用例。对于这两个用例，第一个参数是我们在测试运行器报告中看到的描述信息。'
- en: Each of our tests evaluates the result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function. The first checks the addition feature, verifying that 2 plus 2 returns
    4\. The second test confirms that the function correctly returns negative values
    as well. It adds 4 to −8 and expects a result of −4.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的每个测试都评估 `<samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>` 函数的结果。第一个测试检查加法功能，验证
    2 加 2 是否返回 4。第二个测试确认该函数也能正确返回负值。它将 4 加到 −8，并期望返回 −4。
- en: You might want to check the return type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function, too. Usually, we would have done so, but because we’re using TypeScript,
    there is no need for this additional test case. Instead, we can define the return
    type in the function signature, and TSC will verify it for us.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想检查 `<samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>` 函数的返回类型。通常，我们会检查返回类型，但由于我们正在使用
    TypeScript，因此不需要这个额外的测试用例。相反，我们可以在函数签名中定义返回类型，TSC 会为我们验证它。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Act</samp>
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">操作</samp>
- en: As soon as the test runner executes a case, the test steps *act* on our behalf
    by invoking the code under test with the data for the particular test case. Each
    test case should test exactly one feature or variant of the system. This step
    is the line of code that invokes the function to execute. [Listing 8-5](chapter8.xhtml#Lis8-5)
    adds it to the test cases in *sum.test.ts*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试运行器执行某个用例，测试步骤就会通过使用特定测试用例的数据来调用待测试的代码，*代表*我们执行相应的操作。每个测试用例应测试系统的一个功能或变体。这个步骤是调用执行函数的代码行。[Listing
    8-5](chapter8.xhtml#Lis8-5) 将其添加到 *sum.test.ts* 的测试用例中。
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 8-5: The test suite containing the act steps'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-5：包含操作步骤的测试套件
- en: Our new lines call the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function and pass it the values we defined as parameters. We store the returned
    values in the <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> variable.
    In your editor, TSC should throw an error along the lines of <samp class="SANS_TheSansMonoCd_W5Regular_11">Expected
    0 arguments, but got 2</samp>. This is fine, as the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function is just an empty placeholder and doesn’t yet expect any parameters.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新代码行调用 `<samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>` 函数，并将我们定义的参数值传递给它。我们将返回的值存储在
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>` 变量中。在编辑器中，TSC 应该会抛出类似
    `<samp class="SANS_TheSansMonoCd_W5Regular_11">Expected 0 arguments, but got 2</samp>`
    的错误。这是正常的，因为 `<samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>` 函数只是一个空占位符，尚未期望任何参数。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assert</samp>
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">断言</samp>
- en: 'The final step of our test case is the *assertion* that the code fulfills the
    expectations we defined. We create this assertion with two parts: the Jest <samp
    class="SANS_TheSansMonoCd_W5Regular_11">expect</samp> function, used in conjunction
    with a *matcher* function from Jest’s *assert* library that defines the condition
    for which we are testing. Depending on the unit test’s category, this condition
    could be a specific return value, a state change, or the invocation of another
    function. Common matchers check whether a value is a number, a string, and so
    on. We can also use them to assert that a function returns true or false.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试用例的最后一步是*断言*，即代码满足我们定义的预期。我们通过两个部分创建这个断言：Jest的<samp class="SANS_TheSansMonoCd_W5Regular_11">expect</samp>函数，结合Jest的*assert*库中的*matcher*函数来定义我们测试的条件。根据单元测试的类别，这个条件可以是特定的返回值、状态变化或调用另一个函数。常见的匹配器检查值是否为数字、字符串等。我们还可以使用它们来断言一个函数返回true或false。
- en: Jest’s *assert* library provides us with a built-in set of basic matchers, and
    we can add additional ones from the npm repository. One of the most common assert
    packages is *testing-library/dom*, used to query the DOM for a particular node
    and assert its characteristics. For example, we can check for a class name or
    attribute or work with native DOM events. Another common assert package, *testing-library/react*,
    adds utilities for React and gives us access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">render</samp>
    function and React hooks in our asserts.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Jest的*assert*库为我们提供了一组内置的基本匹配器，我们可以从npm仓库中添加额外的匹配器。最常见的断言包之一是*testing-library/dom*，用于查询DOM中特定的节点并断言其特性。例如，我们可以检查类名或属性，或者与原生DOM事件一起使用。另一个常见的断言包是*testing-library/react*，它为React提供了实用工具，并让我们在断言中访问<samp
    class="SANS_TheSansMonoCd_W5Regular_11">render</samp>函数和React hooks。
- en: Because each test case evaluates one condition in one unit of code, we limit
    each test to one assert. In this way, as soon as the test run succeeds or fails
    and the test reporter generates the report, we can easily spot which test assumption
    failed. [Listing 8-6](chapter8.xhtml#Lis8-6) adds one assert per test case. Paste
    it into the *sum.test.ts* file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个测试用例评估一个代码单元中的一个条件，我们将每个测试限制为一个断言。这样，一旦测试运行成功或失败，测试报告生成时，我们可以轻松找出哪个测试假设失败了。[清单
    8-6](chapter8.xhtml#Lis8-6)为每个测试用例添加了一个断言。将它粘贴到*sum.test.ts*文件中。
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 8-6: The test suite containing the assert steps'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-6：包含断言步骤的测试套件
- en: These lines use the <samp class="SANS_TheSansMonoCd_W5Regular_11">expect</samp>
    assert function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">toBe</samp>
    matcher to compare the expected result to be the same as our expectation. Our
    test cases are now complete. Each follows the *arrange, act, assert* pattern and
    verifies one condition. [Appendix C](appendix-C.xhtml) lists additional matchers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行使用<samp class="SANS_TheSansMonoCd_W5Regular_11">expect</samp>断言函数，并与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">toBe</samp>匹配器一起使用，以将预期结果与我们的期望进行比较。我们的测试用例现在已经完成。每个测试用例都遵循*arrange,
    act, assert*模式，并验证一个条件。[附录C](appendix-C.xhtml)列出了其他匹配器。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Using TDD</samp>
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用 TDD</samp>
- en: 'Our test cases still haven’t executed, and if you run <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    test</samp>, the test runner should fail immediately. TSC checks the code and
    throws an error for the missing parameter declarations on the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试用例仍未执行，如果你运行<samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp>，测试运行器应该会立即失败。TSC检查代码，并且由于缺少对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>函数的参数声明，它会抛出错误：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It’s time to implement this <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function. Following the principles of TDD, we’ll incrementally add features to
    the code and run the test suites after each addition, continuing this process
    until all tests pass. First we’ll add those missing parameters. Replace the code
    in *sum.ts* with the contents of [Listing 8-7](chapter8.xhtml#Lis8-7).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候实现这个<samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>函数了。按照TDD的原则，我们将逐步向代码中添加功能，并在每次添加后运行测试套件，直到所有测试通过。首先，我们将添加那些缺失的参数。将*sum.ts*中的代码替换为[清单
    8-7](chapter8.xhtml#Lis8-7)的内容。
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 8-7: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    function with added parameters'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-7：带有附加参数的<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>函数
- en: 'We’ve added the parameters and typed them as numbers. Now we rerun the test
    cases and, as expected, they fail. The console output tells us that the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function doesn’t return the
    expected results. This shouldn’t surprise us, because our <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function doesn’t return anything at all:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了参数并将其类型指定为数字。现在我们重新运行测试用例，正如预期的那样，它们失败了。控制台输出告诉我们 <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    函数没有返回预期的结果。这不应令我们感到惊讶，因为我们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    函数根本没有返回任何值：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code in [Listing 8-8](chapter8.xhtml#Lis8-8) adds this functionality to
    the *sum.ts* file. We type the function’s return type as a number and add the
    two parameters.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-8](chapter8.xhtml#Lis8-8) 中的代码将此功能添加到 *sum.ts* 文件中。我们将函数的返回类型指定为数字，并添加了两个参数。'
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 8-8: The complete <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    function'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-8：完整的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    函数
- en: 'If we rerun <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp>,
    Jest should report that all test cases succeed:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp>，Jest
    应该报告所有测试用例都通过了：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, everything worked.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一切正常。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Refactoring Code</samp>
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">重构代码</samp>
- en: Unit tests are particularly useful when we need to refactor our code. As an
    example, let’s rewrite the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function so that, instead of two parameters, it accepts an array of numbers. The
    function should return the sum of all array items.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试在我们需要重构代码时特别有用。例如，我们可以重写 <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    函数，使其接受一个数字数组，而不是两个参数。该函数应返回数组中所有项的和。
- en: We begin by rewriting our existing test cases into a more compact form and then
    expanding the test suite to verify the new behavior. Replace the code in the *sum.test.file*
    with [Listing 8-9](chapter8.xhtml#Lis8-9).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将现有的测试用例重写为更简洁的形式，然后扩展测试套件以验证新行为。将 *sum.test.file* 中的代码替换为 [列表 8-9](chapter8.xhtml#Lis8-9)。
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 8-9: The test suite for the refactored <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    function'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-9：重构后的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    函数的测试套件
- en: Notice that we rewrote the test cases in a more compact form. Explicitly splitting
    the arrange, act, and assert statements across multiple lines may be easier to
    read, but for simple test cases, such as those in [Listing 8-9](chapter8.xhtml#Lis8-9),
    we often write them in one line. We’ve changed their functionality to accommodate
    the new requirements. Instead of accepting two values, our <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function receives an array with numbers. Again, the TSC instantly notifies us
    of the mismatching parameters between the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function in the test suite and the actual implementation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将测试用例重写为更简洁的形式。虽然将 arrange、act 和 assert 语句拆分到多行可能更易于阅读，但对于像 [列表 8-9](chapter8.xhtml#Lis8-9)
    中的简单测试用例，我们通常会将其写成一行。我们已将其功能进行了更改，以适应新需求。我们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    函数不再接受两个值，而是接受一个包含数字的数组。再次提醒，TSC 会立即通知我们测试套件中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    函数与实际实现之间的参数不匹配。
- en: Once we’ve written our tests, we can rewrite our code. [Listing 8-10](chapter8.xhtml#Lis8-10)
    shows the code for the *helpers/sum.ts* file. Here the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function now accepts an array of numbers as a parameter and returns a number.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编写了测试用例，我们就可以重写代码了。[列表 8-10](chapter8.xhtml#Lis8-10) 展示了 *helpers/sum.ts*
    文件的代码。在这里，<samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> 函数现在接受一个数字数组作为参数，并返回一个数字。
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 8-10: The rewritten <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    function in the helpers/sum.ts file'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-10：在 helpers/sum.ts 文件中重写的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    函数
- en: 'We changed the parameter to an array of numbers. This fixes the TypeScript
    error caused by the test suite in [Listing 8-9](chapter8.xhtml#Lis8-9). But because
    we’re following TDD and making only one functional change at a time, we keep the
    function’s original behavior of adding two values. As expected, one of the test
    cases fails when we run the automated tests with <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    test</samp>:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将参数更改为一个数字数组。这修复了由 [列表 8-9](chapter8.xhtml#Lis8-9) 中的测试套件引起的 TypeScript 错误。但因为我们遵循
    TDD 并且每次只做一个功能性更改，我们保持了函数原有的行为，即添加两个值。正如预期的那样，当我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    test</samp> 运行自动化测试时，测试用例中的一个会失败：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The third test case, which tests the new requirement, is the one that failed.
    Not only did we expect this result, but we also wanted the test to fail; this
    way, we know that the tests themselves are working. If they succeeded before we
    implemented the corresponding functionality, the test cases would be faulty.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 测试新需求的第三个测试用例失败了。我们不仅预期到这个结果，而且希望测试失败；这样我们就能确认测试本身有效。如果在我们实现相应功能之前测试就通过了，那么测试用例就是错误的。
- en: With the failing test as the baseline, it is now time to refactor the code to
    accommodate the new requirement. Paste the code in [Listing 8-11](chapter8.xhtml#Lis8-11)
    into the *sum.ts* file. Here we refactor the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function to return the sum of all array values.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以失败的测试作为基准，现在是时候重构代码以适应新的需求了。将 [列表 8-11](chapter8.xhtml#Lis8-11) 中的代码粘贴到 *sum.ts*
    文件中。在这里，我们重构了 <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> 函数，使其返回所有数组值的和。
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 8-11: The corrected <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    function with <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">array.reduce</samp>'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-11：修正后的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    函数，使用 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">array.reduce</samp>
- en: 'Although we could loop through the array with a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, we use modern JavaScript’s <samp class="SANS_TheSansMonoCd_W5Regular_11">array.reduce</samp>
    function. This native array function runs a callback function on each array element.
    The callback receives the return value of the previous iteration and the current
    array item as parameters: exactly what we need to calculate the sum.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环遍历数组，但我们使用现代
    JavaScript 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">array.reduce</samp>
    函数。这个原生数组函数会对每个数组元素运行一个回调函数。回调函数接收上一次迭代的返回值和当前数组项作为参数：这正是我们计算和所需的。
- en: 'Run all the test cases in our test suite to verify that they are working as
    expected:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试套件中的所有测试用例，验证它们是否按预期工作：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The test runner should show that the code passed every test.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行器应显示代码通过了所有测试。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Evaluating Test Coverage</samp>
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">评估测试覆盖率</samp>
- en: To measure exactly which lines of code our test suites cover, Jest generates
    a test-coverage report. The higher the percentage of code our tests assess, the
    more thorough they are, and the more confident we can be about the application’s
    quality and maintainability. As a general rule of thumb, you should aim for code
    coverage of 90 percent or above, with a high coverage for the most critical part
    of your code. Of course, the test cases should add value by testing the code’s
    functions; adding tests just to increase the test coverage is not the goal we
    are aiming for. But as soon as you’ve tested your code base thoroughly, you can
    refactor existing features and implement new ones without worrying about introducing
    regression bugs. A high code coverage verifies that changes have no hidden side
    effects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准确测量我们的测试套件覆盖了哪些代码行，Jest 会生成测试覆盖率报告。我们的测试评估的代码比例越高，测试就越全面，关于应用程序质量和可维护性的信心也越强。作为一般经验法则，您应该争取达到
    90% 或以上的代码覆盖率，并且在最关键的部分有较高的覆盖率。当然，测试用例应该通过测试代码的功能来增加价值；单纯为了增加测试覆盖率而添加测试并非我们的目标。但一旦彻底测试了代码库，您就可以重构现有功能并实现新功能，而不必担心引入回归性错误。高代码覆盖率验证了更改没有隐藏的副作用。
- en: Modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp> script
    in the *package.json* file by adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">--coverage</samp>
    flag to it, as shown in [Listing 8-12](chapter8.xhtml#Lis8-12).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 *package.json* 文件中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp>
    脚本，添加 <samp class="SANS_TheSansMonoCd_W5Regular_11">--coverage</samp> 标志，如 [列表
    8-12](chapter8.xhtml#Lis8-12) 所示。
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 8-12: Enabling Jest’s test-coverage feature in the package.json file'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-12：在 package.json 文件中启用 Jest 的测试覆盖率功能
- en: 'If we rerun the test suite, Jest should show what percentage of the code our
    unit tests cover. It generates a code-coverage report and stores it in the *coverage*
    folder. Compare your output with the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新运行测试套件，Jest 应该会显示我们的单元测试覆盖了代码的百分比。它会生成一个代码覆盖率报告并将其存储在*coverage*文件夹中。请将你的输出与以下内容进行比较：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The report shows the coverage broken down by statements, branches, functions,
    and lines. We see that our simple <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function has a code coverage of 100 percent across all categories. Hence, we know
    that we’ve left no code untested and can trust that the test cases reflect the
    function’s quality.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 报告显示了按语句、分支、函数和行分解的覆盖率。我们看到我们简单的 <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    函数在所有类别中的代码覆盖率为 100%。因此，我们知道我们没有留下任何未测试的代码，并且可以信任测试用例反映了函数的质量。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Replacing Dependencies with Fakes, Stubs,
    and Mocks</samp>
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">用伪造、存根和模拟替代依赖关系</samp>
- en: We mentioned that our tests should run in isolation, without depending on external
    code. You might have wondered how to handle imported modules; after all, as soon
    as you import code, you add a dependency to the unit under evaluation. Those third-party
    modules might not work as expected, and we don’t want our code to depend on the
    assumption that they all operate correctly. Consequently, you should provide a
    set of test cases for each imported module to verify its functionality. They,
    too, are units to test.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过，我们的测试应该在独立的环境中运行，而不依赖于外部代码。你可能会想，如何处理导入的模块？毕竟，一旦你导入代码，就会为被评估的单元添加一个依赖关系。这些第三方模块可能无法按预期工作，我们不希望我们的代码依赖于假设它们都能正确运行。因此，你应该为每个导入的模块提供一组测试用例来验证其功能。它们也是需要测试的单元。
- en: Separately, instead of importing modules into our other code units, we need
    to replace them with *test doubles* that return a defined set of static data tailored
    to the test. Test doubles replace an object or a function, effectively removing
    a dependency. Because they return a defined dataset, their response is known and
    predictable. You can compare them to stunt doubles in movies.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 单独地，我们需要用*测试替身*替换我们其他代码单元中的模块，而不是导入它们，测试替身返回一组针对测试的静态数据。测试替身替代了一个对象或函数，有效地消除了依赖关系。由于它们返回的是已定义的数据集，因此它们的响应是已知的且可预测的。你可以把它们比作电影中的替身演员。
- en: 'Besides replacing an object or function, test doubles have a second important
    purpose: they record their calls and let us spy on them. We can thus use them
    to test whether the test double has been called at all, how often, and which arguments
    it received. There are three main types of test doubles: fakes, stubs, and mocks.
    However, you’ll sometimes hear the term *mock* to refer to all three.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了替代对象或函数外，测试替身还有第二个重要目的：它们记录它们的调用并允许我们对其进行监控。因此，我们可以用它们来测试测试替身是否被调用过，调用了多少次，以及接收到哪些参数。测试替身有三种主要类型：伪造、存根和模拟。然而，你有时会听到*模拟*一词用于指代这三者。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Module
    with Dependencies</samp>
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建一个带有依赖关系的模块</samp>
- en: To practice using test doubles in our <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function, we’ll create a new function that calculates a specified number of values
    in the Fibonacci sequence. The *Fibonacci sequence* is a pattern in which each
    subsequent number is the sum of the previous two, a simple use case for a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> module.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的 <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> 函数中练习使用测试替身，我们将创建一个新函数，计算斐波那契数列中的指定数量值。*斐波那契数列*是一个模式，其中每个后续数字是前两个数字的和，这是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> 模块的一个简单用例。
- en: All developers must figure out how fine-grained their test cases need to be.
    The Fibonacci sequence is a good example, because trying to test every possible
    number submitted to the function would be useless, as the sequence has no end.
    Instead, we want to verify that the function properly handles edge cases and that
    its underlying functionality works. For instance, we’ll check how it handles an
    input with a length of 0; in that case, the function should return an empty string.
    Then we’ll test how it calculates a Fibonacci sequence of any length longer than
    3\. Create the *fibonacci.test.ts* test suite inside the *__tests__* folder and
    then add the code from [Listing 8-13](chapter8.xhtml#Lis8-13) to it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所有开发者都必须确定他们的测试用例需要多么精细。斐波那契数列就是一个很好的例子，因为尝试测试提交给函数的每一个可能的数字是没有意义的，因为数列是无限的。相反，我们希望验证函数是否正确处理边界情况，并且其底层功能是否正常工作。例如，我们将检查它如何处理长度为
    0 的输入；在这种情况下，函数应该返回一个空字符串。然后，我们将测试它如何计算任意长度大于 3 的斐波那契数列。在 *__tests__* 文件夹中创建 *fibonacci.test.ts*
    测试套件，然后将[示例 8-13](chapter8.xhtml#Lis8-13)中的代码添加进去。
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 8-13: The test suite for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fibonacci</samp>
    function'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-13：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fibonacci</samp>
    函数的测试套件
- en: 'We define two test cases: one that checks for a length input of 0 and another
    that calculates a Fibonacci sequence of five numbers. Both tests follow the *arrange,
    act, assert* pattern in the compact variant we used earlier.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个测试用例：一个检查长度为 0 的输入，另一个计算一个包含五个数字的斐波那契数列。两个测试都遵循我们之前使用的紧凑版 *arrange, act,
    assert* 模式。
- en: After we’ve created the test cases, we can move on to writing the Fibonacci
    function code. Create the *fibonacci.ts* file in the *helpers* folder, next to
    the *sum.ts* file, and add the code from [Listing 8-14](chapter8.xhtml#Lis8-14)
    to it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完测试用例后，我们可以继续编写斐波那契函数的代码。在 *helpers* 文件夹中创建 *fibonacci.ts* 文件，放在 *sum.ts*
    文件旁边，然后将[示例 8-14](chapter8.xhtml#Lis8-14)中的代码添加进去。
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 8-14: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fibonacci</samp>
    function'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-14：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fibonacci</samp>
    函数
- en: We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function
    from the module we created earlier in this chapter. It is now a dependency that
    we’ll need to replace with a test double later. Then we implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">fibonacci</samp>
    function, which accepts the length of the sequence to calculate and returns a
    string. We store the current sequence in an array so that we have a simple way
    to access the two previous values needed to calculate the next one. Notice that
    the first number in the sequence is always <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    and the second is always <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
    Finally, we return a string with the requested number of values. If you save this
    code and rerun the test suites, both *sum.test.js* and *fibonacci.test.ts* should
    pass successfully.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从本章早些时候创建的模块中导入了 <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    函数。它现在是一个依赖项，稍后我们需要将其替换为测试双重对象。接着，我们实现了 <samp class="SANS_TheSansMonoCd_W5Regular_11">fibonacci</samp>
    函数，该函数接受要计算的数列长度并返回一个字符串。我们将当前的数列存储在一个数组中，以便能够简单地访问计算下一个数值所需的两个前一个值。请注意，数列中的第一个数字始终是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，第二个是 <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。最后，我们返回一个包含所请求数量值的字符串。如果你保存这段代码并重新运行测试套件，*sum.test.js*
    和 *fibonacci.test.ts* 都应该成功通过。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Doubles
    Folder</samp>
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建一个 Doubles 文件夹</samp>
- en: 'Because we import the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function in the Fibonacci module, our code has an external dependency. This is
    problematic for testing purposes: if the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function breaks, the test for the Fibonacci sequence will fail as well, even if
    the logic of the Fibonacci implementation is correct.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在斐波那契模块中导入了 <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> 函数，所以我们的代码有一个外部依赖。这对测试来说是个问题：如果
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> 函数坏了，斐波那契数列的测试也会失败，即使斐波那契实现的逻辑是正确的。
- en: To decouple the test from the dependency, we’ll replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function in the *fibonacci.ts* file with a test double. Jest can replace any module
    that has an identically named file saved in a *__mocks__* subdirectory adjacent
    to the test file during the test run. Create such a folder in the *helpers* folder
    next to the test file and place a *sum.ts* file inside it. Leave the file empty
    for now.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将测试与依赖项解耦，我们将用一个测试替代品替换*fibonacci.ts*文件中的<samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>函数。Jest可以在测试运行期间替换任何模块，只要该模块在与测试文件相邻的*__mocks__*子目录中有一个同名的文件。在测试文件旁的*helpers*文件夹中创建这样的文件夹，并在其中放置一个*sum.ts*文件。现在先将文件留空。
- en: To enable the test double, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">jest.mock</samp>
    function, passing it the path to the original module saved in the test file. In
    [Listing 8-15](chapter8.xhtml#Lis8-15), we add this call to *fibonacci.test.ts*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用测试替代品，我们调用<samp class="SANS_TheSansMonoCd_W5Regular_11">jest.mock</samp>函数，并传递测试文件中保存的原始模块的路径。在[Listing
    8-15](chapter8.xhtml#Lis8-15)中，我们将此调用添加到*fibonacci.test.ts*文件中。
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 8-15: The test suite for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fibonacci</samp>
    function with the test double'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-15：带有测试替代品的<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fibonacci</samp>函数的测试套件
- en: This new line replaces the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    module with the test double. Now let’s create all three basic types of test doubles,
    adding their code to the file in the *__mocks__* folder.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码替换了<samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>模块为测试替代品。现在我们来创建三种基本类型的测试替代品，将它们的代码添加到*__mocks__*文件夹中的文件中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using a Stub</samp>
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用存根</samp>
- en: Stubs are merely objects that return some predefined data. This makes them very
    simple to implement but limited in use; often, returning the same data isn’t enough
    to mimic a dependency’s original actions. [Listing 8-16](chapter8.xhtml#Lis8-16)
    shows a stub implementation for the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function’s test double. Paste the code into the *sum.ts* file inside the *__mocks__*
    folder.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 存根仅仅是返回一些预定义数据的对象。这使得它们非常容易实现，但使用上有所限制；通常，返回相同的数据不足以模拟依赖项的原始行为。[Listing 8-16](chapter8.xhtml#Lis8-16)展示了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>函数测试替代品的存根实现。将代码粘贴到*__mocks__*文件夹中的*sum.ts*文件中。
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 8-16: A stub for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    function'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-16：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>函数的存根
- en: The stubbed function has the same signature as the original function. It accepts
    the same arguments, an array of numbers, and returns a string. Unlike the original,
    however, this test double always returns the same number, 999, regardless of the
    data it received.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 存根函数具有与原始函数相同的签名。它接受相同的参数——一个数字数组，并返回一个字符串。然而，与原始函数不同的是，这个测试替代品总是返回相同的数字999，无论它接收到的数据是什么。
- en: To successfully run the test suites with this stub function, we’d need to adjust
    our expectations about what our code will do. Instead of returning five numbers
    in the Fibonacci sequence, it would produce the string <samp class="SANS_TheSansMonoCd_W5Regular_11">999,
    999, 999, 999, 999</samp>. If we see such a string, we know that the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function was called five times. Experiment with the stub, modifying the test suite’s
    expectations to match it. Then restore the matchers to those shown in [Listing
    8-15](chapter8.xhtml#Lis8-15) so that you can use them for the upcoming tests.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功运行带有此存根函数的测试套件，我们需要调整对代码行为的预期。它不会返回斐波那契数列中的五个数字，而是会生成字符串<samp class="SANS_TheSansMonoCd_W5Regular_11">999,
    999, 999, 999, 999</samp>。如果我们看到这样的字符串，我们就知道<samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>函数被调用了五次。试验这个存根，修改测试套件的预期，以匹配它。然后将匹配器恢复到[Listing
    8-15](chapter8.xhtml#Lis8-15)中显示的状态，这样你就可以在接下来的测试中使用它们。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using a Fake</samp>
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用伪造</samp>
- en: Fakes are the most complex kind of test double. They are working implementations
    of the original functionality, but unlike the real implementation, they provide
    only the functionality necessary for the unit test. Their implementation is simplified
    and often doesn’t cater to edge cases.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 伪造是最复杂的测试替代品类型。它们是原始功能的工作实现，但与真实实现不同，伪造只提供单元测试所需的功能。它们的实现被简化，通常不会处理边缘情况。
- en: The fake for the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> adds
    the first and second items of the array manually, instead of using <samp class="SANS_TheSansMonoCd_W5Regular_11">array.reduce</samp>.
    This simplified implementation strips the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function of the ability to sum more than two data points, but for the Fibonacci
    sequence, it is sufficient. The reduced complexity makes it easy to understand
    and less prone to error. Replace the content of the *sum.ts* file inside the *__mocks__*
    folder with the code in [Listing 8-17](chapter8.xhtml#Lis8-17).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> 的伪造通过手动添加数组中的第一个和第二个项，而不是使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">array.reduce</samp>。这种简化的实现剥夺了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> 函数对两个以上数据点求和的能力，但对于斐波那契序列来说是足够的。减少的复杂性使其更易于理解，并且不容易出错。将
    *__mocks__* 文件夹中的 *sum.ts* 文件内容替换为 [Listing 8-17](chapter8.xhtml#Lis8-17) 中的代码。
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 8-17: A fake for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    function'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-17：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    函数的伪造
- en: Our fake uses a simple mathematical plus operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>)
    to add the first and second items of the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    parameter. Its main benefit is that it returns a result similar to that of the
    actual implementation. We can now run the test suites, and they should pass successfully
    without our having to adjust our expectations, returning the Fibonacci sequence.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的伪造使用一个简单的数学加法运算符（<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>）来添加
    <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> 参数中的第一个和第二个项。它的主要好处是返回的结果类似于实际实现的结果。我们现在可以运行测试套件，它们应该会成功通过，无需调整期望值，返回斐波那契序列。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using a Mock</samp>
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用模拟</samp>
- en: Mocks lie somewhere between stubs and fakes. Although less sophisticated than
    fakes, they return more realistic data than stubs. While they don’t simulate a
    dependency’s true behavior, they can react to the data they receive.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟介于存根和伪造之间。虽然比伪造简单，但它们返回比存根更真实的数据。虽然它们没有模拟依赖项的真实行为，但它们能够响应收到的数据。
- en: For example, our naive mock implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function will return a result from a hardcoded hash map. Replace the code in the
    *__mocks__/sum.ts* file with the code from [Listing 8-18](chapter8.xhtml#Lis8-18),
    which inspects the request and enables the Fibonacci calculator to use the original
    test suites.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的简单模拟实现的 <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> 函数将从一个硬编码的哈希映射中返回结果。将
    [Listing 8-18](chapter8.xhtml#Lis8-18) 中的代码替换到 *__mocks__/sum.ts* 文件中，该代码检查请求并允许斐波那契计算器使用原始的测试套件。
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 8-18: A mock for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    function'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-18：<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    函数的模拟
- en: We create a type, called <samp class="SANS_TheSansMonoCd_W5Regular_11">resultMap</samp>,
    that uses a string as a key and a number as a value. Then we use the newly created
    type for a hash map that stores our desired responses. Next, we define the mock
    function with the same interface as the original implementation. Inside the mock,
    we calculate the key to use in the hash map based on the parameters we receive.
    This lets us return the correct dataset and produce an actual Fibonacci sequence.
    The main benefit of using the mock over <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    is that we can control its outcome, as it returns values from a known dataset.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个类型，称为 <samp class="SANS_TheSansMonoCd_W5Regular_11">resultMap</samp>，它使用字符串作为键，数字作为值。然后，我们使用新创建的类型来表示一个哈希映射，存储我们期望的响应。接下来，我们定义一个与原始实现具有相同接口的模拟函数。在模拟函数中，我们根据收到的参数计算出要在哈希映射中使用的键。这使我们能够返回正确的数据集，并生成一个实际的斐波那契序列。使用模拟相对于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> 的主要好处是我们可以控制它的结果，因为它是从已知数据集返回的值。
- en: Conveniently, Jest provides us with helpers to work with test doubles. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">jest.mock</samp> function replaces imported
    modules with mocks. The <samp class="SANS_TheSansMonoCd_W5Regular_11">jest.fn</samp>
    API creates a basic mock that can return any kind of predefined data, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">jest.spyOn</samp> lets us record calls
    to any function without modifying it. We will use all of those in [Exercise 8](#Exe8)
    on page 146.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，Jest为我们提供了帮助工具来使用测试替代品。<samp class="SANS_TheSansMonoCd_W5Regular_11">jest.mock</samp>函数将导入的模块替换为模拟对象。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">jest.fn</samp> API创建一个基本的模拟，可以返回任何预定义的数据，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">jest.spyOn</samp>让我们在不修改函数的情况下记录对其的调用。我们将在第146页的[练习8](#Exe8)中使用这些工具。
- en: In typical developer contexts, you won’t bother with the subtle differences
    between stubs, fakes, and mocks and will use the term *mock* as a generic term
    for test doubles. Don’t spend too much time overengineering your mocks; they’re
    just tools to help you test your code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的开发人员环境中，你不会过多关注存根（stubs）、假对象（fakes）和模拟（mocks）之间的细微差别，通常会把*模拟*作为测试替代品的统称。不要花太多时间在过度设计模拟上；它们只是帮助你测试代码的工具。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Types of Tests</samp>
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">其他类型的测试</samp>
- en: The tests covered in this chapter so far are the most common ones you’ll encounter
    as a full-stack developer. This section briefly explains additional types of tests
    and when to use them. These aren’t meant to replace unit tests; rather, they supplement
    unit tests by covering specific aspects of your implementation that aren’t otherwise
    testable. For example, because unit tests run in isolation, they can’t evaluate
    the interaction between modules. Theoretically, if every function and module passes
    its test, the whole program should work as expected. Practically, you’ll often
    face issues caused by faulty module documentation. Commonly, the documentation
    will claim that an API returns a specific type, but the actual implementation
    will return a different one.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本章至此涵盖的测试是你作为全栈开发人员最常遇到的测试类型。本节简要解释了其他类型的测试以及何时使用它们。这些测试并不是要替代单元测试；而是通过覆盖实现中其他无法测试的特定方面来补充单元测试。例如，由于单元测试在隔离环境中运行，它们无法评估模块之间的交互。理论上，如果每个函数和模块都通过了测试，那么整个程序应该按预期工作。实际上，你经常会遇到由于模块文档错误导致的问题。通常，文档会声称某个API返回某种特定类型，但实际实现返回的是不同的类型。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Functional Tests</samp>
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">功能测试</samp>
- en: While unit tests examine the implementation of a feature from a developer’s
    perspective, *functional tests* cover the user’s perspective by verifying that
    code works as the user expects it to work. Put otherwise, these tests check that
    a given input results in an expected output. Most functional tests are a type
    of *black-box* test, which ignores the module’s internal code, side effects, and
    intermediate results and tests only the interfaces. Functional tests do not generate
    a code-coverage report. Generally, a quality assurance manager will write and
    use functional tests during a system testing stage. By contrast, developers write
    and use unit tests during development.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单元测试从开发人员的角度检查功能的实现，*功能测试*从用户的角度验证代码是否按用户预期的方式工作。换句话说，这些测试检查给定的输入是否会产生预期的输出。大多数功能测试属于*黑箱*测试的一种，它忽略模块的内部代码、副作用和中间结果，只测试接口。功能测试不会生成代码覆盖率报告。通常，质量保证经理会在系统测试阶段编写和使用功能测试。相比之下，开发人员在开发过程中编写和使用单元测试。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integration Tests</samp>
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">集成测试</samp>
- en: You learned that the goal of a unit test is to check the smallest possible section
    of code in isolation. An *integration test* is the complete opposite. It verifies
    the behavior of entire subsystems, whether they be layers of code, such as an
    app’s data storage mechanism, or specific functions consisting of multiple modules.
    Integration tests check the integration of the subsystem in the context of the
    current environment. Hence, they never run in isolation and typically don’t use
    test doubles.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了单元测试的目标是检查代码中最小的独立部分。*集成测试*则完全相反。它验证整个子系统的行为，无论是代码的层次结构，比如应用的数据存储机制，还是由多个模块组成的特定功能。集成测试检查子系统在当前环境中的集成情况。因此，它们永远不会在隔离环境中运行，通常也不使用测试替代品。
- en: Integration tests are helpful for finding three types of problems. The first
    type is problems related to *inter-module communication*, which is the communication
    between modules. Common problems are faulty internal API integrations and undetected
    side effects, such as a function that doesn’t delete old files before writing
    new data to the filesystem. The second type is problems related to the *environment*,
    which describes the hardware and software setup the code runs on. Different software
    versions or hardware configurations can introduce significant issues for your
    code. The most common problem for full-stack developers involves differences in
    Node.js versions and outdated dependencies in the modules.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试有助于发现三种类型的问题。第一类是与*模块间通信*相关的问题，即模块之间的通信。常见问题包括内部API集成故障和未检测到的副作用，例如某个函数没有在写入新数据到文件系统之前删除旧文件。第二类是与*环境*相关的问题，指的是代码运行的硬件和软件设置。不同的软件版本或硬件配置可能会给你的代码带来重大问题。全栈开发人员最常遇到的问题是Node.js版本的差异以及模块中过时的依赖项。
- en: The third type is problems related to *gateway communications*, which relates
    to testing any API communication with a third-party API gateway. Any communication
    with external APIs should be tested with integration tests. This is the only instance
    in which integration tests might use test doubles, such as stubbed versions of
    the external API, in order to simulate a specific API behavior, like a timeout
    or successful request. As with functional tests, a quality assurance manager generally
    writes and uses integration tests. Developers do so less often.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第三类是与*网关通信*相关的问题，指的是测试与第三方API网关的任何API通信。与外部API的任何通信都应该通过集成测试进行测试。这是唯一一个可能使用测试替代品的集成测试实例，比如使用外部API的虚拟版本，以模拟特定的API行为，如超时或成功请求。与功能测试一样，质量保证经理通常编写并使用集成测试，开发人员则较少这样做。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">End-to-End Tests</samp>
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">端到端测试</samp>
- en: You can think of the *end-to-end test* as a combination of functional tests
    and integration tests. As another kind of black-box test, they examine the application’s
    functionality across the full stack, from the frontend to the backend, in a specific
    environment. These business-facing tests should provide confidence that the overall
    application is still working as expected.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将*端到端测试*视为功能测试和集成测试的结合。作为另一种黑盒测试，它们检查整个堆栈中的应用程序功能，从前端到后端，在特定环境中运行。这些面向业务的测试应该提供信心，确保整个应用程序仍按预期工作。
- en: End-to-end tests run the application in a specific environment. Often, the complexity
    of the many dependencies increases the risk of flaky tests in which the application
    works correctly but the environment causes the tests to fail. End-to-end tests
    are thus the most time-consuming to create and maintain. Due to their complexity,
    we must craft them carefully. During execution, they are known to be slow, prone
    to encountering timeouts, and, like nearly all black-box tests, unable to provide
    detailed error reports. Therefore, they test only the most critical business-facing
    scenarios. Generally, a quality assurance manager writes them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试在特定环境中运行应用程序。通常，许多依赖关系的复杂性增加了不稳定测试的风险，虽然应用程序正常运行，但环境导致测试失败。因此，端到端测试是最耗时的创建和维护测试。由于其复杂性，我们必须谨慎设计它们。在执行过程中，它们通常较慢，容易遇到超时问题，且像几乎所有的黑盒测试一样，无法提供详细的错误报告。因此，它们仅测试最关键的面向业务的场景。通常，质量保证经理编写这些测试。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Snapshot Tests</samp>
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">快照测试</samp>
- en: The tests described earlier in this chapter check the code against some assertion.
    By contrast, a *snapshot test* compares the application’s current visual (or user
    interface) state to a previous version of it. Hence, these tests are also called
    visual regression tests. In each test, we create new snapshots and then compare
    them with ones stored earlier, providing a cheap way to test user interface components
    and complete pages. Instead of manually creating and maintaining tests that describe
    every property of an interface, such as a component’s height, width, position,
    and colors, we can establish a snapshot containing all of these properties.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面描述的测试通过一些断言来检查代码。相比之下，*快照测试*则是将应用程序当前的视觉（或用户界面）状态与其之前的版本进行比较。因此，这些测试也称为视觉回归测试。在每个测试中，我们会创建新的快照，然后与之前存储的快照进行比较，这为测试用户界面组件和完整页面提供了一种低成本的方法。我们不再手动创建和维护描述界面每个属性的测试，比如组件的高度、宽度、位置和颜色，而是可以通过快照来包含所有这些属性。
- en: One way to perform this type of test is to create and compare screenshots. Generally,
    a headless browser renders the component; the test runner waits for the page to
    render and then captures an image of it. Unfortunately, this process is relatively
    slow, and headless browsers are flaky. Jest takes a different approach to snapshot
    testing. Instead of working with headless browsers and image files, it renders
    the React user interface components to the virtual DOM, serializes them, and saves
    them as plaintext in *snap* files stored in the *__snapshots__* directory. Hence,
    Jest snapshot tests are much more performant and less flawed. The Food Finder
    application you’ll build in [Part II](part2.xhtml) will use snapshot tests to
    verify the integrity of the build and test your React components.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这种类型测试的一种方法是创建并比较截图。通常，一个无头浏览器会渲染组件；测试运行器等待页面渲染完成后再捕捉其图像。不幸的是，这个过程相对较慢，并且无头浏览器存在不稳定的情况。Jest采用了不同的方法进行快照测试。它不依赖无头浏览器和图像文件，而是将React用户界面组件渲染到虚拟DOM中，进行序列化并将其保存为纯文本的*snap*文件，存储在*__snapshots__*目录下。因此，Jest的快照测试具有更高的性能，并且更少出错。你将在[第二部分](part2.xhtml)构建的Food
    Finder应用中使用快照测试来验证构建的完整性并测试React组件。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8: Add Test Cases to the
    Weather App</samp>'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">练习8：为天气应用添加测试用例</samp>
- en: As long as you follow the basic principles we’ve discussed, there is no right
    or wrong way to test your code. Unit, snapshot, and end-to-end tests are all different
    tools in your tool belt, and you must strike a balance between the time you spend
    writing the tests and the usefulness of each. There is also no consensus on what
    to test. While you should strive for 90 percent code coverage or higher, the general
    rule of thumb is to cover at least the most critical parts of your application
    with unit tests and then write some integration tests to verify that your application
    works on each deployment.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你遵循我们讨论过的基本原则，就没有对错之分来测试你的代码。单元测试、快照测试和端到端测试都是你工具包中的不同工具，你必须在编写测试的时间和每种测试的实用性之间找到平衡。关于测试什么内容，也没有共识。虽然你应该努力达到90%以上的代码覆盖率，但一般的经验法则是，至少覆盖应用程序中最关键的部分进行单元测试，然后编写一些集成测试，以验证你的应用在每次部署时是否能够正常工作。
- en: 'When it comes to our weather application, we’ll want our test cases to cover
    four core aspects. First we’ll add unit tests to evaluate the middleware and services.
    Even though the REST API endpoints and React user interface component are easy
    to test directly in the browser, we’ll add test cases for both of them: a basic
    snapshot test for the user interface component and an end-to-end test for the
    REST API endpoint */v1/weather/[zipcode].ts*.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的天气应用，我们希望测试用例覆盖四个核心方面。首先，我们将添加单元测试来评估中间件和服务。即使REST API端点和React用户界面组件可以在浏览器中直接进行测试，我们也会为它们添加测试用例：一个用于用户界面组件的基本快照测试，以及一个针对REST
    API端点*/v1/weather/[zipcode].ts*的端到端测试。
- en: We’ve opted to test the REST endpoint rather than the GraphQL API for simplicity’s
    sake, as each REST endpoint has its own file, while all GraphQL APIs share an
    entry point, making their testing more complex. However, testing this GraphQL
    API would make an excellent exercise for exploring end-to-end-tests after you’ve
    finished the chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 出于简便考虑，我们选择测试REST端点而不是GraphQL API，因为每个REST端点都有自己的文件，而所有GraphQL API共享一个入口点，这使得测试更为复杂。然而，测试这个GraphQL
    API将是一个很好的练习，帮助你在完成本章后探索端到端测试。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing the Middleware
    with Spies</samp>
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">使用间谍测试中间件</samp>
- en: The middleware to connect to the database is a core part of the application,
    but we can’t access it directly, as it doesn’t expose any API. We can only implicitly
    test it by examining the database or by running a query through Mongoose, some
    service, or an API endpoint. Each of these methods would work, but if we want
    to test the connection to the database as a unit test, we need to do so in a way
    that isolates that component as much as possible.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 连接数据库的中间件是应用程序的核心部分，但我们无法直接访问它，因为它没有暴露任何 API。我们只能通过检查数据库或通过 Mongoose、某个服务或 API
    端点运行查询来间接测试它。这些方法都能奏效，但如果我们想将数据库连接作为单元测试进行测试，我们需要尽可能地将该组件隔离开来。
- en: To do so, we’ll use Jest’s built-in spies to verify that our middleware successfully
    calls all the functions necessary for establishing the connection to the MongoDB
    memory server. Navigate to your *__tests__* folder and create a new folder, *middleware*,
    and a file, *db-connect.test.ts*, inside it. Then copy the code from [Listing
    8-19](chapter8.xhtml#Lis8-19) into the file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用 Jest 内置的间谍来验证我们的中间件是否成功调用了建立与 MongoDB 内存服务器连接所需的所有函数。导航到你的 *__tests__*
    文件夹，并在其中创建一个新文件夹 *middleware*，然后在其中创建一个文件 *db-connect.test.ts*。然后，将[列表 8-19](chapter8.xhtml#Lis8-19)中的代码复制到该文件中。
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 8-19: The __tests__/middleware/db-connect.test.ts suite for the database
    connection'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-19：数据库连接的 __tests__/middleware/db-connect.test.ts 套件
- en: Most of this code resembles the test suites you wrote earlier in this chapter.
    But instead of testing simplified example code, we’re now testing real code, which
    requires us to make some adjustments.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码大部分与本章之前你编写的测试套件相似。但我们现在不是在测试简化的示例代码，而是在测试真实的代码，这要求我们做出一些调整。
- en: First we set the testing environment for Jest to <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp>,
    which simulates a Node.js runtime. Later, when writing snapshot tests, we’ll use
    Jest’s default environment, called <samp class="SANS_TheSansMonoCd_W5Regular_11">jsdom</samp>,
    which simulates a browser by providing a <samp class="SANS_TheSansMonoCd_W5Regular_11">window</samp>
    object, as well as all the usual DOM properties and functions. By always setting
    these environments in the file, we avoid issues caused by using the wrong environment.
    Then, as usual, we import the packages we need.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 Jest 的测试环境设置为<samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp>，该环境模拟了
    Node.js 运行时。之后，在编写快照测试时，我们将使用 Jest 的默认环境，称为<samp class="SANS_TheSansMonoCd_W5Regular_11">jsdom</samp>，它通过提供一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">window</samp>对象以及所有常见的 DOM 属性和函数来模拟浏览器。通过始终在文件中设置这些环境，我们避免了因使用错误环境而引发的问题。然后，像往常一样，我们导入所需的包。
- en: Now we can start writing the test suite for the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>
    function. We define a <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp>
    variable in the test suite’s scope to store the database connection, and then
    we can access the MongoDB’s server instance, including its methods and properties.
    For example, we’ll use these to stop the connection and disconnect from the server
    after each test to guarantee that each test case is independent.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始为<samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>函数编写测试套件。我们在测试套件的作用域中定义一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">connection</samp>变量来存储数据库连接，然后我们可以访问 MongoDB
    的服务器实例，包括它的方法和属性。例如，我们将使用这些来停止连接并在每次测试后断开与服务器的连接，以确保每个测试用例是独立的。
- en: To be able to store the connection, we first need to return the <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoServer</samp>
    constant from the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>
    function in the file *db-connect.ts*. Open the file and add the line <samp class="SANS_TheSansMonoCd_W5Regular_11">return
    mongoServer</samp> to the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>
    function right before the function’s closing curly bracket (<samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>).
    From time to time, you’ll need to modify the code you wrote earlier to accommodate
    the requirements of your tests. In other words, you need to adapt the code to
    make it testable.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够存储连接，我们首先需要从文件*db-connect.ts*中的<sup class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</sup>函数返回<samp
    class="SANS_TheSansMonoCd_W5Regular_11">mongoServer</samp>常量。打开文件并在<sup class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</sup>函数的闭合大括号（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">}</samp>）之前添加一行代码<samp class="SANS_TheSansMonoCd_W5Regular_11">return
    mongoServer</samp>。时不时地，你需要修改你之前写的代码，以适应测试的要求。换句话说，你需要调整代码，使其可以进行测试。
- en: Now we use the connection we just exposed and set up the <samp class="SANS_TheSansMonoCd_W5Regular_11">afterEach</samp>
    hook, which runs after each test case, to reset the mocked functions to their
    initial mocked state, thus clearing all previously gathered data. This is necessary,
    because otherwise, the spies would report information gained during the previous
    calls, as they retain their state across all test suites. Also, we re-create the
    database connection for each test case. Therefore, we need to stop the current
    connection and explicitly disconnect from the database after each test. Then we
    set up the <samp class="SANS_TheSansMonoCd_W5Regular_11">afterAll</samp> hook
    to remove all mocks and restore the original functions through the <samp class="SANS_TheSansMonoCd_W5Regular_11">restoreAllMocks</samp>
    function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用刚刚暴露的连接，并设置<sup class="SANS_TheSansMonoCd_W5Regular_11">afterEach</sup>钩子，它在每个测试用例后运行，用于将模拟函数重置为初始模拟状态，从而清除之前收集的所有数据。这是必要的，因为否则间谍会报告在前一次调用中获取的信息，因为它们会在所有测试套件中保留其状态。此外，我们为每个测试用例重新创建数据库连接。因此，在每个测试之后，我们需要停止当前连接并显式断开与数据库的连接。然后，我们设置<sup
    class="SANS_TheSansMonoCd_W5Regular_11">afterAll</sup>钩子，通过<samp class="SANS_TheSansMonoCd_W5Regular_11">restoreAllMocks</samp>函数删除所有模拟并恢复原始函数。
- en: Our test cases should all follow the *arrange, act, assert* pattern. As we review
    them, you might find it useful to open the *db-connect.ts* file in the *middleware*
    folder and follow along. The initial test case verifies the call to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">create</samp> function on the <samp class="SANS_TheSansMonoCd_W5Regular_11">MongoMemoryServer</samp>,
    as this is the first function that we call in the *db-connect.ts* file. To do
    so, we create a spy with the <samp class="SANS_TheSansMonoCd_W5Regular_11">jest
    .spyOn</samp> method. As arguments, this method takes the name of an object and
    the object’s method on which to spy. Then we act on the code under test and call
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> function. Finally,
    we assert that the spy has been called.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试用例应该都遵循*arrange, act, assert*模式。在回顾这些用例时，你可能会发现打开*middleware*文件夹中的*db-connect.ts*文件并跟着一起操作会很有帮助。第一个测试用例验证了调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">MongoMemoryServer</samp>上的<sup class="SANS_TheSansMonoCd_W5Regular_11">create</sup>函数，因为这是我们在*db-connect.ts*文件中调用的第一个函数。为了做到这一点，我们使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">jest.spyOn</samp>方法创建一个间谍。该方法的参数是一个对象的名称以及要监视的对象方法。然后我们对待测试的代码进行操作，并调用<sup
    class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</sup>函数。最后，我们断言该间谍已被调用。
- en: The second test case works similarly except that it spies on a different method.
    We use it to check that <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose.disconnect</samp>
    was called successfully during the execution of <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>.
    The third test case introduces a new matcher. Instead of verifying only the call
    itself with <samp class="SANS_TheSansMonoCd_W5Regular_11">toHaveBeenCalled</samp>,
    we now also verify the call’s arguments using <samp class="SANS_TheSansMonoCd_W5Regular_11">toHaveBeenCalledWith</samp>.
    Here we grab the connection string directly from the connection and store it in
    the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">MONGO_URI</samp>. We
    also hardcode the database we want to connect to. Then we call the matcher, passing
    it the expected arguments and verifying that they meet our expectations.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Now run the test suites with <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    test</samp>. All tests should pass with 100 percent test coverage.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating Mocks to
    Test the Services</samp>
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While the tests we wrote for the middleware were quite simple, the service tests
    are a bit more complicated. If you open the *mongoose/weather/services.ts* file,
    you’ll see that the services depend on <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>,
    which is Mongoose’s gateway to the MongoDB collection. Each service calls a method
    on the model that, in turn, requires a database connection. We won’t reevaluate
    those database connections here; instead, the goal of this test suite will be
    to verify that the service functions call the correct <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>
    functions. To do so, we’ll create a mock <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>
    that exposes the same set of APIs as mocked functions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: We first write the mocked model. Following convention, we create the file *mongoose/weather/__mocks__/model.ts*
    and add the code in [Listing 8-20](chapter8.xhtml#Lis8-20).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 8-20: The mock for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">WeatherModel</samp>'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: We implement <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp>
    and define the new <samp class="SANS_TheSansMonoCd_W5Regular_11">param</samp>
    type, which is an object with key-value pairs that we use to type the first parameter.
    We make the mocked <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>
    the default export and use an object that implements the four methods of the actual
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>, each of which
    takes the same parameters as the original. They also take the original Mongoose
    model’s method. Because they are asynchronous functions, we return a promise resolved
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Now we can write the test suite for the services. These check that each service
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> upon success
    and calls the correct method of the mocked <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>.
    Create the file */__tests__/mongoose/weather/services.test.ts* and add the code
    from [Listing 8-21](chapter8.xhtml#Lis8-21) to it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为服务编写测试套件。它们检查每个服务在成功时返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>，并调用模拟的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp> 的正确方法。创建文件 */__tests__/mongoose/weather/services.test.ts*，并将
    [列表 8-21](chapter8.xhtml#Lis8-21) 中的代码添加到该文件中。
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 8-21: The updated test suite in __tests__/mongoose/weather/services.test.ts'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-21：__tests__/mongoose/weather/services.test.ts 中更新的测试套件
- en: As in the previous test suite, we begin by setting up the environment and importing
    modules. We also import <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>
    and call <samp class="SANS_TheSansMonoCd_W5Regular_11">jest.mock</samp> with the
    path to the mocked model we created, effectively replacing the original model
    in the code under test. Then we create a document containing some test data. We
    store it in the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">doc</samp>
    and will pass it to the mocked model’s methods. As done previously, we use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">afterEach</samp> hook to reset all
    mocks after each test and the <samp class="SANS_TheSansMonoCd_W5Regular_11">afterAll</samp>
    hook to remove the mocks and restore the original functions after all test cases
    have been finished.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的测试套件一样，我们首先设置环境并导入模块。我们还导入了 <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>，并使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">jest.mock</samp> 调用我们创建的模拟模型路径，从而有效地替换了测试代码中的原始模型。然后，我们创建一个包含一些测试数据的文档。我们将其存储在常量
    <samp class="SANS_TheSansMonoCd_W5Regular_11">doc</samp> 中，并将其传递给模拟模型的方法。与之前一样，我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">afterEach</samp> 钩子在每个测试后重置所有模拟，使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">afterAll</samp> 钩子在所有测试用例完成后移除模拟并恢复原始函数。
- en: 'We create a nested test suite for each of the four services. Each has the same
    two unit tests: one to verify the return value upon success with the <samp class="SANS_TheSansMonoCd_W5Regular_11">toBeTruthy</samp>
    matcher and one to spy on a particular <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>
    mock function. The code follows the same pattern as the previous test suite and
    uses the same matchers as well.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为四个服务创建了一个嵌套的测试套件。每个服务都有相同的两个单元测试：一个是使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">toBeTruthy</samp>
    匹配器验证成功时的返回值，另一个是间谍（spy）监视一个特定的 <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>
    模拟函数。代码遵循与前一个测试套件相同的模式，并使用相同的匹配器。
- en: 'The code-coverage report we receive after running <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    test</samp> shows that we tested around 70 percent of the service code. If you
    take a look at the uncovered lines listed in the last column, you’ll see that
    they contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">console.log(err);</samp>
    output. This output is used whenever an asynchronous call to the model’s methods
    fails:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在运行 <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp> 后收到的代码覆盖率报告显示，我们测试了大约
    70% 的服务代码。如果你查看最后一列中列出的未覆盖行，你会看到它们包含了 <samp class="SANS_TheSansMonoCd_W5Regular_11">console.log(err);</samp>
    输出。这个输出会在异步调用模型方法失败时使用：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: For the purposes of this chapter, we’ll leave these lines uncovered. Otherwise,
    we could modify the mocked model to throw an error—for example, by supplying an
    invalid document—and then add a third test case per service verifying the error.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的，我们将保留这些未覆盖的行。否则，我们可以修改模拟的模型，使其抛出一个错误——例如，提供一个无效的文档——然后为每个服务添加一个第三个测试案例，验证错误。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Performing an End-to-End
    Test of the REST API</samp>
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">执行 REST API 的端到端测试</samp>
- en: Sophisticated API tests might use a dedicated API testing library such as *SuperTest*,
    which provides matchers for HTTP status codes and simplifies the handling of requests
    and responses. Alternatively, they might use a GUI tool like Postman. In this
    example, we’ll merely test that the returned data matches our expectations by
    using the native <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> method.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 高级 API 测试可能会使用专门的 API 测试库，如 *SuperTest*，它提供了 HTTP 状态码的匹配器，并简化了请求和响应的处理。或者，它们可能会使用像
    Postman 这样的 GUI 工具。在本例中，我们将仅通过使用本地的 <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    方法测试返回的数据是否符合我们的预期。
- en: 'Unlike the previous tests, this one doesn’t isolate any single component, as
    our goal is to verify that all components of the system work together as expected.
    To check whether the API returns a proper response from the database when supplied
    some input, our end-to-end test will make certain assumptions: that all layers
    have already been tested independently, that the database contains its initial
    seed data, and that our application runs at *http://localhost:3000/*.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: To verify our first assumption, open the API endpoint file *pages/api/v1/weather/[zipcode].ts*.
    You’ll notice that the API code imports two functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">findByZip</samp>
    from the service module and the middleware’s <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>,
    both of which we’ve already tested. The second assumption is also satisfied; the
    database loads the initial seed on each startup. Create the file *zipcode.e2e
    .test.ts* in *__tests__/pages/api/v1/weather/* and add the code from [Listing
    8-22](chapter8.xhtml#Lis8-22).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 8-22: The test suite for the REST API'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: We set the environment to <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp>
    and then define the test suite with one test case. In it, we supply a ZIP code
    that matches one of the initial seed datasets. Then we use the native <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    method, which has been available since Node.js version 17.5, to call our weather
    API on our localhost and check whether the returned ZIP code is the same as the
    one passed as a parameter. We add an empty export statement to define this file
    as an ES6 module.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The test should pass and have 100 percent code coverage. Now that we’re confident
    that the core of our application is working as expected, we can test the user
    interface components.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: When using <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>, there
    are two common error messages you might encounter. The first, <samp class="SANS_TheSansMonoCd_W5Regular_11">ECONNREFUSED</samp>,
    tells you that <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> could
    not connect to your application because it is not running. Use <samp class="SANS_TheSansMonoCd_W7Bold_B_11">npm
    run dev</samp> to start the application or adjust the port in the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    call if you’re not using port 3000\. The second error mentions that the test exceeded
    the timeout of 5,000 ms for a test. If you started your application for the purposes
    of testing and did not use a previously running application, Next.js compiles
    the API route as soon as the test consumes it. Depending on your environment,
    this might take longer than the default timeout. Add the line <samp class="SANS_TheSansMonoCd_W7Bold_B_11">jest.setTimeout(20000);</samp>
    before the <samp class="SANS_TheSansMonoCd_W5Regular_11">describe</samp> method
    at the top of your file to increase the timeout and make the test wait 20,000
    ms instead of 5,000 ms.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Evaluating the User
    Interface with a Snapshot Test</samp>
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Snapshot tests verify that a page’s rendered HTML didn’t change between two
    test runs. To achieve this with Jest, we must first prepare our environment. Add
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">jsdom</samp> environment, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">react-testing-library</samp>, and the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">react-test-renderer</samp> to the
    project:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We’ll need these to simulate a browser environment and render React components
    during our test cases. Now we’ll modify the *jest.config.js* file in our root
    directory accordingly. Replace its content with the code in [Listing 8-23](chapter8.xhtml#Lis8-23).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 8-23: The updated jest.config.js file'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: This code imports the *next/jest* package and exports a Jest configuration with
    the default properties of a Next.js project. It is the simplest form of Next.js-compatible
    Jest configuration. If you take a look at the official Next.js setup guide at
    [*https://<wbr>nextjs<wbr>.org<wbr>/docs<wbr>/testing*](https://nextjs.org/docs/testing),
    you’ll see that it outlines some basic configuration options, none of which we
    need.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The First Version</samp>
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A snapshot test renders a component or a page, takes a snapshot of it as serialized
    JSON, and stores it in a *__snapshots__* folder next to the test suite. On each
    consecutive run, Jest compares the current snapshot with the stored reference.
    As long as they are the same, the snapshot test passes. To generate the initial
    snapshot, create a new folder, *__tests__/pages/components*, and the file *weather.snapshot.test.tsx*,
    and then add the code in [Listing 8-24](chapter8.xhtml#Lis8-24) to it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 8-24: The snapshot test for <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PageComponentWeather</samp>'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The first lines of our snapshot test set the environment to <samp class="SANS_TheSansMonoCd_W5Regular_11">jsdom</samp>
    and import the test renderer’s <samp class="SANS_TheSansMonoCd_W5Regular_11">act</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">create</samp> methods to test
    the React component, which we import in the next line.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Next, we write the simulated user behavior and wrap the component’s creation
    in the asynchronous <samp class="SANS_TheSansMonoCd_W5Regular_11">act</samp> function.
    As you might have guessed, this function draws its name from the *arrange, act,
    assert* pattern and ensures that all relevant updates to the DOM have been applied
    before proceeding with the test case. It is required for all statements that cause
    updates to the React state, and here, it delays the test execution until after
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> hook runs.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Then we write a test case that awaits the <samp class="SANS_TheSansMonoCd_W5Regular_11">create</samp>
    function, which renders the JSX component. This lets us generate HTML in a simulated
    browser environment and store the result in a variable. We await the component’s
    rendering so that the HTML is available for our follow-up interactions before
    we continue with the test case. Then we serialize the rendered component to a
    JSON string and use a new matcher, <samp class="SANS_TheSansMonoCd_W5Regular_11">toMatchSnapshot</samp>,
    which compares the current JSON string with the stored reference.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'A trial run shows that all tests succeed. We see two interesting things— that
    the test created one snapshot and that we achieved a test coverage of 81 percent:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can look at the created snapshot by opening the *weather.snapshot.test.tsx.snap*
    file in the *__snapshots__* folder. It should look fairly similar to the code
    in [Listing 8-25](chapter8.xhtml#Lis8-25), and you’ll see that it is nothing more
    than the rendered HTML saved as a multiline template literal. Your HTML might
    not be identical to that shown here; the important aspect is that it looks the
    same after each test run when <samp class="SANS_TheSansMonoCd_W5Regular_11">react-test-renderer</samp>
    rendered the component.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 8-25: The weather.snapshot.test.tsx.snap file with the serialized HTML'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: We also see that the counter is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    which indicates that the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    did not run before we created the snapshot. If you open the component’s file and
    check the uncovered lines, you’ll learn that they relate to the click handler
    that increases the <samp class="SANS_TheSansMonoCd_W5Regular_11">state</samp>
    variable and, as suspected, the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    hook. We want to test these core functionalities as well.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Second Version</samp>
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">第二个版本</samp>
- en: We’ll modify the test code to cover the previously untested functionalities.
    Paste the code from [Listing 8-26](chapter8.xhtml#Lis8-26) into the snapshot test
    file.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改测试代码，以覆盖之前未测试的功能。将 [清单 8-26](chapter8.xhtml#Lis8-26) 中的代码粘贴到快照测试文件中。
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 8-26: The updated snapshot test'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-26：更新后的快照测试
- en: In the updated code, we’ve added another test case that finds the headline on
    the page and simulates a user clicking it. Remember from previous chapters that
    this increases the state variable <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp>.
    Again, we await the creation of the component and use the <samp class="SANS_TheSansMonoCd_W5Regular_11">act</samp>
    function.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新后的代码中，我们添加了另一个测试用例，它找到页面上的标题并模拟用户点击它。记住在前面的章节中，这会增加状态变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp>。再次提醒，我们等待组件的创建，并使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">act</samp> 函数。
- en: 'If you rerun the tests, you should see a failure. The test runner tells us
    that the snapshots do not match:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新运行测试，应该会看到失败。测试运行器告诉我们快照不匹配：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Because we modified the test case to wait for the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    hook and set the state variable <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    the DOM changed as well. Follow the test runner’s advice and rerun the tests with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test -- -u</samp> to create
    a new, updated snapshot. The tests should now succeed, reporting a test coverage
    of 100 percent for our component.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们修改了测试用例，等待 <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    钩子，并将状态变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp> 设置为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">1</samp> 而不是 <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>，所以
    DOM 也发生了变化。按照测试运行器的建议，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test
    -- -u</samp> 重新运行测试，创建一个新的更新后的快照。现在测试应该会成功，报告我们组件的测试覆盖率为 100%。
- en: Try experimenting with your newfound knowledge. For example, can you write a
    snapshot test for the page routes in the *pages* directory or a set of end-to-end
    tests for the GraphQL API?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运用你新学到的知识。例如，你能为 *pages* 目录中的页面路由编写快照测试，或者为 GraphQL API 编写一组端到端测试吗？
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: You should now be able to create automated tests with Jest and, more broadly,
    design a testing plan on your own to strike a balance between effort and reward.
    We discussed the benefits of TDD and unit testing and then used the *arrange,
    act, assert* pattern to develop a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function following test-driven principles. Next, we used three types of test doubles
    to replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function
    while calculating the Fibonacci sequence. Finally, we added unit and snapshot
    tests to our existing Next.js application, created a mock of a Mongoose model,
    and used spies to verify our assumptions.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能够使用 Jest 创建自动化测试，并且更广泛地说，自己设计一个测试计划，以在努力和回报之间找到平衡。我们讨论了 TDD 和单元测试的好处，然后使用
    *arrange, act, assert* 模式，按照测试驱动原则开发了一个简单的 <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    函数。接着，我们使用三种类型的测试替代品，在计算 Fibonacci 数列时替换了 <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    函数。最后，我们向现有的 Next.js 应用程序添加了单元和快照测试，创建了一个 Mongoose 模型的模拟，并使用间谍验证了我们的假设。
- en: To learn more about Jest and automated testing, consult the official Jest documentation
    at [*https://<wbr>jestjs<wbr>.io<wbr>/docs<wbr>/getting<wbr>-started*](https://jestjs.io/docs/getting-started).
    In the next chapter, you’ll explore the differences between authorization and
    authentication and how you can leverage OAuth in your applications.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Jest 和自动化测试的信息，请查阅官方 Jest 文档：[*https://<wbr>jestjs<wbr>.io<wbr>/docs<wbr>/getting<wbr>-started*](https://jestjs.io/docs/getting-started)。在下一章中，你将探索授权和认证之间的区别，以及如何在应用程序中利用
    OAuth。
