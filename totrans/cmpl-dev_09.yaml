- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">TESTING
    WITH THE JEST FRAMEWORK</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Drop-image.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Whenever you modify your code, you risk causing unforeseen side effects in another
    part of your application. As a result, guaranteeing the integrity and stability
    of a code base can be challenging. To do so, developers follow two main strategies.
  prefs: []
  type: TYPE_NORMAL
- en: In the first, an architectural pattern, we split our code into small, self-contained
    React components. By nature, these components don’t interfere with one another.
    Hence, changing one shouldn’t lead to any side effects. In the second, we perform
    automated unit testing, which this chapter covers using the Jest framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we discuss the essentials of automated unit testing
    and the benefits of using it. You’ll learn how to write a test suite in Jest and
    use its reports to improve your code. You’ll also handle dependencies by using
    code doubles. Lastly, you’ll explore other kinds of tests you might want to run
    against your application.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Test-Driven Development and Unit Testing</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Developers sometimes use the technique of *test-driven development (TDD)*, in
    which they write their automated tests before implementing the actual code to
    be tested. They first create a test to evaluate that the smallest possible unit
    of code would work as expected. Such a test is called a *unit test*. Next, they
    write the minimum amount of code necessary to pass the test.
  prefs: []
  type: TYPE_NORMAL
- en: This approach has distinct benefits. First, it lets you focus on your app’s
    requirements by explicitly defining the code’s functionality and edge cases. Therefore,
    you have a clear picture of its desired behavior, and you can identify unclear
    or missing specifications sooner rather than later. When you write tests after
    completing the functionality, they might reflect the behavior you implemented
    rather than the behavior you require.
  prefs: []
  type: TYPE_NORMAL
- en: Second, limiting yourself to writing only necessary code prevents your functions
    from becoming too complex and splits your application into small, understandable
    sections. Testable code is maintainable code. In addition, the technique ensures
    that your tests cover a large portion of the app’s code, a metric called *code
    coverage*, and by running the tests frequently during development, you’ll instantly
    recognize bugs introduced by new lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the situation, the *unit* targeted by a unit test can be a module,
    a function, or a line of code. The tests aim to verify that each unit works in
    isolation. The single lines inside each test function are the test *steps*, and
    the whole test function is called a test *case*. Test *suites* aggregate test
    cases into logical blocks. To be considered reproducible, the test must return
    the same results every time we run it. As we will explore in this chapter, this
    means that we must run the tests in a controlled environment with a defined dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Facebook developed the Jest testing framework in conjunction with React, but
    we can use it with any Node.js project. It has a defined syntax for setting up
    and writing tests. Its *test runner* executes these tests, automatically replaces
    any dependencies in our code, and generates a test-coverage report. Additional
    npm modules provide custom code for testing DOM or React components and, of course,
    adding TypeScript types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Using Jest</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use Jest in a project, we must install its required packages, create a directory
    for all test files, and add an npm script that will run the tests. Execute the
    following in your Next.js application’s root directory to install the framework,
    as well as type definitions from DefinitelyTyped as development dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then create the directory in which to save your tests. Jest uses the *__tests__*
    folder by default, so make one in your root directory. Next, to add the npm script
    *test* to your project, open the *package.json* file and modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">scripts</samp>
    object to match the one in [Listing 8-1](chapter8.xhtml#Lis8-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-1: The package.json file with the new text command'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can run tests with the <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    test</samp> command. Usually, build servers execute this command by default during
    the build process. Lastly, to enable TypeScript support in Jest, add the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ts-jest</samp> transpiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Also create a *jest.config* file to add TypeScript by running <samp class="SANS_TheSansMonoCd_W5Regular_11">npx
    ts-jest config:init</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating an Example Module to Test</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s write some example code to help us understand unit testing and TDD. Say
    we want to create a new module in our app, *./helpers/sum.ts*. It should export
    a function, <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>, that returns
    the sum of its parameters. To follow a TDD pattern, we’ll begin by creating test
    cases for this module.
  prefs: []
  type: TYPE_NORMAL
- en: First we need to create the function that will run our tests. Create a file
    called *sum.test.ts* in the default test directory and add the code from [Listing
    8-2](chapter8.xhtml#Lis8-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-2: The empty test suite'
  prefs: []
  type: TYPE_NORMAL
- en: We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function
    we’ll write later and use Jest’s <samp class="SANS_TheSansMonoCd_W5Regular_11">describe</samp>
    function to create an empty test suite. As soon as we run the (nonexistent) tests
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp>, Jest should
    complain that there is no file called *sum.ts* in the *helpers* directory. Create
    this file and folder now, at the root directory of your project. Within the file,
    write the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function shown
    in [Listing 8-3](chapter8.xhtml#Lis8-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-3: The bare bones of the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    function'
  prefs: []
  type: TYPE_NORMAL
- en: Now run the tests again with <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    test</samp>. Because the code just exports a placeholder <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function that returns nothing, the Jest test runner again complains. This time,
    it informs us that the test suite needs to contain at least one test.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the anatomy of a test case and add a few test cases to the *sum.test.ts*
    file during the process.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Anatomy of a Test Case</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two types of unit tests: state and interaction based. An *interaction-based*
    test case verifies that the code under evaluation invokes a specific function,
    whereas a *state-based* test case checks the code’s return value or resulting
    state. Both types follow the same three steps: arrange, act, and assert.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Arrange</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To write independent and reproducible tests, we need to first *arrange* our
    environment by defining prerequisites, such as test data. If we need these prerequisites
    for only one particular test case, we define them at the beginning of the case.
    Otherwise, we set them globally for all tests in the test suite by using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">beforeEach</samp> hook, which gets executed
    before each test case, or the <samp class="SANS_TheSansMonoCd_W5Regular_11">beforeAll</samp>
    hook, which gets executed before all tests run.
  prefs: []
  type: TYPE_NORMAL
- en: If, for example, we had some reason to use the same global dataset for each
    test case and knew that our test steps would modify the dataset, we would need
    to re-create the dataset before each test. The <samp class="SANS_TheSansMonoCd_W5Regular_11">beforeEach</samp>
    hook would be the perfect place to do this. On the other hand, if the test cases
    merely consume the data, we’d need to define the datasets only once and so would
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">beforeAll</samp> hook.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s define two test cases and create the input values for each. Our input
    parameters will be specific to each test case, so we’ll declare them inside the
    test cases instead of using a <samp class="SANS_TheSansMonoCd_W5Regular_11">beforeEach</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">beforeAll</samp> hook. Update
    the *sum.test.ts* file with the code from [Listing 8-4](chapter8.xhtml#Lis8-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-4: The test suite containing the arrange steps'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">describe</samp> function creates
    our test suite, which comprises two calls to the <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp>
    function, each of which is a test case. For both, the first argument is the description
    we see on the test runner’s report.
  prefs: []
  type: TYPE_NORMAL
- en: Each of our tests evaluates the result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function. The first checks the addition feature, verifying that 2 plus 2 returns
    4\. The second test confirms that the function correctly returns negative values
    as well. It adds 4 to −8 and expects a result of −4.
  prefs: []
  type: TYPE_NORMAL
- en: You might want to check the return type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function, too. Usually, we would have done so, but because we’re using TypeScript,
    there is no need for this additional test case. Instead, we can define the return
    type in the function signature, and TSC will verify it for us.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Act</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As soon as the test runner executes a case, the test steps *act* on our behalf
    by invoking the code under test with the data for the particular test case. Each
    test case should test exactly one feature or variant of the system. This step
    is the line of code that invokes the function to execute. [Listing 8-5](chapter8.xhtml#Lis8-5)
    adds it to the test cases in *sum.test.ts*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-5: The test suite containing the act steps'
  prefs: []
  type: TYPE_NORMAL
- en: Our new lines call the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function and pass it the values we defined as parameters. We store the returned
    values in the <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> variable.
    In your editor, TSC should throw an error along the lines of <samp class="SANS_TheSansMonoCd_W5Regular_11">Expected
    0 arguments, but got 2</samp>. This is fine, as the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function is just an empty placeholder and doesn’t yet expect any parameters.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assert</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The final step of our test case is the *assertion* that the code fulfills the
    expectations we defined. We create this assertion with two parts: the Jest <samp
    class="SANS_TheSansMonoCd_W5Regular_11">expect</samp> function, used in conjunction
    with a *matcher* function from Jest’s *assert* library that defines the condition
    for which we are testing. Depending on the unit test’s category, this condition
    could be a specific return value, a state change, or the invocation of another
    function. Common matchers check whether a value is a number, a string, and so
    on. We can also use them to assert that a function returns true or false.'
  prefs: []
  type: TYPE_NORMAL
- en: Jest’s *assert* library provides us with a built-in set of basic matchers, and
    we can add additional ones from the npm repository. One of the most common assert
    packages is *testing-library/dom*, used to query the DOM for a particular node
    and assert its characteristics. For example, we can check for a class name or
    attribute or work with native DOM events. Another common assert package, *testing-library/react*,
    adds utilities for React and gives us access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">render</samp>
    function and React hooks in our asserts.
  prefs: []
  type: TYPE_NORMAL
- en: Because each test case evaluates one condition in one unit of code, we limit
    each test to one assert. In this way, as soon as the test run succeeds or fails
    and the test reporter generates the report, we can easily spot which test assumption
    failed. [Listing 8-6](chapter8.xhtml#Lis8-6) adds one assert per test case. Paste
    it into the *sum.test.ts* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-6: The test suite containing the assert steps'
  prefs: []
  type: TYPE_NORMAL
- en: These lines use the <samp class="SANS_TheSansMonoCd_W5Regular_11">expect</samp>
    assert function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">toBe</samp>
    matcher to compare the expected result to be the same as our expectation. Our
    test cases are now complete. Each follows the *arrange, act, assert* pattern and
    verifies one condition. [Appendix C](appendix-C.xhtml) lists additional matchers.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Using TDD</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our test cases still haven’t executed, and if you run <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    test</samp>, the test runner should fail immediately. TSC checks the code and
    throws an error for the missing parameter declarations on the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It’s time to implement this <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function. Following the principles of TDD, we’ll incrementally add features to
    the code and run the test suites after each addition, continuing this process
    until all tests pass. First we’ll add those missing parameters. Replace the code
    in *sum.ts* with the contents of [Listing 8-7](chapter8.xhtml#Lis8-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-7: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    function with added parameters'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve added the parameters and typed them as numbers. Now we rerun the test
    cases and, as expected, they fail. The console output tells us that the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function doesn’t return the
    expected results. This shouldn’t surprise us, because our <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function doesn’t return anything at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code in [Listing 8-8](chapter8.xhtml#Lis8-8) adds this functionality to
    the *sum.ts* file. We type the function’s return type as a number and add the
    two parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-8: The complete <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    function'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we rerun <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp>,
    Jest should report that all test cases succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, everything worked.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Refactoring Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unit tests are particularly useful when we need to refactor our code. As an
    example, let’s rewrite the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function so that, instead of two parameters, it accepts an array of numbers. The
    function should return the sum of all array items.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by rewriting our existing test cases into a more compact form and then
    expanding the test suite to verify the new behavior. Replace the code in the *sum.test.file*
    with [Listing 8-9](chapter8.xhtml#Lis8-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-9: The test suite for the refactored <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    function'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we rewrote the test cases in a more compact form. Explicitly splitting
    the arrange, act, and assert statements across multiple lines may be easier to
    read, but for simple test cases, such as those in [Listing 8-9](chapter8.xhtml#Lis8-9),
    we often write them in one line. We’ve changed their functionality to accommodate
    the new requirements. Instead of accepting two values, our <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function receives an array with numbers. Again, the TSC instantly notifies us
    of the mismatching parameters between the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function in the test suite and the actual implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve written our tests, we can rewrite our code. [Listing 8-10](chapter8.xhtml#Lis8-10)
    shows the code for the *helpers/sum.ts* file. Here the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function now accepts an array of numbers as a parameter and returns a number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-10: The rewritten <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    function in the helpers/sum.ts file'
  prefs: []
  type: TYPE_NORMAL
- en: 'We changed the parameter to an array of numbers. This fixes the TypeScript
    error caused by the test suite in [Listing 8-9](chapter8.xhtml#Lis8-9). But because
    we’re following TDD and making only one functional change at a time, we keep the
    function’s original behavior of adding two values. As expected, one of the test
    cases fails when we run the automated tests with <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    test</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The third test case, which tests the new requirement, is the one that failed.
    Not only did we expect this result, but we also wanted the test to fail; this
    way, we know that the tests themselves are working. If they succeeded before we
    implemented the corresponding functionality, the test cases would be faulty.
  prefs: []
  type: TYPE_NORMAL
- en: With the failing test as the baseline, it is now time to refactor the code to
    accommodate the new requirement. Paste the code in [Listing 8-11](chapter8.xhtml#Lis8-11)
    into the *sum.ts* file. Here we refactor the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function to return the sum of all array values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-11: The corrected <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    function with <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">array.reduce</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we could loop through the array with a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop, we use modern JavaScript’s <samp class="SANS_TheSansMonoCd_W5Regular_11">array.reduce</samp>
    function. This native array function runs a callback function on each array element.
    The callback receives the return value of the previous iteration and the current
    array item as parameters: exactly what we need to calculate the sum.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run all the test cases in our test suite to verify that they are working as
    expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The test runner should show that the code passed every test.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Evaluating Test Coverage</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To measure exactly which lines of code our test suites cover, Jest generates
    a test-coverage report. The higher the percentage of code our tests assess, the
    more thorough they are, and the more confident we can be about the application’s
    quality and maintainability. As a general rule of thumb, you should aim for code
    coverage of 90 percent or above, with a high coverage for the most critical part
    of your code. Of course, the test cases should add value by testing the code’s
    functions; adding tests just to increase the test coverage is not the goal we
    are aiming for. But as soon as you’ve tested your code base thoroughly, you can
    refactor existing features and implement new ones without worrying about introducing
    regression bugs. A high code coverage verifies that changes have no hidden side
    effects.
  prefs: []
  type: TYPE_NORMAL
- en: Modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test</samp> script
    in the *package.json* file by adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">--coverage</samp>
    flag to it, as shown in [Listing 8-12](chapter8.xhtml#Lis8-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-12: Enabling Jest’s test-coverage feature in the package.json file'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we rerun the test suite, Jest should show what percentage of the code our
    unit tests cover. It generates a code-coverage report and stores it in the *coverage*
    folder. Compare your output with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The report shows the coverage broken down by statements, branches, functions,
    and lines. We see that our simple <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function has a code coverage of 100 percent across all categories. Hence, we know
    that we’ve left no code untested and can trust that the test cases reflect the
    function’s quality.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Replacing Dependencies with Fakes, Stubs,
    and Mocks</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We mentioned that our tests should run in isolation, without depending on external
    code. You might have wondered how to handle imported modules; after all, as soon
    as you import code, you add a dependency to the unit under evaluation. Those third-party
    modules might not work as expected, and we don’t want our code to depend on the
    assumption that they all operate correctly. Consequently, you should provide a
    set of test cases for each imported module to verify its functionality. They,
    too, are units to test.
  prefs: []
  type: TYPE_NORMAL
- en: Separately, instead of importing modules into our other code units, we need
    to replace them with *test doubles* that return a defined set of static data tailored
    to the test. Test doubles replace an object or a function, effectively removing
    a dependency. Because they return a defined dataset, their response is known and
    predictable. You can compare them to stunt doubles in movies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides replacing an object or function, test doubles have a second important
    purpose: they record their calls and let us spy on them. We can thus use them
    to test whether the test double has been called at all, how often, and which arguments
    it received. There are three main types of test doubles: fakes, stubs, and mocks.
    However, you’ll sometimes hear the term *mock* to refer to all three.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Module
    with Dependencies</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To practice using test doubles in our <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function, we’ll create a new function that calculates a specified number of values
    in the Fibonacci sequence. The *Fibonacci sequence* is a pattern in which each
    subsequent number is the sum of the previous two, a simple use case for a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> module.
  prefs: []
  type: TYPE_NORMAL
- en: All developers must figure out how fine-grained their test cases need to be.
    The Fibonacci sequence is a good example, because trying to test every possible
    number submitted to the function would be useless, as the sequence has no end.
    Instead, we want to verify that the function properly handles edge cases and that
    its underlying functionality works. For instance, we’ll check how it handles an
    input with a length of 0; in that case, the function should return an empty string.
    Then we’ll test how it calculates a Fibonacci sequence of any length longer than
    3\. Create the *fibonacci.test.ts* test suite inside the *__tests__* folder and
    then add the code from [Listing 8-13](chapter8.xhtml#Lis8-13) to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-13: The test suite for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fibonacci</samp>
    function'
  prefs: []
  type: TYPE_NORMAL
- en: 'We define two test cases: one that checks for a length input of 0 and another
    that calculates a Fibonacci sequence of five numbers. Both tests follow the *arrange,
    act, assert* pattern in the compact variant we used earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: After we’ve created the test cases, we can move on to writing the Fibonacci
    function code. Create the *fibonacci.ts* file in the *helpers* folder, next to
    the *sum.ts* file, and add the code from [Listing 8-14](chapter8.xhtml#Lis8-14)
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-14: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fibonacci</samp>
    function'
  prefs: []
  type: TYPE_NORMAL
- en: We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function
    from the module we created earlier in this chapter. It is now a dependency that
    we’ll need to replace with a test double later. Then we implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">fibonacci</samp>
    function, which accepts the length of the sequence to calculate and returns a
    string. We store the current sequence in an array so that we have a simple way
    to access the two previous values needed to calculate the next one. Notice that
    the first number in the sequence is always <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    and the second is always <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>.
    Finally, we return a string with the requested number of values. If you save this
    code and rerun the test suites, both *sum.test.js* and *fibonacci.test.ts* should
    pass successfully.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a Doubles
    Folder</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Because we import the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function in the Fibonacci module, our code has an external dependency. This is
    problematic for testing purposes: if the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function breaks, the test for the Fibonacci sequence will fail as well, even if
    the logic of the Fibonacci implementation is correct.'
  prefs: []
  type: TYPE_NORMAL
- en: To decouple the test from the dependency, we’ll replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function in the *fibonacci.ts* file with a test double. Jest can replace any module
    that has an identically named file saved in a *__mocks__* subdirectory adjacent
    to the test file during the test run. Create such a folder in the *helpers* folder
    next to the test file and place a *sum.ts* file inside it. Leave the file empty
    for now.
  prefs: []
  type: TYPE_NORMAL
- en: To enable the test double, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">jest.mock</samp>
    function, passing it the path to the original module saved in the test file. In
    [Listing 8-15](chapter8.xhtml#Lis8-15), we add this call to *fibonacci.test.ts*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-15: The test suite for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">fibonacci</samp>
    function with the test double'
  prefs: []
  type: TYPE_NORMAL
- en: This new line replaces the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    module with the test double. Now let’s create all three basic types of test doubles,
    adding their code to the file in the *__mocks__* folder.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using a Stub</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Stubs are merely objects that return some predefined data. This makes them very
    simple to implement but limited in use; often, returning the same data isn’t enough
    to mimic a dependency’s original actions. [Listing 8-16](chapter8.xhtml#Lis8-16)
    shows a stub implementation for the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function’s test double. Paste the code into the *sum.ts* file inside the *__mocks__*
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-16: A stub for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    function'
  prefs: []
  type: TYPE_NORMAL
- en: The stubbed function has the same signature as the original function. It accepts
    the same arguments, an array of numbers, and returns a string. Unlike the original,
    however, this test double always returns the same number, 999, regardless of the
    data it received.
  prefs: []
  type: TYPE_NORMAL
- en: To successfully run the test suites with this stub function, we’d need to adjust
    our expectations about what our code will do. Instead of returning five numbers
    in the Fibonacci sequence, it would produce the string <samp class="SANS_TheSansMonoCd_W5Regular_11">999,
    999, 999, 999, 999</samp>. If we see such a string, we know that the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function was called five times. Experiment with the stub, modifying the test suite’s
    expectations to match it. Then restore the matchers to those shown in [Listing
    8-15](chapter8.xhtml#Lis8-15) so that you can use them for the upcoming tests.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using a Fake</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Fakes are the most complex kind of test double. They are working implementations
    of the original functionality, but unlike the real implementation, they provide
    only the functionality necessary for the unit test. Their implementation is simplified
    and often doesn’t cater to edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: The fake for the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> adds
    the first and second items of the array manually, instead of using <samp class="SANS_TheSansMonoCd_W5Regular_11">array.reduce</samp>.
    This simplified implementation strips the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function of the ability to sum more than two data points, but for the Fibonacci
    sequence, it is sufficient. The reduced complexity makes it easy to understand
    and less prone to error. Replace the content of the *sum.ts* file inside the *__mocks__*
    folder with the code in [Listing 8-17](chapter8.xhtml#Lis8-17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-17: A fake for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    function'
  prefs: []
  type: TYPE_NORMAL
- en: Our fake uses a simple mathematical plus operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>)
    to add the first and second items of the <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp>
    parameter. Its main benefit is that it returns a result similar to that of the
    actual implementation. We can now run the test suites, and they should pass successfully
    without our having to adjust our expectations, returning the Fibonacci sequence.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using a Mock</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Mocks lie somewhere between stubs and fakes. Although less sophisticated than
    fakes, they return more realistic data than stubs. While they don’t simulate a
    dependency’s true behavior, they can react to the data they receive.
  prefs: []
  type: TYPE_NORMAL
- en: For example, our naive mock implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function will return a result from a hardcoded hash map. Replace the code in the
    *__mocks__/sum.ts* file with the code from [Listing 8-18](chapter8.xhtml#Lis8-18),
    which inspects the request and enables the Fibonacci calculator to use the original
    test suites.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-18: A mock for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">sum</samp>
    function'
  prefs: []
  type: TYPE_NORMAL
- en: We create a type, called <samp class="SANS_TheSansMonoCd_W5Regular_11">resultMap</samp>,
    that uses a string as a key and a number as a value. Then we use the newly created
    type for a hash map that stores our desired responses. Next, we define the mock
    function with the same interface as the original implementation. Inside the mock,
    we calculate the key to use in the hash map based on the parameters we receive.
    This lets us return the correct dataset and produce an actual Fibonacci sequence.
    The main benefit of using the mock over <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    is that we can control its outcome, as it returns values from a known dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Conveniently, Jest provides us with helpers to work with test doubles. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">jest.mock</samp> function replaces imported
    modules with mocks. The <samp class="SANS_TheSansMonoCd_W5Regular_11">jest.fn</samp>
    API creates a basic mock that can return any kind of predefined data, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">jest.spyOn</samp> lets us record calls
    to any function without modifying it. We will use all of those in [Exercise 8](#Exe8)
    on page 146.
  prefs: []
  type: TYPE_NORMAL
- en: In typical developer contexts, you won’t bother with the subtle differences
    between stubs, fakes, and mocks and will use the term *mock* as a generic term
    for test doubles. Don’t spend too much time overengineering your mocks; they’re
    just tools to help you test your code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Types of Tests</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tests covered in this chapter so far are the most common ones you’ll encounter
    as a full-stack developer. This section briefly explains additional types of tests
    and when to use them. These aren’t meant to replace unit tests; rather, they supplement
    unit tests by covering specific aspects of your implementation that aren’t otherwise
    testable. For example, because unit tests run in isolation, they can’t evaluate
    the interaction between modules. Theoretically, if every function and module passes
    its test, the whole program should work as expected. Practically, you’ll often
    face issues caused by faulty module documentation. Commonly, the documentation
    will claim that an API returns a specific type, but the actual implementation
    will return a different one.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Functional Tests</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While unit tests examine the implementation of a feature from a developer’s
    perspective, *functional tests* cover the user’s perspective by verifying that
    code works as the user expects it to work. Put otherwise, these tests check that
    a given input results in an expected output. Most functional tests are a type
    of *black-box* test, which ignores the module’s internal code, side effects, and
    intermediate results and tests only the interfaces. Functional tests do not generate
    a code-coverage report. Generally, a quality assurance manager will write and
    use functional tests during a system testing stage. By contrast, developers write
    and use unit tests during development.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integration Tests</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You learned that the goal of a unit test is to check the smallest possible section
    of code in isolation. An *integration test* is the complete opposite. It verifies
    the behavior of entire subsystems, whether they be layers of code, such as an
    app’s data storage mechanism, or specific functions consisting of multiple modules.
    Integration tests check the integration of the subsystem in the context of the
    current environment. Hence, they never run in isolation and typically don’t use
    test doubles.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests are helpful for finding three types of problems. The first
    type is problems related to *inter-module communication*, which is the communication
    between modules. Common problems are faulty internal API integrations and undetected
    side effects, such as a function that doesn’t delete old files before writing
    new data to the filesystem. The second type is problems related to the *environment*,
    which describes the hardware and software setup the code runs on. Different software
    versions or hardware configurations can introduce significant issues for your
    code. The most common problem for full-stack developers involves differences in
    Node.js versions and outdated dependencies in the modules.
  prefs: []
  type: TYPE_NORMAL
- en: The third type is problems related to *gateway communications*, which relates
    to testing any API communication with a third-party API gateway. Any communication
    with external APIs should be tested with integration tests. This is the only instance
    in which integration tests might use test doubles, such as stubbed versions of
    the external API, in order to simulate a specific API behavior, like a timeout
    or successful request. As with functional tests, a quality assurance manager generally
    writes and uses integration tests. Developers do so less often.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">End-to-End Tests</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can think of the *end-to-end test* as a combination of functional tests
    and integration tests. As another kind of black-box test, they examine the application’s
    functionality across the full stack, from the frontend to the backend, in a specific
    environment. These business-facing tests should provide confidence that the overall
    application is still working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end tests run the application in a specific environment. Often, the complexity
    of the many dependencies increases the risk of flaky tests in which the application
    works correctly but the environment causes the tests to fail. End-to-end tests
    are thus the most time-consuming to create and maintain. Due to their complexity,
    we must craft them carefully. During execution, they are known to be slow, prone
    to encountering timeouts, and, like nearly all black-box tests, unable to provide
    detailed error reports. Therefore, they test only the most critical business-facing
    scenarios. Generally, a quality assurance manager writes them.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Snapshot Tests</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The tests described earlier in this chapter check the code against some assertion.
    By contrast, a *snapshot test* compares the application’s current visual (or user
    interface) state to a previous version of it. Hence, these tests are also called
    visual regression tests. In each test, we create new snapshots and then compare
    them with ones stored earlier, providing a cheap way to test user interface components
    and complete pages. Instead of manually creating and maintaining tests that describe
    every property of an interface, such as a component’s height, width, position,
    and colors, we can establish a snapshot containing all of these properties.
  prefs: []
  type: TYPE_NORMAL
- en: One way to perform this type of test is to create and compare screenshots. Generally,
    a headless browser renders the component; the test runner waits for the page to
    render and then captures an image of it. Unfortunately, this process is relatively
    slow, and headless browsers are flaky. Jest takes a different approach to snapshot
    testing. Instead of working with headless browsers and image files, it renders
    the React user interface components to the virtual DOM, serializes them, and saves
    them as plaintext in *snap* files stored in the *__snapshots__* directory. Hence,
    Jest snapshot tests are much more performant and less flawed. The Food Finder
    application you’ll build in [Part II](part2.xhtml) will use snapshot tests to
    verify the integrity of the build and test your React components.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Exercise 8: Add Test Cases to the
    Weather App</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As long as you follow the basic principles we’ve discussed, there is no right
    or wrong way to test your code. Unit, snapshot, and end-to-end tests are all different
    tools in your tool belt, and you must strike a balance between the time you spend
    writing the tests and the usefulness of each. There is also no consensus on what
    to test. While you should strive for 90 percent code coverage or higher, the general
    rule of thumb is to cover at least the most critical parts of your application
    with unit tests and then write some integration tests to verify that your application
    works on each deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to our weather application, we’ll want our test cases to cover
    four core aspects. First we’ll add unit tests to evaluate the middleware and services.
    Even though the REST API endpoints and React user interface component are easy
    to test directly in the browser, we’ll add test cases for both of them: a basic
    snapshot test for the user interface component and an end-to-end test for the
    REST API endpoint */v1/weather/[zipcode].ts*.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve opted to test the REST endpoint rather than the GraphQL API for simplicity’s
    sake, as each REST endpoint has its own file, while all GraphQL APIs share an
    entry point, making their testing more complex. However, testing this GraphQL
    API would make an excellent exercise for exploring end-to-end-tests after you’ve
    finished the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing the Middleware
    with Spies</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The middleware to connect to the database is a core part of the application,
    but we can’t access it directly, as it doesn’t expose any API. We can only implicitly
    test it by examining the database or by running a query through Mongoose, some
    service, or an API endpoint. Each of these methods would work, but if we want
    to test the connection to the database as a unit test, we need to do so in a way
    that isolates that component as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we’ll use Jest’s built-in spies to verify that our middleware successfully
    calls all the functions necessary for establishing the connection to the MongoDB
    memory server. Navigate to your *__tests__* folder and create a new folder, *middleware*,
    and a file, *db-connect.test.ts*, inside it. Then copy the code from [Listing
    8-19](chapter8.xhtml#Lis8-19) into the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-19: The __tests__/middleware/db-connect.test.ts suite for the database
    connection'
  prefs: []
  type: TYPE_NORMAL
- en: Most of this code resembles the test suites you wrote earlier in this chapter.
    But instead of testing simplified example code, we’re now testing real code, which
    requires us to make some adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: First we set the testing environment for Jest to <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp>,
    which simulates a Node.js runtime. Later, when writing snapshot tests, we’ll use
    Jest’s default environment, called <samp class="SANS_TheSansMonoCd_W5Regular_11">jsdom</samp>,
    which simulates a browser by providing a <samp class="SANS_TheSansMonoCd_W5Regular_11">window</samp>
    object, as well as all the usual DOM properties and functions. By always setting
    these environments in the file, we avoid issues caused by using the wrong environment.
    Then, as usual, we import the packages we need.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can start writing the test suite for the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>
    function. We define a <samp class="SANS_TheSansMonoCd_W5Regular_11">connection</samp>
    variable in the test suite’s scope to store the database connection, and then
    we can access the MongoDB’s server instance, including its methods and properties.
    For example, we’ll use these to stop the connection and disconnect from the server
    after each test to guarantee that each test case is independent.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to store the connection, we first need to return the <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoServer</samp>
    constant from the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>
    function in the file *db-connect.ts*. Open the file and add the line <samp class="SANS_TheSansMonoCd_W5Regular_11">return
    mongoServer</samp> to the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>
    function right before the function’s closing curly bracket (<samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>).
    From time to time, you’ll need to modify the code you wrote earlier to accommodate
    the requirements of your tests. In other words, you need to adapt the code to
    make it testable.
  prefs: []
  type: TYPE_NORMAL
- en: Now we use the connection we just exposed and set up the <samp class="SANS_TheSansMonoCd_W5Regular_11">afterEach</samp>
    hook, which runs after each test case, to reset the mocked functions to their
    initial mocked state, thus clearing all previously gathered data. This is necessary,
    because otherwise, the spies would report information gained during the previous
    calls, as they retain their state across all test suites. Also, we re-create the
    database connection for each test case. Therefore, we need to stop the current
    connection and explicitly disconnect from the database after each test. Then we
    set up the <samp class="SANS_TheSansMonoCd_W5Regular_11">afterAll</samp> hook
    to remove all mocks and restore the original functions through the <samp class="SANS_TheSansMonoCd_W5Regular_11">restoreAllMocks</samp>
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Our test cases should all follow the *arrange, act, assert* pattern. As we review
    them, you might find it useful to open the *db-connect.ts* file in the *middleware*
    folder and follow along. The initial test case verifies the call to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">create</samp> function on the <samp class="SANS_TheSansMonoCd_W5Regular_11">MongoMemoryServer</samp>,
    as this is the first function that we call in the *db-connect.ts* file. To do
    so, we create a spy with the <samp class="SANS_TheSansMonoCd_W5Regular_11">jest
    .spyOn</samp> method. As arguments, this method takes the name of an object and
    the object’s method on which to spy. Then we act on the code under test and call
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> function. Finally,
    we assert that the spy has been called.
  prefs: []
  type: TYPE_NORMAL
- en: The second test case works similarly except that it spies on a different method.
    We use it to check that <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose.disconnect</samp>
    was called successfully during the execution of <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>.
    The third test case introduces a new matcher. Instead of verifying only the call
    itself with <samp class="SANS_TheSansMonoCd_W5Regular_11">toHaveBeenCalled</samp>,
    we now also verify the call’s arguments using <samp class="SANS_TheSansMonoCd_W5Regular_11">toHaveBeenCalledWith</samp>.
    Here we grab the connection string directly from the connection and store it in
    the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">MONGO_URI</samp>. We
    also hardcode the database we want to connect to. Then we call the matcher, passing
    it the expected arguments and verifying that they meet our expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the test suites with <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    test</samp>. All tests should pass with 100 percent test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating Mocks to
    Test the Services</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While the tests we wrote for the middleware were quite simple, the service tests
    are a bit more complicated. If you open the *mongoose/weather/services.ts* file,
    you’ll see that the services depend on <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>,
    which is Mongoose’s gateway to the MongoDB collection. Each service calls a method
    on the model that, in turn, requires a database connection. We won’t reevaluate
    those database connections here; instead, the goal of this test suite will be
    to verify that the service functions call the correct <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>
    functions. To do so, we’ll create a mock <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>
    that exposes the same set of APIs as mocked functions.
  prefs: []
  type: TYPE_NORMAL
- en: We first write the mocked model. Following convention, we create the file *mongoose/weather/__mocks__/model.ts*
    and add the code in [Listing 8-20](chapter8.xhtml#Lis8-20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-20: The mock for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">WeatherModel</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We implement <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherInterface</samp>
    and define the new <samp class="SANS_TheSansMonoCd_W5Regular_11">param</samp>
    type, which is an object with key-value pairs that we use to type the first parameter.
    We make the mocked <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>
    the default export and use an object that implements the four methods of the actual
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>, each of which
    takes the same parameters as the original. They also take the original Mongoose
    model’s method. Because they are asynchronous functions, we return a promise resolved
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can write the test suite for the services. These check that each service
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> upon success
    and calls the correct method of the mocked <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>.
    Create the file */__tests__/mongoose/weather/services.test.ts* and add the code
    from [Listing 8-21](chapter8.xhtml#Lis8-21) to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-21: The updated test suite in __tests__/mongoose/weather/services.test.ts'
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous test suite, we begin by setting up the environment and importing
    modules. We also import <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>
    and call <samp class="SANS_TheSansMonoCd_W5Regular_11">jest.mock</samp> with the
    path to the mocked model we created, effectively replacing the original model
    in the code under test. Then we create a document containing some test data. We
    store it in the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">doc</samp>
    and will pass it to the mocked model’s methods. As done previously, we use the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">afterEach</samp> hook to reset all
    mocks after each test and the <samp class="SANS_TheSansMonoCd_W5Regular_11">afterAll</samp>
    hook to remove the mocks and restore the original functions after all test cases
    have been finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a nested test suite for each of the four services. Each has the same
    two unit tests: one to verify the return value upon success with the <samp class="SANS_TheSansMonoCd_W5Regular_11">toBeTruthy</samp>
    matcher and one to spy on a particular <samp class="SANS_TheSansMonoCd_W5Regular_11">WeatherModel</samp>
    mock function. The code follows the same pattern as the previous test suite and
    uses the same matchers as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code-coverage report we receive after running <samp class="SANS_TheSansMonoCd_W5Regular_11">npm
    test</samp> shows that we tested around 70 percent of the service code. If you
    take a look at the uncovered lines listed in the last column, you’ll see that
    they contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">console.log(err);</samp>
    output. This output is used whenever an asynchronous call to the model’s methods
    fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: For the purposes of this chapter, we’ll leave these lines uncovered. Otherwise,
    we could modify the mocked model to throw an error—for example, by supplying an
    invalid document—and then add a third test case per service verifying the error.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Performing an End-to-End
    Test of the REST API</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sophisticated API tests might use a dedicated API testing library such as *SuperTest*,
    which provides matchers for HTTP status codes and simplifies the handling of requests
    and responses. Alternatively, they might use a GUI tool like Postman. In this
    example, we’ll merely test that the returned data matches our expectations by
    using the native <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the previous tests, this one doesn’t isolate any single component, as
    our goal is to verify that all components of the system work together as expected.
    To check whether the API returns a proper response from the database when supplied
    some input, our end-to-end test will make certain assumptions: that all layers
    have already been tested independently, that the database contains its initial
    seed data, and that our application runs at *http://localhost:3000/*.'
  prefs: []
  type: TYPE_NORMAL
- en: To verify our first assumption, open the API endpoint file *pages/api/v1/weather/[zipcode].ts*.
    You’ll notice that the API code imports two functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">findByZip</samp>
    from the service module and the middleware’s <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>,
    both of which we’ve already tested. The second assumption is also satisfied; the
    database loads the initial seed on each startup. Create the file *zipcode.e2e
    .test.ts* in *__tests__/pages/api/v1/weather/* and add the code from [Listing
    8-22](chapter8.xhtml#Lis8-22).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-22: The test suite for the REST API'
  prefs: []
  type: TYPE_NORMAL
- en: We set the environment to <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp>
    and then define the test suite with one test case. In it, we supply a ZIP code
    that matches one of the initial seed datasets. Then we use the native <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    method, which has been available since Node.js version 17.5, to call our weather
    API on our localhost and check whether the returned ZIP code is the same as the
    one passed as a parameter. We add an empty export statement to define this file
    as an ES6 module.
  prefs: []
  type: TYPE_NORMAL
- en: The test should pass and have 100 percent code coverage. Now that we’re confident
    that the core of our application is working as expected, we can test the user
    interface components.
  prefs: []
  type: TYPE_NORMAL
- en: When using <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>, there
    are two common error messages you might encounter. The first, <samp class="SANS_TheSansMonoCd_W5Regular_11">ECONNREFUSED</samp>,
    tells you that <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp> could
    not connect to your application because it is not running. Use <samp class="SANS_TheSansMonoCd_W7Bold_B_11">npm
    run dev</samp> to start the application or adjust the port in the <samp class="SANS_TheSansMonoCd_W5Regular_11">fetch</samp>
    call if you’re not using port 3000\. The second error mentions that the test exceeded
    the timeout of 5,000 ms for a test. If you started your application for the purposes
    of testing and did not use a previously running application, Next.js compiles
    the API route as soon as the test consumes it. Depending on your environment,
    this might take longer than the default timeout. Add the line <samp class="SANS_TheSansMonoCd_W7Bold_B_11">jest.setTimeout(20000);</samp>
    before the <samp class="SANS_TheSansMonoCd_W5Regular_11">describe</samp> method
    at the top of your file to increase the timeout and make the test wait 20,000
    ms instead of 5,000 ms.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Evaluating the User
    Interface with a Snapshot Test</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Snapshot tests verify that a page’s rendered HTML didn’t change between two
    test runs. To achieve this with Jest, we must first prepare our environment. Add
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">jsdom</samp> environment, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">react-testing-library</samp>, and the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">react-test-renderer</samp> to the
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We’ll need these to simulate a browser environment and render React components
    during our test cases. Now we’ll modify the *jest.config.js* file in our root
    directory accordingly. Replace its content with the code in [Listing 8-23](chapter8.xhtml#Lis8-23).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-23: The updated jest.config.js file'
  prefs: []
  type: TYPE_NORMAL
- en: This code imports the *next/jest* package and exports a Jest configuration with
    the default properties of a Next.js project. It is the simplest form of Next.js-compatible
    Jest configuration. If you take a look at the official Next.js setup guide at
    [*https://<wbr>nextjs<wbr>.org<wbr>/docs<wbr>/testing*](https://nextjs.org/docs/testing),
    you’ll see that it outlines some basic configuration options, none of which we
    need.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The First Version</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A snapshot test renders a component or a page, takes a snapshot of it as serialized
    JSON, and stores it in a *__snapshots__* folder next to the test suite. On each
    consecutive run, Jest compares the current snapshot with the stored reference.
    As long as they are the same, the snapshot test passes. To generate the initial
    snapshot, create a new folder, *__tests__/pages/components*, and the file *weather.snapshot.test.tsx*,
    and then add the code in [Listing 8-24](chapter8.xhtml#Lis8-24) to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-24: The snapshot test for <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PageComponentWeather</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first lines of our snapshot test set the environment to <samp class="SANS_TheSansMonoCd_W5Regular_11">jsdom</samp>
    and import the test renderer’s <samp class="SANS_TheSansMonoCd_W5Regular_11">act</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">create</samp> methods to test
    the React component, which we import in the next line.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we write the simulated user behavior and wrap the component’s creation
    in the asynchronous <samp class="SANS_TheSansMonoCd_W5Regular_11">act</samp> function.
    As you might have guessed, this function draws its name from the *arrange, act,
    assert* pattern and ensures that all relevant updates to the DOM have been applied
    before proceeding with the test case. It is required for all statements that cause
    updates to the React state, and here, it delays the test execution until after
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> hook runs.
  prefs: []
  type: TYPE_NORMAL
- en: Then we write a test case that awaits the <samp class="SANS_TheSansMonoCd_W5Regular_11">create</samp>
    function, which renders the JSX component. This lets us generate HTML in a simulated
    browser environment and store the result in a variable. We await the component’s
    rendering so that the HTML is available for our follow-up interactions before
    we continue with the test case. Then we serialize the rendered component to a
    JSON string and use a new matcher, <samp class="SANS_TheSansMonoCd_W5Regular_11">toMatchSnapshot</samp>,
    which compares the current JSON string with the stored reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'A trial run shows that all tests succeed. We see two interesting things— that
    the test created one snapshot and that we achieved a test coverage of 81 percent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can look at the created snapshot by opening the *weather.snapshot.test.tsx.snap*
    file in the *__snapshots__* folder. It should look fairly similar to the code
    in [Listing 8-25](chapter8.xhtml#Lis8-25), and you’ll see that it is nothing more
    than the rendered HTML saved as a multiline template literal. Your HTML might
    not be identical to that shown here; the important aspect is that it looks the
    same after each test run when <samp class="SANS_TheSansMonoCd_W5Regular_11">react-test-renderer</samp>
    rendered the component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-25: The weather.snapshot.test.tsx.snap file with the serialized HTML'
  prefs: []
  type: TYPE_NORMAL
- en: We also see that the counter is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    which indicates that the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    did not run before we created the snapshot. If you open the component’s file and
    check the uncovered lines, you’ll learn that they relate to the click handler
    that increases the <samp class="SANS_TheSansMonoCd_W5Regular_11">state</samp>
    variable and, as suspected, the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    hook. We want to test these core functionalities as well.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Second Version</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ll modify the test code to cover the previously untested functionalities.
    Paste the code from [Listing 8-26](chapter8.xhtml#Lis8-26) into the snapshot test
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-26: The updated snapshot test'
  prefs: []
  type: TYPE_NORMAL
- en: In the updated code, we’ve added another test case that finds the headline on
    the page and simulates a user clicking it. Remember from previous chapters that
    this increases the state variable <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp>.
    Again, we await the creation of the component and use the <samp class="SANS_TheSansMonoCd_W5Regular_11">act</samp>
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you rerun the tests, you should see a failure. The test runner tells us
    that the snapshots do not match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Because we modified the test case to wait for the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    hook and set the state variable <samp class="SANS_TheSansMonoCd_W5Regular_11">counter</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>,
    the DOM changed as well. Follow the test runner’s advice and rerun the tests with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">npm test -- -u</samp> to create
    a new, updated snapshot. The tests should now succeed, reporting a test coverage
    of 100 percent for our component.
  prefs: []
  type: TYPE_NORMAL
- en: Try experimenting with your newfound knowledge. For example, can you write a
    snapshot test for the page routes in the *pages* directory or a set of end-to-end
    tests for the GraphQL API?
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should now be able to create automated tests with Jest and, more broadly,
    design a testing plan on your own to strike a balance between effort and reward.
    We discussed the benefits of TDD and unit testing and then used the *arrange,
    act, assert* pattern to develop a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp>
    function following test-driven principles. Next, we used three types of test doubles
    to replace the <samp class="SANS_TheSansMonoCd_W5Regular_11">sum</samp> function
    while calculating the Fibonacci sequence. Finally, we added unit and snapshot
    tests to our existing Next.js application, created a mock of a Mongoose model,
    and used spies to verify our assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about Jest and automated testing, consult the official Jest documentation
    at [*https://<wbr>jestjs<wbr>.io<wbr>/docs<wbr>/getting<wbr>-started*](https://jestjs.io/docs/getting-started).
    In the next chapter, you’ll explore the differences between authorization and
    authentication and how you can leverage OAuth in your applications.
  prefs: []
  type: TYPE_NORMAL
