["```\n#include <termios.h>\n\nint `tcgetattr`(int *fd*, struct termios **termios_p*);\nint `tcsetattr`(int *fd*, int *optional_actions*, const struct termios **termios_p*);\n```", "```\nstruct termios {\n    tcflag_t c_iflag;           /* Input flags */\n    tcflag_t c_oflag;           /* Output flags */\n    tcflag_t c_cflag;           /* Control flags */\n    tcflag_t c_lflag;           /* Local modes */\n    cc_t     c_line;            /* Line discipline (nonstandard)*/\n    cc_t     c_cc[NCCS];        /* Terminal special characters */\n    speed_t  c_ispeed;          /* Input speed (nonstandard; unused) */\n    speed_t  c_ospeed;          /* Output speed (nonstandard; unused) */\n};\n```", "```\nstruct termios tp;\n\nif (tcgetattr(STDIN_FILENO, &tp) == -1)\n    errExit(\"tcgetattr\");\ntp.c_lflag &= ~ECHO;\nif (tcsetattr(STDIN_FILENO, TCSAFLUSH, &tp) == -1)\n    errExit(\"tcsetattr\");\n```", "```\n$ `stty -a`\nspeed 38400 baud; rows 25; columns 80; line = 0;\nintr = ^C; quit = ^\\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>;\neol2 = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R;\nwerase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;\n-parenb -parodd cs8 hupcl -cstopb cread -clocal -crtscts\n-ignbrk brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr\n icrnl ixon -ixoff -iuclc -ixany imaxbel -iutf8\nopost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0\nisig icanon iexten echo echoe echok -echonl -noflsh\n -xcase -tostop -echoprt echoctl echoke\n```", "```\n$ `stty intr ^L`                  *Make the interrupt character Control-L*\n```", "```\n$ `stty intr` *Control-V Control-L*\n```", "```\n$ `stty intr q`                   *Make the interrupt character q*\n```", "```\n$ `stty tostop`                   *Enable the* TOSTOP *flag*\n$ `stty -tostop`                  *Disable the* TOSTOP *flag*\n```", "```\n*Control-J* `stty sane` *Control-J*\n```", "```\n$ `su`                            *Need privilege to access another userâ€™s terminal*\nPassword:\n# `stty -a -F /dev/tty3`          *Fetch attributes for terminal* /dev/tty3\n*Output omitted for brevity*\n```", "```\n# `stty -a < /dev/tty3`\n```", "```\n$ `./new_intr 12`\n$ `stty`\nspeed 38400 baud; line = 0;\nintr = ^L;\n```", "```\n$ `sleep 10`\n^C                              *Control-C has no effect; it is just echoed*\n*Type Control-L to terminate sleep*\n```", "```\n$ `echo $?`\n130\n```", "```\n$ `./new_intr`\n$ `stty`                          *Verify the change*\nspeed 38400 baud; line = 0;\nintr = <undef>;\n```", "```\n$ `sleep 10`\n^C^L                            *Control-C and Control-L are simply echoed*\n*Type Control-\\ to generate* SIGQUIT\nQuit\n$ `stty sane`                     *Return terminal to a sane state*\n```", "```\n`tty/new_intr.c`\n#include <termios.h>\n#include <ctype.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    struct termios tp;\n    int intrChar;\n\n    if (argc > 1 && strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s [intr-char]\\n\", argv[0]);\n\n    /* Determine new INTR setting from command line */\n\n    if (argc == 1) {                                     /* Disable */\n        intrChar = fpathconf(STDIN_FILENO, _PC_VDISABLE);\n        if (intrChar == -1)\n            errExit(\"Couldn't determine VDISABLE\");\n    } else if (isdigit((unsigned char) argv[1][0])) {\n        intrChar = strtoul(argv[1], NULL, 0);           /* Allows hex, octal */\n    } else {                                            /* Literal character */\n        intrChar = argv[1][0];\n    }\n\n    /* Fetch current terminal settings, modify INTR character, and\n       push changes back to the terminal driver */\n\n    if (tcgetattr(STDIN_FILENO, &tp) == -1)\n        errExit(\"tcgetattr\");\n    tp.c_cc[VINTR] = intrChar;\n    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &tp) == -1)\n        errExit(\"tcsetattr\");\n\n    exit(EXIT_SUCCESS);\n}\n      `tty/new_intr.c`\n```", "```\n\\PASSWORD:\n```", "```\n$ `./no_echo`\nEnter text:                           *We type some text, which is not echoed,*\nRead: Knock, knock, Neo.              *but was nevertheless read*\n```", "```\n`tty/no_echo.c`\n#include <termios.h>\n#include \"tlpi_hdr.h\"\n\n#define BUF_SIZE 100\n\nint\nmain(int argc, char *argv[])\n{\n    struct termios tp, save;\n    char buf[BUF_SIZE];\n\n    /* Retrieve current terminal settings, turn echoing off */\n\n    if (tcgetattr(STDIN_FILENO, &tp) == -1)\n        errExit(\"tcgetattr\");\n    save = tp;                          /* So we can restore settings later */\n    tp.c_lflag &= ~ECHO;                /* ECHO off, other bits unchanged */\n    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &tp) == -1)\n        errExit(\"tcsetattr\");\n\n    /* Read some input and then display it back to the user */\n\n    printf(\"Enter text: \");\n    fflush(stdout);\n    if (fgets(buf, BUF_SIZE, stdin) == NULL)\n        printf(\"Got end-of-file/error on fgets()\\n\");\n    else\n        printf(\"\\nRead: %s\", buf);\n\n    /* Restore original terminal settings */\n\n    if (tcsetattr(STDIN_FILENO, TCSANOW, &save) == -1)\n        errExit(\"tcsetattr\");\n\n    exit(EXIT_SUCCESS);\n}\n      `tty/no_echo.c`\n```", "```\n`tty/tty_functions.c`\n#include <termios.h>\n#include <unistd.h>\n#include \"tty_functions.h\"              /* Declares functions defined here */\n\n/* Place terminal referred to by 'fd' in cbreak mode (noncanonical mode\n   with echoing turned off). This function assumes that the terminal is\n   currently in cooked mode (i.e., we shouldn't call it if the terminal\n   is currently in raw mode, since it does not undo all of the changes\n   made by the ttySetRaw() function below). Return 0 on success, or -1\n   on error. If 'prevTermios' is non-NULL, then use the buffer to which\n   it points to return the previous terminal settings. */\n\nint\nttySetCbreak(int fd, struct termios *prevTermios)\n{\n    struct termios t;\n\n    if (tcgetattr(fd, &t) == -1)\n        return -1;\n\n    if (prevTermios != NULL)\n        *prevTermios = t;\n\n    t.c_lflag &= ~(ICANON | ECHO);\n    t.c_lflag |= ISIG;\n\n    t.c_iflag &= ~ICRNL;\n\n    t.c_cc[VMIN] = 1;                   /* Character-at-a-time input */\n    t.c_cc[VTIME] = 0;                  /* with blocking */\n\n    if (tcsetattr(fd, TCSAFLUSH, &t) == -1)\n        return -1;\n\n    return 0;\n}\n\n/* Place terminal referred to by 'fd' in raw mode (noncanonical mode\n   with all input and output processing disabled). Return 0 on success,\n   or -1 on error. If 'prevTermios' is non-NULL, then use the buffer to\n   which it points to return the previous terminal settings. */\n\nint\nttySetRaw(int fd, struct termios *prevTermios)\n{\n    struct termios t;\n\n    if (tcgetattr(fd, &t) == -1)\n        return -1;\n\n    if (prevTermios != NULL)\n        *prevTermios = t;\n\n    t.c_lflag &= ~(ICANON | ISIG | IEXTEN | ECHO);\n                        /* Noncanonical mode, disable signals, extended\n                           input processing, and echoing */\n\n    t.c_iflag &= ~(BRKINT | ICRNL | IGNBRK | IGNCR | INLCR |\n                      INPCK | ISTRIP | IXON | PARMRK);\n                        /* Disable special handling of CR, NL, and BREAK.\n                           No 8th-bit stripping or parity error handling.\n                           Disable START/STOP output flow control. */\n\n    t.c_oflag &= ~OPOST;                /* Disable all output processing */\n\n    t.c_cc[VMIN] = 1;                   /* Character-at-a-time input */\n    t.c_cc[VTIME] = 0;                  /* with blocking */\n\n    if (tcsetattr(fd, TCSAFLUSH, &t) == -1)\n        return -1;\n\n    return 0;\n}\n      `tty/tty_functions.c`\n```", "```\n`tty/test_tty_functions.c`\n    #include <termios.h>\n    #include <signal.h>\n    #include <ctype.h>\n    #include \"tty_functions.h\"              /* Declarations of ttySetCbreak()\n                                               and ttySetRaw() */\n    #include \"tlpi_hdr.h\"\n\nstatic struct termios userTermios;\n                            /* Terminal settings as defined by user */\n\n    static void             /* General handler: restore tty settings and exit */\n    handler(int sig)\n    {\n    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &userTermios) == -1)\n            errExit(\"tcsetattr\");\n        _exit(EXIT_SUCCESS);\n    }\n\n    static void             /* Handler for SIGTSTP */\ntstpHandler(int sig)\n    {\n        struct termios ourTermios;          /* To save our tty settings */\n        sigset_t tstpMask, prevMask;\n        struct sigaction sa;\n        int savedErrno;\n\n        savedErrno = errno;                 /* We might change 'errno' here */\n\n        /* Save current terminal settings, restore terminal to\n           state at time of program startup */\n\n    if (tcgetattr(STDIN_FILENO, &ourTermios) == -1)\n            errExit(\"tcgetattr\");\n    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &userTermios) == -1)\n            errExit(\"tcsetattr\");\n\n        /* Set the disposition of SIGTSTP to the default, raise the signal\n           once more, and then unblock it so that we actually stop */\n\n        if (signal(SIGTSTP, SIG_DFL) == SIG_ERR)\n            errExit(\"signal\");\n        raise(SIGTSTP);\n\n        sigemptyset(&tstpMask);\n        sigaddset(&tstpMask, SIGTSTP);\n        if (sigprocmask(SIG_UNBLOCK, &tstpMask, &prevMask) == -1)\n            errExit(\"sigprocmask\");\n\n        /* Execution resumes here after SIGCONT */\n\n        if (sigprocmask(SIG_SETMASK, &prevMask, NULL) == -1)\n            errExit(\"sigprocmask\");         /* Reblock SIGTSTP */\n\n            sigemptyset(&sa.sa_mask);           /* Reestablish handler */\n        sa.sa_flags = SA_RESTART;\n        sa.sa_handler = tstpHandler;\n        if (sigaction(SIGTSTP, &sa, NULL) == -1)\n            errExit(\"sigaction\");\n\n        /* The user may have changed the terminal settings while we were\n           stopped; save the settings so we can restore them later */\n\n    if (tcgetattr(STDIN_FILENO, &userTermios) == -1)\n            errExit(\"tcgetattr\");\n\n        /* Restore our terminal settings */\n\n    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &ourTermios) == -1)\n            errExit(\"tcsetattr\");\n\n        errno = savedErrno;\n    }\n\n    int\n    main(int argc, char *argv[])\n    {\n        char ch;\n        struct sigaction sa, prev;\n        ssize_t n;\n\n        sigemptyset(&sa.sa_mask);\n        sa.sa_flags = SA_RESTART;\n\n    if (argc > 1) {                     /* Use cbreak mode */\n        if (ttySetCbreak(STDIN_FILENO, &userTermios) == -1)\n                errExit(\"ttySetCbreak\");\n\n            /* Terminal special characters can generate signals in cbreak\n               mode. Catch them so that we can adjust the terminal mode.\n               We establish handlers only if the signals are not being ignored. */\n\n        sa.sa_handler = handler;\n\n            if (sigaction(SIGQUIT, NULL, &prev) == -1)\n                errExit(\"sigaction\");\n            if (prev.sa_handler != SIG_IGN)\n                if (sigaction(SIGQUIT, &sa, NULL) == -1)\n                    errExit(\"sigaction\");\n\n            if (sigaction(SIGINT, NULL, &prev) == -1)\n                errExit(\"sigaction\");\n            if (prev.sa_handler != SIG_IGN)\n                if (sigaction(SIGINT, &sa, NULL) == -1)\n                    errExit(\"sigaction\");\n\n        sa.sa_handler = tstpHandler;\n                if (sigaction(SIGTSTP, NULL, &prev) == -1)\n                errExit(\"sigaction\");\n            if (prev.sa_handler != SIG_IGN)\n                if (sigaction(SIGTSTP, &sa, NULL) == -1)\n                    errExit(\"sigaction\");\n        } else {                            /* Use raw mode */\n        if (ttySetRaw(STDIN_FILENO, &userTermios) == -1)\n                errExit(\"ttySetRaw\");\n        }\n\n    sa.sa_handler = handler;\n        if (sigaction(SIGTERM, &sa, NULL) == -1)\n            errExit(\"sigaction\");\n\n        setbuf(stdout, NULL);               /* Disable stdout buffering */\n\n    for (;;) {                          /* Read and echo stdin */\n            n = read(STDIN_FILENO, &ch, 1);\n            if (n == -1) {\n                errMsg(\"read\");\n                break;\n            }\n\n            if (n == 0)                     /* Can occur after terminal disconnect */\n                break;\n\n        if (isalpha((unsigned char) ch))          /* Letters --> lowercase */\n                putchar(tolower((unsigned char) ch));\n            else if (ch == '\\n' || ch == '\\r')\n                putchar(ch);\n            else if (iscntrl((unsigned char) ch))\n                printf(\"^%c\", ch ^ 64);     /* Echo Control-A as ^A, etc. */\n            else\n                putchar('*');               /* All other chars as '*' */\n\n        if (ch == 'q')                  /* Quit loop */\n                break;\n        }\n\n    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &userTermios) == -1)\n            errExit(\"tcsetattr\");\n        exit(EXIT_SUCCESS);\n    }\n          `tty/test_tty_functions.c`\n```", "```\n$ `stty`                              *Initial terminal mode is sane (cooked)*\nspeed 38400 baud; line = 0;\n$ `./test_tty_functions`\n`abc`                                 *Type abc, and Control-J*\n   `def`                              *Type DEF, Control-J, and Enter*\n`^C^Z`                                *Type Control-C, Control-Z, and Control-J*\n    `q`$                              *Type q to exit*\n```", "```\n$ `./test_tty_functions x`\n`XYZ`                                 *Type XYZ and Control-Z*\n[1]+  Stopped       ./test_tty_functions x\n$ `stty`                              *Verify that terminal mode was restored*\nspeed 38400 baud; line = 0;\n$ `fg`                                *Resume in foreground*\n./test_tty_functions x\n***                                 *Type 123 and Control-J*\n   $                                *Type Control-C to terminate program*\n*Press Enter to get next shell prompt*\n$ `stty`                              *Verify that terminal mode was restored*\nspeed 38400 baud; line = 0;\n```", "```\n#include <termios.h>\n\nspeed_t `cfgetispeed`(const struct termios **termios_p*);\nspeed_t `cfgetospeed`(const struct termios **termios_p*);\n```", "```\nint `cfsetospeed`(struct termios **termios_p*, speed_t *speed*);\nint `cfsetispeed`(struct termios **termios_p*, speed_t *speed*);\n```", "```\nstruct termios tp;\nspeed_t rate;\n\nif (tcgetattr(fd, &tp) == -1)\n    errExit(\"tcgetattr\");\nrate = cfgetospeed(&tp);\nif (rate == -1)\n    errExit(\"cfgetospeed\");\n```", "```\nif (cfsetospeed(&tp, B38400) == -1)\n    errExit(\"cfsetospeed\");\nif (tcsetattr(fd, TCSAFLUSH, &tp) == -1)\n    errExit(\"tcsetattr\");\n```", "```\n#include <termios.h>\n\nint `tcsendbreak`(int *fd*, int *duration*);\nint `tcdrain`(int *fd*);\nint `tcflush`(int *fd*, int *queue_selector*);\nint `tcflow`(int *fd*, int *action*);\n```", "```\nif (ioctl(fd, TIOCGWINSZ, &ws) == -1)\n    errExit(\"ioctl\");\n```", "```\nstruct winsize {\n    unsigned short ws_row;          /* Number of rows (characters) */\n    unsigned short ws_col;          /* Number of columns (characters) */\n    unsigned short ws_xpixel;       /* Horizontal size (pixels) */\n    unsigned short ws_ypixel;       /* Vertical size (pixels) */\n};\n```", "```\n$ `./demo_SIGWINCH`\nCaught SIGWINCH, new window size: 35 rows * 80 columns\nCaught SIGWINCH, new window size: 35 rows * 73 columns\nCaught SIGWINCH, new window size: 22 rows * 73 columns\n*Type Control-C to terminate program*\n```", "```\n`tty/demo_SIGWINCH.c`\n#include <signal.h>\n#include <termios.h>\n#include <sys/ioctl.h>\n#include \"tlpi_hdr.h\"\n\nstatic void\nsigwinchHandler(int sig)\n{\n}\n\nint\nmain(int argc, char *argv[])\n{\n    struct winsize ws;\n    struct sigaction sa;\n\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = 0;\n    sa.sa_handler = sigwinchHandler;\n    if (sigaction(SIGWINCH, &sa, NULL) == -1)\n        errExit(\"sigaction\");\n\n    for (;;) {\n        pause();                        /* Wait for SIGWINCH signal */\n\n        if (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) == -1)\n            errExit(\"ioctl\");\n        printf(\"Caught SIGWINCH, new window size: \"\n                \"%d rows * %d columns\\n\", ws.ws_row, ws.ws_col);\n    }\n}\n     `tty/demo_SIGWINCH.c`\n```", "```\nws.ws_row = 40;\nws.ws_col = 100;\nif (ioctl(fd, TIOCSWINSZ, &ws) == -1)\n    errExit(\"ioctl\");\n```", "```\n#include <unistd.h>\n\nint `isatty`(int *fd*);\n```", "```\n#include <unistd.h>\n\nchar *`ttyname`(int *fd*);\n```"]