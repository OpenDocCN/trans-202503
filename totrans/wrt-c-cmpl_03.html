<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch2">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_24" aria-label="24"/>&#13;
<figure class="co-img"><img id="fig-pg24" class="img40" src="../images/pg24.jpg" alt="" width="691" height="1289"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-05.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_25" aria-label="25"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch2">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">UNARY OPERATORS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro">C has several <i>unary operators</i>, which operate on a single value. In this chapter, you’ll extend your compiler to handle two unary operators: negation and bitwise complement. You’ll transform complex, nested unary expressions into simple operations that can be expressed in assembly. Instead of performing this transformation in a single compiler pass, you’ll introduce a new intermediate representation between the AST produced by the parser and the assembly AST produced by the assembly generation pass. You’ll also break up assembly generation into several smaller passes. The new passes are bolded in the diagram at the start of this chapter.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_26" aria-label="26"/>To get started, let’s look at a C program using the new unary operators and the corresponding assembly we’ll generate.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-19"/><samp class="SANS_Futura_Std_Bold_B_11">Negation and Bitwise Complement in Assembly</samp></h3>&#13;
<p class="TNI">In this chapter, you’ll learn to compile programs like <a href="chapter2.xhtml#list2-1">Listing 2-1</a>.</p>&#13;
<a id="list2-1"/>&#13;
<pre><code>int main(void) {&#13;
    return ~(-2);&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-1: A C program with negation and bitwise complement</samp></p>&#13;
<p class="TX">This program contains a nested expression using both new unary operators. The first operator, <i>negation</i> (<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>), negates an integer—no surprise there. The <i>bitwise complement</i> (<samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>) operator flips every bit in an integer, which has the effect of negating the integer and then subtracting one. (It has this effect because computers use a system called <i>two’s complement</i> to represent signed integers. If you’re not familiar with two’s complement, see <span class="Xref">“Additional Resources” on <a href="#pg_45">page 45</a></span> for links to a few explanations of how it works.)</p>&#13;
<p class="TX">Your compiler will convert <a href="chapter2.xhtml#list2-1">Listing 2-1</a> to the assembly code in <a href="chapter2.xhtml#list2-2">Listing 2-2</a>.</p>&#13;
<a id="list2-2"/>&#13;
<pre><code>    .globl main&#13;
main:&#13;
    pushq   %rbp&#13;
    movq     %rsp, %rbp&#13;
    subq     $8, %rsp&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> movl     $2, <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> -4(%rbp)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> negl     -4(%rbp)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> movl     -4(%rbp), %r10d&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> movl     %r10d, -8(%rbp)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span> notl     -8(%rbp)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation7">❼</span> movl     -8(%rbp), %eax&#13;
    movq     %rbp, %rsp&#13;
    popq     %rbp&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-2: The assembly code for <a href="chapter2.xhtml#list2-1">Listing 2-1</a></samp></p>&#13;
<p class="TX">The first three instructions after <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> form the <i>function prologue</i>, which sets up the current stack frame; I’ll cover them in the next section, when I talk about the stack in detail. After the function prologue, we calculate the intermediate result, –2, and then the final result, 1, storing each of them at a unique memory address. This isn’t very efficient, since we waste a lot of instructions copying values from one address to another. The optimizations we’ll implement in <span class="Xref-1"><a href="part3.xhtml">Part III</a></span> will clean up most of these unnecessary copies.</p>&#13;
<p class="TX">The first <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction <span class="CodeAnnotation" aria-label="annotation1">❶</span> stores <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> at an address in memory. The operand <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span> means “the value stored in the RBP register, minus four.” The value in RBP is a memory address on the stack (more on this shortly), <span role="doc-pagebreak" epub:type="pagebreak" id="pg_27" aria-label="27"/>so <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp> refers to another memory address 4 bytes lower. Next, we negate the value at this address with the <samp class="SANS_TheSansMonoCd_W5Regular_11">neg</samp> instruction <span class="CodeAnnotation" aria-label="annotation3">❸</span>, so <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp> contains the value <samp class="SANS_TheSansMonoCd_W5Regular_11">-2</samp>. (Just like <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">neg</samp> has an <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> suffix to indicate that it’s operating on a 32-bit value.)</p>&#13;
<p class="TX">We then handle the outer bitwise complement expression. We start by copying the source value, stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>, to the destination address at <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>. We can’t do this in a single instruction, because <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> can’t have memory addresses as both its source and destination operands. At least one operand to <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> needs to be a register or an immediate value. We get around this by copying <samp class="SANS_TheSansMonoCd_W5Regular_11">-2</samp> from memory into a scratch register, R10D <span class="CodeAnnotation" aria-label="annotation4">❹</span>, and from there to the destination memory address <span class="CodeAnnotation" aria-label="annotation5">❺</span>. Then, we take the bitwise complement of <samp class="SANS_TheSansMonoCd_W5Regular_11">-2</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> instruction <span class="CodeAnnotation" aria-label="annotation6">❻</span>, so memory address <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp> now contains the value we want to return: <samp class="SANS_TheSansMonoCd_W5Regular_11">~(-2)</samp>, which evaluates to 1. To return this value, we move it into EAX <span class="CodeAnnotation" aria-label="annotation7">❼</span>. The final three instructions are the <i>function epilogue</i>, which tears down the stack frame and returns from the function.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>If you compile <a href="chapter2.xhtml#list2-1">Listing 2-1</a> to assembly using GCC, Clang, or any other production C compiler, it won’t look anything like <a href="chapter2.xhtml#list2-2">Listing 2-2</a>. That’s because those compilers evaluate constant expressions at compile time, even when you’ve disabled optimizations! I’m guessing they behave this way because some constant expressions, like static variable initializers,</i> <span class="note_Italic">must</span> <i>be evaluated at compile time, and evaluating all constant expressions at compile time is simpler than evaluating only some.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-20"/><samp class="SANS_Futura_Std_Bold_B_11">The Stack</samp></h3>&#13;
<p class="TNI">There are still two unanswered questions about <a href="chapter2.xhtml#list2-2">Listing 2-2</a>: what the function prologue and epilogue do, and why we refer to stack addresses relative to a value in the RBP register. To answer these questions, we need to talk about the segment of program memory called the <i>stack</i>. The RSP register, also called the <i>stack pointer</i>, always holds the address of the top of the stack. (RSP points to the last used stack slot, rather than the first free one.) As with any stack data structure, you can push values onto the stack and pop values off it; the <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> assembly instructions do exactly that.</p>&#13;
<p class="TX">The stack grows toward lower memory addresses. When you push something onto the stack, you decrement RSP. That means the “top of the stack”—the address stored in RSP—is the <i>lowest</i> address on the stack. The stack diagrams in this book are oriented with lower memory addresses at the top, so the top of the stack is at the top of the diagram. Think of the memory addresses in these diagrams like line numbers in a code listing. The top of a code listing is line 1, and line numbers increase as you go down; similarly, the addresses in these diagrams increase as you go down the page or screen. Note that most stack diagrams in other books and articles use the opposite orientation: they put the top of the stack at the bottom of the diagram, so lower memory addresses appear lower on the page. I find that layout really confusing, but if you prefer it, just turn your book upside down.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_28" aria-label="28"/>An instruction like <samp class="SANS_TheSansMonoCd_W5Regular_11">push $3</samp> does two things:</p>&#13;
<ol class="NL">&#13;
<li class="NL">Writes the value being pushed (in this example, <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>) to the next empty spot on the stack. The <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> instructions adjust the stack pointer in 8-byte increments, and the top value on the stack is currently at the address stored in RSP, so the next empty spot is RSP – 8.</li>&#13;
<li class="NL">Decrements RSP by 8 bytes. The new address in RSP is now the top of the stack, and the value at that address is <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>.</li>&#13;
</ol>&#13;
<p class="TX"><a href="#fig2-1">Figure 2-1</a> illustrates the effect of a <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instruction on the stack and RSP register.</p>&#13;
<figure class="IMG"><img class="img100" id="fig2-1" src="../images/fig2-1.jpg" alt="" width="1662" height="842"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: The effect of push $3 on memory and RSP <a href="description-06.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> instruction performs the opposite operation. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">pop %rax</samp> copies the value at the top of the stack into the RAX register, then adds 8 bytes to RSP.</p>&#13;
<p class="TX">Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instruction decrements the stack pointer by 8 bytes, it has to push an 8-byte value. Likewise, the <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> instruction always pops an 8-byte value off the stack. Values of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>—like the return value in <a href="chapter2.xhtml#list2-1">Listing 2-1</a>—are only 4 bytes. You can’t push only 4 bytes onto the stack, but you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> to copy a 4-byte value into stack space you’ve already allocated. A couple of instructions do this in <a href="chapter2.xhtml#list2-2">Listing 2-2</a>, including <samp class="SANS_TheSansMonoCd_W5Regular_11">movl $2, -4(%rbp)</samp>. (On 32-bit systems, the reverse is true; you can push and pop 4-byte values but not 8-byte values. On both kinds of systems, it’s also possible, though very unusual, to push and pop 2-byte values using the <samp class="SANS_TheSansMonoCd_W5Regular_11">pushw</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">popw</samp> instructions; the <samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp> suffix, for <i>word</i>, indicates that the instruction takes a 2-byte operand. We won’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">pushw</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">popw</samp>, or any other 2-byte instructions in this book.) Memory addresses on x64 systems are 8 bytes, so you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_29" aria-label="29"/>and <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> to put them on and take them off the stack. This will come in handy in a moment.</p>&#13;
<p class="TX">The stack isn’t just an undifferentiated chunk of memory; it’s divided into sections called <i>stack frames</i>. Whenever a function is called, it allocates some memory at the top of the stack by decreasing the stack pointer. This memory is the function’s stack frame, where it stores local variables and temporary values. Just before the function returns, it deallocates its stack frame, restoring the stack pointer to its previous value. By convention, the RBP register points to the base of the current stack frame; for this reason, it’s sometimes called the <i>base pointer</i>. We refer to data in the current stack frame relative to the address stored in RBP. This means we don’t need absolute addresses, which we can’t know in advance. Since the stack grows toward lower memory addresses, every address in the current stack frame is lower than the address stored in RBP; this is why the addresses of local variables, like <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp>, all have negative offsets from RBP. In later chapters, we’ll also refer to data in the caller’s stack frame, like function parameters, relative to RBP. (It’s possible to refer to local variables and parameters relative to RSP instead, and not bother with RBP at all; most production compilers do this as an optimization.)</p>&#13;
<p class="TX">Now that you understand how the stack works, let’s look at the function prologue and epilogue in more detail. The function prologue sets up the stack frame in three instructions:</p>&#13;
<ol class="NL">&#13;
<li class="NL"><samp class="SANS_TheSansMonoCd_W5Regular_11">pushq %rbp</samp> saves the current value of RBP, the address of the base of the caller’s stack frame, onto the stack. We’ll need this value when we restore the caller’s stack frame later. This value will be at the bottom of the new stack frame established by the next instruction.</li>&#13;
<li class="NL"><samp class="SANS_TheSansMonoCd_W5Regular_11">movq %rsp, %rbp</samp> makes the top of the stack the base of the new stack frame. At this point, the top and bottom of the current stack frame are the same. The current stack frame holds exactly one value, which both RSP and RBP point to: the base of the caller’s stack frame, which we saved in the previous instruction.</li>&#13;
<li class="NL"><samp class="SANS_TheSansMonoCd_W5Regular_11">subq $</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, %rsp</samp> decrements the stack pointer by <i>n</i> bytes. The stack frame now has <i>n</i> bytes available to store local and temporary variables.</li>&#13;
</ol>&#13;
<p class="TX"><a href="#fig2-2">Figure 2-2</a> shows how each instruction in the function prologue affects the stack. In this figure, the <samp class="SANS_TheSansMonoCd_W5Regular_11">subq</samp> instruction allocates 24 bytes, enough space for six 4-byte integers.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_30" aria-label="30"/>&#13;
<figure class="IMG"><img class="img100" id="fig2-2" src="../images/fig2-2.jpg" alt="" width="1685" height="1663"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: The state of the stack at each point in the function prologue <a href="description-07.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The function epilogue restores the caller’s stack frame by setting RSP and RBP back to the same values they had before the function prologue. This requires two instructions:</p>&#13;
<ol class="NL">&#13;
<li class="NL"><samp class="SANS_TheSansMonoCd_W5Regular_11">movq %rbp, %rsp</samp> puts us back where we were after the second instruction of the function prologue: both RSP and RBP point to the bottom of the current stack frame, which holds the caller’s value for RBP.</li>&#13;
<li class="NL"><samp class="SANS_TheSansMonoCd_W5Regular_11">popq %rbp</samp> reverses the first instruction of the function prologue and restores the caller’s values for the RSP and RBP registers. It restores RBP because the value at the top of the stack was the base address of the caller’s stack frame that we saved at the start of the prologue. It restores RSP by removing the last value in this stack frame from the stack, leaving RSP pointing to the top of the caller’s stack frame.</li>&#13;
</ol>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_31" aria-label="31"/><a href="#fig2-3">Figure 2-3</a> shows the effect of each instruction in the function epilogue.</p>&#13;
<figure class="IMG"><img class="img100" id="fig2-3" src="../images/fig2-3.jpg" alt="" width="1687" height="1318"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-3: The state of the stack at each point in the function epilogue <a href="description-08.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now that we know what output our compiler should produce, let’s keep coding. We’ll start by extending the lexer and parser.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H1" id="sec3"><span id="h1-21"/><samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp></h3>&#13;
<p class="TNI">In this chapter, you’ll extend the lexer to recognize three new tokens:</p>&#13;
<table class="Basic-Table-ind">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table" scope="col"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">~</samp></p></th>&#13;
<th class="Basic-Table" scope="col"><p class="TB2">A tilde, the bitwise complement operator</p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">-</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">A hyphen, the negation operator</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table"><p class="TB2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">--</samp></p></td>&#13;
<td class="Basic-Table"><p class="TB2">Two hyphens, the decrement operator</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">While you won’t implement the decrement operator in this chapter, you still need to add a token for it. Otherwise, your compiler will accept programs it should reject, like the one in <a href="chapter2.xhtml#list2-3">Listing 2-3</a>.</p>&#13;
<a id="list2-3"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_32" aria-label="32"/>int main(void) {&#13;
    return --2;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-3: An invalid C program using the decrement operator</samp></p>&#13;
<p class="TX">This shouldn’t compile, because you can’t decrement a constant. But if your compiler doesn’t know that <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> is a distinct token, it will think <a href="chapter2.xhtml#list2-3">Listing 2-3</a> is equivalent to <a href="chapter2.xhtml#list2-4">Listing 2-4</a>, which is a perfectly valid program.</p>&#13;
<a id="list2-4"/>&#13;
<pre><code>int main(void) {&#13;
    return -(-2);&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-4: A valid C program with two negation operators in a row</samp></p>&#13;
<p class="TX">Your compiler should reject language features you haven’t implemented; it shouldn’t compile them incorrectly. That’s why your lexer needs to know that <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> is a single token, not just two negation operators in a row. (On the other hand, the lexer should lex <samp class="SANS_TheSansMonoCd_W5Regular_11">~~</samp> as two bitwise complement operators in a row. Expressions like <samp class="SANS_TheSansMonoCd_W5Regular_11">~~2</samp> are valid.)</p>&#13;
<p class="TX">You can process the new tokens the same way you handled punctuation like <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp>in <span class="Xref-1"><a href="chapter1.xhtml">Chapter 1</a></span>. First, you need to define a regular expression for each new token. The regular expressions here are the strings <samp class="SANS_TheSansMonoCd_W5Regular_11">~</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>. Next, have your lexer check the input against these new regexes, as well as the regexes from the previous chapter, every time it tries to produce a token. When the start of the input stream matches more than one possible token, choose the longest one. For example, if your input stream starts with <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>, parse it as a decrement operator rather than two negation operators.</p>&#13;
<aside class="box" aria-label="box-73"><p class="BoxTitle" id="box-73"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE LEXER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test your lexer, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 2 --stage lex</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">This command will validate that your compiler can successfully lex all the test cases for this chapter, including the valid test programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_2/valid</samp> <samp class="SANS_Futura_Std_Book_11">and the invalid test programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_2/invalid_parse</samp><samp class="SANS_Futura_Std_Book_11">. It will also run the lexing test cases from <a href="chapter1.xhtml">Chapter 1</a>, to make sure your lexer can still handle them.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_33" aria-label="33"/>&#13;
<h3 class="H1" id="sec4"><span id="h1-22"/><samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp></h3>&#13;
<p class="TNI">To parse the new operators in this chapter, we first need to extend the AST and formal grammar we defined in <span class="Xref-1"><a href="chapter1.xhtml">Chapter 1</a></span>. Let’s look at the AST first. Since unary operations are expressions, we represent them with a new constructor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST node. <a href="chapter2.xhtml#list2-5">Listing 2-5</a> shows the updated AST definition, with new parts bolded.</p>&#13;
<a id="list2-5"/>&#13;
<pre><code>program = Program(function_definition)&#13;
function_definition = Function(identifier name, statement body)&#13;
statement = Return(exp)&#13;
exp = Constant(int) | <b>Unary(unary_operator, exp)</b>&#13;
<b>unary_operator = Complement | Negate</b></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-5: The abstract syntax tree with unary operations</samp></p>&#13;
<p class="TX">The updated rule for <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> indicates that an expression can be either a constant integer or a unary operation. A unary operation consists of one of the two unary operators, <samp class="SANS_TheSansMonoCd_W5Regular_11">Complement</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp>, applied to an inner expression. Notice that the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> is recursive: the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> constructor for an <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> node contains another <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> node. This lets us construct arbitrarily deeply nested expressions, like <samp class="SANS_TheSansMonoCd_W5Regular_11">-(~(-~-(-4)))</samp>.</p>&#13;
<p class="TX">We also need to make the corresponding changes to the grammar, shown in <a href="chapter2.xhtml#list2-6">Listing 2-6</a>.</p>&#13;
<a id="list2-6"/>&#13;
<pre><code>&lt;program&gt; ::= &lt;function&gt;&#13;
&lt;function&gt; ::= "int" &lt;identifier&gt; "(" "void" ")" "{" &lt;statement&gt; "}"&#13;
&lt;statement&gt; ::= "return" &lt;exp&gt; ";"&#13;
&lt;exp&gt; ::= &lt;int&gt; <b>| &lt;unop&gt; &lt;exp&gt; | "(" &lt;exp&gt; ")"</b>&#13;
<b>&lt;unop&gt; ::= "-" | "~"</b>&#13;
&lt;identifier&gt; ::= ? An identifier token ?&#13;
&lt;int&gt; ::= ? A constant token ?</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-6: The formal grammar with unary operations</samp></p>&#13;
<p class="TX"><a href="chapter2.xhtml#list2-6">Listing 2-6</a> includes a new production rule for unary expressions and a <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;unop&gt;</samp> symbol to represent the two unary operators. These changes correspond to the additions to the AST in <a href="chapter2.xhtml#list2-5">Listing 2-5</a>. We’ve also added a third production rule for the <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> symbol, which describes a parenthesized expression. It doesn’t have a corresponding constructor in the AST because the rest of the compiler doesn’t need to distinguish between an expression wrapped in parentheses and the same expression without parentheses. The expressions <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">(1)</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">((((1))))</samp> are all represented by the same AST node: <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(1)</samp>.</p>&#13;
<p class="TX">The decrement operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>) doesn’t show up anywhere in this grammar, so your parser should fail if it encounters a <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> token.</p>&#13;
<p class="TX">To update the parsing stage, modify your compiler’s AST data structure to match <a href="chapter2.xhtml#list2-5">Listing 2-5</a>. Then, update your recursive descent parsing code to reflect the changes in <a href="chapter2.xhtml#list2-6">Listing 2-6</a>. Parsing an expression gets a bit more complicated in this chapter because you need to figure out which of the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_34" aria-label="34"/>three different production rules for the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt;</samp> symbol to apply. The pseudocode in <a href="chapter2.xhtml#list2-7">Listing 2-7</a> demonstrates how to parse an expression.</p>&#13;
<a id="list2-7"/>&#13;
<pre><code>parse_exp(tokens):&#13;
    next_token = peek(tokens)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if next_token is an int:&#13;
        <var>--snip--</var>&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> else if next_token is "~" or "-":&#13;
        operator = parse_unop(tokens)&#13;
        inner_exp = parse_exp(tokens)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> return Unary(operator, inner_exp)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> else if next_token == "(":&#13;
        take_token(tokens)&#13;
        inner_exp = parse_exp(tokens)&#13;
        expect(")", tokens)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> return inner_exp&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation6">❻</span> else:&#13;
        fail("Malformed expression")</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-7: Parsing an expression</samp></p>&#13;
<p class="TX">First, we look at the next token in the input to figure out which production rule to apply. We call <samp class="SANS_TheSansMonoCd_W5Regular_11">peek</samp> to look at this token without removing it from the input stream. Once we know which production rule to use, we’ll want to process the whole input, including that first token, using that rule. So, we don’t want to consume this token from the input just yet.</p>&#13;
<p class="TX">If the expression we’re about to parse is valid, <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp> should be an integer, a unary operator, or an open parenthesis. If it’s an integer <span class="CodeAnnotation" aria-label="annotation1">❶</span>, we parse it the same way as in the previous chapter. If it’s a unary operator <span class="CodeAnnotation" aria-label="annotation2">❷</span>, we apply the second production rule for <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt;</samp> from <a href="chapter2.xhtml#list2-6">Listing 2-6</a> to construct a unary expression. This rule is <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;unop&gt; &lt;exp&gt;</samp>, so we parse the unary operator and then the inner expression. The <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;unop&gt;</samp> symbol is a single token, <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp>, which we’ve already inspected. In <a href="chapter2.xhtml#list2-7">Listing 2-7</a>, we handle <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;unop&gt;</samp> in a separate function (<samp class="SANS_TheSansMonoCd_W5Regular_11">parse_unop</samp>, whose definition I’ve omitted). In practice, you probably don’t need a separate function to parse one token. Either way, we end up with an AST node representing the appropriate unary operator. The next symbol in the production rule is <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt;</samp>, which we parse with a recursive call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>. (This is the recursive part of “recursive descent.”) This call should return an <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST node representing the operand of the unary expression. Now we have AST nodes for both the operator and the operand, so we return the AST node for the whole unary expression <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp> is an open parenthesis <span class="CodeAnnotation" aria-label="annotation4">❹</span>, we apply the third production rule for <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt;</samp>, which is <samp class="SANS_TheSansMonoCd_W5Regular_11">"(" &lt;exp&gt; ")"</samp> . We remove the open parenthesis from the input stream, then call <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> recursively to handle the expression that follows. Next, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">expect</samp> to remove the closing parenthesis or throw a syntax error if it’s missing. Since the AST doesn’t need to indicate that there were parentheses, we return the inner expression as is <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">Finally, if <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp> isn’t an integer, a unary operator, or an open parenthesis <span class="CodeAnnotation" aria-label="annotation6">❻</span>, the expression is malformed, so we throw a syntax error.</p>&#13;
<aside class="box" aria-label="box-74"><p class="BoxTitle" id="box-74"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_35" aria-label="35"/><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE PARSER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test your parser against the test cases from this chapter and the last chapter, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 2 --stage parse</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Your parser should be able to handle every valid test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_2/valid</samp><samp class="SANS_Futura_Std_Book_11">, and it should raise an error on every invalid test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_2/invalid_parse</samp><samp class="SANS_Futura_Std_Book_11">. It should also continue to handle valid and invalid test cases from the last chapter correctly.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h1-23"/><samp class="SANS_Futura_Std_Bold_B_11">TACKY: A New Intermediate Representation</samp></h3>&#13;
<p class="TNI">Converting the AST to assembly isn’t as straightforward as it was in the last chapter. C expressions can have nested subexpressions, and assembly instructions can’t. A single expression like <samp class="SANS_TheSansMonoCd_W5Regular_11">-(~2)</samp> needs to be broken up into two assembly instructions: one to apply the inner bitwise complement operation and another to apply the outer negation operation.</p>&#13;
<p class="TX">We’ll bridge the gap between C and assembly using a new intermediate representation (IR), <i>three-address code (TAC)</i>. In TAC, the operands of each instruction are constants or variables, not nested expressions. It’s called three-address code because most instructions use at most three values: two source operands and a destination. (The instructions in this chapter use only one or two values; we’ll introduce instructions that use three values when we implement binary operators in <span class="Xref-1"><a href="chapter3.xhtml">Chapter 3</a></span>.) To rewrite nested expressions in TAC, we often need to introduce new temporary variables. For example, <a href="chapter2.xhtml#list2-8">Listing 2-8</a> shows the three-address code for <samp class="SANS_TheSansMonoCd_W5Regular_11">return 1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * 3;</samp>.</p>&#13;
<a id="list2-8"/>&#13;
<pre><code>tmp0 = 2 * 3&#13;
tmp1 = 1 + tmp0&#13;
return tmp1</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-8: The three-address code for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">return 1 + 2 * 3;</samp></p>&#13;
<p class="TX">There are two main reasons to use three-address code instead of converting an AST directly to assembly. First, it lets us handle major structural transformations—like removing nested expressions—separately from the details of assembly language, like figuring out which operands are valid for which instructions. This means we can write several smaller, simpler compiler passes, instead of having one huge, complicated assembly generation pass. Second, three-address code is well suited to several optimizations we’ll implement in <span class="Xref-1"><a href="part3.xhtml">Part III</a></span>. It has a simple, uniform structure, which makes it easy to answer questions like “Is the result of this expression ever used?” or “Will this variable always have the same value?” The answers to those questions determine what optimizations are safe to perform.</p>&#13;
<aside class="box" aria-label="box-75"><p class="BoxTitle" id="box-75"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_36" aria-label="36"/><samp class="SANS_Dogma_OT_Bold_B_11">MULTIPLE LANGUAGES, MULTIPLE TARGETS</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Intermediate representations like three-address code are useful for another reason, although it isn’t relevant to this project. An IR can provide a common target for multiple source languages and a common starting point for assembly generation for multiple target architectures. The LLVM compiler framework (</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11"><a href="https://llvm.org">https://<wbr/>llvm<wbr/>.org</a></samp><samp class="SANS_Futura_Std_Book_11">) is a great example of this: it supports several frontends and backends using a single intermediate representation. If you want to compile a new programming language, you can just compile it to the LLVM IR, and LLVM will take care of optimizing that IR and producing machine code for different CPU architectures. Or, if you want to run software on some exotic new CPU architecture, you can just write a backend that converts the LLVM IR into machine code for that architecture. Then, you’ll be able to take any language with an LLVM frontend and compile it for that architecture.</samp></p>&#13;
</aside>&#13;
<p class="TX">Most compilers use some form of three-address code internally, but the details vary. I’ve decided to name the intermediate representation in this book <i>TACKY</i>. (Naming your intermediate representations is, in my opinion, one of the best parts of compiler design.) I made up TACKY for this book, but it’s similar to three-address code in other compilers.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-11"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining TACKY</samp></h4>&#13;
<p class="TNI">We’ll define TACKY in ASDL, like our other intermediate representations. The definition of TACKY in <a href="chapter2.xhtml#list2-9">Listing 2-9</a> looks similar to the AST definition from <a href="chapter2.xhtml#list2-5">Listing 2-5</a>, but there are a few important differences.</p>&#13;
<a id="list2-9"/>&#13;
<pre><code>program = Program(function_definition)&#13;
function_definition = Function(identifier, <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> instruction* body)&#13;
instruction = Return(val) | Unary(unary_operator, val src, val dst)&#13;
val = Constant(int) | Var(identifier)&#13;
unary_operator = Complement | Negate</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-9: The TACKY intermediate representation</samp></p>&#13;
<p class="TX">In TACKY, a function body consists of a list of instructions <span class="CodeAnnotation" aria-label="annotation1">❶</span> rather than a single statement. In this respect, it’s similar to the assembly AST we defined in the previous chapter. For now, TACKY has two instructions: <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>. <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> returns a value; <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> performs some unary operation on <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>, the source value for the expression, and stores the result in <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>, the destination. Both instructions operate on <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp>s, which can be either constant integers (<samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp>) or temporary variables (<samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>). The TACKY we generate must meet one requirement that isn’t explicit in <a href="chapter2.xhtml#list2-9">Listing 2-9</a>: the <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> of a unary operation must be a temporary <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>, not a <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp>. Trying to assign a value to a constant wouldn’t make sense.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_37" aria-label="37"/>Now that you’ve seen the ASDL definition of TACKY, you’ll need to implement this definition in your own compiler, much like the definitions of the AST and assembly AST. Once you have your TACKY data structure, you’re ready to write the IR generation stage, which converts the AST to TACKY.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-12"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating TACKY</samp></h4>&#13;
<p class="TNI">Your TACKY generation pass should traverse an AST in the form defined in <a href="chapter2.xhtml#list2-5">Listing 2-5</a> and return a TACKY AST in the form defined in <a href="chapter2.xhtml#list2-9">Listing 2-9</a>. The tricky part is turning an <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> node into a list of instructions; once you have that figured out, handling the other AST nodes is easy. <a href="chapter2.xhtml#tab2-1">Table 2-1</a> lists a few examples of ASTs and the resulting TACKY.</p>&#13;
<p class="TT" id="tab2-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 2-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">TACKY Representations of Unary Expressions</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">AST</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Return(Constant(3))</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Return(Constant(3))</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Return(Unary(Complement, Constant(2)))</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(Complement, Constant(2), Var("tmp.0")) Return(Var("tmp.0"))</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><pre class="table"><code>Return(Unary(Negate,&#13;
	     Unary(Complement,&#13;
		  Unary(Negate, Constant(8)))))</code></pre></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(Negate, Constant(8), Var("tmp.0"))</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(Complement, Var("tmp.0"), Var("tmp.1"))</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(Negate, Var("tmp.1"), Var("tmp.2")) Return(Var("tmp.2"))</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">In these examples, we convert each unary operation into a <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> TACKY instruction, starting with the innermost expression and working our way out. We store the result of each <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> instruction in a temporary variable, which we then use in the outer expression or <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement. <a href="chapter2.xhtml#list2-10">Listing 2-10</a> describes how to convert an <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST node to TACKY.</p>&#13;
<a id="list2-10"/>&#13;
<pre><code>emit_tacky(e, instructions):&#13;
    match e with&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> | Constant(c) -&gt;&#13;
        return <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> Constant(c)&#13;
    | Unary(op, inner) -&gt;&#13;
        src = emit_tacky(inner, instructions)&#13;
        dst_name = make_temporary()&#13;
        dst = Var(dst_name)&#13;
        tacky_op = convert_unop(op)&#13;
        instructions.append(Unary(tacky_op, src, dst))&#13;
        return dst</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-10: Converting an expression into a list of TACKY instructions</samp></p>&#13;
<p class="TX">This pseudocode emits the instructions needed to calculate an expression by appending them to the <samp class="SANS_TheSansMonoCd_W5Regular_11">instructions</samp> argument. It also returns a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp> that represents the result of the expression, which we’ll use when translating the outer expression or statement.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">match</samp> statement in <a href="chapter2.xhtml#list2-10">Listing 2-10</a> checks which type of expression we’re translating, then runs the clause to handle that expression. If the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_38" aria-label="38"/>expression is a constant, we return the equivalent TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp> without generating any new instructions. Note that this code includes two different <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp> constructs; the one we match on is a node in the original AST <span class="CodeAnnotation" aria-label="annotation1">❶</span>, while the one we return is a node in the TACKY AST <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The same is true for the two <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> constructs that appear in the following clause.</p>&#13;
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp> is a unary expression, we construct TACKY values for the source and destination. First, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp> recursively on the source expression to get the corresponding TACKY value. This also generates the TACKY instructions to calculate that value. Then, we create a new temporary variable for the destination. The <samp class="SANS_TheSansMonoCd_W5Regular_11">make_temporary</samp> helper function generates a unique name for this variable. We use another helper function, <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_unop</samp>, to convert the unary operator to its TACKY equivalent. Once we have our source, destination, and unary operator, we construct the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> TACKY instruction and append it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">instructions</samp> list. Finally, we return <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> as the result of the whole expression.</p>&#13;
<p class="TX">Keep in mind that <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp> processes an expression, not a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement. You need a separate function (which I won’t provide pseudocode for) to convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement to TACKY. This function should call <samp class="SANS_TheSansMonoCd_W5Regular_11">emit_tacky</samp> to process the statement’s return value, then emit a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> instruction.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-13"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generating Names for Temporary Variables</samp></h4>&#13;
<p class="TNI">It’s clear that every temporary variable needs a distinct name. In later chapters, we’ll also need to guarantee that these autogenerated names won’t conflict with user-defined names for functions and global variables, or with autogenerated names from different functions. These identifiers must all be unique because we’ll store all of them—autogenerated names and user-defined function and variable names—in the same table.</p>&#13;
<p class="TX">One simple solution is to maintain a global integer counter; to generate a unique name, increment the counter and use its new value as the name of the temporary variable. This name won’t conflict with other temporary names because the counter produces a new value each time we increment it. It won’t conflict with user-defined identifiers because integers aren’t valid identifiers in C. In <a href="chapter2.xhtml#tab2-1">Table 2-1</a>, I used a variation on this approach, concatenating a descriptive string, a period, and the value of the global counter to produce unique identifiers like <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp.0</samp>. These won’t conflict with user-defined identifiers because C identifiers can’t contain periods. With this naming scheme, you can encode useful information in autogenerated names, like the name of the function where they’re used. (It’s less useful if you name every variable <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp</samp>, like I’ve done here.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-14"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Updating the Compiler Driver</samp></h4>&#13;
<p class="TNI">To test out the TACKY generator, you need to add a new <samp class="SANS_TheSansMonoCd_W5Regular_11">--tacky</samp> command line option to run your compiler through the TACKY generation stage, stopping before assembly generation. Like the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">--lex</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">--parse</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">--codegen</samp> options, this new option shouldn’t produce any output.</p>&#13;
<aside class="box" aria-label="box-76"><p class="BoxTitle" id="box-76"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_39" aria-label="39"/><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE TACKY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">The TACKY generation stage should handle every valid test case from this chapter and the previous one without throwing an error. To test this stage, the test script will run the whole compiler through TACKY generation and check whether it succeeds or fails. You can run those tests with:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 2 --stage tacky</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">This stage shouldn’t encounter any invalid test cases, because the lexer and parser should catch them first.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span id="h1-24"/><samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp></h3>&#13;
<p class="TNI">TACKY is closer to assembly, but it still doesn’t specify exactly which assembly instructions we need. The next step is converting the program from TACKY into the assembly AST we defined in the last chapter. We’ll do this in three small compiler passes. First, we’ll produce an assembly AST, but still refer to temporary variables directly. Next, we’ll replace those variables with concrete addresses on the stack. That step will result in some invalid instructions because many x64 assembly instructions can’t use memory addresses for both operands. So, in the last compiler pass, we’ll rewrite the assembly AST to fix any invalid instructions.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-15"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting TACKY to Assembly</samp></h4>&#13;
<p class="TNI">We’ll start by extending the assembly AST we defined in the last chapter. We need some new constructs to represent the <samp class="SANS_TheSansMonoCd_W5Regular_11">neg</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> instructions from <a href="chapter2.xhtml#list2-2">Listing 2-2</a>. We also need to decide how to represent the function prologue and epilogue in the assembly AST.</p>&#13;
<p class="TX">There are a few different ways to handle the prologue and epilogue. We could add the <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp> instructions to the assembly AST. We could add high-level instructions that correspond to the entire prologue and epilogue, instead of maintaining a one-to-one correspondence between assembly AST constructs and assembly instructions. Or we could leave out the function prologue and epilogue entirely and add them during code emission. I’ll use a combination of the first and last options. This chapter’s assembly AST, shown in <a href="chapter2.xhtml#list2-11">Listing 2-11</a>, includes a construct corresponding to the <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp> instruction (the third instruction in the function prologue). This construct specifies how many bytes we need to subtract from the stack pointer. The assembly AST doesn’t include the other instructions from the prologue and epilogue; these instructions are always the same, so we can add them during code emission. That said, the other approaches to representing the function prologue and epilogue will also work, so choose whichever you like best.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_40" aria-label="40"/>We’ll also introduce <i>pseudoregisters</i> to represent temporary variables. We use pseudoregisters as operands in assembly instructions, like real registers; the only difference is that we have an unlimited supply of them. Because they aren’t real registers, they can’t appear in the final assembly program; they’ll need to be replaced by real registers or memory addresses in a later compiler pass. For now, we’ll assign every pseudoregister to a distinct address in memory. In <span class="Xref-1"><a href="part3.xhtml">Part III</a></span>, we’ll write a <i>register allocator</i>, which assigns as many pseudoregisters as possible to hardware registers instead of memory addresses.</p>&#13;
<p class="TX"><a href="chapter2.xhtml#list2-11">Listing 2-11</a> shows the updated assembly AST, with the new parts bolded.</p>&#13;
<a id="list2-11"/>&#13;
<pre><code>program = Program(function_definition)&#13;
function_definition = Function(identifier name, instruction* instructions)&#13;
instruction = Mov(operand src, operand dst)&#13;
            <b>| Unary(unary_operator, operand)</b>&#13;
            <b>| AllocateStack(int)</b>&#13;
            | Ret&#13;
<b>unary_operator = Neg | Not</b>&#13;
operand = Imm(int) | <b>Reg(reg) | Pseudo(identifier) | Stack(int)</b>&#13;
<b>reg = AX | R10</b></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-11: The assembly AST with unary operators</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">instruction</samp> node has a couple of new constructors to represent our new assembly instructions. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> constructor represents a single <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">neg</samp> instruction. It takes one operand that’s used as both source and destination. The <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> constructor represents the third instruction in the function prologue, <samp class="SANS_TheSansMonoCd_W5Regular_11">subq $</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, %rsp</samp>. Its one child, an integer, indicates the number of bytes we subtract from RSP.</p>&#13;
<p class="TX">We also have several new instruction operands. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg</samp> constructor represents a hardware register. It can specify either hardware register we’ve seen so far: EAX or R10D. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp> operand lets us use an arbitrary identifier as a pseudoregister. We use this to refer to the temporary variables we produced while generating TACKY. Ultimately, we need to replace every pseudoregister with a location on the stack; we represent those with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> operand, which indicates the stack address at the given offset from RBP. For example, we’d represent the operand <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp> with the assembly AST node <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(-4)</samp>.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Every hardware register has several aliases, depending on how many bytes of the register you need. EAX refers to the lower 32 bits of the 64-bit RAX register, and R10D refers to the lower 32 bits of the 64-bit R10 register. The names AL and R10B refer to the lower 8 bits of RAX and R10, respectively. Register names in the assembly AST are size agnostic, so AX in <a href="chapter2.xhtml#list2-11">Listing 2-11</a> can refer to the register alias RAX, EAX, or AL, depending on context. (The name AX normally refers to the lower 16 bytes of RAX, but we won’t use 16-byte register aliases in this book.)</i></p>&#13;
<p class="TX">Now we can write a straightforward conversion from TACKY to assembly, shown in <a href="chapter2.xhtml#tab2-2">Tables 2-2</a> through <a href="chapter2.xhtml#tab2-5">2-5</a>. As <a href="chapter2.xhtml#tab2-2">Table 2-2</a> illustrates, we <span role="doc-pagebreak" epub:type="pagebreak" id="pg_41" aria-label="41"/>convert TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Program</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Function</samp> nodes to the corresponding assembly constructs.</p>&#13;
<p class="TT" id="tab2-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 2-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting Top-Level TACKY Constructs to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">We’ll convert each TACKY instruction to a sequence of assembly instructions, as shown in <a href="chapter2.xhtml#tab2-3">Table 2-3</a>. Since our new assembly instructions use the same operand for the source and destination, we copy the source value into the destination before issuing a unary <samp class="SANS_TheSansMonoCd_W5Regular_11">neg</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">not</samp> instruction.</p>&#13;
<p class="TT" id="tab2-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 2-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Instructions to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(val, Reg(AX)) Ret</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(unary_operator, src, dst)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(src, dst) Unary(unary_operator, dst)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><a href="chapter2.xhtml#tab2-4">Table 2-4</a> shows the corresponding assembly <samp class="SANS_TheSansMonoCd_W5Regular_11">unary_operator</samp> for each TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">unary_operator</samp>, and <a href="chapter2.xhtml#tab2-5">Table 2-5</a> shows the conversion from TACKY operands to assembly operands.</p>&#13;
<p class="TT" id="tab2-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 2-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Arithmetic Operators to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY operator</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operator</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Complement</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Neg</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab2-5"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 2-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Operands to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(int)</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Var(identifier)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo(identifier)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Note that we’re not using the <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> instruction yet; we’ll add it in the very last pass before code emission, once we know how many bytes we need to allocate. We’re also not using any <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> operands; we’ll replace every <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp> operand with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> operand in the next compiler pass. And we’re not using the R10D register; we’ll introduce it when we rewrite invalid instructions.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_42" aria-label="42"/>&#13;
<h4 class="H2" id="sec12"><span id="h2-16"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudoregisters</samp></h4>&#13;
<p class="TNI">Next, we write a compiler pass to replace each <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp> operand with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> operand, leaving the rest of the assembly AST unchanged. In <a href="chapter2.xhtml#list2-2">Listing 2-2</a>, we used two stack locations: <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-8(%rbp)</samp>. This pass follows the same pattern: we replace the first temporary variable we see with <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(-4)</samp>, the next with <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(-8)</samp>, and so on. We subtract four for each new variable, since every temporary variable is a 4-byte integer. You’ll need to maintain a map from identifiers to offsets as you go so you can replace each pseudoregister with the same address on the stack every time it appears. For example, if you process the instructions</p>&#13;
<pre><code>Mov(Imm(2), Pseudo("a"))&#13;
Unary(Neg, Pseudo("a"))</code></pre>&#13;
<p class="BodyContinued">you should replace <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo("a")</samp> with the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> operand in both instructions.</p>&#13;
<p class="TX">This compiler pass should also return the stack offset of the final temporary variable, because that tells us how many bytes to allocate on the stack in the next pass.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h2-17"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up Instructions</samp></h4>&#13;
<p class="TNI">Now we need to traverse the assembly AST one more time and make two small fixes. First, we’ll insert the <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> instruction at the very beginning of the instruction list in the <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>. The integer argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> should be the stack offset of the last temporary variable we allocated in the previous compiler pass. That way, we’ll allocate enough space on the stack to accommodate every address we use. For example, if we replace three temporary variables, replacing the last one with <samp class="SANS_TheSansMonoCd_W5Regular_11">-12(%rbp)</samp>, we’ll insert <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack(12)</samp> at the front of the instruction list.</p>&#13;
<p class="TX">The second fix is rewriting invalid <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instructions. When we replaced pseudoregisters with stack addresses, we may have ended up with <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instructions where both the source and destination are <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> operands. This happens when the unary expression in your program has at least one level of nesting. But <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>, like many other instructions, can’t have memory addresses as both the source and the destination. If you try to assemble a program with an instruction like <samp class="SANS_TheSansMonoCd_W5Regular_11">movl -4(%rbp), -8(%rbp)</samp>, the assembler will reject it. When you encounter an invalid <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction, rewrite it to first copy from the source address into R10D and then copy from R10D to the destination. For example, the instruction</p>&#13;
<pre><code>movl    -4(%rbp), -8(%rbp)</code></pre>&#13;
<p class="BodyContinued">becomes:</p>&#13;
<pre><code>movl    -4(%rbp), %r10d&#13;
movl    %r10d, -8(%rbp)</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_43" aria-label="43"/>I’ve chosen R10D as a scratch register because it doesn’t serve any other special purpose. Some registers are required by particular instructions; for example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> instruction, which performs division, requires the dividend to be stored in EAX. Other registers are used to pass arguments during function calls. Using any of these registers for scratch at this stage could cause conflicts. For example, you might copy a function argument into the correct register, but then accidentally overwrite it while using that register to transfer a different value between memory addresses. Because R10D doesn’t have any special purpose, we don’t have to worry about these conflicts.</p>&#13;
<aside class="box" aria-label="box-77"><p class="BoxTitle" id="box-77"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE ASSEMBLY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Once you’ve implemented all the passes in the assembly generation stage, use the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">--codegen</samp> <samp class="SANS_Futura_Std_Book_11">option to test them out:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 2 --stage codegen</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">You may also want to write your own unit tests for the individual assembly generation passes.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h3 class="H1" id="sec14"><span id="h1-25"/><samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp></h3>&#13;
<p class="TNI">Finally, we’ll extend the code emission stage to handle our new constructs and print out the function prologue and epilogue. <a href="chapter2.xhtml#tab2-6">Tables 2-6</a> through <a href="chapter2.xhtml#tab2-9">2-9</a> show how to print out each assembly construct. New constructs and changes to the way we emit existing constructs are bolded.</p>&#13;
<p class="TX"><a href="chapter2.xhtml#tab2-6">Table 2-6</a> shows how to include the prologue when you emit an assembly <samp class="SANS_TheSansMonoCd_W5Regular_11">Function</samp>.</p>&#13;
<p class="TT" id="tab2-6"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 2-6:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Top-Level Assembly Constructs</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp></p></td>&#13;
<td class="Basic-Table TBF"><pre class="table"><code><samp class="SANS_Futura_Std_Book_11">Print out the function definition. On Linux, add at end of file:</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">    .section .note.GNU-stack,"",@progbits</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">    .globl</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;name&gt;</samp>&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;name&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">    pushq    %rbp</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">    movq    {@}%rsp, %rbp</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">    &lt;instructions&gt;</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_44" aria-label="44"/><a href="chapter2.xhtml#tab2-7">Table 2-7</a> shows how to include the function epilogue just before the <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp> instruction and how to emit the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> instructions.</p>&#13;
<p class="TT" id="tab2-7"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 2-7:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Instructions</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(src, dst)</samp></p></td>&#13;
<td class="Basic-Table TBF"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp><samp class="SANS_Futura_Std_Book_11">     </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;dst&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">movq    %rbp, %rsp</samp>&#13;
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">popq    %rbp </samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Unary(unary_operator, operand)</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;unary_operator&gt;    &lt;operand&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">AllocateStack(int)</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">subq    $</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;int&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, %rsp</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">As this table illustrates, you should emit <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> as a <samp class="SANS_TheSansMonoCd_W5Regular_11">subq</samp> instruction. Emit <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> as a <samp class="SANS_TheSansMonoCd_W5Regular_11">negl</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">notl</samp> instruction, according to its <samp class="SANS_TheSansMonoCd_W5Regular_11">unary_operator</samp> argument. <a href="chapter2.xhtml#tab2-8">Table 2-8</a> shows which <samp class="SANS_TheSansMonoCd_W5Regular_11">unary_operator</samp> corresponds to each of these instructions.</p>&#13;
<p class="TT" id="tab2-8"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 2-8:</samp></span> <samp class="SANS_Futura_Std_Book_11">Instruction Names for Assembly Operators</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operator</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Instruction name</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Neg</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">negl</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Not</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">notl</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Finally, <a href="chapter2.xhtml#tab2-9">Table 2-9</a> shows how to print out the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack</samp> operands.</p>&#13;
<p class="TT" id="tab2-9"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 2-9:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Operands</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(AX)</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%eax</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(R10)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r10d</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Stack(int)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;int&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">(%rbp)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;int&gt;</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Because RBP and RSP contain memory addresses, which are 8 bytes, we always operate on them using quadword instructions, which have a <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> suffix. The <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction in <a href="chapter2.xhtml#tab2-7">Table 2-7</a> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">movq</samp> instruction in the prologue and epilogue are identical apart from the size of their operands.</p>&#13;
<aside class="box" aria-label="box-78"><p class="BoxTitle" id="box-78"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_45" aria-label="45"/><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE WHOLE COMPILER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Once you’ve updated the code emission stage, your compiler should produce correct assembly for all the test cases in this chapter and the previous one. To test it out, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 2</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">This compiles the valid examples, runs them, and verifies the return code. It also runs the invalid examples, but you’ve already confirmed that the parser rejects them.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1" id="sec15"><span id="h1-26"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">In this chapter, you extended your compiler to implement negation and bitwise complement. You also implemented a new intermediate representation, wrote two new compiler passes that transform assembly code, and learned how stack frames are structured. Next, you’ll implement binary operations like addition and subtraction. The changes to the backend in the next chapter are pretty simple; the tricky part is getting the parser to respect operator precedence and associativity.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h3 class="H1" id="sec16"><span id="h1-27"/><samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp></h3>&#13;
<p class="TNI">This chapter touched on <i>two’s complement</i>, which is how all modern computers represent signed integers. Two’s complement will show up throughout this book, so it’s worth taking the time to understand it. Here are a couple of overviews of how it works:</p>&#13;
<ul class="BL">&#13;
<li class="ListBullet">“Two’s Complement” by Thomas Finley covers how and why two’s complement representations work (<i><a href="https://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html">https://<wbr/>www<wbr/>.cs<wbr/>.cornell<wbr/>.edu<wbr/>/~tomf<wbr/>/notes<wbr/>/cps104<wbr/>/twoscomp<wbr/>.html</a></i>).</li>&#13;
<li class="ListBullet"><a href="chapter2.xhtml">Chapter 2</a> of <i>The Elements of Computing Systems</i> by Noam Nisan and Shimon Schocken (MIT Press, 2005) covers similar material from a more hardware-focused perspective. This is the companion book for the Nand to Tetris project. This chapter is freely available at <i><a href="https://www.nand2tetris.org/course">https://<wbr/>www<wbr/>.nand2tetris<wbr/>.org<wbr/>/course</a></i>; click the book icon under “Project 2: Boolean Arithmetic.”</li>&#13;
</ul>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>