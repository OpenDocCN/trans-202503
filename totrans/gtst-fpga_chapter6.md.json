["```\nassign o_Data = !i_Sel1 & !i_Sel0 ? i_Data0 :\n                !i_Sel1 &  i_Sel0 ? i_Data1 :\n                 i_Sel1 & !i_Sel0 ? i_Data2 : i_Data3;\n```", "```\no_Data <= i_Data0 when i_Sel1 = '0' and i_Sel0 = '0' else\n          i_Data1 when i_Sel1 = '0' and i_Sel0 = '1' else\n          i_Data2 when i_Sel1 = '1' and i_Sel0 = '0' else\n          i_Data3;\n```", "```\nmodule Demux_1_To_4\n (input  i_Data,\n  input  i_Sel1,\n  input  i_Sel0,\n  output o_Data0,\n  output o_Data1,\n  output o_Data2,\n  output o_Data3);\n❶ assign o_Data0 = !i_Sel1 & !i_Sel0 ? i_Data : 1'b0;\nassign o_Data1 = !i_Sel1 &  i_Sel0 ? i_Data : 1'b0;\nassign o_Data2 = i_Sel1 & !i_Sel0 ? i_Data : 1'b0;\nassign o_Data3 = i_Sel1 &  i_Sel0 ? i_Data : 1'b0;\nendmodule\n```", "```\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nentity Demux_1_To_4 is\n  port (\n    i_Data  : in  std_logic;\n    i_Sel0  : in  std_logic;\n    i_Sel1  : in  std_logic;\n    o_Data0 : out std_logic;\n    o_Data1 : out std_logic;\n    o_Data2 : out std_logic;\n    o_Data3 : out std_logic);\nend entity Demux_1_To_4;\narchitecture RTL of Demux_1_To_4 is\nbegin\n❶ o_Data0 <= i_Data when i_Sel1 = '0' and i_Sel0 = '0' else '0';\n  o_Data1 <= i_Data when i_Sel1 = '0' and i_Sel0 = '1' else '0';\n  o_Data2 <= i_Data when i_Sel1 = '1' and i_Sel0 = '0' else '0';\n  o_Data3 <= i_Data when i_Sel1 = '1' and i_Sel0 = '1' else '0';\nend architecture RTL;\n```", "```\n❶ reg [3:0] r_Shift;\nalways @ (posedge i_Clk)\n  begin\n  ❷ r_Shift[0]   <= i_Data_To_Delay;\n  ❸ r_Shift[3:1] <= r_Shift[2:0];\n  end\n```", "```\n❶ signal r_Shift : std_logic_vector(3 downto 0);\nprocess (i_Clk)\nbegin\n  if rising_edge(i_Clk) then\n  ❷ r_Shift(0)          <= i_Data_To_Delay;\n  ❸ r_Shift(3 downto 1) <= r_Shift(2 downto 0);\n  end if;\nend process;\n```", "```\nr_Shift[3] <= r_Shift[2];\nr_Shift[2] <= r_Shift[1];\nr_Shift[1] <= r_Shift[0];\n```", "```\n❶ reg [2:0] r_LFSR;\nwire     w_XNOR;\nalways @(posedge i_Clk)\nbegin\n❷ r_LFSR <= {r_LFSR[1:0], w_XNOR};\nend\n❸ assign w_XNOR = r_LFSR[2] ^~ r_LFSR[1];\n```", "```\n❶ signal r_LFSR : std_logic_vector(2 downto 0)\nsignal w_XNOR : std_logic;\nbegin\n  process (i_Clk) is\n  begin\n    if rising_edge(i_Clk) then\n    ❷ r_LFSR <= r_LFSR(1 downto 0) & w_XNOR;\n    end if;\n  end process;\n❸ w_XNOR <= r_LFSR(2) xnor r_LFSR(1);\n```", "```\nr_LED <= 1;\nwait for 0.20 seconds\nr_LED <= 0;\nwait for 0.20 seconds\n```", "```\nmodule Demux_LFSR_Project_Top\n  (input i_Clk,\n  input i_Switch_1,\n  input i_Switch_2,\n  output o_LED_1,\n  output o_LED_2,\n  output o_LED_3,\n  output o_LED_4);\n  reg r_LFSR_Toggle = 1'b0;\n  wire w_LFSR_Done;\n❶ LFSR_22 LFSR_Inst\n  (.i_Clk(i_Clk),\n ❷ .o_LFSR_Data(), // unconnected\n ❸ .o_LFSR_Done(w_LFSR_Done));\n  always @(posedge i_Clk)\n  begin\n  ❹ if (w_LFSR_Done)\n      r_LFSR_Toggle <= !r_LFSR_Toggle;\n  end\n❺ Demux_1_To_4 Demux_Inst\n  (.i_Data(r_LFSR_Toggle),\n   .i_Sel0(i_Switch_1),\n   .i_Sel1(i_Switch_2),\n   .o_Data0(o_LED_1),\n   .o_Data1(o_LED_2),\n   .o_Data2(o_LED_3),\n   .o_Data3(o_LED_4));\nendmodule\n```", "```\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nentity Demux_LFSR_Project_Top is\n  port (\n    i_Clk      : in  std_logic;\n    i_Switch_1 : in  std_logic;\n    i_Switch_2 : in  std_logic;\n    o_LED_1    : out std_logic;\n    o_LED_2    : out std_logic;\n    o_LED_3    : out std_logic;\n    o_LED_4    : out std_logic);\nend entity Demux_LFSR_Project_Top;\narchitecture RTL of Demux_LFSR_Project_Top is\n  signal r_LFSR_Toggle : std_logic := '0';\n  signal w_LFSR_Done   : std_logic;\nbegin\n❶ LFSR_22 : entity work.LFSR_22\n  port map (\n    i_Clk       => i_Clk,\n ❷ o_LFSR_Data => open, -- unconnected\n ❸ o_LFSR_Done => w_LFSR_Done);\n  process (i_Clk) is\n  begin\n    if rising_edge(i_Clk) then\n    ❹ if w_LFSR_Done  = '1' then\n         r_LFSR_Toggle <= not r_LFSR_Toggle;\n       end if;\n    end if;\n  end process;\n❺ Demux_Inst : entity work.Demux_1_To_4\n  port map (\n    i_Data  => r_LFSR_Toggle,\n    i_Sel0  => i_Switch_1,\n    i_Sel1  => i_Switch_2,\n    o_Data0 => o_LED_1,\n    o_Data1 => o_LED_2,\n    o_Data2 => o_LED_3,\n    o_Data3 => o_LED_4);\nend architecture RTL;\n```", "```\nmodule LFSR_22 (\n  input         i_Clk,\n  output [21:0] o_LFSR_Data,\n  output        o_LFSR_Done);\n❶ reg [21:0] r_LFSR;\nwire       w_XNOR;\nalways @(posedge i_Clk)\nbegin\n❷ r_LFSR <= {r_LFSR[20:0], w_XNOR};\nend\n❸ assign w_XNOR = r_LFSR[21] ^~ r_LFSR[20];\n❹ assign o_LFSR_Done = (r_LFSR == 22'd0);\n❺ assign o_LFSR_Data = r_LFSR;\nendmodule\n```", "```\nlibrary IEEE;\nuse IEEE.std_logic_1164.all;\nentity LFSR_22 is\n   port (\n    i_Clk       : in std_logic;\n    o_LFSR_Data : out std_logic_vector(21 downto 0);\n    o_LFSR_Done : out std_logic);\nend entity LFSR_22;\narchitecture RTL of LFSR_22 is\n❶ signal r_LFSR : std_logic_vector(21 downto 0);\nsignal w_XNOR : std_logic;\nbegin\n  process (i_Clk) begin\n    if rising_edge (i_Clk) then\n    ❷ r_LFSR <= r_LFSR(20 downto 0) & w_XNOR;\n    end if;\n  end process;\n❸ w_XNOR      <= r_LFSR(21) xnor r_LFSR(20);\n❹ o_LFSR_Done <= '1' when (r_LFSR = \"0000000000000000000000\") else '0';\n❺ o_LFSR_Data <= r_LFSR;\nend RTL;\n```", "```\nmodule Count_And_Toggle #(COUNT_LIMIT = 10)\n (input i_Clk,\n  input i_Enable,\n  output reg o_Toggle);\n❶ reg [$clog2(COUNT_LIMIT-1):0] r_Counter;\n  always @(posedge i_Clk)\n  begin\n    if (i_Enable == 1'b1)\n    begin\n    ❷ if (r_Counter == COUNT_LIMIT - 1)\n       begin\n       ❸ o_Toggle   <= !o_Toggle;\n       ❹ r_Counter <= 0;\n       end\n       else\n       ❺ r_Counter <= r_Counter + 1;\n    end\n    else\n       o_Toggle <= 1'b0;\n  end\nendmodule\n```", "```\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nentity Count_And_Toggle is\n  generic (COUNT_LIMIT : natural);\n  port (\n    i_Clk      : in std_logic;\n    i_Enable : in std_logic;\n    o_Toggle : out std_logic);\nend Count_And_Toggle;\narchitecture RTL of Count_And_Toggle is\n❶ signal r_Counter : natural range 0 to COUNT_LIMIT - 1;\nbegin\n  process (i_Clk) is\n  begin\n    if rising_edge(i_Clk) then\n       if i_Enable = '1' then\n       ❷ if r_Counter = COUNT_LIMIT - 1 then\n          ❸ o_Toggle  <= not o_Toggle;\n          ❹ r_Counter <= 0;\n          else\n          ❺ r_Counter <= r_Counter + 1;\n          end if;\n       else\n          o_Toggle <= '0';\n       end if;\n    end if;\n  end process;\nend RTL;\n```", "```\n`--snip--`\n  output o_LED_3,\n  output o_LED_4);\n  // Equivalent to 2^22 - 1, which is what the LFSR counted up to\n  localparam COUNT_LIMIT = 4194303;\n  wire w_Counter_Toggle;\n❶ Count_And_Toggle #(.COUNT_LIMIT(COUNT_LIMIT)) Toggle_Counter\n   (.i_Clk(i_Clk),\n    .i_Enable(1'b1),\n    .o_Toggle(w_Counter_Toggle));\n  Demux_1_To_4 Demux_Inst\n❷ (.i_Data(w_Counter_Toggle),\n   .i_Sel0(i_Switch_1),\n   .i_Sel1(i_Switch_2),\n   .o_Data0(o_LED_1),\n   .o_Data1(o_LED_2),\n   .o_Data2(o_LED_3),\n   .o_Data3(o_LED_4));\nendmodule\n```", "```\n`--snip--`\narchitecture RTL of Demux_LFSR_Project_Top is\n  -- Equivalent to 2^22 - 1, which is what the LFSR counted up to\n  constant COUNT_LIMIT : integer := 4194303;\n  signal w_Counter_Toggle : std_logic;\nbegin\n❶ Toggle_Counter : entity work.Count_And_Toggle\n  generic map (\n    COUNT_LIMIT => COUNT_LIMIT)\n  port map (\n    i_Clk      => i_Clk,\n    i_Enable => '1',\n    o_Toggle => w_Counter_Toggle);\n  Demux_Inst : entity work.Demux_1_To_4\n  port map (\n  ❷ i_Data   => w_Counter_Toggle,\n    i_Sel0   => i_Switch_1,\n    i_Sel1   => i_Switch_2,\n    o_Data0 => o_LED_1,\n    o_Data1 => o_LED_2,\n    o_Data2 => o_LED_3,\n    o_Data3 => o_LED_4);\nend architecture RTL;\n```", "```\n`--snip--`\nRegister bits not including I/Os:  23 (1%)\nMapping Summary:\nTotal  LUTs: 13 (1%)\n```", "```\n`--snip--`\nRegister bits not including I/Os:  24 (1%)\nMapping Summary:\nTotal  LUTs: 36 (2%)\n```", "```\nmodule RAM_2Port ❶ #(parameter WIDTH = 16, DEPTH = 256)\n   (\n   // Write signals\n   input                     i_Wr_Clk,\n   input [$clog2(DEPTH)-1:0] i_Wr_Addr,\n   input                     i_Wr_DV,\n   input [WIDTH-1:0]         i_Wr_Data,\n   // Read signals\n   input                     i_Rd_Clk,\n   input [$clog2(DEPTH)-1:0] i_Rd_Addr,\n   input                     i_Rd_En,\n   output reg                o_Rd_DV,\n   output reg [WIDTH-1:0]    o_Rd_Data\n   );\n❷ reg [WIDTH-1:0] r_Mem[DEPTH-1:0];\n   always @ (posedge i_Wr_Clk)\n   begin\n   ❸ if (i_Wr_DV)\n      begin\n      ❹ r_Mem[i_Wr_Addr] <= i_Wr_Data;\n      end\n   end\n   always @ (posedge i_Rd_Clk)\n   begin\n   ❺ o_Rd_Data <= r_Mem[i_Rd_Addr];\n   ❻ o_Rd_DV   <= i_Rd_En;\n   end\nendmodule\n```", "```\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nentity RAM_2Port is\n❶ generic (\n     WIDTH : integer := 16;\n     DEPTH : integer := 256\n     );\n   port (\n     -- Write signals\n     i_Wr_Clk  : in std_logic;\n     i_Wr_Addr : in std_logic_vector; -- sized at higher level\n     i_Wr_DV   : in std_logic;\n     i_Wr_Data : in std_logic_vector(WIDTH-1 downto 0);\n     -- Read signals\n     i_Rd_Clk  : in std_logic;\n     i_Rd_Addr : in std_logic_vector; -- sized at higher level\n     i_Rd_En   : in std_logic;\n     o_Rd_DV   : out std_logic;\n     o_Rd_Data : out std_logic_vector(WIDTH-1 downto 0)\n     );\nend RAM_2Port;\narchitecture RTL of RAM_2Port is\n   type t_Mem is array (0 to DEPTH-1) of std_logic_vector(WIDTH-1 downto 0);\n❷ signal r_Mem : t_Mem;\nbegin\n   process (i_Wr_Clk)\n   begin\n     if rising_edge(i_Wr_Clk) then\n     ❸ if i_Wr_DV = '1' then\n        ❹ r_Mem(to_integer(unsigned(i_Wr_Addr))) <= i_Wr_Data;\n        end if;\n     end if;\n   end process;\n   process (i_Rd_Clk)\n   begin\n     if rising_edge(i_Rd_Clk) then\n     ❺ o_Rd_Data <= r_Mem(to_integer(unsigned(i_Rd_Addr)));\n     ❻ o_Rd_DV   <= i_Rd_En;\n     end if;\n   end process;\nend RTL;\n```", "```\n`--snip--`\n  always @(posedge i_Clk or negedge i_Rst_L)\n  begin\n  ❶ if (~i_Rst_L)\n    begin\n      r_Wr_Addr <= 0;\n      r_Rd_Addr <= 0;\n      r_Count   <= 0;\n    end\n    else\n    begin\n    ❷ if (i_Wr_DV)\n      begin\n        if (r_Wr_Addr == DEPTH-1)\n          r_Wr_Addr <= 0;\n        else\n          r_Wr_Addr <= r_Wr_Addr + 1;\n      end\n   ❸ if (i_Rd_En)\n     begin\n       if (r_Rd_Addr == DEPTH-1)\n         r_Rd_Addr <= 0;\n       else\n         r_Rd_Addr <= r_Rd_Addr + 1;\n     end\n   ❹ if (i_Rd_En & ~i_Wr_DV)\n     begin\n       if (r_Count != 0)\n       begin\n         r_Count <= r_Count - 1;\n       end\n     end\n   ❺ else if (i_Wr_DV & ~i_Rd_En)\n     begin\n       if (r_Count != DEPTH)\n       begin\n         r_Count <= r_Count + 1;\n       end\n     end\n      if (i_Rd_En)\n      begin\n        o_Rd_Data <= w_Rd_Data;\n      end\n    end // else: !if(~i_Rst_L)\n  end // always @ (posedge i_Clk or negedge i_Rst_L)\n❻ assign o_Full  = (r_Count == DEPTH) ||\n                   (r_Count == DEPTH-1 && i_Wr_DV && !i_Rd_En);\n  assign o_Empty = (r_Count == 0);\n  assign o_AF_Flag = (r_Count > DEPTH - i_AF_Level);\n  assign o_AE_Flag = (r_Count < i_AE_Level);\n`--snip--`\n```", "```\n`--snip--`\n  process (i_Clk, i_Rst_L) is\n  begin\n  ❶ if not i_Rst_L then\n      r_Wr_Addr <= 0;\n      r_Rd_Addr <= 0;\n      r_Count   <= 0;\n    elsif rising_edge(i_Clk) then\n\n    ❷ if i_Wr_DV then\n        if r_Wr_Addr = DEPTH-1 then\n          r_Wr_Addr <= 0;\n        else\n          r_Wr_Addr <= r_Wr_Addr + 1;\n        end if;\n      end if;\n    ❸ if i_Rd_En then\n        if r_Rd_Addr = DEPTH-1 then\n          r_Rd_Addr <= 0;\n        else r_Rd_Addr <= r_Rd_Addr + 1;\n        end if;\n      end if;\n    ❹ if i_Rd_En = '1' and i_Wr_DV = '0' then\n        if (r_Count /= 0) then\n          r_Count <= r_Count - 1;\n        end if;\n    ❺ elsif i_Wr_DV = '1' and i_Rd_En = '0' then\n        if r_Count /= DEPTH then\n          r_Count <= r_Count + 1;\n        end if;\n      end if;\n      if i_Rd_En = '1' then\n        o_Rd_Data <= w_Rd_Data;\n      end if;\n\n    end if;\n  end process;\n\n❻ o_Full <= '1' when ((r_Count = DEPTH) or\n                      (r_Count = DEPTH-1 and i_Wr_DV = '1' and i_Rd_En = '0'))\n                     else '0';\n  o_Empty <= '1' when (r_Count = 0) else '0';\n\n  o_AF_Flag <= '1' when (r_Count > DEPTH - i_AF_Level) else '0';\n  o_AE_Flag <= '1' when (r_Count < i_AE_Level) else '0';\n`--snip--`\n```"]