<html><head></head><body>
<h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_283"/><strong><span class="big">10</span><br/>INSTRUCTION SET ARCHITECTURE</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/comm1.jpg"/></div>&#13;
<p class="noindents">This chapter discusses the implementation of a CPU’s instruction set. Although the choice of a given instruction set is usually beyond a software engineer’s control, understanding the decisions a hardware design engineer has to make when designing a CPU’s instruction set can definitely help you write better code.</p>&#13;
<p class="indent">CPU instruction sets contain several tradeoffs based on assumptions that computer architects make about the way software engineers write code. If the machine instructions you choose match those assumptions, your code will probably run faster and require fewer machine resources. Conversely, if your code violates the assumptions, chances are pretty good it won’t perform as well as it otherwise could.</p>&#13;
<p class="indent">Although studying the instruction set may seem like a task suited only to assembly language programmers, even high-level language programmers can benefit from doing so. After all, every HLL statement maps to some sequence of machine instructions, and the general concepts of instruction <span epub:type="pagebreak" id="page_284"/>set design are portable across architectures. Even if you never intend to write software using assembly language, it’s important to understand how the underlying machine instructions work and how they were designed.</p>&#13;
<h3 class="h3" id="sec10_1"><strong>10.1 The Importance of Instruction Set Design</strong></h3>&#13;
<p class="noindent">While features like caches, pipelining, and superscalar implementation can all be grafted onto a CPU long after the original design is obsolete, it’s very difficult to change the instruction set once a CPU is in production and people are writing software using it. Therefore, instruction set design requires very careful consideration; the designer must get the <em><a href="gloss01.xhtml#gloss01_125">instruction set architecture (ISA)</a></em> correct from the start of the design cycle.</p>&#13;
<p class="indent">You might assume that the “kitchen sink” approach to instruction set design—in which you include every instruction you can dream up—is best. However, instruction set design is the epitome of compromise management. Why can’t we have it all? Well, in the real world there are some nasty realities that prevent this:</p>&#13;
<p class="uln-indent"><strong>Silicon real estate</strong> The first nasty reality is that each feature requires some number of transistors on the CPU’s silicon die (chip), so CPU designers have a “silicon budget”—a finite number of transistors to work with. There simply aren’t enough transistors to support putting every possible feature on a CPU. The original 8086 processor, for example, had a silicon budget of fewer than 30,000 transistors. The 1999 Pentium III processor had a budget of over 9 million transistors. The 2019 AWS Graviton2 (ARM) CPU has over 30 billion transistors.<sup><a href="footnotes.xhtml#fn10_1a" id="fn10_1">1</a></sup> These three budgets reflect the differences in semiconductor technology from 1978 to today.</p>&#13;
<p class="uln-indent"><strong>Cost</strong> Although it’s possible to use billions of transistors on a CPU today, the more transistors used, the more expensive the CPU. For example, at the beginning of 2018, Intel i7 processors using billions of transistors cost hundreds of dollars, whereas contemporary CPUs with 30,000 transistors cost less than a dollar.</p>&#13;
<p class="uln-indent"><strong>Expandability</strong> It’s very difficult to anticipate all the features people will want. For example, Intel’s MMX and SIMD instruction enhancements were added to make multimedia programming more practical on the Pentium processor. Back in 1978, when Intel created the first 8086 processor, very few people could have predicted the need for these instructions. A CPU designer must allow for making extensions to the instruction set in future members of the CPU family to accommodate currently unanticipated needs.</p>&#13;
<p class="uln-indent"><strong>Legacy support for old instructions</strong> This nasty reality is almost the opposite of expandability. Often, an instruction that the CPU designer feels is important now turns out to be less useful than expected. For <span epub:type="pagebreak" id="page_285"/>example, the <code>loop</code> and <code>enter</code> instructions on the 80x86 CPU see very little use in modern high-performance programs. It’s commonly the case that programs never use some of the instructions in a CPU adopting the kitchen sink approach. Unfortunately, once an instruction is added to the instruction set, it has to be supported in all future versions of the processor, unless few enough programs use the instruction that CPU designers are willing to let those programs break.</p>&#13;
<p class="uln-indent"><strong>Complexity</strong> A CPU designer must consider the assembly programmers and compiler writers who will be using the chip. A CPU employing the kitchen sink approach might appeal to someone who’s already familiar with that CPU, but no one else will want to learn an overly complex system.</p>&#13;
<p class="indent">These problems with the kitchen sink approach all have a common solution: design a simple instruction set for the first version of the CPU, and leave room for later expansion. This is one of the main reasons the 80x86 has proven to be so popular and long-lived. Intel started with a relatively simple CPU and figured out how to extend the instruction set over the years to accommodate new features.</p>&#13;
<h3 class="h3" id="sec10_2"><strong>10.2 Basic Instruction Design Goals</strong></h3>&#13;
<p class="noindent">The efficiency of your programs largely depends upon the instructions that they use. Short instructions use very little memory and often execute rapidly, but they can’t tackle big tasks. Larger instructions can handle more complex tasks, with a single instruction often doing the work of several short instructions, but they may consume excessive memory or require many machine cycles to execute. To enable software engineers to write the best possible code, computer architects must strike a balance between the two.</p>&#13;
<p class="indent">In a typical CPU, the computer encodes instructions as numeric values (operation codes, or <em>opcodes</em>) and stores them in memory. Encoding these instructions is one of the major tasks in instruction set design, requiring careful thought. Instructions must each have a unique opcode, so the CPU can differentiate them. With an <em>n</em>-bit number, there are 2<sup><em>n</em></sup> different possible opcodes, so to encode <em>m</em> instructions requires at least log<sub>2</sub>(<em>m</em>) bits. The main point to keep in mind is that the size of individual CPU instructions is dependent on the total number of instructions that the CPU supports.</p>&#13;
<p class="indent">Encoding opcodes is a little more involved than assigning a unique numeric value to each instruction. As the previous chapter discussed, decoding each instruction and executing the specified task requires actual circuitry. With a 7-bit opcode, we could encode 128 different instructions. To decode each of these 128 instructions requires a 7- to 128-line decoder—an expensive piece of circuitry. However, assuming that the instruction opcodes contain certain (binary) patterns, a single large decoder can often be replaced by several smaller, less expensive ones.</p>&#13;
<p class="indent">If an instruction set contains 128 unrelated instructions, there’s little you can do other than decode the entire bit string for each instruction. However, in most architectures the instructions fall into categories. On <span epub:type="pagebreak" id="page_286"/>the 80x86 CPUs, for example, <code>mov(eax,</code> <code>ebx);</code> and <code>mov(ecx,</code> <code>edx);</code> have different opcodes, because they’re different instructions, but they’re obviously related in that they both move data from one register to another. The only difference is their source and destination operands. Thus, CPU designers could encode instructions like <code>mov</code> with a <em>subopcode</em>, and then they could encode the instruction’s operands using other bit fields within the opcode.</p>&#13;
<p class="indent">For example, given an instruction set with only eight instructions, each with two operands, and each operand having only one of four possible values, we could encode the instructions using three packed fields containing 3, 2, and 2 bits, respectively (see <a href="ch10.xhtml#ch10fig01">Figure 10-1</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/10fig01.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig01"/><em>Figure 10-1: Separating an opcode into several fields to simplify decoding</em></p>&#13;
<p class="indent">This encoding needs only three simple decoders to determine what the CPU should do. While this is a basic example, it demonstrates one very important facet of instruction set design: opcodes should be easy to decode. The easiest way to simplify the opcode is to construct it using several different bit fields. The smaller these bit fields are, the easier it will be for the hardware to decode and execute the instruction.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_287"/>The CPU designer’s goal, then, is to assign an appropriate number of bits to the opcode’s instruction field and to its operand fields. Choosing more bits for the instruction field lets the opcode encode more instructions, just as choosing more bits for the operand fields lets the opcode specify a larger number of operands (often memory locations or registers). You might think that when encoding 2<sup><em>n</em></sup> different instructions using <em>n</em> bits, you’d have very little leeway in choosing the size of the instruction. It’s going to take <em>n</em> bits to encode those 2<sup><em>n</em></sup> instructions; you can’t do it with any fewer. It <em>is</em> possible, however, to use more than <em>n</em> bits. This might seem wasteful, but sometimes it’s advantageous. Again, picking an appropriate instruction size is one of the more important aspects of instruction set design.</p>&#13;
<h4 class="h4" id="sec10_2_1"><strong><em>10.2.1 Choosing Opcode Length</em></strong></h4>&#13;
<p class="noindent">Opcode length isn’t arbitrary. Assuming that a CPU is capable of reading bytes from memory, the opcode will probably have to be some multiple of 8 bits long. If the CPU is not capable of reading bytes from memory (most RISC CPUs read memory only in 32- or 64-bit chunks), the opcode will be the same size as the smallest object the CPU can read from memory at one time. Any attempt to shrink the opcode size below this limit is futile. In this chapter, we’ll work with the first case: opcodes that must have a length that is a multiple of 8 bits.</p>&#13;
<p class="indent">Another point to consider is the size of an instruction’s operands. Some CPU designers include all operands in their opcode. Other CPU designers don’t count operands like immediate constants or address displacements as part of the opcode, and this is the approach we’ll take.</p>&#13;
<p class="indent">An 8-bit opcode can encode only 256 different instructions. Even if we don’t count instruction operands as part of the opcode, having only 256 different instructions is a stringent limit. Though CPUs with 8-bit opcodes exist, modern processors tend to have far more than 256 different instructions. Because opcodes must have a length that is a multiple of 8 bits, the next smallest possible opcode size is 16 bits. A 2-byte opcode can encode up to 65,536 different instructions, though the instructions will be larger.</p>&#13;
<p class="indent">When reducing instruction size is an important design goal, CPU designers often employ data compression theory. The first step is to analyze programs written for a typical CPU and count how many times each instruction occurs over a large number of applications. The second step is to create a list of these instructions, sorted by their frequency of use. Next, the designer assigns the 1-byte opcodes to the most frequently used instructions; 2-byte opcodes to the next most frequently used instructions; and opcodes of 3 or more bytes to the rarely used instructions. Although this scheme requires opcodes with a maximum size of 3 or more bytes, most of the actual instructions in a program will use 1- or 2-byte opcodes. The average opcode length will be somewhere between 1 and 2 bytes (let’s say 1.5 bytes), and a typical program will be shorter than had all the instructions employed a 2-byte opcode (see <a href="ch10.xhtml#ch10fig02">Figure 10-2</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/10fig02.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_288"/><a id="ch10fig02"/><em>Figure 10-2: Encoding instructions using a variable-length opcode</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_289"/>Although using variable-length instructions allows us to create smaller programs, it comes at a price. First, decoding variable-length instructions is a bit more complicated than decoding fixed-length instructions. Before decoding a particular instruction field, the CPU must first decode the instruction’s size, which consumes time. This may affect the CPU’s overall performance by introducing delays in the decoding step, which in turn limits the CPU’s maximum clock speed (because those delays stretch out a single clock period, thus reducing the CPU’s clock frequency). Variable-length instructions also make decoding multiple instructions in a pipeline difficult, because the CPU can’t easily determine the instruction boundaries in the prefetch queue.</p>&#13;
<p class="indent">For these reasons and others, most popular RISC architectures avoid variable-length instructions. However, in this chapter, we’ll study a variable-length approach, because saving memory is an admirable goal.</p>&#13;
<h4 class="h4" id="sec10_2_2"><strong><em>10.2.2 Planning for the Future</em></strong></h4>&#13;
<p class="noindent">Before actually choosing the instructions to implement in a CPU, designers must plan for the future. As explained earlier, the need for new instructions will undoubtedly arise after the initial design, so it’s wise to reserve some opcodes specifically for expansion purposes. Given the instruction opcode format in <a href="ch10.xhtml#ch10fig02">Figure 10-2</a>, it might not be a bad idea to reserve one block of 64 1-byte opcodes, half (4,096) of the 2-byte opcodes, and half (1,048,576) of the 3-byte opcodes for future use. Giving up 64 of the very valuable 1-byte opcodes may seem extravagant, but history suggests that such foresight is rewarded.</p>&#13;
<h4 class="h4" id="sec10_2_3"><strong><em>10.2.3 Choosing Instructions</em></strong></h4>&#13;
<p class="noindent">The next step is to choose the instructions to implement. Even if nearly half the instructions have been reserved for future expansion, that doesn’t mean that all the remaining opcodes must be used to implement instructions. A designer can leave a number of these instructions unimplemented, effectively reserving them for the future as well. The right approach is not to use up the opcodes as quickly as possible, but rather to produce a consistent and complete instruction set given the design compromises. It’s much easier to add an instruction later than it is to remove one, so, for the first go-round, it’s generally better to go with a simpler design.</p>&#13;
<p class="indent">First, choose some generic instruction types. Early in the design process it’s important to limit your choices to very common instructions. Other processors’ instruction sets are probably the best place to look for suggestions. For example, most processors have the following:</p>&#13;
<ul>&#13;
<li class="noindent">Data movement instructions (such as <code>mov</code>)</li>&#13;
<li class="noindent">Arithmetic and logical instructions (such as <code>add</code>, <code>sub</code>, <code>and</code>, <code>or</code>, <code>not</code>)</li>&#13;
<li class="noindent">Comparison instructions</li>&#13;
<li class="noindent">Conditional jump instructions (generally used after the comparison instructions)</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_290"/>Input/output instructions</li>&#13;
<li class="noindent">Other miscellaneous instructions</li>&#13;
</ul>&#13;
<p class="indent">The initial instruction set should comprise a reasonable number of instructions that will allow programmers to write efficient programs, without exceeding the silicon budget or violating other design constraints. This requires CPU designers to make strategic decisions based on careful research, experimentation, and simulation.</p>&#13;
<h4 class="h4" id="sec10_2_4"><strong><em>10.2.4 Assigning Opcodes to Instructions</em></strong></h4>&#13;
<p class="noindent">After choosing the initial instructions, the CPU designer assigns opcodes to them. The first step in this process is to group the instructions according to the characteristics they share. For example, an <code>add</code> instruction probably supports the exact same set of operands as the <code>sub</code> instruction, so it makes sense to group these two instructions together. On the other hand, the <code>not</code> and <code>neg</code> instructions each generally require only a single operand. Therefore, it makes sense to put these two instructions in the same group, but one separate from the <code>add</code> and <code>sub</code> group.</p>&#13;
<p class="indent">Once all the instructions are grouped, the next step is to encode them. A typical encoding scheme uses some bits to select the group, some to select a particular instruction from that group, and some to encode the operand types (such as registers, memory locations, and constants). The number of bits needed to encode all this information can have a direct impact on the instruction’s size, regardless of how often the instruction is used. For example, suppose 2 bits are needed to select an instruction’s group, 4 bits to select the instruction within that group, and 6 bits to specify the instruction’s operand types. In this case, the instructions are not going to fit into an 8-bit opcode. On the other hand, if all we need is to push one of eight different registers onto the stack, 4 bits will be enough to specify the <code>push</code> instruction group, and 3 bits will be enough to specify the register.</p>&#13;
<p class="indent">Encoding instruction operands with a minimal amount of space is always a problem, because many instructions allow a large number of operands. For example, the generic 32-bit 80x86 <code>mov</code> instruction allows two operands and requires a 2-byte opcode.<sup><a href="footnotes.xhtml#fn10_2a" id="fn10_2">2</a></sup> However, Intel noticed that <code>mov(</code><span class="EmpItalic">disp</span><code>, eax);</code> and <code>mov(eax,</code> <span class="EmpItalic">disp</span><code>);</code> occur frequently in programs, so it created a special 1-byte version of these instructions to reduce their size and, consequently, the size of programs that use them. Intel did not remove the 2-byte versions of these instructions, though: there are two different instructions that store EAX into memory and two different instructions that load EAX from memory. A compiler or assembler will always emit the shorter versions of each pair of instructions.</p>&#13;
<p class="indent">Intel made an important tradeoff with the <code>mov</code> instruction: it gave up an extra opcode in order to provide a shorter version of one variant of each instruction. Actually, Intel uses this trick all over the place to create <span epub:type="pagebreak" id="page_291"/>shorter and easier-to-decode instructions. Back in 1978, creating redundant instructions to reduce program size was a good compromise given the cost of memory. Today, however, a CPU designer would probably use those redundant opcodes for different purposes.</p>&#13;
<h3 class="h3" id="sec10_3"><strong>10.3 The Y86 Hypothetical Processor</strong></h3>&#13;
<p class="noindent">Because of enhancements made to the 80x86 processor family over time, Intel’s design goals in 1978, and the evolution of computer architecture, the encoding of 80x86 instructions is very complex and somewhat illogical. In short, the 80x86 is not a good introductory example of instruction set design. To work around this, we’ll discuss instruction set design in two stages: first, we’ll develop a trivial instruction set for the Y86, a hypothetical processor that is a small subset of the 80x86, and then we’ll expand our discussion to the full 80x86 instruction set.</p>&#13;
<h4 class="h4" id="sec10_3_1"><strong><em>10.3.1 Y86 Limitations</em></strong></h4>&#13;
<p class="noindent">The hypothetical Y86 processor is a <em>very</em> stripped-down version of the 80x86 CPUs. It supports only:</p>&#13;
<ul>&#13;
<li class="noindent">One operand size: 16 bits. This simplification frees us from having to encode the operand size as part of the opcode (thereby reducing the total number of opcodes we’ll need).</li>&#13;
<li class="noindent">Four 16-bit registers: AX, BX, CX, and DX. This lets us encode register operands with only 2 bits (versus the 3 bits the 80x86 family requires to encode eight registers).</li>&#13;
<li class="noindent">A 16-bit address bus with a maximum of 65,536 bytes of addressable memory.</li>&#13;
</ul>&#13;
<p class="indent">These simplifications, plus a very limited instruction set, will allow us to encode all Y86 instructions using a 1-byte opcode and a 2-byte displacement/offset when applicable.</p>&#13;
<h4 class="h4" id="sec10_3_2"><strong><em>10.3.2 Y86 Instructions</em></strong></h4>&#13;
<p class="noindent">Including both forms of the <code>mov</code> instruction, the Y86 CPU still provides only 18 basic instructions. Seven of these instructions have two operands, eight have one operand, and five have no operands at all. The instructions are <code>mov</code> (two forms), <code>add</code>, <code>sub</code>, <code>cmp</code>, <code>and</code>, <code>or</code>, <code>not</code>, <code>je</code>, <code>jne</code>, <code>jb</code>, <code>jbe</code>, <code>ja</code>, <code>jae</code>, <code>jmp</code>, <code>get</code>, <code>put</code>, and <code>halt</code>.</p>&#13;
<h5 class="h5" id="sec10_3_2_1"><strong>10.3.2.1 The mov Instruction</strong></h5>&#13;
<p class="noindent">The <code>mov</code> instruction comes in two forms, merged into the same instruction class:</p>&#13;
<pre>mov( <span class="EmpItalic1">reg</span>/<span class="EmpItalic1">memory</span>/<span class="EmpItalic1">constant</span>, <span class="EmpItalic1">reg</span> );<br/>&#13;
mov( <span class="EmpItalic1">reg</span>, <span class="EmpItalic1">memory</span> );</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_292"/>In these forms, <span class="EmpItalic">reg</span> is either register <code>ax</code>, <code>bx</code>, <code>cx</code>, or <code>dx</code>; <span class="EmpItalic">memory</span> is an operand specifying a memory location; and <span class="EmpItalic">constant</span> is a numeric constant using hexadecimal notation.</p>&#13;
<h5 class="h5" id="sec10_3_2_2"><strong>10.3.2.2 Arithmetic and Logical Instructions</strong></h5>&#13;
<p class="noindent">The arithmetic and logical instructions are as follows:</p>&#13;
<pre>add( <span class="EmpItalic1">reg</span>/<span class="EmpItalic1">memory</span>/<span class="EmpItalic1">constant</span>, <span class="EmpItalic1">reg</span> );<br/>&#13;
sub( <span class="EmpItalic1">reg</span>/<span class="EmpItalic1">memory</span>/<span class="EmpItalic1">constant</span>, <span class="EmpItalic1">reg</span> );<br/>&#13;
cmp( <span class="EmpItalic1">reg</span>/<span class="EmpItalic1">memory</span>/<span class="EmpItalic1">constant</span>, <span class="EmpItalic1">reg</span> );<br/>&#13;
and( <span class="EmpItalic1">reg</span>/<span class="EmpItalic1">memory</span>/<span class="EmpItalic1">constant</span>, <span class="EmpItalic1">reg</span> );<br/>&#13;
or( <span class="EmpItalic1">reg</span>/<span class="EmpItalic1">memory</span>/<span class="EmpItalic1">constant</span>, <span class="EmpItalic1">reg</span> );<br/><br/>&#13;
not( <span class="EmpItalic1">reg</span>/<span class="EmpItalic1">memory</span> );</pre>&#13;
<p class="indent">The <code>add</code> instruction adds the value of the first operand to the value of the second, storing the sum in the second operand. The <code>sub</code> instruction subtracts the value of the first operand from the value of the second, storing the difference in the second operand. The <code>cmp</code> instruction compares the value of the first operand against the value of the second and saves the result of the comparison for use by the conditional jump instructions (described in the next section). The <code>and</code> and <code>or</code> instructions compute bitwise logical operations between their two operands and store the result in the second operand. The <code>not</code> instruction appears separately because it supports only a single operand. <code>not</code> is the bitwise logical operation that inverts the bits of its single memory or register operand.</p>&#13;
<h5 class="h5" id="sec10_3_2_3"><strong>10.3.2.3 Control Transfer Instructions</strong></h5>&#13;
<p class="noindent">The <em>control transfer instructions</em> interrupt the execution of instructions stored in sequential memory locations and transfer control to instructions stored at some other point in memory. They do this either unconditionally, or conditionally based upon the result from a <code>cmp</code> instruction. These are the control transfer instructions:</p>&#13;
<pre>ja   <span class="EmpItalic1">dest</span>;  // Jump if above (i.e., greater than)<br/>&#13;
jae  <span class="EmpItalic1">dest</span>;  // Jump if above or equal (i.e., greater than or equal to)<br/>&#13;
jb   <span class="EmpItalic1">dest</span>;  // Jump if below (i.e., less than)<br/>&#13;
jbe  <span class="EmpItalic1">dest</span>;  // Jump if below or equal (i.e., less than or equal to)<br/>&#13;
je   <span class="EmpItalic1">dest</span>;  // Jump if equal<br/>&#13;
jne  <span class="EmpItalic1">dest</span>;  // Jump if not equal<br/><br/>&#13;
jmp  <span class="EmpItalic1">dest</span>;  // Unconditional jump</pre>&#13;
<p class="indent">The first six instructions (<code>ja</code>, <code>jae</code>, <code>jb</code>, <code>jbe</code>, <code>je</code>, and <code>jne</code>) let you check the result of the previous <code>cmp</code> instruction—that is, the result of the comparison of that instruction’s first and second operands.<sup><a href="footnotes.xhtml#fn10_3a" id="fn10_3">3</a></sup> For example, if you <span epub:type="pagebreak" id="page_293"/>compare the AX and BX registers with a <code>cmp(ax,</code> <code>bx);</code> instruction and then execute the <code>ja</code> instruction, the Y86 CPU will jump to the specified destination location if AX is greater than BX. If AX is not greater than BX, control will fall through to the next instruction in the program. In contrast to the first six instructions, the <code>jmp</code> instruction unconditionally transfers control to the instruction at the destination address.</p>&#13;
<h5 class="h5" id="sec10_3_2_4"><strong>10.3.2.4 Miscellaneous Instructions</strong></h5>&#13;
<p class="noindent">The Y86 supports three instructions that do not have any operands:</p>&#13;
<pre>get;   // Read an integer value into the AX register<br/>&#13;
put;   // Display the value in the AX register<br/>&#13;
halt;  // Terminate the program</pre>&#13;
<p class="indent">The <code>get</code> and <code>put</code> instructions let you read and write integer values: <code>get</code> prompts the user for a hexadecimal value and then stores that value into the AX register; <code>put</code> displays the value of the AX register in hexadecimal format. The <code>halt</code> instruction terminates program execution.</p>&#13;
<h4 class="h4" id="sec10_3_3"><strong><em>10.3.3 Operand Types and Addressing Modes on the Y86</em></strong></h4>&#13;
<p class="noindent">Before assigning opcodes, we need to look at the operands these instructions support. The 18 Y86 instructions use five different operand types: registers, constants, and three memory-addressing modes (the <em>indirect</em> addressing mode, the <em>indexed</em> addressing mode, and the <em>direct</em> addressing mode). See <a href="ch06.xhtml#ch06">Chapter 6</a> for more details on these addressing modes.</p>&#13;
<h4 class="h4" id="sec10_3_4"><strong><em>10.3.4 Encoding Y86 Instructions</em></strong></h4>&#13;
<p class="noindent">Because a real CPU uses logic circuitry to decode the opcodes and act appropriately on them, it’s not a good idea to arbitrarily assign opcodes to machine instructions. Instead, a typical CPU opcode uses a certain number of bits to denote the instruction class (such as <code>mov</code>, <code>add</code>, and <code>sub</code>), and a certain number of bits to encode each operand.</p>&#13;
<p class="indent">A typical Y86 instruction takes the form shown in <a href="ch10.xhtml#ch10fig03">Figure 10-3</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/10fig03.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig03"/><em>Figure 10-3: Basic Y86 instruction encoding</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_294"/>The basic instruction is either 1 or 3 bytes long, and its opcode consists of a single byte containing three fields. The first field, consisting of the HO 3 bits, defines the instruction, and these 3 bits provide eight possible combinations. As there are 18 different Y86 instructions, we’ll have to pull some tricks to handle the remaining 10 instructions.</p>&#13;
<h5 class="h5" id="sec10_3_4_1"><strong>10.3.4.1 Eight Generic Y86 Instructions</strong></h5>&#13;
<p class="noindent">As you can see in <a href="ch10.xhtml#ch10fig03">Figure 10-3</a>, seven of the eight basic opcodes encode the <code>or</code>, <code>and</code>, <code>cmp</code>, <code>sub</code>, and <code>add</code> instructions, as well as both versions of the <code>mov</code> instruction. The eighth, <code>000</code>, is an <em>expansion opcode</em>. This special instruction class, which we’ll return to shortly, provides a mechanism that allows us to expand the set of available instructions.</p>&#13;
<p class="indent">To determine the full opcode for a particular instruction, you simply select the appropriate bits for the <code>iii</code>, <code>rr</code>, and <code>mmm</code> fields (identified in <a href="ch10.xhtml#ch10fig03">Figure 10-3</a>). The <code>rr</code> field contains the destination register (except for the version of the <code>mov</code> instruction whose <code>iii</code> field is <code>111</code>), and the <code>mmm</code> field encodes the source register. For example, to encode the <code>mov(bx, ax);</code> instruction you would select <code>iii</code> = <code>110</code> (<code>mov(</code><span class="EmpItalic">reg</span><code>,</code> <span class="EmpItalic">reg</span><code>);</code>), <code>rr</code> = <code>00</code> (<code>ax</code>), and <code>mmm</code> <code>= 001</code> (<code>bx</code>). This produces the 1-byte instruction <code>%11000001</code>, or <code>$c0</code>.</p>&#13;
<p class="indent">Some Y86 instructions are larger than 1 byte. To illustrate why this is necessary, take, for example, the instruction <code>mov([1000], ax);</code>, which loads the AX register with the value stored at memory location <code>$1000</code>. The encoding for the opcode is <code>%11000110</code>, or <code>$c6</code>. However, the encoding for the <code>mov([2000], ax);</code> instruction is also <code>$c6</code>. Clearly these two instructions do different things: one loads the AX register from memory location <code>$1000</code>, while the other loads the AX register from memory location <code>$2000</code>.</p>&#13;
<p class="indent">In order to differentiate between instructions that encode an address using the [<span class="EmpItalic">xxxx</span>] or [<span class="EmpItalic">xxxx</span><code>+bx</code>] addressing modes, or to encode a constant using the immediate addressing mode, you must append the 16-bit address or constant to the instruction’s opcode. Within this 16-bit address or constant, the LO byte follows the opcode in memory and the HO byte follows the LO byte. So, the 3-byte encoding for <code>mov([1000], ax);</code> would be <code>$c6,</code> <code>$00,</code> <code>$10</code>, and the 3-byte encoding for <code>mov([2000], ax);</code> would be <code>$c6,</code> <code>$00,</code> <code>$20</code>.</p>&#13;
<h5 class="h5" id="sec10_3_4_2"><strong>10.3.4.2 The Special Expansion Opcode</strong></h5>&#13;
<p class="noindent">The special opcode in <a href="ch10.xhtml#ch10fig03">Figure 10-3</a> allows the Y86 CPU to expand the set of available instructions that can be encoded using a single byte. This opcode handles several zero- and one-operand instructions, as shown in <a href="ch10.xhtml#ch10fig04">Figures 10-4</a> and <a href="ch10.xhtml#ch10fig05">10-5</a>.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10fig04">Figure 10-4</a> shows the encodings of four one-operand instruction classes. The first 2-bit encoding for the <code>rr</code> field, <code>%00</code>, further expands the instruction set by providing a way to encode the zero-operand instructions shown in <a href="ch10.xhtml#ch10fig05">Figure 10-5</a>. Five of these instructions are illegal instruction opcodes; the three valid opcodes are the <code>halt</code> instruction, which terminates program execution; the <code>get</code> instruction, which reads a hexadecimal value from the user and stores it in the AX register; and the <code>put</code> instruction, which outputs the value in the AX register.</p>&#13;
<div class="image"><img alt="image" src="../images/10fig04.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_295"/><a id="ch10fig04"/><em>Figure 10-4: Single-operand instruction encodings (<code>iii = %000</code>)</em></p>&#13;
<div class="image"><img alt="image" src="../images/10fig05.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig05"/><em>Figure 10-5: Zero-operand instruction encodings (<code>iii = %000</code> and <code>rr = %00</code>)</em></p>&#13;
<p class="indent">The second 2-bit encoding for the <code>rr</code> field, <code>%01</code>, is also part of an expansion opcode that provides all the Y86 jump instructions (see <a href="ch10.xhtml#ch10fig06">Figure 10-6</a>). The third <code>rr</code> field encoding, <code>%10</code>, is for the <code>not</code> instruction. The fourth <code>rr</code> field encoding is currently unassigned. Any attempt to execute an opcode with an <code>iii</code> field encoding of <code>%000</code> and an <code>rr</code> field encoding of <code>%11</code> will halt the processor with an illegal instruction error. As previously discussed, CPU designers often reserve unassigned opcodes like this one so they can extend the instruction set in the future (as Intel did when moving from the 80286 processor to the 80386 or from the 32-bit x86 processors to the 64-bit x86-64 processors).</p>&#13;
<p class="indent">The seven jump instructions in the Y86 instruction set all take the form <code>j</code><span class="EmpItalic">xx</span> <span class="EmpItalic">address</span><code>;</code>. The <code>jmp</code> instruction copies the 16-bit address value that follows the opcode into the instruction pointer register, causing the CPU to fetch the next instruction from the target address of the <code>jmp</code>. The remaining six instructions—<code>ja</code>, <code>jae</code>, <code>jb</code>, <code>jbe</code>, <code>je</code>, and <code>jne</code>—test some condition and, if it is <code>true</code>, copy the address value into the instruction pointer register. The eighth opcode, <code>%00001111</code>, is another illegal opcode. These encodings are shown in <a href="ch10.xhtml#ch10fig06">Figure 10-6</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/10fig06.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_296"/><a id="ch10fig06"/><em>Figure 10-6: Jump instruction encodings</em></p>&#13;
<h4 class="h4" id="sec10_3_5"><strong><em>10.3.5 Examples of Encoding Y86 Instructions</em></strong></h4>&#13;
<p class="noindent">The Y86 processor does not execute instructions as human-readable strings of characters like <code>mov(ax, bx);</code>. Instead, it fetches instructions as bit patterns, such as <code>$c1</code>, from memory, then decodes and executes those bit patterns. Human-readable instructions like <code>mov(ax,</code> <code>bx);</code> and <code>add(5,</code> <code>cx);</code> must first be converted into binary representation, or <em><a href="gloss01.xhtml#gloss01_142">machine code</a></em>. This section will explore this conversion.</p>&#13;
<h5 class="h5" id="sec10_3_5_1"><strong>10.3.5.1 The add Instruction</strong></h5>&#13;
<p class="noindent">We’ll start our conversion with a very simple example, the <code>add(cx,</code> <code>dx);</code> instruction. Once you’ve chosen the instruction, you look it up in one of the opcode figures from the previous section. The <code>add</code> instruction is in the first group (see <a href="ch10.xhtml#ch10fig03">Figure 10-3</a>) and has an <code>iii</code> field of <code>%101</code>. The source operand is <code>cx</code>, so the <code>mmm</code> field is <code>%010</code>. The destination operand is <code>dx</code>, so the <code>rr</code> field is <code>%11</code>. Merging these bits produces the opcode <code>%10111010</code>, or <code>$ba</code> (see <a href="ch10.xhtml#ch10fig07">Figure 10-7</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/10fig07.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig07"/><em>Figure 10-7: Encoding the <code>add(</code> <code>cx,</code> <code>dx</code> <code>);</code> instruction</em></p>&#13;
<p class="indent">Now consider the <code>add(5, ax)</code> instruction. Because it has an immediate source operand (a constant), the <code>mmm</code> field will be <code>%111</code> (see <a href="ch10.xhtml#ch10fig03">Figure 10-3</a>). The destination register operand is <code>ax</code> (<code>%00</code>), and the instruction class field is <code>%101</code>, so the full opcode becomes <code>%10100111</code>, or <code>$a7</code>. However, we’re not finished yet. We also have to include the 16-bit constant <code>$0005</code> as part of the instruction, with the LO byte of the constant following the opcode, and the HO byte of the constant following its LO byte, because the bytes are arranged in little-endian order. So, the sequence of bytes in memory, from lowest address to highest address, is <code>$a7,</code> <code>$05,</code> <code>$00</code> (see <a href="ch10.xhtml#ch10fig08">Figure 10-8</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/10fig08.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_297"/><a id="ch10fig08"/><em>Figure 10-8: Encoding the <code>add(</code> <code>5,</code> <code>ax</code> <code>);</code> instruction</em></p>&#13;
<p class="indent">The <code>add([2ff+bx],</code> <code>cx)</code> instruction also contains a 16-bit constant that is the displacement portion of the indexed addressing mode. To encode this instruction, we use the following field values: <code>iii</code> = <code>%101</code>, <code>rr</code> = <code>%10</code>, and <code>mmm</code> = <code>%101</code>. This produces the opcode byte <code>%10110101</code>, or <code>$b5</code>. The complete instruction also requires the constant <code>$2ff</code>, so the full instruction is the 3-byte sequence <code>$b5,</code> <code>$ff,</code> <code>$02</code> (see <a href="ch10.xhtml#ch10fig09">Figure 10-9</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/10fig09.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig09"/><em>Figure 10-9: Encoding the <code>add(</code> <code>[$2ff+bx],</code> <code>cx</code> <code>);</code> instruction</em></p>&#13;
<p class="indent">Now consider <code>add([1000],</code> <code>ax)</code>. This instruction adds the 16-bit contents of memory locations <code>$1000</code> and <code>$1001</code> to the value in the AX register. Once again, <code>iii</code> = <code>%101</code> for the <code>add</code> instruction. The destination register is <code>ax</code>, so <code>rr</code> = <code>%00</code>. Finally, the addressing mode is the displacement-only addressing mode, so <code>mmm</code> = <code>%110</code>. This forms the opcode <code>%10100110</code>, or <code>$a6</code>. The complete instruction is 3 bytes long, because it must also encode the displacement (address) of the memory location in the 2 bytes following the opcode. Therefore, the complete 3-byte sequence is <code>$a6,</code> <code>$00,</code> <code>$10</code> (see <a href="ch10.xhtml#ch10fig10">Figure 10-10</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/10fig10.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig10"/><em>Figure 10-10: Encoding the <code>add(</code> <code>[1000],</code> <code>ax</code> <code>);</code> instruction</em></p>&#13;
<p class="indent">The last addressing mode to consider is the register indirect addressing mode, <code>[bx]</code>. The <code>add([bx],bx)</code> instruction uses the following encoded values: <code>mmm</code> = <code>%101</code>, <code>rr</code> = <code>%01</code> (<code>bx</code>), and <code>mmm</code> = <code>%100</code> (<code>[bx]</code>). Because the value in the BX register completely specifies the memory address, there’s no need to attach a displacement field to the instruction’s encoding. Hence, this instruction is only 1 byte long (see <a href="ch10.xhtml#ch10fig11">Figure 10-11</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/10fig11.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_298"/><a id="ch10fig11"/><em>Figure 10-11: Encoding the <code>add([bx],</code> <code>bx);</code> instruction</em></p>&#13;
<p class="indent">You use a similar approach to encode the <code>sub</code>, <code>cmp</code>, <code>and</code>, and <code>or</code> instructions. The only difference between encoding these instructions and the <code>add</code> instruction is the value you use for the <code>iii</code> field in the opcode.</p>&#13;
<h5 class="h5" id="sec10_3_5_2"><strong>10.3.5.2 The mov Instruction</strong></h5>&#13;
<p class="noindent">The Y86 <code>mov</code> instruction is special, because it comes in two forms. The only difference between the encoding of the <code>add</code> instruction and the encoding of the <code>mov</code> instruction’s first form (<code>iii</code> = <code>%110</code>) is the <code>iii</code> field. This form of <code>mov</code> copies either a constant or data from the register or memory address specified by the <code>mmm</code> field into the destination register specified by the <code>rr</code> field.</p>&#13;
<p class="indent">The second form of the <code>mov</code> instruction (<code>iii</code> = <code>%111</code>) copies data from the source register specified by the <code>rr</code> field to a destination memory location specified by the <code>mmm</code> field. In this form of the <code>mov</code> instruction, the source and destination meanings of the <code>rr</code> and <code>mmm</code> fields are reversed: <code>rr</code> is the source field and <code>mmm</code> is the destination field. Another difference between the two forms of <code>mov</code> is that in its second form, the <code>mmm</code> field may contain only the values <code>%100</code> (<code>[bx]</code>), <code>%101</code> (<code>[disp+bx]</code>), and <code>%110</code> (<code>[disp]</code>). The destination values can’t be any of the registers encoded by <code>mmm</code> field values in the range <code>%000</code> through <code>%011</code> or a constant encoded by an <code>mmm</code> field of <code>%111</code>. These encodings are illegal because the first form of the <code>mov</code> handles cases with a register destination, and because storing data into a constant doesn’t make any sense.</p>&#13;
<h5 class="h5" id="sec10_3_5_3"><strong>10.3.5.3 The not Instruction</strong></h5>&#13;
<p class="noindent">The <code>not</code> instruction is the only instruction with a single memory/register operand that the Y86 processor supports. It has the following syntax:</p>&#13;
<pre>not(<span class="EmpItalic1">reg</span>);</pre>&#13;
<p class="noindent">or:</p>&#13;
<pre>not(<span class="EmpItalic1">address</span>);</pre>&#13;
<p class="noindent">where <span class="EmpItalic">address</span> represents one of the memory addressing modes (<code>[bx]</code>, <code>[disp+bx]</code>, or <code>[disp]</code>). You may not specify a constant operand for the <code>not</code> instruction.</p>&#13;
<p class="indent">Because <code>not</code> has only a single operand, it needs only the <code>mmm</code> field to encode that operand. An <code>iii</code> field of <code>%000</code> and an <code>rr</code> field of <code>%10</code> identify the <code>not</code> instruction. In fact, whenever the <code>iii</code> field contains <code>0</code>, the CPU knows that it has to decode bits beyond the <code>iii</code> field to identify the instruction. <span epub:type="pagebreak" id="page_299"/>In this case, the <code>rr</code> field specifies whether we’ve encoded <code>not</code> or one of the other specially encoded instructions.</p>&#13;
<p class="indent">To encode an instruction like <code>not(ax)</code>, specify <code>%000</code> for the <code>iii</code> field and <code>%10</code> for the <code>rr</code> field, then encode the <code>mmm</code> field the same way you would encode it for the <code>add</code> instruction. Because <code>mmm</code><em/> = <code>%000</code> for AX, <code>not(ax)</code> would be encoded as <code>%00010000</code>, or <code>$10</code> (see <a href="ch10.xhtml#ch10fig12">Figure 10-12</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/10fig12.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig12"/><em>Figure 10-12: Encoding the <code>not(AX);</code> instruction</em></p>&#13;
<p class="indent">The <code>not</code> instruction does not allow an immediate, or constant, operand, so the opcode <code>%00010111</code> (<code>$17</code>) is an illegal opcode.</p>&#13;
<h5 class="h5" id="sec10_3_5_4"><strong>10.3.5.4 The Jump Instructions</strong></h5>&#13;
<p class="noindent">The Y86 jump instructions also use the special encoding, meaning that the <code>iii</code> field for jump instructions is always <code>%000</code>. These instructions are always 3 bytes long. The first byte, the opcode, specifies which jump instruction to execute, and the next 2 bytes specify the address in memory to which the CPU transfers control (if the condition is met, in the case of the conditional jumps). There are seven different Y86 jump instructions, six conditional jumps, and one unconditional jump, <code>jmp</code>. All seven of these instructions set <code>iii</code> = <code>%000</code> and <code>rr</code> = <code>%01</code>, so they differ only by their <code>mmm</code> fields. The eighth possible opcode, with an <code>mmm</code> field value of <code>%111</code>, is an illegal opcode (see <a href="ch10.xhtml#ch10fig06">Figure 10-6</a>).</p>&#13;
<p class="indent">Encoding these instructions is relatively straightforward. Picking the instruction you want to encode completely determines the opcode. The opcode values fall in the range <code>$08</code> through <code>$0e</code> (<code>$0f</code> is the illegal opcode).</p>&#13;
<p class="indent">The only field that requires some thought is the 16-bit operand that follows the opcode. This field holds the address of the target instruction to which the unconditional jump always transfers, and to which the conditional jumps transfer if the transfer condition is <code>true</code>. To properly encode this 16-bit operand, you must know the address of the opcode byte of the target instruction. If you’ve already converted the target instruction to binary form and stored it into memory, you’re all set—just specify the target instruction’s address as the sole operand of the jump instruction. On the other hand, if you haven’t yet written, converted, and placed the target instruction into memory, knowing its address would seem to require a bit of divination. Fortunately, you can figure it out by computing the lengths of all the instructions between the current jump instruction you’re encoding and the target instruction—but unfortunately, this is an arduous task.</p>&#13;
<p class="indent">The best way to calculate the distance is to write all your instructions down on paper, compute their lengths (which is easy, because all instructions are either 1 or 3 bytes long depending on whether they have a 16-bit <span epub:type="pagebreak" id="page_300"/>operand), and then assign an appropriate address to each instruction. Once you’ve done this, you’ll know the starting address for each instruction, and you can put target address operands into your jump instructions as you encode them.</p>&#13;
<h5 class="h5" id="sec10_3_5_5"><strong>10.3.5.5 The Zero-Operand Instructions</strong></h5>&#13;
<p class="noindent">The remaining instructions, the zero-operand instructions, are the easiest to encode. Because they have no operands, they are always 1 byte long. These instructions always have <code>iii</code> = <code>%000</code> and <code>rr</code> = <code>%00</code>, and <code>mmm</code> specifies the particular instruction opcode (see <a href="ch10.xhtml#ch10fig05">Figure 10-5</a>). Note that the Y86 CPU leaves five of these instructions undefined (so we can use these opcodes for future expansion).</p>&#13;
<h4 class="h4" id="sec10_3_6"><strong><em>10.3.6 Extending the Y86 Instruction Set</em></strong></h4>&#13;
<p class="noindent">The Y86 CPU is a trivial CPU, suitable only for demonstrating how to encode machine instructions. However, as with any good CPU, the Y86 design allows for expansion by adding new instructions.</p>&#13;
<p class="indent">You can extend the number of instructions in a CPU’s instruction set by using either undefined or illegal opcodes. So, because the Y86 CPU has several illegal and undefined opcodes, we’ll use them to expand the instruction set.</p>&#13;
<p class="indent">Using undefined opcodes to define new instructions works best when there are undefined bit patterns within an opcode group, and the new instruction you want to add falls into that same group. For example, the opcode <code>%00011</code><span class="EmpItalic">mmm</span> falls into the same group as the <code>not</code> instruction, which also has an <code>iii</code> field value of <code>%000</code>. If you decided that you really needed a <code>neg</code> (negate) instruction, using the <code>%00011</code><span class="EmpItalic">mmm</span> opcode makes sense because you’d probably expect <code>neg</code> to use the same syntax as the <code>not</code> instruction. Likewise, if you want to add a zero-operand instruction to the instruction set, Y86 has five undefined zero-operand instructions for you to choose from (<code>%0000000..%00000100</code>; see <a href="ch10.xhtml#ch10fig05">Figure 10-5</a>). You’d just appropriate one of these opcodes and assign your instruction to it.</p>&#13;
<p class="indent">Unfortunately, the Y86 CPU doesn’t have many illegal opcodes available. For example, if you wanted to add the <code>shl</code> (shift left), <code>shr</code> (shift right), <code>rol</code> (rotate left), and <code>ror</code> (rotate right) instructions as single-operand instructions, there’s not enough space within the group of single-operand instruction opcodes to do so (only <code>%00011</code><span class="EmpItalic">mmm</span> is currently open). Likewise, there are no two-operand opcodes open, so if you wanted to add an <code>xor</code> (exclusive OR) instruction or some other two-operand instruction, you’d be out of luck.</p>&#13;
<p class="indent">A common way to handle this dilemma, and one the Intel designers have employed, is to use one of the undefined opcodes as a prefix opcode byte. For example, the opcode <code>$ff</code> is illegal (it corresponds to a <code>mov(dx,</code> <span epub:type="pagebreak" id="page_301"/><span class="EmpItalic">constant</span><code>)</code> instruction), but we can use it as a special prefix byte to further expand the instruction set (see <a href="ch10.xhtml#ch10fig13">Figure 10-13</a>).<sup><a href="footnotes.xhtml#fn10_4a" id="fn10_4">4</a></sup></p>&#13;
<div class="image"><img alt="image" src="../images/10fig13.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig13"/><em>Figure 10-13: Using a prefix byte to extend the instruction set</em></p>&#13;
<p class="indent">Whenever the CPU encounters a prefix byte in memory, it reads and decodes the next byte in memory as the actual opcode. However, it doesn’t treat the second byte as it would a standard opcode that did not follow a prefix byte. Instead, it allows the CPU designer to create a completely new opcode scheme, independent of the original instruction set. A single-expansion opcode byte allows CPU designers to add up to 256 more instructions to the instruction set. For even more instructions, designers can use additional illegal opcode bytes (in the original instruction set) to add still more expansion opcodes, each with its own independent instruction set; or they can follow the opcode expansion prefix byte with a 2-byte opcode (yielding up to 65,536 new instructions); or they can execute any other scheme they can dream up.</p>&#13;
<p class="indent">Of course, one big drawback of this approach is that it increases the size of the new instructions by 1 byte, because each instruction now requires the prefix byte as part of the opcode. This also increases the cost of the circuitry (since decoding prefix bytes and multiple instruction sets is fairly complex), so you don’t want to use this scheme for the basic instruction set. Nevertheless, it is a good way to expand the instruction set when you’ve run out of opcodes.</p>&#13;
<h3 class="h3" id="sec10_4"><strong>10.4 Encoding 80x86 Instructions</strong></h3>&#13;
<p class="noindent">The Y86 processor is simple to understand; we can easily encode instructions by hand for it, and it’s a great vehicle for learning how to assign opcodes. It’s also a purely hypothetical device intended only as a teaching tool. So, it’s time to take a look at the machine instruction format for a real CPU: the 80x86. After all, the programs you write will run on a real CPU, so to fully appreciate what your compilers are doing with your code—so you can choose the best statements and data structures when writing that code—you need to understand how real instructions are encoded.</p>&#13;
<p class="indent">Even if you’re using a different CPU, studying the 80x86 instruction encoding is helpful. They don’t call the 80x86 a <em>complex</em> instruction set computer (CISC) chip for nothing. Although more complex instruction <span epub:type="pagebreak" id="page_302"/>encodings do exist, no one would challenge the assertion that it’s one of the more complex instruction sets in common use today. Therefore, exploring it will provide valuable insight into the operation of other real-world CPUs.</p>&#13;
<p class="indent">The generic 80x86 32-bit instruction takes the form shown in <a href="ch10.xhtml#ch10fig14">Figure 10-14</a>.<sup><a href="footnotes.xhtml#fn10_5a" id="fn10_5">5</a></sup></p>&#13;
<div class="image"><img alt="image" src="../images/10fig14.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig14"/><em>Figure 10-14: 80x86 32-bit instruction encoding</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Although this diagram seems to imply that instructions can be up to 16 bytes long, 15 bytes is actually the limit.</em></p>&#13;
</div>&#13;
<p class="indent">The prefix bytes are not the same as the opcode expansion prefix byte that we discussed in the previous section. Instead, the 80x86 prefix bytes modify the behavior of existing instructions. An instruction may have a maximum of four prefix bytes attached to it, but the 80x86 supports more than four different prefix values. The behaviors of many prefix bytes are mutually exclusive, and the results of an instruction will be undefined if you prepend a pair of mutually exclusive prefix bytes to it. We’ll take a look at a couple of these prefix bytes in a moment.</p>&#13;
<p class="indent">The (32-bit) 80x86 supports two basic opcode sizes: a standard 1-byte opcode and a 2-byte opcode consisting of a <code>$0f</code> opcode expansion prefix byte and a second byte specifying the actual instruction. One way to think of this opcode expansion prefix byte is as an 8-bit extension of the <code>iii</code> field in the Y86 encoding. This enables the encoding of up to 512 different instruction classes, although the 80x86 doesn’t yet use them all. In reality, various instruction classes use certain bits in this opcode expansion prefix byte for decidedly non-instruction-class purposes. For example, consider the <code>add</code> instruction opcode shown in <a href="ch10.xhtml#ch10fig15">Figure 10-15</a>.</p>&#13;
<p class="indent">Bit 1 (<code>d</code>) specifies the direction of the transfer. If this bit is <code>0</code>, then the destination operand is a memory location, such as in <code>add(al,</code> <code>[ebx]);</code>. If this bit is <code>1</code>, the destination operand is a register, as in <code>add([ebx],</code> <code>al);</code>.</p>&#13;
<div class="image"><img alt="image" src="../images/10fig15.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_303"/><a id="ch10fig15"/><em>Figure 10-15: 80x86 <code>add</code> opcode</em></p>&#13;
<p class="indent">Bit 0 (<code>s</code>) specifies the size of the operands the <code>add</code> instruction operates upon. There’s a problem here, however. The 32-bit 80x86 family supports up to three different operand sizes: 8-bit operands, 16-bit operands, and 32-bit operands. With a single size bit, the instruction can encode only two of these three different sizes. In 32-bit operating systems, the vast majority of operands are either 8 bits or 32 bits, so the 80x86 CPU uses the size bit in the opcode to encode those sizes. For 16-bit operands, which occur less frequently than 8-bit or 32-bit operands, Intel uses a special opcode prefix byte to specify the size. As long as instructions that have 16-bit operands occur less than one out of every eight instructions (which is generally the case), this is more compact than adding another bit to the instruction’s size. Using a size prefix byte allowed Intel’s designers to extend the number of operand sizes without having to change the instruction encoding inherited from the original 16-bit processors in this CPU family.</p>&#13;
<p class="indent">Note that the AMD/Intel 64-bit architectures go even crazier with opcode prefix bytes. However, the CPU operates in a special 64-bit mode; effectively, the 64-bit 80x86 CPUs (often called the <em>X86-64 CPUs</em>) have two completely different instruction sets, each with its own encoding. The X86-64 CPUs can switch between 64- and 32-bit modes to handle programs written in either of the different instruction sets. The encoding in this chapter covers the 32-bit variant; see the Intel or AMD documentation for details on the 64-bit version.</p>&#13;
<h4 class="h4" id="sec10_4_1"><strong><em>10.4.1 Encoding Instruction Operands</em></strong></h4>&#13;
<p class="noindent">The <code>mod-reg-r/m</code> byte (see <a href="ch10.xhtml#ch10fig14">Figure 10-14</a>) provides the encoding for instruction operands by specifying the base addressing mode used to access them as well as their size. This byte contains the fields shown in <a href="ch10.xhtml#ch10fig16">Figure 10-16</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/10fig16.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig16"/><em>Figure 10-16: <code>mod-reg-r/m</code> byte</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_304"/>The <code>reg</code> field almost always specifies an 80x86 register. However, depending on the instruction, the register specified by <code>reg</code> can be either the source or the destination operand. To distinguish between the two, many instructions’ upcodes include the <code>d</code> (direction) field, which contains a value of <code>0</code> when <code>reg</code> is the source and a value of <code>1</code> when it’s the destination operand.</p>&#13;
<p class="indent">This field uses the 3-bit register encodings found in <a href="ch10.xhtml#ch10tab01">Table 10-1</a>. As just discussed, the size bit in the instruction’s opcode indicates whether the <code>reg</code> field specifies an 8- or 32-bit register (when operating under a modern, 32-bit operating system). To make the <code>reg</code> field specify a 16-bit register, you must set the size bit in the opcode to <code>1</code>, as well as adding an extra prefix byte.</p>&#13;
<p class="tabcap"><a id="ch10tab01"/><strong>Table 10-1:</strong> <code>reg</code> Field Encodings</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><span class="EmpStrong">reg</span> value</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Register if data size is 8 bits</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Register if data size is 16 bits</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Register if data size is 32 bits</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%000</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>al</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>ax</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>eax</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%001</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>cl</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>cx</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>ecx</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%010</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>dl</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>dx</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>edx</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%011</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>bl</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>bx</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>ebx</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%100</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>ah</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>sp</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>esp</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%101</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>ch</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>bp</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>ebp</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%110</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>dh</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>si</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>esi</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%111</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>bh</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>di</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>edi</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">With the <code>d</code> bit in the opcode of a two-operand instruction indicating whether the <code>reg</code> field contains the source or destination operand, the <code>mod</code> and <code>r/m</code> fields together specify the other of the two operands. In the case of a single-operand instruction like <code>not</code> or <code>neg</code>, the <code>reg</code> field contains an opcode extension, and <code>mod</code> and <code>r/m</code> combine to specify the only operand. The operand addressing modes specified by the <code>mod</code> and <code>r/m</code> fields are listed in <a href="#ch10tab02">Tables 10-2</a> and <a href="#ch10tab03">10-3</a>.</p>&#13;
<p class="tabcap"><a id="ch10tab02"/><strong>Table 10-2:</strong> <code>mod</code> Field Encodings</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:80%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><span class="EmpStrong">mod</span></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%00</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Specifies register-indirect addressing mode (with two exceptions: scaled-index [<code>sib</code>] addressing modes with no displacement operand when <code>r/m = %100</code>; and displacement-only addressing mode when <code>r/m = %101</code>).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%01</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Specifies that a 1-byte signed displacement follows the addressing mode byte(s).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%10</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Specifies that a 1-byte signed displacement follows the addressing mode byte(s).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%11</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Specifies direct register access.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_305"/><a id="ch10tab03"/><strong>Table 10-3:</strong> <code>mod-r/m</code> Encodings</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><span class="EmpStrong">mod</span></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><span class="EmpStrong">r/m</span></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Addressing mode</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%00</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%000</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[eax]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%01</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%000</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[eax+</code><span class="EmpItalic">disp</span><sub>8</sub><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%10</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%000</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[eax+</code><span class="EmpItalic">disp</span><sub>32</sub><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%11</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%000</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>al</code>, <code>ax</code>, or <code>eax</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%00</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%001</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[ecx]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%01</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%001</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[ecx+</code><span class="EmpItalic">disp</span><sub>8</sub><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%10</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%001</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[ecx+</code><span class="EmpItalic">disp</span><sub>32</sub><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%11</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%001</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>cl</code>, <code>cx</code>, or <code>ecx</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%00</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%010</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[edx]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%01</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%010</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[edx+</code><span class="EmpItalic">disp</span><sub>8</sub><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%10</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%010</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[edx+</code><span class="EmpItalic">disp</span><sub>32</sub><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%11</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%010</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>dl</code>, <code>dx</code>, or <code>edx</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%00</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%011</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[ebx]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%01</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%011</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[ebx+</code><span class="EmpItalic">disp</span><sub>8</sub><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%10</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%011</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[ebx+</code><span class="EmpItalic">disp</span><sub>32</sub><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%11</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%011</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>bl</code>, <code>bx</code>, or <code>ebx</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%00</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%100</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Scaled-index (<code>sib</code>) mode</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%01</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%100</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>sib</code> + <span class="EmpItalic">disp</span><sub>8</sub> mode</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%10</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%100</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>sib</code> + <span class="EmpItalic">disp</span><sub>32</sub> mode</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%11</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%100</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>ah</code>, <code>sp</code>, or <code>esp</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%00</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%101</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Displacement-only mode (32-bit displacement)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%01</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%101</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[ebp+</code><span class="EmpItalic">disp</span><sub>8</sub><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%10</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%101</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[ebp+</code><span class="EmpItalic">disp</span><sub>32</sub><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%11</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%101</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>ch</code>, <code>bp</code>, or <code>ebp</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%00</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%110</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[esi]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%01</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%110</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[esi+</code><span class="EmpItalic">disp</span><sub>8</sub><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%10</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%110</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[esi+</code><span class="EmpItalic">disp</span><sub>32</sub><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%11</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%110</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>dh</code>, <code>si</code>, or <code>esi</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%00</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%111</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[edi]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%01</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%111</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[edi+</code><span class="EmpItalic">disp</span><sub>8</sub><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%10</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%111</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[edi+</code><span class="EmpItalic">disp</span><sub>32</sub><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%11</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%111</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>bh</code>, <code>di</code>, or <code>edi</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_306"/>There are a couple of interesting things to note about <a href="ch10.xhtml#ch10tab02">Tables 10-2</a> and <a href="ch10.xhtml#ch10tab03">10-3</a>. First, there are two different forms of the [<span class="EmpItalic">reg+disp</span>] addressing modes: one form with an 8-bit displacement and one form with a 32-bit displacement. Addressing modes whose displacement falls in the range –128 through +127 require only a single byte after the opcode to encode the displacement. Instructions with a displacement that falls within this range will be shorter and sometimes faster than instructions whose displacement values are not within this range and thus require 4 bytes after the opcode.</p>&#13;
<p class="indent">The second thing to note is that there is no <code>[ebp]</code> addressing mode. If you look at the entry in <a href="ch10.xhtml#ch10tab03">Table 10-3</a> where this addressing mode logically belongs (where <code>r/m</code> is <code>%101</code> and <code>mod</code> is <code>%00</code>), you’ll find that its slot is occupied by the 32-bit displacement-only addressing mode. The basic encoding scheme for addressing modes didn’t allow for a displacement-only addressing mode, so Intel “stole” the encoding for <code>[ebp]</code> and used that for the displacement-only mode. Fortunately, anything you can do with the <code>[ebp]</code> addressing mode you can also do with the <code>[ebp+</code><span class="EmpItalic">disp</span><sub>8</sub><code>]</code> addressing mode by setting the 8-bit displacement to <code>0</code>. While such an instruction is a bit longer than it would otherwise need to be if the <code>[ebp]</code> addressing mode existed, the same capabilities are still there. Intel wisely chose to replace this particular register-indirect addressing mode, anticipating that programmers would use it less often than the other register-indirect addressing modes.</p>&#13;
<p class="indent">Another thing you’ll notice missing from this table are addressing modes of the form <code>[esp]</code>, <code>[esp+</code><span class="EmpItalic">disp</span><sub>8</sub><code>]</code>, and <code>[esp+</code><span class="EmpItalic">disp</span><sub>32</sub><code>]</code>. Intel’s designers borrowed the encodings for these three addressing modes to support the <em><a href="gloss01.xhtml#gloss01_222">scaled-index addressing</a></em> modes they added to their 32-bit processors in the 80x86 family.</p>&#13;
<p class="indent">If <code>r/m</code> = <code>%100</code> and <code>mod</code> = <code>%00</code>, this specifies an addressing mode of the form <code>[reg</code><sub><code>1</code></sub><code>32+reg</code><sub><code>2</code></sub><code>32*n]</code>. This scaled-index addressing mode computes the <span epub:type="pagebreak" id="page_307"/>final address in memory as the sum of <code>reg</code><sub><code>2</code></sub> multiplied by <span class="EmpItalic">n</span> (<span class="EmpItalic">n</span> = <code>1</code>, <code>2</code>, <code>4</code>, or <code>8</code>) and <code>reg</code><sub><code>1</code></sub>. Programs most often use this addressing mode when <code>reg</code><sub><code>1</code></sub> is a pointer holding the base address of an array of bytes (<span class="EmpItalic">n</span> = <code>1</code>), words (<span class="EmpItalic">n</span> = <code>2</code>), double words (<span class="EmpItalic">n</span> = <code>4</code>), or quad words (<span class="EmpItalic">n</span> = <code>8</code>), and <code>reg</code><sub><code>2</code></sub> holds the index into that array.</p>&#13;
<p class="indent">If <code>r/m</code> = <code>%100</code> and <code>mod</code> = <code>%01</code>, this specifies an addressing mode of the form <code>[reg</code><sub><code>1</code></sub><code>32+reg</code><sub><code>2</code></sub><code>32*</code><span class="EmpItalic">n</span><code>+</code><span class="EmpItalic">disp</span><sub><code>8</code></sub><code>]</code>. This scaled-index addressing mode computes the final address in memory as the sum of <code>reg</code><sub><code>2</code></sub> multiplied by <span class="EmpItalic">n</span> (<span class="EmpItalic">n</span> = <code>1</code>, <code>2</code>, <code>4</code>, or <code>8</code>), <code>reg</code><sub><code>1</code></sub>, and the 8-bit signed displacement (sign-extended to 32 bits). Programs most often use this addressing mode when <code>reg</code><sub><code>1</code></sub> is a pointer holding the base address of an array of records, <code>reg</code><sub><code>2</code></sub> holds the index into that array, and <span class="EmpItalic">disp</span><sub><code>8</code></sub> provides the offset to a desired field in the record.</p>&#13;
<p class="indent">If <code>r/m</code> = <code>%100</code> and <code>mod</code> = <code>%10</code>, this specifies an addressing mode of the form <code>[reg</code><sub><code>1</code></sub><code>32+reg</code><sub><code>2</code></sub><code>32*n+</code><span class="EmpItalic">disp</span><sub><code>32</code></sub><code>]</code>. This scaled-index addressing mode computes the final address in memory as the sum of <code>reg</code><sub><code>2</code></sub> multiplied by <span class="EmpItalic">n</span> (<span class="EmpItalic">n</span> = <code>1</code>, <code>2</code>, <code>4</code>, or <code>8</code>), <code>reg</code><sub><code>1</code></sub>, and the 32-bit signed displacement. Programs most often use this addressing mode to index into static arrays of bytes, words, double words, or quad words.</p>&#13;
<p class="indent">If values corresponding to one of the <code>sib</code> modes appear in the <code>mod</code> and <code>r/m</code> fields, the addressing mode is a scaled-index addressing mode with a second byte (the <code>sib</code>) following the <code>mod-reg-r/m</code> byte, though don’t forget that the <code>mod</code> field still specifies a displacement size of 0, 1, or 4 bytes. <a href="ch10.xhtml#ch10fig17">Figure 10-17</a> shows the layout of this extra <code>sib</code>, and <a href="ch10.xhtml#ch10tab04">Tables 10-4</a>, <a href="ch10.xhtml#ch10tab05">10-5</a>, and <a href="ch10.xhtml#ch10tab06">10-6</a> explain the values for each of the <code>sib</code> fields.</p>&#13;
<div class="image"><img alt="image" src="../images/10fig17.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig17"/><em>Figure 10-17: The <code>sib</code> (scaled-index byte) layout</em></p>&#13;
<p class="tabcap"><a id="ch10tab04"/><strong>Table 10-4:</strong> Scale Values</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Scale value</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Index * scale value</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%00</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Index * 1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%01</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Index * 2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%10</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Index * 4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%11</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Index * 8</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="tabcap"><a id="ch10tab05"/><strong>Table 10-5:</strong> Register Values for <code>sib</code> Encoding</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Index value</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Register</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%000</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">EAX</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%001</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">ECX</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%010</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">EDX</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%011</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">EBX</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%100</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Illegal</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%101</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">EBP</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%110</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">ESI</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%111</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">EDI</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_308"/><a id="ch10tab06"/><strong>Table 10-6:</strong> Base Register Values for <code>sib</code> Encoding</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Base value</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Register</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%000</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">EAX</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%001</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">ECX</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%010</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">EDX</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%011</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">EBX</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%100</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">ESP</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%101</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Displacement only if <code>mod</code> = <code>%00</code>, EBP if <code>mod</code> = <code>%01</code> or <code>%10</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%110</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">ESI</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%111</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">EDI</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The <code>mod-reg-r/m</code> and <code>sib</code> bytes are complex and convoluted, no question about that. The reason is that Intel reused its 16-bit addressing circuitry when it switched to the 32-bit format rather than simply abandoning it at that point. There were good hardware reasons for retaining it, but the result is a complex scheme for specifying addressing modes. As you can imagine, things got even worse when Intel and AMD developed the x86-64 architecture.</p>&#13;
<p class="indent">Note that if the <code>r/m</code> field of the <code>mod-reg-r/m</code> byte contains <code>%100</code> and <code>mod</code> does not contain <code>%11</code>, the addressing mode is a <code>sib</code> mode rather than the expected <code>[esp]</code>, <code>[esp+</code><span class="EmpItalic">disp</span><sub><code>8</code></sub><code>]</code>, or <code>[esp+</code><span class="EmpItalic">disp</span><sub><code>32</code></sub><code>]</code> mode. In this case the compiler or assembler will emit an extra <code>sib</code> byte immediately following the <code>mod-reg-r/m</code> byte. <a href="ch10.xhtml#ch10tab07">Table 10-7</a> lists the various combinations of legal scaled-index addressing modes on the 80x86.</p>&#13;
<p class="indent">In each of the addressing modes listed in <a href="ch10.xhtml#ch10tab07">Table 10-7</a>, the <code>mod</code> field of the <code>mod-reg-r/m</code> byte specifies the size of the displacement (0, 1, or 4 bytes). The base and index fields of the <code>sib</code> specify the base and index registers, respectively. Note that this addressing mode does not allow the use of ESP as an index register. Presumably, Intel left this particular mode undefined to allow for extending the addressing modes to 3 bytes in a future version of the CPU, although doing so seems a bit extreme.</p>&#13;
<p class="indent">Just as the <code>mod-reg-r/m</code> encoding replaced the <code>[ebp]</code> addressing mode with a displacement-only mode, the <code>sib</code> addressing format replaces the <code>[ebp+</code><span class="EmpItalic">index</span><code>*</code><span class="EmpItalic">scale</span><code>]</code> mode with a displacement-plus index mode (that is, no base register). If it turns out that you really need to use the <code>[ebp+</code><span class="EmpItalic">index</span><code>*</code><span class="EmpItalic">scale</span><code>]</code> addressing mode, you’ll have to use the <code>[</code><span class="EmpItalic">disp</span><sub><code>8</code></sub><code>+ebp+</code><span class="EmpItalic">index</span><code>*</code><span class="EmpItalic">scale</span><code>]</code> mode instead, specifying a 1-byte displacement value of <code>0</code>.</p>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_309"/><a id="ch10tab07"/><strong>Table 10-7:</strong> The Scaled-Index Addressing Modes</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><span class="EmpStrong">mod</span></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Index</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Legal scaled-index addressing modes<sup><a href="footnotes.xhtml#fn10_6a" id="fn10_6">6</a></sup></strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" rowspan="8" style="vertical-align: top;"><p class="taba"><code>%00</code></p>&#13;
<p class="taba">Base ° <code>%101</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%000</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+eax*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%001</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+ecx*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%010</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+edx*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%011</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+ebx*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%100</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">n/a<sup><a href="footnotes.xhtml#fn10_7a" id="fn10_7">7</a></sup></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%101</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+ebp*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%110</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+esi*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%111</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+edi*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" rowspan="8" style="vertical-align: top;"><p class="taba"><code>%00</code></p>&#13;
<p class="taba">Base = <code>%101</code><sup><a href="footnotes.xhtml#fn10_8a" id="fn10_8">8</a></sup></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%000</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>32</code></sub><code>+eax*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%001</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>32</code></sub><code>+ecx*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%010</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>32</code></sub><code>+edx*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%011</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>32</code></sub><code>+ebx*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%100</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">n/a</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%101</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>32</code></sub><code>+ebp*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%110</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>32</code></sub><code>+esi*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%111</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>32</code></sub><code>+edi*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" rowspan="8" style="vertical-align: top;"><p class="taba"><code>%01</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%000</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>8</code></sub><code>+</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+eax*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%001</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>8</code></sub><code>+</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+ecx*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%010</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>8</code></sub><code>+</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+edx*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%011</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>8</code></sub><code>+</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+ebx*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%100</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">n/a</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%101</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>8</code></sub><code>+</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+ebp*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%110</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>8</code></sub><code>+</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+esi*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%111</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>8</code></sub><code>+</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+edi*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" rowspan="8" style="vertical-align: top;"><p class="taba"><code>%10</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%000</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>32</code></sub><code>+</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+eax*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%001</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>32</code></sub><code>+</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+ecx*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%010</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>32</code></sub><code>+</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+edx*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%011</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>32</code></sub><code>+</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+ebx*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%100</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">n/a</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%101</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>32</code></sub><code>+</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+ebp*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>%110</code></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>32</code></sub><code>+</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+esi*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>%111</code></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><code>[</code><span class="EmpItalic">disp</span><sub><code>32</code></sub><code>+</code><span class="EmpItalic">base</span><sub><code>32</code></sub><code>+edi*</code><span class="EmpItalic">n</span><code>]</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="sec10_4_2"><span epub:type="pagebreak" id="page_310"/><strong><em>10.4.2 Encoding the add Instruction</em></strong></h4>&#13;
<p class="noindent">To help you figure out how to encode an instruction using this complex scheme, let’s look at an example of the 80x86 <code>add</code> instruction using various addressing modes. The <code>add</code> opcode is either <code>$00</code>, <code>$01</code>, <code>$02</code>, or <code>$03</code>, depending on its direction and size bits (see <a href="ch10.xhtml#ch10fig15">Figure 10-15</a>). <a href="ch10.xhtml#ch10fig18">Figures 10-18</a> through <a href="ch10.xhtml#ch10fig25">10-25</a> show how to encode various forms of the <code>add</code> instruction using different addressing modes.</p>&#13;
<div class="image"><img alt="image" src="../images/10fig18.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig18"/><em>Figure 10-18: Encoding the <code>add(al,</code> <code>cl);</code> instruction</em></p>&#13;
<p class="indent">There is an interesting side effect of the <code>mod-reg-r/m</code> organization and direction bit: some instructions have two different legal opcodes. For example, we could also encode the <code>add(al,</code> <code>cl);</code> instruction shown in <a href="ch10.xhtml#ch10fig18">Figure 10-18</a> as <code>$02,</code> <code>$c8</code> by reversing the positions of the AL and CL registers in the <code>reg</code> and <code>r/m</code> fields and then setting the <code>d</code> bit (bit 1) in the opcode to <code>1</code>. This applies to all instructions with two register operands and a direction bit, such as the <code>add(eax,</code> <code>ecx);</code> instruction in <a href="ch10.xhtml#ch10fig19">Figure 10-19</a>, which can also be encoded as <code>$03,</code> <code>$c8</code>.</p>&#13;
<div class="image"><img alt="image" src="../images/10fig19.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_311"/><a id="ch10fig19"/><em>Figure 10-19: Encoding the <code>add(eax,</code> <code>ecx);</code> instruction</em></p>&#13;
<div class="image"><img alt="image" src="../images/10fig20.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig20"/><em>Figure 10-20: Encoding the <code>add(disp,</code> <code>edx);</code> instruction</em></p>&#13;
<div class="image"><img alt="image" src="../images/10fig21.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_312"/><a id="ch10fig21"/><em>Figure 10-21: Encoding the <code>add([ebx],</code> <code>edi);</code> instruction</em></p>&#13;
<div class="image"><img alt="image" src="../images/10fig22.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig22"/><em>Figure 10-22: Encoding the <code>add([esi+disp</code><code><sub>8</sub></code><code>],</code> <code>eax);</code> instruction</em></p>&#13;
<div class="image"><img alt="image" src="../images/10fig23.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_313"/><a id="ch10fig23"/><em>Figure 10-23: Encoding the <code>add([ebp+disp</code><code><sub>32</sub></code><code>],</code> <code>ebx);</code> instruction</em></p>&#13;
<div class="image"><img alt="image" src="../images/10fig24.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig24"/><em>Figure 10-24: Encoding the <code>add([disp</code><code><sub>32</sub></code><code>+eax*1],</code> <code>ebp);</code> instruction</em></p>&#13;
<div class="image"><img alt="image" src="../images/10fig25.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_314"/><a id="ch10fig25"/><em>Figure 10-25: Encoding the <code>add([ebx+edi*4],</code> <code>ecx);</code> instruction</em></p>&#13;
<h4 class="h4" id="sec10_4_3"><strong><em>10.4.3 Encoding Immediate (Constant) Operands on the x86</em></strong></h4>&#13;
<p class="noindent">You may have noticed that the <code>mod-reg-r/m</code> and <code>sib</code> bytes don’t contain any bit combinations you can use to specify that an instruction contains an immediate operand. The 80x86 uses a completely different opcode to specify an immediate operand. <a href="ch10.xhtml#ch10fig26">Figure 10-26</a> shows the basic encoding for an <code>add</code> immediate instruction.</p>&#13;
<div class="image"><img alt="image" src="../images/10fig26.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig26"/><em>Figure 10-26: Encoding an <code>add</code> immediate instruction</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_315"/>There are three major differences between the encoding of the <code>add</code> immediate instruction and the standard <code>add</code> instruction. First, and most important, the opcode has a <code>1</code> in the HO bit position. This tells the CPU that the instruction has an immediate constant. This change alone, however, does not tell the CPU that it must execute an <code>add</code> instruction, as you’ll see shortly.</p>&#13;
<p class="indent">The second difference is that there’s no direction bit in the opcode. This makes sense because you cannot specify a constant as a destination operand. Therefore, the destination operand is always the location specified by the <code>mod</code> and <code>r/m</code> bits in the <code>mod-reg-r/m</code> field.</p>&#13;
<p class="indent">In place of the direction bit, the opcode has a sign-extension (<code>x</code>) bit. For 8-bit operands, the CPU ignores the sign-extension bit. For 16-bit and 32-bit operands, the sign-extension bit specifies the size of the constant following the <code>add</code> instruction. If the sign-extension bit contains <code>0</code>, the constant is already the same size as the operand (either 16 or 32 bits). If the sign-extension bit contains <code>1</code>, the constant is a signed 8-bit value, and the CPU sign-extends this value to the appropriate size before adding it to the operand. This little trick often makes programs much shorter, because you commonly add small constants to 16- or 32-bit destination operands.</p>&#13;
<p class="indent">The third difference between the <code>add</code> immediate and the standard <code>add</code> instruction is the meaning of the <code>reg</code> field in the <code>mod-reg-r/m</code> byte. Because the instruction implies that the source operand is a constant, and the <code>mod-r/m</code> fields specify the destination operand, the instruction does not need to use the <code>reg</code> field to specify an operand. Instead, the 80x86 CPU uses these 3 bits as an opcode extension. For the <code>add</code> immediate instruction, these 3 bits must contain <code>0</code>, and another bit pattern would correspond to a different instruction.</p>&#13;
<p class="indent">When a constant is added to a memory location, any displacement associated with that memory location immediately precedes the constant data in the instruction sequence.</p>&#13;
<h4 class="h4" id="sec10_4_4"><strong><em>10.4.4 Encoding 8-, 16-, and 32-Bit Operands</em></strong></h4>&#13;
<p class="noindent">When designing the 8086, Intel used one opcode bit (<code>s</code>) to specify whether the operand sizes were 8 or 16 bits. Later, when it extended the 80x86 architecture to 32 bits with the introduction of the 80386, Intel had a problem: with this single operand size bit, it could encode only two sizes, but it needed to encode three (8, 16, and 32 bits). To solve this problem, Intel used an <em>operand-size prefix byte</em>.</p>&#13;
<p class="indent">Intel studied its instruction set and concluded that in a 32-bit environment, programs were likely to use 8-bit and 32-bit operands far more often than 16-bit operands. Therefore, it decided to let the size bit (<code>s</code>) in the opcode select between 8- and 32-bit operands, as described in the previous sections. Although modern 32-bit programs don’t use 16-bit operands very often, they do need them now and then. So, Intel lets you prefix a 32-bit instruction with the operand-size prefix byte, whose value is <code>$66</code>, and this prefix byte tells the CPU that the operands contain 16-bit data rather than 32-bit data.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_316"/>You do not have to explicitly add an operand-size prefix byte to your 16-bit instructions; the assembler or compiler takes care of this automatically for you. However, do keep in mind that whenever you use a 16-bit object in a 32-bit program, the instruction is 1 byte longer because of the prefix value. Therefore, you should be careful about using 16-bit instructions if size and, to a lesser extent, speed are important.</p>&#13;
<h4 class="h4" id="sec10_4_5"><strong><em>10.4.5 Encoding 64-Bit Operands</em></strong></h4>&#13;
<p class="noindent">When running in 64-bit mode, Intel and AMD x84-64 processors use special opcode prefix bytes to specify 64-bit registers. There are 16 REX opcode bytes that handle 64-bit operands and addressing modes. Because there weren’t 16 single-byte opcodes available, AMD (who designed the instruction set) chose to repurpose 16 existing opcodes (the 1-byte opcode variants for the <code>inc(</code><span class="EmpItalic">reg</span><code>)</code> and <code>dec(</code><span class="EmpItalic">reg</span><code>)</code> instructions). There are still 2-byte variants of these instructions, so rather than eliminating the instructions altogether, AMD just removed the 1-byte versions. However, standard 32-bit code (a lot of which certainly uses those 1-byte increment and decrement instructions) can no longer run on the 64-bit model. That’s why AMD and Intel introduced new 32-bit and 64-bit operation modes—so the CPUs could run both older 32-bit code and newer 64-bit code on the same piece of silicon.</p>&#13;
<h4 class="h4" id="sec10_4_6"><strong><em>10.4.6 Alternate Encodings for Instructions</em></strong></h4>&#13;
<p class="noindent">As noted earlier in this chapter, one of Intel’s primary design goals for the 80x86 was to create an instruction set that allowed programmers to write very short programs in order to save memory, which was precious at the time. One way Intel did this was to create alternative encodings of some very commonly used instructions. These alternative instructions were shorter than their standard counterparts, and Intel hoped that programmers would make extensive use of the shorter versions, thereby creating shorter programs.</p>&#13;
<p class="indent">A good example of these alternative instructions are the <code>add(</code><span class="EmpItalic">constant</span><code>,</code> <span class="EmpItalic">accumulator</span><code>);</code> instructions, where the accumulator is <code>al</code>, <code>ax</code>, or <code>eax</code>. The 80x86 provides 1-byte opcodes for <code>add(</code><span class="EmpItalic">constant</span><code>, al);</code> and <code>add(</code><span class="EmpItalic">constant</span><code>, eax);</code>, which are <code>$04</code> and <code>$05</code>, respectively. With a 1-byte opcode and no <code>mod-reg-r/m</code> byte, these instructions are 1 byte shorter than their standard <code>add</code> immediate counterparts. The <code>add(</code><span class="EmpItalic">constant</span><code>,</code> <code>ax);</code> instruction requires an operand-size prefix, so its opcode is effectively 2 bytes. However, this is still 1 byte shorter than the corresponding standard <code>add</code> immediate.</p>&#13;
<p class="indent">You don’t have to specify anything special to use these instructions. Any decent assembler or compiler will automatically choose the shortest possible instruction it can use when translating your source code into machine code. However, you should note that Intel provides alternative encodings only for the accumulator registers. Therefore, if you have a choice of several instructions to use and the accumulator registers are among these choices, the AL, AX, and EAX registers are often your best bet. However, this option is usually available only to assembly language programmers.</p>&#13;
<h3 class="h3" id="sec10_5"><span epub:type="pagebreak" id="page_317"/><strong>10.5 Implications of Instruction Set Design to the Programmer</strong></h3>&#13;
<p class="noindent">Only by knowing the computer’s architecture and, in particular, how the CPU encodes machine instructions, can you make the most efficient use of the machine’s instructions. By studying instruction set design, you can gain a clear understanding of the following:</p>&#13;
<ul>&#13;
<li class="noindent">Why some instructions are shorter than others</li>&#13;
<li class="noindent">Why some instructions are faster than others</li>&#13;
<li class="noindent">Which constant values the CPU can handle efficiently</li>&#13;
<li class="noindent">Whether constants are more efficient than memory locations</li>&#13;
<li class="noindent">Why certain arithmetic and logical operations are more efficient than others</li>&#13;
<li class="noindent">Which types of arithmetic expressions are more easily translated into machine code than other types</li>&#13;
<li class="noindent">Why code is less efficient if it transfers control over a large distance in the object code</li>&#13;
</ul>&#13;
<p class="noindent">. . . and so on.</p>&#13;
<p class="indent">By studying instruction set design, you become more aware of the implications of the code you write (even in an HLL) in terms of efficient operation on the CPU. Armed with this knowledge, you’ll be better equipped to write great code.</p>&#13;
<h3 class="h3" id="sec10_6"><strong>10.6 For More Information</strong></h3>&#13;
<p class="ref">Hennessy, John L., and David A. Patterson. <em>Computer Architecture: A Quantitative Approach</em>. 5th ed. Waltham, MA: Elsevier, 2012.</p>&#13;
<p class="ref">Hyde, Randall. <em>The Art of Assembly Language</em>. 2nd ed. San Francisco: No Starch Press, 2010.</p>&#13;
<p class="ref">Intel. “Intel® 64 and IA-32 Architectures Software Developer Manuals.” Last updated November 11, 2019. <em><a href="https://software.intel.com/en-us/articles/intel-sdm/">https://software.intel.com/en-us/articles/intel-sdm/</a>.</em><span epub:type="pagebreak" id="page_318"/></p>&#13;
</body></html>