<html><head></head><body>
<h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_283"/><strong><span class="big">10</span><br/>INSTRUCTION SET ARCHITECTURE</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/comm1.jpg"/></div>&#13;
<p class="noindents">This chapter discusses the implementation of a CPU’s instruction set. Although the choice of a given instruction set is usually beyond a software engineer’s control, understanding the decisions a hardware design engineer has to make when designing a CPU’s instruction set can definitely help you write better code.</p>&#13;
<p class="indent">CPU instruction sets contain several tradeoffs based on assumptions that computer architects make about the way software engineers write code. If the machine instructions you choose match those assumptions, your code will probably run faster and require fewer machine resources. Conversely, if your code violates the assumptions, chances are pretty good it won’t perform as well as it otherwise could.</p>&#13;
<p class="indent">Although studying the instruction set may seem like a task suited only to assembly language programmers, even high-level language programmers can benefit from doing so. After all, every HLL statement maps to some sequence of machine instructions, and the general concepts of instruction <span epub:type="pagebreak" id="page_284"/>set design are portable across architectures. Even if you never intend to write software using assembly language, it’s important to understand how the underlying machine instructions work and how they were designed.</p>&#13;
<h3 class="h3" id="sec10_1"><strong>10.1 The Importance of Instruction Set Design</strong></h3>&#13;
<p class="noindent">While features like caches, pipelining, and superscalar implementation can all be grafted onto a CPU long after the original design is obsolete, it’s very difficult to change the instruction set once a CPU is in production and people are writing software using it. Therefore, instruction set design requires very careful consideration; the designer must get the <em><a href="gloss01.xhtml#gloss01_125">instruction set architecture (ISA)</a></em> correct from the start of the design cycle.</p>&#13;
<p class="indent">You might assume that the “kitchen sink” approach to instruction set design—in which you include every instruction you can dream up—is best. However, instruction set design is the epitome of compromise management. Why can’t we have it all? Well, in the real world there are some nasty realities that prevent this:</p>&#13;
<p class="uln-indent"><strong>Silicon real estate</strong> The first nasty reality is that each feature requires some number of transistors on the CPU’s silicon die (chip), so CPU designers have a “silicon budget”—a finite number of transistors to work with. There simply aren’t enough transistors to support putting every possible feature on a CPU. The original 8086 processor, for example, had a silicon budget of fewer than 30,000 transistors. The 1999 Pentium III processor had a budget of over 9 million transistors. The 2019 AWS Graviton2 (ARM) CPU has over 30 billion transistors.<sup><a href="footnotes.xhtml#fn10_1a" id="fn10_1">1</a></sup> These three budgets reflect the differences in semiconductor technology from 1978 to today.</p>&#13;
<p class="uln-indent"><strong>Cost</strong> Although it’s possible to use billions of transistors on a CPU today, the more transistors used, the more expensive the CPU. For example, at the beginning of 2018, Intel i7 processors using billions of transistors cost hundreds of dollars, whereas contemporary CPUs with 30,000 transistors cost less than a dollar.</p>&#13;
<p class="uln-indent"><strong>Expandability</strong> It’s very difficult to anticipate all the features people will want. For example, Intel’s MMX and SIMD instruction enhancements were added to make multimedia programming more practical on the Pentium processor. Back in 1978, when Intel created the first 8086 processor, very few people could have predicted the need for these instructions. A CPU designer must allow for making extensions to the instruction set in future members of the CPU family to accommodate currently unanticipated needs.</p>&#13;
<p class="uln-indent"><strong>Legacy support for old instructions</strong> This nasty reality is almost the opposite of expandability. Often, an instruction that the CPU designer feels is important now turns out to be less useful than expected. For <span epub:type="pagebreak" id="page_285"/>example, the <span class="literal">loop</span> and <span class="literal">enter</span> instructions on the 80x86 CPU see very little use in modern high-performance programs. It’s commonly the case that programs never use some of the instructions in a CPU adopting the kitchen sink approach. Unfortunately, once an instruction is added to the instruction set, it has to be supported in all future versions of the processor, unless few enough programs use the instruction that CPU designers are willing to let those programs break.</p>&#13;
<p class="uln-indent"><strong>Complexity</strong> A CPU designer must consider the assembly programmers and compiler writers who will be using the chip. A CPU employing the kitchen sink approach might appeal to someone who’s already familiar with that CPU, but no one else will want to learn an overly complex system.</p>&#13;
<p class="indent">These problems with the kitchen sink approach all have a common solution: design a simple instruction set for the first version of the CPU, and leave room for later expansion. This is one of the main reasons the 80x86 has proven to be so popular and long-lived. Intel started with a relatively simple CPU and figured out how to extend the instruction set over the years to accommodate new features.</p>&#13;
<h3 class="h3" id="sec10_2"><strong>10.2 Basic Instruction Design Goals</strong></h3>&#13;
<p class="noindent">The efficiency of your programs largely depends upon the instructions that they use. Short instructions use very little memory and often execute rapidly, but they can’t tackle big tasks. Larger instructions can handle more complex tasks, with a single instruction often doing the work of several short instructions, but they may consume excessive memory or require many machine cycles to execute. To enable software engineers to write the best possible code, computer architects must strike a balance between the two.</p>&#13;
<p class="indent">In a typical CPU, the computer encodes instructions as numeric values (operation codes, or <em>opcodes</em>) and stores them in memory. Encoding these instructions is one of the major tasks in instruction set design, requiring careful thought. Instructions must each have a unique opcode, so the CPU can differentiate them. With an <em>n</em>-bit number, there are 2<sup><em>n</em></sup> different possible opcodes, so to encode <em>m</em> instructions requires at least log<sub>2</sub>(<em>m</em>) bits. The main point to keep in mind is that the size of individual CPU instructions is dependent on the total number of instructions that the CPU supports.</p>&#13;
<p class="indent">Encoding opcodes is a little more involved than assigning a unique numeric value to each instruction. As the previous chapter discussed, decoding each instruction and executing the specified task requires actual circuitry. With a 7-bit opcode, we could encode 128 different instructions. To decode each of these 128 instructions requires a 7- to 128-line decoder—an expensive piece of circuitry. However, assuming that the instruction opcodes contain certain (binary) patterns, a single large decoder can often be replaced by several smaller, less expensive ones.</p>&#13;
<p class="indent">If an instruction set contains 128 unrelated instructions, there’s little you can do other than decode the entire bit string for each instruction. However, in most architectures the instructions fall into categories. On <span epub:type="pagebreak" id="page_286"/>the 80x86 CPUs, for example, <span class="literal">mov(eax,</span> <span class="literal">ebx);</span> and <span class="literal">mov(ecx,</span> <span class="literal">edx);</span> have different opcodes, because they’re different instructions, but they’re obviously related in that they both move data from one register to another. The only difference is their source and destination operands. Thus, CPU designers could encode instructions like <span class="literal">mov</span> with a <em>subopcode</em>, and then they could encode the instruction’s operands using other bit fields within the opcode.</p>&#13;
<p class="indent">For example, given an instruction set with only eight instructions, each with two operands, and each operand having only one of four possible values, we could encode the instructions using three packed fields containing 3, 2, and 2 bits, respectively (see <a href="ch10.xhtml#ch10fig01">Figure 10-1</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/10fig01.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig01"/><em>Figure 10-1: Separating an opcode into several fields to simplify decoding</em></p>&#13;
<p class="indent">This encoding needs only three simple decoders to determine what the CPU should do. While this is a basic example, it demonstrates one very important facet of instruction set design: opcodes should be easy to decode. The easiest way to simplify the opcode is to construct it using several different bit fields. The smaller these bit fields are, the easier it will be for the hardware to decode and execute the instruction.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_287"/>The CPU designer’s goal, then, is to assign an appropriate number of bits to the opcode’s instruction field and to its operand fields. Choosing more bits for the instruction field lets the opcode encode more instructions, just as choosing more bits for the operand fields lets the opcode specify a larger number of operands (often memory locations or registers). You might think that when encoding 2<sup><em>n</em></sup> different instructions using <em>n</em> bits, you’d have very little leeway in choosing the size of the instruction. It’s going to take <em>n</em> bits to encode those 2<sup><em>n</em></sup> instructions; you can’t do it with any fewer. It <em>is</em> possible, however, to use more than <em>n</em> bits. This might seem wasteful, but sometimes it’s advantageous. Again, picking an appropriate instruction size is one of the more important aspects of instruction set design.</p>&#13;
<h4 class="h4" id="sec10_2_1"><strong><em>10.2.1 Choosing Opcode Length</em></strong></h4>&#13;
<p class="noindent">Opcode length isn’t arbitrary. Assuming that a CPU is capable of reading bytes from memory, the opcode will probably have to be some multiple of 8 bits long. If the CPU is not capable of reading bytes from memory (most RISC CPUs read memory only in 32- or 64-bit chunks), the opcode will be the same size as the smallest object the CPU can read from memory at one time. Any attempt to shrink the opcode size below this limit is futile. In this chapter, we’ll work with the first case: opcodes that must have a length that is a multiple of 8 bits.</p>&#13;
<p class="indent">Another point to consider is the size of an instruction’s operands. Some CPU designers include all operands in their opcode. Other CPU designers don’t count operands like immediate constants or address displacements as part of the opcode, and this is the approach we’ll take.</p>&#13;
<p class="indent">An 8-bit opcode can encode only 256 different instructions. Even if we don’t count instruction operands as part of the opcode, having only 256 different instructions is a stringent limit. Though CPUs with 8-bit opcodes exist, modern processors tend to have far more than 256 different instructions. Because opcodes must have a length that is a multiple of 8 bits, the next smallest possible opcode size is 16 bits. A 2-byte opcode can encode up to 65,536 different instructions, though the instructions will be larger.</p>&#13;
<p class="indent">When reducing instruction size is an important design goal, CPU designers often employ data compression theory. The first step is to analyze programs written for a typical CPU and count how many times each instruction occurs over a large number of applications. The second step is to create a list of these instructions, sorted by their frequency of use. Next, the designer assigns the 1-byte opcodes to the most frequently used instructions; 2-byte opcodes to the next most frequently used instructions; and opcodes of 3 or more bytes to the rarely used instructions. Although this scheme requires opcodes with a maximum size of 3 or more bytes, most of the actual instructions in a program will use 1- or 2-byte opcodes. The average opcode length will be somewhere between 1 and 2 bytes (let’s say 1.5 bytes), and a typical program will be shorter than had all the instructions employed a 2-byte opcode (see <a href="ch10.xhtml#ch10fig02">Figure 10-2</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/10fig02.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_288"/><a id="ch10fig02"/><em>Figure 10-2: Encoding instructions using a variable-length opcode</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_289"/>Although using variable-length instructions allows us to create smaller programs, it comes at a price. First, decoding variable-length instructions is a bit more complicated than decoding fixed-length instructions. Before decoding a particular instruction field, the CPU must first decode the instruction’s size, which consumes time. This may affect the CPU’s overall performance by introducing delays in the decoding step, which in turn limits the CPU’s maximum clock speed (because those delays stretch out a single clock period, thus reducing the CPU’s clock frequency). Variable-length instructions also make decoding multiple instructions in a pipeline difficult, because the CPU can’t easily determine the instruction boundaries in the prefetch queue.</p>&#13;
<p class="indent">For these reasons and others, most popular RISC architectures avoid variable-length instructions. However, in this chapter, we’ll study a variable-length approach, because saving memory is an admirable goal.</p>&#13;
<h4 class="h4" id="sec10_2_2"><strong><em>10.2.2 Planning for the Future</em></strong></h4>&#13;
<p class="noindent">Before actually choosing the instructions to implement in a CPU, designers must plan for the future. As explained earlier, the need for new instructions will undoubtedly arise after the initial design, so it’s wise to reserve some opcodes specifically for expansion purposes. Given the instruction opcode format in <a href="ch10.xhtml#ch10fig02">Figure 10-2</a>, it might not be a bad idea to reserve one block of 64 1-byte opcodes, half (4,096) of the 2-byte opcodes, and half (1,048,576) of the 3-byte opcodes for future use. Giving up 64 of the very valuable 1-byte opcodes may seem extravagant, but history suggests that such foresight is rewarded.</p>&#13;
<h4 class="h4" id="sec10_2_3"><strong><em>10.2.3 Choosing Instructions</em></strong></h4>&#13;
<p class="noindent">The next step is to choose the instructions to implement. Even if nearly half the instructions have been reserved for future expansion, that doesn’t mean that all the remaining opcodes must be used to implement instructions. A designer can leave a number of these instructions unimplemented, effectively reserving them for the future as well. The right approach is not to use up the opcodes as quickly as possible, but rather to produce a consistent and complete instruction set given the design compromises. It’s much easier to add an instruction later than it is to remove one, so, for the first go-round, it’s generally better to go with a simpler design.</p>&#13;
<p class="indent">First, choose some generic instruction types. Early in the design process it’s important to limit your choices to very common instructions. Other processors’ instruction sets are probably the best place to look for suggestions. For example, most processors have the following:</p>&#13;
<ul>&#13;
<li class="noindent">Data movement instructions (such as <span class="literal">mov</span>)</li>&#13;
<li class="noindent">Arithmetic and logical instructions (such as <span class="literal">add</span>, <span class="literal">sub</span>, <span class="literal">and</span>, <span class="literal">or</span>, <span class="literal">not</span>)</li>&#13;
<li class="noindent">Comparison instructions</li>&#13;
<li class="noindent">Conditional jump instructions (generally used after the comparison instructions)</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_290"/>Input/output instructions</li>&#13;
<li class="noindent">Other miscellaneous instructions</li>&#13;
</ul>&#13;
<p class="indent">The initial instruction set should comprise a reasonable number of instructions that will allow programmers to write efficient programs, without exceeding the silicon budget or violating other design constraints. This requires CPU designers to make strategic decisions based on careful research, experimentation, and simulation.</p>&#13;
<h4 class="h4" id="sec10_2_4"><strong><em>10.2.4 Assigning Opcodes to Instructions</em></strong></h4>&#13;
<p class="noindent">After choosing the initial instructions, the CPU designer assigns opcodes to them. The first step in this process is to group the instructions according to the characteristics they share. For example, an <span class="literal">add</span> instruction probably supports the exact same set of operands as the <span class="literal">sub</span> instruction, so it makes sense to group these two instructions together. On the other hand, the <span class="literal">not</span> and <span class="literal">neg</span> instructions each generally require only a single operand. Therefore, it makes sense to put these two instructions in the same group, but one separate from the <span class="literal">add</span> and <span class="literal">sub</span> group.</p>&#13;
<p class="indent">Once all the instructions are grouped, the next step is to encode them. A typical encoding scheme uses some bits to select the group, some to select a particular instruction from that group, and some to encode the operand types (such as registers, memory locations, and constants). The number of bits needed to encode all this information can have a direct impact on the instruction’s size, regardless of how often the instruction is used. For example, suppose 2 bits are needed to select an instruction’s group, 4 bits to select the instruction within that group, and 6 bits to specify the instruction’s operand types. In this case, the instructions are not going to fit into an 8-bit opcode. On the other hand, if all we need is to push one of eight different registers onto the stack, 4 bits will be enough to specify the <span class="literal">push</span> instruction group, and 3 bits will be enough to specify the register.</p>&#13;
<p class="indent">Encoding instruction operands with a minimal amount of space is always a problem, because many instructions allow a large number of operands. For example, the generic 32-bit 80x86 <span class="literal">mov</span> instruction allows two operands and requires a 2-byte opcode.<sup><a href="footnotes.xhtml#fn10_2a" id="fn10_2">2</a></sup> However, Intel noticed that <span class="literal">mov(</span><span class="EmpItalic">disp</span><span class="literal">, eax);</span> and <span class="literal">mov(eax,</span> <span class="EmpItalic">disp</span><span class="literal">);</span> occur frequently in programs, so it created a special 1-byte version of these instructions to reduce their size and, consequently, the size of programs that use them. Intel did not remove the 2-byte versions of these instructions, though: there are two different instructions that store EAX into memory and two different instructions that load EAX from memory. A compiler or assembler will always emit the shorter versions of each pair of instructions.</p>&#13;
<p class="indent">Intel made an important tradeoff with the <span class="literal">mov</span> instruction: it gave up an extra opcode in order to provide a shorter version of one variant of each instruction. Actually, Intel uses this trick all over the place to create <span epub:type="pagebreak" id="page_291"/>shorter and easier-to-decode instructions. Back in 1978, creating redundant instructions to reduce program size was a good compromise given the cost of memory. Today, however, a CPU designer would probably use those redundant opcodes for different purposes.</p>&#13;
<h3 class="h3" id="sec10_3"><strong>10.3 The Y86 Hypothetical Processor</strong></h3>&#13;
<p class="noindent">Because of enhancements made to the 80x86 processor family over time, Intel’s design goals in 1978, and the evolution of computer architecture, the encoding of 80x86 instructions is very complex and somewhat illogical. In short, the 80x86 is not a good introductory example of instruction set design. To work around this, we’ll discuss instruction set design in two stages: first, we’ll develop a trivial instruction set for the Y86, a hypothetical processor that is a small subset of the 80x86, and then we’ll expand our discussion to the full 80x86 instruction set.</p>&#13;
<h4 class="h4" id="sec10_3_1"><strong><em>10.3.1 Y86 Limitations</em></strong></h4>&#13;
<p class="noindent">The hypothetical Y86 processor is a <em>very</em> stripped-down version of the 80x86 CPUs. It supports only:</p>&#13;
<ul>&#13;
<li class="noindent">One operand size: 16 bits. This simplification frees us from having to encode the operand size as part of the opcode (thereby reducing the total number of opcodes we’ll need).</li>&#13;
<li class="noindent">Four 16-bit registers: AX, BX, CX, and DX. This lets us encode register operands with only 2 bits (versus the 3 bits the 80x86 family requires to encode eight registers).</li>&#13;
<li class="noindent">A 16-bit address bus with a maximum of 65,536 bytes of addressable memory.</li>&#13;
</ul>&#13;
<p class="indent">These simplifications, plus a very limited instruction set, will allow us to encode all Y86 instructions using a 1-byte opcode and a 2-byte displacement/offset when applicable.</p>&#13;
<h4 class="h4" id="sec10_3_2"><strong><em>10.3.2 Y86 Instructions</em></strong></h4>&#13;
<p class="noindent">Including both forms of the <span class="literal">mov</span> instruction, the Y86 CPU still provides only 18 basic instructions. Seven of these instructions have two operands, eight have one operand, and five have no operands at all. The instructions are <span class="literal">mov</span> (two forms), <span class="literal">add</span>, <span class="literal">sub</span>, <span class="literal">cmp</span>, <span class="literal">and</span>, <span class="literal">or</span>, <span class="literal">not</span>, <span class="literal">je</span>, <span class="literal">jne</span>, <span class="literal">jb</span>, <span class="literal">jbe</span>, <span class="literal">ja</span>, <span class="literal">jae</span>, <span class="literal">jmp</span>, <span class="literal">get</span>, <span class="literal">put</span>, and <span class="literal">halt</span>.</p>&#13;
<h5 class="h5" id="sec10_3_2_1"><strong>10.3.2.1 The mov Instruction</strong></h5>&#13;
<p class="noindent">The <span class="literal">mov</span> instruction comes in two forms, merged into the same instruction class:</p>&#13;
<p class="programs">mov( <span class="EmpItalic1">reg</span>/<span class="EmpItalic1">memory</span>/<span class="EmpItalic1">constant</span>, <span class="EmpItalic1">reg</span> );<br/>&#13;
mov( <span class="EmpItalic1">reg</span>, <span class="EmpItalic1">memory</span> );</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_292"/>In these forms, <span class="EmpItalic">reg</span> is either register <span class="literal">ax</span>, <span class="literal">bx</span>, <span class="literal">cx</span>, or <span class="literal">dx</span>; <span class="EmpItalic">memory</span> is an operand specifying a memory location; and <span class="EmpItalic">constant</span> is a numeric constant using hexadecimal notation.</p>&#13;
<h5 class="h5" id="sec10_3_2_2"><strong>10.3.2.2 Arithmetic and Logical Instructions</strong></h5>&#13;
<p class="noindent">The arithmetic and logical instructions are as follows:</p>&#13;
<p class="programs">add( <span class="EmpItalic1">reg</span>/<span class="EmpItalic1">memory</span>/<span class="EmpItalic1">constant</span>, <span class="EmpItalic1">reg</span> );<br/>&#13;
sub( <span class="EmpItalic1">reg</span>/<span class="EmpItalic1">memory</span>/<span class="EmpItalic1">constant</span>, <span class="EmpItalic1">reg</span> );<br/>&#13;
cmp( <span class="EmpItalic1">reg</span>/<span class="EmpItalic1">memory</span>/<span class="EmpItalic1">constant</span>, <span class="EmpItalic1">reg</span> );<br/>&#13;
and( <span class="EmpItalic1">reg</span>/<span class="EmpItalic1">memory</span>/<span class="EmpItalic1">constant</span>, <span class="EmpItalic1">reg</span> );<br/>&#13;
or( <span class="EmpItalic1">reg</span>/<span class="EmpItalic1">memory</span>/<span class="EmpItalic1">constant</span>, <span class="EmpItalic1">reg</span> );<br/><br/>&#13;
not( <span class="EmpItalic1">reg</span>/<span class="EmpItalic1">memory</span> );</p>&#13;
<p class="indent">The <span class="literal">add</span> instruction adds the value of the first operand to the value of the second, storing the sum in the second operand. The <span class="literal">sub</span> instruction subtracts the value of the first operand from the value of the second, storing the difference in the second operand. The <span class="literal">cmp</span> instruction compares the value of the first operand against the value of the second and saves the result of the comparison for use by the conditional jump instructions (described in the next section). The <span class="literal">and</span> and <span class="literal">or</span> instructions compute bitwise logical operations between their two operands and store the result in the second operand. The <span class="literal">not</span> instruction appears separately because it supports only a single operand. <span class="literal">not</span> is the bitwise logical operation that inverts the bits of its single memory or register operand.</p>&#13;
<h5 class="h5" id="sec10_3_2_3"><strong>10.3.2.3 Control Transfer Instructions</strong></h5>&#13;
<p class="noindent">The <em>control transfer instructions</em> interrupt the execution of instructions stored in sequential memory locations and transfer control to instructions stored at some other point in memory. They do this either unconditionally, or conditionally based upon the result from a <span class="literal">cmp</span> instruction. These are the control transfer instructions:</p>&#13;
<p class="programs">ja   <span class="EmpItalic1">dest</span>;  // Jump if above (i.e., greater than)<br/>&#13;
jae  <span class="EmpItalic1">dest</span>;  // Jump if above or equal (i.e., greater than or equal to)<br/>&#13;
jb   <span class="EmpItalic1">dest</span>;  // Jump if below (i.e., less than)<br/>&#13;
jbe  <span class="EmpItalic1">dest</span>;  // Jump if below or equal (i.e., less than or equal to)<br/>&#13;
je   <span class="EmpItalic1">dest</span>;  // Jump if equal<br/>&#13;
jne  <span class="EmpItalic1">dest</span>;  // Jump if not equal<br/><br/>&#13;
jmp  <span class="EmpItalic1">dest</span>;  // Unconditional jump</p>&#13;
<p class="indent">The first six instructions (<span class="literal">ja</span>, <span class="literal">jae</span>, <span class="literal">jb</span>, <span class="literal">jbe</span>, <span class="literal">je</span>, and <span class="literal">jne</span>) let you check the result of the previous <span class="literal">cmp</span> instruction—that is, the result of the comparison of that instruction’s first and second operands.<sup><a href="footnotes.xhtml#fn10_3a" id="fn10_3">3</a></sup> For example, if you <span epub:type="pagebreak" id="page_293"/>compare the AX and BX registers with a <span class="literal">cmp(ax,</span> <span class="literal">bx);</span> instruction and then execute the <span class="literal">ja</span> instruction, the Y86 CPU will jump to the specified destination location if AX is greater than BX. If AX is not greater than BX, control will fall through to the next instruction in the program. In contrast to the first six instructions, the <span class="literal">jmp</span> instruction unconditionally transfers control to the instruction at the destination address.</p>&#13;
<h5 class="h5" id="sec10_3_2_4"><strong>10.3.2.4 Miscellaneous Instructions</strong></h5>&#13;
<p class="noindent">The Y86 supports three instructions that do not have any operands:</p>&#13;
<p class="programs">get;   // Read an integer value into the AX register<br/>&#13;
put;   // Display the value in the AX register<br/>&#13;
halt;  // Terminate the program</p>&#13;
<p class="indent">The <span class="literal">get</span> and <span class="literal">put</span> instructions let you read and write integer values: <span class="literal">get</span> prompts the user for a hexadecimal value and then stores that value into the AX register; <span class="literal">put</span> displays the value of the AX register in hexadecimal format. The <span class="literal">halt</span> instruction terminates program execution.</p>&#13;
<h4 class="h4" id="sec10_3_3"><strong><em>10.3.3 Operand Types and Addressing Modes on the Y86</em></strong></h4>&#13;
<p class="noindent">Before assigning opcodes, we need to look at the operands these instructions support. The 18 Y86 instructions use five different operand types: registers, constants, and three memory-addressing modes (the <em>indirect</em> addressing mode, the <em>indexed</em> addressing mode, and the <em>direct</em> addressing mode). See <a href="ch06.xhtml#ch06">Chapter 6</a> for more details on these addressing modes.</p>&#13;
<h4 class="h4" id="sec10_3_4"><strong><em>10.3.4 Encoding Y86 Instructions</em></strong></h4>&#13;
<p class="noindent">Because a real CPU uses logic circuitry to decode the opcodes and act appropriately on them, it’s not a good idea to arbitrarily assign opcodes to machine instructions. Instead, a typical CPU opcode uses a certain number of bits to denote the instruction class (such as <span class="literal">mov</span>, <span class="literal">add</span>, and <span class="literal">sub</span>), and a certain number of bits to encode each operand.</p>&#13;
<p class="indent">A typical Y86 instruction takes the form shown in <a href="ch10.xhtml#ch10fig03">Figure 10-3</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/10fig03.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig03"/><em>Figure 10-3: Basic Y86 instruction encoding</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_294"/>The basic instruction is either 1 or 3 bytes long, and its opcode consists of a single byte containing three fields. The first field, consisting of the HO 3 bits, defines the instruction, and these 3 bits provide eight possible combinations. As there are 18 different Y86 instructions, we’ll have to pull some tricks to handle the remaining 10 instructions.</p>&#13;
<h5 class="h5" id="sec10_3_4_1"><strong>10.3.4.1 Eight Generic Y86 Instructions</strong></h5>&#13;
<p class="noindent">As you can see in <a href="ch10.xhtml#ch10fig03">Figure 10-3</a>, seven of the eight basic opcodes encode the <span class="literal">or</span>, <span class="literal">and</span>, <span class="literal">cmp</span>, <span class="literal">sub</span>, and <span class="literal">add</span> instructions, as well as both versions of the <span class="literal">mov</span> instruction. The eighth, <span class="literal">000</span>, is an <em>expansion opcode</em>. This special instruction class, which we’ll return to shortly, provides a mechanism that allows us to expand the set of available instructions.</p>&#13;
<p class="indent">To determine the full opcode for a particular instruction, you simply select the appropriate bits for the <span class="literal">iii</span>, <span class="literal">rr</span>, and <span class="literal">mmm</span> fields (identified in <a href="ch10.xhtml#ch10fig03">Figure 10-3</a>). The <span class="literal">rr</span> field contains the destination register (except for the version of the <span class="literal">mov</span> instruction whose <span class="literal">iii</span> field is <span class="literal">111</span>), and the <span class="literal">mmm</span> field encodes the source register. For example, to encode the <span class="literal">mov(bx, ax);</span> instruction you would select <span class="literal">iii</span> = <span class="literal">110</span> (<span class="literal">mov(</span><span class="EmpItalic">reg</span><span class="literal">,</span> <span class="EmpItalic">reg</span><span class="literal">);</span>), <span class="literal">rr</span> = <span class="literal">00</span> (<span class="literal">ax</span>), and <span class="literal">mmm</span> <span class="literal">= 001</span> (<span class="literal">bx</span>). This produces the 1-byte instruction <span class="literal">%11000001</span>, or <span class="literal">$c0</span>.</p>&#13;
<p class="indent">Some Y86 instructions are larger than 1 byte. To illustrate why this is necessary, take, for example, the instruction <span class="literal">mov([1000], ax);</span>, which loads the AX register with the value stored at memory location <span class="literal">$1000</span>. The encoding for the opcode is <span class="literal">%11000110</span>, or <span class="literal">$c6</span>. However, the encoding for the <span class="literal">mov([2000], ax);</span> instruction is also <span class="literal">$c6</span>. Clearly these two instructions do different things: one loads the AX register from memory location <span class="literal">$1000</span>, while the other loads the AX register from memory location <span class="literal">$2000</span>.</p>&#13;
<p class="indent">In order to differentiate between instructions that encode an address using the [<span class="EmpItalic">xxxx</span>] or [<span class="EmpItalic">xxxx</span><span class="literal">+bx</span>] addressing modes, or to encode a constant using the immediate addressing mode, you must append the 16-bit address or constant to the instruction’s opcode. Within this 16-bit address or constant, the LO byte follows the opcode in memory and the HO byte follows the LO byte. So, the 3-byte encoding for <span class="literal">mov([1000], ax);</span> would be <span class="literal">$c6,</span> <span class="literal">$00,</span> <span class="literal">$10</span>, and the 3-byte encoding for <span class="literal">mov([2000], ax);</span> would be <span class="literal">$c6,</span> <span class="literal">$00,</span> <span class="literal">$20</span>.</p>&#13;
<h5 class="h5" id="sec10_3_4_2"><strong>10.3.4.2 The Special Expansion Opcode</strong></h5>&#13;
<p class="noindent">The special opcode in <a href="ch10.xhtml#ch10fig03">Figure 10-3</a> allows the Y86 CPU to expand the set of available instructions that can be encoded using a single byte. This opcode handles several zero- and one-operand instructions, as shown in <a href="ch10.xhtml#ch10fig04">Figures 10-4</a> and <a href="ch10.xhtml#ch10fig05">10-5</a>.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10fig04">Figure 10-4</a> shows the encodings of four one-operand instruction classes. The first 2-bit encoding for the <span class="literal">rr</span> field, <span class="literal">%00</span>, further expands the instruction set by providing a way to encode the zero-operand instructions shown in <a href="ch10.xhtml#ch10fig05">Figure 10-5</a>. Five of these instructions are illegal instruction opcodes; the three valid opcodes are the <span class="literal">halt</span> instruction, which terminates program execution; the <span class="literal">get</span> instruction, which reads a hexadecimal value from the user and stores it in the AX register; and the <span class="literal">put</span> instruction, which outputs the value in the AX register.</p>&#13;
<div class="image"><img alt="image" src="../images/10fig04.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_295"/><a id="ch10fig04"/><em>Figure 10-4: Single-operand instruction encodings (<span class="literal">iii = %000</span>)</em></p>&#13;
<div class="image"><img alt="image" src="../images/10fig05.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig05"/><em>Figure 10-5: Zero-operand instruction encodings (<span class="literal">iii = %000</span> and <span class="literal">rr = %00</span>)</em></p>&#13;
<p class="indent">The second 2-bit encoding for the <span class="literal">rr</span> field, <span class="literal">%01</span>, is also part of an expansion opcode that provides all the Y86 jump instructions (see <a href="ch10.xhtml#ch10fig06">Figure 10-6</a>). The third <span class="literal">rr</span> field encoding, <span class="literal">%10</span>, is for the <span class="literal">not</span> instruction. The fourth <span class="literal">rr</span> field encoding is currently unassigned. Any attempt to execute an opcode with an <span class="literal">iii</span> field encoding of <span class="literal">%000</span> and an <span class="literal">rr</span> field encoding of <span class="literal">%11</span> will halt the processor with an illegal instruction error. As previously discussed, CPU designers often reserve unassigned opcodes like this one so they can extend the instruction set in the future (as Intel did when moving from the 80286 processor to the 80386 or from the 32-bit x86 processors to the 64-bit x86-64 processors).</p>&#13;
<p class="indent">The seven jump instructions in the Y86 instruction set all take the form <span class="literal">j</span><span class="EmpItalic">xx</span> <span class="EmpItalic">address</span><span class="literal">;</span>. The <span class="literal">jmp</span> instruction copies the 16-bit address value that follows the opcode into the instruction pointer register, causing the CPU to fetch the next instruction from the target address of the <span class="literal">jmp</span>. The remaining six instructions—<span class="literal">ja</span>, <span class="literal">jae</span>, <span class="literal">jb</span>, <span class="literal">jbe</span>, <span class="literal">je</span>, and <span class="literal">jne</span>—test some condition and, if it is <span class="literal">true</span>, copy the address value into the instruction pointer register. The eighth opcode, <span class="literal">%00001111</span>, is another illegal opcode. These encodings are shown in <a href="ch10.xhtml#ch10fig06">Figure 10-6</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/10fig06.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_296"/><a id="ch10fig06"/><em>Figure 10-6: Jump instruction encodings</em></p>&#13;
<h4 class="h4" id="sec10_3_5"><strong><em>10.3.5 Examples of Encoding Y86 Instructions</em></strong></h4>&#13;
<p class="noindent">The Y86 processor does not execute instructions as human-readable strings of characters like <span class="literal">mov(ax, bx);</span>. Instead, it fetches instructions as bit patterns, such as <span class="literal">$c1</span>, from memory, then decodes and executes those bit patterns. Human-readable instructions like <span class="literal">mov(ax,</span> <span class="literal">bx);</span> and <span class="literal">add(5,</span> <span class="literal">cx);</span> must first be converted into binary representation, or <em><a href="gloss01.xhtml#gloss01_142">machine code</a></em>. This section will explore this conversion.</p>&#13;
<h5 class="h5" id="sec10_3_5_1"><strong>10.3.5.1 The add Instruction</strong></h5>&#13;
<p class="noindent">We’ll start our conversion with a very simple example, the <span class="literal">add(cx,</span> <span class="literal">dx);</span> instruction. Once you’ve chosen the instruction, you look it up in one of the opcode figures from the previous section. The <span class="literal">add</span> instruction is in the first group (see <a href="ch10.xhtml#ch10fig03">Figure 10-3</a>) and has an <span class="literal">iii</span> field of <span class="literal">%101</span>. The source operand is <span class="literal">cx</span>, so the <span class="literal">mmm</span> field is <span class="literal">%010</span>. The destination operand is <span class="literal">dx</span>, so the <span class="literal">rr</span> field is <span class="literal">%11</span>. Merging these bits produces the opcode <span class="literal">%10111010</span>, or <span class="literal">$ba</span> (see <a href="ch10.xhtml#ch10fig07">Figure 10-7</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/10fig07.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig07"/><em>Figure 10-7: Encoding the <span class="literal">add(</span> <span class="literal">cx,</span> <span class="literal">dx</span> <span class="literal">);</span> instruction</em></p>&#13;
<p class="indent">Now consider the <span class="literal">add(5, ax)</span> instruction. Because it has an immediate source operand (a constant), the <span class="literal">mmm</span> field will be <span class="literal">%111</span> (see <a href="ch10.xhtml#ch10fig03">Figure 10-3</a>). The destination register operand is <span class="literal">ax</span> (<span class="literal">%00</span>), and the instruction class field is <span class="literal">%101</span>, so the full opcode becomes <span class="literal">%10100111</span>, or <span class="literal">$a7</span>. However, we’re not finished yet. We also have to include the 16-bit constant <span class="literal">$0005</span> as part of the instruction, with the LO byte of the constant following the opcode, and the HO byte of the constant following its LO byte, because the bytes are arranged in little-endian order. So, the sequence of bytes in memory, from lowest address to highest address, is <span class="literal">$a7,</span> <span class="literal">$05,</span> <span class="literal">$00</span> (see <a href="ch10.xhtml#ch10fig08">Figure 10-8</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/10fig08.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_297"/><a id="ch10fig08"/><em>Figure 10-8: Encoding the <span class="literal">add(</span> <span class="literal">5,</span> <span class="literal">ax</span> <span class="literal">);</span> instruction</em></p>&#13;
<p class="indent">The <span class="literal">add([2ff+bx],</span> <span class="literal">cx)</span> instruction also contains a 16-bit constant that is the displacement portion of the indexed addressing mode. To encode this instruction, we use the following field values: <span class="literal">iii</span> = <span class="literal">%101</span>, <span class="literal">rr</span> = <span class="literal">%10</span>, and <span class="literal">mmm</span> = <span class="literal">%101</span>. This produces the opcode byte <span class="literal">%10110101</span>, or <span class="literal">$b5</span>. The complete instruction also requires the constant <span class="literal">$2ff</span>, so the full instruction is the 3-byte sequence <span class="literal">$b5,</span> <span class="literal">$ff,</span> <span class="literal">$02</span> (see <a href="ch10.xhtml#ch10fig09">Figure 10-9</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/10fig09.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig09"/><em>Figure 10-9: Encoding the <span class="literal">add(</span> <span class="literal">[$2ff+bx],</span> <span class="literal">cx</span> <span class="literal">);</span> instruction</em></p>&#13;
<p class="indent">Now consider <span class="literal">add([1000],</span> <span class="literal">ax)</span>. This instruction adds the 16-bit contents of memory locations <span class="literal">$1000</span> and <span class="literal">$1001</span> to the value in the AX register. Once again, <span class="literal">iii</span> = <span class="literal">%101</span> for the <span class="literal">add</span> instruction. The destination register is <span class="literal">ax</span>, so <span class="literal">rr</span> = <span class="literal">%00</span>. Finally, the addressing mode is the displacement-only addressing mode, so <span class="literal">mmm</span> = <span class="literal">%110</span>. This forms the opcode <span class="literal">%10100110</span>, or <span class="literal">$a6</span>. The complete instruction is 3 bytes long, because it must also encode the displacement (address) of the memory location in the 2 bytes following the opcode. Therefore, the complete 3-byte sequence is <span class="literal">$a6,</span> <span class="literal">$00,</span> <span class="literal">$10</span> (see <a href="ch10.xhtml#ch10fig10">Figure 10-10</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/10fig10.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig10"/><em>Figure 10-10: Encoding the <span class="literal">add(</span> <span class="literal">[1000],</span> <span class="literal">ax</span> <span class="literal">);</span> instruction</em></p>&#13;
<p class="indent">The last addressing mode to consider is the register indirect addressing mode, <span class="literal">[bx]</span>. The <span class="literal">add([bx],bx)</span> instruction uses the following encoded values: <span class="literal">mmm</span> = <span class="literal">%101</span>, <span class="literal">rr</span> = <span class="literal">%01</span> (<span class="literal">bx</span>), and <span class="literal">mmm</span> = <span class="literal">%100</span> (<span class="literal">[bx]</span>). Because the value in the BX register completely specifies the memory address, there’s no need to attach a displacement field to the instruction’s encoding. Hence, this instruction is only 1 byte long (see <a href="ch10.xhtml#ch10fig11">Figure 10-11</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/10fig11.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_298"/><a id="ch10fig11"/><em>Figure 10-11: Encoding the <span class="literal">add([bx],</span> <span class="literal">bx);</span> instruction</em></p>&#13;
<p class="indent">You use a similar approach to encode the <span class="literal">sub</span>, <span class="literal">cmp</span>, <span class="literal">and</span>, and <span class="literal">or</span> instructions. The only difference between encoding these instructions and the <span class="literal">add</span> instruction is the value you use for the <span class="literal">iii</span> field in the opcode.</p>&#13;
<h5 class="h5" id="sec10_3_5_2"><strong>10.3.5.2 The mov Instruction</strong></h5>&#13;
<p class="noindent">The Y86 <span class="literal">mov</span> instruction is special, because it comes in two forms. The only difference between the encoding of the <span class="literal">add</span> instruction and the encoding of the <span class="literal">mov</span> instruction’s first form (<span class="literal">iii</span> = <span class="literal">%110</span>) is the <span class="literal">iii</span> field. This form of <span class="literal">mov</span> copies either a constant or data from the register or memory address specified by the <span class="literal">mmm</span> field into the destination register specified by the <span class="literal">rr</span> field.</p>&#13;
<p class="indent">The second form of the <span class="literal">mov</span> instruction (<span class="literal">iii</span> = <span class="literal">%111</span>) copies data from the source register specified by the <span class="literal">rr</span> field to a destination memory location specified by the <span class="literal">mmm</span> field. In this form of the <span class="literal">mov</span> instruction, the source and destination meanings of the <span class="literal">rr</span> and <span class="literal">mmm</span> fields are reversed: <span class="literal">rr</span> is the source field and <span class="literal">mmm</span> is the destination field. Another difference between the two forms of <span class="literal">mov</span> is that in its second form, the <span class="literal">mmm</span> field may contain only the values <span class="literal">%100</span> (<span class="literal">[bx]</span>), <span class="literal">%101</span> (<span class="literal">[disp+bx]</span>), and <span class="literal">%110</span> (<span class="literal">[disp]</span>). The destination values can’t be any of the registers encoded by <span class="literal">mmm</span> field values in the range <span class="literal">%000</span> through <span class="literal">%011</span> or a constant encoded by an <span class="literal">mmm</span> field of <span class="literal">%111</span>. These encodings are illegal because the first form of the <span class="literal">mov</span> handles cases with a register destination, and because storing data into a constant doesn’t make any sense.</p>&#13;
<h5 class="h5" id="sec10_3_5_3"><strong>10.3.5.3 The not Instruction</strong></h5>&#13;
<p class="noindent">The <span class="literal">not</span> instruction is the only instruction with a single memory/register operand that the Y86 processor supports. It has the following syntax:</p>&#13;
<p class="programs">not(<span class="EmpItalic1">reg</span>);</p>&#13;
<p class="noindent">or:</p>&#13;
<p class="programs">not(<span class="EmpItalic1">address</span>);</p>&#13;
<p class="noindent">where <span class="EmpItalic">address</span> represents one of the memory addressing modes (<span class="literal">[bx]</span>, <span class="literal">[disp+bx]</span>, or <span class="literal">[disp]</span>). You may not specify a constant operand for the <span class="literal">not</span> instruction.</p>&#13;
<p class="indent">Because <span class="literal">not</span> has only a single operand, it needs only the <span class="literal">mmm</span> field to encode that operand. An <span class="literal">iii</span> field of <span class="literal">%000</span> and an <span class="literal">rr</span> field of <span class="literal">%10</span> identify the <span class="literal">not</span> instruction. In fact, whenever the <span class="literal">iii</span> field contains <span class="literal">0</span>, the CPU knows that it has to decode bits beyond the <span class="literal">iii</span> field to identify the instruction. <span epub:type="pagebreak" id="page_299"/>In this case, the <span class="literal">rr</span> field specifies whether we’ve encoded <span class="literal">not</span> or one of the other specially encoded instructions.</p>&#13;
<p class="indent">To encode an instruction like <span class="literal">not(ax)</span>, specify <span class="literal">%000</span> for the <span class="literal">iii</span> field and <span class="literal">%10</span> for the <span class="literal">rr</span> field, then encode the <span class="literal">mmm</span> field the same way you would encode it for the <span class="literal">add</span> instruction. Because <span class="literal">mmm</span><em/> = <span class="literal">%000</span> for AX, <span class="literal">not(ax)</span> would be encoded as <span class="literal">%00010000</span>, or <span class="literal">$10</span> (see <a href="ch10.xhtml#ch10fig12">Figure 10-12</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/10fig12.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig12"/><em>Figure 10-12: Encoding the <span class="literal">not(AX);</span> instruction</em></p>&#13;
<p class="indent">The <span class="literal">not</span> instruction does not allow an immediate, or constant, operand, so the opcode <span class="literal">%00010111</span> (<span class="literal">$17</span>) is an illegal opcode.</p>&#13;
<h5 class="h5" id="sec10_3_5_4"><strong>10.3.5.4 The Jump Instructions</strong></h5>&#13;
<p class="noindent">The Y86 jump instructions also use the special encoding, meaning that the <span class="literal">iii</span> field for jump instructions is always <span class="literal">%000</span>. These instructions are always 3 bytes long. The first byte, the opcode, specifies which jump instruction to execute, and the next 2 bytes specify the address in memory to which the CPU transfers control (if the condition is met, in the case of the conditional jumps). There are seven different Y86 jump instructions, six conditional jumps, and one unconditional jump, <span class="literal">jmp</span>. All seven of these instructions set <span class="literal">iii</span> = <span class="literal">%000</span> and <span class="literal">rr</span> = <span class="literal">%01</span>, so they differ only by their <span class="literal">mmm</span> fields. The eighth possible opcode, with an <span class="literal">mmm</span> field value of <span class="literal">%111</span>, is an illegal opcode (see <a href="ch10.xhtml#ch10fig06">Figure 10-6</a>).</p>&#13;
<p class="indent">Encoding these instructions is relatively straightforward. Picking the instruction you want to encode completely determines the opcode. The opcode values fall in the range <span class="literal">$08</span> through <span class="literal">$0e</span> (<span class="literal">$0f</span> is the illegal opcode).</p>&#13;
<p class="indent">The only field that requires some thought is the 16-bit operand that follows the opcode. This field holds the address of the target instruction to which the unconditional jump always transfers, and to which the conditional jumps transfer if the transfer condition is <span class="literal">true</span>. To properly encode this 16-bit operand, you must know the address of the opcode byte of the target instruction. If you’ve already converted the target instruction to binary form and stored it into memory, you’re all set—just specify the target instruction’s address as the sole operand of the jump instruction. On the other hand, if you haven’t yet written, converted, and placed the target instruction into memory, knowing its address would seem to require a bit of divination. Fortunately, you can figure it out by computing the lengths of all the instructions between the current jump instruction you’re encoding and the target instruction—but unfortunately, this is an arduous task.</p>&#13;
<p class="indent">The best way to calculate the distance is to write all your instructions down on paper, compute their lengths (which is easy, because all instructions are either 1 or 3 bytes long depending on whether they have a 16-bit <span epub:type="pagebreak" id="page_300"/>operand), and then assign an appropriate address to each instruction. Once you’ve done this, you’ll know the starting address for each instruction, and you can put target address operands into your jump instructions as you encode them.</p>&#13;
<h5 class="h5" id="sec10_3_5_5"><strong>10.3.5.5 The Zero-Operand Instructions</strong></h5>&#13;
<p class="noindent">The remaining instructions, the zero-operand instructions, are the easiest to encode. Because they have no operands, they are always 1 byte long. These instructions always have <span class="literal">iii</span> = <span class="literal">%000</span> and <span class="literal">rr</span> = <span class="literal">%00</span>, and <span class="literal">mmm</span> specifies the particular instruction opcode (see <a href="ch10.xhtml#ch10fig05">Figure 10-5</a>). Note that the Y86 CPU leaves five of these instructions undefined (so we can use these opcodes for future expansion).</p>&#13;
<h4 class="h4" id="sec10_3_6"><strong><em>10.3.6 Extending the Y86 Instruction Set</em></strong></h4>&#13;
<p class="noindent">The Y86 CPU is a trivial CPU, suitable only for demonstrating how to encode machine instructions. However, as with any good CPU, the Y86 design allows for expansion by adding new instructions.</p>&#13;
<p class="indent">You can extend the number of instructions in a CPU’s instruction set by using either undefined or illegal opcodes. So, because the Y86 CPU has several illegal and undefined opcodes, we’ll use them to expand the instruction set.</p>&#13;
<p class="indent">Using undefined opcodes to define new instructions works best when there are undefined bit patterns within an opcode group, and the new instruction you want to add falls into that same group. For example, the opcode <span class="literal">%00011</span><span class="EmpItalic">mmm</span> falls into the same group as the <span class="literal">not</span> instruction, which also has an <span class="literal">iii</span> field value of <span class="literal">%000</span>. If you decided that you really needed a <span class="literal">neg</span> (negate) instruction, using the <span class="literal">%00011</span><span class="EmpItalic">mmm</span> opcode makes sense because you’d probably expect <span class="literal">neg</span> to use the same syntax as the <span class="literal">not</span> instruction. Likewise, if you want to add a zero-operand instruction to the instruction set, Y86 has five undefined zero-operand instructions for you to choose from (<span class="literal">%0000000..%00000100</span>; see <a href="ch10.xhtml#ch10fig05">Figure 10-5</a>). You’d just appropriate one of these opcodes and assign your instruction to it.</p>&#13;
<p class="indent">Unfortunately, the Y86 CPU doesn’t have many illegal opcodes available. For example, if you wanted to add the <span class="literal">shl</span> (shift left), <span class="literal">shr</span> (shift right), <span class="literal">rol</span> (rotate left), and <span class="literal">ror</span> (rotate right) instructions as single-operand instructions, there’s not enough space within the group of single-operand instruction opcodes to do so (only <span class="literal">%00011</span><span class="EmpItalic">mmm</span> is currently open). Likewise, there are no two-operand opcodes open, so if you wanted to add an <span class="literal">xor</span> (exclusive OR) instruction or some other two-operand instruction, you’d be out of luck.</p>&#13;
<p class="indent">A common way to handle this dilemma, and one the Intel designers have employed, is to use one of the undefined opcodes as a prefix opcode byte. For example, the opcode <span class="literal">$ff</span> is illegal (it corresponds to a <span class="literal">mov(dx,</span> <span epub:type="pagebreak" id="page_301"/><span class="EmpItalic">constant</span><span class="literal">)</span> instruction), but we can use it as a special prefix byte to further expand the instruction set (see <a href="ch10.xhtml#ch10fig13">Figure 10-13</a>).<sup><a href="footnotes.xhtml#fn10_4a" id="fn10_4">4</a></sup></p>&#13;
<div class="image"><img alt="image" src="../images/10fig13.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig13"/><em>Figure 10-13: Using a prefix byte to extend the instruction set</em></p>&#13;
<p class="indent">Whenever the CPU encounters a prefix byte in memory, it reads and decodes the next byte in memory as the actual opcode. However, it doesn’t treat the second byte as it would a standard opcode that did not follow a prefix byte. Instead, it allows the CPU designer to create a completely new opcode scheme, independent of the original instruction set. A single-expansion opcode byte allows CPU designers to add up to 256 more instructions to the instruction set. For even more instructions, designers can use additional illegal opcode bytes (in the original instruction set) to add still more expansion opcodes, each with its own independent instruction set; or they can follow the opcode expansion prefix byte with a 2-byte opcode (yielding up to 65,536 new instructions); or they can execute any other scheme they can dream up.</p>&#13;
<p class="indent">Of course, one big drawback of this approach is that it increases the size of the new instructions by 1 byte, because each instruction now requires the prefix byte as part of the opcode. This also increases the cost of the circuitry (since decoding prefix bytes and multiple instruction sets is fairly complex), so you don’t want to use this scheme for the basic instruction set. Nevertheless, it is a good way to expand the instruction set when you’ve run out of opcodes.</p>&#13;
<h3 class="h3" id="sec10_4"><strong>10.4 Encoding 80x86 Instructions</strong></h3>&#13;
<p class="noindent">The Y86 processor is simple to understand; we can easily encode instructions by hand for it, and it’s a great vehicle for learning how to assign opcodes. It’s also a purely hypothetical device intended only as a teaching tool. So, it’s time to take a look at the machine instruction format for a real CPU: the 80x86. After all, the programs you write will run on a real CPU, so to fully appreciate what your compilers are doing with your code—so you can choose the best statements and data structures when writing that code—you need to understand how real instructions are encoded.</p>&#13;
<p class="indent">Even if you’re using a different CPU, studying the 80x86 instruction encoding is helpful. They don’t call the 80x86 a <em>complex</em> instruction set computer (CISC) chip for nothing. Although more complex instruction <span epub:type="pagebreak" id="page_302"/>encodings do exist, no one would challenge the assertion that it’s one of the more complex instruction sets in common use today. Therefore, exploring it will provide valuable insight into the operation of other real-world CPUs.</p>&#13;
<p class="indent">The generic 80x86 32-bit instruction takes the form shown in <a href="ch10.xhtml#ch10fig14">Figure 10-14</a>.<sup><a href="footnotes.xhtml#fn10_5a" id="fn10_5">5</a></sup></p>&#13;
<div class="image"><img alt="image" src="../images/10fig14.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig14"/><em>Figure 10-14: 80x86 32-bit instruction encoding</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Although this diagram seems to imply that instructions can be up to 16 bytes long, 15 bytes is actually the limit.</em></p>&#13;
</div>&#13;
<p class="indent">The prefix bytes are not the same as the opcode expansion prefix byte that we discussed in the previous section. Instead, the 80x86 prefix bytes modify the behavior of existing instructions. An instruction may have a maximum of four prefix bytes attached to it, but the 80x86 supports more than four different prefix values. The behaviors of many prefix bytes are mutually exclusive, and the results of an instruction will be undefined if you prepend a pair of mutually exclusive prefix bytes to it. We’ll take a look at a couple of these prefix bytes in a moment.</p>&#13;
<p class="indent">The (32-bit) 80x86 supports two basic opcode sizes: a standard 1-byte opcode and a 2-byte opcode consisting of a <span class="literal">$0f</span> opcode expansion prefix byte and a second byte specifying the actual instruction. One way to think of this opcode expansion prefix byte is as an 8-bit extension of the <span class="literal">iii</span> field in the Y86 encoding. This enables the encoding of up to 512 different instruction classes, although the 80x86 doesn’t yet use them all. In reality, various instruction classes use certain bits in this opcode expansion prefix byte for decidedly non-instruction-class purposes. For example, consider the <span class="literal">add</span> instruction opcode shown in <a href="ch10.xhtml#ch10fig15">Figure 10-15</a>.</p>&#13;
<p class="indent">Bit 1 (<span class="literal">d</span>) specifies the direction of the transfer. If this bit is <span class="literal">0</span>, then the destination operand is a memory location, such as in <span class="literal">add(al,</span> <span class="literal">[ebx]);</span>. If this bit is <span class="literal">1</span>, the destination operand is a register, as in <span class="literal">add([ebx],</span> <span class="literal">al);</span>.</p>&#13;
<div class="image"><img alt="image" src="../images/10fig15.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_303"/><a id="ch10fig15"/><em>Figure 10-15: 80x86 <span class="literal">add</span> opcode</em></p>&#13;
<p class="indent">Bit 0 (<span class="literal">s</span>) specifies the size of the operands the <span class="literal">add</span> instruction operates upon. There’s a problem here, however. The 32-bit 80x86 family supports up to three different operand sizes: 8-bit operands, 16-bit operands, and 32-bit operands. With a single size bit, the instruction can encode only two of these three different sizes. In 32-bit operating systems, the vast majority of operands are either 8 bits or 32 bits, so the 80x86 CPU uses the size bit in the opcode to encode those sizes. For 16-bit operands, which occur less frequently than 8-bit or 32-bit operands, Intel uses a special opcode prefix byte to specify the size. As long as instructions that have 16-bit operands occur less than one out of every eight instructions (which is generally the case), this is more compact than adding another bit to the instruction’s size. Using a size prefix byte allowed Intel’s designers to extend the number of operand sizes without having to change the instruction encoding inherited from the original 16-bit processors in this CPU family.</p>&#13;
<p class="indent">Note that the AMD/Intel 64-bit architectures go even crazier with opcode prefix bytes. However, the CPU operates in a special 64-bit mode; effectively, the 64-bit 80x86 CPUs (often called the <em>X86-64 CPUs</em>) have two completely different instruction sets, each with its own encoding. The X86-64 CPUs can switch between 64- and 32-bit modes to handle programs written in either of the different instruction sets. The encoding in this chapter covers the 32-bit variant; see the Intel or AMD documentation for details on the 64-bit version.</p>&#13;
<h4 class="h4" id="sec10_4_1"><strong><em>10.4.1 Encoding Instruction Operands</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">mod-reg-r/m</span> byte (see <a href="ch10.xhtml#ch10fig14">Figure 10-14</a>) provides the encoding for instruction operands by specifying the base addressing mode used to access them as well as their size. This byte contains the fields shown in <a href="ch10.xhtml#ch10fig16">Figure 10-16</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/10fig16.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig16"/><em>Figure 10-16: <span class="literal">mod-reg-r/m</span> byte</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_304"/>The <span class="literal">reg</span> field almost always specifies an 80x86 register. However, depending on the instruction, the register specified by <span class="literal">reg</span> can be either the source or the destination operand. To distinguish between the two, many instructions’ upcodes include the <span class="literal">d</span> (direction) field, which contains a value of <span class="literal">0</span> when <span class="literal">reg</span> is the source and a value of <span class="literal">1</span> when it’s the destination operand.</p>&#13;
<p class="indent">This field uses the 3-bit register encodings found in <a href="ch10.xhtml#ch10tab01">Table 10-1</a>. As just discussed, the size bit in the instruction’s opcode indicates whether the <span class="literal">reg</span> field specifies an 8- or 32-bit register (when operating under a modern, 32-bit operating system). To make the <span class="literal">reg</span> field specify a 16-bit register, you must set the size bit in the opcode to <span class="literal">1</span>, as well as adding an extra prefix byte.</p>&#13;
<p class="tabcap"><a id="ch10tab01"/><strong>Table 10-1:</strong> <span class="literal">reg</span> Field Encodings</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong><span class="EmpStrong">reg</span> value</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Register if data size is 8 bits</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Register if data size is 16 bits</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Register if data size is 32 bits</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%000</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">al</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">ax</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">eax</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%001</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">cl</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">cx</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">ecx</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%010</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">dl</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">dx</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">edx</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%011</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">bl</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">bx</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">ebx</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%100</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">ah</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">sp</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">esp</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%101</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">ch</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">bp</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">ebp</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%110</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">dh</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">si</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">esi</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%111</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">bh</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">di</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">edi</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">With the <span class="literal">d</span> bit in the opcode of a two-operand instruction indicating whether the <span class="literal">reg</span> field contains the source or destination operand, the <span class="literal">mod</span> and <span class="literal">r/m</span> fields together specify the other of the two operands. In the case of a single-operand instruction like <span class="literal">not</span> or <span class="literal">neg</span>, the <span class="literal">reg</span> field contains an opcode extension, and <span class="literal">mod</span> and <span class="literal">r/m</span> combine to specify the only operand. The operand addressing modes specified by the <span class="literal">mod</span> and <span class="literal">r/m</span> fields are listed in <a href="#ch10tab02">Tables 10-2</a> and <a href="#ch10tab03">10-3</a>.</p>&#13;
<p class="tabcap"><a id="ch10tab02"/><strong>Table 10-2:</strong> <span class="literal">mod</span> Field Encodings</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:80%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><span class="EmpStrong">mod</span></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%00</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Specifies register-indirect addressing mode (with two exceptions: scaled-index [<span class="literal">sib</span>] addressing modes with no displacement operand when <span class="literal">r/m = %100</span>; and displacement-only addressing mode when <span class="literal">r/m = %101</span>).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%01</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Specifies that a 1-byte signed displacement follows the addressing mode byte(s).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%10</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Specifies that a 1-byte signed displacement follows the addressing mode byte(s).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%11</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Specifies direct register access.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_305"/><a id="ch10tab03"/><strong>Table 10-3:</strong> <span class="literal">mod-r/m</span> Encodings</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><span class="EmpStrong">mod</span></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><span class="EmpStrong">r/m</span></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Addressing mode</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%00</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%000</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[eax]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%01</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%000</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[eax+</span><span class="EmpItalic">disp</span><sub>8</sub><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%10</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%000</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[eax+</span><span class="EmpItalic">disp</span><sub>32</sub><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%11</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%000</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">al</span>, <span class="literal">ax</span>, or <span class="literal">eax</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%00</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%001</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[ecx]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%01</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%001</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[ecx+</span><span class="EmpItalic">disp</span><sub>8</sub><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%10</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%001</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[ecx+</span><span class="EmpItalic">disp</span><sub>32</sub><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%11</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%001</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">cl</span>, <span class="literal">cx</span>, or <span class="literal">ecx</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%00</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%010</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[edx]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%01</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%010</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[edx+</span><span class="EmpItalic">disp</span><sub>8</sub><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%10</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%010</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[edx+</span><span class="EmpItalic">disp</span><sub>32</sub><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%11</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%010</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">dl</span>, <span class="literal">dx</span>, or <span class="literal">edx</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%00</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%011</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[ebx]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%01</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%011</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[ebx+</span><span class="EmpItalic">disp</span><sub>8</sub><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%10</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%011</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[ebx+</span><span class="EmpItalic">disp</span><sub>32</sub><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%11</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%011</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">bl</span>, <span class="literal">bx</span>, or <span class="literal">ebx</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%00</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%100</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Scaled-index (<span class="literal">sib</span>) mode</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%01</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%100</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">sib</span> + <span class="EmpItalic">disp</span><sub>8</sub> mode</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%10</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%100</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">sib</span> + <span class="EmpItalic">disp</span><sub>32</sub> mode</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%11</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%100</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">ah</span>, <span class="literal">sp</span>, or <span class="literal">esp</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%00</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%101</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Displacement-only mode (32-bit displacement)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%01</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%101</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[ebp+</span><span class="EmpItalic">disp</span><sub>8</sub><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%10</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%101</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[ebp+</span><span class="EmpItalic">disp</span><sub>32</sub><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%11</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%101</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">ch</span>, <span class="literal">bp</span>, or <span class="literal">ebp</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%00</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%110</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[esi]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%01</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%110</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[esi+</span><span class="EmpItalic">disp</span><sub>8</sub><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%10</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%110</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[esi+</span><span class="EmpItalic">disp</span><sub>32</sub><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%11</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%110</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">dh</span>, <span class="literal">si</span>, or <span class="literal">esi</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%00</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%111</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[edi]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%01</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%111</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[edi+</span><span class="EmpItalic">disp</span><sub>8</sub><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%10</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%111</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[edi+</span><span class="EmpItalic">disp</span><sub>32</sub><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%11</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%111</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">bh</span>, <span class="literal">di</span>, or <span class="literal">edi</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_306"/>There are a couple of interesting things to note about <a href="ch10.xhtml#ch10tab02">Tables 10-2</a> and <a href="ch10.xhtml#ch10tab03">10-3</a>. First, there are two different forms of the [<span class="EmpItalic">reg+disp</span>] addressing modes: one form with an 8-bit displacement and one form with a 32-bit displacement. Addressing modes whose displacement falls in the range –128 through +127 require only a single byte after the opcode to encode the displacement. Instructions with a displacement that falls within this range will be shorter and sometimes faster than instructions whose displacement values are not within this range and thus require 4 bytes after the opcode.</p>&#13;
<p class="indent">The second thing to note is that there is no <span class="literal">[ebp]</span> addressing mode. If you look at the entry in <a href="ch10.xhtml#ch10tab03">Table 10-3</a> where this addressing mode logically belongs (where <span class="literal">r/m</span> is <span class="literal">%101</span> and <span class="literal">mod</span> is <span class="literal">%00</span>), you’ll find that its slot is occupied by the 32-bit displacement-only addressing mode. The basic encoding scheme for addressing modes didn’t allow for a displacement-only addressing mode, so Intel “stole” the encoding for <span class="literal">[ebp]</span> and used that for the displacement-only mode. Fortunately, anything you can do with the <span class="literal">[ebp]</span> addressing mode you can also do with the <span class="literal">[ebp+</span><span class="EmpItalic">disp</span><sub>8</sub><span class="literal">]</span> addressing mode by setting the 8-bit displacement to <span class="literal">0</span>. While such an instruction is a bit longer than it would otherwise need to be if the <span class="literal">[ebp]</span> addressing mode existed, the same capabilities are still there. Intel wisely chose to replace this particular register-indirect addressing mode, anticipating that programmers would use it less often than the other register-indirect addressing modes.</p>&#13;
<p class="indent">Another thing you’ll notice missing from this table are addressing modes of the form <span class="literal">[esp]</span>, <span class="literal">[esp+</span><span class="EmpItalic">disp</span><sub>8</sub><span class="literal">]</span>, and <span class="literal">[esp+</span><span class="EmpItalic">disp</span><sub>32</sub><span class="literal">]</span>. Intel’s designers borrowed the encodings for these three addressing modes to support the <em><a href="gloss01.xhtml#gloss01_222">scaled-index addressing</a></em> modes they added to their 32-bit processors in the 80x86 family.</p>&#13;
<p class="indent">If <span class="literal">r/m</span> = <span class="literal">%100</span> and <span class="literal">mod</span> = <span class="literal">%00</span>, this specifies an addressing mode of the form <span class="literal">[reg</span><sub><span class="literal">1</span></sub><span class="literal">32+reg</span><sub><span class="literal">2</span></sub><span class="literal">32*n]</span>. This scaled-index addressing mode computes the <span epub:type="pagebreak" id="page_307"/>final address in memory as the sum of <span class="literal">reg</span><sub><span class="literal">2</span></sub> multiplied by <span class="EmpItalic">n</span> (<span class="EmpItalic">n</span> = <span class="literal">1</span>, <span class="literal">2</span>, <span class="literal">4</span>, or <span class="literal">8</span>) and <span class="literal">reg</span><sub><span class="literal">1</span></sub>. Programs most often use this addressing mode when <span class="literal">reg</span><sub><span class="literal">1</span></sub> is a pointer holding the base address of an array of bytes (<span class="EmpItalic">n</span> = <span class="literal">1</span>), words (<span class="EmpItalic">n</span> = <span class="literal">2</span>), double words (<span class="EmpItalic">n</span> = <span class="literal">4</span>), or quad words (<span class="EmpItalic">n</span> = <span class="literal">8</span>), and <span class="literal">reg</span><sub><span class="literal">2</span></sub> holds the index into that array.</p>&#13;
<p class="indent">If <span class="literal">r/m</span> = <span class="literal">%100</span> and <span class="literal">mod</span> = <span class="literal">%01</span>, this specifies an addressing mode of the form <span class="literal">[reg</span><sub><span class="literal">1</span></sub><span class="literal">32+reg</span><sub><span class="literal">2</span></sub><span class="literal">32*</span><span class="EmpItalic">n</span><span class="literal">+</span><span class="EmpItalic">disp</span><sub><span class="literal">8</span></sub><span class="literal">]</span>. This scaled-index addressing mode computes the final address in memory as the sum of <span class="literal">reg</span><sub><span class="literal">2</span></sub> multiplied by <span class="EmpItalic">n</span> (<span class="EmpItalic">n</span> = <span class="literal">1</span>, <span class="literal">2</span>, <span class="literal">4</span>, or <span class="literal">8</span>), <span class="literal">reg</span><sub><span class="literal">1</span></sub>, and the 8-bit signed displacement (sign-extended to 32 bits). Programs most often use this addressing mode when <span class="literal">reg</span><sub><span class="literal">1</span></sub> is a pointer holding the base address of an array of records, <span class="literal">reg</span><sub><span class="literal">2</span></sub> holds the index into that array, and <span class="EmpItalic">disp</span><sub><span class="literal">8</span></sub> provides the offset to a desired field in the record.</p>&#13;
<p class="indent">If <span class="literal">r/m</span> = <span class="literal">%100</span> and <span class="literal">mod</span> = <span class="literal">%10</span>, this specifies an addressing mode of the form <span class="literal">[reg</span><sub><span class="literal">1</span></sub><span class="literal">32+reg</span><sub><span class="literal">2</span></sub><span class="literal">32*n+</span><span class="EmpItalic">disp</span><sub><span class="literal">32</span></sub><span class="literal">]</span>. This scaled-index addressing mode computes the final address in memory as the sum of <span class="literal">reg</span><sub><span class="literal">2</span></sub> multiplied by <span class="EmpItalic">n</span> (<span class="EmpItalic">n</span> = <span class="literal">1</span>, <span class="literal">2</span>, <span class="literal">4</span>, or <span class="literal">8</span>), <span class="literal">reg</span><sub><span class="literal">1</span></sub>, and the 32-bit signed displacement. Programs most often use this addressing mode to index into static arrays of bytes, words, double words, or quad words.</p>&#13;
<p class="indent">If values corresponding to one of the <span class="literal">sib</span> modes appear in the <span class="literal">mod</span> and <span class="literal">r/m</span> fields, the addressing mode is a scaled-index addressing mode with a second byte (the <span class="literal">sib</span>) following the <span class="literal">mod-reg-r/m</span> byte, though don’t forget that the <span class="literal">mod</span> field still specifies a displacement size of 0, 1, or 4 bytes. <a href="ch10.xhtml#ch10fig17">Figure 10-17</a> shows the layout of this extra <span class="literal">sib</span>, and <a href="ch10.xhtml#ch10tab04">Tables 10-4</a>, <a href="ch10.xhtml#ch10tab05">10-5</a>, and <a href="ch10.xhtml#ch10tab06">10-6</a> explain the values for each of the <span class="literal">sib</span> fields.</p>&#13;
<div class="image"><img alt="image" src="../images/10fig17.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig17"/><em>Figure 10-17: The <span class="literal">sib</span> (scaled-index byte) layout</em></p>&#13;
<p class="tabcap"><a id="ch10tab04"/><strong>Table 10-4:</strong> Scale Values</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Scale value</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Index * scale value</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%00</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Index * 1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%01</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Index * 2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%10</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Index * 4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%11</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Index * 8</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="tabcap"><a id="ch10tab05"/><strong>Table 10-5:</strong> Register Values for <span class="literal">sib</span> Encoding</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Index value</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Register</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%000</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">EAX</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%001</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">ECX</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%010</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">EDX</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%011</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">EBX</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%100</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">Illegal</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%101</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">EBP</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%110</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">ESI</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%111</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">EDI</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_308"/><a id="ch10tab06"/><strong>Table 10-6:</strong> Base Register Values for <span class="literal">sib</span> Encoding</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Base value</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Register</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%000</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">EAX</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%001</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">ECX</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%010</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">EDX</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%011</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">EBX</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%100</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">ESP</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%101</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">Displacement only if <span class="literal">mod</span> = <span class="literal">%00</span>, EBP if <span class="literal">mod</span> = <span class="literal">%01</span> or <span class="literal">%10</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%110</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">ESI</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%111</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">EDI</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The <span class="literal">mod-reg-r/m</span> and <span class="literal">sib</span> bytes are complex and convoluted, no question about that. The reason is that Intel reused its 16-bit addressing circuitry when it switched to the 32-bit format rather than simply abandoning it at that point. There were good hardware reasons for retaining it, but the result is a complex scheme for specifying addressing modes. As you can imagine, things got even worse when Intel and AMD developed the x86-64 architecture.</p>&#13;
<p class="indent">Note that if the <span class="literal">r/m</span> field of the <span class="literal">mod-reg-r/m</span> byte contains <span class="literal">%100</span> and <span class="literal">mod</span> does not contain <span class="literal">%11</span>, the addressing mode is a <span class="literal">sib</span> mode rather than the expected <span class="literal">[esp]</span>, <span class="literal">[esp+</span><span class="EmpItalic">disp</span><sub><span class="literal">8</span></sub><span class="literal">]</span>, or <span class="literal">[esp+</span><span class="EmpItalic">disp</span><sub><span class="literal">32</span></sub><span class="literal">]</span> mode. In this case the compiler or assembler will emit an extra <span class="literal">sib</span> byte immediately following the <span class="literal">mod-reg-r/m</span> byte. <a href="ch10.xhtml#ch10tab07">Table 10-7</a> lists the various combinations of legal scaled-index addressing modes on the 80x86.</p>&#13;
<p class="indent">In each of the addressing modes listed in <a href="ch10.xhtml#ch10tab07">Table 10-7</a>, the <span class="literal">mod</span> field of the <span class="literal">mod-reg-r/m</span> byte specifies the size of the displacement (0, 1, or 4 bytes). The base and index fields of the <span class="literal">sib</span> specify the base and index registers, respectively. Note that this addressing mode does not allow the use of ESP as an index register. Presumably, Intel left this particular mode undefined to allow for extending the addressing modes to 3 bytes in a future version of the CPU, although doing so seems a bit extreme.</p>&#13;
<p class="indent">Just as the <span class="literal">mod-reg-r/m</span> encoding replaced the <span class="literal">[ebp]</span> addressing mode with a displacement-only mode, the <span class="literal">sib</span> addressing format replaces the <span class="literal">[ebp+</span><span class="EmpItalic">index</span><span class="literal">*</span><span class="EmpItalic">scale</span><span class="literal">]</span> mode with a displacement-plus index mode (that is, no base register). If it turns out that you really need to use the <span class="literal">[ebp+</span><span class="EmpItalic">index</span><span class="literal">*</span><span class="EmpItalic">scale</span><span class="literal">]</span> addressing mode, you’ll have to use the <span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">8</span></sub><span class="literal">+ebp+</span><span class="EmpItalic">index</span><span class="literal">*</span><span class="EmpItalic">scale</span><span class="literal">]</span> mode instead, specifying a 1-byte displacement value of <span class="literal">0</span>.</p>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_309"/><a id="ch10tab07"/><strong>Table 10-7:</strong> The Scaled-Index Addressing Modes</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><span class="EmpStrong">mod</span></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Index</strong></p></td>&#13;
<td class="table-h" style="vertical-align: top;"><p class="tab_th"><strong>Legal scaled-index addressing modes<sup><a href="footnotes.xhtml#fn10_6a" id="fn10_6">6</a></sup></strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" rowspan="8" style="vertical-align: top;"><p class="taba"><span class="literal">%00</span></p>&#13;
<p class="taba">Base ° <span class="literal">%101</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%000</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+eax*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%001</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+ecx*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%010</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+edx*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%011</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+ebx*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%100</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">n/a<sup><a href="footnotes.xhtml#fn10_7a" id="fn10_7">7</a></sup></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%101</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+ebp*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%110</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+esi*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%111</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+edi*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" rowspan="8" style="vertical-align: top;"><p class="taba"><span class="literal">%00</span></p>&#13;
<p class="taba">Base = <span class="literal">%101</span><sup><a href="footnotes.xhtml#fn10_8a" id="fn10_8">8</a></sup></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%000</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">32</span></sub><span class="literal">+eax*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%001</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">32</span></sub><span class="literal">+ecx*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%010</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">32</span></sub><span class="literal">+edx*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%011</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">32</span></sub><span class="literal">+ebx*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%100</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">n/a</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%101</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">32</span></sub><span class="literal">+ebp*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%110</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">32</span></sub><span class="literal">+esi*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%111</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">32</span></sub><span class="literal">+edi*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" rowspan="8" style="vertical-align: top;"><p class="taba"><span class="literal">%01</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%000</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">8</span></sub><span class="literal">+</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+eax*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%001</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">8</span></sub><span class="literal">+</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+ecx*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%010</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">8</span></sub><span class="literal">+</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+edx*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%011</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">8</span></sub><span class="literal">+</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+ebx*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%100</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">n/a</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%101</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">8</span></sub><span class="literal">+</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+ebp*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%110</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">8</span></sub><span class="literal">+</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+esi*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%111</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">8</span></sub><span class="literal">+</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+edi*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" rowspan="8" style="vertical-align: top;"><p class="taba"><span class="literal">%10</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%000</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">32</span></sub><span class="literal">+</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+eax*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%001</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">32</span></sub><span class="literal">+</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+ecx*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%010</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">32</span></sub><span class="literal">+</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+edx*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%011</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">32</span></sub><span class="literal">+</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+ebx*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%100</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba">n/a</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%101</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">32</span></sub><span class="literal">+</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+ebp*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">%110</span></p></td>&#13;
<td class="table-ba" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">32</span></sub><span class="literal">+</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+esi*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">%111</span></p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba"><span class="literal">[</span><span class="EmpItalic">disp</span><sub><span class="literal">32</span></sub><span class="literal">+</span><span class="EmpItalic">base</span><sub><span class="literal">32</span></sub><span class="literal">+edi*</span><span class="EmpItalic">n</span><span class="literal">]</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h4 class="h4" id="sec10_4_2"><span epub:type="pagebreak" id="page_310"/><strong><em>10.4.2 Encoding the add Instruction</em></strong></h4>&#13;
<p class="noindent">To help you figure out how to encode an instruction using this complex scheme, let’s look at an example of the 80x86 <span class="literal">add</span> instruction using various addressing modes. The <span class="literal">add</span> opcode is either <span class="literal">$00</span>, <span class="literal">$01</span>, <span class="literal">$02</span>, or <span class="literal">$03</span>, depending on its direction and size bits (see <a href="ch10.xhtml#ch10fig15">Figure 10-15</a>). <a href="ch10.xhtml#ch10fig18">Figures 10-18</a> through <a href="ch10.xhtml#ch10fig25">10-25</a> show how to encode various forms of the <span class="literal">add</span> instruction using different addressing modes.</p>&#13;
<div class="image"><img alt="image" src="../images/10fig18.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig18"/><em>Figure 10-18: Encoding the <span class="literal">add(al,</span> <span class="literal">cl);</span> instruction</em></p>&#13;
<p class="indent">There is an interesting side effect of the <span class="literal">mod-reg-r/m</span> organization and direction bit: some instructions have two different legal opcodes. For example, we could also encode the <span class="literal">add(al,</span> <span class="literal">cl);</span> instruction shown in <a href="ch10.xhtml#ch10fig18">Figure 10-18</a> as <span class="literal">$02,</span> <span class="literal">$c8</span> by reversing the positions of the AL and CL registers in the <span class="literal">reg</span> and <span class="literal">r/m</span> fields and then setting the <span class="literal">d</span> bit (bit 1) in the opcode to <span class="literal">1</span>. This applies to all instructions with two register operands and a direction bit, such as the <span class="literal">add(eax,</span> <span class="literal">ecx);</span> instruction in <a href="ch10.xhtml#ch10fig19">Figure 10-19</a>, which can also be encoded as <span class="literal">$03,</span> <span class="literal">$c8</span>.</p>&#13;
<div class="image"><img alt="image" src="../images/10fig19.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_311"/><a id="ch10fig19"/><em>Figure 10-19: Encoding the <span class="literal">add(eax,</span> <span class="literal">ecx);</span> instruction</em></p>&#13;
<div class="image"><img alt="image" src="../images/10fig20.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig20"/><em>Figure 10-20: Encoding the <span class="literal">add(disp,</span> <span class="literal">edx);</span> instruction</em></p>&#13;
<div class="image"><img alt="image" src="../images/10fig21.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_312"/><a id="ch10fig21"/><em>Figure 10-21: Encoding the <span class="literal">add([ebx],</span> <span class="literal">edi);</span> instruction</em></p>&#13;
<div class="image"><img alt="image" src="../images/10fig22.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig22"/><em>Figure 10-22: Encoding the <span class="literal">add([esi+disp</span><span class="literal"><sub>8</sub></span><span class="literal">],</span> <span class="literal">eax);</span> instruction</em></p>&#13;
<div class="image"><img alt="image" src="../images/10fig23.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_313"/><a id="ch10fig23"/><em>Figure 10-23: Encoding the <span class="literal">add([ebp+disp</span><span class="literal"><sub>32</sub></span><span class="literal">],</span> <span class="literal">ebx);</span> instruction</em></p>&#13;
<div class="image"><img alt="image" src="../images/10fig24.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig24"/><em>Figure 10-24: Encoding the <span class="literal">add([disp</span><span class="literal"><sub>32</sub></span><span class="literal">+eax*1],</span> <span class="literal">ebp);</span> instruction</em></p>&#13;
<div class="image"><img alt="image" src="../images/10fig25.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_314"/><a id="ch10fig25"/><em>Figure 10-25: Encoding the <span class="literal">add([ebx+edi*4],</span> <span class="literal">ecx);</span> instruction</em></p>&#13;
<h4 class="h4" id="sec10_4_3"><strong><em>10.4.3 Encoding Immediate (Constant) Operands on the x86</em></strong></h4>&#13;
<p class="noindent">You may have noticed that the <span class="literal">mod-reg-r/m</span> and <span class="literal">sib</span> bytes don’t contain any bit combinations you can use to specify that an instruction contains an immediate operand. The 80x86 uses a completely different opcode to specify an immediate operand. <a href="ch10.xhtml#ch10fig26">Figure 10-26</a> shows the basic encoding for an <span class="literal">add</span> immediate instruction.</p>&#13;
<div class="image"><img alt="image" src="../images/10fig26.jpg"/></div>&#13;
<p class="figcap"><a id="ch10fig26"/><em>Figure 10-26: Encoding an <span class="literal">add</span> immediate instruction</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_315"/>There are three major differences between the encoding of the <span class="literal">add</span> immediate instruction and the standard <span class="literal">add</span> instruction. First, and most important, the opcode has a <span class="literal">1</span> in the HO bit position. This tells the CPU that the instruction has an immediate constant. This change alone, however, does not tell the CPU that it must execute an <span class="literal">add</span> instruction, as you’ll see shortly.</p>&#13;
<p class="indent">The second difference is that there’s no direction bit in the opcode. This makes sense because you cannot specify a constant as a destination operand. Therefore, the destination operand is always the location specified by the <span class="literal">mod</span> and <span class="literal">r/m</span> bits in the <span class="literal">mod-reg-r/m</span> field.</p>&#13;
<p class="indent">In place of the direction bit, the opcode has a sign-extension (<span class="literal">x</span>) bit. For 8-bit operands, the CPU ignores the sign-extension bit. For 16-bit and 32-bit operands, the sign-extension bit specifies the size of the constant following the <span class="literal">add</span> instruction. If the sign-extension bit contains <span class="literal">0</span>, the constant is already the same size as the operand (either 16 or 32 bits). If the sign-extension bit contains <span class="literal">1</span>, the constant is a signed 8-bit value, and the CPU sign-extends this value to the appropriate size before adding it to the operand. This little trick often makes programs much shorter, because you commonly add small constants to 16- or 32-bit destination operands.</p>&#13;
<p class="indent">The third difference between the <span class="literal">add</span> immediate and the standard <span class="literal">add</span> instruction is the meaning of the <span class="literal">reg</span> field in the <span class="literal">mod-reg-r/m</span> byte. Because the instruction implies that the source operand is a constant, and the <span class="literal">mod-r/m</span> fields specify the destination operand, the instruction does not need to use the <span class="literal">reg</span> field to specify an operand. Instead, the 80x86 CPU uses these 3 bits as an opcode extension. For the <span class="literal">add</span> immediate instruction, these 3 bits must contain <span class="literal">0</span>, and another bit pattern would correspond to a different instruction.</p>&#13;
<p class="indent">When a constant is added to a memory location, any displacement associated with that memory location immediately precedes the constant data in the instruction sequence.</p>&#13;
<h4 class="h4" id="sec10_4_4"><strong><em>10.4.4 Encoding 8-, 16-, and 32-Bit Operands</em></strong></h4>&#13;
<p class="noindent">When designing the 8086, Intel used one opcode bit (<span class="literal">s</span>) to specify whether the operand sizes were 8 or 16 bits. Later, when it extended the 80x86 architecture to 32 bits with the introduction of the 80386, Intel had a problem: with this single operand size bit, it could encode only two sizes, but it needed to encode three (8, 16, and 32 bits). To solve this problem, Intel used an <em>operand-size prefix byte</em>.</p>&#13;
<p class="indent">Intel studied its instruction set and concluded that in a 32-bit environment, programs were likely to use 8-bit and 32-bit operands far more often than 16-bit operands. Therefore, it decided to let the size bit (<span class="literal">s</span>) in the opcode select between 8- and 32-bit operands, as described in the previous sections. Although modern 32-bit programs don’t use 16-bit operands very often, they do need them now and then. So, Intel lets you prefix a 32-bit instruction with the operand-size prefix byte, whose value is <span class="literal">$66</span>, and this prefix byte tells the CPU that the operands contain 16-bit data rather than 32-bit data.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_316"/>You do not have to explicitly add an operand-size prefix byte to your 16-bit instructions; the assembler or compiler takes care of this automatically for you. However, do keep in mind that whenever you use a 16-bit object in a 32-bit program, the instruction is 1 byte longer because of the prefix value. Therefore, you should be careful about using 16-bit instructions if size and, to a lesser extent, speed are important.</p>&#13;
<h4 class="h4" id="sec10_4_5"><strong><em>10.4.5 Encoding 64-Bit Operands</em></strong></h4>&#13;
<p class="noindent">When running in 64-bit mode, Intel and AMD x84-64 processors use special opcode prefix bytes to specify 64-bit registers. There are 16 REX opcode bytes that handle 64-bit operands and addressing modes. Because there weren’t 16 single-byte opcodes available, AMD (who designed the instruction set) chose to repurpose 16 existing opcodes (the 1-byte opcode variants for the <span class="literal">inc(</span><span class="EmpItalic">reg</span><span class="literal">)</span> and <span class="literal">dec(</span><span class="EmpItalic">reg</span><span class="literal">)</span> instructions). There are still 2-byte variants of these instructions, so rather than eliminating the instructions altogether, AMD just removed the 1-byte versions. However, standard 32-bit code (a lot of which certainly uses those 1-byte increment and decrement instructions) can no longer run on the 64-bit model. That’s why AMD and Intel introduced new 32-bit and 64-bit operation modes—so the CPUs could run both older 32-bit code and newer 64-bit code on the same piece of silicon.</p>&#13;
<h4 class="h4" id="sec10_4_6"><strong><em>10.4.6 Alternate Encodings for Instructions</em></strong></h4>&#13;
<p class="noindent">As noted earlier in this chapter, one of Intel’s primary design goals for the 80x86 was to create an instruction set that allowed programmers to write very short programs in order to save memory, which was precious at the time. One way Intel did this was to create alternative encodings of some very commonly used instructions. These alternative instructions were shorter than their standard counterparts, and Intel hoped that programmers would make extensive use of the shorter versions, thereby creating shorter programs.</p>&#13;
<p class="indent">A good example of these alternative instructions are the <span class="literal">add(</span><span class="EmpItalic">constant</span><span class="literal">,</span> <span class="EmpItalic">accumulator</span><span class="literal">);</span> instructions, where the accumulator is <span class="literal">al</span>, <span class="literal">ax</span>, or <span class="literal">eax</span>. The 80x86 provides 1-byte opcodes for <span class="literal">add(</span><span class="EmpItalic">constant</span><span class="literal">, al);</span> and <span class="literal">add(</span><span class="EmpItalic">constant</span><span class="literal">, eax);</span>, which are <span class="literal">$04</span> and <span class="literal">$05</span>, respectively. With a 1-byte opcode and no <span class="literal">mod-reg-r/m</span> byte, these instructions are 1 byte shorter than their standard <span class="literal">add</span> immediate counterparts. The <span class="literal">add(</span><span class="EmpItalic">constant</span><span class="literal">,</span> <span class="literal">ax);</span> instruction requires an operand-size prefix, so its opcode is effectively 2 bytes. However, this is still 1 byte shorter than the corresponding standard <span class="literal">add</span> immediate.</p>&#13;
<p class="indent">You don’t have to specify anything special to use these instructions. Any decent assembler or compiler will automatically choose the shortest possible instruction it can use when translating your source code into machine code. However, you should note that Intel provides alternative encodings only for the accumulator registers. Therefore, if you have a choice of several instructions to use and the accumulator registers are among these choices, the AL, AX, and EAX registers are often your best bet. However, this option is usually available only to assembly language programmers.</p>&#13;
<h3 class="h3" id="sec10_5"><span epub:type="pagebreak" id="page_317"/><strong>10.5 Implications of Instruction Set Design to the Programmer</strong></h3>&#13;
<p class="noindent">Only by knowing the computer’s architecture and, in particular, how the CPU encodes machine instructions, can you make the most efficient use of the machine’s instructions. By studying instruction set design, you can gain a clear understanding of the following:</p>&#13;
<ul>&#13;
<li class="noindent">Why some instructions are shorter than others</li>&#13;
<li class="noindent">Why some instructions are faster than others</li>&#13;
<li class="noindent">Which constant values the CPU can handle efficiently</li>&#13;
<li class="noindent">Whether constants are more efficient than memory locations</li>&#13;
<li class="noindent">Why certain arithmetic and logical operations are more efficient than others</li>&#13;
<li class="noindent">Which types of arithmetic expressions are more easily translated into machine code than other types</li>&#13;
<li class="noindent">Why code is less efficient if it transfers control over a large distance in the object code</li>&#13;
</ul>&#13;
<p class="noindent">. . . and so on.</p>&#13;
<p class="indent">By studying instruction set design, you become more aware of the implications of the code you write (even in an HLL) in terms of efficient operation on the CPU. Armed with this knowledge, you’ll be better equipped to write great code.</p>&#13;
<h3 class="h3" id="sec10_6"><strong>10.6 For More Information</strong></h3>&#13;
<p class="ref">Hennessy, John L., and David A. Patterson. <em>Computer Architecture: A Quantitative Approach</em>. 5th ed. Waltham, MA: Elsevier, 2012.</p>&#13;
<p class="ref">Hyde, Randall. <em>The Art of Assembly Language</em>. 2nd ed. San Francisco: No Starch Press, 2010.</p>&#13;
<p class="ref">Intel. “Intel® 64 and IA-32 Architectures Software Developer Manuals.” Last updated November 11, 2019. <em><a href="https://software.intel.com/en-us/articles/intel-sdm/">https://software.intel.com/en-us/articles/intel-sdm/</a>.</em><span epub:type="pagebreak" id="page_318"/></p>&#13;
</body></html>