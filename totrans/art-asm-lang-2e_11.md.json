["```\nclassname : class\n\n               << Class declaration section >>\n\n          endclass;\n```", "```\nTYPE\n     TypicalClass:  class\n\n          Const\n               TCconst := 5;\n\n          Val\n               TCval := 6;\n\n          var\n               TCvar : uns32; // Private field used only by TCproc.\n\n          static\n               TCstatic : int32;\n\n          procedure TCproc( u:uns32 ); @returns( \"eax\" );\n          iterator TCiter( i:int32 ); external;\n\n          method TCmethod( c:char );\n\n     endclass;\n```", "```\nmov ( obj.TCconst, eax );\n    mov( obj.TCval, ebx );\n    add( obj.TCvar, eax );\n    add( obj.TCstatic, ebx );\n    obj.TCproc( 20 );  // Calls the TCproc procedure in TypicalClass.\n    etc.\n```", "```\nprocedure TypicalClass.TCproc( u:uns32 ); @nodisplay;\n     << Local declarations for this procedure >>\nbegin TCproc;\n\n     << Code to implement whatever this procedure does >>\n\nend TCProc;\n```", "```\nvar\n     T1: TypicalClass;\n     T2: TypicalClass;\n```", "```\ntype\n     sc: class\n\n          var\n               i:int32;\n\n          static\n               s:int32;\n               .\n               .\n               .\n     endclass;\n\nvar\n     s1: sc;\n     s2: sc;\n```", "```\nvar\n     pSC: pointer to sc;\n          .\n          .\n          .\n     mem.alloc( @size( sc ) );\n     mov( eax, pSC );\n          .\n          .\n          .\n     mov( pSC, ebx );\n     mov( (type sc [ebx]).i, eax );\n```", "```\ntype\n     point: class\n\n          var\n               x:int32;\n               y:int32;\n\n          method distance;\n\n     endclass;\n```", "```\ntype\n     point3D: class inherits( point )\n\n          var\n               z:int32;\n\n     endclass;\n```", "```\nmov( P3.x, eax );\n     add( P3.y, eax );\n     mov( eax, P3.z );\n     P3.distance();\n```", "```\ntype\n     point3D:     class inherits( point )\n\n          var\n               z:int32;\n          method distance; // This doesn't work!\n     endclass;\n```", "```\ntype\n     point3D: class inherits( point )\n\n          var\n               z:int32;\n\n          override method distance; // This will work!\n\n     endclass;\n```", "```\nmethod point3D.distance; @nodisplay;\n\n     << Local declarations for the distance function >>\n\nbegin distance;\n\n     << Code to implement the distance function >>\n\nend distance;\n```", "```\nvar\n     P2: point;\n     P:  pointer to point;\n```", "```\nmov( P2.x, eax );\n     mov( P2.y, ecx );\n     P2.distance();       // Calls point3D.distance.\n\n     lea( ebx, P2 );      // Store address of P2 into P.\n     mov( ebx, P );\n     P.distance();        // Calls point.distance.\n```", "```\nvar\n     P2: point;\n     P3: point3D;\n     p:  pointer to point;\n          .\n          .\n          .\n\n     lea( ebx, P2 );\n     mov( ebx, p );\n     p.distance();         // Calls the point.distance method.\n          .\n          .\n          .\n     lea( ebx, P3 );\n     mov( ebx, p );        // Yes, this is semantically legal.\n     p.distance();         // Surprise, this calls point3D.distance.\n```", "```\ntype\n     point2D: class\n         const\n              UnitDistance: real32 := 1.0;\n\n         var\n              x: real32;\n              y: real32;\n\n         static\n              LastDistance: real32;\n\n         method distance\n         (\n             fromX: real32;\n             fromY: real32\n         ); @returns( \"st0\" );\n         procedure InitLastDistance;\n\n     endclass;\n```", "```\nmethod point2D.distance( fromX:real32; fromY:real32 ); @nodisplay;\nbegin distance;\n\n     fld( x );       // Note: this doesn't work!\n     fld( fromX );   // Compute (x-fromX)\n     fsubp();\n     fld( st0 );     // Duplicate value on TOS.\n     fmulp();        // Compute square of difference.\n\n     fld( y );       // This doesn't work either.\n     fld( fromY );   // Compute (y-fromY)\n     fsubp();\n     fld( st0 );     // Compute the square of the difference.\n     fmulp();\n     faddp();\n     fsqrt();\n\nend distance;\n```", "```\nvar\n     Origin:    point2D;\n     PtInSpace: point2D;\n```", "```\n(type point2D [esi]).x\n```", "```\nmethod point2D.distance( fromX:real32; fromY:real32 ); @nodisplay;\nbegin distance;\n\n          fld( this.x );\n          fld( fromX );     // Compute (x-fromX).\n          fsubp();\n          fld( st0 );       // Duplicate value on TOS.\n          fmulp();          // Compute square of difference.\n\n          fld( this.y );\n          fld( fromY );     // Compute (y-fromY).\n          fsubp();\n          fld( st0 );       // Compute the square of the difference.\n          fmulp();\n          faddp();\n          fsqrt();\n\nend distance;\n```", "```\n.\n      .\n      .\n      fld( this.x );         // esi points at current object.\n      .\n      .\n      .\n      push( esi );           // Preserve esi across this method call.\n      *`SomeObject`*.*`SomeMethod`*();\n      pop( esi );\n      .\n      .\n      .\n      lea( ebx, this.x );    // esi points at original object here.\n```", "```\nthis.distance( 5.0, 6.0 );\n```", "```\nfld( point2D.UnitDistance );\n```", "```\nmethod point2D.distance( fromX:real32; fromY:real32 ); @nodisplay;\nbegin distance;\n\n      fld( this.x );\n      fld( fromX );        // Compute (x-fromX).\n      fsubp();\n      fld( st0 );          // Duplicate value on TOS.\n      fmulp();             // Compute square of difference.\n\n      fld( this.y );\n      fld( fromY );        // Compute (y-fromY).\n      fsubp();\n      fld( st0 );          // Compute the square of the difference.\n      fmulp();\n      faddp();\n      fsqrt();\n\n      fst( point2D.LastDistance ); // Update shared (STATIC) field.\n\nend distance;\n```", "```\nOrigin.InitLastDistance();\n      point2D.InitLastDistance();\n```", "```\ntype\n     student: record\n          Name:     char[65];\n          Major:    int16;\n          SSN:      char[12];\n          Midterm1: int16;\n          Midterm2: int16;\n          Final:    int16;\n          Homework: int16;\n          Projects: int16;\n     endrecord;\n     student2: class\n          var\n               Name:     char[65];\n               Major:    int16;\n               SSN:      char[12];\n               Midterm1: int16;\n               Midterm2: int16;\n               Final:    int16;\n               Homework: int16;\n               Projects: int16;\n     endclass;\n```", "```\ntype\n     tHasStatic: class\n\n          var\n               i:int32;\n               j:int32;\n               r:real32;\n\n          static\n               c:char[2];\n               b:byte;\n\n     endclass;\n\nvar\n     hs1: tHasStatic;\n     hs2: tHasStatic;\n```", "```\nmov( *`ObjectAdrs`*, ESI );       // All class routines do this.\nmov( [esi], edi );            // Get the address of the VMT into edi\ncall( (type dword [edi+n]));  // \"n\" is the offset of the method's\n                              // entry in the VMT.\n```", "```\nreadonly\n     VMT( *`classname`* );\n```", "```\nreadonly\n     myVMT: VMT( *`classname`* );\n```", "```\ntype\n     tBaseClass: class\n          var\n               i:uns32;\n               j:uns32;\n               r:real32;\n\n          method mBase;\n     endclass;\n\n     tChildClassA: class inherits( tBaseClass )\n          var\n               c:char;\n               b:boolean;\n               w:word;\n\n          method mA;\n     endclass;\n\n     tChildClassB: class inherits( tBaseClass )\n          var\n               d:dword;\n               c:char;\n               a:byte[3];\n\n     endclass;\n```", "```\nvar\n     B1:  tBaseClass;\n     CA:  tChildClassA;\n     CB:  tChildClassB;\n     ptr: pointer to tBaseClass;\n          .\n          .\n          .\n     lea( ebx, B1 );\n     mov( ebx, ptr );\n     << Use ptr >>\n          .\n          .\n          .\n     lea( eax, CA );\n     mov( ebx, ptr );\n     << Use ptr >>\n          .\n          .\n          .\n     lea( eax, CB );\n     mov( eax, ptr );\n     << Use ptr >>\n```", "```\nvar\n     sc: tBaseClass;\n          .\n          .\n          .\n     lea( esi, sc );     // Get the address of the object (& VMT).\n     mov( [esi], edi );  // Put address of VMT into edi.\n     call( (type dword [edi+@offset( tBaseClass.mBase )] );\n```", "```\nlea( esi, sc );\n     mov( (type tBaseClass [esi])._pVMT_, edi );\n     call( (type dword [edi+@offset( tBaseClass.mBase )] );\n```", "```\nvar\n     bc: tBaseClass;\n          .\n          .\n          .\n     bc.mBase();\n```", "```\nlea( esi, bc);\n     mov( [esi], edi );\n     call( (type dword [edi+@offset( tBaseClass.mBase )] );\n```", "```\nmov( &tBaseClass._VMT_, bc._pVMT_ );\n```", "```\ntClass.clsProc();\n     Obj.clsProc();\n```", "```\nprocedure tBaseClass.create; @nodisplay;\nbegin create;\n\n  if( ESI = 0 ) then\n\n      push( eax );      // mem.alloc returns its result here, so save it.\n      mem.alloc( @size( tBaseClass ));\n      mov( eax, esi );  // Put pointer into esi.\n      pop( eax );\n\n  endif;\n\n  // Initialize the pointer to the VMT:\n  // Remember, \"this\" is shorthand for \"(type tBaseClass [esi])\".\n\n  mov( &tBaseClass._VMT_, this._pVMT_ );\n\n  // Other class initialization would go here.\n\nend create;\n```", "```\nvar\n     bc0: tBaseClass;\n     bcp: pointer to tBaseClass;\n          .\n          .\n          .\n     bc0.create();  // Initializes preallocated bc0 object.\n          .\n          .\n          .\n     // Allocate storage for bcp object.\n\n     mem.alloc( @size( tBaseClass ));\n     mov( eax, bcp );\n          .\n          .\n          .\n     bcp.create();  // Initializes preallocated bcp object.\n```", "```\nmov( bcp, esi );\n     call tBaseClass.create;\n```", "```\nvar\n     bcp2: pointer to tBaseClass;\n          .\n          .\n          .\n   tBaseClass.create(); // Calls create with esi=NULL.\n   mov( esi, bcp2 );    // Save pointer to new class object in bcp2.\n```", "```\ntype\n     tBase: class\n          var\n               i:uns32;\n               j:int32;\n\n          procedure create(); @returns( \"esi\" );\n     endclass;\n\n     tDerived: class inherits( tBase );\n          var\n               r: real64;\n          override procedure create(); @returns( \"esi\" );\n     endclass;\n\n     procedure tBase.create; @nodisplay;\n     begin create;\n\n          if( esi = 0 ) then\n\n               push( eax );\n               mov( mem.alloc( @size( tBase )), esi );\n               pop( eax );\n\n          endif;\n          mov( &tBase._VMT_, this._pVMT_ );\n          mov( 0, this.i );\n          mov( −1, this.j );\n\n     end create;\n\n     procedure tDerived.create; @nodisplay;\n     begin create;\n\n          if( esi = 0 ) then\n\n               push( eax );\n               mov( mem.alloc( @size( tDerived )), esi );\n               pop( eax );\n\n          endif;\n\n          // Initialize the VMT pointer for this object:\n\n          mov( &tDerived._VMT_, this._pVMT_ );\n\n          // Initialize the \"r\" field of this particular object:\n\n     fldz();\n     fstp( this.r );\n\n     // Duplicate the initialization required by tBase.create:\n\n     mov( 0, this.i );\n     mov( −1, this.j );\n\n     end create;\n```", "```\nprocedure tDerived.create; @nodisplay;\n     begin create;\n\n        if( esi = 0 ) then\n\n             push( eax );\n             mov( mem.alloc( @size( tDerived )), esi );\n             pop( eax );\n\n        endif;\n\n        // Call the base class constructor to do any initialization\n        // needed by the base class. Note that this call must follow\n        // the object allocation code above (so esi will always contain\n        // a pointer to an object at this point and tBase.create will\n        // never allocate storage).\n\n        (type tBase [esi]).create();\n\n        // Initialize the VMT pointer for this object. This code\n        // must always follow the call to the base class constructor\n        // because the base class constructor also initializes this\n        // field and we don't want the initial value supplied by\n        // tBase.create.\n\n        mov( &tDerived._VMT_, this._pVMT_ );\n\n        // Initialize the \"r\" field of this particular object:\n\n        fldz();\n        fstp( this.r );\n\n     end create;\n```", "```\nprocedure tBase.destroy; @nodisplay;\nbegin destroy;\n\n     push( eax );   // isInHeap uses this.\n\n     // Place any other cleanup code here.\n     // The code to free dynamic objects should always appear last\n     // in the destructor.\n\n          /*************/\n\n     // The following code assumes that esi still contains the address\n     // of the object.\n\n     if( mem.isInHeap( esi )) then\n\n          free( esi);\n\n     endif;\n     pop( eax );\n\nend destroy;\n```", "```\nval\n     _initialize_: string := \"\";\n     _finalize_: string := \"\";\n```", "```\nprocedure *`SomeProc`*;\n     << declarations >>\nbegin *`SomeProc`*;\n\n     @text( _initialize_ );\n\n          << Procedure body >>\n\n     @text( _finalize_ );\n\nend *`SomeProc`*;\n```", "```\nprocedure *`SomeProc`*;\n     ?_initialize_ := \"mov( 0, eax );\";\n     ?_finalize_ := \"stdout.put( eax );\";\nbegin *`SomeProc`*;\n\n     // HLA emits \"mov( 0, eax );\" here in response to the _initialize_\n     // string constant.\n\n     add( 5, eax );\n\n     // HLA emits \"stdout.put( eax );\" here.\n\nend *`SomeProc`*;\n```", "```\nprocedure *`SomeProc`*;\n     ?_initialize_ := _initialize_  + \"mov( 0, eax );\";\n     ?_finalize_ := _finalize_ + \"stdout.put( eax );\";\nbegin *`SomeProc`*;\n\n     // HLA emits \"mov( 0, eax );\" here in response to the _initialize_\n     // string constant.\n\n     add( 5, eax );\n\n     // HLA emits \"stdout.put( eax );\" here.\n\nend *`SomeProc`*;\n```", "```\nprocedure *`SomeProc`*;\n     << Declarations that modify _initialize_ and _finalize_ >>\nbegin *`SomeProc`*;\n\n     << HLA emits the code for the _initialize_ string here. >>\n\n     try   // Catch any exceptions that occur:\n\n          << Procedure body goes here. >>\n\n     anyexception\n\n          push( eax );             // Save the exception #.\n          @text( _finalize_ );     // Execute the _finalize_ code here.\n          pop( eax );              // Restore the exception #.\n          raise( eax );            // Reraise the exception.\n\n     endtry;\n\n     << HLA automatically emits the _finalize_ code here. >>\n\nend *`SomeProc`*;\n```", "```\n*`ForwardSymbolName`*: forward( *`undefinedID`* );\n```", "```\n?*`undefinedID`*: text := \"*`ForwardSymbolName`*\";\n```", "```\ntype\n     myClass: class\n          var\n               i:int32;\n\n          procedure create; @returns( \"esi\" );\n               procedure destroy;\n          endclass;\n\n#macro _myClass: varID;\n     forward( varID );\n     ?_initialize_ := _initialize_ + @string:varID + \".create(); \";\n     ?_finalize_ := _finalize_ + @string:varID + \".destroy(); \";\n     varID: myClass\n#endmacro;\n```", "```\nprocedure HasmyClassObject;\nvar\n     mco: _myClass;\nbegin HasmyClassObject;\n\n     << Do stuff with mco here. >>\n\nend HasmyClassObject;\n```", "```\nprocedure HasmyClassObject;\nvar\n     mco:                 // Expansion of the _myClass macro:\n       forward( _0103_ ); // _0103_ symbol is an HLA-supplied text\n                          // symbol that expands to \"mco\".\n\n     ?_initialize_ := _initialize_ + \"mco\" + \".create(); \";\n     ?_finalize_ := _finalize_ + \"mco\" + \".destroy(); \";\n     mco: myClass;\n\nbegin HasmyClassObject;\n\n     mco.create();  // Expansion of the _initialize_ string.\n\n     << Do stuff with mco here. >>\n\n     mco.destroy(); // Expansion of the _finalize_ string.\n\nend HasmyClassObject;\n```", "```\nvar\n     mcoArray: _myClass[10];\n```", "```\nmcoArray:              // Expansion of the _myClass macro:\n         forward( _0103_ ); // _0103_ symbol is an HLA-supplied text\n                            // symbol that expands to \"mcoArray\".\n\n     ?_initialize_ := _initialize_ + \"mcoArray\" + \".create(); \";\n     ?_finalize_ := _finalize_ + \"mcoArray\" + \".Destroy(); \";\n     mcoArray: myClass[10];\n```", "```\ntype\n     uint: class\n          var\n               TheValue: dword;\n\n          method put;\n          << Other methods for this class >>\n     endclass;\n\n     sint: class\n          var\n               TheValue: dword;\n\n          method put;\n          << Other methods for this class >>\n     endclass;\n\n     r64: class\n          var\n               TheValue: real64;\n\n          method put;\n          << Other methods for this class >>\n     endclass;\n```", "```\ntype\n     numeric: class\n          method put;\n          << Other common methods shared by all the classes >>\n     endclass;\n\n     uint: class inherits( numeric )\n          var\n               TheValue: dword;\n\n          override method put;\n          << Other methods for this class >>\n     endclass;\n\n     sint: class inherits( numeric )\n          var\n               TheValue: dword;\n\n          override method put;\n          << Other methods for this class >>\n     endclass;\n\n     r64: class inherits( numeric )\n          var\n               TheValue: real64;\n\n          override method put;\n          << Other methods for this class >>\nendclass;\n```", "```\ntype\n     numeric: class\n          method put; abstract;\n          << Other common methods shared by all the classes >>\n     endclass;\n```", "```\n*`ReturnSomeObject`*(); // Returns a pointer to some class in esi.\n     mov( esi, *`ptrToObject`* );\n```", "```\n*`ObjectPointerOrVar`* is *`ClassType`*\n```", "```\nif( *`ptrToNumeric`* is uint ) then begin\n     .\n     .\n     .\n     end;\n```", "```\nmov( *`ptrToNumeric`*, esi );\n     if( (type uint [esi])._pVMT_ = &uint._VMT_  ) then\n          .\n          .\n          .\n     endif;\n```", "```\nif( edi = &uint._VMT_  ) then\n          .\n          .\n          .\n     endif;\n```", "```\ntype\n     *`myCls`*: class\n          .\n          .\n          .\n          method m;\n          .\n          .\n          .\n     endclass;\n          .\n          .\n          .\n     call( *`myCls`*._VMT_[ @offset( *`myCls`*.m )]);\n```"]