<html><head></head><body>
<h2 class="h2" id="ch3"><span epub:type="pagebreak" id="page_37"/><span class="big">3</span><br/>COMBINING COMMANDS</h2>&#13;
<div class="image1"><img class="inline" src="../images/common.jpg" alt="Images"/></div>&#13;
<p class="noindent"><span class="bign">So far, you’ve been using the PowerShell console to call one command at a time. For simple code, this isn’t a problem: you run the command you need, and if you need one more, you call that too. But for bigger projects, having to call each command individually is too time-consuming.</span> Luckily, you can combine commands so you can call them as a single unit. In this chapter, you’ll learn two ways of combining commands: by using the PowerShell pipeline and by saving your code in external scripts.</p>&#13;
<h3 class="h3" id="ch3lev1">Starting a Windows Service</h3>&#13;
<p class="noindent">To illustrate why you’d want to combine commands, you’ll start by doing a simple example the old way. You’ll use two commands: <code>Get-Service</code>, which queries Windows services and returns information about them; and <code>Start-Service</code>, which starts Windows services. As shown in <a href="ch03.xhtml#ch3list1">Listing 3-1</a>, use <code>Get-Service</code> to make sure the service exists and then use <code>Start-Service</code> to start it.</p>&#13;
<pre><span epub:type="pagebreak" id="page_38"/>PS&gt; <span class="codestrong1">$serviceName =</span> <span class="codestrong1">'wuauserv'</span>&#13;
PS&gt; <span class="codestrong1">Get-Service -Name $serviceName</span>&#13;
Status   Name               DisplayName&#13;
------   ----               -----------&#13;
Running  wuauserv           Windows Update&#13;
PS&gt; <span class="codestrong1">Start-Service -Name $serviceName</span></pre>&#13;
<p class="caption" id="ch3list1"><em>Listing 3-1: Finding a service and starting it by using the <code>Name</code> parameter</em></p>&#13;
<p class="indent">You run <code>Get-Service</code> just to make sure PowerShell doesn’t throw any errors. Chances are the service is already running. If it is, <code>Start-Service</code> will simply return control to the console.</p>&#13;
<p class="indent">When you’re starting just one service, running the commands like this isn’t particularly taxing. But you can imagine how monotonous it might get if you were working with hundreds of services. Let’s look at how to simplify this problem.</p>&#13;
<h3 class="h3" id="ch3lev2">Using the Pipeline</h3>&#13;
<p class="noindent">The first way to simplify your code is by chaining together commands by using the PowerShell <em>pipeline</em>, a tool that allows you to send the output of one command directly into another command as input. To use the pipeline, use the <em>pipe operator</em> (<code>|</code>) between two commands, like so:</p>&#13;
<pre><span class="codestrong1">PS&gt;</span><span class="codeitalicst1"> command1</span><span class="codestrong1"> |</span> <span class="codeitalicst1">command2</span></pre>&#13;
<p class="indent">Here, the output of <span class="codeitalic">command1</span> is <em>piped</em> into <span class="codeitalic">command2</span>, becoming <span class="codeitalic">command2</span>’s input. The final command in the pipeline will output to the console.</p>&#13;
<p class="indent">Many shell scripting languages, including <em>cmd.exe</em> and bash, use a pipeline. But what makes the pipeline in PowerShell unique is that it passes objects and not simple strings. Later in this chapter, you’ll look at how that happens, but for now, let’s rewrite the code in <a href="ch03.xhtml#ch3list1">Listing 3-1</a> by using the pipeline.</p>&#13;
<h4 class="h4" id="ch3lev2sec1">Piping Objects Between Commands</h4>&#13;
<p class="noindent">To send the output of <code>Get-Service</code> into <code>Start-Service</code>, use the code in <a href="ch03.xhtml#ch3list2">Listing 3-2</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Service -Name 'wuauserv' | Start-Service</span></pre>&#13;
<p class="caption" id="ch3list2"><em>Listing 3-2: Piping existing services to the <code>Start-Service</code> command</em></p>&#13;
<p class="indent">In <a href="ch03.xhtml#ch3list1">Listing 3-1</a>, you used the <code>Name</code> parameter to tell the <code>Start-Service</code> command which service to start. But in this example, you don’t have to specify any parameters because PowerShell takes care of that for you. It looks at the output of <code>Get-Service</code>, decides what values it should pass to <code>Start-Service</code>, and matches the values to the parameters that <code>Start-Service</code> takes.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_39"/>If you wanted to, you could rewrite <a href="ch03.xhtml#ch3list2">Listing 3-2</a> to use no parameters at all:</p>&#13;
<pre>PS&gt; <span class="codestrong1">'wuauserv' | Get-Service | Start-Service</span></pre>&#13;
<p class="indent">PowerShell sends the string <code>wuauserv</code> into <code>Get-Service</code>, and the output of <code>Get-Service</code> into <code>Start-Service</code>—all without you having to specify a thing! You’ve combined three separate commands into a single line, but you’ll still have to reenter that line for every service you want to start. In the next section, you’ll see how to use one line to start as many services as you want.</p>&#13;
<h4 class="h4" id="ch3lev2sec2">Piping Arrays Between Commands</h4>&#13;
<p class="noindent">In a text editor such as Notepad, create a text file called <em>Services.txt</em> that contains the strings <code>Wuauserv</code> and <code>W32Time</code> on separate lines, as shown in <a href="ch03.xhtml#ch3fig1">Figure 3-1</a>.</p>&#13;
<div class="image"><img src="../images/03fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch3fig1"><em>Figure 3-1: A</em> Services.txt <em>file with <code>Wuauserv</code> and <code>W32Time</code> listed on separate lines</em></p>&#13;
<p class="indent">This file contains a list of services you want to start. I’ve used two services here for simplicity’s sake, but you could add as many as you like. To display the file to your PowerShell window, use the <code>Get-Content</code> cmdlet’s <code>Path</code> parameter:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Content -Path C:\Services.txt</span>&#13;
Wuauserv&#13;
W32Time</pre>&#13;
<p class="indent">The <code>Get-Content</code> command reads in a file line by line, adding each line to an array and then returning that array. <a href="ch03.xhtml#ch3list3">Listing 3-3</a> uses the pipeline to pass the array that <code>Get-Content</code> returns into the <code>Get-Service</code> command.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Content -Path C:\Services.txt | Get-Service</span>&#13;
&#13;
Status   Name               DisplayName&#13;
------   ----               -----------&#13;
Stopped  Wuauserv           Windows Update&#13;
Stopped  W32Time            Windows Time</pre>&#13;
<p class="caption" id="ch3list3"><em>Listing 3-3: Displaying a list of services to a PowerShell session by piping</em> Services.txt <em>to <code>Get-Service</code></em></p>&#13;
<p class="indent">The <code>Get-Content</code> command is reading in the text file and spitting out an array. But instead of sending the array itself through the pipeline, PowerShell <em>unwraps</em> it, sending each item in the array individually through the pipeline. <span epub:type="pagebreak" id="page_40"/>This allows you to execute the same command for every item in the array. By putting every service you want to start in your text file, and tacking on an extra <code>| Start-Service</code> to the command in <a href="ch03.xhtml#ch3list3">Listing 3-3</a>, you have a single command that can start as many services as you need.</p>&#13;
<p class="indent">There’s no limit to how many commands you can stitch together using the pipeline. But if you find yourself going over five, you may need to rethink your approach. Note that although the pipeline is powerful, it won’t work everywhere: most PowerShell commands accept only certain types of pipeline input, and some don’t accept any at all. In the next section, you’ll dig a little deeper into how PowerShell handles pipeline input by looking at parameter binding.</p>&#13;
<h4 class="h4" id="ch3lev2sec3">Looking at Parameter Binding</h4>&#13;
<p class="noindent">When you pass parameters to a command, PowerShell initiates a process known as <em>parameter binding</em>, in which it matches each object you pass into the command to the various parameters specified by the command’s creator. For a PowerShell command to accept pipeline input, the person who writes the command—whether that’s Microsoft or you—has to explicitly build in pipeline support for one or more parameters. You’ll notice an error if you attempt to pipe information into a command that doesn’t have pipeline support on any parameter, or if PowerShell cannot find a suitable binding. For example, try running the following command:</p>&#13;
<pre>PS&gt; 'string' | Get-Process &#13;
Get-Process : The input object cannot be bound to any parameters for the command either...&#13;
--<span class="codeitalic1">snip</span>--</pre>&#13;
<p class="indent">You should see that the command won’t accept pipeline input. To see if using the pipeline is even possible, you can look at a command’s full help content by using the <code>Full</code> parameter on the <code>Get-Help</code> command. Let’s use <code>Get-Help</code> to look at the <code>Get-Service</code> command you used in <a href="ch03.xhtml#ch3list1">Listing 3-1</a>:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Help -Name Get-Service –Full</span></pre>&#13;
<p class="indent">You should get quite a bit of output. Scroll down to the <code>PARAMETERS</code> section. This section lists information about each parameter and gives you more information than you’d get by not using the <code>Detailed</code> or <code>Full</code> parameter at all. <a href="ch03.xhtml#ch3list4">Listing 3-4</a> shows the information for <code>Get-Service</code>’s <code>Name</code> parameter.</p>&#13;
<pre>-Name &lt;string[]&gt;&#13;
        Required?                    false&#13;
        Position?                    0&#13;
        Accept pipeline input?       true (ByValue, ByPropertyName)&#13;
        Parameter set name           Default&#13;
        Aliases                      ServiceName&#13;
        Dynamic?                     false</pre>&#13;
<p class="caption" id="ch3list4"><em>Listing 3-4: The <code>Get-Service</code> command’s <code>Name</code> parameter information</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_41"/>There’s a lot of information here, but we want to focus on the <code>Accept pipeline input?</code> field. As you can imagine, this field tells you whether a parameter accepts pipeline input or not; if the parameter didn’t accept pipeline input, you’d see <code>false</code> next to this field. But notice there’s more information here: this parameter accepts pipeline input both via <code>ByValue</code> and <code>ByPropertyName</code>. Contrast this with the <code>ComputerName</code> parameter for the same command, whose information is in <a href="ch03.xhtml#ch3list5">Listing 3-5</a>.</p>&#13;
<pre>-ComputerName &lt;string[]&gt;&#13;
        Required?                    false&#13;
        Position?                    Named&#13;
        Accept pipeline input?       true (ByPropertyName)&#13;
        Parameter set name           (all)&#13;
        Aliases                      Cn&#13;
        Dynamic?                     false</pre>&#13;
<p class="caption" id="ch3list5"><em>Listing 3-5: The <code>Get-Service</code> command’s <code>ComputerName</code> parameter information</em></p>&#13;
<p class="indent">The <code>ComputerName</code> parameter allows you to specify which computer you’d like to run <code>Get-Service</code> on. Notice this parameter also accepts a <code>string</code> type. So how does PowerShell know that you mean the service name, and not the computer name, when you do something like the following?</p>&#13;
<pre>PS&gt; <span class="codestrong1">'wuauserv' | Get-Service</span></pre>&#13;
<p class="indent">PowerShell matches pipeline input to parameters in two ways. The first is via <code>ByValue</code>, which means that PowerShell will look at the <em>type</em> of object passed in and interpret it accordingly. Because <code>Get-Service</code> specifies that it accepts the <code>Name</code> parameter via <code>ByValue</code>, it will interpret any string passed to it as <code>Name</code> unless otherwise specified. Because parameters passed via <code>ByValue</code> depend on the type of input, each parameter passed via <code>ByValue</code> can be one type only.</p>&#13;
<p class="indent">The second way PowerShell will match a parameter from the pipeline is via <code>ByPropertyName</code>. In this case, PowerShell will look at the object passed in, and if it has a property with the appropriate name (<code>ComputerName</code>, in this case), then it will look at the value for that property and accept that value as the parameter. So if you wanted to pass in both a service name and a computer name to <code>Get-Service</code>, you could create a <code>PSCustomObject</code> and pass it in, as in <a href="ch03.xhtml#ch3list6">Listing 3-6</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$serviceObject = [PSCustomObject]@{Name = 'wuauserv'; ComputerName = 'SERV1'}</span>&#13;
PS&gt; <span class="codestrong1">$serviceObject | Get-Service</span></pre>&#13;
<p class="caption" id="ch3list6"><em>Listing 3-6: Passing a custom object into <code>Get-Service</code></em></p>&#13;
<p class="indent">By looking at a command’s parameter specifications, and using a hashtable to cleanly store the ones you need, you’ll be able to use the pipeline to string together all sorts of commands. But as you start to write more complex PowerShell code, you’ll need more than the pipeline. In the next section, you’ll look at how to externally store your PowerShell code as scripts.</p>&#13;
<h3 class="h3" id="ch3lev3"><span epub:type="pagebreak" id="page_42"/>Writing Scripts</h3>&#13;
<p class="noindent"><em>Scripts</em> are external files that store a sequence of commands, which you can run by entering a single line in the PowerShell console. As you can see in <a href="ch03.xhtml#ch3list7">Listing 3-7</a>, to run a script, you simply enter the path to it in the console.</p>&#13;
<pre>PS&gt; <span class="codeitalicst1">C:\FolderPathToScript\script</span><span class="codestrong1">.ps1</span>&#13;
Hello, I am in a script!</pre>&#13;
<p class="caption" id="ch3list7"><em>Listing 3-7: Running a script from the console</em></p>&#13;
<p class="indent">Although there’s nothing you can do in a script that you can’t do in the console, it’s much easier to run a single command using a script than it is to type several thousand commands! Not to mention that if you want to change anything in your code, or you make a mistake, you’ll need to retype those commands again. As you’ll see later in the book, scripting allows you to write complex, robust code. But before you start writing scripts, you have to change some PowerShell settings to make sure you can run them.</p>&#13;
<h4 class="h4" id="ch3lev3sec4">Setting the Execution Policy</h4>&#13;
<p class="noindent">By default, PowerShell does not allow you to run any scripts. If you try to run an external script in the default PowerShell installation, you’ll encounter the error in <a href="ch03.xhtml#ch3list8">Listing 3-8</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">C:\PowerShellScript.ps1</span> &#13;
<span class="codestrong1">C:\PowerShellScript.ps1:</span> File C:\PowerShellScript.ps1 cannot be loaded because&#13;
running scripts is disabled on this system. For more information, see about&#13;
_Execution_Policies at http://go.microsoft.com/fwlink/?LinkID=135170.&#13;
At line:1 char:1&#13;
+ C:\PowerShellScript.ps1&#13;
+ ~~~~~~~~~~~~~~~~~~~~~~~&#13;
    + CategoryInfo          : SecurityError: (:) [], PSSecurityException&#13;
    + FullyQualifiedErrorId : UnauthorizedAccess</pre>&#13;
<p class="caption" id="ch3list8"><em>Listing 3-8: An error that occurs when you try to run scripts</em></p>&#13;
<p class="indentb">This frustrating error message is the result of PowerShell’s <em>execution policy</em>, a security measure that decides which scripts can be run. The execution policy has four main configurations:</p>&#13;
<p class="noindenti"><strong>Restricted</strong> This configuration, which is the default, doesn’t allow you to run scripts.</p>&#13;
<p class="noindenti"><strong>AllSigned</strong> This configuration allows you to run only scripts that have been cryptographically signed by a trusted party (more on this later).</p>&#13;
<p class="noindenti"><span epub:type="pagebreak" id="page_43"/><strong>RemoteSigned</strong> This configuration allows you to run any script you write, and any script you download as long as it’s been cryptographically signed by a trusted party.</p>&#13;
<p class="noindentib"><strong>Unrestricted</strong> This configuration allows you to run any scripts.</p>&#13;
<p class="indent">To see which execution policy your machine is currently using, run the command in <a href="ch03.xhtml#ch3list9">Listing 3-9</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-ExecutionPolicy</span>&#13;
Restricted</pre>&#13;
<p class="caption" id="ch3list9"><em>Listing 3-9: Displaying the current execution policy with the <code>Get-ExecutionPolicy</code> command</em></p>&#13;
<p class="indent">Chances are you get <code>Restricted</code> when you run this command. For the purposes of this book, you’ll change the execution policy to <code>RemoteSigned</code>. This will allow you to run any script you write, while also ensuring that you use only external scripts that come from trusted sources. To change the execution policy, use the <code>Set-ExecutionPolicy</code> command and pass in the policy you want, as in <a href="ch03.xhtml#ch3list10">Listing 3-10</a>. Note that you’ll need to be running this command as an administrator (see <a href="ch01.xhtml#ch1">Chapter 1</a> for a refresher on running commands as an admin). You need to perform this command only once, as the setting is saved in the registry. If you’re in a large Active Directory environment, the execution policy can also be set across many computers at once by using Group Policy.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Set-ExecutionPolicy -ExecutionPolicy RemoteSigned</span>&#13;
&#13;
Execution Policy Change&#13;
The execution policy helps protect you from scripts that you do not trust. Changing the&#13;
execution policy might expose you to the security risks described in the about_Execution&#13;
_Policies help topic at http://go.microsoft.com/fwlink/?LinkID=135170. Do you want to change&#13;
the execution policy?&#13;
[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help (default is "N"): A</pre>&#13;
<p class="caption" id="ch3list10"><em>Listing 3-10: Changing your execution policy with the <code>Set-ExecutionPolicy</code> command</em></p>&#13;
<p class="indent">Run the <code>Get-ExecutionPolicy</code> command again in order to verify that you successfully changed the policy to <code>RemoteSigned</code>. As I said previously, you won’t need to set the execution policy every time you open PowerShell. The policy will stay at <code>RemoteSigned</code> until you want to change it again.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><span epub:type="pagebreak" id="page_44"/>SCRIPT SIGNING</p>&#13;
<p class="noindent">A <em>script signature</em> is an encrypted string appended to the end of the script as a comment; these signatures are generated by a certificate installed on your computer. When you set your policy to <code>AllSigned</code> or <code>RemoteSigned</code>, you will be able to run only those scripts that are properly signed. Signing a source lets PowerShell know that the script’s source is reliable and that the author of the script is who they say they are. A script signature looks something like this:</p>&#13;
<pre># SIG # Begin signature block&#13;
# MIIEMwYJKoZIhvcNAQcCoIIEJDCCBCACAQExCzAJBgUrDgMCGgUAMGkGCisGAQQB&#13;
# gjcCAQSgWzBZMDQGCisGAQQBgjcCAR4wJgIDAQAABBAfzDtgWUsITrck0sYpfvNR&#13;
# AgEAAgEAAgEAAgEAAgEAMCEwCQYFKw4DAhoFAAQU6vQAn5sf2qIxQqwWUDwTZnJj&#13;
--<span class="codeitalic1">snip</span>--&#13;
# m5ugggI9MIICOTCCAaagAwIBAgIQyLeyGZcGA4ZOGqK7VF45GDAJBgUrDgMCHQUA&#13;
# Dxoj+2keS9sRR6XPl/ASs68LeF8o9cM=&#13;
# SIG # End signature block</pre>&#13;
<p class="indent">You should sign any script that you’re creating and executing in a professional environment. I won’t go into how to do that here, but one of the best resources I’ve found to explain this concept is the article series “PowerShell Basics—Execution Policy and Code Signing” by Carlos Perez, a popular security guru, which you can find at <em><a href="https://www.darkoperator.com/blog/2013/3/5/powershell-basics-execution-policy-part-1.html">https://www.darkoperator.com/blog/2013/3/5/powershell-basics-execution-policy-part-1.html</a></em>.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch3lev3sec5">Scripting in PowerShell</h4>&#13;
<p class="noindent">Now that your execution policy is set, it’s time to write a script and execute it in the console. You can write PowerShell scripts in any text editor you like (Emacs, Vim, Sublime Text, Atom—even Notepad), but the most convenient way to write PowerShell scripts is by using the PowerShell Integrated Scripting Environment (ISE) or Microsoft’s Visual Studio Code editor. Technically, the ISE is deprecated, but it comes preinstalled with Windows so it will probably be the first editor you discover.</p>&#13;
<h5 class="h5">Using the PowerShell ISE</h5>&#13;
<p class="noindent">To start the PowerShell ISE, run the command in <a href="ch03.xhtml#ch3list11">Listing 3-11</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">powershell_ise.exe</span></pre>&#13;
<p class="caption" id="ch3list11"><em>Listing 3-11: Opening the PowerShell ISE</em></p>&#13;
<p class="indent">An interactive console screen that looks like <a href="ch03.xhtml#ch3fig2">Figure 3-2</a> should open up.</p>&#13;
<div class="image"><img src="../images/03fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch3fig2"><span epub:type="pagebreak" id="page_45"/><em>Figure 3-2: The PowerShell ISE</em></p>&#13;
<p class="indent">To add a script, click <strong>File <span class="ent">▶</span> New</strong>. The screen should split, with a white panel opening above the console, as in <a href="ch03.xhtml#ch3fig3">Figure 3-3</a>.</p>&#13;
<div class="image"><img src="../images/03fig03.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch3fig3"><em>Figure 3-3: The PowerShell ISE with a script opened</em></p>&#13;
<p class="indent">Click <strong>File <span class="ent">▶</span> Save</strong> and save the new file as <em>WriteHostExample.ps1</em>. I’ll save my script at the root of my C: drive, so it’s located at <em>C:\WriteHostExample.ps1</em>. Notice that you save your script with the extension <em>.ps1</em>; this extension tells your system that the file is a PowerShell script.</p>&#13;
<p class="indent">You’ll be entering all the text for your script in the white panel. The PowerShell ISE allows you to edit and run the script in the same window, which can save you a lot of annoying back and forth as you’re editing. The PowerShell ISE has many more features, although I won’t cover them here.</p>&#13;
<p class="indent">PowerShell scripts are simple text files. It doesn’t matter which text editor you use, so long as you use the correct PowerShell syntax.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_46"/>Writing Your First Script</h5>&#13;
<p class="noindent">Using whatever editor you like, add the line in <a href="ch03.xhtml#ch3list12">Listing 3-12</a> to your script.</p>&#13;
<pre><span class="codestrong1">Write-Host 'Hello, I am in a script!'</span></pre>&#13;
<p class="caption" id="ch3list12"><em>Listing 3-12: The first line in your script</em></p>&#13;
<p class="indent">Notice there’s no <code>PS&gt;</code> at the start of the line. From here on out, that’s how you’ll know whether we’re working in the console or writing in a script.</p>&#13;
<p class="indent">To run this script, head over to your console and type the path to your script, as in <a href="ch03.xhtml#ch3list13">Listing 3-13</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">C:\WriteHostExample.ps1</span>&#13;
Hello, I am in a script!</pre>&#13;
<p class="caption" id="ch3list13"><em>Listing 3-13: Executing</em> WriteHostExample.ps1 <em>in the console</em></p>&#13;
<p class="indent">Here, you use the full path to run <em>WriteHostExample.ps1</em>. If you’re already in the directory containing the script you want to run, you can use a dot to indicate the current working directory, like so: <code>.\WriteHostExample.ps1</code>.</p>&#13;
<p class="indent">Congratulations, that’s it—you’ve created your first script! It might not look like much, but it’s a big step in the right direction. By the end of this book, you’ll be defining your own PowerShell modules in scripts with hundreds of lines.</p>&#13;
<h3 class="h3" id="ch3lev4">Summary</h3>&#13;
<p class="noindent">In this chapter, you learned two valuable methods to combine commands: the pipeline and scripts. You also saw how to change your execution policy, and demystified some of the magic behind the pipeline by looking at parameter binding. We’ve laid the foundation for creating more-powerful scripts, but we need to cover a few more key concepts before we get there. In <a href="ch04.xhtml#ch4">Chapter 4</a>, you’ll learn how to make your code considerably more robust by using control flow structures such as <code>if/then</code> statements and <code>for</code> loops.</p>&#13;
</body></html>