<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="app01"><span epub:type="pagebreak" id="page_249"/><strong>A  More Bootloader Vulns</strong></h2>&#13;
<h3 class="h3" id="app01_1"><strong>A.1 PN553 Signature Bypass</strong></h3>&#13;
<p class="noindent">Wade (2021a) and Wade (2021b) document a memory corruption vulnerability in the bootloader of the PN553, PN547, PN548, PN551, and PN5180 series of NFC chips found in consumer smart-phones such as the Pixel 3 and Xiaomi MI Note 3. These implement NFC communications so that the operating system can call high-level abstractions. Raw control of the chip would be useful to perform raw NFC transactions, and that is the value of exploits for this vulnerability.</p>&#13;
<p class="indent">Within a phone, Wade found that Linux presents the device as <code>/dev/nq-nci</code>. This character device allows both standard NCI commands and custom commands unique to the series. Boot-loader commands were as follows, which he extracted from an ELF library.</p>&#13;
<table class="table95">&#13;
<colgroup>&#13;
<col style="width:15%"/>&#13;
<col style="width:85%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td><p class="tab-para"><code>c0</code></p></td>&#13;
<td><p class="tab-para">Write Memory</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><code>a2</code></p></td>&#13;
<td><p class="tab-para">Read Memory</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><code>a7</code></p></td>&#13;
<td><p class="tab-para">Write 64 bytes to Configuration</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para"><code>e0</code></p></td>&#13;
<td><p class="tab-para">Checksum and Configuration</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The <code>c0</code> commands perform firmware writes, but with an odd signing structure. The very first of these contains a version number, a SHA256 hash, and a signature of that hash. The hash itself is the hash of the <em>next</em> block, which in turn will include a hash of the block after itself. In this way, the update can proceed linearly from the beginning, verifying and writing blocks one at a time without ever having to hold the entire image in RAM.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_250"/><img id="chAfig1" src="../images/f0250-01.jpg" alt="Image" width="777" height="799"/></div>&#13;
<p class="figcap">Figure A.1: NXP PN553 NFC Controller</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_251"/>The final block is a bit different, having no hash, as there’s no subsequent block to continue the chain. Noticing that the final block could be sent multiple times without an error, Wade theorized that the upcoming hash is not replaced by this command. If it were possible to overwrite the expected value with an arbitrary hash, then anything might be used for the next block, regardless of the signature and hash chain.</p>&#13;
<p class="indent">Now, the <code>c0</code> commands that write most blocks are just a little bit longer than the <code>c0</code> command that writes the very last block. Wade found that sending an illegally long <code>e0</code> command would replace the expected hash <em>before</em> returning an error. This corruption of the expected hash would break the chain, allowing further blocks to be written as if they were signed.</p>&#13;
<p class="indent">Having this authority to patch the firmware, he then implemented a read command without range restrictions and happily dumped all memory for reverse engineering. He also notes that the SN100 chip, while similar to other series, encrypts its firmware updates, making exploitation far more difficult.</p>&#13;
<h3 class="h3" id="app01_2"><strong>A.2 Tegra X1, Fusée Gelée</strong></h3>&#13;
<p class="noindent">The Nintendo Switch uses a Tegra X1 processor from Nvidia that strictly limits the device to booting content licensed by Nintendo. Temkin (2018) presents an exploit for the USB stack of the underlying X1 chip. Reported to Nvidia as CVE-2018-6242, the bug is better known as Fusée Gelée.</p>&#13;
<p class="indent">The vulnerability is in a USB Recovery Mode (RCM) boot ROM that the device will enter when certain pins are strapped to ground and the external boot memory is unavailable. On a Switch, that’s performed by removing the eMMC board from its socket, holding the volume-down button and shorting pin 10 of <span epub:type="pagebreak" id="page_252"/>the right joystick connector to ground. The Switch then appears as a USB device, awaiting a signed payload of executable code.</p>&#13;
<div class="image"><img id="chAfig2" src="../images/f0252-01.jpg" alt="Image" width="762" height="278"/></div>&#13;
<p class="figcap">Figure A.2: Fusée Gelée <code>memcpy</code></p>&#13;
<p class="indent">Temkin describes the bug as an unchecked length when reading from the device. USB control requests include a 16-bit length field for the maximum amount of data that the device might transfer to the host in a reply. For example, the host might ask the device for its status, and the device could reply with just a couple of bytes instead of the maximum allowed by the host. She identified three exceptions to this rule, in which the X1’s USB stack would send as much data as the host allows:</p>&#13;
<ul>&#13;
<li class="noindent"><code>GET_CONFIGURATION</code> request with a <code>DEVICE</code> recipient.</li>&#13;
<li class="noindent"><code>GET_INTERFACE</code> request with an <code>INTERFACE</code> recipient.</li>&#13;
<li class="noindent"><code>GET_STATUS</code> request with an <code>ENDPOINT</code> recipient.</li>&#13;
</ul>&#13;
<p class="indent">Reads past the end of a buffer are great for dumping memory, but buffering makes this far more serious. When the host asks for 65,535 bytes of status, those excess bytes are copied from the status variable’s address to one of the DMA buffers for USB transfer. Because the DMA buffers are small and located just <span epub:type="pagebreak" id="page_253"/>beneath the call stack, this overflow in the copy can overwrite the <em>entire</em> call stack!</p>&#13;
<p class="indent">Conveniently, the memory after the status variable is also controlled by the host. Much of it is used as a buffer to hold up to <code>0x30000</code> bytes of an RCM command. The command has a signature that we can’t forge, but it is stored in memory before the signature is checked.</p>&#13;
<p class="indent"><a href="app01.xhtml#chAfig2">Figure A.2</a> shows the layout of memory as Temkin’s exploit copies the pending RCM command over the call stack. There are no stack canaries or address space layout randomization (ASLR) to complicate things, and the call stack itself is executable. Trust-Zone is also not a problem here, as the RCM ROM runs in the highest privilege level as the Secure Monitor.</p>&#13;
<h3 class="h3" id="app01_3"><strong>A.3 LPC55S69, K82 USB Overread</strong></h3>&#13;
<p class="noindent">In addition to the TrustZone-M vulnerability in NXP’s LPC55S-69 that we’ll see in <a href="app03.xhtml#app03_4">Chapter C.4</a>, there is a USB overread bug in both that chip and NXP’s Kinetis K82 chip. Kilobytes of memory can be read past the end of a much smaller buffer. The bug was fixed in Revision A3 of the LPC55S69, but it is suspected that the same USB stack and its vulnerability were used in a variety of microcontrollers.</p>&#13;
<p class="indent">Alaudeen’s exploit for the LPC55S69 from Alaudeen (2021) is shown in <a href="app01.xhtml#chAfig3">Figure A.3</a>, which dumps 16kB from the chip before it resets. The K82 exploit in <a href="app01.xhtml#chAfig4">Figure A.4</a> involves a more complicated transaction, but successfully dumps 64kB from the chip.</p>&#13;
<p class="indent">These two exploits are each limited to 4kB due to value of <code>MAX_CTRL_BUFFER_LENGTH</code> in libusb. It’s apparently possible to simply patch this <code>#define</code> to 65,536 in the library’s source code on many Linux platforms.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_254"/><img id="chAfig3" src="../images/f0254-01.jpg" alt="Image" width="822" height="671"/></div>&#13;
<p class="figcap">Figure A.3: Alaudeen’s USB Exploit for the LPC55S69</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_255"/><img id="chAfig4" src="../images/f0255-01.jpg" alt="Image" width="821" height="693"/></div>&#13;
<p class="figcap">Figure A.4: Alaudeen’s USB Exploit for the K82</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_256"/>Alaudeen provides sample dumps from both chips, but I can’t seem to find details on what is found within the dumps. As this chip has hundreds of kilobytes of SRAM, I expect that you are likely to find some bytes from the prior boot in the dump, but that you should not expect the technique to reveal much of the flash memory’s contents.</p>&#13;
<h3 class="h3" id="app01_4"><strong>A.4 CH552 Verify Command</strong></h3>&#13;
<p class="noindent">The CH552 is a cheap 8051 microcontroller with handy USB peripherals in the W.CH series from Nanjing Qinheng Microelectronics. Christophel and Thomas (2018) began as a German forum thread exploring this handy chip, but the conversation quickly took a turn to reverse engineering the bootloader as a way to write new clients without documentation.</p>&#13;
<p class="indent">The bootloader comes pre-written to flash memory of these chips, but it is not in masked ROM, so software patches are possible. Eleven commands support reading, writing, erasing, and verifying flash memory. In keeping with the 8051’s Harvard architecture, there are separate commands for accessing the disjoint code and data memories.</p>&#13;
<p class="indent">The exploitable bug here is in command <code>0xA6</code>, which verifies the code flash region. You provide it with a start address and some XOR-encoded bytes,<sup><a id="app1fn_1" href="footnotes.xhtml#app1fn1">1</a></sup> and it returns zero if they match or non-zero if there’s an error. Thomas rewrites the vulnerable function as the C in <a href="app01.xhtml#chAfig6">Figure A.6</a>.</p>&#13;
<p class="indent">The intent of the code seems to be that by requiring a multiple of eight bytes, an attacker should not be able to use the Verify function to brute-force the contents of memory. While it is true that guessing eight bytes at once would take forever, the bootloader’s author has forgotten to enforce alignment of the address!</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_257"/><img id="chAfig5" src="../images/f0257-01.jpg" alt="Image" width="777" height="893"/></div>&#13;
<p class="figcap">Figure A.5: W.CH CH552</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_258"/><img id="chAfig6" src="../images/f0258-01.jpg" alt="Image" width="821" height="368"/></div>&#13;
<p class="figcap">Figure A.6: Decompiled CH552 Verification</p>&#13;
<p class="indent">So to exploit this vulnerability, an attacker can set the address to seven known bytes followed by an eighth unknown byte, then brute-force the eighth byte. Once it is known, the window can slide forward by one byte to crack the next.</p>&#13;
<p class="indent">One direct way to exploit this is to begin at the known boot-loader, then slide forward into the application one byte at a time. A more generic technique, used in Cheron (2019), is to assume that the firmware ends with eight bytes of <code>0xff</code> and work backward to the start of the application image.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_259"/><img id="chAfig7" src="../images/f0259-01.jpg" alt="Image" width="821" height="322"/></div>&#13;
<p class="figcap">Figure A.7: Stack Buffer Overflow in BCM61650</p>&#13;
<h3 class="h3" id="app01_5"><strong>A.5 BCM61650/PRC6000 Headers</strong></h3>&#13;
<p class="noindent">Broadcom’s BCM61650, previously known as the PRC6000 before their acquisition of Percello, is a MIPS CPU used in 3G femtocells as a plugin to a popular French brand of DSL and fiber modems.</p>&#13;
<p class="indent">Xilokar (2022) describes an exploit against the header format of the chip’s TFTP boot image. He begins by patching the module hardware to expose Ethernet pins, then popping a root shell by exposed passwords in a TFTP network boot image. After gaining this foothold, he wrote the quick kernel module in <a href="app01.xhtml#chAfig8">Figure A.8</a> to dump the ROM into the kernel log.</p>&#13;
<p class="indent">Having the ROM dump, he identified a parsing bug in the bootloader’s header parsing routine, shown in <a href="app01.xhtml#chAfig7">Figure A.7</a>. The bug here is that <code>fm_sig_len</code> is directly read from the attacker-controlled bootloader header, and its destination buffer at <code>0xbf40-090c</code> is not far from the initial stack position of <code>0xbf403ff0</code>. A very long header will overwrite stack variables and the return pointer during the copy.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_260"/><img id="chAfig8" src="../images/f0260-01.jpg" alt="Image" width="822" height="879"/></div>&#13;
<p class="figcap">Figure A.8: Linux ROM Dumper for the BCM61650</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_261"/>By crafting an obscenely long signature length, the Percello bootloader can be exploited to skip the signature validation. The FM loader can then be freely patched to allow an arbitrary kernel and initial ramdisk.</p>&#13;
<h3 class="h3" id="app01_6"><strong>A.6 PSoC4 Flash Doubler</strong></h3>&#13;
<p class="noindent">The PSoC4 series of ARM Cortex M0 microcontrollers from Cypress has a protected ROM, called SROM, that implements many boot features. It in turn uses a hidden and protected flash memory, called SFLASH, to store settings such as the protection level of the chip and the capacity of flash memory.</p>&#13;
<p class="indent">In Grinberg (2017a), Dmitry Grinberg published details for dumping the SROM by a ROP chain triggered from user flash memory, patching the SFLASH by re-implementing the SROM’s flash library, and doubling the capacity of a CY8C4013SXI-400 from 8kB to 16kB by patching two bytes of SFLASH.</p>&#13;
<p class="indent">As a follow-up, Grinberg (2017b) attempts to thoroughly document the extra registers and their meanings to aid in porting these attacks to other chips.</p>&#13;
<h3 class="h3" id="app01_7"><strong>A.7 i.MX53 Overflow in Bootloader</strong></h3>&#13;
<p class="noindent">The i.MX53 chip used in the first-generation USB Armory device has a stack buffer overflow vulnerability in its boot ROM, described in Delugré and Szkudlapski (2017), that allows for a bypass of the code signing and secure boot restrictions. A few more details are in Barisani (2017).</p>&#13;
<p class="indent">The first vuln, CVE-2017-7932, is a stack buffer overflow in the X.509 parser. The certificate is parsed before it is verified, so the exploit can trigger without proper signing, and a proof of concept <span epub:type="pagebreak" id="page_262"/>is available in the <code>hab_poc</code> function of <code>usbarmory_csftool</code> in the USB Armory git repository.</p>&#13;
<p class="indent">The second, CVE-2017-7936, allows for remote code execution in ROM’s implementation of the Serial Download Protocol (SDP) by abusing incorrect memory checks.</p>&#13;
<h3 class="h3" id="app01_8"><strong>A.8 M16C Bootloader Timing Attack</strong></h3>&#13;
<p class="noindent">Renesas M16C chips have a ROM bootloader that’s vulnerable to a straightforward timing attack, at least until the fourth revision of the bootloader. In Bazanski and Kowalczyk (2018), this was used as a way to dump the Mitsubishi M306K9FCLRP chip that functions as the embedded controller in a Toshiba Portégé R100 laptop.</p>&#13;
<p class="indent">The firmware extraction bug itself is a simple timing attack against a password check. As you enumerate every possible first byte, one of them will be 3 µs faster than the other 255. Repeating this for each byte gives the expected password in an average of 900 guesses, after which all seven bytes are known. With those seven bytes, you can freely read and write flash memory.</p>&#13;
<p class="indent">An exploit for this bug is available as Bazanski (2017). It runs as a Python host application, matched to an ICEStick FPGA devboard, programmed with the open source Icestorm toolchain.</p>&#13;
<h3 class="h3" id="app01_9"><strong>A.9 IC204 Bypass by Magic Number</strong></h3>&#13;
<p class="noindent">Lim (2021) describes the inner workings of a Mercedes-Benz ECU whose model number is the IC204. Lim’s specific example is from a 2011 C300, but many vehicles between 2007 and 2013 ought to be vulnerable to the same bug.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_263"/><img id="chAfig9" src="../images/f0263-01.jpg" alt="Image" width="778" height="778"/></div>&#13;
<p class="figcap">Figure A.9: Nyan Cat on a 2011 Mercedes Dashboard</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_264"/>The trick here is that the Renesas uPD70F3426 is programmed with a ROM bootloader chain that verifies signatures on each section as the boot progresses. Lim reverse engineered that ROM to find that the signature check is performed just once per firmware update, and each block’s successful verification is cached as a 32-bit magic word.</p>&#13;
<p class="indent">The magic word in this case is <code>0x5a5a5a5a</code>. By writing that word to <code>0x0f1f80</code>, <code>0x16ef80</code>, <code>0x1b3f80</code>, <code>0x1f4f80</code>, <code>0x1f5f80</code>, <code>0x0fff80</code> and <code>0x1fff80</code>, all of which are allowed by the ROM, the signature check can be bypassed and arbitrary code can be freely run.</p>&#13;
<p class="indent">After gaining control of the ECU firmware, he added Nyan Cat to the ABS and SYS malfunction messages in <a href="app01.xhtml#chAfig9">Figure A.9</a>.</p>&#13;
<h3 class="h3" id="app01_10"><strong>A.10 Zynq 7000 Bootloader Dumping</strong></h3>&#13;
<p class="noindent">Quite often a chip is exploited first by awkward and labor intensive means, and then the dump from that first exploit is reverse engineered to find a simpler method. Such was the case with the Xilinx Zynq bootloader, after being dumped by the glitching attack in <a href="app05.xhtml#app05_16">Chapter E.16</a>.</p>&#13;
<p class="indent">Schretlen (2021a) describes such a UART bootloader, which you can enable by pulling both boot mode pins high. It takes just the Python code from <a href="app01.xhtml#chAfig10">Figure A.10</a> to upload and execute a valid image. When implementing this yourself, be careful to delay as that code does; it’s necessary to avoid reliability bugs in the ROM.</p>&#13;
<p class="indent">By this stage, it’s clear that we can upload an image, but what image is worth uploading to extract the ROM? A good first target would be something that copies the ROM into RAM for later extraction. Schretlen (2021c) presents an exploit in the form of a Zynq 7000 application header header, taking advantage <span epub:type="pagebreak" id="page_265"/>of the fact that the bootloader never bothers to verify the source address of the image.</p>&#13;
<p class="indent">Shown in <a href="app01.xhtml#chAfig10">Figure A.10</a>, the exploit payload is just an image header that copies the ROM out of its native address and into RAM at <code>0x00000000</code>. After booting the exploit, the attacker recovers the image by attaching a JTAG debugger and dumping that range of memory to disk. The JTAG debugger can’t read the original, but it can freely read the copy that the ROM refuses to boot.</p>&#13;
<h3 class="h3" id="app01_11"><strong>A.11 Zynq 7000 NAND/ONFI</strong></h3>&#13;
<p class="noindent">Schretlen (2022a) describes a memory corruption exploit for the NAND/ONFI interface of the Zynq ROM and the <code>embeddedsw</code> hardware abstraction library (HAL) prior to <code>xilinx_v2021.1</code>.</p>&#13;
<p class="indent">The ONFI specification (Open NAND Flash Interface) is a standard for NAND chips that defines their package, their pinout, and various other modes, so chips from one vendor can be a drop-in, compatible replacement for those from another vendor.</p>&#13;
<p class="indent">Beyond standardizing the pinout (<a href="app01.xhtml#chAfig12">Figure A.12</a>) and signaling, ONFI also provides a standardized “parameter page” and matching data structure. The parameter page is a page of the NAND chip that can be read by device code, as a way for the NAND to report back some of its characteristics. The parameter page structure begins with <code>4f</code>, <code>4e</code>, <code>46</code>, <code>49</code> (“<code>ONFI</code>”) and includes fields for protocol revision numbers, a baker’s dozen of optional features and commands, JEDEC manufacturer information, and memory organization.<sup><a id="app1fn_2" href="footnotes.xhtml#app1fn2">2</a></sup></p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_266"/><img id="chAfig10" src="../images/f0266-01.jpg" alt="Image" width="819" height="997"/></div>&#13;
<p class="figcap">Figure A.10: Zynq Bootloader Client from Schretlen (2021a)</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_267"/><img id="chAfig11" src="../images/f0267-01.jpg" alt="Image" width="819" height="769"/></div>&#13;
<p class="figcap">Figure A.11: Zynq 7000 Exploit Header from Schretlen (2021c)</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_268"/><img id="chAfig12" src="../images/f0268-01.jpg" alt="Image" width="737" height="435"/></div>&#13;
<p class="figcap">Figure A.12: Standardized NAND/ONFI Pinout</p>&#13;
<p class="indent">Bytes 80 through 99 of the ONFI parameter page describe the memory organization as a number of data bytes per page, spare bytes per page, pages per block, and blocks per LUN, or logical unit number. These values are poorly verified, and having too many spare bytes per page will cause an overflow in the fetching of the Bad Block Table, which is loaded into a <code>0x200</code> byte local stack variable. Overflowing this buffer gives control of several useful stack variables.</p>&#13;
<p class="indent">Because the parameter page isn’t known to be writable on any commercially available NAND flash chip, triggering this exploit requires emulating the NAND chip with an FPGA. Galan Schretlen had the advantage when writing this attack of previously having dumped the ROM by the techniques in <a href="app05.xhtml#app05_16">Chapters E.16</a> and <a href="app01.xhtml#app01_10">A.10</a>; writing the exploit blind would be more of a challenge!</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_269"/>The following is his shellcode in ARM assembly that will unlock JTAG on Xilinx Zynq and dump a few useful register values to the UART.</p>&#13;
<div class="imagel"><img src="../images/f0269-01.jpg" alt="Image" width="819" height="1004"/></div>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_270"/><img src="../images/f0270-01.jpg" alt="Image" width="827" height="1099"/></div>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_271"/><img src="../images/f0271-01.jpg" alt="Image" width="827" height="1099"/></div>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_272"/><img src="../images/f0272-01.jpg" alt="Image" width="828" height="742"/></div>&#13;
<h3 class="h3" id="app01_12"><strong>A.12 Zynq 7000 BOOT.BIN Parsing</strong></h3>&#13;
<p class="noindent">The Xilinx Zynq 7000 exploit in <a href="app01.xhtml#app01_11">Chapter A.11</a> is great when physical access is available, the NAND pins are broken out, and an FPGA emulator of the NAND chip is readily available, but these restrictions can be tiresome, and many high-end boards don’t use NAND chips, so they don’t break out the necessary pins. In this chapter we’ll discuss Schretlen (2022b), a memory <span epub:type="pagebreak" id="page_273"/>corruption vulnerability in the parser of the <code>BOOT.BIN</code> file that might be found on an SD Card.</p>&#13;
<p class="indent">This exploit requires no fancy emulator hardware, and it triggers before signatures are checked, so it does not require a separate break of the cryptography. It’s perfect for jailbreaking a device.</p>&#13;
<p class="indent">Schretlen began by using Unicorn’s Python bindings to emulate the ROM that had previously been extracted. Once functional, the emulator could be used to explore the allowed address ranges in the Register Init Lists (RILs) of <code>BOOT.BIN</code>.</p>&#13;
<p class="indent">As <code>BOOT.BIN</code> is being parsed, the ROM loads sections into RAM according to the RILs. Only <em>after</em> the image has been completely loaded is the signature checked. This defends against time-of-check to time-of-use (TOCTOU) attacks, but this also means that a parser bug might be exploited before the signature check is complete.</p>&#13;
<p class="indent">Schretlen found that while the base register of the SDIO DMA controller is not writable, it has already been set by the boot ROM because the machine is booting from an SD Card. You’ll see this same trick in many embedded exploits, in that they won’t bother to configure an I/O port or register that the exploited software has already configured.</p>&#13;
<p class="indent">The following is a Python script that generates a payload header for triggering the bug. It requires a rather fast SD Card for race condition reasons that are best explained in the original paper, and the header must be followed by blocks with shellcode that fit into the overwritten bootloader.</p>&#13;
<div class="imagel"><img src="../images/f0273-01.jpg" alt="Image" width="809" height="167"/></div>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_274"/><img src="../images/f0274-01.jpg" alt="Image" width="819" height="1099"/></div>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_275"/><img src="../images/f0275-01.jpg" alt="Image" width="828" height="1039"/></div>&#13;
<h3 class="h3" id="app01_13"><span epub:type="pagebreak" id="page_276"/><strong>A.13 TMP91 Password</strong></h3>&#13;
<p class="noindent">Toshiba’s TLCS-900 series, better known by its prefix TMP91, is a 16-bit microcontroller from the early 2000s. Its bootloader features two protections: a password and a protection flag. The protections are redundant, so that if the flag is set, the password alone is not very useful.</p>&#13;
<p class="indent">In the case of at least the TMP91FW27 and TMP91FW60 devices, O’Flynn (2023) describes a successful use of power analysis to recover the bootloader password, as well as a less successful fault injection attack against the protection flag.</p>&#13;
<p class="indent">The ROM bootloader contains just five commands, with the password being required to lock the chip with <code>0x60</code> and to execute code from RAM with <code>0x10</code>. Enabling the protection flag ensures that no new programs will run from RAM even with the password.</p>&#13;
<p class="indent">In O’Flynn’s case, he wanted to dump the firmware from his kitchen oven in order to work around a bug with the thermostat. The oven would work its way up to roughly the right temperature, but the thermometer always read the target temperature and never the actual temperature. This ruined a fine batch of cookies and Colin had to have his revenge with a firmware extraction and patch.</p>&#13;
<p class="indent">His oven uses a TMP91FW60, but he prototyped his attack against the TMP91FW27, which is more plentiful on eBay. The idea here is to first attack a cheap target, then to go back and hit the rare target.</p>&#13;
<p class="indent">For power analysis, he added a shunt resistor on the VCC pin, and he also replaced the quartz crystal with an external clock supply to keep power analysis synced with the target. By sending password guesses to the chip and measuring the voltage drop during each guess, he was able to reveal the correctness of the guess, one byte at a time. He also identified a potential target for a voltage or clock glitch to skip the flag check in the bootloader, which is necessary to run a RAM program when the protection flag is enabled.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_277"/><img id="chAfig13" src="../images/f0277-01.jpg" alt="Image" width="593" height="200"/></div>&#13;
<p class="figcap">Figure A.13: TMP91 Bootloader Commands</p>&#13;
<div class="image"><img id="chAfig14" src="../images/f0277-02.jpg" alt="Image" width="777" height="580"/></div>&#13;
<p class="figcap">Figure A.14: O’Flynn’s TMP91 Target Board</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_278"/><img id="chAfig15" src="../images/f0278-01.jpg" alt="Image" width="777" height="771"/></div>&#13;
<p class="figcap">Figure A.15: TMP91FU62F0</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_279"/>At this point, all was well on his FW27 demo board, so he moved back to the FW60 chip from his oven. Power analysis revealed the password to be <code>samsungoven0</code>, but in adjusting his voltage glitch, he accidentally erased all memory. The firmware he had worked so hard to extract was gone!</p>&#13;
<p class="indent">A few phone calls to Samsung support got a replacement shipped his way, but this board differed from the original oven in one crucial way. While both used the same password, the replacement did not have the protection flag enabled! Knowing the password, he could freely run shellcode from SRAM to dump the program memory. If you aren’t so lucky as to get a target missing the lockout bit, O’Flynn suggests searching your glitch parameters backward from the end of the search window.<span epub:type="pagebreak" id="page_280"/></p>&#13;
</div>
</div>
</body></html>