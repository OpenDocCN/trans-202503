- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing Interfaces
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: 'Every project, no matter how large or small, has an API. In fact, it usually
    has several. Some of these are user-facing, like an HTTP endpoint or a command
    line interface, and some are developer-facing, like a library’s public interface.
    On top of these, Rust crates also have a number of internal interfaces: every
    type, trait, and module boundary has its own miniature API that the rest of your
    code interfaces with. As your codebase grows in size and complexity, you’ll find
    it worthwhile to invest some thought and care into how you design even the internal
    APIs to make the experience of using and maintaining the code over time as pleasant
    as possible.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we’ll look at some of the most important considerations for
    writing idiomatic interfaces in Rust, whether the users of those interfaces are
    your own code or other developers using your library. These essentially boil down
    to four principles: your interfaces should be *unsurprising*, *flexible*, *obvious*,
    and *constrained*. I’ll discuss each of these principles in turn, to provide some
    guidance for writing reliable and usable interfaces.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: I highly recommend taking a look at the Rust API Guidelines ([https://rust-lang.github.io/api-guidelines/](https://rust-lang.github.io/api-guidelines/))
    after you’ve read this chapter. There’s an excellent checklist you can follow,
    with a detailed run-through of each recommendation. Many of the recommendations
    in this chapter are also checked by the `cargo clippy` tool, which you should
    start running on your code if you aren’t already. I also encourage you to read
    through Rust RFC 1105 ([https://rust-lang.github.io/rfcs/1105-api-evolution.html](https://rust-lang.github.io/rfcs/1105-api-evolution.html))
    and the chapter of *The Cargo Book* on SemVer compatibility ([https://doc.rust-lang.org/cargo/reference/semver.html](https://doc.rust-lang.org/cargo/reference/semver.html)),
    which cover what is and is not a breaking change in Rust.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Unsurprising
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Principle of Least Surprise, otherwise known as the Law of Least Astonishment,
    comes up a lot in software engineering, and it holds true for Rust interfaces
    as well. Where possible, your interfaces should be intuitive enough that if the
    user has to guess, they usually guess correctly. Of course, not everything about
    your application is going to be immediately intuitive in this way, but anything
    that *can* be unsurprising should be. The core idea here is to stick close to
    things the user is likely to already know so that they don’t have to relearn concepts
    in a different way than they’re used to. That way you can save their brain power
    for figuring out the things that are actually specific to your interface.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: There are a variety of ways you can make your interfaces predictable. Here,
    we’ll look at how you can use naming, common traits, and ergonomic trait tricks
    to help the user out.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Naming Practices
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A user of your interface will encounter it first through its names; they will
    immediately start to infer things from the names of types, methods, variables,
    fields, and libraries they come across. If your interface reuses names for things—say,
    methods and types—from other (perhaps common) interfaces, the user will know they
    can make certain assumptions about your methods and types. A method called `iter`
    probably takes `&self`, and probably gives you an iterator. A method called `into_inner`
    probably takes `self` and likely returns some kind of wrapped type. A type called
    `SomethingError` probably implements `std::error::Error` and appears in various
    `Result`s. By reusing common names for the same purpose, you make it easier for
    the user to guess what things do and allow them to more easily understand the
    things that are different about your interface.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 用户首先会通过接口的名称接触到它；他们会立即从遇到的类型、方法、变量、字段和库的名称中推断出一些信息。如果你的接口重用了其他（可能是常见的）接口中的名称——比如方法和类型——用户会知道他们可以对你的方法和类型做出某些假设。一个叫做`iter`的方法可能接受`&self`，并且很可能会给你一个迭代器。一个叫做`into_inner`的方法可能接受`self`，并很可能返回某种包装类型。一个叫做`SomethingError`的类型可能实现了`std::error::Error`并出现在各种`Result`中。通过为相同目的重用常见名称，你可以让用户更容易猜测某些事物的作用，并帮助他们更容易理解你的接口中与众不同的部分。
- en: A corollary to this is that things that share a name *should* in fact work the
    same way. Otherwise—for example, if your `iter` method takes `self`, or if your
    `SomethingError` type does not implement `Error`—the user will likely write incorrect
    code based on how they expect the interface to work. They will be surprised and
    frustrated and will have to spend time digging into how your interface differs
    from their expectations. When we can save the user this kind of friction, we should.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由此产生的一个推论是，具有相同名称的事物*应该*以相同的方式工作。否则——例如，如果你的`iter`方法接受`self`，或者你的`SomethingError`类型没有实现`Error`——用户可能会根据他们对接口的预期编写错误的代码。他们会感到惊讶和沮丧，并且不得不花时间去弄清楚你的接口与他们的预期有什么不同。当我们能够为用户减少这种摩擦时，我们应该尽量做到。
- en: Common Traits for Types
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型的常见特征
- en: Users in Rust will also make the major assumption that everything in the interface
    “just works.” They expect to be able to print any type with `{:?}` and send anything
    and everything to another thread, and they expect that every type is `Clone`.
    Where possible, we should again avoid surprising the user and eagerly implement
    most of the standard traits even if we do not need them immediately.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 用户通常会做出一个重要的假设，即接口中的所有东西“都能正常工作”。他们期望能够使用`{:?}`打印任何类型，并将任何东西发送到另一个线程，而且他们还期望每个类型都实现了`Clone`。在可能的情况下，我们应避免给用户带来意外，并且积极实现大多数标准特征，即使我们暂时不需要它们。
- en: Because of the coherence rules discussed in Chapter 2, the compiler will not
    allow users to implement these traits when they need them. Users aren’t allowed
    to implement a foreign trait (like `Clone`) for a foreign type like one from your
    interface. They would instead need to wrap your interface type in their own type,
    and even then it may be quite difficult to write a reasonable implementation without
    access to the type’s internals.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第2章讨论的连贯性规则，编译器将不允许用户在需要这些特征时自行实现它们。用户不能为外部类型（如来自你接口的类型）实现外部特征（例如`Clone`）。他们需要将你的接口类型包装在自己的类型中，即使如此，没有访问类型内部信息的权限，编写一个合理的实现也可能非常困难。
- en: First among these standard traits is the `Debug` trait. Nearly every type can,
    and should, implement `Debug`, even if it only prints the type’s name. Using `#[derive(Debug)]`
    is often the best way to implement the `Debug` trait in your interface, but keep
    in mind that all derived traits automatically add the same bound for any generic
    parameters. You could also simply write your own implementation by leveraging
    the various `debug_` helpers on `fmt::Formatter`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标准特征中的首个是`Debug`特征。几乎每种类型都可以且应该实现`Debug`，即使它仅仅是打印类型的名称。使用`#[derive(Debug)]`通常是实现接口中`Debug`特征的最佳方式，但请记住，所有派生特征会自动为任何泛型参数添加相同的限制。你也可以通过利用`fmt::Formatter`上的各种`debug_`辅助方法来编写自己的实现。
- en: Tied in close second are the Rust auto-traits `Send` and `Sync` (and, to a lesser
    extent, `Unpin`). If a type does not implement one of these traits, it should
    be for a very good reason. A type that is not `Send` can’t be placed in a `Mutex`
    and can’t be used even transitively in an application that contains a thread pool.
    A type that is not `Sync` can’t be shared through an `Arc` or placed in a static
    variable. Users have come to expect that types *just work* in these contexts,
    especially in the asynchronous world where nearly everything runs on a thread
    pool, and will become frustrated if you don’t ensure that your types implement
    these traits. If your types cannot implement them, make sure that fact, and the
    reason why, is well documented!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 紧随其后的是 Rust 自动特性 `Send` 和 `Sync`（以及，较少程度上，`Unpin`）。如果一个类型没有实现其中一个特性，那么它应该有充分的理由。一个非
    `Send` 的类型不能放入 `Mutex`，即使在包含线程池的应用中，也不能被传递使用。一个非 `Sync` 的类型不能通过 `Arc` 共享，也不能放入静态变量。用户已经习惯于这些类型在这些上下文中*正常工作*，特别是在异步环境中，几乎所有东西都运行在线程池上。如果你没有确保你的类型实现了这些特性，用户会感到沮丧。如果你的类型无法实现这些特性，确保在文档中清楚地说明这一事实及其原因！
- en: The next set of nearly universal traits you should implement is `Clone` and
    `Default`. These traits can be derived or implemented easily and make sense to
    implement for most types. If your type cannot implement these traits, make sure
    to call it out in your documentation, as users will usually expect to be able
    to easily create more (and new) instances of types as they see fit. If they cannot,
    they will be surprised.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是你应该实现的几乎普遍适用的特性：`Clone` 和 `Default`。这些特性可以很容易地派生或实现，对于大多数类型来说实现它们是有意义的。如果你的类型不能实现这些特性，确保在文档中指出，因为用户通常会期望能够轻松创建更多（以及新的）类型实例。如果不能做到这一点，他们会感到惊讶。
- en: 'One step further down in the hierarchy of expected traits is the comparison
    traits: `PartialEq`, `PartialOrd`, `Hash`, `Eq`, and `Ord`. The `PartialEq` trait
    is particularly desirable, because users will at some point inevitably have two
    instances of your type that they wish to compare with `==` or `assert_eq!`. Even
    if your type would compare equal for only the same instance of the type, it’s
    worth implementing `PartialEq` to enable your users to use `assert_eq!`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在预期特性的层级中，接下来是比较特性：`PartialEq`、`PartialOrd`、`Hash`、`Eq` 和 `Ord`。`PartialEq`
    特性尤其受欢迎，因为用户最终会遇到两个你类型的实例，他们希望用 `==` 或 `assert_eq!` 来比较它们。即使你的类型仅在同一个实例之间才会比较相等，还是值得实现
    `PartialEq`，以便让用户能够使用 `assert_eq!`。
- en: '`PartialOrd` and `Hash` are more specialized, and may not apply quite as broadly,
    but where possible you will want to implement them too. This is especially true
    for types a user might use as the key in a map, or a type they may deduplicate
    using any of the `std::collection` set types, since they tend to require these
    bounds. `Eq` and `Ord` come with additional semantic requirements on the implementing
    type’s comparison operations beyond those of `PartialEq` and `PartialOrd`. These
    are well documented in the documentation for those traits, and you should implement
    them *only* if you’re sure those semantics actually apply to your type.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`PartialOrd` 和 `Hash` 是更为专业化的特性，可能并不适用于所有情况，但在可能的情况下，你也需要实现它们。尤其是对于用户可能用作映射中的键，或是可能通过任何
    `std::collection` 集合类型进行去重的类型，因为这些类型通常需要这些边界。`Eq` 和 `Ord` 在实现类型的比较操作时，除了 `PartialEq`
    和 `PartialOrd` 的要求之外，还带有额外的语义要求。这些要求在这些特性的文档中有详细说明，只有在你确定这些语义适用于你的类型时，才应实现它们，*仅限于此*。'
- en: Finally, for most types, it makes sense to implement the `serde` crate’s `Serialize`
    and `Deserialize` traits. These can be easily derived, and the `serde_derive`
    crate even comes with mechanisms for overwriting the serialization for just one
    field or enum variant. Since `serde` is a third-party crate, you may not wish
    to add a required dependency on it. Most libraries therefore choose to provide
    a `serde` feature that adds support for `serde` only when the user opts into it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于大多数类型，实现 `serde` crate 的 `Serialize` 和 `Deserialize` 特性是有意义的。这些特性可以轻松派生，`serde_derive`
    crate 甚至提供了仅重写某个字段或枚举变体的序列化机制。由于 `serde` 是一个第三方 crate，你可能不希望将其作为必需的依赖项。因此，大多数库选择提供一个
    `serde` 特性，仅在用户选择时才添加对 `serde` 的支持。
- en: 'You might be wondering why I haven’t included the derivable trait `Copy` in
    this section. There are two things that set `Copy` apart from the other traits
    mentioned. The first is that users do not generally expect types to be `Copy`;
    quite to the contrary, they tend to expect that if they want two copies of something,
    they have to call `clone`. `Copy` changes the semantics of moving a value of the
    given type, which might surprise the user. This ties in to the second observation:
    it is very easy for a type to *stop* being `Copy`, because `Copy` types are highly
    restricted. A type that starts out simple can easily end up having to hold a `String`,
    or some other non-`Copy` type. Should that happen, and you have to remove the
    `Copy` implementation, that’s a backward incompatible change. In contrast, you
    rarely have to remove a `Clone` implementation, so that’s a less onerous commitment.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会好奇为什么我没有在这一节中包括可派生特征`Copy`。`Copy`与前面提到的其他特征有两点不同。首先，用户通常不期望类型是`Copy`；相反，他们往往期望如果需要两个副本的话，必须调用`clone`。`Copy`改变了移动给定类型的值的语义，这可能会让用户感到惊讶。第二个观察点是：类型变得不再是`Copy`非常容易，因为`Copy`类型的限制非常严格。一个开始时很简单的类型，最终可能需要持有`String`或其他非`Copy`类型。如果发生这种情况，而你需要移除`Copy`实现，那将是一个不兼容的改变。相比之下，通常你不需要移除`Clone`实现，因此这是一种较为轻松的承诺。
- en: Ergonomic Trait Implementations
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 人体工学特征实现
- en: 'Rust does not automatically implement traits for references to types that implement
    traits. To phrase this a different way, you cannot generally call `fn foo<T: Trait>(t:
    T)` with a `&Bar`, even if `Bar: Trait`. This is because `Trait` may contain methods
    that take `&mut self` or `self`, which obviously cannot be called on `&Bar`. Nonetheless,
    this behavior might be very surprising to a user who sees that `Trait` has only
    `&self` methods!'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 'Rust 并不会自动为引用类型实现特征。换句话说，你通常不能使用`fn foo<T: Trait>(t: T)`来传入`&Bar`，即使`Bar: Trait`。这是因为`Trait`可能包含一些接受`&mut
    self`或`self`的方法，而显然这些方法不能在`&Bar`上调用。然而，这种行为对于看到`Trait`只有`&self`方法的用户来说可能会非常令人惊讶！'
- en: 'For this reason, when you define a new trait, you’ll usually want to provide
    blanket implementations as appropriate for that trait for `&T where T: Trait`,
    `&mut T where T: Trait`, and `Box<T> where T: Trait`. You may be able to implement
    only some of these depending on what receivers the methods of `Trait` have. Many
    of the traits in the standard library have similar implementations, precisely
    because that leads to fewer surprises for the user.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '正因如此，当你定义一个新的特征时，通常希望为`&T where T: Trait`、`&mut T where T: Trait`以及`Box<T>
    where T: Trait`提供适当的通用实现。根据`Trait`方法的接收者，你可能只能实现其中的一些。标准库中的许多特征都有类似的实现，正是因为这可以减少用户的意外。'
- en: Iterators are another case where you’ll often want to specifically add trait
    implementations on references to a type. For any type that can be iterated over,
    consider implementing `IntoIterator` for both `&MyType` and `&mut MyType` where
    applicable. This makes `for` loops work with borrowed instances of your type as
    well out of the box, just like users would expect.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是另一个常见的情况，你通常会想要专门为类型的引用添加特征实现。对于任何可以被迭代的类型，考虑为`&MyType`和`&mut MyType`分别实现`IntoIterator`（如果适用）。这使得`for`循环能够像用户期望的那样，在你的类型的借用实例上直接工作。
- en: Wrapper Types
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包装类型
- en: 'Rust does not have object inheritance in the classical sense. However, the
    `Deref` trait and its cousin `AsRef` both provide something a little like inheritance.
    These traits allow you to have a value of type `T` and call methods on some type
    `U` by calling them directly on the `T`-typed value if `T: Deref<Target = U>`.
    This feels like magic to the user, and is generally great.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 'Rust 并没有像传统意义上的对象继承。然而，`Deref`特征及其“亲戚”`AsRef`提供了一些类似继承的功能。这些特征允许你拥有一个类型为`T`的值，并通过直接调用`T`类型的值来调用类型`U`的方法，只要`T:
    Deref<Target = U>`。这对用户来说像是魔法，通常效果很好。'
- en: If you provide a relatively transparent wrapper type (like `Arc`), there’s a
    good chance you’ll want to implement `Deref` so that users can call methods on
    the inner type by just using the `.` operator. If accessing the inner type does
    not require any complex or potentially slow logic, you should also consider implementing
    `AsRef`, which allows users to easily use a `&WrapperType` as an `&InnerType`.
    For most wrapper types, you will also want to implement `From<InnerType>` and
    `Into<InnerType>` where possible so that your users can easily add or remove your
    wrapping.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提供一个相对透明的包装类型（如 `Arc`），你很可能希望实现 `Deref`，以便用户可以仅使用 `.` 运算符调用内部类型的方法。如果访问内部类型不需要任何复杂或可能较慢的逻辑，你还应该考虑实现
    `AsRef`，这样用户就可以轻松地将 `&WrapperType` 用作 `&InnerType`。对于大多数包装类型，你还会希望在可能的情况下实现 `From<InnerType>`
    和 `Into<InnerType>`，以便用户可以轻松地添加或移除你的包装。
- en: 'You may also have come across the `Borrow` trait, which feels very similar
    to `Deref` and `AsRef` but is really a bit of a different beast. Specifically,
    `Borrow` is tailored for a much narrower use case: allowing the caller to supply
    any one of multiple essentially identical variants of the same type. It could,
    perhaps, have been called `Equivalent` instead. For example, for a `HashSet<String>`,
    `Borrow` allows the caller to supply either a `&str` *or* a `&String`. While the
    same could have been achieved with `AsRef`, that would not be safe without `Borrow`’s
    additional requirement that the target type implements `Hash`, `Eq`, and `Ord`
    exactly the same as the implementing type. `Borrow` also has a blanket implementation
    of `Borrow<T>` for `T`, `&T`, and `&mut T`, which makes it convenient to use in
    trait bounds to accept either owned *or* referenced values of a given type. In
    general, `Borrow` is intended only for when your type is essentially equivalent
    to another type, whereas `Deref` and `AsRef` are intended to be implemented more
    widely for anything your type can “act as.”'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也遇到过 `Borrow` 特征，它看起来与 `Deref` 和 `AsRef` 非常相似，但实际上它是有些不同的。具体来说，`Borrow` 是为一个更窄的用例量身定制的：允许调用者提供多个基本相同的类型变体中的任何一个。它或许本可以被称为
    `Equivalent`。例如，对于一个 `HashSet<String>`，`Borrow` 允许调用者提供一个 `&str` *或* `&String`。虽然同样可以通过
    `AsRef` 实现这一点，但没有 `Borrow` 的额外要求（目标类型必须实现与实现类型完全相同的 `Hash`、`Eq` 和 `Ord`），这将是不安全的。`Borrow`
    还对 `T`、`&T` 和 `&mut T` 实现了 `Borrow<T>` 的广泛实现，这使得它在特征边界中非常方便，可以接受给定类型的所有权 *或* 引用值。一般来说，`Borrow`
    仅用于当你的类型与另一种类型本质上等价时，而 `Deref` 和 `AsRef` 更广泛地用于实现任何你的类型可以“充当”的内容。
- en: Flexible
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 灵活
- en: Every piece of code you write includes, implicitly or explicitly, a contract.
    The contract consists of a set of requirements and a set of promises. The requirements
    are restrictions on how the code can be used, while the promises are guarantees
    about how the code can be used. When designing a new interface, you want to think
    carefully about this contract. A good rule of thumb is to avoid imposing unnecessary
    restrictions and to only make promises you can keep. Adding restrictions or removing
    promises usually requires a major semantic version change and is likely to break
    code elsewhere. Relaxing restrictions or giving additional promises, on the other
    hand, is usually backward compatible.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的每一行代码，隐式或显式地都包含一个合同。这个合同由一组要求和一组承诺组成。要求是对代码如何使用的限制，而承诺是关于代码如何使用的保证。在设计新接口时，你需要仔细考虑这个合同。一个好的经验法则是避免施加不必要的限制，并且只做出你能够兑现的承诺。增加限制或去除承诺通常需要进行重大语义版本的更改，并且可能会破坏其他地方的代码。另一方面，放宽限制或增加承诺通常是向后兼容的。
- en: In Rust, restrictions usually come in the form of trait bounds and argument
    types, and promises come in the form of trait implementations and return types.
    For example, compare the three function signatures in [Listing 3-1](#listing3-1).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，限制通常表现为特征边界和参数类型，而承诺则表现为特征实现和返回类型。例如，比较 [Listing 3-1](#listing3-1)
    中的三个函数签名。
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 3-1: Similar function signatures with different contracts'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 3-1: 相似的函数签名，具有不同的合同'
- en: These three function signatures all take a string and return a string, but they
    do so under very different contracts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个函数签名都接受一个字符串并返回一个字符串，但它们的合同却大不相同。
- en: The first function requires the caller to own the string in the form of the
    `String` type, and it promises that it will return an owned `String`. Since the
    contract requires the caller to allocate and requires us to return an owned `String`,
    we cannot later make this function allocation-free in a backward compatible way.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数要求调用者拥有一个`String`类型的字符串，并且承诺返回一个拥有所有权的`String`。由于契约要求调用者分配内存，并要求我们返回一个拥有所有权的`String`，因此我们不能在不破坏向后兼容性的情况下使这个函数不再需要分配内存。
- en: 'The second function relaxes the contract: the caller can provide any reference
    to a string, so the user no longer needs to allocate or give up ownership of a
    `String`. It also promises to give back a `std::borrow::Cow`, meaning it can return
    either a string reference or an owned `String`, depending on whether it needs
    to own the string. The promise here is that the function will always return a
    `Cow`, which means that we cannot, say, change it to use some other optimized
    string representation later. The caller must also specifically provide a `&str`,
    so if they have, say, a pre-existing `String` of their own, they must dereference
    it to a `&str` to call our function.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数放宽了契约：调用者可以提供任何字符串引用，因此用户不再需要分配内存或放弃`String`的所有权。它还承诺返回一个`std::borrow::Cow`，意味着它可以根据是否需要拥有字符串的所有权，返回字符串引用或拥有所有权的`String`。这里的承诺是函数将始终返回一个`Cow`，这意味着我们不能后来将其改为使用其他优化的字符串表示。调用者还必须特别提供一个`&str`，因此如果他们有一个现成的`String`，必须将其解引用为`&str`才能调用我们的函数。
- en: The third function lifts these restrictions. It requires only that the user
    pass in a type that can produce a reference to a string, and it promises only
    that the return value can produce a reference to a string.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个函数解除这些限制。它仅要求用户传入一个能够生成字符串引用的类型，并且只承诺返回值能够生成字符串引用。
- en: None of these function signatures is *better* than the others. If you need ownership
    of a string in the function, you can use the first argument type to avoid an extra
    string copy. If you want to allow the caller to take advantage of the case where
    an owned string was allocated and returned, the second function with a return
    type of `Cow` may be a good choice. Instead, what I want you to take away from
    this is that you should think carefully about what contract your interface binds
    you to, because changing it after the fact can be disruptive.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数签名中没有一个比其他的*更好*。如果你需要在函数中拥有一个字符串的所有权，你可以使用第一个参数类型来避免额外的字符串复制。如果你希望允许调用者利用已经分配并返回的拥有所有权的字符串的情况，那么第二个返回类型为`Cow`的函数可能是一个不错的选择。相反，我希望你从中得到的是，你应该仔细考虑接口所绑定的契约，因为事后修改它可能会带来破坏性影响。
- en: In the remainder of this section I give examples of interface design decisions
    that often come up, and their implications for your interface contract.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我将给出一些接口设计决策的例子，这些决策经常出现，并且它们对你的接口契约的影响。
- en: Generic Arguments
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型参数
- en: One obvious requirement your interface must place on users is what types they
    must provide to your code. If your function explicitly takes a `Foo`, the user
    must own and give you a `Foo`. There is no way around it. In most cases it pays
    off to use generics rather than concrete types, to allow the caller to pass any
    type that conforms to what your function actually needs, rather than only a particular
    type. Changing `&str` in [Listing 3-1](#listing3-1) to `impl AsRef<str>` is an
    example of this kind of relaxing. One way to go about relaxing requirements this
    way is to start with the argument fully generic with no bounds, and then just
    follow the compiler errors to discover what bounds you need to add.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你的接口必须对用户施加的一个明显要求是，他们必须为你的代码提供什么类型。如果你的函数明确地接受一个`Foo`类型，用户必须拥有并提供一个`Foo`。这是无法绕过的。在大多数情况下，使用泛型而不是具体类型是值得的，这样可以允许调用者传递任何符合你函数实际需求的类型，而不仅仅是某个特定类型。将[示例3-1](#listing3-1)中的`&str`改为`impl
    AsRef<str>`就是这种宽松的一个例子。通过这种方式放宽要求的一种方法是，从完全泛型且没有边界的参数开始，然后通过编译器的错误信息来发现你需要添加哪些边界。
- en: However, if taken to the extreme, this approach would make every argument to
    every function its own generic type, which would be both hard to read and hard
    to understand. There are no hard-and-fast rules for exactly when you should or
    should not make a given parameter generic, so use your best judgment. A good rule
    of thumb is to make an argument generic if you can think of other types a user
    might reasonably and frequently want to use instead of the concrete type you started
    with.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: You may remember from Chapter 2 that generic code is duplicated for every combination
    of types ever used with the generic code through monomorphization. With that in
    mind, the idea of making lots of arguments generic might make you worried about
    overly enlarging your binaries. In Chapter 2 we also discussed how you can use
    dynamic dispatch to mitigate this at a (usually) negligible performance cost,
    and that applies here too. For arguments that you take by reference anyway (recall
    that `dyn Trait` is not `Sized`, and that you need a wide pointer to use them),
    you can easily replace your generic argument with one that uses dynamic dispatch.
    For instance, instead of `impl AsRef<str>`, you could take `&dyn AsRef<str>`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you go running to do that, though, there are a few things you should
    consider. First, you are making this choice on behalf of your users, who cannot
    opt out of dynamic dispatch. If you know that the code you’re applying dynamic
    dispatch to will never be performance-sensitive, that may be fine. But if a user
    comes along who wants to use your library in their high-performance application,
    dynamic dispatch in a function that is called in a hot loop may be a deal breaker.
    Second, at the time of writing, using dynamic dispatch will work only when you
    have a simple trait bound like `T: AsRef<str>` or `impl AsRef<str>`. For more
    complex bounds, Rust does not know how to construct a dynamic dispatch vtable,
    so you cannot take, say, `&dyn Hash + Eq`. And finally, remember that with generics,
    the caller can always choose dynamic dispatch themselves by passing in a trait
    object. The reverse is not true: if you take a trait object, that is what the
    caller must provide.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'It may be tempting to start your interfaces off with concrete types and then
    turn them generic over time. This can work, but keep in mind that such changes
    are not necessarily backward compatible. To see why, imagine that you change a
    function from `fn foo(v: &Vec<usize>)` to `fn foo(v: impl AsRef<[usize]>)`. While
    every `&Vec<usize>` implements `AsRef<[usize]>`, type inference can still cause
    issues for users. Consider what happens if the caller invokes `foo` with `foo(&iter.collect())`.
    In the original version, the compiler could determine that it should collect into
    a `Vec`, but now it just knows that it needs to collect into some type that implements
    `AsRef<[usize]>`. And there could be multiple such types, so with this change,
    the caller’s code will no longer compile!'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Object Safety
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you define a new trait, whether or not that trait is object-safe (see
    the end of “Compilation and Dispatch” in Chapter 2) is an unwritten part of the
    trait’s contract. If the trait is object-safe, users can treat different types
    that implement your trait as a single common type using `dyn Trait`. If it isn’t,
    the compiler will disallow `dyn Trait` for that trait. You should prefer your
    traits to be object-safe even if that comes at a slight cost to the ergonomics
    of using them (such as taking `impl AsRef<str>` over `&str`), since object safety
    enables new ways to use your traits. If your trait must have a generic method,
    consider whether its generic parameters can be on the trait itself or if its generic
    arguments can also use dynamic dispatch to preserve the object safety of the trait.
    Alternatively, you can add a `where Self: Sized` trait bound to that method, which
    makes it possible to call the method only with a concrete instance of the trait
    (and not through `dyn Trait`). You can see examples of this pattern in the `Iterator`
    and `Read` traits, which are object-safe but provide some additional convenience
    methods on concrete instances.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '当你定义一个新特性时，该特性是否具备对象安全性（请参见第二章“编译与分发”部分的结尾）是特性的契约中一个未明确写明的部分。如果特性是对象安全的，用户可以将实现该特性的不同类型当作一个通用类型来使用`dyn
    Trait`。如果不是，编译器将不允许为该特性使用`dyn Trait`。即使这样做会稍微影响使用它们的可用性（比如，采用`impl AsRef<str>`而不是`&str`），你也应该倾向于使你的特性具备对象安全性，因为对象安全性能为你的特性提供新的使用方式。如果你的特性必须有一个泛型方法，考虑它的泛型参数是否可以位于特性本身，或者它的泛型参数是否也可以使用动态分发来保持特性的对象安全性。或者，你可以为该方法添加`where
    Self: Sized`的特性约束，这样就可以仅使用特性实例（而不是通过`dyn Trait`）调用该方法。你可以在`Iterator`和`Read`特性中看到这种模式的例子，这些特性是对象安全的，但在具体实例上提供了一些额外的便利方法。'
- en: There is no single answer to the question of how many sacrifices you should
    be willing to make to preserve object safety. My recommendation is that you consider
    how your trait will be used, and whether it makes sense for users to want to use
    it as a trait object. If you think it’s likely that users will want to use many
    different instances of your trait together, you should work harder to provide
    object safety than if you don’t think that use case makes much sense. For example,
    dynamic dispatch would not be useful for the `FromIterator` trait because its
    one method does not take `self`, so you wouldn’t be able to construct a trait
    object in the first place. Similarly, `std::io::Seek` is fairly useless as a trait
    object on its own, because the only thing you would be able to do with such a
    trait object is seek, without being able to read or write.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“你应该愿意为保持对象安全做出多少牺牲”这个问题，并没有唯一的答案。我的建议是，你应该考虑你的特性将如何被使用，用户是否有必要将其用作特性对象。如果你认为用户可能会希望将你的特性与许多不同的实例一起使用，那么你应该更加努力地提供对象安全，而不是认为这种用例没有什么意义。例如，动态分发对于`FromIterator`特性没有用处，因为它的唯一方法不接受`self`，因此你根本无法构造一个特性对象。类似地，`std::io::Seek`作为一个特性对象本身几乎没有用，因为你只能在特性对象上进行寻址，而无法进行读写操作。
- en: Remember that object safety is a part of your public interface! If you modify
    a trait in an otherwise backward compatible way, such as by adding a method with
    a default implementation, but it makes the trait not object-safe, you need to
    bump your major semantic version number.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对象安全是你公共接口的一部分！如果你以向后兼容的方式修改了特性，比如添加一个具有默认实现的方法，但却导致特性不再具备对象安全性，那么你需要增加你的主语义版本号。
- en: Borrowed vs. Owned
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 借用与拥有
- en: For nearly every function, trait, and type you define in Rust, you must decide
    whether it should own, or just hold a reference to, its data. Whatever decision
    you make will have far-reaching implications for the ergonomics and performance
    of your interface. Luckily, these decisions very often make themselves.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你在 Rust 中定义的几乎每个函数、特性和类型，你都必须决定它是应该拥有其数据，还是仅仅持有其数据的引用。无论你做出什么决定，都将对你的接口的可用性和性能产生深远的影响。幸运的是，这些决策通常会自己显现出来。
- en: If the code you write needs ownership of the data, such as to call methods that
    take `self` or to move the data to another thread, it must store the owned data.
    When your code must own data, it should generally also make the caller provide
    owned data, rather than taking values by reference and cloning them. This leaves
    the caller in control of allocation, and it is upfront about the cost of using
    the interface in question.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写的代码需要拥有数据，例如调用需要`self`的方式或将数据移动到另一个线程，它必须存储拥有的数据。当你的代码必须拥有数据时，通常也应该要求调用者提供拥有的数据，而不是通过引用获取值并克隆它们。这让调用者控制分配过程，并且明确了使用该接口的成本。
- en: On the other hand, if your code doesn’t need to own the data, it should operate
    on references instead. One common exception to this rule is with small types like
    `i32`, `bool`, or `f64`, which are just as cheap to store and copy directly as
    to store through references. Be wary of assuming this holds true for all `Copy`
    types, though; `[u8; 8192]` is `Copy`, but it would be expensive to store and
    copy it all over the place.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你的代码不需要拥有数据，它应该改为操作引用。一个常见的例外是像`i32`、`bool`或`f64`这样的简单类型，它们直接存储和复制的成本与通过引用存储的成本相当。然而，要小心假设这一规则适用于所有`Copy`类型；`[u8;
    8192]`是`Copy`类型，但将它到处存储和复制会非常昂贵。
- en: Sometimes, you don’t know if your code must own data or not, as it is runtime
    dependent. For this, the `Cow` type is your friend. It lets you represent data
    that *may* be owned by holding either a reference or an owned value. If asked
    to produce an owned value when it only has a reference, a `Cow` uses the `ToOwned`
    trait to make one behind the scenes, usually by cloning. `Cow` is typically used
    in return types to represent functions that sometimes allocate. For example, `String::from_utf8_lossy`
    allocates only if the input contains invalid UTF-8\. `Cow` can also be used in
    arguments for functions that can sometimes make use of owned inputs, but that’s
    rarer in practice.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你并不知道代码是否需要拥有数据，因为这取决于运行时。在这种情况下，`Cow`类型是你的朋友。它允许你通过持有引用或拥有的值来表示可能拥有的数据。如果要求在只有引用时生成一个拥有的值，`Cow`会使用`ToOwned`特性在幕后创建一个，通常是通过克隆。`Cow`通常用于返回类型，表示某些函数可能会分配内存。例如，`String::from_utf8_lossy`只有在输入包含无效UTF-8时才会分配内存。`Cow`也可以用于函数的参数，这些函数有时会使用拥有的输入，但在实践中这种情况较少见。
- en: Other times, reference lifetimes complicate the interface so much that it becomes
    a pain to use. If your users are struggling to get code to compile on top of your
    interface, that’s a sign that you may want to (even unnecessarily) take ownership
    of certain pieces of data. If you do this, start with data that is cheap to clone
    or is not part of anything performance-sensitive before you decide to heap-allocate
    what might be a huge chunk of bytes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，引用生命周期会使接口变得复杂到让它使用起来很麻烦。如果你的用户在使用你的接口时难以让代码编译通过，那通常是一个信号，表明你可能希望（即使不必要）对某些数据拥有所有权。如果你这么做，应该从那些克隆成本较低或不涉及性能敏感的部分数据开始，然后再决定是否为可能是大块字节的数据分配堆内存。
- en: Fallible and Blocking Destructors
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可失败和阻塞的析构函数
- en: Types centered on I/O often need to perform cleanup when they’re dropped. This
    may include flushing writes to disk, closing files, or gracefully terminating
    connections to remote hosts. The natural place to perform this cleanup is in the
    type’s `Drop` implementation. Unfortunately, once a value is dropped, we no longer
    have a way to communicate errors to the user except by panicking. A similar problem
    arises in asynchronous code, where we wish to finish up when there is work pending.
    By the time `drop` is called, the executor may be shutting down, and we have no
    way to do more work. We could try to start another executor, but that comes with
    its own host of problems, such as blocking in asynchronous code, as we will see
    in Chapter 8.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以 I/O 为中心的类型通常在被丢弃时需要执行清理操作。这可能包括将数据刷新到磁盘、关闭文件或优雅地终止与远程主机的连接。执行这些清理操作的自然位置是在该类型的`Drop`实现中。不幸的是，一旦值被丢弃，我们就没有办法通过其他方式向用户报告错误，除了触发恐慌（panic）。在异步代码中也会出现类似的问题，我们希望在有待完成的工作时完成任务。等到`drop`被调用时，执行器可能已经在关闭中，我们也无法再执行更多的工作。我们可以尝试启动另一个执行器，但这会带来一系列问题，例如在异步代码中阻塞，正如我们在第8章中将看到的那样。
- en: There is no perfect solution to these problems, and no matter what we do, some
    applications will inevitably fall back to our `Drop` implementation. For that
    reason, we need to provide best-effort cleanup through `Drop`. If cleanup errors,
    at least we tried—we swallow the error and move on. If an executor is still available,
    we might spawn a future to do cleanup, but if it never gets to run, we did what
    we could.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: However, we ought to provide a better alternative for users who wish to leave
    no loose threads. We can do this by providing an explicit destructor. This usually
    takes the form of a method that takes ownership of `self` and exposes any errors
    (using `-> Result<_, _>`) or asynchrony (using `async fn`) that are inherent to
    the destruction. A careful user can then use that method to gracefully tear down
    any associated resources.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: As always, there’s a trade-off. The moment you add an explicit destructor, you
    will run into two issues. First, since your type implements `Drop`, you can no
    longer move out of any of that type’s fields in the destructor. This is because
    `Drop::drop` will still be called after your explicit destructor runs, and it
    takes `&mut self`, which requires that no part of `self` has been moved. Second,
    `drop` takes `&mut self`, not `self`, so your `Drop` implementation cannot simply
    call your explicit destructor and ignore its result (because it doesn’t own `self`).
    There are a couple of ways around these problems, none of which are perfect.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: The first is to make your top-level type a newtype wrapper around an `Option`,
    which in turn holds some inner type that holds all of the type’s fields. You can
    then use `Option::take` in both destructors, and call the inner type’s explicit
    destructor only if the inner type has not already been taken. Since the inner
    type does not implement `Drop`, you can take ownership of all the fields there.
    The downside of this approach is that all the methods you wish to provide on the
    top-level type must now include code to get through the `Option` (which you know
    is always `Some` since `drop` has not yet been called) to the fields on the inner
    type.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The second workaround is to make each of your fields *takeable*. You can “take”
    an `Option` by replacing it with `None` (which is what `Option::take` does), but
    you can do this with many other types as well. For example, you can take a `Vec`
    or `HashMap` by simply replacing them with their cheap-to-construct default values—`std::mem::take`
    is your friend here. This approach works great if your types have sane “empty”
    values but gets tedious if you must wrap nearly every field in an `Option` and
    then modify every access of those fields with a matching `unwrap`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: The third option is to hold the data inside the `ManuallyDrop` type, which dereferences
    to the inner type, so there’s no need for unwraps. You can also use `ManuallyDrop::take`
    in `drop` to take ownership at destruction time. The primary downside of this
    approach is that `ManuallyDrop::take` is unsafe. There are no safety mechanisms
    in place to ensure that you don’t try to use the value inside the `ManuallyDrop`
    after you’ve called `take` or that you don’t call `take` multiple times. If you
    do, your program will silently exhibit undefined behavior, and bad things will
    happen.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, you should choose whichever of these approaches fits your application
    best. I would err on the side of going with the second option, and switching to
    the others only if you find yourself in a sea of `Option`s. The `ManuallyDrop`
    solution is excellent if the code is simple enough that you can easily check the
    safety of your code, and you are confident in your ability to do so.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Obvious
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While some users may be familiar with aspects of the implementation that underpins
    your interface, they are unlikely to understand all of its rules and limitations.
    They won’t know that it’s never okay to call `foo` after calling `bar`, or that
    it’s only safe to call the unsafe method `baz` when the moon is at a 47-degree
    angle and no one has sneezed in the past 18 seconds. Only if the interface makes
    it clear that something strange is going on will they reach for the documentation
    or carefully read type signatures. It’s therefore critical for you to make it
    as easy as possible for users to understand your interface and as hard as possible
    for them to use it incorrectly. The two primary techniques at your disposal for
    this are your documentation and the type system, so let’s look at each of those
    in turn.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Documentation
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step to making your interfaces transparent is to write good documentation.
    I could write an entire book dedicated to how to write documentation, but let’s
    focus on Rust-specific advice here.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'First, clearly document any cases where your code may do something unexpected,
    or where it relies on the user doing something beyond what’s dictated by the type
    signature. Panics are a good example of both of these circumstances: if your code
    can panic, document that fact, along with the circumstances it might panic under.
    Similarly, if your code might return an error, document the cases in which it
    does. For unsafe functions, document what the caller must guarantee in order for
    the call to be safe.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Second, include end-to-end usage examples for your code on a crate and module
    level. These are more important than examples for specific types or methods, since
    they give the user a feel for how everything fits together. With a decent high-level
    understanding of the interface’s structure, the developer may soon realize what
    particular methods and types do and where they should be used. End-to-end examples
    also give the user a starting point for customizing their usage, and they can,
    and often will, copy-paste the example and then modify it to suit their needs.
    This kind of “learning by doing” tends to work better than having them try to
    piece something together from the components.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Third, organize your documentation. Having all your types, traits, and functions
    in a single top-level module makes it difficult for the user to get a sense of
    where to start. Take advantage of modules to group together semantically related
    items. Then, use intra-documentation links to interlink items. If the documentation
    on type A talks about trait B, then it should link to that trait right there.
    If you make it easy for the user to explore your interface, they are less likely
    to miss important connections or dependencies. Also consider marking parts of
    your interface that are not intended to be public but are needed for legacy reasons
    with `#[doc(hidden)]`, so that they do not clutter up your documentation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: And finally, enrich your documentation wherever possible. Link to external resources
    that explain concepts, data structures, algorithms, or other aspects of your interface
    that may have good explanations elsewhere. RFCs, blog posts, and whitepapers are
    great for this, if any are relevant. Use `#[doc(cfg(..))]` to highlight items
    that are available only under certain configurations so the user quickly realizes
    why some method that’s listed in the documentation isn’t available. Use `#[doc(alias
    = "...")]` to make types and methods discoverable under other names that users
    may search for them by. In the top-level documentation, point the user to commonly
    used modules, features, types, traits, and methods.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Type System Guidance
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The type system is an excellent tool to ensure that your interfaces are obvious,
    self-documenting, and misuse-resistant. You have several techniques at your disposal
    that can make your interfaces very hard to misuse, and thus, make it more likely
    that they will be used correctly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'The first of these is *semantic typing*, in which you add types to represent
    the *meaning* of a value, not just its primitive type. The classic example here
    is for Booleans: if your function takes three `bool` arguments, chances are some
    user will mess up the order of the values and realize it only after something
    has gone terribly wrong. If, on the other hand, it takes three arguments of distinct
    two-variant enum types, the user cannot get the order wrong without the compiler
    yelling at them: if they attempt to pass `DryRun::Yes` to the `overwrite` argument,
    that will simply not work, nor will passing `Overwrite::No` as the `dry_run` argument.
    You can apply semantic typing beyond Booleans as well. For example, a newtype
    around a numeric type may provide a unit for the contained value, or it could
    constrain raw pointer arguments to only those that have been returned by another
    method.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: A closely related technique is to use zero-sized types to indicate that a particular
    fact is true about an instance of a type. Consider, for instance, a type called
    `Rocket` that represents the state of a real rocket. Some operations (methods)
    on `Rocket` should be available no matter what state the rocket is in, but some
    make sense only in particular situations. It is, for example, impossible to launch
    a rocket if it has already been launched. Similarly, it should probably not be
    possible to separate the fuel tank if the rocket has not yet launched. We could
    model these as enum variants, but then all the methods would be available at every
    stage, and we’d need to introduce possible panics.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Instead, as shown in [Listing 3-2](#listing3-2), we can introduce a generic
    parameter on `Rocket`, `Stage`, and use it to restrict what methods are available
    when.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 3-2: Using marker types to restrict implementations'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: We introduce unit types to represent each stage of the rocket 1. We don’t actually
    need to store the stage—only the meta-information it provides—so we store it behind
    a `PhantomData` 2 to guarantee that it is eliminated at compile time. Then, we
    write implementation blocks for `Rocket` only when it holds a particular type
    parameter. You can construct a rocket only on the ground (for now), and you can
    launch it only from the ground 3. Only when the rocket has been launched can you
    control its velocity 4. There are some things you can always do with the rocket,
    no matter what state it is in, and those we place in a generic implementation
    block 5. You’ll notice that with the interface designed this way, it’s simply
    not possible for the user to call a method at the wrong time—we have encoded the
    usage rules in the types themselves, and made illegal states *unrepresentable*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: This notion extends to many other domains as well; if your function ignores
    a pointer argument unless a given Boolean argument is true, it’s better to combine
    the two arguments instead. With an enum type with one variant for `false` (and
    no pointer) and one variant for `true` that holds a pointer, neither the caller
    nor the implementer can misunderstand the relationship between the two. This is
    a powerful idea that I highly encourage you to make use of.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Another small but useful tool in making interfaces obvious is the `#[must_use]`
    annotation. Add it to any type, trait, or function, and the compiler will issue
    a warning if the user’s code receives an element of that type or trait, or calls
    that function, and does not explicitly handle it. You may already have seen this
    in the context of `Result`: if a function returns a `Result` and you do not assign
    its return value somewhere, you get a compiler warning. Be careful not to overuse
    this annotation, though—add it only if the user is very likely to make a mistake
    if they are not using the return value.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Constrained
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over time, some user will depend on every property of your interface, whether
    bug or feature. This is especially true for publicly available libraries where
    you have no control over your users. As a result, you should think carefully before
    you make user-visible changes. Whether you’re adding a new type, field, method,
    or trait implementation or changing an existing one, you want to make sure that
    the change will not break existing users’ code, and that you are planning to keep
    that change around for a while. Frequent backward incompatible changes (major
    version increases in semantic versioning) are sure to draw the ire of your users.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Many backward incompatible changes are obvious, like renaming a public type
    or removing a public method, but some are subtler and tie in deeply with the way
    Rust works. Here, we’ll cover some of the thornier subtle changes and how to plan
    for them. You’ll see that you need to balance some of these against how flexible
    you want your interface to be—sometimes, something’s got to give.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Type Modifications
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Removing or renaming a public type will almost certainly break some user’s code.
    To counter this, you’ll want to take advantage of Rust’s visibility modifiers,
    like `pub(crate)` and `pub(in path)`, whenever possible. The fewer public types
    you have, the more freedom you have to change things later without breaking existing
    code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: User code can depend on your types in more ways than just by name, though. Consider
    the public type in [Listing 3-3](#listing3-3) and the given use of that code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 3-3: An innocent-looking public type'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Now consider what happens if you add a private field to `Unit`. Even though
    the field you add is private, the change will still break the user’s code, because
    the constructor they relied on has disappeared. Similarly, consider the code and
    use in [Listing 3-4](#listing3-4).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 3-4: User code accessing a single public field'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, too, adding a private field to `Unit` will break user code, this time
    because Rust’s exhaustive pattern match checking logic is able to see parts of
    the interface that the user cannot see. It recognizes that there are more fields,
    even though the user code cannot access them, and rejects the user’s pattern as
    incomplete. A similar issue arises if we turn a tuple struct into a regular struct
    with named fields: even if the fields themselves are exactly the same, any old
    patterns will no longer be valid for the new type definition.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Rust provides the `#[non_exhaustive]` attribute to help mitigate these issues.
    You can add it to any type definition, and the compiler will disallow the use
    of implicit constructors (like `lib::Unit { field1: true }`) and nonexhaustive
    pattern matches (that is, patterns without a trailing `, ..`) on that type. This
    is a great attribute to add if you suspect that you’re likely to modify a particular
    type in the future. It does constrain user code though, such as by taking away
    users’ ability to rely on exhaustive pattern matches, so avoid adding it if you
    think a given type is likely to remain stable.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Trait Implementations
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you’ll recall from Chapter 2, Rust’s coherence rules disallow multiple implementations
    of a given trait for a given type. Since we do not know what implementations downstream
    code may have added, adding a blanket implementation of an existing trait is generally
    a breaking change. The same holds true for implementing a foreign trait for an
    existing type, or an existing trait for a foreign type—in both cases, the owner
    of the foreign trait or type may simultaneously add a conflicting implementation,
    so this must be a breaking change.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Removing a trait implementation is a breaking change, but implementing traits
    for a *new* type is never a problem, since no crate can have implementations that
    conflict with that type.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps counterintuitively, you also want to be careful about implementing *any*
    trait for an existing type. To see why, consider the code in [Listing 3-5](#listing3-5).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 3-5: Implementing a trait for an existing type may cause problems.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: If you add `impl Foo1 for Unit` to `crate1` without marking it a breaking change,
    the downstream code will suddenly stop compiling since the call to `foo` is now
    ambiguous. This can even apply to implementations of *new* public traits, if the
    downstream crate uses wildcard imports (`use crate1::*`). You will particularly
    want to keep this in mind if you provide a `prelude` module that you instruct
    users to use wildcard imports for.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Most changes to existing traits are also breaking changes, such as changing
    a method signature or adding a new method. Changing a method signature breaks
    all implementations, and probably many uses, of the trait, whereas adding a new
    method “just” breaks all implementations. Adding a new method with a default implementation
    is fine though, since existing implementations will continue to apply.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'I say “generally” and “most” here, because as interface authors, we have a
    tool available to us that lets us skirt some of these rules: *sealed traits*.
    Asealed trait is one that can be used only, and not implemented, by other crates.
    This immediately makes a number of breaking changes non-breaking. For example,
    you can add a new method to a sealed trait, since you know there are no implementations
    outside of the current crate to consider. Similarly, you can implement a sealed
    trait for new foreign types, since you know the foreign crate that defined that
    type cannot have added a conflicting implementation.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Sealed traits are most commonly used for *derived* traits—traits that provide
    blanket implementations for types that implement particular other traits. You
    should seal a trait only if it does not make sense for a foreign crate to implement
    your trait; it severely restricts the usefulness of the trait, since downstream
    crates will no longer be able to implement it for their own types. You can also
    use sealed traits to restrict which types can be used as type arguments, such
    as restricting the `Stage` type in the `Rocket` example from [Listing 3-2](#listing3-2)
    to only the `Grounded` and `Launched` types.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-6](#listing3-6) shows how to seal a trait and how to then still
    add implementations for it in the defining crate.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 3-6: How to seal a trait and add implementations for it'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The trick is to add a private, empty trait as a supertrait of the trait you
    wish to seal 1. Since the supertrait is in a private module, other crates cannot
    reach it and thus cannot implement it. The sealed trait requires the underlying
    type to implement `Sealed`, so only the types that we explicitly allow 2 are able
    to ultimately implement the trait.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Hidden Contracts
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, changes you make to one part of your code affect the contract elsewhere
    in your interface in subtle ways. The two primary ways this happens are through
    re-exports and auto-traits.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Re-Exports
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If any part of your interface exposes foreign types, then any change to one
    of those foreign types is *also* a change to your interface. For example, consider
    what happens if you move to a new major version of a dependency and expose a type
    from that dependency as, say, an iterator type in your interface. A user that
    depends on your interface may also depend directly on that dependency and expect
    that the type your interface provides is the same as the one by the same name
    in that dependency. But if you change the major version of your dependency, that
    is no longer true even though the *name* of the type is the same. [Listing 3-7](#listing3-7)
    shows an example of this.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 3-7: Re-exports make foreign crates part of your interface contract.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: If your crate moves from `itercrate 1.0` to `itercrate 2.0` but otherwise does
    not change, the code in this listing will no longer compile. Even though no types
    have changed, the compiler believes (correctly) that `itercrate1.0::Empty` and
    `itercrate2.0::Empty` are *different* types. Therefore, you cannot assign the
    latter to the former, making this a breaking change in your interface.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate issues like this, it’s often best to wrap foreign types using the
    newtype pattern, and then expose only the parts of the foreign type that you think
    are useful. In many cases, you can avoid the newtype wrapper altogether by using
    `impl Trait` to provide only the very minimal contract to the caller. By promising
    less, you make fewer changes breaking.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Auto-Traits
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Rust has a handful of traits that are automatically implemented for every type
    depending on what that type contains. The most relevant of these for this discussion
    are `Send` and `Sync`, though the `Unpin`, `Sized`, and `UnwindSafe` traits have
    similar issues. By their very nature, these add a hidden promise made by nearly
    every type in your interface. These traits even propagate through otherwise type-erased
    types like `impl Trait`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Implementations for these traits are (generally) automatically added by the
    compiler, but that also means that they are *not* automatically added if they
    no longer apply. So, if you have a public type `A` that contains a private type
    `B`, and you change `B` so that it is no longer `Send`, then `A` is now *also*
    not `Send`. That is a breaking change!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: These changes can be hard to keep track of and are often not discovered until
    a user of your interface complains that their code no longer works. To catch these
    cases before they happen, it’s good practice to include some simple tests in your
    test suite that check that all your types implement these traits the way you expect.
    [Listing 3-8](#listing3-8) gives an example of what such a test might look like.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 3-8: Testing that a type implements a set of traits'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this test does not run any code, but simply tests that the code
    compiles. If `MyType` no longer implements `Sync`, the test code will not compile,
    and you will know that the change you just made broke the auto-trait implementation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter we’ve explored the many facets of designing a Rust interface,
    whether it’s intended for external use or just as an abstraction boundary between
    the different modules within your crate. We covered a lot of specific pitfalls
    and tricks, but ultimately, the high-level principles are what should guide your
    thinking: your interfaces should be unsurprising, flexible, obvious, and constrained.
    In the next chapter, we will dig into how to represent and handle errors in Rust
    code.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
