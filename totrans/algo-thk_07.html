<html><head></head><body>
<h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_231"/><span class="big">7</span><br/>BINARY SEARCH</h2>
<div class="image1"><img alt="Image" src="../images/common1.jpg"/></div>
<p class="noindenta">This chapter is all about binary search. If you don’t know what binary search is— excellent! I’m excited for the opportunity to teach you a systematic, performant technique for isolating an optimal solution from among zillions of possible solutions. And if you do know what binary search is and think that it’s just for searching a sorted array—excellent! You’ll learn that binary search is for so much more than that. To keep things fresh, we will not search a sorted array in this entire chapter, not even once.</p>
<p class="indent">What do minimizing the amount of liquid needed to feed ants, maximizing the minimum jump distance between rocks, finding the best living area in a city, and flipping switches to open cave doors have in common? Let’s find out.</p>
<h3 class="h3" id="lev43">Problem 1: Feeding Ants</h3>
<p class="noindent">This is DMOJ problem <code>coci14c4p4</code>.</p>
<span epub:type="pagebreak" id="page_232"/>
<h4 class="h4" id="sec96"><em>The Problem</em></h4>
<p class="noindent">Bobi has a terrarium in the shape of a tree. Each edge of the tree is a pipe in which liquid flows down. Some pipes are superpipes that increase the amount of liquid that flows through them. Bobi keeps one of his pet ants in each of the tree’s leaves. (Yes, this context is a reach. I won’t pretend otherwise, but this problem is otherwise ace.)</p>
<p class="indent">Each pipe has a percentage value that indicates the percentage of the available liquid that flows through it. For example, suppose that a node <em>n</em> has three downward pipes, where those pipes have percentage values of 20 percent, 50 percent, and 30 percent, respectively. If 20 liters of liquid arrive at Node <em>n</em>, then the 20 percent pipe gets 20 × 0.2 = 4 liters, the 50 percent pipe gets 20 × 0.5 = 10 liters, and the 30 percent pipe gets 20 × 0.3 = 6 liters.</p>
<p class="indent">Now consider the superpipes. For each superpipe, Bobi decides whether its special behavior is off or on. If it is off, then it behaves like a regular pipe. If it is on, then it squares the amount of liquid that it receives.</p>
<p class="indent">Bobi pours liquid into the root of the tree. His goal is to give each ant at least the amount of liquid that it requires and to do so by pouring as little liquid as possible.</p>
<p class="indent">Let’s make this description concrete by studying a sample terrarium; see <a href="ch07.xhtml#ch07fig01">Figure 7-1</a>.</p>
<div class="image"><img alt="Image" id="ch07fig01" src="../images/ch07fig01.jpg"/></div>
<p class="figcap"><em>Figure 7-1: A sample terrarium</em></p>
<p class="indent">I’ve numbered the nodes from 1 to 6; the leaf nodes (2, 3, 5, and 6) have an additional annotation giving the amount of liquid required by each ant. I’ve also annotated each edge with its percentage value. Notice that the percentage values of the downward pipes leaving a given node always add up to 100 percent.</p>
<p class="indent">There’s one superpipe in the tree, from Node 1 to Node 4; I’ve drawn that with a thicker edge. Suppose that 20 liters of liquid are poured into the root. The superpipe gets 30 percent of the 20 liters, which is 6 liters. If the superpipe’s special behavior is off, then 6 liters flow through it. However, <span epub:type="pagebreak" id="page_233"/>if the superpipe’s special behavior is on, then, instead of 6 liters of liquid flowing through it, 6<sup>2</sup> = 36 liters of liquid flow through it.</p>
<h5 class="h5">Input</h5>
<p class="noindent">The input contains one test case, consisting of the following lines:</p>
<ul>
<li class="noindent">A line containing <em>n</em>, the number of nodes in the tree. <em>n</em> is between 1 and 1,000. The tree nodes are numbered from 1 to <em>n</em>, and the root of the tree is node 1.</li>
<li class="noindent"><em>n</em> – 1 lines used to build the tree. Each of these lines represents one pipe and consists of four integers: the two nodes connected by the pipe, the pipe’s percentage value (between 1 and 100), and whether the pipe is a superpipe (with 0 meaning no and 1 meaning yes).</li>
<li class="noindent">A line containing <em>n</em> integers, one for each node, giving the number of liters of liquid needed by the ant in that node. Each ant requires between 1 and 10 liters of liquid. For any nonleaf node (where there is no ant), a value of –1 is given.</li>
</ul>
<p class="indent">Here’s an input that could generate the sample terrarium in <a href="ch07.xhtml#ch07fig01">Figure 7-1</a>:</p>
<pre>6
1 2 20 0
1 3 50 0
1 4 30 1
4 5 50 0
4 6 50 0
-1 2 9 -1 7 8</pre>
<p class="indent">Note how the first line (integer 6 here) indicates the number of nodes in the tree, not the number of lines that build the tree. The number of lines that build the tree (in this case five lines) is always one less than the number of nodes. (Why is it always one less? Each line that builds the tree effectively tells us the parent of one of the <em>n</em> nodes. Each node except for the root has a parent, so we need <em>n</em> – 1 lines to tell us about all of the <em>n</em> – 1 parents.)</p>
<h5 class="h5">Output</h5>
<p class="noindent">Output the minimum number of liters of liquid that Bobi must pour into the tree’s root to feed all the ants. Include four digits of accuracy after the decimal point. The correct output is guaranteed to be at most 2,000,000,000 (two billion).</p>
<p class="indent">The time limit for solving the test case is 0.6 seconds.</p>
<h4 class="h4" id="sec97"><em>A New Flavor of Tree Problem</em></h4>
<p class="noindent">As in <a href="ch02.xhtml">Chapter 2</a>, we’re in the domain of trees here. If we want to explore a terrarium tree, then we can use recursion. (A full graph-search algorithm such as BFS is overkill because there are no cycles.)</p>
<span epub:type="pagebreak" id="page_234"/>
<p class="indent">For the two problems in <a href="ch02.xhtml">Chapter 2</a>, our solutions were based on the structure of the tree and the values stored in nodes:</p>
<ul>
<li class="noindent">In Halloween Haul, we calculated the total candy by adding up the values in the leaves, and we calculated the total street-walks using the height and shape of the tree.</li>
<li class="noindent">In Descendant Distance, we calculated the number of descendants at the desired distance by using the number of children of each node.</li>
</ul>
<p class="noindent">That is, what we needed—candy values, height, tree shape—were right there, encoded for us in the tree itself. In the present problem, we’re asked to find the minimum number of liters that Bobi must pour—but the tree doesn’t contain any values like that! The tree has information on pipe percentage, superpipe status, and ant appetite, but it has nothing directly informing us of the amount of liquid that should be poured into the root. In particular, the superpipes, with their liquid-squaring behavior, make unclear the relationship between the amount of liquid needed by the ants and the amount of liquid that should be poured.</p>
<p class="indent">Because the tree won’t readily give us what we need, I’ll just pick a value out of thin air—say, 10. There you go, Bobi. Pour 10 liters in there.</p>
<p class="indent">I hope you’re very suspicious of what I just did, recklessly choosing a number like that. You should be surprised if 10 were the answer. I pulled 10 out of thin air, after all. You may also be surprised that we can in fact learn a lot by trying out the value 10 and seeing what happens.</p>
<p class="indent">Let’s use <a href="ch07.xhtml#ch07fig01">Figure 7-1</a> again. Suppose that we pour 10 liters of liquid into the root. Twenty percent of 10 is 2, so 2 liters of liquid will make it to the ant in Node 2. Perfect: that ant needs 2 liters of liquid, so we’re sending just enough liquid. Let’s continue.</p>
<p class="indent">Since 50 percent of 10 is 5, the ant in Node 3 gets 5 liters of liquid. Now we’re in trouble: that ant needs 9 liters of liquid, and 5 liters is not enough. More bad news: the pipe between Nodes 1 and 3 is not a superpipe, so there’s nothing we can do except declare that 10 is not in fact the solution.</p>
<p class="indent">We could proceed by picking another number of liters out of thin air and similarly simulating the flow of liquid on that new number. However, because 10 liters was insufficient, now we should restrict our thin-air range to only values <em>greater than 10</em>. Since 10 liters was insufficient, any smaller value will be insufficient, too. There’s no point trying 2 liters or 7 liters or 9.5 liters or anything less than 10. They’re all too small.</p>
<p class="indent">Let’s next try 20 liters. This time, the ant at Node 2 gets 4 liters, which is just fine because that ant only needs 2 liters. The ant at Node 3 gets 10 liters, which again is fine because that ant only needs 9 liters.</p>
<p class="indent">The pipe between Nodes 1 and 4 takes 30 percent of the liquid, so that’s 6 liters of the total 20 liters. However, this pipe is a superpipe! If we use its special behavior, the pipe cranks up the 6 liters to 6<sup>2</sup> = 36 liters, so 36 liters arrives at Node 4. Now the ants at Nodes 5 and 6 are fine: each ant gets 18 liters, and they only need 7 liters (Node 5) and 8 liters (Node 6).</p>
<span epub:type="pagebreak" id="page_235"/>
<p class="indent">Unlike 10 liters, then, 20 liters is a feasible solution, but is it the optimal (that is, minimal) solution? Maybe, maybe not. What we know for sure is that there’s no point testing any number of liters greater than 20. We already have 20 as a feasible solution; why try values, such as 25 or 30, that are worse?</p>
<p class="indent">We’ve now reduced the problem to finding an optimal solution between 10 and 20 liters. We could keep choosing numbers, reducing the range at each step, until our range is so small that one of its endpoints serves as an accurate solution.</p>
<p class="indent">In the general case, what number of liters should we choose first? The optimal solution could be up to 2 billion, so starting with 10 may be way, way off. And, once we test a number of liters, where should we go next? The optimal solution might be considerably larger or smaller than our current guess, so adding or subtracting 10 at a time may not help us make much progress.</p>
<p class="indent">These are good questions, good questions that we will answer . . . but not yet. Let’s first tackle how to read the input (so that we can explore a tree) and how to determine whether a number of liters is a feasible solution. Then, we’ll see a super-fast algorithm for searching massive ranges. A range of two billion? We’ll eat that for breakfast.</p>
<h4 class="h4" id="sec98"><em>Reading the Input</em></h4>
<p class="noindent">In <a href="ch02.xhtml">Chapter 2</a>, we used a <code>node</code> struct at the core of how trees were represented. Then, in <a href="ch05.xhtml">Chapter 5</a>, Book Translation, we used the adjacency list representation of a graph with an <code>edge</code> struct. There we learned that whether we use a <code>node</code> or <code>edge</code> struct comes down to whether it’s the nodes or the edges that carry additional attributes. In the present problem, the edges carry information (a percentage and a superpipe status), but so do the leaf nodes (the amount of liquid required by each ant). It’s therefore tempting and reasonable to use <em>both</em> an <code>edge</code> struct and a <code>node</code> struct. Instead, to closely parallel the use of adjacency lists, I’ve chosen to stick with only an <code>edge</code> struct. As in the problem description, we number nodes starting at 1, but, with no <code>node</code> struct, we have nowhere to store the amount of liquid required by each ant. For that reason, we augment the adjacency list with a <code>liquid_needed</code> array, where <code>liquid_needed[i]</code> gives the amount of liquid required by the ant in Node <code>i</code>.</p>
<p class="indent">Here’s the constant and <code>typedef</code> that we’ll use throughout the code:</p>
<pre>#define MAX_NODES 1000
 
typedef struct edge {
  int to_node, percentage, superpipe;
  struct edge *next;
} edge;</pre>
<p class="indent">As in Book Translation (<a href="ch05.xhtml">Chapter 5</a>) and the two problems in <a href="ch06.xhtml">Chapter 6</a>, we can chain these <code>edge</code> structs together through <code>next</code> pointers to form a linked list of edges. If an edge is in the linked list for nNde <code>i</code>, then we know <span epub:type="pagebreak" id="page_236"/>that the parent node of the edge is <code>i</code>. The <code>to_node</code> member tells us the child node at which this edge connects with the parent node; <code>percentage</code> is an integer between 1 and 100 that gives the percentage value for the pipe (edge); and <code>superpipe</code> is a flag whose value is <code>1</code> if the pipe is a superpipe and <code>0</code> if it’s a regular pipe.</p>
<p class="indent">Now we can read the tree from the input, as shown in <a href="ch07.xhtml#ch07ex01">Listing 7-1</a>.</p>
<pre>int main(void) {
  static edge *adj_list[MAX_NODES + 1] = {NULL};
  static int liquid_needed[MAX_NODES + 1];
  int num_nodes, i;
  int from_node, to_node, percentage, superpipe;
  edge *e;
  scanf("%d", &amp;num_nodes);
 
  for (i = 0; i &lt; num_nodes - 1; i++) {
    scanf("%d%d%d%d", &amp;from_node, &amp;to_node, &amp;percentage, &amp;superpipe);
    e = malloc(sizeof(edge));
    if (e == NULL) {
      fprintf(stderr, "malloc error\n");
      exit(1);
    }
    e-&gt;to_node = to_node;
    e-&gt;percentage = percentage;
    e-&gt;superpipe = superpipe;
    e-&gt;next = adj_list[from_node];
  <span class="ent">➊</span> adj_list[from_node] = e;
  }
 
  for (i = 1; i &lt;= num_nodes; i++)
  <span class="ent">➋</span> scanf("%d", &amp;liquid_needed[i]);
  solve(adj_list, liquid_needed);
  return 0;
}</pre>
<p class="excap" id="ch07ex01"><em>Listing 7-1: The</em> <span class="codeitalic1">main</span> <em>function for building the tree</em></p>
<p class="indent">The code is similar to, but simpler than, <a href="ch05.xhtml#ch05ex016">Listing 5-16</a> (Book Translation). In particular, each edge is read from the input, its members are set, and then it’s added to the list of edges for <code>from_node</code> <span class="ent">➊</span>. You may expect a corresponding edge to be added for <code>to_node</code>, since the graph is undirected, but I’ve left out such edges: liquid moves down the tree, not up, so adding backward edges would needlessly complicate the code that explores a tree.</p>
<p class="indent">Once the edge information is read in, all that’s left is to read the values for the amount of liquid required by each ant. We’ll use the <code>liquid_needed</code> array for that <span class="ent">➋</span>. The combination of <code>adj_list</code> and <code>liquid_needed</code> captures everything we need to know about the test case.</p>
<span epub:type="pagebreak" id="page_237"/>
<h4 class="h4" id="sec99"><em>Testing Feasibility</em></h4>
<p class="noindent">Our next milestone is this: determine whether a given amount of liquid is a feasible solution. This is a crucial step, because once we have a function that can test a value for feasibility, we’ll be able to use it to progressively narrow the search space until we find the optimal solution. Here’s the signature for the function that we’ll write:</p>
<pre>int can_feed(int node, double liquid,
             edge *adj_list[], int liquid_needed[])</pre>
<p class="indent">Here, <code>node</code> is the root node of the tree, <code>liquid</code> is the amount of liquid that we pour into the root of the tree, <code>adj_list</code> is the adjacency list for the tree, and <code>liquid_needed</code> is the amount of liquid required by each ant. We’ll return <code>1</code> if <code>liquid</code> is enough to feed the ants (that is, if <code>liquid</code> is a feasible solution) and <code>0</code> if it is not.</p>
<p class="indent">We spent a whole chapter (<a href="ch02.xhtml">Chapter 2</a>) writing recursive functions on trees. Let’s think about whether we can use recursion again.</p>
<p class="indent">Remember that, to use recursion, we need a base case—a case that can be solved with no recursion. Luckily, we have one! If the tree is a single leaf node, then we can determine right away whether <code>liquid</code> is sufficient. If <code>liquid</code> is greater than or equal to the amount of liquid needed by the ant in this leaf, then we have a feasible solution; otherwise, we don’t.</p>
<p class="indent">We can tell whether a node is a leaf by checking the corresponding value in <code>liquid_needed</code>: if it’s <code>-1</code>, then it isn’t a leaf; otherwise, it is. (We could have also used the adjacency list to check whether or not the linked list for the node was empty.) Here’s what we’ve got:</p>
<pre>if (liquid_needed[node] != -1)
  return liquid &gt;= liquid_needed[node];</pre>
<p class="indent">Now, consider the recursive case. Imagine that the root node of some tree has <em>p</em> downward pipes (that is, <em>p</em> children). We’re given the amount of liquid that’s poured into the root. Using the pipe percentage values, we can determine the amount of liquid that goes into each pipe; using the superpipe statuses, we can determine the amount of liquid that reaches the bottom end of each pipe. If enough liquid reaches the bottom end of each pipe, then the liquid poured into the root was sufficient and we should return <code>1</code>. Otherwise, the amount of liquid that reaches the bottom end of some pipe isn’t sufficient, and we should return <code>0</code>. This suggests that we should make <em>p</em> recursive calls, one for each pipe that leaves the root. We’ll do that in a loop that uses the adjacency list to go through each such pipe.</p>
<p class="indent">The full code for the function is given in <a href="ch07.xhtml#ch07ex02">Listing 7-2</a>.</p>
<pre>int can_feed(int node, double liquid,
             edge *adj_list[], int liquid_needed[]) {
  edge *e;
  int ok;
  double down_pipe;
  if (liquid_needed[node] != -1)
<span epub:type="pagebreak" id="page_238"/>     return liquid &gt;= liquid_needed[node];
  e = adj_list[node];
<span class="ent">➊</span> ok = 1;
  while (e &amp;&amp; ok) {
    down_pipe = liquid * e-&gt;percentage / 100;
    if (e-&gt;superpipe)
   <span class="ent">➋</span> down_pipe = down_pipe * down_pipe;
    if (!can_feed(e-&gt;to_node, down_pipe, adj_list, liquid_needed))
   <span class="ent">➌</span> ok = 0;
    e = e-&gt;next;
 }
 return ok;
}</pre>
<p class="excap" id="ch07ex02"><em>Listing 7-2: Testing the feasibility of the amount of liquid</em></p>
<p class="indent">The <code>ok</code> variable tracks whether <code>liquid</code> is a feasible solution for the tree. If <code>ok</code> is <code>1</code>, then the solution is still feasible; if <code>ok</code> is <code>0</code>, then it’s definitely not. We initialize <code>ok</code> to <code>1</code> <span class="ent">➊</span>, and we set it to <code>0</code> if the amount of liquid through one of the pipes isn’t sufficient <span class="ent">➌</span>. If <code>ok</code> is still <code>1</code> at the bottom of the function, then we’ve satisfied all pipes and we conclude that <code>liquid</code> is feasible.</p>
<p class="indent">We determine the amount of liquid that enters each pipe by using that pipe’s percentage value. Then, if the pipe is a superpipe, we square that value <span class="ent">➋</span>  . . . but hey, wait! The problem description says that Bobi gets to decide whether or not to use the special behavior of each superpipe. However, here we’re just indiscriminately squaring the amount of liquid, thereby always using the special behavior.</p>
<p class="indent">The reason we can get away with this is that squaring makes values bigger: compare 2 to 2<sup>2</sup> = 4, 3 to 3<sup>2</sup> = 9, and so on. Since we want to know whether the given amount of liquid is feasible and there’s no penalty for using the special behavior of a superpipe, we may as well generate as much liquid as possible. Maybe we could have gotten away without using some superpipe special behavior, but no one’s asking us to be economical.</p>
<p class="indent">Don’t worry that squaring makes positive values less than one, such as 0.5, smaller. 0.5<sup>2</sup> = 0.25, so indeed we wouldn’t want to activate superpipe behavior in such cases. Each ant requires at least 1 liter of liquid, though. So, if we’re down to 0.5 liters of liquid at some node, then nothing we do is going to feed the ants in the node’s subtree anyway. We’d eventually return <code>0</code> whether or not we squared the value.</p>
<p class="indent">Let’s show how useful this <code>can_feed</code> function is by continuing the work we did in “A New Flavor of Tree Problem” on <a href="ch07.xhtml#sec97">page 233</a>. We showed there that 10 liters was not sufficient for the sample instance from the problem description. Comment out the <code>solve</code> call at the bottom of <a href="ch07.xhtml#ch07ex01">Listing 7-1</a> (don’t worry: we’ll write that <code>solve</code> function soon), and add a call to <code>can_feed</code> to test 10 liters of liquid:</p>
<pre>printf("%d\n", can_feed(1, 10, adj_list, liquid_needed));</pre>
<span epub:type="pagebreak" id="page_239"/>
<p class="indent">You should see a result of <code>0</code>, which means that 10 liters isn’t sufficient. We also showed that 20 liters was sufficient. Change the <code>can_feed</code> call to test 20 liters instead of 10:</p>
<pre>printf("%d\n", can_feed(1, 20, adj_list, liquid_needed));</pre>
<p class="noindent">You should see a result of <code>1</code>, which means that 20 liters is sufficient.</p>
<p class="indent">Now, we know that 10 is not enough but 20 is. Let’s squeeze this range down further. Try 15, and you should see an output of <code>0</code>. So, it seems 15 is not enough. Our optimal answer is now greater than 15 and at most 20.</p>
<p class="indent">Try 18 next: you should see that 18 is enough. How about 17? No, 17 is not enough, nor is 17.5 or 17.9. It turns out that the optimal solution is indeed 18.</p>
<p class="indent">That’s enough of the ad hoc searching. Let’s systematize this.</p>
<h4 class="h4" id="sec100"><em>Searching for a Solution</em></h4>
<p class="noindent">From the problem description, we know that the optimal solution is at most two billion. There’s therefore a massive search space in which the optimal solution lies. Our goal is to cut down this space as quickly as possible by never wasting a guess.</p>
<p class="indent">It’s easy to waste a guess. For example, if we start with a guess of 10, and the optimal solution is in fact two billion, then we’ve essentially wasted that guess: all we’ve done is eliminate the numbers between 0 and 10. It’s true that a guess of 10 would be fantastic if the optimal solution were, say, 8, because that one step would cut the range down to 0 to 10 and we’d find 8 soon after. Nonetheless, taking shots like this isn’t worth it, because getting lucky once in a while won’t offset the very likely case that our guess tells us almost nothing. It’s for this reason that you don’t guess 10 as your first guess when someone asks you to guess their number between 1 and 1,000. Sure, if they say “lower,” you look like a full-on rock star, but if they say “higher,” as they most likely will, you’ve all but wasted that first guess.</p>
<p class="indent">To guarantee that we learn as much as possible with each guess, we’ll always guess the middle of the range. To do so, we maintain two variables, <code>low</code> and <code>high</code>, holding the low end and high end, respectively, of our current range. We then calculate the middle of the range, <code>mid</code>, test the feasibility of <code>mid</code>, and update <code>low</code> or <code>high</code> based on what we learn. We’ll implement this strategy in <a href="ch07.xhtml#ch07ex03">Listing 7-3</a>.</p>
<pre>#define HIGHEST 2000000000
 
void solve(edge *adj_list[], int liquid_needed[]) {
  double low, high, mid;
  low = 0;
  high = HIGHEST;
<span class="ent">➊</span> while (high - low &gt; 0.00001) {
  <span class="ent">➋</span> mid = (low + high) / 2;
  <span class="ent">➌</span> if (can_feed(1, mid, adj_list, liquid_needed))
<span epub:type="pagebreak" id="page_240"/>      high = mid;
    else
      low = mid;
   }
<span class="ent">➍</span> printf("%.4lf\n", high);
}</pre>
<p class="excap" id="ch07ex03"><em>Listing 7-3: Searching for the optimal solution</em></p>
<p class="indent">It’s important to initialize <code>low</code> and <code>high</code> so that their range is guaranteed to contain the optimal solution. At all times, we’ll maintain that <code>low</code> is less than or equal to the optimal solution and that <code>high</code> is greater than or equal to the optimal solution. We start <code>low</code> off with a value of 0; as each ant requires at least 1 liter, 0 liters is definitely less than or equal to the optimal solution. We start <code>high</code> off with a value of 2 billion, because it’s guaranteed by the problem description that 2 billion is the maximum value of the optimal solution.</p>
<p class="indent">The <code>while</code> loop condition forces the range between <code>low</code> and <code>high</code> to be very small by the time the loop ends <span class="ent">➊</span>. We need four digits of accuracy, hence the four 0s after the decimal point in <code>0.00001</code>.</p>
<p class="indent">The first thing to do in the loop body is to calculate the middle of the range. We’ll do that by taking the average of <code>low</code> and <code>high</code>, storing that result in <code>mid</code> <span class="ent">➋</span>.</p>
<p class="indent">Now it’s time to test <code>mid</code> liters for feasibility, using <code>can_feed</code> <span class="ent">➌</span>. If <code>mid</code> is feasible, we have learned that guessing anything larger than <code>mid</code> would be a waste. We therefore set <code>high = mid</code> to cut the range off at a maximum of <code>mid</code>.</p>
<p class="indent">If <code>mid</code> is not feasible, then guessing anything smaller than <code>mid</code> would be a waste. We therefore set <code>low = mid</code> to cut the range off at a minimum of <code>mid</code>.</p>
<p class="indent">Once the loop terminates, <code>low</code> and <code>high</code> are very close together. We’re printing <code>high</code> <span class="ent">➍</span>, but printing <code>low</code> would work just as well.</p>
<p class="indent">This technique, where we keep dividing the range in half until it’s very small, is called <em>binary search</em>. It’s a surprisingly subtle and powerful algorithm, further evidence of which will come from the remaining problems in this chapter. It’s also very fast, able to handle ranges of billions or trillions with ease.</p>
<p class="indent">Submit the solution to the judge, and then let’s keep going. There’s a lot more to know about binary search.</p>
<h3 class="h3" id="lev44">Binary Search</h3>
<p class="noindent">Feeding Ants is an exemplar of the types of problems where binary search thrives. There are two ingredients to such problems; if you see these ingredients in a new problem you’re facing, it’s worth your time to try binary search.</p>
<p class="block"><strong>Ingredient 1: Hard optimality and easy feasibility</strong>   For some problems, it’s hard to come up with a way to find an optimal solution. Fortunately, in many such cases, it’s considerably easier to determine whether or not some proposed solution is feasible. This was the situation in the <span epub:type="pagebreak" id="page_241"/>Feeding Ants problem: we didn’t know how to find an optimal solution directly, but we did see how to determine whether some number of liters was feasible.</p>
<p class="block"><strong>Ingredient 2: Infeasible–feasible split</strong>   We need the problem to exhibit the property that there is a border between infeasible and feasible solutions. All solutions on one side of the border must be infeasible, and all solutions on the other side must be feasible. In Feeding Ants, small values were infeasible and large values were feasible. Imagine considering values from small to large and asking whether each is infeasible or feasible. In doing so, we’ll see a bunch of infeasible values and then a feasible value; after our first feasible value, we won’t see infeasible values again. Suppose we try a value of 20 liters and find that it’s infeasible. This means that we’re still in the infeasible part of the search space, and we must search larger values. If 20 liters is feasible, then we’re in the feasible part of the search space, and we should search smaller values. (Not meeting Ingredient 2 renders binary search useless. For example, suppose we have a problem where small values are infeasible, larger values are feasible, and even-larger values are infeasible again. We try a value of 20 and find that it is infeasible. Don’t even think about focusing on values greater than 20: for all we know, values less than 10 could be infeasible and 10 to 15 could be feasible, giving 10 as the optimal solution here.) It’s also okay if the search space transitions from feasible to infeasible, rather than from infeasible to feasible. Our next problem will offer such an example.</p>
<h4 class="h4" id="sec101"><em>Runtime of Binary Search</em></h4>
<p class="noindent">The reason why binary search is so powerful is that it makes a huge amount of progress with just a single iteration. For example, suppose that we’re searching for an optimal solution in a range of two billion. A single iteration of binary search throws out half of this range, leaving a range of only one billion. Let that sink in: with just a single <code>if</code> statement and one variable update to <code>mid</code>, we make one billion units of progress! If binary search takes <em>q</em> iterations to search a range of one billion, then it takes only one more iteration, <em>q</em> + 1, to search a range of two billion. The number of iterations grows very slowly compared to the width of the range.</p>
<p class="indent">The number of iterations taken by binary search to cut a range <em>n</em> to range 1 is roughly the number of times that <em>n</em> must be divided by 2 to get down to 1. For example, say that we start with a range of 8. After one iteration, we’ll have reduced the range to at most 4. After two iterations, we’ll have reduced the range to at most 2. After three iterations, we’ll have reduced the range to 1. Moreover, if we don’t care about decimal digits of accuracy, then that’s it: three iterations.</p>
<p class="indent">There’s a mathematical function called the <em>base-2 logarithm</em>, which, given value <em>n</em>, tells you how many times you have to divide <em>n</em> by 2 to get 1 or less. It’s written log<sub>2</sub> <em>n</em> or, when the discussion makes it clear that two is the base, as just log <em>n</em>. For example, log<sub>2</sub> 8 is 3 and log<sub>2</sub> 16 is 4. log<sub>2</sub> 2,000,000,000 <span epub:type="pagebreak" id="page_242"/>(that’s two billion) is 30.9, so it takes about 31 iterations to knock this range down to 1.</p>
<p class="indent">Binary search is an example of a <em>logarithmic-time</em> algorithm. We therefore say that it’s <em>O</em>(log <em>m</em>). (You’d ordinarily use <em>n</em> here instead of <em>m</em>, but we’re going to use <em>n</em> for something else later in this section.) To reduce a range to 1, <em>m</em> is the initial width of the range. However, in Feeding Ants, we needed to go further, obtaining four decimal digits of accuracy. What is <em>m</em> there?</p>
<p class="indent">It’s time to come clean on how we used binary search in Feeding Ants: we do more than log<sub>2</sub> 2,000,000,000 iterations of binary search, because we don’t stop when the width of the range is 1. Instead, we stop once we’ve achieved four digits of accuracy after the decimal point. Adding five zeros gives us the number of iterations that we do: log<sub>2</sub> 200,000,000,000,000 rounds up to 48. Only 48 iterations are needed to pull a solution with four decimal digits of accuracy from a bewildering range of trillions. That’s what binary search is made of.</p>
<p class="indent">On a tree of <em>n</em> nodes, the <code>can_feed</code> function in <a href="ch07.xhtml#ch07ex02">Listing 7-2</a> (Feeding Ants) takes linear time; that is, time proportional to <em>n</em>. We call that function log<sub>2</sub> <em>m</em> × 10<sup>4</sup> times, where <em>m</em> is the width of the range (two billion in the test cases). This is proportional to log <em>m</em> work. In total, then, we do <em>n</em> work a total of log <em>m</em> times. This is an <em>O</em>(<em>n</em> log <em>m</em>) algorithm. It is not quite linear, because of that extra log <em>m</em> factor, but still very fast.</p>
<h4 class="h4" id="sec102"><em>Determining Feasibility</em></h4>
<p class="noindent">What I like most about binary search algorithms is that determining whether a value is feasible often requires the use of some other type of algorithm. That is, on the outside we have binary search, but on the inside—to test if each value is feasible—we have something else. That something else could be anything. In Feeding Ants, it was a tree search. In our next problem, it will be a greedy algorithm. In our third problem, it will be a dynamic-programming algorithm. We won’t see one in this book, but there are problems where checking feasibility requires running a graph algorithm. That stuff you’ve learned in the previous chapters will all be in play again.</p>
<p class="indent">Determining feasibility often requires considerable creativity (just hopefully not as much creativity as needed for finding optimality!).</p>
<h4 class="h4" id="sec103"><em>Searching a Sorted Array</em></h4>
<p class="noindent">If you were familiar with binary search prior to reading this chapter, odds are that it was in the context of searching a sorted array. A typical scenario is that we are given an array <code>a</code> and a value <code>v</code>, and we want to find the smallest index of <code>a</code> whose value is greater than or equal to <code>v</code>. For example, if we were given the array <code>{-5, -1, 15, 31, 78}</code> and <code>v</code> were 26, we’d return index <code>3</code>, because the value at index <code>3</code> (31) is the first one that’s greater than or equal to 26.</p>
<p class="indent">Why does binary search work here? Take a look at the two ingredients:</p>
<p class="block"><strong>Ingredient 1</strong>   Without a binary search, finding the optimal value would involve a costly scan through the array. Therefore, optimality is hard <span epub:type="pagebreak" id="page_243"/>to obtain, but feasibility is easy: if I give you an index <code>i</code>, you can tell me right away whether <code>a[i]</code> is greater than or equal to <code>v</code> just by comparing <code>a[i]</code> to <code>v</code>.</p>
<p class="block"><strong>Ingredient 2</strong>   Any values smaller than <code>v</code> come before any values that are greater than or equal to <code>v</code>—remember that <code>a</code> is sorted! That is, the infeasible values come before the feasible values.</p>
<p class="indent">It’s true that binary search can be used to find a suitable index in an array in logarithmic time; later, in <a href="ch10.xhtml">Chapter 10</a>, we’ll use it for that very purpose. But we solved Feeding Ants with binary search, with no such array in sight. Don’t restrict yourself to thinking about binary search only when you have an array to search. Binary search is far more flexible than that.</p>
<h3 class="h3" id="lev45">Problem 2: River Jump</h3>
<p class="noindent">We’ll now see a problem in which we need a greedy algorithm to determine feasibility.</p>
<p class="indent">This is POJ problem <code>3258</code>.</p>
<h4 class="h4" id="sec104"><em>The Problem</em></h4>
<p class="noindent">There’s a river of length <em>L</em> along which rocks have been placed. There’s a rock at Location 0 (the beginning of the river), a rock at Location <em>L</em> (the end of the river), and then <em>n</em> other rocks between these. For example, on a river of length 12, we might have rocks at the following locations: 0, 5, 8, and 12.</p>
<p class="indent">A cow begins on the first rock (Location 0), jumps from there to the second rock, jumps from the second rock to the third rock, and so on, until it gets to the rock at the end of the river (Location <em>L</em>). Its minimum jump distance is the minimum distance between any consecutive pair of rocks. In the above example, the minimum jump distance is 3, witnessed by the distance between the rocks at Locations 5 and 8.</p>
<p class="indent">Farmer John is bored by the short jumps made by the cow, so he wants to increase the minimum jump distance as much as possible. He can’t remove the rock at Location 0 or Location <em>L</em>, but he is able to remove <em>m</em> of the other rocks.</p>
<p class="indent">In the above example, suppose that Farmer John is able to remove one rock. His choice is then to remove the rock at Location 5 or Location 8. If he removes the rock at Location 5, the minimum jump distance is 4 (from Location 8 to Location 12). However, he shouldn’t do that, because if he removes the rock at Location 8, then he achieves a greater minimum jump distance of 5 (from Location 0 to Location 5).</p>
<p class="indent">Our task is to maximize the minimum jump distance that Farmer John can achieve by removing <em>m</em> rocks.</p>
<span epub:type="pagebreak" id="page_244"/>
<h5 class="h5">Input</h5>
<p class="noindent">The input contains one test case, consisting of the following lines:</p>
<ul>
<li class="noindent">A line containing the three integers <em>L</em> (the length of the river), <em>n</em> (the number of rocks, not including the rocks at the beginning and end), and <em>m</em> (the number of rocks that Farmer John can remove). <em>L</em> is between 1 and 1,000,000,000 (one billion), <em>n</em> is between 0 and 50,000, and <em>m</em> is between 0 and <em>n</em>.</li>
<li class="noindent"><em>n</em> lines, each giving the integer location of a rock. No two rocks will be at the same location.</li>
</ul>
<h5 class="h5">Output</h5>
<p class="noindent">Output the maximum achievable minimum jump distance. For the above example, we would output <code>5</code>.</p>
<p class="indent">The time limit for solving the test case is two seconds.</p>
<h4 class="h4" id="sec105"><em>A Greedy Idea</em></h4>
<p class="noindent">In <a href="ch03.xhtml">Chapter 3</a>, when solving the Moneygrubbers problem, we introduced the idea of a greedy algorithm. A greedy algorithm does what looks promising right now, with no regard to the long-term consequences of its choices. Such an algorithm is often easy to propose: just state the greedy rule that it uses to make its next choice. When solving the Moneygrubbers problem, for example, I proposed the greedy algorithm that chooses the option of cheapest cost per apple. That greedy algorithm was incorrect. That lesson is worth remembering: while it’s easy to propose a greedy algorithm, it’s not easy to find one that’s correct.</p>
<p class="indent">For two reasons, I didn’t dedicate a chapter of the book to greedy algorithms. First, they’re not as broadly applicable as other algorithm design approaches (such as dynamic programming). Second, when they do happen to work, it’s often for subtle, problem-specific reasons. I’ve been duped many times over the years by seemingly correct but ultimately flawed greedy algorithms. A careful proof of correctness is often required to distinguish between the ones that are right and the ones that only feel right.</p>
<p class="indent">Nevertheless, greedy algorithms did make a concealed—and this time correct—appearance in <a href="ch06.xhtml">Chapter 6</a> in the form of Dijkstra’s algorithm. Algorithmists generally classify Dijkstra’s algorithm as greedy. Once the algorithm declares that a node’s shortest path has been found, it never goes back on that decision. It commits, once and for all, and does not let future discoveries influence what it has done in the past.</p>
<p class="indent">Greedy algorithms are now going to reappear. When I was introduced to River Jump several years ago, my instinct was that I could use a greedy algorithm to solve it. I wonder if you’ll find the proposed algorithm as natural as I did. Here’s the greedy rule: find the two rocks that are closest together, remove the one that’s closest to its other neighbor rock, and repeat.</p>
<p class="indent">Let’s return to the example from the problem description. Here it is as a test case:</p>
<span epub:type="pagebreak" id="page_245"/>
<pre>12 2 1
5
8</pre>
<p class="indent">For convenience, here are the rock locations: 0, 5, 8, and 12. We’re allowed to remove one rock. The two rocks that are closest together are those at Locations 5 and 8, so the greedy rule will result in one of these being removed. The rock at Location 8 is a distance of 4 from its neighbor to the right; the rock at Location 5 is a distance of 5 from its neighbor to the left. Therefore, the greedy algorithm removes the rock at Location 8. It works correctly in this example.</p>
<p class="indent">Let’s throw a bigger example in here and see what the greedy algorithm does. Suppose that the river has a length of 12 and we’re allowed to remove two rocks. Here’s the test case:</p>
<pre>12 4 2
1
3
8
9</pre>
<p class="indent">The rock locations are 0, 1, 3, 8, 9, and 12. What will the greedy algorithm do? The rocks that are closest together are the ones at Locations 0 and 1 and those at Locations 8 and 9. We’ll have to choose one pair—let’s choose 0 and 1. Since removing the rock at Location 0 is not allowed, we remove the rock at Location 1. The remaining rock locations are 0, 3, 8, 9, and 12.</p>
<p class="indent">Now the closest rocks are at Locations 8 and 9. The distance between 9 and 12 is less than the distance between 8 and 3, so the greedy algorithm removes the rock at Location 9. We’re left with 0, 3, 8, and 12. The minimum jump distance here, and the correct answer, is 3. The greedy algorithm wins again.</p>
<p class="indent">Isn’t that right? Keep knocking off the smallest distance between two rocks. How could we possibly do better than that? The greedy algorithm charms.</p>
<p class="indent">Sadly, the greedy algorithm is not correct. I encourage you to try to come up with a counterexample before I spoil it in the next paragraph.</p>
<p class="indent">Here’s a counterexample:</p>
<pre>12 4 2
2
4
5
8</pre>
<p class="indent">We’re allowed to remove two rocks. The rock locations are 0, 2, 4, 5, 8, and 12. The greedy rule identifies the rocks at Locations 4 and 5 as the closest rocks. It will remove the rock at Location 4, since the distance between <span epub:type="pagebreak" id="page_246"/>4 and 2 is less than the distance between 5 and 8. Here’s what’s left: 0, 2, 5, 8, and 12.</p>
<p class="indent">Now the greedy rule identifies the rocks at Locations 0 and 2 as the closest pair. It isn’t allowed to remove the rock at 0, so it removes the rock at 2. We’re left with 0, 5, 8, and 12. That’s a minimum jump distance of 3. Here we have a mistake made by the greedy algorithm, because the maximum achievable minimum jump distance is 4. To see this, rather than remove the rocks at Locations 2 and 4, remove the ones at Locations 2 and 5. That leaves us with 0, 4, 8, and 12.</p>
<p class="indent">What went wrong? By removing the rock at Location 4 as its first move, the greedy algorithm creates a situation involving a jump distance of 2 and a jump distance of 3. It can only fix one of those two with its second move, so it has no chance of producing a minimum jump distance of anything greater than 3.</p>
<p class="indent">I don’t know a greedy algorithm that directly solves this problem. Like Feeding Ants, this is a tough one to solve head-on. Fortunately, we don’t have to.</p>
<h4 class="h4" id="sec106"><em>Testing Feasibility</em></h4>
<p class="noindent">In “Binary Search” on <a href="ch07.xhtml#lev44">page 240</a>, I offered two signals that point to a binary search solution: that it’s easier to test feasibility than produce optimality and that the search space transitions from infeasible to feasible (or feasible to infeasible). We’ll see that the River Jump problem passes on both counts.</p>
<p class="indent">Instead of solving for the optimal solution outright, let’s solve for a different question: Is it possible to achieve a minimum jump distance of at least <em>d</em>? If we can nail this, then we can use binary search to find the largest feasible value of <em>d</em>.</p>
<p class="indent">Here’s the test case that ended the previous subsection:</p>
<pre>12 4 2
2
4
5
8</pre>
<p class="indent">We’re allowed to remove two rocks. The rock locations are 0, 2, 4, 5, 8, and 12.</p>
<p class="indent">Here’s a question: What is the minimum number of rock removals that are needed to achieve a minimum jump distance of at least 6? Let’s work from left to right and check. The rock at Location 0 has to stay—that’s spelled out in the problem description. It’s then evident that we have no choice of what to do with the rock at Location 2: we must remove it. If we didn’t, then the distance between the rocks at Locations 0 and 2 would be less than 6. So, one rock is removed. The remaining rocks are at 0, 4, 5, 8, and 12.</p>
<p class="indent">Now, consider the rock at Location 4—do we keep it or remove it? Again, we’re forced to remove it. If we keep it, then the rocks at Locations 0 and 4 <span epub:type="pagebreak" id="page_247"/>would be closer together than 6. That’s our second removal, and we’re left with rocks at 0, 5, 8, and 12.</p>
<p class="indent">The rock at Location 5 has to be removed, too, because it’s only a distance of 5 from the 0 rock. That’s our third removal, leaving us with rocks at 0, 8, and 12.</p>
<p class="indent">We have to remove the rock at Location 8, too! It’s far enough from Location 0 but too close to Location 12. That’s our fourth removal, ultimately leaving us with just two rocks at 0 and 12.</p>
<p class="indent">So it takes four removals to achieve a minimum jump distance of at least 6, but we’re only allowed to remove two rocks. As such, 6 is not a feasible solution. It’s too big.</p>
<p class="indent">Is 3 a feasible solution? That is, can we achieve a minimum jump distance of at least 3 by removing two rocks? Let’s see.</p>
<p class="indent">The rock at Location 0 stays. The rock at Location 2 has to go. That’s our first removal, and it leaves us with this: 0, 4, 5, 8, and 12.</p>
<p class="indent">The rock at Location 4 can stay: it’s more than a distance of 3 from Location 0. The rock at Location 5, though, has to go, because it’s too close to the rock at Location 4. That’s our second removal, giving us this: 0, 4, 8, and 12.</p>
<p class="indent">The rock at Location 8 is fine: it’s far enough away from the rocks at Locations 4 and 12. We’re done: it took us only two removals to achieve a minimum jump distance of at least 3. So, 3 is feasible.</p>
<p class="indent">We seem to be homing in on a greedy algorithm for checking feasibility. The rule is this: consider each rock in order, and remove it if it’s too close to the previously kept rock. Also check the rightmost rock that we kept, and remove it if it’s too close to the end of the river. Then, count the number of rocks that we removed; that count tells us whether the proposed minimum jump distance is feasible given the number of rocks we’re allowed to remove. (To be clear, this is a proposed greedy algorithm for checking feasibility of a specified jump distance, not for finding the optimal solution in one shot.)</p>
<p class="indent">The code for this algorithm is in <a href="ch07.xhtml#ch07ex04">Listing 7-4</a>.</p>
<pre>int can_make_min_distance(int distance, int rocks[], int num_rocks,
                          int num_remove, int length) {
  int i;
  int removed = 0, prev_rock_location = 0, cur_rock_location;
  if (length &lt; distance)
    return 0;
  for (i = 0; i &lt; num_rocks; i++) {
    cur_rock_location = rocks[i];
 <span class="ent">➊</span> if (cur_rock_location - prev_rock_location &lt; distance)
      removed++;
    else
      prev_rock_location = cur_rock_location;
  }
<span class="ent">➋</span> if (length - prev_rock_location &lt; distance)
     removed++;
<span epub:type="pagebreak" id="page_248"/>   return removed &lt;= num_remove;
}</pre>
<p class="excap" id="ch07ex04"><em>Listing 7-4: Testing the feasibility of the jump distance</em></p>
<p class="indent">The function has five parameters:</p>
<p class="block"><span class="codestrong">distance</span>   The minimum jump distance whose feasibility we’re testing</p>
<p class="block"><span class="codestrong">rocks</span>   An array giving the location of each rock, not including the rocks at the beginning and end of the river</p>
<p class="block"><span class="codestrong">num_rocks</span>   The number of rocks in the <code>rocks</code> array</p>
<p class="block"><span class="codestrong">num_remove</span>   The number of rocks that we’re allowed to remove</p>
<p class="block"><span class="codestrong">length</span>   The length of the river</p>
<p class="indent">The function returns <code>1</code> (true) if <code>distance</code> is a feasible solution and returns <code>0</code> otherwise.</p>
<p class="indent">The variable <code>prev_rock_location</code> tracks the location of the most recent rock that we’ve kept. Inside the <code>for</code> loop, <code>cur_rock_location</code> holds the location of the rock that we’re currently considering. We then have our crucial test to determine whether to keep or remove the current rock <span class="ent">➊</span>. If the current rock is too close to the previous rock, then we remove the current rock and increase the number of removals by one. Otherwise, we keep the current rock and update <code>prev_rock_location</code> accordingly.</p>
<p class="indent">When the loop terminates, we’ve counted the number of rocks that we must remove. Well . . . almost. We still need to check whether the rightmost rock that we’ve kept is too close to the end of the river <span class="ent">➋</span>. If it is, then we remove that rock. (Don’t worry about the possibility of removing the rock at Location 0. If we really have removed all the rocks, then <code>prev_rock_location</code> will be 0. However, <code>length - 0 &lt; distance</code> cannot be true; if it were, then we would have returned in the <code>if</code> statement at the start of the function.)</p>
<p class="indent">Now we have no rocks within the minimum jump distance of each other, and we have not removed rocks unnecessarily. How could we possibly do better than that? The greedy algorithm charms . . . but here we go again. The last time this occurred, in “A Greedy Idea” on <a href="ch07.xhtml#sec105">page 244</a>, the greedy algorithm turned out to be incorrect. Don’t be convinced by a couple of examples where things happen to work out. Don’t let me sweet-talk you into believing that everything is okay.</p>
<p class="indent">Before moving on, I’d like to give a fairly precise argument for why this greedy algorithm is correct. Specifically, I’ll show that it removes the minimum number of rocks required to achieve a minimum jump distance of at least <em>d</em>. I’ll assume that <em>d</em> is at most the length of the river; otherwise, the greedy algorithm immediately and correctly determines that a minimum jump distance of <em>d</em> is infeasible.</p>
<p class="indent">For each rock from left to right, our greedy algorithm decides whether to keep the rock or remove it. Our goal will be to show that it matches, step for step, what an optimal solution does. When the greedy algorithm decides to keep a rock, we’ll show that an optimal solution keeps that rock, <span epub:type="pagebreak" id="page_249"/>too. When the greedy algorithm decides to remove a rock, we’ll show that an optimal solution removes that rock, too. If the greedy algorithm does exactly what an optimal solution does, then what we get from it must be correct. In this example, “optimal” will be used to refer to an optimal solution. For each rock, we have four possibilities: greedy and optimal both remove the rock, greedy and optimal both keep the rock, greedy removes it but optimal keeps it, and greedy keeps it but optimal removes it. We have to show that the third and fourth cases cannot actually occur.</p>
<p class="indent">Before we proceed to the four cases, consider again removing two rocks from these rock locations: 0, 2, 4, 5, 8, and 12. When asked whether it’s possible to achieve a minimum jump distance of at least 3, we have seen that greedy will remove the rocks at Locations 2 and 5, leaving us with 0, 4, 8, and 12. So we might expect that the optimal solution is also to remove the same two rocks. Although that is optimal, another optimal solution is to remove the rocks at Locations 2 and 4, resulting in these rocks: 0, 5, 8, and 12. That’s another way to get a minimum distance of at least 3 by removing two rocks, and it’s as good as what the greedy algorithm produces. Rather than match <em>the</em> optimal solution, we’ll be just as happy matching <em>an</em> optimal solution. We don’t care which one greedy matches: all optimal solutions are equally optimal.</p>
<p class="indent">We have some optimal solution <em>S</em> that we want greedy to match. Greedy starts running, and for some time there are no discrepancies: it does whatever <em>S</em> does. Greedy at least does the right thing for the rock at Location 0: that one has to stay, no matter what.</p>
<p class="indent">Greedy is thus looking at the rocks from left to right, doing the right stuff, keeping rocks and removing rocks just like optimal solution <em>S</em> . . . and then, boom, greedy and <em>S</em> disagree on what to do with some rock. We think about the <em>first</em> rock on which greedy and <em>S</em> disagree.</p>
<p class="noindent1"><strong>Greedy removes it, but optimal keeps it.</strong></p>
<p class="block95">The greedy algorithm only removes a rock when it’s too close to another rock. If greedy removes a rock because it’s less than <em>d</em> from the rock to the left, then <em>S</em> must have removed the rock, too. Because this is the first disagreement, <em>S</em> includes exactly the same rocks to the left as greedy. So if <em>S</em> did not remove the rock, then it would have two rocks within a distance of less than <em>d</em>. However, that can’t happen: <em>S</em> is an optimal (and necessarily feasible) solution where all distances between rocks are at least <em>d</em>. We can conclude that <em>S</em> really does remove the rock, agreeing with greedy. Similar reasoning shows that, if greedy removes a rock because it’s too close to the end of the river, then <em>S</em> must remove it, too.</p>
<p class="noindent1"><strong>Greedy keeps it, but optimal removes it.</strong></p>
<p class="block95ab">We’re not going to be able to make greedy and <em>S</em> match here, but that’s okay, because we’ll be able to form a new optimal solution <em>U</em> that keeps this rock. Let <em>r</em> be the current rock; the one that greedy keeps and <em>S</em> removes. Think about a new set of rocks <em>T</em> that has exactly the same rocks as <em>S</em> plus rock <em>r</em>. Therefore, <em>T</em> removes one fewer rock than <em>S</em>. Because of this, <em>T</em> can’t be a feasible solution. If it were, then it would be better (by one rock) than <em>S</em>, contradicting the fact that <em>S</em> is an optimal solution. <span epub:type="pagebreak" id="page_250"/>Since the only difference between <em>S</em> and <em>T</em> is that <em>T</em> has rock <em>r</em>, it must be <em>r</em> that causes <em>T</em> to be infeasible. Therefore, in <em>T</em>, <em>r</em> must be closer than <em>d</em> to rock <em>r</em><sub>2</sub> to its right. We know that <em>r</em><sub>2</sub> can’t be the rock at the end of the river, because then greedy wouldn’t have kept <em>r</em> (as <em>r</em> would be too close to the end of the river). So <em>r</em><sub>2</sub> is some rock that is allowed to be removed.</p>
<p class="blockdd">Now, think about another new set of rocks <em>U</em> that has exactly the same rocks as <em>T</em> except that it doesn’t have <em>r</em><sub>2</sub>. We can say that <em>U</em> has the same number of rocks as <em>S</em>: we added one rock <em>r</em> to <em>S</em> to get <em>T</em>, and we removed one rock <em>r</em><sub>2</sub> from <em>T</em> to get <em>U</em>. Also, <em>U</em> has no rocks that are less than a distance of <em>d</em> apart, because it doesn’t include the offending rock <em>r</em><sub>2</sub>. That is, <em>U</em> is an optimal solution, just like <em>S</em>. Crucially, <em>U</em> contains rock <em>r</em>! So greedy agrees with optimal solution <em>U</em> to include <em>r</em>.</p>
<p class="indent">Let’s give our feasibility tester a whirl before we continue. Here’s how to call it on the example that we used throughout this section:</p>
<pre>int main(void) {
  int rocks[4] = {2, 4, 5, 8};
  printf("%d\n", can_make_min_distance(6, rocks, 4, 2, 12));
  return 0;
}</pre>
<p class="indent">The code above asks whether it’s possible to achieve a minimum jump distance of at least 6 by removing two rocks. The answer is “no,” so you should see <code>0</code> (false) as the output. Change the first argument from <code>6</code> to <code>3</code>, and now you’re asking whether a minimum jump distance of at least 3 is feasible. Run the program again, and you should see <code>1</code> (true).</p>
<p class="indent">Excellent: now we have a way to check feasibility. It’s time to bring out binary search to give us optimality.</p>
<h4 class="h4" id="sec107"><em>Searching for a Solution</em></h4>
<p class="noindent">To use binary search, let’s adapt the code from <a href="ch07.xhtml#ch07ex03">Listing 7-3</a>. In Feeding Ants, we had to achieve four digits of accuracy after the decimal point. Here, however, we’re looking to optimize the minimum jump distance, and that’s guaranteed to be an integer value because all rocks are at integer locations. So we’ll stop when <code>high</code> and <code>low</code> are within one, rather than within the four decimal digits. <a href="ch07.xhtml#ch07ex05">Listing 7-5</a> gives the new code.</p>
<pre>// bugged!
void solve(int rocks[], int num_rocks,
           int num_remove, int length) {
  int low, high, mid;
  low = 0;
  high = length;
  while (high - low &gt; 1) {
    mid = (low + high) / 2;
 <span class="ent">➊</span> if (can_make_min_distance(mid, rocks, num_rocks, num_remove, length))
   <span class="ent">➋</span> low = mid;
<span epub:type="pagebreak" id="page_251"/>    else
   <span class="ent">➌</span> high = mid;
  }
  printf("%d\n", high);
}</pre>
<p class="excap" id="ch07ex05"><em>Listing 7-5: Searching for the optimal solution (bugged!)</em></p>
<p class="indent">On each iteration, we calculate the midpoint <code>mid</code> of the range, and we use our helper function to test its feasibility <span class="ent">➊</span>.</p>
<p class="indent">If <code>mid</code> is feasible, then everything less than <code>mid</code> is also feasible, so we update <code>low</code> to cut off the low half of the range <span class="ent">➋</span>. Notice the contrast to <a href="ch07.xhtml#ch07ex03">Listing 7-3</a>: there, a feasible <code>mid</code> means that everything greater than <code>mid</code> is feasible, so we cut off the high half of the range instead.</p>
<p class="indent">If <code>mid</code> is infeasible, then everything greater than <code>mid</code> is also infeasible, so we update <code>high</code> to cut off the high half of the range <span class="ent">➌</span>.</p>
<p class="indent">Unfortunately, this binary search is not correct. To see why, run it on this test case:</p>
<pre>12 4 2
2
4
5
8</pre>
<p class="indent">You should get an output of <code>5</code>, but the optimal solution is in fact <code>4</code>.</p>
<p class="indent">Ahh, I know what to do. Let’s change the <code>printf</code> call at the bottom to output <code>low</code> instead of <code>high</code>. When the loop terminates, <code>low</code> will be one less than <code>high</code>, so this change will result in an output of <code>4</code> instead of <code>5</code>. The new code is given in <a href="ch07.xhtml#ch07ex06">Listing 7-6</a>.</p>
<pre>// bugged!
void solve(int rocks[], int num_rocks,
           int num_remove, int length) {
  int low, high, mid;
  low = 0;
  high = length;
  while (high - low &gt; 1) {
    mid = (low + high) / 2;
    if (can_make_min_distance(mid, rocks, num_rocks, num_remove, length))
      low = mid;
    else
      high = mid;
  }
  printf("%d\n", low);
}</pre>
<p class="excap" id="ch07ex06"><em>Listing 7-6: Searching for the optimal solution (still bugged!)</em></p>
<span epub:type="pagebreak" id="page_252"/>
<p class="indent">That fixes the problematic test case, but now we get this test case wrong:</p>
<pre>12 0 0</pre>
<p class="indent">This is a perfectly valid test case, if a little strange: the length of the river is 12, and there are no rocks. The maximum achievable minimum jump distance is 12, but our binary search returns <code>11</code> on this example. Again, we are off by one.</p>
<p class="indent">Binary search is legendarily difficult to implement correctly. Should that <code>&gt;</code> be a <code>&gt;=</code>? Should that be a <code>mid</code> or a <code>mid + 1</code>? Do we want <code>low + high</code> or <code>low + high + 1</code>? If you keep on with binary search problems, you’ll grapple with all of this eventually. I don’t know any other algorithm with the bug-density potential of binary search.</p>
<p class="indent">Let’s be a little more careful for our next attempt. Suppose we knew at all times that <code>low</code> and everything smaller than <code>low</code> are feasible and that <code>high</code> and everything larger than <code>high</code> are infeasible. Such a claim is called an <em>invariant</em>, which simply means that it’s always true as the code runs.</p>
<p class="indent">When the loop terminates, <code>low</code> will be one less than <code>high</code>. If we’ve managed to maintain our invariant, then we know that <code>low</code> is feasible. We also know that nothing greater than <code>low</code> can be feasible: <code>high</code> is next, and the invariant tells us that <code>high</code> is infeasible. So <code>low</code> will be the maximum feasible value, and we’ll need to output <code>low</code>.</p>
<p class="indent">However, in all of this we assume that we can make this invariant true at the beginning of the code and keep it true at all times thereafter.</p>
<p class="indent">Let’s start with the code above the loop. This code does <em>not</em> necessarily make the invariant true:</p>
<pre>low = 0;
high = length;</pre>
<p class="indent">Is <code>low</code> feasible? Certainly! A minimum jump distance of at least 0 is always achievable, because every jump has a nonzero distance. Is <code>high</code> infeasible? Well, it could be, but what if we can jump the whole river after we remove the allowed number of rocks? Then <code>length</code> is feasible, and our invariant is broken. Here’s a better initialization:</p>
<pre>low = 0;
high = length + 1;</pre>
<p class="indent">Now <code>high</code> certainly isn’t feasible: we can’t achieve a minimum jump distance of <code>length + 1</code> when the river is only of length <code>length</code>.</p>
<p class="indent">We next have to figure out what to do for the two possibilities in the loop. If <code>mid</code> is feasible, then we can set <code>low = mid</code>. The invariant is okay, because <code>low</code> and everything to its left are feasible, and, if <code>mid</code> is not feasible, then we can set <code>high = mid</code>. The invariant is again okay, because <code>high</code> and everything to its right are infeasible. Thus, in both cases, we maintain the invariant.</p>
<span epub:type="pagebreak" id="page_253"/>
<p class="indent">We now see that nothing in the code invalidates the invariant, and so we’re safe to output <code>low</code> when the loop terminates. The correct code is given in <a href="ch07.xhtml#ch07ex07">Listing 7-7</a>.</p>
<pre>void solve(int rocks[], int num_rocks,
           int num_remove, int length) {
  int low, high, mid;
  low = 0;
  high = length + 1;
  while (high - low &gt; 1) {
    mid = (low + high) / 2;
    if (can_make_min_distance(mid, rocks, num_rocks, num_remove, length))
      low = mid;
    else
      high = mid;
  }
  printf("%d\n", low);
}</pre>
<p class="excap" id="ch07ex07"><em>Listing 7-7: Searching for the optimal solution</em></p>
<p class="indent">For a river of length <em>L</em>, we’re calling <code>can_make_min_distance</code> a total of log <em>L</em> times. If we have <em>n</em> rocks, then <code>can_make_min_distance</code> (<a href="ch07.xhtml#ch07ex04">Listing 7-4</a>) takes <em>O</em>(<em>n</em>) time. Therefore, our solution to this problem is an <em>O</em>(<em>n</em> log <em>L</em>) algorithm.</p>
<h4 class="h4" id="sec108"><em>Reading the Input</em></h4>
<p class="noindent">We’re nearly there. All that’s left is to read the input and call <code>solve</code>. The code is provided in <a href="ch07.xhtml#ch07ex08">Listing 7-8</a>.</p>
<pre>#define MAX_ROCKS 50000
 
int compare(const void *v1, const void *v2) {
  int num1 = *(const int *)v1;
  int num2 = *(const int *)v2;
  return num1 - num2;
}
 
int main(void) {
  static int rocks[MAX_ROCKS];
  int length, num_rocks, num_remove, i;
  scanf("%d%d%d", &amp;length, &amp;num_rocks, &amp;num_remove);
  for (i = 0; i &lt; num_rocks; i++)
    scanf("%d", &amp;rocks[i]);
<span class="ent">➊</span> qsort(rocks, num_rocks, sizeof(int), compare);
  solve(rocks, num_rocks, num_remove, length);
<span epub:type="pagebreak" id="page_254"/>  return 0;
}</pre>
<p class="excap" id="ch07ex08"><em>Listing 7-8: The</em> <span class="codeitalic1">main</span> <em>function for reading the input</em></p>
<p class="indent">We’ve been analyzing this problem by thinking about locations of rocks from left to right, that is, from smallest location to largest location. However, the rocks could come from the input in any order. Nothing in the problem description guarantees that they’ll be sorted.</p>
<p class="indent">It’s been a while, but we did use <code>qsort</code> to sort nodes in <a href="ch02.xhtml">Chapter 2</a> when solving the Descendant Distance problem. Sorting rocks is a little easier than sorting those nodes. Our comparison function <code>compare</code> takes pointers to two integers, and it returns the result of subtracting the second from the first. This leads to a negative integer if the first integer is smaller than the second, <code>0</code> if the two integers are equal, and a positive integer if the first integer is larger than the second. We use <code>qsort</code> with this comparison function to sort the rocks <span class="ent">➊</span>. We then call <code>solve</code> with the array of sorted rocks.</p>
<p class="indent">If you submit this solution to the judge, then you should see that all test cases pass.</p>
<h3 class="h3" id="lev46">Problem 3: Living Quality</h3>
<p class="noindent">So far in this chapter, we’ve seen two approaches to check feasibility: a recursive traversal of a tree and a greedy algorithm. Now, we’ll see an example where we’ll use ideas from dynamic programming (<a href="ch03.xhtml">Chapter 3</a>) to efficiently check feasibility.</p>
<p class="indent">This is the first problem in the book where we don’t read from standard input or write to standard output. We’ll write a function with a name specified by the judge. In lieu of standard input, we’ll use an array passed by the judge. In lieu of standard output, we’ll return the correct value from our function. This is rather nice: we won’t have to bother with <code>scanf</code> and <code>printf</code> at all!</p>
<p class="indent">Incidentally, this will also be our first problem from a world championship programming competition (IOI 2010). You’ve got this!</p>
<p class="indent">This is DMOJ problem <code>ioi10p3</code>.</p>
<h4 class="h4" id="sec109"><em>The Problem</em></h4>
<p class="noindent">A city consists of a rectangular grid of blocks. Each block is identified by its row and column coordinates. There are <em>r</em> rows numbered 0 to <em>r</em> – 1 from top to bottom and <em>c</em> columns numbered 0 to <em>c</em> – 1 from left to right.</p>
<p class="indent">Each block has been given a distinct <em>quality rank</em> between 1 and <em>rc</em>. For example, if we have seven rows and seven columns, then the ranks of each block will be some permutation of the numbers from 1 to 49. See <a href="ch07.xhtml#ch07tab1">Table 7-1</a> for an example city.<span epub:type="pagebreak" id="page_255"/></p>
<p class="tabcap" id="ch07tab1"><strong>Table 7-1:</strong> A Sample City</p>
<div class="bqparan">
<table class="allczzt">
<colgroup>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
</colgroup>
<thead>
<tr>
<th class="borderrb" style="vertical-align: top"> </th>
<th class="borderrb" style="vertical-align: top"><strong>0</strong></th>
<th class="borderrb" style="vertical-align: top"><strong>1</strong></th>
<th class="borderrb" style="vertical-align: top"><strong>2</strong></th>
<th class="borderrb" style="vertical-align: top"><strong>3</strong></th>
<th class="borderrb" style="vertical-align: top"><strong>4</strong></th>
<th class="borderrb" style="vertical-align: top"><strong>5</strong></th>
<th class="borderbb" style="vertical-align: top"><strong>6</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>0</strong></td>
<td class="borderrb" style="vertical-align: top">48</td>
<td class="borderrb" style="vertical-align: top">16</td>
<td class="borderrb" style="vertical-align: top">15</td>
<td class="borderrb" style="vertical-align: top">45</td>
<td class="borderrb" style="vertical-align: top">40</td>
<td class="borderrb" style="vertical-align: top">28</td>
<td class="borderbb" style="vertical-align: top">8</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>1</strong></td>
<td class="borderrb" style="vertical-align: top">20</td>
<td class="borderrb" style="vertical-align: top">11</td>
<td class="borderrb" style="vertical-align: top">36</td>
<td class="borderrb" style="vertical-align: top">19</td>
<td class="borderrb" style="vertical-align: top">24</td>
<td class="borderrb" style="vertical-align: top">6</td>
<td class="borderbb" style="vertical-align: top">33</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>2</strong></td>
<td class="borderrb" style="vertical-align: top">22</td>
<td class="borderrb" style="vertical-align: top">39</td>
<td class="borderrb" style="vertical-align: top">30</td>
<td class="borderrb" style="vertical-align: top">7</td>
<td class="borderrb" style="vertical-align: top">9</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderbb" style="vertical-align: top">18</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>3</strong></td>
<td class="borderrb" style="vertical-align: top">14</td>
<td class="borderrb" style="vertical-align: top">35</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">13</td>
<td class="borderrb" style="vertical-align: top">31</td>
<td class="borderrb" style="vertical-align: top">12</td>
<td class="borderbb" style="vertical-align: top">46</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>4</strong></td>
<td class="borderrb" style="vertical-align: top">32</td>
<td class="borderrb" style="vertical-align: top">37</td>
<td class="borderrb" style="vertical-align: top">21</td>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderrb" style="vertical-align: top">41</td>
<td class="borderrb" style="vertical-align: top">23</td>
<td class="borderbb" style="vertical-align: top">29</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>5</strong></td>
<td class="borderrb" style="vertical-align: top">42</td>
<td class="borderrb" style="vertical-align: top">49</td>
<td class="borderrb" style="vertical-align: top">38</td>
<td class="borderrb" style="vertical-align: top">10</td>
<td class="borderrb" style="vertical-align: top">17</td>
<td class="borderrb" style="vertical-align: top">47</td>
<td class="borderbb" style="vertical-align: top">5</td>
</tr>
<tr>
<td class="borderr" style="vertical-align: top"><strong>6</strong></td>
<td class="borderr" style="vertical-align: top">43</td>
<td class="borderr" style="vertical-align: top">4</td>
<td class="borderr" style="vertical-align: top">34</td>
<td class="borderr" style="vertical-align: top">25</td>
<td class="borderr" style="vertical-align: top">26</td>
<td class="borderr" style="vertical-align: top">27</td>
<td style="vertical-align: top">44</td>
</tr>
</tbody>
</table>
</div>
<p class="indent">The <em>median quality rank</em> of a rectangle is the quality rank such that half of the quality ranks in the rectangle are smaller and half are larger. For example, consider the five-row-by-three-column (5×3) rectangle in the top left of <a href="ch07.xhtml#ch07tab1">Table 7-1</a>. It consists of 15 quality ranks: 48, 16, 15, 20, 11, 36, 22, 39, 30, 14, 35, 2, 32, 37, and 21. The median quality rank is 22, because seven numbers are less than 22 and the other seven are greater.</p>
<p class="indent">We’ll be provided integers <em>h</em> and <em>w</em> that specify the height (number of rows) and width (number of columns) of candidate rectangles. Our task is to identify the minimum median quality rank of any rectangle with <em>h</em> rows and <em>w</em> columns. (In this problem, low-quality ranks correspond to high qualities; finding the minimum median quality rank therefore corresponds to finding a high-quality living area of the city.)</p>
<p class="indent">Let’s use (<em>x</em>, <em>y</em>) to refer to row <em>x</em>, column <em>y</em>. Suppose <em>h</em> is 5 and <em>w</em> is 3. Then, for the city in <a href="ch07.xhtml#ch07tab1">Table 7-1</a>, we would identify 13 as the minimum median quality rank. The rectangle whose median quality rank is 13 is the one whose top-left coordinate is (1, 3) and whose bottom-right coordinate is (5, 5).</p>
<h5 class="h5">Input</h5>
<p class="noindent">There’s nothing to read from standard input. Everything we need will come from the judge through function parameters. Here’s the signature for the function that we’ll write:</p>
<pre>int rectangle(int r, int c, int h, int w, int q[3001][3001])</pre>
<p class="indent">Here, <code>r</code> and <code>c</code> are the numbers of rows and columns in the city, respectively. Similarly, <code>h</code> and <code>w</code> are the numbers of rows and columns in the candidate rectangles, respectively; <code>h</code> will be at most <code>r</code> and <code>w</code> will be at most <code>c</code>. It’s also guaranteed that <code>h</code> and <code>w</code> will be odd numbers. (Why is that? Since <span epub:type="pagebreak" id="page_256"/>multiplying two odd numbers results in an odd number, <em>hw</em>, the number of blocks in a candidate rectangle, will be an odd number. The median is precisely defined in this case: the quality rank such that half of the remaining quality ranks are smaller and the other half are larger. What if we had an even number of quality ranks, such as the four ranks 2, 6, 4, and 5? What would the median be? We’d have to choose between 4 and 5. The problem author has spared us this choice.)</p>
<p class="indent">The final parameter <code>q</code> gives the quality rank of the blocks. For example, <code>q[2][3]</code> gives the quality of the block at row 2, column 3. Notice how the dimensions on <code>q</code> tell us the maximum number of rows and columns in the city: 3,001, in each case.</p>
<h5 class="h5">Output</h5>
<p class="noindent">We won’t produce anything on standard output. Instead, from the <code>rectangle</code> function just described, we’ll return the minimum median quality rank.</p>
<p class="indent">The time limit for solving the test case is 4.5 seconds.</p>
<h4 class="h4" id="sec110"><em>Sorting Every Rectangle</em></h4>
<p class="noindent">It’s hard to make much progress toward an efficient solution that doesn’t use binary search, but we’ll try here, anyway. It’ll give us practice looping through all of the candidate rectangles. We’ll get to binary search in the next subsection.</p>
<p class="indent">To start, we need a couple of constants and a type definition:</p>
<pre>#define MAX_ROWS 3001
#define MAX_COLS 3001
 
typedef int board[MAX_ROWS][MAX_COLS];</pre>
<p class="indent">Much as we did in <a href="ch05.xhtml">Chapter 5</a>, we’ll use <code>board</code> whenever we need a two-dimensional array of the correct size.</p>
<p class="indent">Suppose you are given the top-left and bottom-right coordinates of a rectangle and asked to determine the median quality rank of its blocks. How can you do it?</p>
<p class="indent">Sorting can help. Sort the quality ranks from smallest to largest, and then pick out the element at the middle index. For example, say we have these 15 quality ranks again: 48, 16, 15, 20, 11, 36, 22, 39, 30, 14, 35, 2, 32, 37, and 21. If we sort them, we get 2, 11, 14, 15, 16, 20, 21, 22, 30, 32, 35, 36, 37, 39, and 48. There are 15 quality ranks, so all we do is take the eighth one, 22, and that’s our median.</p>
<p class="indent">There are slightly faster algorithms for finding the median directly, without taking the scenic route through sorting. Sorting gives us an algorithm that takes <em>O</em>(<em>n</em> log <em>n</em>) time to find the median; there’s a sophisticated <em>O</em>(<em>n</em>) algorithm for finding the median that I encourage you to look up if you are interested.</p>
<span epub:type="pagebreak" id="page_257"/>
<p class="indent">We won’t go there, though. What we do in this subsection is going to be so slow that no improved algorithm for finding the median is going to be of benefit.</p>
<p class="indent"><a href="ch07.xhtml#ch07ex09">Listing 7-9</a> gives the code for finding the median of a given rectangle.</p>
<pre> int compare(const void *v1, const void *v2) {
   int num1 = *(const int *)v1;
   int num2 = *(const int *)v2;
   return num1 - num2;
 }
 
 int median(int top_row, int left_col, int bottom_row, int right_col,
            board q) {
   static int cur_rectangle[MAX_ROWS * MAX_COLS];
   int i, j, num_cur_rectangle;
   num_cur_rectangle = 0;
   for (i = top_row; i &lt;= bottom_row; i++)
     for (j = left_col; j &lt;= right_col; j++) {
       cur_rectangle[num_cur_rectangle] = q[i][j];
       num_cur_rectangle++;
     }
<span class="ent">➊</span> qsort(cur_rectangle, num_cur_rectangle, sizeof(int), compare);
   return cur_rectangle[num_cur_rectangle / 2];
 }</pre>
<p class="excap" id="ch07ex09"><em>Listing 7-9: Finding the median of a given rectangle</em></p>
<p class="indent">The first four parameters of <code>median</code> delimit the rectangle by specifying the top-left row and column and the bottom-right row and column. The final parameter, <code>q</code>, holds the quality ranks. We use the one-dimensional array <code>cur_rectangle</code> to accumulate the quality ranks for the rectangle. The nested <code>for</code> loops go through each block in the rectangle and add the block’s quality rank to <code>cur_rectangle</code>. After corralling the quality ranks, we’re all set to feed them to <code>qsort</code> <span class="ent">➊</span>. Then we know exactly where the median is—it’s in the middle of the array—so we just return it.</p>
<p class="indent">With that function in hand, we can now proceed to loop through each candidate rectangle, keeping track of the one whose median quality rank is the smallest. Check out <a href="ch07.xhtml#ch07ex010">Listing 7-10</a> for the code.</p>
<pre> int rectangle(int r, int c, int h, int w, board q) {
   int top_row, left_col, bottom_row, right_col;
<span class="ent">➊</span> int best = r * c + 1;
   int result;
   for (top_row = 0; top_row &lt; r - h + 1; top_row++)
     for (left_col = 0; left_col &lt; c - w + 1; left_col++) {
   <span class="ent">➋</span> bottom_row = top_row + h - 1;
   <span class="ent">➌</span> right_col = left_col + w - 1;
   <span class="ent">➍</span> result = median(top_row, left_col, bottom_row, right_col, q);
      if (result &lt; best)
<span epub:type="pagebreak" id="page_258"/>      best = result;
  }
  return best;
}</pre>
<p class="excap" id="ch07ex010"><em>Listing 7-10: Finding the smallest median of all candidate rectangles</em></p>
<p class="indent">The variable <code>best</code> tracks the best (smallest) median that we’ve found so far. We start it off with a big value, bigger than the median of any candidate rectangle <span class="ent">➊</span>. There’s no way for a rectangle to have a median of <code>r * c + 1</code>: that would mean that half of its quality ranks were larger than <code>r * c</code>, but by the problem description, <em>no</em> quality ranks can be larger than <code>r * c</code>. The nested <code>for</code> loops consider each possible top-left coordinate for a rectangle. That gives us the top row and left column, but we also need the bottom row and right column in order to call <code>median</code>. To calculate the bottom row, we take the top row, add <code>h</code> (the number of rows in the candidate rectangles), and then subtract 1 <span class="ent">➋</span>. It’s really easy to make an off-by-one error here, but that <code>- 1</code> is required. If the top row is 4 and <code>h</code> is <code>2</code>, then we want the bottom row to be 4 + 2 – 1 = 5; if we made the bottom row be 4 + 2 = 6, then we’d have a rectangle with three rows instead of the desired two. We use a similar calculation to find the right column <span class="ent">➌</span>. With the four coordinates available, we call <code>median</code> to calculate the median of the rectangle <span class="ent">➍</span>. The remainder of the code updates <code>best</code> if we’ve found a better median.</p>
<p class="indent">We’re done with this solution. There’s no <code>main</code> function, because the judge calls <code>rectangle</code> directly, but the absence of <code>main</code> means that we can’t test our code on our own computer. For testing purposes, you can introduce a <code>main</code> function, but don’t keep that in there when you submit to the judge.</p>
<p class="noindent">Here’s an example <code>main</code> function on the city in <a href="ch07.xhtml#ch07tab1">Table 7-1</a>:</p>
<pre>int main(void) {
static board q = {{48, 16, 15, 45, 40, 28, 8},
                  {20, 11, 36, 19, 24, 6, 33},
                  {22, 39, 30, 7, 9, 1, 18},
                  {14, 35, 2, 13, 31, 12, 46},
                  {32, 37, 21, 3, 41, 23, 29},
                  {42, 49, 38, 10, 17, 47, 5},
                  {43, 4, 34, 25, 26, 27, 44}};
  int result = rectangle(7, 7, 5, 3, q);
  printf("%d\n", result);
  return 0;
}</pre>
<p class="indent">You should see an output of <code>13</code> when you run the program.</p>
<p class="indent">Feel free to submit our solution, minus the <code>main</code> function, to the judge. It’ll pass a few test cases but time-out on the rest.</p>
<p class="indent">To get a feel for why our code is so slow, let’s focus on the case where <em>r</em> and <em>c</em> are both the same number <em>m</em>. To exhibit the worst case, take <em>h</em> and <em>w</em> to both be <em>m</em>/2. (We don’t want the rectangles to be too big, because then there won’t be many rectangles; and we don’t want them to be too small, <span epub:type="pagebreak" id="page_259"/>because then each is easy to process.) The slowest part of our <code>median</code> function is the call to <code>qsort</code>. It’s given an array with <em>m</em>/2 × <em>m</em>/2 = <em>m</em><sup>2</sup>/4 values. On an array of <em>n</em> values, <code>qsort</code> takes <em>n</em> log <em>n</em> steps. Replacing <em>n</em> by <em>m</em><sup>2</sup>/4 gives (<em>m</em><sup>2</sup>/4) log(<em>m</em><sup>2</sup>/4) = <em>O</em>(<em>m</em><sup>2</sup> log <em>m</em>). So we’re already slower than quadratic—and all we’ve done is calculate the median for one rectangle! The <code>rectangle</code> function calls <code>median</code> a total of <em>m</em><sup>2</sup>/4 times, so our total runtime is <em>O</em>(<em>m</em><sup>4</sup> log <em>m</em>). That power of 4 relegates this solution to only very small problem instances.</p>
<p class="indent">There are two bottlenecks here. The first is sorting each rectangle. The second is doing a lot of work from scratch for each rectangle. Using a binary search disposes the former, and a neat dynamic-programming trick disposes the latter.</p>
<h4 class="h4" id="sec111"><em>Using Binary Search</em></h4>
<p class="noindent">Why should we be optimistic that binary search will lead to a speedup here? First, in the previous subsection, we saw that finding optimality head-on is a costly endeavor; our approach that piggybacked on sorting was slightly slower than an <em>m</em><sup>4</sup> algorithm. Second, we have another example of a problem where all infeasible solutions come first and are followed by all feasible solutions. Suppose I tell you that there is no rectangle with median quality rank of at most five. Then there’d be no point looking for rectangles with median quality five, or four, or three, or anything else less than five. Conversely, suppose I tell you that there is a rectangle with median quality rank of at most five. Now, there’d be no point looking for rectangles with median quality of six, or seven, or anything greater than five. This is tailor-made binary search territory.</p>
<p class="indent">In the Feeding Ants problem, small values were infeasible and large values were feasible. In the River Jump problem, small values were feasible and large values were infeasible. Here, we’re back in the Feeding Ants case: small values are infeasible and large values are feasible. We’ll therefore need a change to the River Jump invariant, flipping the locations of the feasible and infeasible portions of the solution space.</p>
<p class="indent">Here’s the invariant that we’ll use: <code>low</code> and everything smaller than <code>low</code> are infeasible; <code>high</code> and everything larger than <code>high</code> are feasible. This tells us that we should return <code>high</code> when we’re done, as it will be the smallest feasible value. The code, in <a href="ch07.xhtml#ch07ex011">Listing 7-11</a>, is otherwise very similar to <a href="ch07.xhtml#ch07ex07">Listing 7-7</a>.</p>
<pre>int rectangle(int r, int c, int h, int w, board q) {
  int low, high, mid;
  low = 0;
  high = r * c + 1;
  while (high - low &gt; 1) {
    mid = (low + high) / 2;
    if (can_make_quality(mid, r, c, h, w, q))
      high = mid;
    else
      low = mid;
  }
<span epub:type="pagebreak" id="page_260"/>  return high;
}</pre>
<p class="excap" id="ch07ex011"><em>Listing 7-11: Searching for the optimal solution</em></p>
<p class="indent">To finish the job, we need an implementation of <code>can_make_quality</code> to test feasibility.</p>
<h4 class="h4" id="sec112"><em>Testing Feasibility</em></h4>
<p class="noindent">Here’s the signature for the feasibility-checking function that we’ll write:</p>
<pre>int can_make_quality(int quality, int r, int c, int h, int w, board q)</pre>
<p class="indent">In “Sorting Every Rectangle” on <a href="ch07.xhtml#sec110">page 256</a>, we were saddled by having to calculate the median quality rank of each rectangle. Now this is no longer the case: we’re content to determine whether the median value of some rectangle is at most some cutoff <code>quality</code> rank value.</p>
<p class="indent">This is an easier problem for which a sorting step is unnecessary. Here’s the key observation: the specific values themselves no longer matter; all that matters is the relationship between each value and <code>quality</code>. To exploit this observation, we’ll replace all values that are less than or equal to <code>quality</code> by –1 and all values greater than <code>quality</code> by 1. We then add up these –1 and 1 values for a given rectangle. If we have at least as many –1 values as 1 values (that is, there are at least as many small values as large values, relative to <code>quality</code>), then the sum will be zero or negative, and we can conclude that this rectangle has a median quality rank of <code>quality</code> or less.</p>
<p class="indent">Let’s work an example. Here are the 15 quality ranks again for the 5×3 rectangle in the top left of <a href="ch07.xhtml#ch07tab1">Table 7-1</a>: 48, 16, 15, 20, 11, 36, 22, 39, 30, 14, 35, 2, 32, 37, and 21. Does this rectangle have a median quality rank of 16 or less? Take each value and replace it by –1 if it’s less than or equal to 16 and 1 if it’s greater than 16. Here are the new values: 1, –1, –1, 1, –1, 1, 1, 1, 1, –1, 1, –1, 1, 1, and 1. If we add these up, we get a value of 5. This means that there are five more large values than small values, and we must conclude that a median of 16 or smaller is not possible for this rectangle. If we wanted to know whether a median of 30 was feasible, we’d get this after replacing the numbers by –1s and 1s: 1, –1, –1, –1, –1, 1, –1, 1, –1, –1, 1, –1, 1, 1, and –1. Adding these up, we get a total of –3.</p>
<p class="indent">Aha! So 30 is a feasible median. Crucially, we’re making this feasible–infeasible decision with no sorting at all.</p>
<p class="indent">We need to loop through each rectangle, testing whether it has a median quality rank of <code>quality</code> or less. <a href="ch07.xhtml#ch07ex012">Listing 7-12</a> does exactly this.</p>
<pre>int can_make_quality(int quality, int r, int c, int h, int w, board q) {
<span class="ent">➊</span> static int zero_one[MAX_ROWS][MAX_COLS];
  int i, j;
  int top_row, left_col, bottom_row, right_col;
  int total;
<span epub:type="pagebreak" id="page_261"/>
  for (i = 0; i &lt; r; i++)
    for (j = 0; j &lt; c; j++)
    <span class="ent">➋</span> if (q[i][j] &lt;= quality)
        zero_one[i][j] = -1;
      else
        zero_one[i][j] = 1;

   for (top_row = 0; top_row &lt; r - h + 1; top_row++)
     for (left_col = 0; left_col &lt; c - w + 1; left_col++) {
       bottom_row = top_row + h - 1;
       right_col = left_col + w - 1;
       total = 0;
       for (i = top_row; i &lt;= bottom_row; i++)
         for (j = left_col; j &lt;= right_col; j++)
         <span class="ent">➌</span> total = total + zero_one[i][j];
        if (total &lt;= 0)
          return 1;
      }
    return 0;
}</pre>
<p class="excap" id="ch07ex012"><em>Listing 7-12: Testing the feasibility of</em> <span class="codeitalic1">quality</span></p>
<p class="indent">We can’t just obliterate the <code>q</code> array with –1s and 1s, because then we couldn’t use the original quality ranks to later test other values of <code>quality</code>. Therefore, we use a new array to hold the –1s and 1s <span class="ent">➊</span>. Notice how this array is filled in based on whether each value is less than or equal to (–1) or greater than (1) the cutoff <code>quality</code> parameter that we’re checking <span class="ent">➋</span>.</p>
<p class="indent">We then go through each rectangle, just as we did in <a href="ch07.xhtml#ch07ex010">Listing 7-10</a>. We add up all of its –1 and 1 values <span class="ent">➌</span>  and return <code>1</code> (true) if it has a median quality rank that’s small enough.</p>
<p class="indent">All right! We have sidestepped the sorting—crafty, eh? What we did in this subsection is crucial to a fast solution to solving our problem, but we’re not there yet, because if you count the number of nested loops, you’ll see that there are four of them.</p>
<p class="indent">At the end of “Sorting Every Rectangle” we observed that our first solution—with no binary search anywhere!—was a very slow <em>O</em>(<em>m</em><sup>4</sup> log <em>m</em>), where <em>m</em> is the number of rows or columns in the city. Here, our feasibility check is already <em>m</em><sup>4</sup>; multiply by the log factor for the binary search, and it’s not clear that we’ve made any progress.</p>
<p class="indent">Oh, but we have! It’s just locked up behind too many nested loops, involving too much recomputation. Dynamic programming is now going to take us the rest of the way.</p>
<h4 class="h4" id="sec113"><em>A Quicker Way to Test Feasibility</em></h4>
<p class="noindent">Suppose we start with <a href="ch07.xhtml#ch07tab1">Table 7-1</a> and are interested in whether any 5×3 rectangle has a median quality rank of 16 or less. Changing all values less than or equal to 16 to –1 and all values greater than 16 to 1 results in <a href="ch07.xhtml#ch07tab2">Table 7-2</a>.</p>
<span epub:type="pagebreak" id="page_262"/>
<p class="tabcap" id="ch07tab2"><strong>Table 7-2:</strong> A City with Quality Ranks Replaced</p>
<div class="bqparan">
<table class="allczzt">
<colgroup>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
</colgroup>
<thead>
<tr>
<th class="borderrb" style="vertical-align: top"/>
<th class="borderrb" style="vertical-align: top"><strong>0</strong></th>
<th class="borderrb" style="vertical-align: top"><strong>1</strong></th>
<th class="borderrb" style="vertical-align: top"><strong>2</strong></th>
<th class="borderrb" style="vertical-align: top"><strong>3</strong></th>
<th class="borderrb" style="vertical-align: top"><strong>4</strong></th>
<th class="borderrb" style="vertical-align: top"><strong>5</strong></th>
<th class="borderbb" style="vertical-align: top"><strong>6</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>0</strong></td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderbb" style="vertical-align: top">–1</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>1</strong></td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderbb" style="vertical-align: top">1</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>2</strong></td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderbb" style="vertical-align: top">1</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>3</strong></td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderbb" style="vertical-align: top">1</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>4</strong></td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderbb" style="vertical-align: top">1</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>5</strong></td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderbb" style="vertical-align: top">–1</td>
</tr>
<tr>
<td class="borderr" style="vertical-align: top"><strong>6</strong></td>
<td class="borderr" style="vertical-align: top">1</td>
<td class="borderr" style="vertical-align: top">–1</td>
<td class="borderr" style="vertical-align: top">1</td>
<td class="borderr" style="vertical-align: top">1</td>
<td class="borderr" style="vertical-align: top">1</td>
<td class="borderr" style="vertical-align: top">1</td>
<td style="vertical-align: top">1</td>
</tr>
</tbody>
</table>
</div>
<p class="indent">We might begin by summing the elements of the 5×3 rectangle whose top-left coordinate is (0, 0). As we saw in the previous section, the sum of that rectangle is 5. Next, maybe we want to sum the elements of the 5×3 rectangle whose top-left coordinate is (0, 1). Adding up all 15 numbers here is what we would have done in the previous subsection. However, doing so fails to lean on the work we did to compute the sum of the first rectangle. Indeed, this second rectangle has 10 values in common with the first rectangle. We should be able to prevent this kind of duplication of effort for this and all other rectangles.</p>
<p class="indent">Dodging the repeated work here amounts to efficiently solving what’s known as a two-dimensional <em>range sum query</em>. The one-dimensional case uses similar ideas, but in a simpler context, so we’ll briefly study that before returning to finish the Living Quality problem. (About half of <a href="ch08.xhtml">Chapter 8</a> will be devoted to range queries, so stay tuned!)</p>
<h5 class="h5">One-Dimensional Range Sum Queries</h5>
<p class="noindent">Here’s a one-dimensional array:</p>
<div class="image1"><img alt="Image" src="../images/pg262-01.jpg"/></div>
<p class="indent">If asked to find the sum of the array from index 2 to index 5, we could directly sum the values in that range: 15 + 9 + 12 + 4 = 40. That’s not very fast, and it would be particularly unfortunate if we were asked for the sum of the entire array. However, if we had to answer just a few such queries, we could get away with answering each by summing the appropriate values.</p>
<p class="indent">Now imagine that we’re getting peppered by hundreds or thousands of these queries. It makes sense to have done a little up-front work, once, if it means that we can then answer the queries more quickly.</p>
<span epub:type="pagebreak" id="page_263"/>
<p class="indent">Consider the “index 2 to 5” query. What if we could look up the sum from index 0 to 5? That sum is 48. That’s not 40, the answer that we want. Far from useless, though, is that 48 is quite close to what we need. It’s only wrong because it includes the values at index 0 and index 1, stuff that we now need to exclude. We could do that if we could look up the sum from index 0 to 1. That sum is 8. If we subtract this 8 from 48, we get 40.</p>
<p class="indent">What’s needed, then, is a new array, one where index <em>i</em> holds the sum of all values from index 0 to index <em>i</em>. This new array is included in the Prefix Sum row in the following table:</p>
<div class="image1"><img alt="Image" src="../images/pg263-01.jpg"/></div>
<p class="indent">No matter the query, we can now quickly answer it using the prefix sum array: to calculate the sum of the range from index <em>a</em> to <em>b</em>, take the value at index <em>b</em> and subtract the value at index <em>a</em> – 1. For 2 to 5, we get 48 – 8 = 40, and for 1 to 6, we get 59 – 6 = 53. These are constant-time answers, for eternity, and all we had to do was one preprocessing pass over the array.</p>
<h5 class="h5">Two-Dimensional Range Sum: Queries</h5>
<p class="noindent">Let’s return to the two-dimensional world of our quality ranks. Summing the elements of each rectangle is too slow, so we’ll extend what we did in one dimension to two dimensions. Specifically, we’ll produce a new array, where index (<em>i</em>, <em>j</em>) is the sum of the elements of the rectangle whose top-left coordinate is (0, 0) and whose bottom-right coordinate is (<em>i</em>, <em>j</em>).</p>
<p class="indent">Let’s look again at <a href="ch07.xhtml#ch07tab2">Table 7-2</a>.</p>
<div class="bqparan">
<table class="allczzt">
<colgroup>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
</colgroup>
<thead>
<tr>
<th class="borderrb" style="vertical-align: top"/>
<th class="borderrb" style="vertical-align: top"><strong>0</strong></th>
<th class="borderrb" style="vertical-align: top"><strong>1</strong></th>
<th class="borderrb" style="vertical-align: top"><strong>2</strong></th>
<th class="borderrb" style="vertical-align: top"><strong>3</strong></th>
<th class="borderrb" style="vertical-align: top"><strong>4</strong></th>
<th class="borderrb" style="vertical-align: top"><strong>5</strong></th>
<th class="borderbb" style="vertical-align: top"><strong>6</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>0</strong></td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderbb" style="vertical-align: top">–1</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>1</strong></td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderbb" style="vertical-align: top">1</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>2</strong></td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderbb" style="vertical-align: top">1</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>3</strong></td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderbb" style="vertical-align: top">1</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>4</strong></td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderbb" style="vertical-align: top">1</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>5</strong></td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderbb" style="vertical-align: top">–1</td>
</tr>
<tr>
<td class="borderr" style="vertical-align: top"><strong>6</strong></td>
<td class="borderr" style="vertical-align: top">1</td>
<td class="borderr" style="vertical-align: top">–1</td>
<td class="borderr" style="vertical-align: top">1</td>
<td class="borderr" style="vertical-align: top">1</td>
<td class="borderr" style="vertical-align: top">1</td>
<td class="borderr" style="vertical-align: top">1</td>
<td style="vertical-align: top">1</td>
</tr>
</tbody>
</table>
</div>
<span epub:type="pagebreak" id="page_264"/>
<p class="indent">The corresponding prefix array is in <a href="ch07.xhtml#ch07tab3">Table 7-3</a>. (It may seem a little strange to call it a “prefix array” here, but let’s stick with it to match the terminology from the one-dimensional case.)</p>
<p class="tabcap" id="ch07tab3"><strong>Table 7-3:</strong> An Array for Two-Dimensional Range Sum Queries</p>
<div class="bqparan">
<table class="allczzt">
<colgroup>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
</colgroup>
<thead>
<tr>
<th class="borderrb" style="vertical-align: top"/>
<th class="borderrb" style="vertical-align: top"><strong>0</strong></th>
<th class="borderrb" style="vertical-align: top"><strong>1</strong></th>
<th class="borderrb" style="vertical-align: top"><strong>2</strong></th>
<th class="borderrb" style="vertical-align: top"><strong>3</strong></th>
<th class="borderrb" style="vertical-align: top"><strong>4</strong></th>
<th class="borderrb" style="vertical-align: top"><strong>5</strong></th>
<th class="borderbb" style="vertical-align: top"><strong>6</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>0</strong></td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">0</td>
<td class="borderrb" style="vertical-align: top">–1</td>
<td class="borderrb" style="vertical-align: top">0</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderbb" style="vertical-align: top">1</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>1</strong></td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">0</td>
<td class="borderrb" style="vertical-align: top">0</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">4</td>
<td class="borderrb" style="vertical-align: top">4</td>
<td class="borderbb" style="vertical-align: top">4</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>2</strong></td>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderrb" style="vertical-align: top">4</td>
<td class="borderrb" style="vertical-align: top">5</td>
<td class="borderrb" style="vertical-align: top">4</td>
<td class="borderbb" style="vertical-align: top">5</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>3</strong></td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderrb" style="vertical-align: top">4</td>
<td class="borderrb" style="vertical-align: top">2</td>
<td class="borderbb" style="vertical-align: top">4</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>4</strong></td>
<td class="borderrb" style="vertical-align: top">3</td>
<td class="borderrb" style="vertical-align: top">4</td>
<td class="borderrb" style="vertical-align: top">5</td>
<td class="borderrb" style="vertical-align: top">4</td>
<td class="borderrb" style="vertical-align: top">7</td>
<td class="borderrb" style="vertical-align: top">6</td>
<td class="borderbb" style="vertical-align: top">9</td>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>5</strong></td>
<td class="borderrb" style="vertical-align: top">4</td>
<td class="borderrb" style="vertical-align: top">6</td>
<td class="borderrb" style="vertical-align: top">8</td>
<td class="borderrb" style="vertical-align: top">6</td>
<td class="borderrb" style="vertical-align: top">10</td>
<td class="borderrb" style="vertical-align: top">10</td>
<td class="borderbb" style="vertical-align: top">12</td>
</tr>
<tr>
<td class="borderr" style="vertical-align: top"><strong>6</strong></td>
<td class="borderr" style="vertical-align: top">5</td>
<td class="borderr" style="vertical-align: top">6</td>
<td class="borderr" style="vertical-align: top">9</td>
<td class="borderr" style="vertical-align: top">8</td>
<td class="borderr" style="vertical-align: top">13</td>
<td class="borderr" style="vertical-align: top">14</td>
<td style="vertical-align: top">17</td>
</tr>
</tbody>
</table>
</div>
<p class="indent">Let’s make sure we know what this array tells us before worrying about how to quickly build it. The value in row 4, column 2 gives the sum of the values of the rectangle whose top-left coordinate is (0, 0) and whose bottom-right coordinate is (4, 2). We have seen in “Testing Feasibility” that this sum is 5 and, indeed, that’s what this array has there.</p>
<p class="indent">How could we compute that (4, 2) value of 5 using other values that we’ve already computed? We need to start with its value in <a href="ch07.xhtml#ch07tab2">Table 7-2</a>, add what’s in range above it, and add everything in its row to the left. We can do this with judicious use of the array in <a href="ch07.xhtml#ch07tab3">Table 7-3</a>, as shown in <a href="ch07.xhtml#ch07tab4">Table 7-4</a>.</p>
<p class="tabcap" id="ch07tab4"><strong>Table 7-4:</strong> Quickly Calculating a Given Sum</p>
<div class="bqparan">
<table class="allczzt">
<colgroup>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
</colgroup>
<thead>
<tr>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"><strong>0</strong></td>
<td class="borderrb" style="vertical-align: top"><strong>1</strong></td>
<td class="borderrb" style="vertical-align: top"><strong>2</strong></td>
<td class="borderrb" style="vertical-align: top"><strong>3</strong></td>
<td class="borderrb" style="vertical-align: top"><strong>4</strong></td>
<td class="borderrb" style="vertical-align: top"><strong>5</strong></td>
<td class="borderbb" style="vertical-align: top"><strong>6</strong></td>
</tr>
</thead>
<tbody>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>0</strong></td>
<td class="borderrb" style="vertical-align: top">• ■</td>
<td class="borderrb" style="vertical-align: top">• ■</td>
<td class="borderrb" style="vertical-align: top">•</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>1</strong></td>
<td class="borderrb" style="vertical-align: top">• ■</td>
<td class="borderrb" style="vertical-align: top">• ■</td>
<td class="borderrb" style="vertical-align: top">•</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>2</strong></td>
<td class="borderrb" style="vertical-align: top">• ■</td>
<td class="borderrb" style="vertical-align: top">• ■</td>
<td class="borderrb" style="vertical-align: top">•</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>3</strong></td>
<td class="borderrb" style="vertical-align: top">• ■</td>
<td class="borderrb" style="vertical-align: top">• ■</td>
<td class="borderrb" style="vertical-align: top">•</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>4</strong></td>
<td class="borderrb" style="vertical-align: top">■</td>
<td class="borderrb" style="vertical-align: top">■</td>
<td class="borderrb" style="vertical-align: top">1</td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>5</strong></td>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderr" style="vertical-align: top"><strong>6</strong></td>
<td class="borderr" style="vertical-align: top"/>
<td class="borderr" style="vertical-align: top"/>
<td class="borderr" style="vertical-align: top"/>
<td class="borderr" style="vertical-align: top"/>
<td class="borderr" style="vertical-align: top"/>
<td class="borderr" style="vertical-align: top"/>
<td style="vertical-align: top"/>
</tr>
</tbody>
</table>
</div>
<span epub:type="pagebreak" id="page_265"/>
<p class="indent">We need to start with the 1, capture the cells that include a circle (those above), capture the cells that include a square (those to the left), and add them all up. We can capture the cells that include a circle by looking up the element at row 3, column 2. We can also capture the cells that include a square by looking up the element at row 4, column 1. However, adding those together double-counts the cells that include both a circle and a square (those both above and to the left), but this is not an issue because the element at row 3, column 1 captures exactly those circle-and-square cells, whose subtraction undoes the double-counting. In all, we have 1 + 2 + 4 – 2 = 5, as desired. As long as we work from top to bottom and left to right, we can build this array with only two additions and one subtraction per cell.</p>
<p class="indent">We now know how to build an array like that in <a href="ch07.xhtml#ch07tab3">Table 7-3</a>. So what?</p>
<p class="indent">The “so what” is that it enables us to quickly calculate the sum of any rectangle. Suppose we wanted the sum of the rectangle whose top-left coordinate is (1, 3) and whose bottom-right coordinate is (5, 5). We can’t just use the value 10 in row 5, column 5 of <a href="ch07.xhtml#ch07tab3">Table 7-3</a>. That captures everything in the desired rectangle but also includes more than we want: it includes elements that are outside (above or to the left) of our desired rectangle. However, just as in the one-dimensional case, we’ll be able to adjust that value to include only the elements in the rectangle. See <a href="ch07.xhtml#ch07tab5">Table 7-5</a> for how to do this. In this table, the cells of the desired rectangle are marked by stars.</p>
<p class="tabcap" id="ch07tab5"><strong>Table 7-5:</strong> Quickly Calculating the Sum of a Rectangle</p>
<div class="bqparan">
<table class="allczzt">
<colgroup>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:12%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
<col style="width:13%"/>
</colgroup>
<thead>
<tr>
<td class="borderrb" style="vertical-align: top"/>
<td class="borderrb" style="vertical-align: top"><strong>0</strong></td>
<td class="borderrb" style="vertical-align: top"><strong>1</strong></td>
<td class="borderrb" style="vertical-align: top"><strong>2</strong></td>
<td class="borderrb" style="vertical-align: top"><strong>3</strong></td>
<td class="borderrb" style="vertical-align: top"><strong>4</strong></td>
<td class="borderrb" style="vertical-align: top"><strong>5</strong></td>
<td class="borderbb" style="vertical-align: top"><strong>6</strong></td>
</tr>
</thead>
<tbody>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>0</strong></td>
<td class="borderrb" style="vertical-align: top">• ■</td>
<td class="borderrb" style="vertical-align: top">• ■</td>
<td class="borderrb" style="vertical-align: top">• ■</td>
<td class="borderrb" style="vertical-align: top">•</td>
<td class="borderrb" style="vertical-align: top">•</td>
<td class="borderrb" style="vertical-align: top">•</td>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>1</strong></td>
<td class="borderrb" style="vertical-align: top">■</td>
<td class="borderrb" style="vertical-align: top">■</td>
<td class="borderrb" style="vertical-align: top">■</td>
<td class="borderrb" style="vertical-align: top">★</td>
<td class="borderrb" style="vertical-align: top">★</td>
<td class="borderrb" style="vertical-align: top">★</td>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>2</strong></td>
<td class="borderrb" style="vertical-align: top">■</td>
<td class="borderrb" style="vertical-align: top">■</td>
<td class="borderrb" style="vertical-align: top">■</td>
<td class="borderrb" style="vertical-align: top">★</td>
<td class="borderrb" style="vertical-align: top">★</td>
<td class="borderrb" style="vertical-align: top">★</td>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>3</strong></td>
<td class="borderrb" style="vertical-align: top">■</td>
<td class="borderrb" style="vertical-align: top">■</td>
<td class="borderrb" style="vertical-align: top">■</td>
<td class="borderrb" style="vertical-align: top">★</td>
<td class="borderrb" style="vertical-align: top">★</td>
<td class="borderrb" style="vertical-align: top">★</td>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>4</strong></td>
<td class="borderrb" style="vertical-align: top">■</td>
<td class="borderrb" style="vertical-align: top">■</td>
<td class="borderrb" style="vertical-align: top">■</td>
<td class="borderrb" style="vertical-align: top">★</td>
<td class="borderrb" style="vertical-align: top">★</td>
<td class="borderrb" style="vertical-align: top">★</td>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderrb" style="vertical-align: top"><strong>5</strong></td>
<td class="borderrb" style="vertical-align: top">■</td>
<td class="borderrb" style="vertical-align: top">■</td>
<td class="borderrb" style="vertical-align: top">■</td>
<td class="borderrb" style="vertical-align: top">★</td>
<td class="borderrb" style="vertical-align: top">★</td>
<td class="borderrb" style="vertical-align: top">★</td>
<td class="borderbb" style="vertical-align: top"/>
</tr>
<tr>
<td class="borderr" style="vertical-align: top"><strong>6</strong></td>
<td class="borderr" style="vertical-align: top"/>
<td class="borderr" style="vertical-align: top"/>
<td class="borderr" style="vertical-align: top"/>
<td class="borderr" style="vertical-align: top"/>
<td class="borderr" style="vertical-align: top"/>
<td class="borderr" style="vertical-align: top"/>
<td style="vertical-align: top"/>
</tr>
</tbody>
</table>
</div>
<p class="indent">This time, we need to subtract the cells that include a circle and the cells that include a square. We can get the cells with a circle from row 0, column 5 and the cells with a square from row 5, column 2. But subtracting both will double-subtract the cells that have both a circle and a square, so we need to add back the cell in row 0, column 2. That is, we have 10 – 2 – 8 + (–1) = –1, which is the sum of the rectangle.</p>
<span epub:type="pagebreak" id="page_266"/>
<p class="indent">Here’s a general expression for this calculation:</p>
<pre>sum[bottom_row][right_col] - sum[top_row - 1][right_col] -
  sum[bottom_row][left_col - 1] + sum[top_row - 1][left_col - 1]</pre>
<p class="indent">This will be used in the code presented next.</p>
<h5 class="h5">Two-Dimensional Range Sum: Code</h5>
<p class="noindent">We’re ready to put it all together—the –1 and 1 idea, building the prefix array, and using the prefix array for fast rectangle sums—in <a href="ch07.xhtml#ch07ex013">Listing 7-13</a>.</p>
<pre>int can_make_quality(int quality, int r, int c, int h, int w, board q) {
  static int zero_one[MAX_ROWS][MAX_COLS];
  static int sum[MAX_ROWS + 1][MAX_COLS + 1];
  int i, j;
  int top_row, left_col, bottom_row, right_col;
  int total;

<span class="ent">➊</span> for (i = 0; i &lt; r; i++)
    for (j = 0; j &lt; c; j++)
      if (q[i][j] &lt;= quality)
        zero_one[i][j] = -1;
      else
        zero_one[i][j] = 1;

   for (i = 0; i &lt;= c; i++)
     sum[0][i] = 0;
   for (i = 0; i &lt;= r; i++)
     sum[i][0] = 0;
<span class="ent">➋</span> for (i = 1; i &lt;= r; i++)
     for (j = 1; j &lt;= c; j++)
       sum[i][j] = zero_one[i - 1][j - 1] + sum[i - 1][j] +
                   sum[i][j - 1] - sum[i - 1][j - 1];
 
<span class="ent">➌</span> for (top_row = 1; top_row &lt;= r - h + 1; top_row++)
     for (left_col = 1; left_col &lt;= c - w + 1; left_col++) {
       bottom_row = top_row + h - 1;
       right_col = left_col + w - 1;
       total = sum[bottom_row][right_col] - sum[top_row - 1][right_col] -
               sum[bottom_row][left_col - 1] + sum[top_row - 1][left_col - 1];
       if (total &lt;= 0)
         return 1;
    }
  return 0;
}</pre>
<p class="excap" id="ch07ex013"><em>Listing 7-13: Testing the feasibility of</em> <span class="codeitalic1">quality</span> <em>quickly</em></p>
<span epub:type="pagebreak" id="page_267"/>
<p class="indent">Step 1 is to build the <code>zero_one</code> array <span class="ent">➊</span>, exactly as we did in <a href="ch07.xhtml#ch07ex012">Listing 7-12</a>. Step 2 is to build the prefix sum array <code>sum</code> <span class="ent">➋</span>. We’ll use indices that start at 1, rather than 0, so that we don’t have to worry about staying within bounds when we later process cells on the edges of the array. Finally, Step 3 is to use the prefix sum array to quickly calculate the sum of each rectangle <span class="ent">➌</span>. Notice how each rectangle can be summed in constant time here! We paid for the preprocessing work of Step 2, but that work pays for itself every time we sum a rectangle without summing its elements.</p>
<p class="indent">Compared to <a href="ch07.xhtml#ch07ex012">Listing 7-12</a>, we’ve removed two levels of nesting from the <code>for</code> loops. Therefore, this is an <em>O</em>(<em>m</em><sup>2</sup> log <em>m</em>) algorithm, which is fast enough to pass all of the test cases. Go for it! Then take a well-deserved break, because we’ve got one more big problem to solve before we’re through with this chapter.</p>
<h3 class="h3" id="lev47">Problem 4: Cave Doors</h3>
<p class="noindent">Another IOI championship problem? Bring it on! This one is unique to the chapter because it uses binary search not to find an optimal solution, but to quickly zone-in on a desired element. As we did in the Living Quality problem, we won’t read anything from standard input, and we won’t write anything to standard output. Rather, we’ll learn about the problem instance and submit our answer through calls to functions provided by the judge. As you read the problem description, try to anticipate why binary search is still appropriate here.</p>
<p class="indent">This is DMOJ problem <code>ioi13p4</code>.</p>
<h4 class="h4" id="sec114"><em>The Problem</em></h4>
<p class="noindent">You are at the entrance to a long, narrow cave, and you want to get through the cave to the other side. There are <em>n</em> doors that you must pass through: the first door is Door 0, the second is Door 1, and so on.</p>
<p class="indent">Each door can be open or closed. You can walk through any open door, but you can’t get past or see through a closed door. So if Door 0 and Door 1 are open but Door 2 is closed, then you progress to Door 2 but no further.</p>
<p class="indent">At the entrance to the cave is a panel of <em>n</em> switches. Like the doors, the switches are numbered starting from 0. Each switch can be in the up (0) position or the down (1) position. Each switch is associated with a different door, and it determines whether that door is open or closed. If a switch is set to the correct position, then its associated door is open; otherwise, its associated door is closed. You don’t know which switch is associated with which door, and you don’t know whether the switch should be up or down for the door to be open. For example, maybe Switch 0 is associated with Door 5, and the switch has to be down for Door 5 to be open. And maybe Switch 1 is associated with Door 0, and the switch has to be up for Door 0 to be open.</p>
<p class="indent">You can set the switches to whatever positions you choose and then walk through the cave to determine the first door that is closed. You have the <span epub:type="pagebreak" id="page_268"/>stamina to do this at most 70,000 times. Your goal is to determine both the correct position (0 or 1) and the associated door for each switch.</p>
<p class="indent">We have to write the function with this signature:</p>
<pre>void exploreCave(int n)</pre>
<p class="noindent">where <code>n</code> is the number of doors and switches (between 1 and 5,000). To implement this function, you call two functions provided by the judge. These are described next.</p>
<h5 class="h5">Input</h5>
<p class="noindent">We’re not reading anything from standard input. The only way to learn about the problem instance is to call the function <code>tryCombination</code> provided by the judge. Its signature is</p>
<pre>int tryCombination(int switch_positions[])</pre>
<p class="indent">The parameter <code>switch_positions</code> is an array of length <em>n</em> giving the position (0 or 1) of each switch. That is, <code>switch_positions[0]</code> gives the position of Switch 0, <code>switch_positions[1]</code> gives the position of Switch 1, and so on. The <code>tryCombination</code> function simulates what would happen if we set the switches as in <code>switch_positions</code> and walked through the cave. If some door is still closed, it returns the number of the first closed door; otherwise, it returns <code>-1</code> to indicate that all doors are open.</p>
<h5 class="h5">Output</h5>
<p class="noindent">We’re not writing anything to standard output. Instead, when we’re ready, we submit our answer by calling the function <code>answer</code> provided by the judge. Its signature is</p>
<pre>void answer(int switch_positions[], int door_for_switch[])</pre>
<p class="indent">We have one shot at this: when we call <code>answer</code>, we can’t then do anything else, so we had better submit the correct answer the first time. The parameter <code>switch_positions</code> is our proposed switch positions, in the same format as for <code>tryCombination</code>. The parameter <code>door_for_switch</code> is our proposed association between switches and doors: <code>door_for_switch[0]</code> gives the door for Switch 0, <code>door_for_switch[1]</code> gives the door for Switch 1, and so on.</p>
<p class="indent">The number of calls to <code>tryCombination</code>, rather than execution time, is the scarce resource here. We’re allowed to make at most 70,000 calls; if we make more, then our program is terminated and we do not solve the problem.</p>
<h4 class="h4" id="sec115"><em>Solving a Subtask</em></h4>
<p class="noindent">The author of this problem has split the points across five <em>subtasks</em>. The fifth subtask is the problem in its full generality as I’ve presented it here. The other subtasks impose additional constraints on the problem instances to make the problem easier.</p>
<span epub:type="pagebreak" id="page_269"/>
<p class="indent">I like when problem authors use subtasks, especially when I’m struggling to solve a problem. I can then target each subtask in turn, improving my solution as I go, until I solve the full problem. Moreover, if I can’t solve the full problem, then I still get points for the subtasks that I was able to solve.</p>
<p class="indent">The first subtask in the Cave Doors problem is to solve the problem when each switch <code>i</code> is associated with door number <code>i</code>. That is, Switch 0 is associated with Door 0, Switch 1 is associated with Door 1, and so on. What we need to deduce is the correct position (0 or 1) for each switch.</p>
<p class="indent">Don’t worry: we won’t stop with this problem until we solve it fully. But let’s start by solving Subtask 1 here, so we can focus on correctly calling the <code>tryCombination</code> and <code>answer</code> judge functions before we tackle the other aspects of the problem.</p>
<p class="indent">We don’t have access to the code for the two judge functions, so we’re not going to be able to locally compile and run our program. (If you’d like to get things set up locally, you can google “IOI 2013 tasks” and find the test data and templates for the Cave Doors problem, but you won’t need to do any of that to follow the discussion here.) Whenever we want to test what we’re doing, we can submit our code to the judge. In particular, once we successfully solve Subtask 1 and submit our code, the judge should give us some points. The code for Subtask 1 is given in <a href="ch07.xhtml#ch07ex014">Listing 7-14</a>.</p>
<pre>void exploreCave(int n) {
  int switch_positions[n], door_for_switch[n];
  int i, result;
  for (i = 0; i &lt; n; i++) {
 <span class="ent">➊</span> switch_positions[i] = 0;
 <span class="ent">➋</span> door_for_switch[i] = i;
  }
 
  for (i = 0; i &lt; n; i++) {
  <span class="ent">➌</span> result = tryCombination(switch_positions);
    if (result == i) // door i is closed
    <span class="ent">➍</span> switch_positions[i] = 1;
   }
<span class="ent">➎</span> answer(switch_positions, door_for_switch);
}</pre>
<p class="excap" id="ch07ex014"><em>Listing 7-14: Solving Subtask 1</em></p>
<p class="indent">To begin, we use a <code>for</code> loop to set each switch position to <code>0</code> <span class="ent">➊</span>  and associate Door <code>i</code> with Switch <code>i</code> <span class="ent">➋</span>. We’ll update the switch positions when needed, but (as per the subtask constraints) we’ll have no reason to touch the door associations again.</p>
<p class="indent">The second <code>for</code> loop loops through each switch. Its job is to determine if the current switch should stay in Position 0 or change to Position 1. Let’s work through the first iteration, when <code>i</code> is <code>0</code>. We call <code>tryCombination</code> <span class="ent">➌</span>, which returns to us the number of the first door that is closed. If it returns <code>0</code>, then Switch 0 is not set correctly; if Switch 0 were set correctly, Door 0 would be open, and <code>tryCombination</code> would return a number other than <code>0</code>. So, if Door 0 <span epub:type="pagebreak" id="page_270"/>is closed, then we change the position of Switch 0 from <code>0</code> to <code>1</code> <span class="ent">➍</span>. That opens Door 0, and we can move on to Door 1.</p>
<p class="indent">When <code>i</code> is 1, we again call <code>tryCombination</code>. We won’t get a result of <code>0</code>, because our code has already done the work to guarantee that Door 0 is open. If we get a result of <code>1</code>, it means that Door 1 is closed, and we have to change Switch 1 from Position 0 to Position 1.</p>
<p class="indent">Generalizing, we can say that, when we start a new iteration of the loop, all of the doors up to and including Door <code>i - 1</code> are open. If Door <code>i</code> is closed, then we change the position of Switch <code>i</code> from <code>0</code> to <code>1</code>; otherwise, Door <code>i</code> is already open, and Switch <code>i</code> is already correctly set.</p>
<p class="indent">Once we’re finished with that second <code>for</code> loop, we’ve figured out the correct position of each switch. We communicate this to the judge through the call to the <code>answer</code> function <span class="ent">➎</span>.</p>
<p class="indent">I suggest submitting this code to the judge to verify that you’re correctly calling <code>tryCombination</code> and <code>answer</code>. Once you’re ready, we’ll move on to solve the real deal.</p>
<h4 class="h4" id="sec116"><em>Using Linear Search</em></h4>
<p class="noindent">It’s a good thing we solved Subtask 1, beyond the fact of getting our feet wet. That’s because there’s a nice strategy in our solution that paves our way. That strategy is to figure out how to open each door and never let that door interfere again.</p>
<p class="indent">In our solution to Subtask 1, we focus first on Door 0 and get that door open. Once it’s open, we never mess with its switch again. With Door 0 out of the way, we next focus on getting Door 1 open. Once Door 1 is open, we never mess with its switch again. As far as we are concerned, Doors 0 and 1 are gone; the Doors may as well start with Door 2. We continue in this way, knocking off one door after another, until all doors are open.</p>
<p class="indent">In Subtask 1, we knew exactly which door was associated with each of the switches. There was no searching required to figure out this correspondence. But, to solve the full problem, we do need a search, because we don’t know which switch controls the current door. We start by getting Door 0 closed. Then we search through the switches. We change the position of the current switch and ask whether or not Door 0 opened. If not, then this was not the correct switch. If so, then we’ve found the switch for Door 0. We keep Door 0 open from this point onward, and we repeat the process for Door 1: getting it closed and then looping through the switches to find the one that opens it.</p>
<p class="indent">Let’s start with the new <code>exploreCave</code> code given in <a href="ch07.xhtml#ch07ex015">Listing 7-15</a>. It’s brief, because it offloads the search to a helper function.</p>
<pre>void exploreCave(int n) {
  int switch_positions[n], door_for_switch[n];
  int i;
  for (i = 0; i &lt; n; i++)
<span class="ent">➊</span> door_for_switch[i] = -1;
<span epub:type="pagebreak" id="page_271"/>  for (i = 0; i &lt; n; i++)
 <span class="ent">➋</span> set_a_switch(i, switch_positions, door_for_switch, n);
  answer(switch_positions, door_for_switch);
}</pre>
<p class="excap" id="ch07ex015"><em>Listing 7-15: The</em> <span class="codeitalic1">exploreCave</span> <em>function</em></p>
<p class="indent">As with solving Subtask 1, each element of <code>switch_positions</code> will end up being a 0 or 1, indicating the position of each switch. <code>door_for_switch</code> indicates the door associated with each switch. We initialize each element of <code>door_for_switch</code> to <code>-1</code> <span class="ent">➊</span>  to indicate that the door for each switch is unknown. When the door for Switch <code>i</code> becomes known, we’ll update <code>switch_positions[i]</code> and <code>door_for_switch[i]</code> accordingly.</p>
<p class="indent">Pop quiz: If <code>door_for_switch[5]</code> is <code>8</code>, what does that mean? Does it mean that Switch 5 is associated with Door 8 or that Door 5 is associated with Switch 8?</p>
<p class="indent">It’s the former! Make sure you’re clear on this before continuing.</p>
<p class="indent">For each Door <code>i</code>, we call the <code>set_a_switch</code> helper function <span class="ent">➋</span>. Its task is to search through the switches to determine the one that is associated with Door <code>i</code>. It also determines whether that switch should be in Position 0 or 1.</p>
<p class="indent">The code for <code>set_a_switch</code> is given in <a href="ch07.xhtml#ch07ex016">Listing 7-16</a>.</p>
<pre>void set_a_switch(int door, int switch_positions[],
                  int door_for_switch[], int n) {
  int i, result;
  int found = 0;
 
  for (i = 0; i &lt; n; i++)
    if (door_for_switch[i] == -1)
    <span class="ent">➊</span> switch_positions[i] = 0;
 
  result = tryCombination(switch_positions);
  if (result != door) { // door is open
    for (i = 0; i &lt; n; i++)
      if (door_for_switch[i] == -1)
      <span class="ent">➋</span> switch_positions[i] = 1;
  }
 
  i = 0;
  while (!found) {
    if (door_for_switch[i] == -1) {
   <span class="ent">➌</span> switch_positions[i] = 1 - switch_positions[i];
      result = tryCombination(switch_positions);
   <span class="ent">➍</span> if (result != door)
        found = 1;
      else
        i++;
    }
<span epub:type="pagebreak" id="page_272"/>    else
      i++;
  }
  door_for_switch[i] = door;
}</pre>
<p class="excap" id="ch07ex016"><em>Listing 7-16: Finding and setting the switch for the current door using a linear search</em></p>
<p class="indent">The <code>door</code> parameter dictates which door we want to solve next.</p>
<p class="indent">We begin with a loop through the switches. We set the position of the switches to <code>0</code> <span class="ent">➊</span>, but only for those switches that are not associated with a door yet. (Remember that, if a switch is already associated with a door, we don’t want to change that switch’s position ever again.)</p>
<p class="indent">With all relevant switches set to Position 0, we determine whether the current door is open or closed. If it’s open, then we want to close it so that we can later change switch positions, one at a time, to see which switch opens it. To close the door, we just set all switch positions to <code>1</code> <span class="ent">➋</span>. This works because the door was open when the switch positions were all <code>0</code>; one of those switches controls this door, so the door will close when that switch position changes.</p>
<p class="indent">With the door closed, it’s time to search for the switch that opens it. For each switch not already associated with a door, we <em>toggle</em> its position from 0 to 1 or 1 to 0 <span class="ent">➌</span>. Notice how subtracting the position from 1 changes the position: if it was 1 before, then it’s 0 now; if it was 0 before, then it’s 1 now. Then, we check the new status of the door. If it’s open <span class="ent">➍</span>, then we’ve found the associated switch! If it’s still closed, then this wasn’t the right switch and the loop continues.</p>
<p class="indent">What we’re doing in <code>set_a_switch</code> is a linear search through all of the remaining switches. We could have up to 5,000 switches, so finding the switch for a single door could take up to 5,000 calls of <code>tryCombination</code>.</p>
<p class="indent">We can call <code>tryCombination</code> up to 70,000 times. If we get unlucky and the search for the first door takes 5,000 calls, the second takes 4,999 calls, the third takes 4,998 calls, and so on, then we can only handle about 14 doors before we go over the limit. Only 14 doors is not much. We could have 5,000 doors—we’re not even close! This is the end of the line for a linear search.</p>
<h4 class="h4" id="sec117"><em>Using Binary Search</em></h4>
<p class="noindent">The numbers 5,000 (maximum number of doors) and 70,000 (maximum number of <code>tryCombination</code> calls) subtly encode the fact that binary search is a plausible solution strategy. Notice that log<sub>2</sub> 5,000 rounds up to 13. If we can find a way to use binary search, then it’ll pick out the switch for the current door in only 13 calls of <code>tryCombination</code>, not 5,000. If we take 13 calls per door, and we have 5,000 doors, that’s 13 × 5,000 = 65,000 calls in all. We’ll need one extra call per door to tell us whether the door is closed but, still, we should be able to get in under the 70,000 limit.</p>
<p class="indent">How can binary search be used here? It must have something to do with eliminating half of the switch range on each step. Take some time to think through this before continuing!</p>
<span epub:type="pagebreak" id="page_273"/>
<p class="indent">I’ll explain the idea through an example. Suppose we have eight doors and eight switches and that Door 0 is currently closed. If we flip Switch 0, and Door 0 doesn’t open, then we’ve learned very little: all we’ve learned is that Switch 0 isn’t the switch associated with Door 0. (It’s like starting with “1” when guessing someone’s number between 1 and 1,000.) A better idea is to flip half of the switches. So let’s flip Switches 0, 1, 2, and 3. No matter what that does to Door 0, we learn a lot. If Door 0 is still closed, then Switches 0 to 3 have nothing to do with Door 0, and we can focus only on Switches 4 to 7. If Door 0 is now open, we know that one of the Switches 0 to 3 is the switch that’s associated with Door 0, and we can focus only on Switches 0 to 3. One step: half the range gone. We continue in this way until we find the switch (and its position) associated with Door 0.</p>
<p class="indent">Suppose that we go all the way, cutting the range of switches in half again and again until we have only one switch remaining. Let’s say we find that Switch 6 is associated with Door 0. We’ll then set Switch 6 so that Door 0 is open. That’s how it stays. When we next solve Door 1, or indeed any other door later, we’ll be careful not to change the position of Switch 6.</p>
<p class="indent">I can now present the binary search solution to this problem. The new <code>set_a_switch</code> code is given in <a href="ch07.xhtml#ch07ex017">Listing 7-17</a>. The <code>exploreCave</code> function is the same as before (<a href="ch07.xhtml#ch07ex015">Listing 7-15</a>).</p>
<pre>void set_a_switch(int door, int switch_positions[],
                  int door_for_switch[], int n) {
  int i, result;
  int low = 0, high = n-1, mid;
 
  for (i = 0; i &lt; n; i++)
    if (door_for_switch[i] == -1)
      switch_positions[i] = 0;
 
  result = tryCombination(switch_positions);
  if (result != door) {
    for (i = 0; i &lt; n; i++)
      if (door_for_switch[i] == -1)
        switch_positions[i] = 1;
  }
 
<span class="ent">➊</span> while (low != high) {
    mid = (low + high) / 2;
    for (i = low; i &lt;= mid; i++)
      if (door_for_switch[i] == -1)
        switch_positions[i] = 1 - switch_positions[i];
  <span class="ent">➋</span> result = tryCombination(switch_positions);
     if (result != door) {
       high = mid;
       for (i = low; i &lt;= mid; i++)
         if (door_for_switch[i] == -1)
           switch_positions[i] = 1 - switch_positions[i];
    }
<span epub:type="pagebreak" id="page_274"/>    else
      low = mid + 1;
  }
  door_for_switch[low] = door;
<span class="ent">➌</span> switch_positions[low] = 1 - switch_positions[low];
}</pre>
<p class="excap" id="ch07ex017"><em>Listing 7-17: Finding and setting the switch for the current door using a binary search</em></p>
<p class="indent">Compared to <a href="ch07.xhtml#ch07ex016">Listing 7-16</a>, the only real change is the replacement of the linear search with a binary search. Prior to each evaluation of the binary search condition <span class="ent">➊</span>, we’ll arrange so that the current door is closed. In particular, once <code>low</code> and <code>high</code> are equal and the loop terminates, the door will still be closed. Then all we have to do is change the position of switch <code>low</code> to open the door.</p>
<p class="indent">Let’s now study the binary search itself. On each iteration, we calculate the midpoint <code>mid</code>, then change the position of the first half of the switches (but only those that are not already associated with doors). What effect did that have on the current door <span class="ent">➋</span>? There are two possibilities:</p>
<p class="block"><strong>The door is now open.</strong>   We now know that the switch we seek is between <code>low</code> and <code>mid</code>, so we throw away all switches greater than <code>mid</code>. We also flip each switch between <code>low</code> and <code>mid</code> back to what they were prior to this iteration. This closes the door again so that we’re ready for the next iteration.</p>
<p class="block"><strong>The door is still closed.</strong>   The switch we want is therefore between <code>mid + 1</code> and <code>high</code>, so we throw away all switches that are <code>mid</code> or less. That’s all we do! No switches get flipped here, because the door is still closed, just as we want it.</p>
<p class="indent">When we finish the binary search, <code>low</code> and <code>high</code> will be equal, and they tell us the switch associated with the current door. The current door is still closed at this point, so we flip the switch to open it <span class="ent">➌</span>.</p>
<p class="indent">There are no more caveats: we have a clean, fast, binary-search-based solution. Send this off to the judge and you should pass all of the test cases.</p>
<h3 class="h3" id="lev48">Summary</h3>
<p class="noindent">Sometimes it’s much tougher to find an optimal solution than it is to check whether some proposed solution is feasible. How much liquid should be poured in a tree? I don’t know. Is 10 liters enough liquid? Now that question I can handle.</p>
<p class="indent">When the conditions are right, binary search can convert a hard optimization problem into an easier feasibility-check problem. Sometimes it feels like cheating! We pay just an extra logarithmic factor for adding the binary search. A logarithmic factor is practically free. In return, we get to deal with an easier problem.</p>
<span epub:type="pagebreak" id="page_275"/>
<p class="indent">I’m not claiming that binary search is the only way to solve the problems in this chapter. For example, it’s possible to solve Feeding Ants without binary search along the lines of what we did in <a href="ch02.xhtml">Chapter 2</a>, but I find that solution trickier than the one I presented in this chapter. Some problems that can be solved by binary search can also be solved by dynamic programming, but, again, doing so may be very challenging and there’d likely be little practical payoff anyway.</p>
<p class="indent">What I am claiming is that binary search can offer solutions that are both nearly as fast as and easier to design than anything else we might try. If you’re not convinced, you might revisit each problem in this chapter, this time considering how you might solve it without binary search. But, really: if you’re working on a problem and see that you can use binary search, just do it and don’t look back.</p>
<h3 class="h3" id="lev49">Notes</h3>
<p class="noindent">Feeding Ants is originally from the 2014 Croatian Open Competition in Informatics, Round 4. River Jump is originally from the December 2006 USA Computing Olympiad, Silver Division. Living Quality is originally from the 2010 International Olympiad in Informatics. Cave Doors is originally from the 2013 International Olympiad in Informatics.</p>
<p class="indent">Binary search is one manifestation of a general algorithm design technique called <em>divide and conquer (D&amp;C)</em>. D&amp;C algorithms solve one or more independent subproblems, then combine those solutions to solve the original problem. Binary search solves just one subproblem—the one corresponding to the part of the input that we know contains the solution. Other D&amp;C algorithms typically solve two or more subproblems; in <a href="ch10.xhtml">Chapter 10</a>, we’ll see such an example. To learn about other problems that are solved efficiently by D&amp;C algorithms, see <em>Algorithms Illuminated (Part 1): The Basics</em> by Tim Roughgarden (2017).<span epub:type="pagebreak" id="page_276"/></p>
</body></html>