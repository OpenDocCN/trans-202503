["```\nhalleyUpdate :: TimeStep\n             -> ParticleState -> ParticleState\nhalleyUpdate dt\n    = updatePS (eulerCromerPS dt) [sunGravity]\n```", "```\nhalleyInitial :: ParticleState\nhalleyInitial = ParticleState { mass     = 2.2e14            -- kg\n                              , charge   = 0\n                              , time     = 0\n                              , posVec   = 8.766e10 *^ iHat  -- m\n                              , velocity = 54569 *^ jHat }   -- m/s\n```", "```\n{-# OPTIONS -Wall #-}\n\nimport SimpleVec\n    ( xComp, yComp )\nimport Mechanics3D\n    ( ParticleState(..), simulateGloss, disk, halleyInitial, halleyUpdate )\nimport Graphics.Gloss\n    ( Picture(..), pictures, translate, red, yellow )\n\ndiskComet :: Picture\ndiskComet = Color red (disk 10)\n\ndiskSun :: Picture\ndiskSun = Color yellow (disk 20)\n\nhalleyPicture :: ParticleState -> Picture\n\nhalleyPicture (ParticleState _m _q _t r _v)\n    = pictures [diskSun, translate xPixels yPixels diskComet]\n          where\n            pixelsPerMeter = 1e-10\n            xPixels = pixelsPerMeter * realToFrac (xComp r)\n            yPixels = pixelsPerMeter * realToFrac (yComp r)\n\nmain :: IO ()\nmain = simulateGloss (365.25 * 24 * 60 * 60) 400\n       halleyInitial halleyPicture halleyUpdate\n```", "```\ndisk :: Float -> G.Picture\ndisk radius = G.ThickCircle (radius/2) radius\n```", "```\nbaseballForces :: [OneBodyForce]\nbaseballForces\n    = let area = pi * (0.074 / 2) ** 2\n      in [earthSurfaceGravity\n         ,airResistance 0.3 1.225 area]\n```", "```\nbaseballTrajectory :: R  -- time step\n                   -> R  -- initial speed\n                   -> R  -- launch angle in degrees\n                   -> [(R,R)]  -- (y,z) pairs\nbaseballTrajectory dt v0 thetaDeg\n    = let thetaRad = thetaDeg * pi / 180\n          vy0 = v0 * cos thetaRad\n          vz0 = v0 * sin thetaRad\n          initialState\n              = ParticleState { mass     = 0.145\n                              , charge   = 0\n                              , time     = 0\n                              , posVec   = zeroV\n                              , velocity = vec 0 vy0 vz0 }\n      in trajectory $ zGE0 $\n         statesPS (eulerCromerPS dt) baseballForces initialState\n```", "```\nzGE0 :: [ParticleState] -> [ParticleState]\nzGE0 = takeWhile (\\(ParticleState _ _ _ r _) -> zComp r >= 0)\n```", "```\ntrajectory :: [ParticleState] -> [(R,R)]\ntrajectory sts = [(yComp r,zComp r) | (ParticleState _ _ _ r _) <- sts]\n```", "```\nbaseballRange :: R  -- time step\n              -> R  -- initial speed\n              -> R  -- launch angle in degrees\n              -> R  -- range\nbaseballRange dt v0 thetaDeg\n    = let (y,_) = last $ baseballTrajectory dt v0 thetaDeg\n      in y\n```", "```\nbaseballRangeGraph :: IO ()\nbaseballRangeGraph\n    = plotFunc [Title \"Range for baseball hit at 45 m/s\"\n               ,XLabel \"Angle above horizontal (degrees)\"\n               ,YLabel \"Horizontal range (m)\"\n               ,PNG \"baseballrange.png\"\n               ,Key Nothing\n               ] [10,11..80] $ baseballRange 0.01 45\n```", "```\nbestAngle :: (R,R)\nbestAngle\n    = maximum [(baseballRange 0.01 45 thetaDeg,thetaDeg) |\n               thetaDeg <- [30,31..60]]\n```", "```\nPrelude> :l Mechanics3D\n[1 of 4] Compiling Newton2         ( Newton2.hs, interpreted )\n[2 of 4] Compiling Mechanics1D     ( Mechanics1D.hs, interpreted )\n[3 of 4] Compiling SimpleVec       ( SimpleVec.hs, interpreted )\n[4 of 4] Compiling Mechanics3D     ( Mechanics3D.hs, interpreted )\nOk, four modules loaded.\n*Mechanics3D> bestAngle\n(116.77499158246208,41.0)\n```", "```\n{-# OPTIONS -Wall #-}\n\nimport SimpleVec\n    ( yComp, zComp )\nimport Mechanics3D\n    ( ParticleState(..), simulateGloss, disk\n    , projectileInitial, projectileUpdate )\nimport Graphics.Gloss\n    ( Picture(..), red, scale, translate )\nimport System.Environment\n    ( getArgs )\n\nprojectilePicture :: ParticleState -> Picture\nprojectilePicture (ParticleState _m _q _t r _v)\n    = scale 0.2 0.2 $ translate yFloat zFloat redDisk\n      where\n        yFloat = realToFrac (yComp r)\n        zFloat = realToFrac (zComp r)\n        redDisk :: Picture\n        redDisk = Color red (disk 50)\n\nmainWithArgs :: [String] -> IO ()\nmainWithArgs args\n    = simulateGloss 3 20\n      (projectileInitial args) projectilePicture projectileUpdate\n\nmain :: IO ()\nmain = getArgs >>= mainWithArgs\n```", "```\n$ ./GlossProjectile 30 40\n```", "```\n*Mechanics3D> :m +System.Environment\n*Mechanics3D System.Environment> :t getArgs\ngetArgs :: IO [String]\n```", "```\n*Mechanics3D System.Environment> :t (>>=)\n(>>=) :: Monad m => m a -> (a -> m b) -> m b\n```", "```\nIO a -> (a -> IO b) -> IO b\n```", "```\nIO [String] -> ([String] -> IO()) -> IO ()\n```", "```\nprojectileUpdate :: TimeStep\n                 -> ParticleState  -- old state\n                 -> ParticleState  -- new state\nprojectileUpdate dt\n    = updatePS (eulerCromerPS dt) baseballForces\n```", "```\nprojectileInitial :: [String] -> ParticleState\nprojectileInitial []        = error \"Please supply initial speed and angle.\"\nprojectileInitial [_]       = error \"Please supply initial speed and angle.\"\nprojectileInitial (_:_:_:_)\n    = error \"First argument is speed.  Second is angle in degrees.\"\nprojectileInitial (arg1:arg2:_)\n    = let v0       = read arg1 :: R       -- initial speed, m/s\n          angleDeg = read arg2 :: R       -- initial angle, degrees\n          theta    = angleDeg * pi / 180  -- in radians\n      in defaultParticleState\n             { mass     = 0.145  -- kg\n             , posVec   = zeroV\n             , velocity = vec 0 (v0 * cos theta) (v0 * sin theta)\n             }\n```", "```\n*Mechanics3D System.Environment> :t read\nread :: Read a => String -> a\n*Mechanics3D System.Environment> read \"56\" :: R\n56.0\n```", "```\n{-# OPTIONS -Wall #-}\n\nimport SimpleVec ( R, (*^) )\nimport Mechanics3D\n    ( ParticleState(..), simulateVis , projectileInitial, projectileUpdate, v3FromVec )\nimport Vis\n    ( VisObject(..), Flavour(..), red )\nimport System.Environment\n    ( getArgs )\n\nprojectileVisObject :: ParticleState -> VisObject R\nprojectileVisObject st\n    = let r = posVec st\n      in Trans (v3FromVec (0.01 *^ r)) (Sphere 0.1 Solid red)\n\nmainWithArgs :: [String] -> IO ()\nmainWithArgs args\n    = simulateVis 3 20\n      (projectileInitial args) projectileVisObject projectileUpdate\n\nmain :: IO ()\nmain = getArgs >>= mainWithArgs\n```", "```\nprotonUpdate :: TimeStep -> ParticleState -> ParticleState\nprotonUpdate dt\n    = updatePS (rungeKutta4 dt) [uniformLorentzForce zeroV (3e-8 *^ kHat)]\n```", "```\nprotonInitial :: ParticleState\nprotonInitial\n    = defaultParticleState { mass     = 1.672621898e-27  -- kg\n                           , charge   = 1.602176621e-19  -- C\n                           , posVec   = zeroV\n                           , velocity = 1.5*^jHat ^+^ 0.3*^kHat  -- m/s\n                           }\n```", "```\nprotonPicture :: ParticleState -> V.VisObject R\nprotonPicture st\n    = let r0 = v3FromVec (posVec st)\n      in V.Trans r0 (V.Sphere 0.1 V.Solid V.red)\n```", "```\n{-# OPTIONS -Wall #-}\n\nimport Mechanics3D (simulateVis, protonInitial, protonPicture, protonUpdate)\n\nmain :: IO ()\nmain = simulateVis 1 60 protonInitial protonPicture protonUpdate\n```", "```\napR :: R\napR = 0.04  -- meters\n```", "```\nwallForce :: OneBodyForce\nwallForce ps\n    = let m = mass ps\n          r = posVec ps\n          x = xComp r\n          y = yComp r\n          z = zComp r\n          v = velocity ps\n          timeStep = 5e-4 / 60\n      in if y >= 1 && y < 1.1 && sqrt (x**2 + z**2) > apR\n         then (-m) *^ (v ^/ timeStep)\n         else zeroV\n```", "```\nzOut :: V.VisObject R -> V.VisObject R\nzOut = V.RotEulerDeg (Euler 90 0 90)\n```", "```\nenergy :: ParticleState -> R\nenergy ps = undefined ps\n```", "```\nfirstOrbit :: ParticleState -> Bool\nfirstOrbit st\n    = let year = 365.25 * 24 * 60 * 60\n      in time st < 50 * year || yComp (posVec st) <= 0\n```"]