<html><head></head><body>
<h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_137"/><span class="big">11</span><br/>AUTOMATING ACTIVE DIRECTORY</h2>&#13;
<div class="image1"><img class="inline" src="../images/common.jpg" alt="Images"/></div>&#13;
<p class="noindent"><span class="bign">One of the best products to automate with PowerShell is Microsoft’s Active Directory (AD). Employees are constantly entering, leaving, and moving around an organization. A dynamic system is needed to keep track of the ever-shifting flux of employees, and that’s where AD comes in. IT pros perform repetitive and similar tasks in AD, making it a perfect site for automation.</span></p>&#13;
<p class="indent">In this chapter, we’ll walk through using PowerShell to automate a few scenarios involving AD. Although numerous AD objects can be manipulated with PowerShell, we’ll cover only three of the most common: user accounts, computer accounts, and groups. These types of objects are the ones an AD administrator will most likely encounter on a day-to-day basis.</p>&#13;
<h3 class="h3" id="ch11lev1"><span epub:type="pagebreak" id="page_138"/>Prerequisites</h3>&#13;
<p class="noindent">As you follow along with the examples in this chapter, I make a few assumptions about your computer environment.</p>&#13;
<p class="indent">The first is that you’re working on a Windows computer that’s already a member of an Active Directory domain. There are ways to work with AD from a workgroup computer using alternate credentials, but that’s beyond the scope of this chapter.</p>&#13;
<p class="indent">The second is that you’ll be working with the same domain that your computer is a member of. Complicated cross-domain and forest trust issues are also beyond the scope of this chapter.</p>&#13;
<p class="indent">The last is that you are logged into your computer with an AD account that has appropriate permissions to read, modify, and create common AD objects such as users, computers, groups, and organizational units. I am doing these exercises from a computer with an account that is part of the Domain Admins group—meaning I have control over everything in my domain. Although this is not completely necessary, and generally not recommended in a production environment, this allows me to demonstrate various topics without being concerned with object rights, which are beyond the scope of this book.</p>&#13;
<h3 class="h3" id="ch11lev2">Installing the ActiveDirectory PowerShell Module</h3>&#13;
<p class="noindent">As you know by now, there’s more than one way to accomplish a task with PowerShell. Likewise, there’s not much use in reinventing the wheel when you can use the preexisting tools to make bigger and better ones. In this chapter, you’ll use only a single module: <span class="literal">ActiveDirectory</span>. Although it’s not without its shortcomings—obscure parameters, odd filtering syntax, strange error behavior—it’s by far the most comprehensive module for managing AD.</p>&#13;
<p class="indent">The <span class="literal">ActiveDirectory</span> module comes with the <em>Remote Server Administration Tools</em> software package. This is a software bundle of many tools and, unfortunately, at the time of this writing, the only way to get a copy of the <span class="literal">ActiveDirectory</span> module. Before you continue with this chapter, I encourage you to download and install this package. Once you do, you’ll have the <span class="literal">ActiveDirectory</span> module installed.</p>&#13;
<p class="indent">To confirm you have <span class="literal">ActiveDirectory</span> installed, you can use the <span class="literal">Get-Module</span> command:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Module -Name ActiveDirectory -List</span>  &#13;
Directory: C:\WINDOWS\system32\WindowsPowerShell\v1.0\Modules&#13;
&#13;
ModuleType  Version  Name             ExportedCommands&#13;
----------  -------  ----             ----------------&#13;
Manifest    1.0.0.0  ActiveDirectory  {Add-ADCentralAccessPolicyMember,...</pre>&#13;
<p class="indent">If you see this output, <span class="literal">ActiveDirectory</span> is installed.</p>&#13;
<h3 class="h3" id="ch11lev3"><span epub:type="pagebreak" id="page_139"/>Querying and Filtering AD Objects</h3>&#13;
<p class="noindent">Once you’ve ensured that you’ve met all of the prerequisites and have the <span class="literal">ActiveDirectory</span> module installed, you’re ready to get started.</p>&#13;
<p class="indent">One of the best ways to get acclimated to a new PowerShell module is to look for all its <span class="literal">Get</span> verb commands. Commands that begin with <em>Get</em> only read information, so the risk that you’ll change something by accident is minimal. Let’s take this approach with the <span class="literal">ActiveDirectory</span> module and look for commands associated with the objects we’ll be working with in this chapter. <a href="ch11.xhtml#ch11list1">Listing 11-1</a> shows how to retrieve only the <span class="literal">ActiveDirectory</span> commands that begin with <em>Get</em> and have the word <em>computer</em> somewhere in the verb portion.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Command -Module ActiveDirectory -Verb Get -Noun *computer*</span>&#13;
&#13;
CommandType     Name                               Version    Source&#13;
-----------     ----                               -------    ------&#13;
Cmdlet          Get-ADComputer                     1.0.0.0    ActiveDirectory&#13;
Cmdlet          Get-ADComputerServiceAccount       1.0.0.0    ActiveDirectory&#13;
&#13;
PS&gt; <span class="codestrong1">Get-Command -Module ActiveDirectory -Verb Get -Noun *user*</span>&#13;
&#13;
CommandType     Name                               Version    Source&#13;
-----------     ----                               -------    ------&#13;
Cmdlet          Get-ADUser                         1.0.0.0    ActiveDirectory&#13;
Cmdlet          Get-ADUserResultantPasswordPolicy  1.0.0.0    ActiveDirectory&#13;
&#13;
PS&gt; <span class="codestrong1">Get-Command -Module ActiveDirectory -Verb Get -Noun *group*</span>&#13;
&#13;
CommandType     Name                               Version    Source&#13;
-----------     ----                               -------    ------&#13;
Cmdlet          Get-ADAccountAuthorizationGroup    1.0.0.0    ActiveDirectory&#13;
Cmdlet          Get-ADGroup                        1.0.0.0    ActiveDirectory&#13;
Cmdlet          Get-ADGroupMember                  1.0.0.0    ActiveDirectory&#13;
Cmdlet          Get-ADPrincipalGroupMembership     1.0.0.0    ActiveDirectory</pre>&#13;
<p class="caption" id="ch11list1"><em>Listing 11-1: <span class="literal">ActiveDirectory</span> module <span class="literal">Get</span> commands</em></p>&#13;
<p class="indent">You can see a few commands that look interesting. In this chapter, you’ll be using <span class="literal">Get-ADComputer</span>, <span class="literal">Get-ADUser</span>, <span class="literal">Get-ADGroupm</span>, and <span class="literal">Get-ADGroupMember</span>.</p>&#13;
<h4 class="h4" id="ch11lev3sec1">Filtering Objects</h4>&#13;
<p class="noindent">Many of the <span class="literal">Get</span> AD commands you’ll be using have a common parameter called <span class="literal">Filter</span>. <span class="literal">Filter</span> is similar to the PowerShell <span class="literal">Where-Object</span> command as it filters what each command returns, but is different in the way it accomplishes this task.</p>&#13;
<p class="indent">The <span class="literal">Filter</span> parameter uses its own syntax and can be difficult to understand, especially when you’re using complex filters. For a full breakdown of the <span class="literal">Filter</span> parameter’s syntax, you can run <span class="literal">Get-Help</span> <span class="literal">about</span>_<span class="literal">ActiveDirectory_Filter</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_140"/>For this chapter, we’ll keep it simple and avoid any advanced filtering. First, let’s use the <span class="literal">Filter</span> parameter and the <span class="literal">Get-ADUser</span> command to return all users in the domain, as shown in <a href="ch11.xhtml#ch11list2">Listing 11-2</a>. Be careful, though: if you have a lot of user accounts in your domain, you could be waiting a while.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-ADUser -Filter *</span>&#13;
&#13;
&#13;
DistinguishedName : CN=adam,CN=Users,DC=lab,DC=local&#13;
Enabled           : True&#13;
GivenName         :&#13;
Name              : adam&#13;
ObjectClass       : user&#13;
ObjectGUID        : 5e53c562-4fd8-4620-950b-aad8fbaa84db&#13;
SamAccountName    : adam&#13;
SID               : S-1-5-21-930245869-402111599-3553179568-500&#13;
Surname           :&#13;
UserPrincipalName :&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch11list2"><em>Listing 11-2: Finding all user accounts in a domain</em></p>&#13;
<p class="indent">As you can see, the <span class="literal">Filter</span> parameter accepts a string value wildcard character, <span class="literal">*</span>. On its own, this character tells (most) <span class="literal">Get</span> commands to return everything they find. Although this can be occasionally useful, most of the time you don’t want <em>all</em> possible objects. However, used correctly, the wildcard character is a powerful tool.</p>&#13;
<p class="indent">Let’s say you want to find all computer accounts in AD that start with the letter <em>C</em>. You can do so by running <span class="literal">Get-ADComputer -Filter 'Name -like "C*"'</span>, where <span class="literal">C*</span> represents all characters after a <em>C</em>. You could also do it in reverse; say you want to find anyone with a last name that ends in <em>son</em>. You could run the command <span class="literal">Get-ADComputer -Filter 'Name -like "*son"'</span>.</p>&#13;
<p class="indent">If you want to find all users that have a last name of <em>Jones</em>, you could run <span class="literal">Get-ADUser -Filter "surName -eq 'Jones'"</span>; if you want a single user using the first and last name, you could run <span class="literal">Get-ADUser -Filter "surName -eq 'Jones' -and givenName -eq 'Joe'</span>. The <span class="literal">Filter</span> parameter allows you to use various PowerShell operators such as <span class="literal">like</span> and <span class="literal">eq</span> to build a filter that returns only the results you’re looking for. Active Directory attributes are stored in the AD database using lower camel case, so that’s what I’ve used in the filters, although this isn’t technically necessary.</p>&#13;
<p class="indent">Another command useful for filtering AD objects is the <span class="literal">Search-ADAccount</span> command. This command has built-in support for common filtering scenarios such as finding all users with an expired password, finding locked-out users, and finding computers that are enabled. Check out the help for the <span class="literal">Search-ADAccount</span> cmdlet to see the full range of parameters.</p>&#13;
<p class="indent">Most of the time, the <span class="literal">Search-ADAccount</span> syntax is self-explanatory. Various switch parameters, including <span class="literal">PasswordNeverExpires</span>, <span class="literal">AccountDisabled</span>, and <span class="literal">AccountExpired</span>, do not require other parameters to function.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_141"/>Besides these fancy parameters, <span class="literal">Search-ADAccount</span> also has various parameters that require additional input—for example, to indicate how old a datetime attribute is or if you need to limit the results by a particular object type (for example, Users or Computers).</p>&#13;
<p class="indent">Let’s use the <span class="literal">AccountInactive</span> parameter as an example. Say you want to find all users who haven’t used their account in 90 days. This is a great query for <span class="literal">Search-ADAccount</span>. By using the syntax in <a href="ch11.xhtml#ch11list3">Listing 11-3</a>, using <span class="literal">–</span><span class="literal">UsersOnly</span> to filter the type of object and <span class="literal">–</span><span class="literal">TimeSpan</span> to filter for objects that have not been active in the last 90 days, you can quickly find all the requested users.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Search-ADAccount -AccountInactive -TimeSpan 90.00:00:00 -UsersOnly</span></pre>&#13;
<p class="caption" id="ch11list3"><em>Listing 11-3: Using <span class="literal">Search-ADAccount</span></em></p>&#13;
<p class="indent">The <span class="literal">Search-ADAccount</span> cmdlet returns an object type of <span class="literal">Microsoft.ActiveDirectory.Management.ADUser</span>. This is the same object type that commands such as <span class="literal">Get-ADUser</span> and <span class="literal">Get-ADComputer</span> return. <span class="literal">Search-ADAccount</span> can be a good shortcut when you’re using a <span class="literal">Get</span> command and feel stuck trying to figure out what syntax to use for the <span class="literal">Filter</span> parameter.</p>&#13;
<h4 class="h4" id="ch11lev3sec2">Returning Single Objects</h4>&#13;
<p class="noindent">Sometimes you know the exact AD object you’re looking for, so there’s no need to use <span class="literal">Filter</span> at all. Here, you can use the <span class="literal">Identity</span> parameter.</p>&#13;
<p class="indent"><span class="literal">Identity</span> is a flexible parameter that allows you to specify attributes that make an AD object unique; thus it returns only a single object. Every user account has a unique attribute called <span class="literal">samAccountName</span>. You could use the <span class="literal">Filter</span> parameter to find all users with a specific <span class="literal">samAccountName</span>, which would look like this:</p>&#13;
<pre>Get-ADUser -Filter "samAccountName -eq 'jjones'"</pre>&#13;
<p class="indent">But it’s much cleaner to use the <span class="literal">Identity</span> parameter instead:</p>&#13;
<pre>Get-ADUser -Identity jjones</pre>&#13;
<h4 class="h4" id="ch11lev3sec3">Project 4: Finding User Accounts That Haven’t Changed Their Password in 30 Days</h4>&#13;
<p class="noindent">Now that you have a basic understanding of how to query AD objects, let’s create a small script and put that knowledge to use. Here’s the scenario: you work at a company that’s about to implement a new password-expiration policy and your job is to find all the accounts that haven’t changed their password in the past 30 days.</p>&#13;
<p class="indent">First, let’s think about what command to use. Your first choice might be the <span class="literal">Search-ADAccount</span> command you learned earlier in this chapter. <span class="literal">Search-ADAccount</span> has many uses for searching and filtering on various objects, but <span epub:type="pagebreak" id="page_142"/>you can’t craft custom filters. To get more granular in your searching, you’ll have to build your own filters by using the <span class="literal">Get-ADUser</span> command.</p>&#13;
<p class="indent">Once you know what command you’re going to use, the next step is to figure out what you want to filter for. You know you want to filter for accounts that haven’t changed their password in the past 30 days, but if you look only for that, you’ll find more accounts than you need. Why? If you don’t filter for accounts that are <span class="literal">Enabled</span>, you’ll probably get old accounts that don’t matter anymore (maybe someone who left the company or lost computer privileges). So you look for enabled computers that haven’t changed their password in the past 30 days.</p>&#13;
<p class="indent">Let’s start with filtering enabled user accounts. You can do this by using <span class="literal">–Filter "Enabled -eq 'True'"</span>. Simple enough. The next step is to figure out how to access the attribute that is stored when a user’s password is set.</p>&#13;
<p class="indent">By default, <span class="literal">Get-ADUser</span> doesn’t return all of a user’s properties. Using the <span class="literal">Properties</span> parameter, you can specify which properties you’d like to see; here, you’ll use <span class="literal">name</span> and <span class="literal">passwordlastset</span>. Notice that some users don’t have a <span class="literal">password</span><span class="literal">lastset</span> property. This is because they’ve never set their own password.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-AdUser -Filter * -Properties passwordlastset  | select name,passwordlastset</span>&#13;
&#13;
name           passwordlastset&#13;
----           ---------------&#13;
adam           2/22/2019 6:45:40 AM&#13;
Guest&#13;
DefaultAccount&#13;
krbtgt         2/22/2019 3:03:32 PM&#13;
Non-Priv User  2/22/2019 3:12:38 PM&#13;
abertram&#13;
abertram2&#13;
fbar&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="indent">Now that you have the attribute name, you need to build a filter for it. Remember that you want only accounts whose passwords changed in the past 30 days. To find a date difference, you need two dates: the oldest possible date (30 days ago) and the newest possible date (today). You can get today’s date easily by using the <span class="literal">Get-Date</span> command. And you can use the <span class="literal">AddDays</span> method to figure out what the date was 30 days ago. You’ll store both in variables for easy access later.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$today = Get-Date</span>&#13;
PS&gt; <span class="codestrong1">$30DaysAgo = $today.AddDays(-30)</span></pre>&#13;
<p class="indent">Now that you have the dates, you can use them in the filter:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-ADUser -Filter "passwordlastset -lt '$30DaysAgo'"</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_143"/>All that’s left to do is to add your <span class="literal">Enabled</span> condition to the filter. <a href="ch11.xhtml#ch11list4">Listing 11-4</a> shows the steps to do this.</p>&#13;
<pre>$today = Get-Date&#13;
$30DaysAgo = $today.AddDays(-30)&#13;
Get-ADUser -Filter "Enabled -eq 'True' -and passwordlastset –lt&#13;
'$30DaysAgo'"</pre>&#13;
<p class="caption" id="ch11list4"><em>Listing 11-4: Finding enabled user accounts that haven’t changed their password in 30 days</em></p>&#13;
<p class="indent">You now have some code built up to find all enabled Active Directory users that have set their password in the last 30 days.</p>&#13;
<h3 class="h3" id="ch11lev4">Creating and Changing AD Objects</h3>&#13;
<p class="noindent">Now that you know how to find existing AD objects, let’s learn how to change and create them. This section is divided into two parts: one dealing with users and computers, and one dealing with groups.</p>&#13;
<h4 class="h4" id="ch11lev4sec4">Users and Computers</h4>&#13;
<p class="noindent">To change users and computer accounts, you’ll use a <span class="literal">Set</span> command: either <span class="literal">Set-ADUser</span> or <span class="literal">Set-ADComputer</span>. These commands can change any attribute of an object. Usually, you’ll want to pipe in an object you get from a <span class="literal">Get</span> command (like those covered in the previous lesson).</p>&#13;
<p class="indent">As an example, say that an employee named Jane Jones got married, and you’re asked to change the last name of her user account. If you didn’t know an identity attribute for this user account, you could use the <span class="literal">Filter</span> parameter on <span class="literal">Get-ADUser</span> to find it. But first, you’d need to discover how AD stores each user’s first and last name. You can then use the values of those attributes to pass to the <span class="literal">Filter</span> parameter.</p>&#13;
<p class="indent">One way to find all available attributes stored in AD is with a little .NET. Using a schema object, you can find the user class and enumerate all of its attributes:</p>&#13;
<pre><span class="codestrong1">$schema =[DirectoryServices.ActiveDirectory.ActiveDirectorySchema]::GetCurrentSchema()</span>&#13;
<span class="codestrong1">$userClass = $schema.FindClass('user')</span>&#13;
<span class="codestrong1">$userClass.GetAllProperties().Name</span></pre>&#13;
<p class="indent">By reviewing the available attribute list, you then find the <span class="literal">givenName</span> and <span class="literal">surName</span> attribute to use in the <span class="literal">Filter</span> parameter with the <span class="literal">Get-ADUser</span> command, finding the user account. Next, you can pass that object to <span class="literal">Set-ADUser</span>, as shown in <a href="ch11.xhtml#ch11list5">Listing 11-5</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_144"/>PS&gt; <span class="codestrong1">Get-ADUser -Filter "givenName -eq 'Jane' -and surName –eq</span>&#13;
<span class="codestrong1">'Jones'" | Set-ADUser -Surname 'Smith'</span>&#13;
PS&gt; <span class="codestrong1">Get-ADUser -Filter "givenName -eq 'Jane' -and surName –eq</span>&#13;
<span class="codestrong1">'Smith'"</span>&#13;
&#13;
DistinguishedName : CN=jjones,CN=Users,DC=lab,DC=local&#13;
Enabled           : False&#13;
GivenName         : Jane&#13;
Name              : jjones&#13;
ObjectClass       : user&#13;
ObjectGUID        : fbddbd77-ac35-4664-899c-0683c6ce8457&#13;
SamAccountName    : jjones&#13;
SID               : S-1-5-21-930245869-402111599-3553179568-3103&#13;
Surname           : Smith&#13;
UserPrincipalName :</pre>&#13;
<p class="caption" id="ch11list5"><em>Listing 11-5: Changing AD object attributes with <span class="literal">Set-ADUser</span></em></p>&#13;
<p class="indent">You can also change multiple attributes at once. It turns out Jane also moved departments and got a promotion, both of which need to be updated. Not a problem. You just need to use the parameters that match up to the AD attributes:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-ADUser -Filter "givenName -eq 'Jane' -and surname –eq</span>&#13;
<span class="codestrong1">'Smith'" | Set-ADUser -Department 'HR' -Title Director</span>&#13;
PS&gt; <span class="codestrong1">Get-ADUser -Filter "givenName -eq 'Jane' -and surname –eq</span>&#13;
<span class="codestrong1">'Smith'" -Properties GivenName,SurName,Department,Title</span>&#13;
&#13;
Department        : HR&#13;
DistinguishedName : CN=jjones,CN=Users,DC=lab,DC=local&#13;
Enabled           : False&#13;
GivenName         : Jane&#13;
Name              : jjones&#13;
ObjectClass       : user&#13;
ObjectGUID        : fbddbd77-ac35-4664-899c-0683c6ce8457&#13;
SamAccountName    : jjones&#13;
SID               : S-1-5-21-930245869-402111599-3553179568-3103&#13;
Surname           : Smith&#13;
Title             : Director&#13;
UserPrincipalName :</pre>&#13;
<p class="indent">Finally, you can create AD objects by using <span class="literal">New-AD*</span> commands. Creating new AD objects is similar to changing existing objects, but here you don’t have access to an <span class="literal">Identity</span> parameter. Creating a new AD computer account is as easy as running <span class="literal">New-ADComputer -Name FOO</span>; likewise, an AD user can be created by using <span class="literal">New-ADUser -Name adam</span>. You’ll see that the <span class="literal">New-AD*</span> commands also have parameters that correlate to AD attributes, just like the <span class="literal">Set-AD*</span> commands do.</p>&#13;
<h4 class="h4" id="ch11lev4sec5"><span epub:type="pagebreak" id="page_145"/>Groups</h4>&#13;
<p class="noindent"><em>Groups</em> are trickier than users and computers. One way to think about groups is as a container for many AD objects. In that sense, a group is a bunch of things. But at the same time, it’s still a <em>single</em> container, meaning that just like users and computers, a group is a singular AD object. That means you can query, create, and change groups the same way you would users and computers, with a few slight differences.</p>&#13;
<p class="indent">Maybe your organization created a new department called AdamBertramLovers, and it’s bursting at the seams with new employees. Now you need to create a group with this name. <a href="ch11.xhtml#ch11list6">Listing 11-6</a> shows an example of how to create such a group. You use the <span class="literal">Description</span> parameter to pass in a string (the group’s description), and the <span class="literal">GroupScope</span> parameter to ensure that the group created has a scope of <span class="literal">DomainLocal</span>. You could have chosen <span class="literal">Global</span> or <span class="literal">Universal</span> here as well if that’s what you required.</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-ADGroup -Name 'AdamBertramLovers'</span> &#13;
<span class="codestrong1">-Description 'All Adam Bertram lovers in the company'</span> &#13;
<span class="codestrong1">-GroupScope DomainLocal</span></pre>&#13;
<p class="caption" id="ch11list6"><em>Listing 11-6: Creating an AD group</em></p>&#13;
<p class="indent">Once the group exists, you can modify it just as you would a user or computer. To change the description, for example, you could do this:</p>&#13;
<pre>PS&gt;<span class="codestrong1"> Get-ADGroup -Identity AdamBertramLovers |</span> &#13;
<span class="codestrong1">Set-ADGroup -Description 'More Adam Bertram lovers'</span></pre>&#13;
<p class="indent">Of course, the key difference between groups and users/computers is that a group can contain users and computers. When a computer or user account is contained within a group, we say that is a <em>member</em> of that group. But to add and change members of a group, you can’t use the commands you’ve been using. Instead, you need to use <span class="literal">Add-ADGroupMember</span> and <span class="literal">Remove-ADGroupMember</span>.</p>&#13;
<p class="indent">For example, to add Jane to our group, you can do so using <span class="literal">Add-ADGroupMember</span>. If Jane wants to leave the group, you can remove her by using <span class="literal">Remove-ADGroupMember</span>. As you try this, you’ll find that running the <span class="literal">Remove-ADGroupMember</span> command will lead to a prompt asking you to confirm your decision to remove the member:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-ADGroup -Identity AdamBertramLovers | Add-ADGroupMember Members 'jjones'</span>&#13;
PS&gt; <span class="codestrong1">Get-ADGroup -Identity AdamBertramLovers | Remove-ADGroupMember-Members 'jjones'</span>&#13;
&#13;
    Confirm&#13;
Are you sure you want to perform this action?&#13;
Performing the operation "Set" on target&#13;
"CN=AdamBertramLovers,CN=Users,DC=lab,DC=local".&#13;
[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  &#13;
[?]&#13;
Help (default is "Y"): a</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_146"/>Add the <span class="literal">Force</span> parameter if you want to skip this check, but be aware that getting that confirmation may end up saving you one day!</p>&#13;
<h4 class="h4" id="ch11lev4sec6">Project 5: Creating an Employee Provisioning Script</h4>&#13;
<p class="noindent">Let’s bring this all together and tackle another real-world scenario. Your company has hired a new employee. You, the system administrator, now have to perform a series of actions: creating an AD user, creating their computer account, and adding them to specific groups. You’ll build a script that will automate this whole process.</p>&#13;
<p class="indent">But before you start this project—and really, any project—it’s important to figure out what the script will do and write down an informal definition. For this script, you need to create the AD user, which will:</p>&#13;
<ul>&#13;
<li><p class="noindent">Dynamically create a username for user based on the first name and last name</p></li>&#13;
<li><p class="noindent">Create and assign the user a random password</p></li>&#13;
<li><p class="noindent">Force the user to change their password at logon</p></li>&#13;
<li><p class="noindent">Set the department attribute based on the department given</p></li>&#13;
<li><p class="noindent">Assign the user an internal employee number</p></li>&#13;
</ul>&#13;
<p class="indent">Next, add the user account to a group with the same name as the department. Finally, add the user account into an organizational unit with the same name as the department the employee is in.</p>&#13;
<p class="indent">Now, with these requirements laid out, let’s build the script. The finished script will be called <em>New-Employee.ps1</em> and is available in the book’s resources.</p>&#13;
<p class="indent">You want this to be a reusable script. Ideally, anytime you have a new employee, you can use the script. This means you need to figure out a smart way to handle the inputs to the script. By looking at the requirements, you know you’ll need a first name, a last name, a department, and an employee number. <a href="ch11.xhtml#ch11list7">Listing 11-7</a> provides a script outline with all parameters defined and a <span class="literal">try/catch</span> block to catch any terminating errors you may encounter. The <span class="literal">#requires</span> statement is set at the top to ensure that whenever this script is run, it checks to see that the machine has the <span class="literal">ActiveDirectory</span> module installed.</p>&#13;
<pre>#requires -Module ActiveDirectory&#13;
&#13;
[CmdletBinding()]&#13;
param (&#13;
    [Parameter(Mandatory)]&#13;
    [string]$FirstName,&#13;
&#13;
    [Parameter(Mandatory)]&#13;
    [string]$LastName,&#13;
&#13;
    [Parameter(Mandatory)]&#13;
    [string]$Department,&#13;
&#13;
<span epub:type="pagebreak" id="page_147"/>    [Parameter(Mandatory)]&#13;
    [int]$EmployeeNumber&#13;
)&#13;
&#13;
try {&#13;
&#13;
} catch {&#13;
    Write-Error -Message $_.Exception.Message&#13;
}</pre>&#13;
<p class="caption" id="ch11list7"><em>Listing 11-7: Base</em> New-Employee.ps1 <em>script</em></p>&#13;
<p class="indent">Now that you created the base, let’s fill out the <span class="literal">try</span> block.</p>&#13;
<p class="indent">First, you need to create an AD user according to the requirements laid out in our informal definition. You have to <em>dynamically create</em> a username. There are several ways to do this: some organizations prefer the username to be the first initial and the last name, some prefer first name and last name, and some do something else entirely. Let’s say your company uses first initial and last name. If that username is taken, the next character in the first name is added until a unique username is found.</p>&#13;
<p class="indent">Let’s handle the base case first. You’ll use the built-in <span class="literal">Substring</span> method on every string object to get the first initial. You’ll then concatenate the last name to the first initial. You’ll do this by using <em>string formatting</em>, which allows you to define placeholders for multiple expressions in a string and replace the placeholders with values at runtime, like so:</p>&#13;
<pre>$userName = '{0}{1}' -f $FirstName.Substring(0, 1), $LastName</pre>&#13;
<p class="indent">After you create the initial username, you need to query AD to see whether this username is already taken by using <span class="literal">Get-ADUser</span>.</p>&#13;
<pre>Get-ADUser -Filter "samAccountName -eq '$userName'"</pre>&#13;
<p class="indent">If this command returns anything, the username is taken, and you need to try the next username. This means you need to figure out a way to dynamically generate new names, always being prepared for the possibility that the new username is taken. A good way to check for various usernames is a <span class="literal">while</span> loop conditioned on your previous call to <span class="literal">Get-ADUser</span>. But you’ll need another condition to account for what happens if you run out of letters in the first name. You don’t want the loop to run forever, so you’ll put in another condition, <span class="literal">$userName –notlike "$FirstName*"</span>, to stop the loop.</p>&#13;
<p class="indent">The <span class="literal">while</span> condition looks like this:</p>&#13;
<pre>(Get-ADUser -Filter "samAccountName -eq '$userName'") –and&#13;
($userName -notlike "$FirstName*")</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_148"/>With the <span class="literal">while</span> condition created, you can fill out the rest of the loop:</p>&#13;
<pre>$i = 2&#13;
while ((Get-ADUser -Filter "samAccountName -eq '$userName'") –and&#13;
($userName -notlike "$FirstName*")) {&#13;
    Write-Warning -Message "The username [$($userName)] already exists. Trying another..."&#13;
    $userName = '{0}{1}' -f $FirstName.Substring(0, $i), $LastName&#13;
    Start-Sleep -Seconds 1&#13;
    $i++&#13;
}</pre>&#13;
<p class="indent">For each iteration of the loop, you add an additional character from the first name to the proposed username by taking the substring of the first name from 0 to <span class="literal">i</span>, where <span class="literal">$i</span> is a counter variable that starts at 2 (the next position in the string) and is increased each time the loop runs. By the time this <span class="literal">while</span> loop finishes, it will have either found a unique username or exhausted all options.</p>&#13;
<p class="indent">If an existing username <em>isn’t</em> found, you’re clear to create the username you intended to. If a username <em>is</em> found, you have a few other things to check. You need to check whether the <em>organizational unit</em> <em>(OU)</em> and group you’re putting the user account into exists:</p>&#13;
<pre>if (-not ($ou = Get-ADOrganizationalUnit -Filter "Name –eq '$Department'")) {&#13;
    throw "The Active Directory OU for department [$($Department)] could not be found."&#13;
} elseif (-not (Get-ADGroup -Filter "Name -eq '$Department'")) {&#13;
    throw "The group [$($Department)] does not exist."&#13;
}</pre>&#13;
<p class="indent">Once you complete all the checks, you need to create the user account. Again, you have to consult our informal definition: <em>create and assign the user a</em> <em>random password</em>. You want to generate a random password every time this script runs. An easy way to generate a secure password is to use the <span class="literal">GeneratePassword</span> static method on the <span class="literal">System.Web.Security.Membership</span> object, as shown here:</p>&#13;
<pre>Add-Type -AssemblyName 'System.Web'&#13;
$password = [System.Web.Security.Membership]::GeneratePassword(&#13;
    (Get-Random Minimum 20 -Maximum 32), 3)&#13;
$secPw = ConvertTo-SecureString -String $password -AsPlainText -Force</pre>&#13;
<p class="indent">I chose to generate a password of at least 20 characters, with a maximum of 32, but this is completely configurable. If desired, you could also find AD’s minimum required password by running <span class="literal">Get-ADDefaultDomainPasswordPolicy | Select-object -expand minPasswordLength</span>. This method even allows you to specify the length and complexity of the new password.</p>&#13;
<p class="indent">Now that you have the password as a secure string, you have all the parameter values needed to create the user according to the requirements I laid out earlier.</p>&#13;
<pre><span epub:type="pagebreak" id="page_149"/>$newUserParams = @{&#13;
    GivenName             = $FirstName&#13;
    EmployeeNumber        = $EmployeeNumber&#13;
    Surname               = $LastName&#13;
    Name                  = $userName&#13;
    AccountPassword       = $secPw&#13;
    ChangePasswordAtLogon = $true&#13;
    Enabled               = $true&#13;
    Department            = $Department&#13;
    Path                  = $ou.DistinguishedName&#13;
    Confirm               = $false&#13;
}&#13;
New-ADUser @newUserParams</pre>&#13;
<p class="indent">After you make the user, all that’s left is to add them to the department group, which you can do with a simple <span class="literal">Add-ADGroupMember</span> command:</p>&#13;
<pre>Add-ADGroupMember -Identity $Department -Members $userName</pre>&#13;
<p class="indent">Be sure to check out the <em>New-Employee.ps1</em> script in the book’s resources to get a copy of the full implementation of this script.</p>&#13;
<h3 class="h3" id="ch11lev5">Syncing from Other Data Sources</h3>&#13;
<p class="noindent">Active Directory, especially when used in large enterprises, can contain millions of objects being created and modified by dozens of people every day. With all that activity and all those inputs, problems are bound to arise. One of the biggest you’ll run into is keeping the AD database synced up with the rest of the organization.</p>&#13;
<p class="indent">A company’s AD should be organized the same way the company is organized. This might mean that every department has its own associated AD group, every physical office its own OU, and so on. Regardless, as system administrators, we have the difficult task of ensuring that AD is always in sync with the rest of the organization. This is a great task for PowerShell.</p>&#13;
<p class="indent">Using PowerShell, you can “link” AD with just about any other source of information, meaning you can have PowerShell continually reading external data sources and making the appropriate changes to AD as necessary to create a sync process.</p>&#13;
<p class="indent">This syncing process, when triggered, roughly consists of the following six steps:</p>&#13;
<ol>&#13;
<li><p class="noindent">Query the external data source (SQL database, CSV file, and so forth).</p></li>&#13;
<li><p class="noindent">Retrieve objects from AD.</p></li>&#13;
<li><p class="noindent">Find each object in the source that AD has a unique attribute to match on. This is usually referred to as an <em>ID</em>. The ID can be an employee ID or even usernames. The only thing that matters is that the attribute is unique. If no match is found, optionally create or remove the object from AD based on the source.</p></li>&#13;
<li><p class="noindent"><span epub:type="pagebreak" id="page_150"/>Find a single matching object.</p></li>&#13;
<li><p class="noindent">Map all external data sources to AD object attributes.</p></li>&#13;
<li><p class="noindent">Modify existing AD objects or create new ones.</p></li>&#13;
</ol>&#13;
<p class="indent">You’ll put this plan into action in the next section.</p>&#13;
<h4 class="h4" id="ch11lev5sec7">Project 6: Creating a Syncing Script</h4>&#13;
<p class="noindent">In this section, you’ll learn how to build a script that’ll sync employees from a CSV file to AD. To do so, you’ll have to draw on some of the commands you learned in <a href="ch10.xhtml#ch10">Chapter 10</a>, as well as those you just learned in the previous lessons of this chapter. Before we get started, I encourage you to glance at <em>Employees.csv</em> and <em>Invoke-AdCsvSync.ps1</em> in the book’s resources and familiarize yourself with the project files.</p>&#13;
<p class="indent">The key to building a great AD sync tool is sameness. By this, I don’t mean the data sources should be the same—since, technically, they never will be—but instead that you need to create a script that can query each datastore the same way and have each datastore return the same kind of object. The tricky part of this occurs when you have two sources that use different schemas. In that case, you may have to start doing some translation by mapping one field name to another (as you’ll do later in the chapter).</p>&#13;
<p class="indent">Consider this: you already know that AD has common attributes associated with each user account—things like first name, last name, and department, which we’ll call a <em>schema</em> of attributes. However, chances are the source datastore you’d like to sync with will never have the exact same attributes. And even if it has the same attributes, it might know them by different names. To resolve this issue, you have to build a mapping between the two datastores.</p>&#13;
<h4 class="h4" id="ch11lev5sec8">Mapping Data Source Attributes</h4>&#13;
<p class="noindent">An easy, effective way to create this mapping is to use a hashtable in which the key is the attribute name in the first datastore, and the value is the attribute name in the second datastore. To see this in action, let’s say you work at a company called Acme. Acme wants to sync employee records from a CSV file into AD. Specifically, they want to sync <em>Employees.csv</em>, which you can find in the book’s resources or here:</p>&#13;
<pre>"fname","lname","dept"&#13;
"Adam","Bertram","IT"&#13;
"Barack","Obama","Executive Office"&#13;
"Miranda","Bertram","Executive Office"&#13;
"Michelle","Obama","Executive Office"</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_151"/>Given that you know the headers of the CSV, and the property names in AD, you can build a mapping hashtable with the value for the CSV field as the key and the AD attribute name as the value:</p>&#13;
<pre>$syncFieldMap = @{   &#13;
    fname = 'GivenName'&#13;
    lname = 'Surname'   &#13;
    dept = 'Department'&#13;
}</pre>&#13;
<p class="indent">This will handle the conversion between the two datastore schemas. But you also need a unique ID for each employee. As of right now, there is no unique ID to match to an AD object in each row of the CSV. You could have more than one Adam, more than one person in the IT department, or more than one person with the last name of Bertram, for example. This means you’ll have to generate your own unique ID. To make things easier, assume that no two employees have the same first and last name. Otherwise, the ID to create will probably be dependent on your own organizational schema. With that assumption, you can simply concatenate each datastore’s respective first- and last-name fields to create a temporary unique ID.</p>&#13;
<p class="indent">You’ll represent this unique ID in another hashtable. You haven’t handled the concatenation just yet, but you’ve set up the infrastructure to do so:</p>&#13;
<pre>$fieldMatchIds = @{&#13;
    AD = @('givenName','surName')&#13;
    CSV = @('fname','lname')&#13;
}</pre>&#13;
<p class="indent">Now that you created a way to map different fields together, you can incorporate that code into a couple of functions to “force” two datastores to return the same properties, allowing an apples-to-apples comparison.</p>&#13;
<h4 class="h4" id="ch11lev5sec9">Creating Functions to Return Similar Properties</h4>&#13;
<p class="noindent">Now that you have the hashtables, you need to translate field names and build unique IDs. You can create a function that’ll query our CSV file and output both attributes that AD understands, and a property you can use to match both datastores. To do that, you’ll create a function called <span class="literal">Get-Acme</span><span class="literal">EmployeeFromCsv</span> that looks like <a href="ch11.xhtml#ch11list8">Listing 11-8</a>. I’ve assigned the <span class="literal">CsvFilePath</span> parameter’s value to <em>C:\Employees.csv</em>, assuming that our CSV is located there:</p>&#13;
<pre>function Get-AcmeEmployeeFromCsv&#13;
{    &#13;
[CmdletBinding()]&#13;
    param (&#13;
        [Parameter()]&#13;
        [string]$CsvFilePath = 'C:\Employees.csv',&#13;
        [Parameter(Mandatory)]&#13;
        [hashtable]$SyncFieldMap,&#13;
<span epub:type="pagebreak" id="page_152"/>        [Parameter(Mandatory)]&#13;
        [hashtable]$FieldMatchIds&#13;
    )&#13;
    try {&#13;
        ## Read each key/value pair in $SyncFieldMap to create calculated&#13;
        ## fields which we can pass to Select-Object later. This allows us to&#13;
        ## return property names that match Active Directory attributes rather&#13;
        ## than what's in the CSV file.&#13;
     <span class="ent">❶</span> $properties = $SyncFieldMap.GetEnumerator() | ForEach-Object {&#13;
            @{&#13;
                Name = $_.Value&#13;
                Expression = [scriptblock]::Create("`$_.$($_.Key)")&#13;
            }&#13;
        }&#13;
        ## Create the unique ID based on the unique fields defined in&#13;
        ## $FieldMatchIds&#13;
     <span class="ent">❷</span> $uniqueIdProperty = '"{0}{1}" -f '&#13;
        $uniqueIdProperty = $uniqueIdProperty += &#13;
        ($FieldMatchIds.CSV | ForEach-Object { '$_.{0}' -f $_ }) – join ','&#13;
        $properties += @{&#13;
            Name = 'UniqueID'&#13;
            Expression = [scriptblock]::Create($uniqueIdProperty)&#13;
        }&#13;
        ## Read the CSV file and "transform" the CSV fields to AD attributes&#13;
        ## so we can compare apples to apples&#13;
     <span class="ent">❸</span> Import-Csv -Path $CsvFilePath | Select-Object – Property $properties&#13;
    } catch {&#13;
        Write-Error -Message $_.Exception.Message&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch11list8"><em>Listing 11-8: The <span class="literal">Get-AcmeEmployeeFromCsv</span> function</em></p>&#13;
<p class="indent">This function works in three broad steps: first, map the properties of the CSV to AD properties <span class="ent">❶</span>; next, create a unique ID and make that a property <span class="ent">❷</span>; last, read in the CSV and use <span class="literal">Select-Object</span> and a calculated property to return the properties you need <span class="ent">❸</span>.</p>&#13;
<p class="indent">As you can see in the following code, you can pass the <span class="literal">$syncFieldMap</span> hashtable and the <span class="literal">$fieldMatchIds</span> hashtable to your new <span class="literal">Get-AcmeEmployeeFromCsv</span> function, which you can use to return property names that’ll sync up with the Active Directory attributes as well as with your new unique ID:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-AcmeEmployeeFromCsv -SyncFieldMap $syncFieldMap</span> &#13;
<span class="codestrong1">-FieldMatchIds $fieldMatchIds</span>&#13;
&#13;
GivenName Department       Surname UniqueID&#13;
--------- ----------       ------- --------&#13;
Adam      IT               Bertram AdamBertram&#13;
Barack    Executive Office Obama   BarackObama&#13;
Miranda   Executive Office Bertram MirandaBertram&#13;
Michelle  Executive Office Obama   MichelleObama</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_153"/>Now you have to build a function that will query from AD. Thankfully, this time around you don’t have to convert any property names because the AD property names are your common set. All you’ll be doing in this function is calling <span class="literal">Get-ADUser</span>, and making sure you return the properties you need, as shown in <a href="ch11.xhtml#ch11list9">Listing 11-9</a>.</p>&#13;
<pre>function Get-AcmeEmployeeFromAD&#13;
{&#13;
    [CmdletBinding()]&#13;
    param (&#13;
        [Parameter(Mandatory)]&#13;
        [hashtable]$SyncFieldMap,&#13;
&#13;
        [Parameter(Mandatory)]&#13;
        [hashtable]$FieldMatchIds&#13;
    )&#13;
&#13;
    try {&#13;
        $uniqueIdProperty = '"{0}{1}" -f '&#13;
        $uniqueIdProperty += ($FieldMatchIds.AD | ForEach Object { '$_.{0}' -f $_ }) -join ','&#13;
&#13;
        $uniqueIdProperty = @{ <span class="ent">❶</span>&#13;
            Name = 'UniqueID'&#13;
            Expression = [scriptblock]::Create($uniqueIdProperty)&#13;
        }&#13;
&#13;
        Get-ADUser -Filter * -Properties @($SyncFieldMap.Values) | Select-Object *,$uniqueIdProperty <span class="ent">❷</span>&#13;
&#13;
    } catch {&#13;
        Write-Error -Message $_.Exception.Message&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch11list9"><em>Listing 11-9: The <span class="literal">Get-AcmeEmployeeFromAD</span> function</em></p>&#13;
<p class="indent">Again, I’ll highlight the broad strokes of this code: first, create the unique ID to perform the matches on <span class="ent">❶</span>; then, query the AD users and return only the values in the field map hashtable, also returning the unique ID that you created earlier <span class="ent">❷</span>.</p>&#13;
<p class="indent">When you run this, you’ll see that it returns the AD user accounts with the appropriate properties and your unique ID property.</p>&#13;
<h4 class="h4" id="ch11lev5sec10">Finding Matches in Active Directory</h4>&#13;
<p class="noindent">You now have two similar functions that pull information from your datastores and return the same property names. The next move is to find all the matches between our CSV and AD. To make this easier, you’ll use the code in <a href="ch11.xhtml#ch11list10">Listing 11-10</a> to create another function called <span class="literal">Find-UserMatch</span> that’ll execute both of these functions and gather both sets of data. Once it has the data, it will look for a match on the <span class="literal">UniqueID</span> field.</p>&#13;
<pre><span epub:type="pagebreak" id="page_154"/>function Find-UserMatch {&#13;
    [OutputType()]&#13;
    [CmdletBinding()]&#13;
    param&#13;
    (&#13;
        [Parameter(Mandatory)]&#13;
        [hashtable]$SyncFieldMap,&#13;
&#13;
        [Parameter(Mandatory)]&#13;
        [hashtable]$FieldMatchIds &#13;
    )&#13;
    $adusers = Get-AcmeEmployeeFromAD -SyncFieldMap $SyncFieldMap -FieldMatchIds $FieldMatchIds <span class="ent">❶</span>&#13;
&#13;
    $csvUsers = Get-AcmeEmployeeFromCSV -SyncFieldMap $SyncFieldMap -FieldMatchIds $FieldMatchIds <span class="ent">❷</span>&#13;
&#13;
    $adUsers.foreach({&#13;
        $adUniqueId = $_.UniqueID&#13;
        if ($adUniqueId) { <span class="ent">❸</span>&#13;
            $output = @{&#13;
                CSVProperties = 'NoMatch'&#13;
                ADSamAccountName = $_.samAccountName&#13;
            }&#13;
            if ($adUniqueId -in $csvUsers.UniqueId) { <span class="ent">❹</span>&#13;
                $output.CSVProperties = ($csvUsers.Where({$_.UniqueId -eq $adUniqueId})) <span class="ent">❺</span>&#13;
            }&#13;
            [pscustomobject]$output&#13;
        }&#13;
    })&#13;
}</pre>&#13;
<p class="caption" id="ch11list10"><em>Listing 11-10: Finding user matches</em></p>&#13;
<p class="indent">Let’s walk through this code. First, get a list of users from AD <span class="ent">❶</span>; then, get a list of users from our CSV <span class="ent">❷</span>. For each user from AD, check whether the <span class="literal">UniqueID</span> property was populated <span class="ent">❸</span>. If it was, check whether a match was found between the CSV and AD users <span class="ent">❹</span>, and if so, in our custom object, create a property called <span class="literal">CSVProperties</span> that contains all the properties associated with the matched user <span class="ent">❺</span>.</p>&#13;
<p class="indent">If a match is found, the function will return the AD user’s <span class="literal">samAccountName</span> and all of its CSV properties; otherwise, it will return <span class="literal">NoMatch</span>. Returning the <span class="literal">samAccountName</span> gives you a unique ID in AD, which allows you to look up this user later.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Find-UserMatch -SyncFieldMap $syncFieldMap -FieldMatchIds $fieldMatchIds</span>&#13;
&#13;
ADSamAccountName CSVProperties&#13;
---------------- -------------&#13;
user             NoMatch&#13;
abertram         {@{GivenName=Adam; Department=IT;&#13;
                 Surname=Bertram; UniqueID=AdamBertram}}&#13;
dbddar           NoMatch&#13;
jjones           NoMatch&#13;
BSmith           NoMatch</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_155"/>At this point, you have a function that allows you to find 1:1 matches between your AD data and your CSV data. You’re now ready to begin the gratifying (yet scary) work of making bulk changes to AD!</p>&#13;
<h4 class="h4" id="ch11lev5sec11">Changing Active Directory Attributes</h4>&#13;
<p class="noindent">Now you have a way to find out which CSV row pertains to which AD user account. You can use the <span class="literal">Find-UserMatch</span> function to find the AD user by their unique ID, and then update its AD information to match the data in the CSV, as shown in <a href="ch11.xhtml#ch11list11">Listing 11-11</a>.</p>&#13;
<pre>## Find all of the CSV &lt;--&gt; AD user account matches&#13;
$positiveMatches = (Find-UserMatch -SyncFieldMap $syncFieldMap -FieldMatchIds $fieldMatchIds).where({ $_.CSVProperties -ne 'NoMatch' })&#13;
foreach ($positiveMatch in $positiveMatches) {&#13;
    ## Create the splatting parameters for Set-ADUser using&#13;
    ## the identity of the AD samAccountName&#13;
    $setADUserParams = @{&#13;
        Identity = $positiveMatch.ADSamAccountName&#13;
    }&#13;
&#13;
    ## Read each property value that was in the CSV file&#13;
    $positiveMatch.CSVProperties.foreach({&#13;
        ## Add a parameter to Set-ADUser for all of the CSV&#13;
        ## properties excluding UniqueId&#13;
        ## Find all of the properties on the CSV row that are NOT UniqueId&#13;
        $_.PSObject.Properties.where({ $_.Name –ne 'UniqueID' }).foreach({&#13;
            $setADUserParams[$_.Name] = $_.Value&#13;
        })&#13;
    })&#13;
    Set-ADUser @setADUserParams&#13;
}</pre>&#13;
<p class="caption" id="ch11list11"><em>Listing 11-11: Syncing CSV to AD attributes</em></p>&#13;
<p class="indent">Quite a bit of work goes into creating a robust and flexible AD syncing script. Along the way, you’ll encounter tons of little details and hiccups, especially when you’re building even more complicated scripts.</p>&#13;
<p class="indent">We’ve only scratched the surface of syncing with PowerShell. If you want to see just how much you can do with this concept, check out the <span class="literal">PSADSync</span> module in the PowerShell Gallery (<span class="literal">Find-Module PSADSync</span>). This module was built specifically for the task we had here, but handles considerably more complex cases. If you felt a little lost during this exercise, I highly encourage you to go over the code again—as many times as it takes. The only true way to learn PowerShell is to experiment! Run the code, see it break, fix it yourself, and try again.</p>&#13;
<h3 class="h3" id="ch11lev6"><span epub:type="pagebreak" id="page_156"/>Summary</h3>&#13;
<p class="noindent">In this chapter, you familiarized yourself with the <span class="literal">ActiveDirectory</span> PowerShell module. You learned how to create and update users, computers, and groups in AD. Through a couple of real-world examples, you saw how to use PowerShell to automate tedious Active Directory work.</p>&#13;
<p class="indent">In the next two chapters, we’re going to the cloud! We’ll continue our journey of automating all the things and look at automating some common tasks done both in Microsoft Azure and in Amazon Web Services (AWS).</p>&#13;
</body></html>