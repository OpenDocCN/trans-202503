["```\ndef memcmp_consttime(c1, c2, num):\n    # Accumulate differing bits in diff\n    diff = 0\n    for i in range(num):\n        # If bits differ, the xor is nonzero, therefore diff will be nonzero\n        diff = diff | (c1[i] ^ c2[i])\n    return diff\n```", "```\nif secret == 0xCA:\n    res = takesLong()\nelse:\n    res = muchShorter()\n```", "```\ndef dontLeakSecret(secret):\n    # Run both sides of the if() condition\n    res1 = takesLong()\n    res2 = muchShorter()\n    # Mask is either all bits 0 or all bits 1, depending on if() condition\n    mask = int(secret == 0xCA) - 1 \n    res = (res1 & ~mask) | (res2 & mask) # Use mask to select one value return res\n    return res\n```", "```\nif verify_signature(new_code_array):\n    erase_and_flash(new_code_array)\n```", "```\ndef memcmp_nontrivial(c1, c2, num):\n    # Prep decoy values, initialize to 0\n    decoy1 = bytes(len(c1))\n    decoy2 = bytes(len(c2))\n\n    # Init diff accumulator and random starting point\n    diff = 0\n    rnd = random.randint(0, num-1)\n\n    i = 0 \n while i < num:\n        # Get index, wrap around if needed\n        idx = (i + rnd) % num\n\n        # Flip coin to check we have a decoy round\n        do_decoy = random.random() < DECOY_PROBABILITY\n        if do_decoy:\n            decoy = (CONST1 | decoy1[idx]) ^ (CONST2 | decoy2[idx]) # Do similar operation\n            tmpdiff = CONST1 | CONST2 # Set tmpdiff so we still have nontrivial consts\n        else: \n            tmpdiff = (CONST1 | c1[idx]) ^ (CONST2 | c2[idx]) # Real operation, put in tmpdiff\n            decoy = CONST1 | CONST2 # Just to mimic other branch \n\n        # Accumulate diff \n        diff = diff | tmpdiff \n\n        # Adjust index if not a decoy \n        i = i + int(not do_decoy) \n\nreturn diff\n```", "```\nSECURE_OK = 0xc001bead\ndef check_fw(a, s, fault_skip):\n  1 rv = validate_address(a) \n    if rv == SECURE_OK: \n      2 rv = validate_signature(s) \n\n        if rv == SECURE_OK: \n            print(\"Firmware ok. Flashing!\")\n```", "```\n 1 bl      signature_ok(IMG_PTR)\n        mov     r3, r0\n        cmp     r3, #0\n        movne   r3, #1\n        moveq   r3, #0\n        and     r3, r3, #255\n        cmp     r3, #0\n      2 beq     .L2\n        ldr     r0, [fp, #-8]\n      3 bl      boot_image(IMG_PTR)\n        b       .L3\n.L2:\n      4 bl      panic()\n.L3:\n        nop\n```", "```\ndef double_check_wait(input, secret):\n    # Check result\n    result = memcmp(input, secret, len(input))\n\n    if result == 0:\n        # Random wait\n        wait = random.randint(0,3)\n        for i in range(wait):\n            None \n\n        # This is also a good point to insert some not-so-sensitive other operations\n        # Just to decouple the random wait loop from the sensitive operation\n\n        # Do memcmp again\n        result2 = memcmp(input, secret, len(input))\n\n        # Double check with some different logic\n        if not result2 ^ 0xff != 0xff:\n            print(\"Access granted, my liege\")\n        else: \n            print(\"Fault2 detected!\") 1\n```"]