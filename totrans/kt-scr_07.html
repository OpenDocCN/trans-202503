<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><section aria-labelledby="ch5" epub:type="chapter" role="doc-chapter">
<span aria-label="175" epub:type="pagebreak" id="pg_175" role="doc-pagebreak"/>
<hgroup>
<h2 class="title" id="ch5">
<span class="tpt"><span class="sans_dogma_ot_bold_b_">5</span></span>
<span class="ct"><span class="sans_dogma_ot_bold_b_">MODELING AND SIMULATION</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener1" height="380" src="../images/icon.jpg" width="381"/>
</figure>
<p class="chapterintro">In this chapter, we’ll venture into several mini science projects that will further strengthen your coding abilities in Kotlin. In addition, the mini projects of this chapter will enhance your problem-solving skills by showing how to apply basic laws of nature and mathematics to solve problems that are very difficult to answer without the help of a computer.</p>
<p class="tx">Since visualization is a key part of scientific investigation, we’ll also use the graphics templates we developed in <span><a href="chapter3.xhtml" class="calibre2">Chapter 3</a></span> to visualize our program outputs.</p>
<p class="headaexercise" id="pre-17"><span class="sans_dogma_ot_bold_b_15-n">Project 17: Predict the Flight of a Cannonball</span></p>
<p class="tni">Imagine an old castle surrounded by thick defensive walls. The walls have notches where vigilant soldiers stand ready to fire cannons on any <span aria-label="176" epub:type="pagebreak" id="pg_176" role="doc-pagebreak"/>encroaching enemy. Typically, a castle is located on high ground to allow for better visibility over the surrounding area, and the cannons themselves are placed at a higher elevation relative to the base of the castle to maximize their firing range. Within that range, the soldiers can hit targets at a variety of distances by adjusting parameters of the cannon. Our question is, how can the soldiers aim a cannon to hit a target on the ground <i class="calibre9">x</i> distance away?</p>
<p class="tx">Assuming no air resistance for now and assuming that the impact of wind is negligible, the distance a cannonball travels is affected by three factors: the cannon’s height above ground level, its angle of fire, and the exit velocity of the cannonball. The soldiers can’t easily change the height of the cannon or the exit velocity of the cannonball, but they can adjust the angle of fire, so that’s where we’ll focus our efforts. <a href="chapter5.xhtml#fig5-1" class="calibre2">Figure 5-1</a> diagrams the nature of the problem.</p>
<figure class="img"><img alt="" class="img2" height="626" id="fig5-1" src="../images/Figure5-1.jpg" width="1096"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 5-1: The path of a cannonball</span></p></figcaption>
</figure>
<p class="tx">The cannonball is fired from point A, which has an elevation of H<sub class="calibre19">0</sub> relative to the ground surface, and the goal is to hit point B. The exit velocity of the cannonball is <i class="calibre9">v</i><sub class="calibre19">0</sub>, and its angle of fire is <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>.</p>
<p class="tx">Once the cannonball is fired, it becomes a <i class="calibre9">projectile</i>, an object in motion that has only one force acting upon it: gravity. To arrive at the correct value for <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>, we need to know a little bit about the science of projectiles. First, let’s assume that the cannonball is moving in only two dimensions: horizontally and vertically. We’ll place the origin of this two-dimensional coordinate system at point A. Given the initial velocity of the ball <i class="calibre9">v</i><sub class="calibre19">0</sub>, which is projected at an angle <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>, we can write the corresponding x- and y-components of the initial velocity as:</p>
<p class="equation"><i class="calibre9">v</i><sub class="calibre19">0</sub><span class="epub-i-sub">x</span> = <i class="calibre9">v</i><sub class="calibre19">0</sub> cos<i class="calibre9"><span lang="el" xml:lang="el">θ</span></i></p>
<p class="equation"><i class="calibre9">  v</i><sub class="calibre19">0</sub><span class="epub-i-sub">y</span> = <i class="calibre9">v</i><sub class="calibre19">0</sub> sin<i class="calibre9"><span lang="el" xml:lang="el">θ</span></i></p>
<p class="tx">These velocity components tell us how fast the ball will be traveling in the horizontal and vertical directions solely due to its initial velocity. Again, disregarding the effects of air or wind resistance, no other force is acting <span aria-label="177" epub:type="pagebreak" id="pg_177" role="doc-pagebreak"/>on the ball horizontally. Therefore, we could say that the velocity in the x-direction, <i class="calibre9">v</i><span class="epub-i-sub">x</span>, remains constant:</p>
<p class="equation"><i class="calibre9">  v</i><span class="epub-i-sub">x</span> = <i class="calibre9">v</i><sub class="calibre19">0</sub><span class="epub-i-sub">x</span> = <i class="calibre9">v</i><sub class="calibre19">0</sub> cos<i class="calibre9"><span lang="el" xml:lang="el">θ</span></i></p>
<p class="tni">In the vertical direction, however, the acceleration due to gravity will slow the ball’s rise and eventually bring it down to the ground. Thus, we can express the resultant velocity in the y-direction, <i class="calibre9">v</i><span class="epub-i-sub">y</span>, as:</p>
<p class="equation"><i class="calibre9">  v</i><span class="epub-i-sub">y</span> = <i class="calibre9">v</i><sub class="calibre19">0</sub><span class="epub-i-sub">y</span> − <i class="calibre9">g t</i> = <i class="calibre9">v</i><sub class="calibre19">0</sub> sin<i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> − <i class="calibre9">g t</i></p>
<p class="tni">Here <i class="calibre9">g</i> is the acceleration due to gravity, and <i class="calibre9">t</i> is time.</p>
<p class="tx">Using these expressions for <i class="calibre9">v</i><span class="epub-i-sub">x</span> and <i class="calibre9">v</i><span class="epub-i-sub">y</span>, we can write the <i class="calibre9">displacement equations</i> for the projectile, which express its x- and y-coordinates, or how far the ball has traveled horizontally and vertically, as of a given time <i class="calibre9">t</i>:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>x</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><msub><mi>v</mi><mn>0</mn></msub><mtext> </mtext><mi>cos</mi><mi>θ</mi><mtext> </mtext><mi>t</mi></mrow></math> (5.1)<span class="sblock"/><math alttext="Equation" display="inline"><mrow><mi>y</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><mfenced><mrow><msub><mi>v</mi><mn>0</mn></msub><mi>sin</mi><mi>θ</mi></mrow></mfenced><mtext> </mtext><mi>t</mi><mtext> </mtext><mo>−</mo><mtext> </mtext><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>g</mi><msup><mi>t</mi><mn>2</mn></msup></mrow></math> (5.2)</span>
<span class="mobi"><img alt="" class="img1" height="142" src="../images/eq5-1-2.jpg" width="1383"/></span></figure>
<p class="tx">If we now assume that the time to reach the target at point B is <i class="calibre9">t</i><sub class="calibre19">B</sub>, then the horizontal distance to the target is:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msub><mi>x</mi><mtext>B</mtext></msub><mtext> </mtext><mo>=</mo><mtext> </mtext><msub><mi>v</mi><mn>0</mn></msub><mtext> </mtext><mi>cos</mi><mi>θ</mi><mtext> </mtext><msub><mi>t</mi><mtext>B</mtext></msub></mrow></math> (5.3)</span>
<span class="mobi"><img alt="" class="img1" height="43" src="../images/eq5-3.jpg" width="1383"/></span></figure>
<p class="tx">Over the same time period <i class="calibre9">t</i><sub class="calibre19">B</sub>, the projectile will also move vertically. It will pass through point C (shown in <a href="chapter5.xhtml#fig5-1" class="calibre2">Figure 5-1</a>, the ball’s highest elevation, at <i class="calibre9">H</i> + H<sub class="calibre19">0</sub>) and then free-fall to the ground while continuing to move horizontally at velocity <i class="calibre9">v</i><span class="epub-i-sub">x</span>. When the projectile reaches point B (meaning it hits the target), its net vertical displacement <i class="calibre9">y</i><sub class="calibre19">B</sub> will be −H<sub class="calibre19">0</sub>, which can be expressed using Equation 5.2 as:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mo>−</mo><msub><mtext>H</mtext><mn>0</mn></msub><mtext> </mtext><mo>=</mo><mtext> </mtext><mfenced><mrow><msub><mi>v</mi><mn>0</mn></msub><mtext> </mtext><mi>sin</mi><mi>θ</mi></mrow></mfenced><mtext> </mtext><msub><mi>t</mi><mtext>B</mtext></msub><mtext> </mtext><mo>−</mo><mtext> </mtext><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>g</mi><msub><mi>t</mi><mtext>B</mtext></msub><msup><mrow/><mn>2</mn></msup></mrow></math> (5.4)</span>
<span class="mobi"><img alt="" class="img1" height="71" src="../images/eq5-4.jpg" width="1383"/></span></figure>
<p class="tx">We don’t actually know how long it will take the cannonball to reach the target, however, so we need a way to express <i class="calibre9">t</i><sub class="calibre19">B</sub> in terms of the other variables. Equation 5.4 is a <i class="calibre9">quadratic equation</i>, where the highest power of a variable is 2. It can be solved for the positive value of <i class="calibre9">t</i><sub class="calibre19">B</sub> as:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msub><mi>t</mi><mtext>B</mtext></msub><mo>=</mo><mtext> </mtext><mfrac><mn>1</mn><mi>g</mi></mfrac><mtext> </mtext><mfenced><mrow><msub><mi>v</mi><mn>0</mn></msub><mi>sin</mi><mi>θ</mi><mtext> </mtext><mo>+</mo><mtext> </mtext><msqrt><mrow><msup><mrow><mfenced><mrow><msub><mi>v</mi><mn>0</mn></msub><mi>sin</mi><mi>θ</mi></mrow></mfenced></mrow><mn>2</mn></msup><mtext> </mtext><mo>+</mo><mtext> </mtext><mn>2</mn><mi>g</mi><msub><mtext>H</mtext><mn>0</mn></msub></mrow></msqrt></mrow></mfenced></mrow></math> (5.5)</span>
<span class="mobi"><img alt="" class="img1" height="80" src="../images/eq5-5.jpg" width="1383"/></span></figure>
<p class="tx">We can now use Equation 5.5 to substitute for <i class="calibre9">t</i><sub class="calibre19">B</sub> in Equation 5.3, which gives us the following equation for <i class="calibre9">x</i><sub class="calibre19">B</sub> as a function of <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msub><mi>x</mi><mtext>B</mtext></msub><mo>=</mo><mtext> </mtext><mfrac><mrow><msub><mi>v</mi><mn>0</mn></msub><mi>cos</mi><mi>θ</mi></mrow><mi>g</mi></mfrac><mtext> </mtext><mfenced><mrow><msub><mi>v</mi><mn>0</mn></msub><mi>sin</mi><mi>θ</mi><mtext> </mtext><mo>+</mo><mtext> </mtext><msqrt><mrow><msup><mrow><mfenced><mrow><msub><mi>v</mi><mn>0</mn></msub><mi>sin</mi><mi>θ</mi></mrow></mfenced></mrow><mn>2</mn></msup><mo>+</mo><mtext> </mtext><mn>2</mn><mi>g</mi><msub><mtext>H</mtext><mn>0</mn></msub></mrow></msqrt></mrow></mfenced></mrow></math> (5.6)</span>
<span class="mobi"><img alt="" class="img1" height="93" src="../images/eq5-6.jpg" width="1383"/></span></figure>
<p class="tx">This equation establishes a relationship between the distance to the target <i class="calibre9">x</i><sub class="calibre19">B</sub> and the firing angle <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>, but it still doesn’t allow us to calculate <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> for a given <i class="calibre9">x</i><sub class="calibre19">B</sub>. What we need is an equation that expresses <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> in terms of <i class="calibre9">x</i><sub class="calibre19">B</sub>, not the other way around.</p>
<p class="tx"><span aria-label="178" epub:type="pagebreak" id="pg_178" role="doc-pagebreak"/>We have two options to resolve this situation. One is analytical, involving rearranging Equation 5.6 and deriving an expression for <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> in terms of <i class="calibre9">x</i><sub class="calibre19">B</sub>. It can be done, but it would require a significant amount of mathematical juggling. The other option is to use a <i class="calibre9">numerical method</i>, which involves solving the problem through an iterative process following an algorithm. A numerical method is also an approximate method, meaning it won’t produce the exact same solution as the theoretical one. However, we can choose the desired degree of precision, and often that’s close enough. In fact, for many real-world problems of this nature, we may not have any known theoretical solution, in which case a numerical method is the only viable option for solving the problem. This is why we’ll use a numerical method to answer our cannonball question.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="h1"><span id="sec1"/><span id="h2-83"/><span class="sans_futura_std_bold_condensed_oblique_">The Strategy</span></h3>
<p class="tni">We need to take one additional step to make the problem amenable to a numerical method: getting <i class="calibre9">x</i><sub class="calibre19">B</sub> onto the right-hand side of Equation 5.6 and turning it into a function of <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>. In other words, we’ll define function <i class="calibre9">f</i>(<i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>) as:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>f</mi><mtext/><mfenced><mi>θ</mi></mfenced><mo>=</mo><mtext> </mtext><msub><mi>x</mi><mtext>B</mtext></msub><mtext> </mtext><mo>−</mo><mtext> </mtext><mfrac><mrow><msub><mi>v</mi><mn>0</mn></msub><mi>cos</mi><mi>θ</mi></mrow><mi>g</mi></mfrac><mfenced><mrow><msub><mi>v</mi><mn>0</mn></msub><mi>sin</mi><mi>θ</mi><mtext> </mtext><mo>+</mo><mtext> </mtext><msqrt><mrow><msup><mrow><mfenced><mrow><msub><mi>v</mi><mn>0</mn></msub><mi>sin</mi><mi>θ</mi></mrow></mfenced></mrow><mn>2</mn></msup><mo>+</mo><mtext> </mtext><mn>2</mn><mi>g</mi><msub><mtext>H</mtext><mn>0</mn></msub></mrow></msqrt></mrow></mfenced></mrow></math> (5.7)</span>
<span class="mobi"><img alt="" class="img1" height="93" src="../images/eq5-7.jpg" width="1392"/></span></figure>
<p class="tx">To solve our cannonball problem, we now need to find a value of the independent variable <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> that, for a given value of <i class="calibre9">x</i><sub class="calibre19">B</sub>, will make the right-hand side of Equation 5.7 equal to zero. In mathematical terms, this value is known as the <i class="calibre9">root</i> of the function. We’ve turned the projectile problem into a root-finding problem.</p>
<p class="tx">We could use a number of methods to find the root for Equation 5.7. In this case, we’ll use a simple method called <i class="calibre9">bisection</i>, as illustrated in <a href="chapter5.xhtml#fig5-2" class="calibre2">Figure 5-2</a>.</p>
<figure class="img"><img alt="" class="img2" height="586" id="fig5-2" src="../images/Figure5-2.jpg" width="1011"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 5-2: The elements of the bisection method for root finding</span></p></figcaption>
</figure>
<p class="tx">Let’s assume we’re trying to find the root of a simple linear function <i class="calibre9">f</i>(<i class="calibre9">x</i>), which is a continuous function of variable <i class="calibre9">x</i>, as shown in <a href="chapter5.xhtml#fig5-2" class="calibre2">Figure 5-2</a>. The root is the value of <i class="calibre9">x</i> that makes the function equal zero. Here are the simple bisection steps for finding the root <i class="calibre9">x*</i> so that <i class="calibre9">f</i>(<i class="calibre9">x*</i>) = 0:</p>
<p class="listnumber"><span aria-label="179" epub:type="pagebreak" id="pg_179" role="doc-pagebreak"/>  1.  Locate two values <span class="copyright_italic">x</span><sub class="calibre19">1</sub> and <span class="copyright_italic">x</span><sub class="calibre19">2</sub> such that they are on the opposite side of the root, meaning <span class="copyright_italic">f</span>(<span class="copyright_italic">x</span><sub class="calibre19">1</sub>) &lt; 0 and <span class="copyright_italic">f</span>(<span class="copyright_italic">x</span><sub class="calibre19">2</sub>) &gt; 0.</p>
<p class="listnumber1">  2.  Find the midpoint <span class="copyright_italic">x</span> between <span class="copyright_italic">x</span><sub class="calibre19">1</sub> and <span class="copyright_italic">x</span><sub class="calibre19">2</sub> such that <span class="copyright_italic">x =</span> (<span class="copyright_italic">x</span><sub class="calibre19">1</sub> <span class="copyright_italic">+ x</span><sub class="calibre19">2</sub>)/2.</p>
<p class="listnumber1">  3.  If the absolute value of <span class="copyright_italic">f</span>(<span class="copyright_italic">x</span>) is less than some tolerance factor (for example, 0.0000001), then <span class="copyright_italic">x</span> is the root, so we’re done.</p>
<p class="listnumber1">  4.  Otherwise, if <span class="copyright_italic">f</span>(<span class="copyright_italic">x</span>) * <span class="copyright_italic">f</span>(<span class="copyright_italic">x</span><sub class="calibre19">2</sub>) &gt; 0, set <span class="copyright_italic">x</span><sub class="calibre19">2</sub> = <span class="copyright_italic">x</span>, else set <span class="copyright_italic">x</span><sub class="calibre19">1</sub> = <span class="copyright_italic">x</span>.</p>
<p class="listnumber2">  5.  Repeat steps 2 through 4 until the condition in step 3 is met.</p>
<p class="tx">This method is guaranteed to converge to the root if <i class="calibre9">f</i>(<i class="calibre9">x</i>) is continuous within the initial range [<i class="calibre9">x</i><sub class="calibre19">1</sub>, <i class="calibre9">x</i><sub class="calibre19">2</sub>], which also includes the root or roots. Without further ado, let’s start coding!</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="h1"><span id="sec2"/><span id="h2-84"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">The bisection method involves only a few lines of code, as shown here:</p>
<pre class="calibre10"><code class="calibre11"><span aria-label="annotation1" class="codeannotated_codeannotation">❶</span> // Import Kotlin math functions.
import kotlin.math.sin
import kotlin.math.cos
import kotlin.math.PI
import kotlin.math.sqrt
import kotlin.math.pow
import kotlin.math.abs

<span aria-label="annotation2" class="codeannotated_codeannotation">❷</span> // Set global parameters.
val v0 = 70             // m/s
val g = 9.8             // m/s2
val h0 = 25             // m
val target = 400        // m
val TOL = 1.0e-7

private val f = :: projectile

<span aria-label="annotation3" class="codeannotated_codeannotation">❸</span> // The interval [x1, x2] needs to enclose the root.
val x1 = 10.0    // in degrees
val x2 = 30.0    // in degrees

fun main() {
    println("\n*** Firing angle for hitting a target ***\n")

  <span aria-label="annotation4" class="code_codeannotation">❹</span> if (f(x1) * f(x2) &lt; 0) {
        println("...Initial guesses are valid...")
        val root = bisection(x1, x2)
        val rootFormatted = String.format("%.2f", root)
        println("The firing angle to hit the target is:" +
                "\n$rootFormatted degrees")
    } else {
        println("\n...Initial guesses are not valid...\n")
    }
}

<span aria-label="180" epub:type="pagebreak" id="pg_180" role="doc-pagebreak"/>fun projectile(angle: Double): Double {
  <span aria-label="annotation5" class="code_codeannotation">❺</span> val x = angle * PI / 180.0
    return target - (v0 * cos(x) / g) *
            (v0 * sin(x) + sqrt((v0 * sin(x)).pow(2) + 2 * g * h0))
}

fun bisection(_x1: Double, _x2: Double): Double {
    var x1 = _x1
    var x2 = _x2
  <span aria-label="annotation6" class="code_codeannotation">❻</span> var x = (x1 + x2) / 2.0

  <span aria-label="annotation7" class="code_codeannotation">❼</span> while (abs(f(x)) &gt;= TOL) {
        if (f(x) * f(x2) &gt; 0) {
            x2 = x
        } else x1 = x
        x = (x1 + x2) / 2.0
    }
    return x
}</code></pre>
<p class="tx">We start by importing the <span class="sans_thesansmonocd_w5regular_">math</span> library functions <span aria-label="annotation1" class="codeannotation">❶</span> and providing the global parameter values <span aria-label="annotation2" class="codeannotation">❷</span>. Notice that we import only the math functions we need, separately, instead of using <span class="sans_thesansmonocd_w5regular_">import kotlin.math.*</span> to import all math functions. It’s good coding etiquette to use only what you need, as it helps keep the namespace clean and reduces the chance of introducing bugs, especially when the code is reused.</p>
<p class="tx">In this example, we’ve set the target distance to 400 m, the cannon’s height to 25 m, and the cannonball’s initial velocity to 70 m/s. Next, we guess initial values for <span class="sans_thesansmonocd_w5regular_">x1</span> and <span class="sans_thesansmonocd_w5regular_">x2</span> for the bisection method <span aria-label="annotation3" class="codeannotation">❸</span> and set the function parameter <span class="sans_thesansmonocd_w5regular_">f</span> to <span class="sans_thesansmonocd_w5regular_">projectile</span>. Treating <span class="sans_thesansmonocd_w5regular_">projectile</span> as a parameter allows us to reuse the code to find the roots of other functions.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">main()</span> function uses an <span class="sans_thesansmonocd_w5regular_">if...else</span> block to confirm that the initial <span class="sans_thesansmonocd_w5regular_">x1</span> and <span class="sans_thesansmonocd_w5regular_">x2</span> guesses are located on opposite sides of the root <span aria-label="annotation4" class="codeannotation">❹</span>. If true, it calls the <span class="sans_thesansmonocd_w5regular_">bisection()</span> function to find the root. If the test fails, the program prints a message indicating that the initial guesses weren’t valid.</p>
<p class="tx">The next code block defines the <span class="sans_thesansmonocd_w5regular_">projectile()</span> function, which calculates the right-hand side of Equation 5.7 for a given angle, after first converting the angle to radians <span aria-label="annotation5" class="codeannotation">❺</span> as required for the <span class="sans_thesansmonocd_w5regular_">sin()</span> and <span class="sans_thesansmonocd_w5regular_">cos()</span> functions.</p>
<p class="tx">The final code block is the <span class="sans_thesansmonocd_w5regular_">bisection()</span> function that implements the steps outlined earlier. The function takes the two initial guesses as arguments, finds the midpoint between them <span aria-label="annotation6" class="codeannotation">❻</span>, and then uses a <span class="sans_thesansmonocd_w5regular_">while</span> loop <span aria-label="annotation7" class="codeannotation">❼</span> to make smaller and smaller bisections until the midpoint is within the specified tolerance range. The function returns the root as <span class="sans_thesansmonocd_w5regular_">x</span> (of type <span class="sans_thesansmonocd_w5regular_">Double</span>).</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<span aria-label="181" epub:type="pagebreak" id="pg_181" role="doc-pagebreak"/>
<h4 class="h1"><span id="sec3"/><span id="h2-85"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">If you run the program, the output should look like this:</p>
<pre class="calibre10"><code class="calibre11">*** Firing angle for hitting a target ***

...Initial guesses are valid...
The firing angle to hit the target is:
21.91 degrees</code></pre>
<p class="tx">Finally, we have the answer to the cannonball question! For the given initial velocity and height of the cannon above the ground, the soldiers need to fire the cannon at an angle of 21.91 degrees to hit a target 400 m away.</p>
<p class="tx">Let’s think about this solution a bit more. Is this the only possible way to hit the target? <a href="chapter5.xhtml#fig5-3" class="calibre2">Figure 5-3</a> shows how <i class="calibre9">f</i>(<i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>) varies with <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> (for the given parameter values).</p>
<figure class="img"><img alt="" class="img2" height="780" id="fig5-3" src="../images/Figure5-3.jpg" width="1135"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 5-3: The relationship between</span> <span class="sans_futura_std_book_">f</span><span class="sans_futura_std_book_oblique_">(</span><span class="sans_futura_std_book_"><span lang="el" xml:lang="el">θ</span></span><span class="sans_futura_std_book_oblique_">) and</span> <span class="sans_futura_std_book_"><span lang="el" xml:lang="el">θ</span></span></p></figcaption>
</figure>
<p class="tx">The function follows a parabolic curve, passing through the x-axis twice, so it has two different roots for <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> ≥ 0. From the given initial guesses, we’ve found the first root at point A, but another root is found at point B, where <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> = 64.51 degrees. This is a much steeper angle than the first solution, <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> = 21.91 degrees. <a href="chapter5.xhtml#fig5-4" class="calibre2">Figure 5-4</a> shows the paths, or <i class="calibre9">trajectories</i>, the cannonball will take for both firing angles.</p>
<span aria-label="182" epub:type="pagebreak" id="pg_182" role="doc-pagebreak"/>
<figure class="img"><img alt="" class="img1" height="1130" id="fig5-4" src="../images/Figure5-4.jpg" width="1624"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 5-4: Two trajectories for the cannonball solutions</span></p></figcaption>
</figure>
<p class="tx">While cannonballs fired at either angle will hit the target, the ball will reach a much higher elevation and take longer to hit the target when <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> = 64.51 degrees. Which option do you think the soldiers will prefer, and why?</p>
<aside aria-label="box-27" class="box2">
<p class="boxtitle" id="box-27"><span class="sans_futura_std_bold_b_">EXERCISE</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">Using your understanding of projectiles and the equations we’ve discussed, write a program to generate the data required to plot <a href="chapter5.xhtml#fig5-3" class="calibre2">Figures 5-3</a> and <a href="chapter5.xhtml#fig5-4" class="calibre2">5-4</a>. Then try creating these figures by using the data and the visualization tools presented in <a href="chapter3.xhtml" class="calibre2">Chapter 3</a>.</span></p>
</aside>
<p class="headaexercise" id="pre-18"><span class="sans_dogma_ot_bold_b_15-n">Project 18: Design a Fountain with Water Jets</span></p>
<p class="tni">In this project, we’ll continue to explore the path of a projectile, but instead of chasing a cannonball, we’ll follow a jet of water. Water jets have many familiar applications, such as washing cars, watering lawns, and fighting <span aria-label="183" epub:type="pagebreak" id="pg_183" role="doc-pagebreak"/>fires. We’ll explore a more artistic example: running the water jet through a nozzle assembly to create a decorative fountain.</p>
<p class="tx">A <i class="calibre9">nozzle</i> is a narrow opening through which a jet of fluid comes out at a high velocity (the fluid can be a gas or a liquid). For a given pressure, the narrower the opening of the nozzle, the faster the velocity of the jet. In the nozzle assembly used in fountains, several nozzles of different sizes or with adjustable openings can be placed at different angles. Designers vary these parameters to create beautiful patterns with the water jets. In this case, we’ll try to adjust the nozzle to shoot jets into different levels of a multilevel fountain. <a href="chapter5.xhtml#fig5-5" class="calibre2">Figure 5-5</a> illustrates the problem.</p>
<figure class="img"><img alt="" class="img2" height="791" id="fig5-5" src="../images/Figure5-5.jpg" width="1018"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 5-5: Pointing a nozzle toward a multilevel water fountain</span></p></figcaption>
</figure>
<p class="tx">The objective of this exercise is to estimate the velocity of a jet <i class="calibre9">v</i> and its angle of ejection <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>, given the desired highest point of the jet’s trajectory, (<i class="calibre9">x</i><span class="epub-i-sub">max</span>, <i class="calibre9">y</i><span class="epub-i-sub">max)</span>. This high point is set so that the jet will just pass over the edge of the water basin at a particular level, as shown in <a href="chapter5.xhtml#fig5-5" class="calibre2">Figure 5-5</a>. The fountain has four levels, so we have four sets of (<i class="calibre9">x</i><span class="epub-i-sub">max</span>, <i class="calibre9">y</i><span class="epub-i-sub">max)</span>, shown in <a href="chapter5.xhtml#tab5-1" class="calibre2">Table 5-1</a>.</p>
<p class="tt" id="tab5-1"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 5-1:</span></span> <span class="sans_futura_std_book_">Fountain Parameters</span></p>
<table class="basic-table">
<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Level</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_condensed_oblique_">x</span><span class="sans_futura_std_heavy_oblique_sub_">max</span> <span class="sans_futura_std_bold_b_">(meters)</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_condensed_oblique_">y</span><span class="sans_futura_std_heavy_oblique_sub_">max</span> <span class="sans_futura_std_bold_b_">(meters)</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tb1"><span class="sans_futura_std_book_">1</span></p></td>
<td class="tbf"><p class="tb1"><span class="sans_futura_std_book_">2.25</span></p></td>
<td class="tbf"><p class="tb1"><span class="sans_futura_std_book_">1.5</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">2</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">2.55</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">3.0</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">3</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">2.85</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">4.25</span></p></td>
</tr>
<tr class="calibre14">
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">4</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">3.0</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">5.5</span></p></td>
</tr>
</tbody>
</table>
<p class="tx">The values in this table are defined relative to the nozzle at point (0, 0). We’ll use them to calculate the corresponding values of <i class="calibre9">v</i> and <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>. Further, <span aria-label="184" epub:type="pagebreak" id="pg_184" role="doc-pagebreak"/>we’ll draw the trajectories of the jets by using the canvas feature of JavaFX so that we can visualize the solution relative to the water fountain.</p>
<p class="tx">Notice that <a href="chapter5.xhtml#fig5-5" class="calibre2">Figure 5-5</a> shows only a cross section of the fountain system, which is circular in shape in three dimensions. The nozzles are placed at diametrically opposite positions along the base of the fountain system, which is made up of the ground-level basin (not shown), the nozzles, and the four-level middle structure. We’ll use the spacing between the nozzles as the base width of this fountain system.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="h1"><span id="sec4"/><span id="h2-86"/><span class="sans_futura_std_bold_condensed_oblique_">The Strategy</span></h4>
<p class="tni">We need to use three specific equations to solve this problem, all of which can be derived from the projectile equations discussed in <span><a href="chapter5.xhtml#pre-17" class="calibre2">Project 17</a></span> (search online for “projectile motion” or “equations of motion” to learn about the derivations, or see the resources listed at the end of the chapter).</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msub><mi>t</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><mtext> </mtext><mfrac><mrow><mi>v</mi><mi>sin</mi><mi>θ</mi></mrow><mi>g</mi></mfrac></mrow></math> (5.8)<span class="sblock"/><math alttext="Equation" display="inline"><mrow><msub><mi>x</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><mtext> </mtext><mfrac><mrow><msup><mi>v</mi><mn>2</mn></msup><mi>sin</mi><mi>θ</mi><mi>cos</mi><mi>θ</mi></mrow><mi>g</mi></mfrac></mrow></math> (5.9)<span class="sblock"/><math alttext="Equation" display="inline"><mrow><msub><mi>y</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><mtext> </mtext><mfrac><mrow><msup><mi>v</mi><mn>2</mn></msup><msup><mrow><mi>sin</mi></mrow><mn>2</mn></msup><mi>θ</mi></mrow><mrow><mn>2</mn><mi>g</mi></mrow></mfrac></mrow></math> (5.10)</span>
<span class="mobi"><img alt="" class="img1" height="334" src="../images/eq5-8-10.jpg" width="1389"/></span></figure>
<p class="tx">We’ve already defined the variables in these equations, except for <i class="calibre9">t</i><span class="epub-i-sub">max</span>, which is the time needed for a water particle leaving the nozzle to reach the highest point (<i class="calibre9">x</i><span class="epub-i-sub">max</span>, <i class="calibre9">y</i><span class="epub-i-sub">max</span>). We can use Equations 5.9 and 5.10 to find the expressions for <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> and <i class="calibre9">v</i> as:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>θ</mi><mo>=</mo><mtext> </mtext><mi>arctan</mi><mtext> </mtext><mfenced><mrow><mfrac><mrow><mn>2</mn><msub><mi>y</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow><mrow><msub><mi>x</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow></mfrac></mrow></mfenced></mrow></math> (5.11)<span class="sblock"/><math alttext="Equation" display="inline"><mrow><mi>v</mi><mo>=</mo><mtext> </mtext><mfrac><mrow><msqrt><mrow><mn>2</mn><mi>g</mi><msub><mi>y</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></mrow></msqrt></mrow><mrow><mi>sin</mi><mi>θ</mi></mrow></mfrac></mrow></math> (5.12)</span>
<span class="mobi"><img alt="" class="img1" height="220" src="../images/eq5-11-12.jpg" width="1389"/></span></figure>
<p class="tx">We’ll use these equations to calculate the angles of ejection and velocities for the four levels of the fountain, based on the data provided in <a href="chapter5.xhtml#tab5-1" class="calibre2">Table 5-1</a>. We’ll also use Equation 5.8 to calculate the trajectories to be drawn with the JavaFX library.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="h1"><span id="sec5"/><span id="h2-87"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">Our project uses the same basic JavaFX template that’s discussed in detail in <span><a href="chapter3.xhtml" class="calibre2">Chapter 3</a></span>. We begin with some overall setup.</p>
<pre class="calibre10"><code class="calibre11">// Import JavaFX features.
import javafx.application.Application
import javafx.scene.Scene
import javafx.scene.canvas.Canvas
<span aria-label="185" epub:type="pagebreak" id="pg_185" role="doc-pagebreak"/>import javafx.scene.canvas.GraphicsContext
import javafx.scene.layout.Pane
import javafx.scene.paint.Color
import javafx.stage.Stage

// Import required math functions.
import kotlin.math.sin
import kotlin.math.cos
import kotlin.math.tan
import kotlin.math.atan
import kotlin.math.pow
import kotlin.math.PI
import kotlin.math.sqrt

// Set global parameters and variables.
val baseWidth = 6.5  // m
val xMaxJet = doubleArrayOf(2.25, 2.55, 2.85, 3.0)
val yMaxJet = doubleArrayOf(1.5, 3.0, 4.25, 5.5)
val angle = DoubleArray(4)
val vel = DoubleArray(4)
val g = 9.8  // m/s2

// Set canvas properties.
val xMin = -0.5
val xMax = baseWidth + 0.5
val yMin = -0.5
val yMax = 6.0
val xRange = xMax - xMin
val yRange = yMax - yMin
val canvasW = 700.0
val canvasH = (canvasW/ xRange) * yRange</code></pre>
<p class="tx">The first half of the import block imports the necessary graphics features from the JavaFX library, and the second half imports the required math functions from the <span class="sans_thesansmonocd_w5regular_">kotlin.math</span> library.</p>
<p class="tx">Next, we define the global parameters and variables. The base width of the fountain system has been set to 6.5 m. The coordinates for the highest points of the parabolic jets (<span class="sans_thesansmonocd_w5regular_">xMaxJet</span> and <span class="sans_thesansmonocd_w5regular_">yMaxJet</span>) are set by using type <span class="sans_thesansmonocd_w5regular_">DoubleArray</span>. We also create arrays to hold the angles and velocities that we’ll be calculating. As we’re imagining this fountain to be on Earth, the acceleration due to gravity, <span class="sans_thesansmonocd_w5regular_">g</span>, has been set to 9.8 m/s<sup class="calibre8">2</sup>. Finally, we set the required dimensions for the canvas based on the width and height of the fountain, with some margins on the sides.</p>
<p class="tx">The remainder of the project code has three core segments: the <span class="sans_thesansmonocd_w5regular_">ShapeOfWater</span> application class and two helper functions, <span class="sans_thesansmonocd_w5regular_">getAngleAndVel()</span> and <span class="sans_thesansmonocd_w5regular_">getTrajectories()</span>. We’ll look at these in turn.</p>
<section aria-labelledby="sec6" epub:type="division">
<h5 class="h2"><span id="sec6"/><span id="h3-34"/><span class="sans_futura_std_bold_b_">The ShapeOfWater Application Class</span></h5>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">ShapeOfWater</span> application class manages the canvas and calls the helper functions.</p>
<pre class="calibre10"><code class="calibre11"><span aria-label="186" epub:type="pagebreak" id="pg_186" role="doc-pagebreak"/>// the primary application class
class ShapeOfWater : Application() {
    override fun start(stage: Stage) {
        val root = Pane()
        val canvas = Canvas(canvasW, canvasH)
        val gc = canvas.graphicsContext2D
        gc.translate(0.0, canvas.height)
        gc.scale(1.0, -1.0)
        root.children.add(canvas)
        val scene = Scene(root, canvasW, canvasH)
        scene.fill = Color.WHITE
        stage.title = "Shape of Water"
        stage.scene = scene
        stage.show()

        // problem-specific section
<b class="calibre6">        </b>getAngleAndVel()
        getTrajectories(gc)
        println("\nNozzle velocities:")
        for (v in vel) print(String.format("%.2f  ", v))
        println("\nNozzle angles:")
        for (theta in angle)
             print(String.format("%.2f  ", theta))
    }
}

fun main() {
    Application.launch(ShapeOfWater::class.java)
}</code></pre>
<p class="tx">The class follows the standard JavaFX block we developed in <span><a href="chapter3.xhtml" class="calibre2">Chapter 3</a></span>, which we’ll use throughout this book. Notice the two function calls. The first call to <span class="sans_thesansmonocd_w5regular_">getAngleAndVel()</span> calculates the <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> and <i class="calibre9">v</i> for the four sets of coordinates provided for the four levels of the fountain. Calling <span class="sans_thesansmonocd_w5regular_">getTrajectories()</span> calculates the corresponding trajectories for the water jets and draws them on the canvas.</p>
<p class="tx">The class declaration ends with a few lines of print statements to display the calculated values of <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> and <i class="calibre9">v</i> (as <span class="sans_thesansmonocd_w5regular_">angle</span> and <span class="sans_thesansmonocd_w5regular_">vel</span>) for the four pairs of (<i class="calibre9">x</i><span class="epub-i-sub">max</span>, <i class="calibre9">y</i><span class="epub-i-sub">max</span>) provided. The values are rounded to two decimal places for ease of reading.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h5 class="h2"><span id="sec7"/><span id="h3-35"/><span class="sans_futura_std_bold_b_">The getAngleAndVel() Function</span></h5>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">getAngleAndVel()</span> function uses Equations 5.11 and 5.12 to calculate <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> and <i class="calibre9">v</i> for the four water jets.</p>
<pre class="calibre10"><code class="calibre11">fun getAngleAndVel() {
    var index = 0

  <span aria-label="annotation1" class="code_codeannotation">❶</span> xMaxJet.zip(yMaxJet) {x, y -&gt;
        val theta = atan(2 * y / x)
      <span aria-label="annotation2" class="code_codeannotation">❷</span> angle[index] = theta * 180/ PI
        vel[index] = sqrt(2 * g * y) / sin(theta)
<span aria-label="187" epub:type="pagebreak" id="pg_187" role="doc-pagebreak"/>        index += 1
    }
}</code></pre>
<p class="tx">We use <span class="sans_thesansmonocd_w5regular_">zip()</span> with a lambda expression <span aria-label="annotation1" class="codeannotation">❶</span> to work through the pairs of (<i class="calibre9">x</i><span class="epub-i-sub">max</span>, <i class="calibre9">y</i><span class="epub-i-sub">max</span>) values, calculating <span class="sans_thesansmonocd_w5regular_">theta</span> and <span class="sans_thesansmonocd_w5regular_">vel</span> for each and storing those values in the appropriate arrays. We could have also used a <span class="sans_thesansmonocd_w5regular_">for</span> loop to iterate over the coordinates, and you might try that as an exercise. The <span class="sans_thesansmonocd_w5regular_">atan()</span> function gives us angles in radians, but we convert the values to degrees before storing them in the <span class="sans_thesansmonocd_w5regular_">angles</span> array to make the output more intuitive <span aria-label="annotation2" class="codeannotation">❷</span>.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h5 class="h2"><span id="sec8"/><span id="h3-36"/><span class="sans_futura_std_bold_b_">The getTrajectories() Function</span></h5>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">getTrajectories()</span> function calculates the trajectories of the jets based on the data from <span class="sans_thesansmonocd_w5regular_">getAngleAndVel()</span> and visualizes the results.</p>
<pre class="calibre10"><code class="calibre11">fun getTrajectories(gc: GraphicsContext) {
    // Generate trajectories by iterating over time.
    vel.zip(angle) {v, _theta -&gt;
        val theta = _theta * PI / 180
      <span aria-label="annotation1" class="code_codeannotation">❶</span> val tmax = 1.1 * v * sin(theta)/g
        val delt = tmax/50

        // Calculate trajectory coordinates.
        var t = 0.0
      <span aria-label="annotation2" class="code_codeannotation">❷</span> while (t &lt;= tmax) {
            val x = v * cos(theta) * t
            val y = x * tan(theta) -
                (g / (2 * (v * cos(theta)).pow(2))) * x.pow(2)

            // Draw points on canvas.
          <span aria-label="annotation3" class="code_codeannotation">❸</span> gc.fillOval(canvasW * (x - xMin)/ xRange,
                        canvasH * (y - yMin)/ yRange, 3.0, 3.0)
          <span aria-label="annotation4" class="code_codeannotation">❹</span> gc.fillOval(
               canvasW * ((baseWidth - x) - xMin)/ xRange,
               canvasH * (y - yMin)/ yRange, 3.0, 3.0)
            t += delt
        }
    }
}</code></pre>
<p class="tx">First, we calculate <i class="calibre9">t</i><span class="epub-i-sub">max</span> for each (<i class="calibre9">x</i><span class="epub-i-sub">max</span>, <i class="calibre9">y</i><span class="epub-i-sub">max</span>) pair by using Equation 5.8. We deliberately extend <i class="calibre9">t</i><span class="epub-i-sub">max</span> by 10 percent so that when the trajectory is drawn up to that time, we’ll see the jet starting to bend downward toward the water basin <span aria-label="annotation1" class="codeannotation">❶</span>. Next, we use a <span class="sans_thesansmonocd_w5regular_">while</span> loop <span aria-label="annotation2" class="codeannotation">❷</span> to iterate over 50 even time steps between 0 and <i class="calibre9">t</i><span class="epub-i-sub">max</span>. Using <span class="sans_thesansmonocd_w5regular_">while</span> allows us to work with a real-valued (noninteger) increment per time step. We couldn’t do that with a <span class="sans_thesansmonocd_w5regular_">for</span> loop, whose iterator can only be an integer.</p>
<p class="tx">Inside the <span class="sans_thesansmonocd_w5regular_">while</span> loop, we use the original displacement Equations 5.1 and 5.2 introduced in <span><a href="chapter5.xhtml#pre-17" class="calibre2">Project 17</a></span> to calculate the successive locations of a water particle at each time step, giving us the entire trajectory for the water <span aria-label="188" epub:type="pagebreak" id="pg_188" role="doc-pagebreak"/>jet from the nozzle to the basin. Instead of saving the values in an array for future use, we use them instantly to draw small circles on the canvas <span aria-label="annotation3" class="codeannotation">❸</span>. By repeating the process for all (<i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>, <i class="calibre9">v</i>) pairs and for all time steps, we create the two-dimensional profile of the water jets. Notice that we take advantage of the symmetric nature of the problem to draw a second set of jets from another nozzle on the opposite side of the ground-level basin <span aria-label="annotation4" class="codeannotation">❹</span>. For this extra set of jets, we only need to adjust the x-coordinates by subtracting <span class="sans_thesansmonocd_w5regular_">x</span> from <span class="sans_thesansmonocd_w5regular_">baseWidth</span>.</p>
</section>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="h1"><span id="sec9"/><span id="h2-88"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">If you run the downloadable version of the code, the complete 2D solution should resemble <a href="chapter5.xhtml#fig5-6" class="calibre2">Figure 5-6</a>. This version of the code includes two additional functions: <span class="sans_thesansmonocd_w5regular_">drawFountain()</span> and <span class="sans_thesansmonocd_w5regular_">drawNozzles()</span>. The former is used to draw the four-level fountain from the given arrays of <i class="calibre9">x</i><span class="epub-i-sub">max</span> and <i class="calibre9">y</i><span class="epub-i-sub">max</span> for the water jets, while the latter is used to display the positions of the nozzles as shown in <a href="chapter5.xhtml#fig5-5" class="calibre2">Figure 5-5</a>. I encourage you to study these two functions and understand the logic used to calculate the dimensions of the fountain and the positions of the nozzles.</p>
<p class="tx">To change the shape of the trajectories, you can adjust the values of <i class="calibre9">x</i><span class="epub-i-sub">max</span> and <i class="calibre9">y</i><span class="epub-i-sub">max</span> for the water jets. The shape of the fountain will be automatically adjusted. However, it’s important to ensure that the values of <i class="calibre9">x</i><span class="epub-i-sub">max</span> and <i class="calibre9">y</i><span class="epub-i-sub">max</span> are consistent and reasonable. For example, the <i class="calibre9">x</i><span class="epub-i-sub">max</span> and <i class="calibre9">y</i><span class="epub-i-sub">max</span> for level 2 should be greater than those of level 1, and similar conditions apply to levels 3 and 4. Additionally, all values must be nonnegative.</p>
<figure class="img"><img alt="" class="img3" height="742" id="fig5-6" src="../images/Figure5-6.jpg" width="1018"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 5-6: Water jet profiles around a multilevel fountain</span></p></figcaption>
</figure>
<p class="tx">The values of the nozzle velocities (in m/s) and angles (in degrees) are directly printed onscreen as text output when you run the code. The output should look like this:</p>
<pre class="calibre10"><code class="calibre11"><span aria-label="189" epub:type="pagebreak" id="pg_189" role="doc-pagebreak"/>Nozzle velocities:
6.78  8.33  9.63  10.76
Nozzle angles:
53.13  66.97  71.46  74.74</code></pre>
<p class="tx">It’s not difficult to use this 2D solution to build a real-world 3D fountain. Since we previously imagined the fountain system to be circular in shape, all we need to do is repeat the solution at certain intervals along the perimeter of the circle that passes through the nozzle assemblies. You can also play with the code to generate your own unique fountain designs.</p>
<aside aria-label="box-28" class="box2">
<p class="boxtitle" id="box-28"><span class="sans_futura_std_bold_b_">EXERCISE</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">Using the idea and techniques discussed in <a href="chapter5.xhtml#pre-18" class="calibre2">Project 18</a>, design a water fountain so that the nozzles are placed along the outer edges of the water tanks of the same four-level structure. Make the nozzles point away from the center of the structure and then draw the water jets. You can decide how far and high those jets should travel before coming down, but be realistic and pay attention to aesthetics. The shape and size of the jets should match the size of the fountain. A water fountain is an object of beauty, after all.</span></p>
</aside>
<p class="headaexercise" id="pre-19"><span class="sans_dogma_ot_bold_b_15-n">Project 19: Track a Pendulum’s Motion and Phase</span></p>
<p class="tni">A <i class="calibre9">pendulum</i> is a body or weight hung from a fixed point with the help of a string, chain, or rod. When the pendulum is moved from the stable equilibrium of its vertical position, it can freely swing under the influence of gravity. In ideal conditions, when no friction or air resistance interferes, the pendulum will continue to swing indefinitely once it’s set in motion. Clockmakers have long used pendulums to steadily drive mechanical clocks—picture, for example, the swinging pendulum of an antique grandfather clock. Other examples of real-life pendulums include swings, wrecking balls, and church bells.</p>
<p class="tx">Pendulums exhibit <i class="calibre9">simple harmonic motion (SHM)</i>, defined as the motion of an object that is <i class="calibre9">periodic</i>, or repeating, and that is driven by two opposing forces: an <i class="calibre9">inertial force</i> that moves the object away from its equilibrium position and a <i class="calibre9">restoring force</i> that tries to return the object to its equilibrium position. The maximum displacement of the object relative to the mean or equilibrium position is called the <i class="calibre9">amplitude</i>, and the number of cycles the object goes through per unit time is called the <i class="calibre9">frequency</i>. The inverse of frequency, which is the time it takes to complete one cycle or oscillation, is called the <i class="calibre9">period</i>.</p>
<p class="tx">The simple harmonic motion of a pendulum provides a starting point for understanding the more complex periodic motions found in nature, <span aria-label="190" epub:type="pagebreak" id="pg_190" role="doc-pagebreak"/>from the vibration of an electron to the orbit of a planet about a star. This project introduces the equation for the motion of a simple pendulum. It shows you how to use a numerical method to solve this equation and calculate the state of the pendulum—that is, its velocity and displacement angle—at any given time once the pendulum is set in motion. For added realism, we’ll factor in the effect of air resistance to show how it gradually dampens the pendulum’s motion. Of course, we’ll codify our model pendulum in Kotlin and visualize the results by using the JavaFX tools we learned in <span><a href="chapter3.xhtml" class="calibre2">Chapter 3</a></span>. Our visualization will consist of three charts: one showing the change of the pendulum’s velocity over time, one showing the change of its displacement angle over time, and one showing the relationship between the two.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="h1"><span id="sec10"/><span id="h2-89"/><span class="sans_futura_std_bold_condensed_oblique_">The Motion of a Simple Pendulum</span></h4>
<p class="tni">A simple pendulum has a single weight, or <i class="calibre9">bob</i>, of mass <i class="calibre9">m</i> that hangs from a thin string of length <i class="calibre9">l</i> fixed at point A<i class="calibre9">.</i> It’s assumed that the mass of the string is negligible compared with the mass of the bob. It’s also assumed that the string doesn’t stretch due to the weight of the bob and that the bob can move back and forth indefinitely without any friction or loss of energy (meaning the total energy of the system is conserved, once set in motion). As the pendulum swings, its angular displacement (<i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>) changes, as measured relative to the pendulum’s stable equilibrium position (the vertical line passing through point A). <a href="chapter5.xhtml#fig5-7" class="calibre2">Figure 5-7</a> shows these components of a simple pendulum.</p>
<figure class="img"><img alt="" class="img3" height="588" id="fig5-7" src="../images/Figure5-7.jpg" width="405"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 5-7: Components of a simple pendulum</span></p></figcaption>
</figure>
<p class="tx">At any point in time, the force of gravity, <i class="calibre9">mg</i>, acts on the bob to set it in motion. The gravitational force has two components. The first, <i class="calibre9">mg</i> cos(<i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>), acts along the line of the string and is countered by the tension in the string. The second, <i class="calibre9">mg</i> sin(<i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>), acts perpendicularly to the string. This is the part that isn’t balanced by any other force (assuming no air resistance) and is responsible for the harmonic motion of the pendulum.</p>
<p class="tx"><span aria-label="191" epub:type="pagebreak" id="pg_191" role="doc-pagebreak"/>Let <i class="calibre9"><span lang="el" xml:lang="el">ω</span></i> denote the rate of change of angular displacement, also called the <i class="calibre9">angular velocity</i>:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mtext>ω</mtext><mtext> </mtext><mtext>=</mtext><mtext> </mtext><mfrac><mrow><mi>d</mi><mi>θ</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac></mrow></math> (5.13)</span>
<span class="mobi"><img alt="" class="img1" height="78" src="../images/eq5-13.jpg" width="1391"/></span></figure>
<p class="tx">The right-hand side of Equation 5.13 is called the derivative of <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> with respect to time <i class="calibre9">t</i>. Mathematically speaking, the time derivative of a variable gives us the instantaneous rate of change of that variable with respect to time.</p>
<p class="tx">We can now express the equation of motion for this simple pendulum in terms of its angular acceleration as follows:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mfrac><mrow><mi>d</mi><mi>ω</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mo>−</mo><mfrac><mi>g</mi><mi>l</mi></mfrac><mi>sin</mi><mi>θ</mi></mrow></math> (5.14)</span>
<span class="mobi"><img alt="" class="img1" height="76" src="../images/eq5-14.jpg" width="1391"/></span></figure>
<p class="tx">An analytical solution to Equation 5.14 would give us an expression for the angular displacement <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> in terms of time <i class="calibre9">t</i> and other parameters. However, the analytical solution isn’t easy to derive unless we make an additional assumption that the maximum displacement <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i><span class="epub-i-sub">max</span> is relatively small—say, less than 15 degrees. This would allow us to replace sin(<i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>) with <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>, since the two are equivalent for small angles.</p>
<p class="tx">We don’t want to be limited to just this special case, however. Instead, we’ll use the Euler-Cromer numerical method to incrementally solve Equation 5.14 for a small time step. This method maintains the conservation of energy inherent in simple harmonic motion, and it yields <i class="calibre9">stable</i> solutions (a solution is <i class="calibre9">stable</i> when the numerical approximation doesn’t deteriorate and move away from the theoretical solution over time).</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="h1"><span id="sec11"/><span id="h2-90"/><span class="sans_futura_std_bold_condensed_oblique_">The Strategy</span></h4>
<p class="tni">To apply the Euler-Cromer method, we need to change Equation 5.14 from its continuous-time form to its discrete-time form:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msub><mtext>ω</mtext><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mtext>ω</mtext><mi>t</mi></msub><mo>−</mo><mfrac><mi>g</mi><mi>l</mi></mfrac><mi>sin</mi><msub><mi>θ</mi><mi>t</mi></msub><mi>δ</mi><mi>t</mi></mrow></math> (5.15)</span>
<span class="mobi"><img alt="" class="img1" height="71" src="../images/eq5-15.jpg" width="1391"/></span></figure>
<p class="tni">Here <i class="calibre9"><span lang="el" xml:lang="el">δ</span>t</i> is a small, discrete time step. Next, we’ll incorporate the impact of air resistance on the pendulum. Air resistance slows down the angular velocity as a decelerating force, which can be assumed to be proportional to the angular velocity. Assuming <i class="calibre9"><span lang="el" xml:lang="el">γ</span></i> to be the proportionality constant, we can modify Equation 5.15 as:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msub><mtext>ω</mtext><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mtext>ω</mtext><mi>t</mi></msub><mo>−</mo><mfrac><mi>g</mi><mi>t</mi></mfrac><mi>sin</mi><msub><mi>θ</mi><mi>t</mi></msub><mi>δ</mi><mi>t</mi><mo>−</mo><mi>γ</mi><msub><mi>ω</mi><mi>t</mi></msub><mi>δ</mi><mi>t</mi></mrow></math> (5.16)</span>
<span class="mobi"><img alt="" class="img1" height="71" src="../images/eq5-16.jpg" width="1391"/></span></figure>
<p class="tx">Finally, we’ll write another expression for updating the angular displacement <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>, which follows directly from the definition of angular velocity <i class="calibre9"><span lang="el" xml:lang="el">ω</span></i> in Equation 5.13 as:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msub><mi>θ</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>θ</mi><mi>t</mi></msub><mo>+</mo><mtext> </mtext><mi>ω</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mi>δ</mi><mi>t</mi></mrow></math> (5.17)</span>
<span class="mobi"><img alt="" class="img1" height="46" src="../images/eq5-17.jpg" width="1391"/></span></figure>
<p class="tx"><span aria-label="192" epub:type="pagebreak" id="pg_192" role="doc-pagebreak"/>Here, we are assuming that over a small time interval <i class="calibre9"><span lang="el" xml:lang="el">δ</span>t</i>, <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> is changing from <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i><span class="epub-i-sub">t</span> to <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i><span class="epub-i-sub">t</span> <sub class="calibre19">+ 1</sub>. In reality, <i class="calibre9"><span lang="el" xml:lang="el">ω</span></i> also continues to change over this small time period. We recognize this fact by denoting <i class="calibre9"><span lang="el" xml:lang="el">ω</span></i> as a function of time—that is, <i class="calibre9"><span lang="el" xml:lang="el">ω</span></i>(<i class="calibre9">t</i>)—in Equation 5.17. However, in discrete-time representation, we can use only one discrete value of <i class="calibre9"><span lang="el" xml:lang="el">ω</span></i>, and the Euler-Cromer method requires that it be <i class="calibre9"><span lang="el" xml:lang="el">ω</span></i><span class="epub-i-sub">t</span> <sub class="calibre19">+ 1</sub> to ensure numerical stability. Thus, the final numerical form for the equation of motion of a simple pendulum is:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msub><mi>θ</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>θ</mi><mi>t</mi></msub><mo>+</mo><msub><mi>ω</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mtext> </mtext><mi>δ</mi><mi>t</mi></mrow></math> (5.18)</span>
<span class="mobi"><img alt="" class="img1" height="45" src="../images/eq5-18.jpg" width="1388"/></span></figure>
<p class="tx">By starting with initial values for <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> and <i class="calibre9"><span lang="el" xml:lang="el">ω</span></i>, and by repeatedly using Equations 5.16 and 5.18, we can calculate the state of a simple pendulum and plot the changes of its angular displacement and velocity over time.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h4 class="h1"><span id="sec12"/><span id="h2-91"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">The program for modeling our simple pendulum has three main code segments: the main application segment coordinating the model, a <span class="sans_thesansmonocd_w5regular_">simplePendulumWithDrag()</span> function implementing the equations we’ve discussed, and a <span class="sans_thesansmonocd_w5regular_">singleXYChart()</span> function to draw each plot. We’ll review these segments in detail in the same order, starting with the main application segment.</p>
<pre class="calibre10"><code class="calibre11">// import block
import javafx.application.Application
import javafx.scene.Scene
import javafx.scene.control.ScrollPane
import javafx.scene.layout.VBox
import javafx.scene.paint.Color
import javafx.scene.chart.*
import javafx.stage.Stage
import java.text.DecimalFormat
import kotlin.math.PI
import kotlin.math.sin
import kotlin.math.sqrt

// data classes
data class XYChartData(val x: Double, val y: Double)
data class PendulumData(val theta: Double, val omega: Double,
                         val t: Double)

// problem definition and global parameters
val theta0 = -PI/6  // angular displacement at t = 0, rad
val omega0 = 0.0    // angular velocity at t = 0, rad/s
val l = 0.4         // length, m
val g = 9.81        // acceleration due to gravity, m/s2
val n = 100         // intervals
val gamma = 0.6     // drag coefficient

class SimplePendulum : Application() {
    override fun start(primaryStage: Stage) {
        val root = VBox()
        val scroll = ScrollPane()
<span aria-label="193" epub:type="pagebreak" id="pg_193" role="doc-pagebreak"/>        scroll.content = root
        val scene = Scene(scroll, 550.0, 600.0, Color.WHITE)
        primaryStage.title = "Simple Pendulum"
        primaryStage.scene = scene
        primaryStage.show()

        // Generate pendulum state data.
      <span aria-label="annotation1" class="code_codeannotation">❶</span> val state: List&lt;PendulumData&gt; =
            simplePendulumWithDrag(theta0, omega0,
                  l, g, n, gamma)
        // Create (x, y) series for plotting.
        val list1 = mutableListOf&lt;XYChartData&gt;()
        val list2 = mutableListOf&lt;XYChartData&gt;()
        val list3 = mutableListOf&lt;XYChartData&gt;()

      <span aria-label="annotation2" class="code_codeannotation">❷</span> for (item in state) {
            val (theta, omega, t) = item
            list1 += XYChartData(t, theta)  // t along x-axis
            list2 += XYChartData(t, omega)  // t along x-axis
            list3 += XYChartData(theta, omega)
        }

        // Call singleXYChart() to generate plots.
        val xyChart1 =
            singleXYChart(list1,
                title = "Angular Displacement over Time",
                xLabel = "Time (sec)",
                yLabel = "Angular displacement (rad)")
        val xyChart2 =
            singleXYChart(list2,
                title = "Angular Velocity over Time",
                xLabel = "Time (sec)",
                yLabel = "Angular velocity (rad/sec)")
        val xyChart3 =
            singleXYChart(list3,
                title = "Phase-Space Plot (omega vs. theta)",
                xLabel = "Angular displacement (rad)",
                yLabel = "Angular velocity (rad/sec)",
                sort = "NONE")

        // Add the charts to the root (VBox) object.
      <span aria-label="annotation3" class="code_codeannotation">❸</span> root.children.addAll(xyChart1, xyChart2, xyChart3)
    }
}

fun main() {
    Application.launch(SimplePendulum::class.java)
}</code></pre>
<p class="tx">As usual, the main application segment starts with the boilerplate import block required for a JavaFX-based app. This time, we’re also going to use a class called <span class="sans_thesansmonocd_w5regular_">ScrollPane</span> that can hold a graphics element and provide a scrollable view of it. This will help us view all three charts in the same <span aria-label="194" epub:type="pagebreak" id="pg_194" role="doc-pagebreak"/>window. The import block also includes the math functions we’ll need for this project.</p>
<p class="tx">The second code block declares two data classes. We’ll use the <span class="sans_thesansmonocd_w5regular_">XYChartData</span> class to hold (<i class="calibre9">x</i>, <i class="calibre9">y</i>) data points for creating the line charts and the <span class="sans_thesansmonocd_w5regular_">PendulumData</span> class to store the state of the pendulum (angular displacement <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> and velocity <i class="calibre9"><span lang="el" xml:lang="el">ω</span></i>) for a specific time <i class="calibre9">t</i>. Each <span class="sans_thesansmonocd_w5regular_">XYChartData</span> data point will be fetched from the values in a particular <span class="sans_thesansmonocd_w5regular_">PendulumData</span> instance.</p>
<p class="tx">Next, we provide problem-specific and global parameter values. For example, we’ve set the initial displacement to <span class="sans_thesansmonocd_w5regular_">-PI/6</span> (–30 degrees) and the initial velocity to <span class="sans_thesansmonocd_w5regular_">0</span>. The length of the pendulum, measured in meters, is <span class="sans_thesansmonocd_w5regular_">0.4</span>, and <span class="sans_thesansmonocd_w5regular_">n</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">100</span> means we’ll determine the value of the time step (<i class="calibre9"><span lang="el" xml:lang="el">δ</span>t</i>) by dividing the period of oscillation into 100 intervals. We’ve also set the coefficient for air resistance to <span class="sans_thesansmonocd_w5regular_">0.6</span> (a value of <span class="sans_thesansmonocd_w5regular_">0</span> would mean no air resistance).</p>
<p class="tx">Inside the <span class="sans_thesansmonocd_w5regular_">SimplePendulum</span> application class, the problem-specific part of the code starts with a call to <span class="sans_thesansmonocd_w5regular_">simplePendulumWithDrag()</span> <span aria-label="annotation1" class="codeannotation">❶</span> that takes in the following arguments: the initial displacement <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i><sub class="calibre19">0</sub>, the initial velocity <i class="calibre9"><span lang="el" xml:lang="el">ω</span></i><sub class="calibre19">0</sub>, the length of the pendulum <i class="calibre9">l</i>, the acceleration due to gravity <i class="calibre9">g</i>, the number of time intervals per period <i class="calibre9">n</i>, and the air resistance coefficient <i class="calibre9"><span lang="el" xml:lang="el">γ</span></i>. As you’ll see shortly when we look at the inner workings of this function, it returns a list of <span class="sans_thesansmonocd_w5regular_">PendulumData</span> instances, one for each time step, which we store as <span class="sans_thesansmonocd_w5regular_">state</span>.</p>
<p class="tx">Next, we create three mutable lists to hold the <span class="sans_thesansmonocd_w5regular_">XYChartData</span> instances that we’ll need to draw the line charts illustrating the pendulum’s state variables. We build these lists by extracting the elements from each <span class="sans_thesansmonocd_w5regular_">PendulumData</span> instance as needed for the three charts <span aria-label="annotation2" class="codeannotation">❷</span>. Charts 1 and 2 both show time on the x-axis and displacement and velocity on the y-axis, respectively; chart 3 shows displacement on the x-axis and velocity on the y-axis.</p>
<p class="tx">We generate the three charts by making successive calls to the <span class="sans_thesansmonocd_w5regular_">singleXYChart()</span> function. The function takes five arguments, four of which have default values assigned in the function definition. Thus, we only need to provide a list of type <span class="sans_thesansmonocd_w5regular_">XYChartData</span> (for example, <span class="sans_thesansmonocd_w5regular_">list1</span>) and optionally supply values of the other named parameters. Notice that for <span class="sans_thesansmonocd_w5regular_">xyChart3</span>, we specify <span class="sans_thesansmonocd_w5regular_">sort = "NONE"</span> so that we can correctly plot the (velocity, displacement) pairs without changing their sequence. This is a requirement when we consider the air resistance that alters the cyclic relationship between the two state variables.</p>
<p class="tx">We plot the charts by attaching them to <span class="sans_thesansmonocd_w5regular_">root</span> <span aria-label="annotation3" class="codeannotation">❸</span>, which we previously assigned to a <span class="sans_thesansmonocd_w5regular_">ScrollPane</span>. This scheme allows us to view all three charts inside the same window by scrolling up and down or sideways as needed. Finally, the <span class="sans_thesansmonocd_w5regular_">main()</span> function’s only job in a JavaFX application is to launch the main application class—in this case, <span class="sans_thesansmonocd_w5regular_">SimplePendulum</span>.</p>
<section aria-labelledby="sec13" epub:type="division">
<h5 class="h2"><span id="sec13"/><span id="h3-37"/><span class="sans_futura_std_bold_b_">The simplePendulumWithDrag() Function</span></h5>
<p class="tni">In the <span class="sans_thesansmonocd_w5regular_">simplePendulumWithDrag()</span> function, we use the Euler-Cromer method to calculate the values of the pendulum’s state variables for a specified number of time steps, given the initial conditions and global parameter values.</p>
<pre class="calibre10"><code class="calibre11">fun simplePendulumWithDrag(
        theta0 : Double,
        omega0 : Double,
<span aria-label="195" epub:type="pagebreak" id="pg_195" role="doc-pagebreak"/>        l: Double, g: Double, n: Int,
        gamma: Double = 0.0): List&lt;PendulumData&gt; {

    // Set local variables, parameters, and list.
    val alpha = g / l
    // Calculate period for small displacement.
  <span aria-label="annotation1" class="code_codeannotation">❶</span> val T = 2 * PI * sqrt(l/g)
  <span aria-label="annotation2" class="code_codeannotation">❷</span> val dt = T / n
    val Nmax = 4 * n
    val df = DecimalFormat("##.####")

    var omegaOld: Double; var omegaNew: Double
    var thetaOld: Double; var thetaNew: Double
    var timeOld: Double;  var timeNew: Double
    val pList = mutableListOf&lt;PendulumData&gt;()

    // Initialize for t = 0.
    thetaOld = theta0
    omegaOld = omega0
    timeOld = 0.0
    pList += PendulumData(theta0, omega0, 0.0)

    // Calculate and save state variables.
  <span aria-label="annotation3" class="code_codeannotation">❸</span> for (k in 1..Nmax) {
        omegaNew = omegaOld –
            (alpha * sin(thetaOld) + gamma * omegaOld) * dt
        thetaNew = thetaOld + omegaNew * dt // Euler-Cromer
        timeNew = timeOld + dt
      <span aria-label="annotation4" class="code_codeannotation">❹</span> pList += PendulumData(thetaNew, omegaNew, timeNew)

      <span aria-label="annotation5" class="code_codeannotation">❺</span> omegaOld = omegaNew
        thetaOld = thetaNew
        timeOld = timeNew
    }

    println("\n*** Simple Pendulum Simulation ***\n")
    println("length l: $l m")
    println("theta0: ${df.format(theta0*180/PI)} degrees")
    println("omega0: ${df.format(omega0*180/PI)} rad/sec")
    println("gamma: ${df.format(gamma)}")
    println("dt: ${df.format(dt)} sec")
    println("Nmax: $Nmax intervals")
    println("Simulation length: ${df.format(Nmax*dt)} sec")

    return pList
}</code></pre>
<p class="tx">Our first order of business is to determine the value of the time step <span class="sans_thesansmonocd_w5regular_">dt</span> (<i class="calibre9"><span lang="el" xml:lang="el">δ</span>t</i>). For that, we need to estimate the pendulum’s period of oscillation <i class="calibre9">T</i> <span aria-label="annotation1" class="codeannotation">❶</span>, using the following formula:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>T</mi><mo>=</mo><mn>2</mn><mi>π</mi><msqrt><mrow><mfrac><mi>l</mi><mi>g</mi></mfrac></mrow></msqrt></mrow></math></span>
<span class="mobi"><img alt="" class="img1" height="113" src="../images/pg195-1.jpg" width="1333"/></span></figure>
<p class="tni"><span aria-label="196" epub:type="pagebreak" id="pg_196" role="doc-pagebreak"/>Technically, this formula is valid only for initial displacement angles under 15 degrees, but it provides a good starting approximation. Dividing <i class="calibre9">T</i> by the number of time intervals per period <span class="sans_thesansmonocd_w5regular_">n</span> gives us the length of each time interval <span aria-label="annotation2" class="codeannotation">❷</span>.</p>
<p class="tx">Notice that we also arbitrarily set the maximum number of time steps, <span class="sans_thesansmonocd_w5regular_">Nmax</span>, to <span class="sans_thesansmonocd_w5regular_">4 * n</span> intervals to ensure that the simulation period includes at least three full cycles of the pendulum’s oscillation (the period of a pendulum gets longer as the initial displacement or amplitude gets larger). Feel free to try out other values for these parameters, but keep in mind that a larger <span class="sans_thesansmonocd_w5regular_">n</span> (and thus a smaller <span class="sans_thesansmonocd_w5regular_">dt</span>), or a longer simulation period, will increase the number of computations and require more memory to store all the intermediate values of the state variables.</p>
<p class="tx">After initializing the local variables, parameters, and the mutable list <span class="sans_thesansmonocd_w5regular_">pList</span> that saves the state variables (including time), we implement the Euler-Cromer method by using a <span class="sans_thesansmonocd_w5regular_">for</span> loop <span aria-label="annotation3" class="codeannotation">❸</span>. Inside this loop, we use Equations 5.16 and 5.18 to calculate <span class="sans_thesansmonocd_w5regular_">omegaNew</span> and <span class="sans_thesansmonocd_w5regular_">thetaNew</span>, along with the updated time <span class="sans_thesansmonocd_w5regular_">timeNew</span>. We store these in an instance of <span class="sans_thesansmonocd_w5regular_">PendulumData</span> and add it to <span class="sans_thesansmonocd_w5regular_">pList</span> <span aria-label="annotation4" class="codeannotation">❹</span>. Then we assign these “new” state variables back to the “old” state variables (for example, setting <span class="sans_thesansmonocd_w5regular_">omegaOld</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">omegaNew</span> <span aria-label="annotation5" class="codeannotation">❺</span>) for the next time through the loop. In all, these steps are repeated for each time interval, for a total of <span class="sans_thesansmonocd_w5regular_">Nmax</span> times.</p>
<p class="tx">The code segment includes several print statements that summarize the global values and parameters used to solve the problem. Then the segment ends by returning <span class="sans_thesansmonocd_w5regular_">pList</span> to the calling function.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h5 class="h2"><span id="sec14"/><span id="h3-38"/><span class="sans_futura_std_bold_b_">The singleXYChart() Function</span></h5>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">singleXYChart()</span> function creates a line chart with JavaFX. In this case, using the JavaFX charting tools is a more natural choice for creating our visualization than using the canvas feature, as we did in <span><a href="chapter5.xhtml#pre-18" class="calibre2">Project 18</a></span>. This time we want to be able to read off the values of the state variables directly from the charts, and this would not be easy to do from scratch using the canvas (we’d essentially have to write our own charting library).</p>
<p class="tx">Most of the code in this segment is boilerplate JavaFX code used for creating a line chart. Since this process was discussed in detail in <span><a href="chapter3.xhtml" class="calibre2">Chapter 3</a></span>, we’ll focus only on the problem-specific elements in this code.</p>
<pre class="calibre10"><code class="calibre11">fun singleXYChart(data: List&lt;XYChartData&gt;,
          title: String  = "",
          xLabel: String = "x-axis",
          yLabel: String = "y-axis",
          sort: String = "default"): LineChart&lt;Number, Number&gt; {

    // Define axes.
    val xAxis = NumberAxis()
    val yAxis = NumberAxis()
    xAxis.label = xLabel
    yAxis.label = yLabel

<span aria-label="197" epub:type="pagebreak" id="pg_197" role="doc-pagebreak"/>    // Create LineChart.
    val lineChart = LineChart(xAxis, yAxis)
    lineChart.title = title
  <span aria-label="annotation1" class="code_codeannotation">❶</span> lineChart.createSymbols = false
  <span aria-label="annotation2" class="code_codeannotation">❷</span> lineChart.isLegendVisible = false
  <span aria-label="annotation3" class="code_codeannotation">❸</span> if (sort == "NONE")
    lineChart.axisSortingPolicy = LineChart.SortingPolicy.NONE

    // Define series.
    val series = XYChart.Series&lt;Number, Number&gt;()

    // Populate series with data.
  <span aria-label="annotation4" class="code_codeannotation">❹</span> for (item in data) {
        val (x, y) = item
        series.data.add(XYChart.Data(x, y))
    }

    // Assign series with data to LineChart.
    lineChart.data.add(series)

    // Return LineChart object.
    return lineChart
}</code></pre>
<p class="tx">The first thing to notice is that the function takes five arguments, four of which are named arguments. We’ve provided default values for the named arguments in the function definition, and these defaults will be used unless we supply problem-specific values when calling the function.</p>
<p class="tx">To keep the chart clean and simple, we turn off markers <span aria-label="annotation1" class="codeannotation">❶</span> and the legend <span aria-label="annotation2" class="codeannotation">❷</span>. We also turn off the default sorting of x-values when the <span class="sans_thesansmonocd_w5regular_">sort</span> parameter is set to <span class="sans_thesansmonocd_w5regular_">"NONE"</span> <span aria-label="annotation3" class="codeannotation">❸</span>. As you saw in the main application code, we use this option when creating the chart of angular velocity over displacement, because we need to maintain the order of (<i class="calibre9"><span lang="el" xml:lang="el">ω</span></i>, <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>) pairs to correctly capture the cyclic nature of this relationship. Finally, we extract the data points for the line chart from <span class="sans_thesansmonocd_w5regular_">data</span> (which is a list of <span class="sans_thesansmonocd_w5regular_">XYChartData</span> instances) by deconstructing each <span class="sans_thesansmonocd_w5regular_">item</span> in <span class="sans_thesansmonocd_w5regular_">data</span> into a set of <span class="sans_thesansmonocd_w5regular_">x</span> and <span class="sans_thesansmonocd_w5regular_">y</span> values <span aria-label="annotation4" class="codeannotation">❹</span>.</p>
</section>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h4 class="h1"><span id="sec15"/><span id="h2-92"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">The program generates a few lines of text output and a scrollable window that contains our line charts. The text output should look like this:</p>
<pre class="calibre10"><code class="calibre11">*** Simple Pendulum Simulation ***

length l: 0.4 m
theta0: -30 degrees
omega0: 0 rad/sec
gamma: 0.6
dt: 0.0127 sec
Nmax: 400 intervals
Simulation length: 5.075 sec</code></pre>
<p class="tx"><span aria-label="198" epub:type="pagebreak" id="pg_198" role="doc-pagebreak"/>This output provides a reminder of the parameter values used and especially shows the time interval <i class="calibre9"><span lang="el" xml:lang="el">δ</span>t</i> that we’ve calculated internally based on the estimated period of the pendulum. You need to monitor this value if accuracy is a concern.</p>
<p class="tx">Regarding the content of the chart window, the first line chart shows how the angular displacement varies with time, and the second chart shows the same for angular velocity (see <a href="chapter5.xhtml#fig5-8" class="calibre2">Figure 5-8</a>).</p>
<figure class="img"><img alt="" class="img1" height="701" id="fig5-8" src="../images/Figure5-8.jpg" width="1681"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 5-8: The angular displacement (left) and angular velocity (right) of a pendulum facing air resistance</span></p></figcaption>
</figure>
<p class="tx">The charts show the pendulum’s periodic pattern decaying, or dampening, due to air resistance; otherwise, the maximum displacement and the maximum velocity would remain unchanged. Notice the phase difference between <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> (displacement) and <i class="calibre9"><span lang="el" xml:lang="el">ω</span></i> (velocity): <i class="calibre9"><span lang="el" xml:lang="el">ω</span></i> lags <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> by a fixed distance along the time axis. Specifically, whenever <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> is at its most extreme, <i class="calibre9"><span lang="el" xml:lang="el">ω</span></i> is 0, and vice versa. For example, at <i class="calibre9">t</i> = 0, <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> is at its maximum displacement, –<span class="copyright_accent"><span lang="el" xml:lang="el">π</span></span>/6 (to the left of the equilibrium position), but <i class="calibre9"><span lang="el" xml:lang="el">ω</span> =</i> 0; then, at approximately <i class="calibre9">t</i> = 0.32, the pendulum passes through its equilibrium position (<i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> = 0) and <i class="calibre9"><span lang="el" xml:lang="el">ω</span></i> reaches its maximum magnitude. This is because at this location, all of the pendulum’s potential energy becomes kinetic energy. Beyond that point, <i class="calibre9"><span lang="el" xml:lang="el">ω</span></i> begins to drop as the kinetic energy converts back into potential energy, until <i class="calibre9"><span lang="el" xml:lang="el">ω</span></i> becomes 0 again at the point of maximum displacement on the opposite side.</p>
<p class="tx">This relationship can be shown directly by plotting <i class="calibre9"><span lang="el" xml:lang="el">ω</span></i> against <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>, which is exactly what we’ve done in our third plot. This kind of visualization is known as a <i class="calibre9">phase-space plot</i>; for a dynamic system in two dimensions, it plots velocity <i class="calibre9">v</i>(<i class="calibre9">t</i>) over displacement <i class="calibre9">x</i>(<i class="calibre9">t</i>), the common denominator being time, <i class="calibre9">t</i>. Also called a <i class="calibre9">phase portrait</i>, a phase-space plot helps in studying complex system behaviors and uncovering relationships between the state variables that might otherwise remain undetected. <a href="chapter5.xhtml#fig5-9" class="calibre2">Figure 5-9</a> shows our phase-space plot for the pendulum, with <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> on the x-axis and <i class="calibre9"><span lang="el" xml:lang="el">ω</span></i> on the y-axis.</p>
<span aria-label="199" epub:type="pagebreak" id="pg_199" role="doc-pagebreak"/>
<figure class="img"><img alt="" class="img2" height="845" id="fig5-9" src="../images/Figure5-9.jpg" width="1037"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 5-9: A phase-space plot of a simple pendulum with damped motion</span></p></figcaption>
</figure>
<p class="tx">The main point to notice in the plot is that while <i class="calibre9"><span lang="el" xml:lang="el">ω</span></i> and <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> are still related through the parameter <i class="calibre9">t</i>, both are decreasing due to air resistance. With each time step, the pendulum gets a bit slower and its swing a bit narrower—hence the distinctive spiral shape of the plot. If you’re wondering what the pattern might look like for an undamped pendulum that isn’t experiencing any air resistance, you can simply set the drag coefficient <i class="calibre9"><span lang="el" xml:lang="el">γ</span></i> to 0 and run the program again to investigate.</p>
<aside aria-label="box-29" class="box2">
<p class="boxtitle" id="box-29"><span class="sans_futura_std_bold_b_">EXERCISE</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">For many periodic systems, the Euler-Cromer method, which is</span> <span class="sans_futura_std_book_oblique_">first-order convergent</span> <span class="sans_futura_std_book_">(the global error is proportional to the step size), isn’t suitable, because it will require too many computations to produce results of acceptable accuracy. The Runge-Kutta (R-K) method offers significant computational efficiency and accuracy over the Euler-Cromer method. Study the R-K method and implement the algorithm in Kotlin to solve the simple pendulum problem. (Detailed instructions can be found in any introductory resource on numerical analysis, including those provided at the end of this chapter.) You’ll notice that the R-K method will allow you to use larger time steps to achieve the same level of accuracy as the Euler-Cromer method.</span></p>
</aside>
<p class="headaexercise" id="pre-20"><span aria-label="200" epub:type="pagebreak" id="pg_200" role="doc-pagebreak"/><span class="sans_dogma_ot_bold_b_15-n">Project 20: The Physics of Coffee Cooling</span></p>
<p class="tni">Now we’ll turn our attention from the physics of motion to the physics of heat transfer. Imagine you’ve picked up a cup of coffee from your favorite coffee shop on your way to work in the morning. It’s a 25-minute drive from the coffee shop to your office, during which the coffee will get colder due to heat loss. You like to have milk in your coffee, but the milk is kept refrigerated, so adding it will further lower the temperature of the coffee. You could add milk right away at the coffee shop or wait to add milk from your office refrigerator. Which option should you use to keep your coffee as warm as possible?</p>
<p class="tx">We’ll write a Kotlin application to plot the coffee’s change in temperature over time in both scenarios. For that, we’ll first need to review Newton’s law of cooling, which defines how an object cools due to the loss of heat energy to its surroundings. We also have to consider the science of mixing two different liquids so we can figure out how to calculate the change of temperature when we add cold milk to hot coffee.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h4 class="h1"><span id="sec16"/><span id="h2-93"/><span class="sans_futura_std_bold_condensed_oblique_">Newton’s Law of Cooling</span></h4>
<p class="tni">Newton’s law of cooling states that the rate of change of the temperature of an object is proportional to the difference between the object’s temperature and the ambient temperature. It can be mathematically expressed as follows:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mfrac><mrow><mi>d</mi><mi>T</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mo>−</mo><mi>k</mi><mo stretchy="false">(</mo><mi>T</mi><mo>−</mo><msub><mi>T</mi><mi>a</mi></msub><mo stretchy="false">)</mo></mrow></math> (5.19)</span>
<span class="mobi"><img alt="" class="img1" height="77" src="../images/eq5-19.jpg" width="1385"/></span></figure>
<p class="tx"><i class="calibre9">T</i> is the temperature of the object at time <i class="calibre9">t</i>, <i class="calibre9">T</i><span class="epub-i-sub">a</span> is the ambient temperature, which is assumed to remain constant, and <i class="calibre9">k</i> is the heat transfer coefficient. For situations where <i class="calibre9">T</i> is greater than <i class="calibre9">T</i><span class="epub-i-sub">a</span>, the greater the value of <i class="calibre9">k</i>, the quicker the object will cool.</p>
<p class="tx">The value of the coefficient <i class="calibre9">k</i> depends on the material and surface properties of the object, as well as on the temperature of the object itself. When the primary method of heat loss is conduction, and convective and radiative losses are negligible, <i class="calibre9">k</i> can be assumed to remain constant for a small range of temperature variations. Our coffee cooling problem meets these requirements well: most of the heat loss happens conductively through the wall of the cup, convection is minimized by keeping a lid on the cup, and electromagnetic radiation in this temperature range is negligible compared to the other two factors.</p>
<p class="tx">Let’s now look at the solution of Equation 5.19, which is a first-order ordinary differential equation. For the initial temperature <i class="calibre9">T</i><sub class="calibre19">0</sub> (at <i class="calibre9">t</i> = 0) &gt; <i class="calibre9">T</i><span class="epub-i-sub">a</span>, the solution can be expressed as:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>T</mi><mi>a</mi></msub><mo>+</mo><mfenced><mrow><msub><mi>T</mi><mn>0</mn></msub><mo>−</mo><msub><mi>T</mi><mi>a</mi></msub></mrow></mfenced><mtext> </mtext><mtext> </mtext><msup><mi>e</mi><mrow><mo>−</mo><mi>k</mi><mi>t</mi></mrow></msup></mrow></math> (5.20)</span>
<span class="mobi"><img alt="" class="img1" height="46" src="../images/eq5-20.jpg" width="1385"/></span></figure>
<p class="tx">Equation 5.20 will allow us to calculate the temperature of the coffee (with or without milk) given the initial coffee temperature <i class="calibre9">T</i><sub class="calibre19">0</sub>, the ambient temperature <i class="calibre9">T</i><span class="epub-i-sub">a</span>, the elapsed time <i class="calibre9">t</i>, and the heat transfer coefficient <i class="calibre9">k</i>.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<span aria-label="201" epub:type="pagebreak" id="pg_201" role="doc-pagebreak"/>
<h4 class="h1"><span id="sec17"/><span id="h2-94"/><span class="sans_futura_std_bold_condensed_oblique_">The Effect of Mixing Liquids</span></h4>
<p class="tni">When two liquids of different temperatures are mixed together, the hotter liquid gets cooler by releasing heat energy, and the colder liquid gets warmer by absorbing the released heat. This exchange of heat energy will continue until both liquids attain the same temperature.</p>
<p class="tx">Mathematically, the amount of heat <i class="calibre9">Q</i> absorbed or released by one of the liquids, and its corresponding change in temperature <i class="calibre9"><span lang="el" xml:lang="el">Δ</span>T</i>, are related as follows:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>Q</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><mi>C</mi><mi>Δ</mi><mi>T</mi><mo>,</mo><mtext> </mtext><mtext>where</mtext><mtext> </mtext><mi>C</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><mi>ρ</mi><mi>V</mi><mi>s</mi></mrow></math> (5.21)</span>
<span class="mobi"><img alt="" class="img1" height="41" src="../images/eq5-21.jpg" width="1386"/></span></figure>
<p class="tx">The term <i class="calibre9">C</i> in Equation 5.21 is called the <i class="calibre9">thermal mass</i> of the object, which is the product of its density <i class="calibre9"><span lang="el" xml:lang="el">ρ</span></i>, volume <i class="calibre9">V</i>, and specific heat capacity <i class="calibre9">s</i>. In SI units, <i class="calibre9">Q</i> is measured in joules (J), temperature <i class="calibre9">T</i> in degrees Celsius (°C), <i class="calibre9"><span lang="el" xml:lang="el">ρ</span></i> in kg/m<sup class="calibre8">3</sup>, <i class="calibre9">V</i> in m<sup class="calibre8">3</sup>, and <i class="calibre9">s</i> in J/(kg °C). As a result, the unit for <i class="calibre9">C</i> will be J/°C. For the coffee cooling problem, since we’ll be working with small quantities of liquids, we’ll use grams per milliliter (g/mL) for density, mL for volume, and J/(g °C) for specific heat capacity.</p>
<p class="tx">Say we’re mixing two liquids such that <i class="calibre9">C</i><sub class="calibre19">1</sub>, <i class="calibre9">T</i><sub class="calibre19">1</sub>, and <i class="calibre9">T</i><span class="epub-i-sub">f</span> are the thermal mass, initial temperature, and final temperature for liquid 1, and <i class="calibre9">C</i><sub class="calibre19">2</sub>, <i class="calibre9">T</i><sub class="calibre19">2</sub>, and <i class="calibre9">T</i><span class="epub-i-sub">f</span> are the same for liquid 2. (Notice that the final temperature for both liquids is the same.) If the mixing happens quickly, with no heat exchange with the surrounding environment, and if the liquids don’t chemically react and generate or absorb heat, the principle of conservation of energy suggests that the net change in energy in the system will be zero—that is, <i class="calibre9">Q</i><sub class="calibre19">1</sub> + <i class="calibre9">Q</i><sub class="calibre19">2</sub> = 0. After substituting for <i class="calibre9">Q</i><sub class="calibre19">1</sub> and <i class="calibre9">Q</i><sub class="calibre19">2</sub> using Equation 5.21 and simplifying the results, we get the following expression for the final temperature:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msub><mi>T</mi><mi>f</mi></msub><mo>=</mo><mtext> </mtext><mfrac><mrow><msub><mi>C</mi><mn>1</mn></msub><msub><mi>T</mi><mn>1</mn></msub><mo>+</mo><msub><mi>C</mi><mn>2</mn></msub><msub><mi>T</mi><mn>2</mn></msub></mrow><mrow><msub><mi>C</mi><mn>1</mn></msub><mo>+</mo><msub><mi>C</mi><mn>2</mn></msub></mrow></mfrac></mrow></math> (5.22)</span>
<span class="mobi"><img alt="" class="img1" height="100" src="../images/eq5-22.jpg" width="1386"/></span></figure>
<p class="tx">You can use Equation 5.22 to calculate the temperature of the coffee after adding milk, either at the coffee shop or when you arrive at the office. Finally, we have all the science worked out to solve our problem and enjoy the optimal cup of coffee.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h4 class="h1"><span id="sec18"/><span id="h2-95"/><span class="sans_futura_std_bold_condensed_oblique_">The Strategy</span></h4>
<p class="tni">To identify the right time for adding milk, we need some data on the properties of the coffee and milk, as well as the ambient temperature of the environment. This data is summarized in <a href="chapter5.xhtml#tab5-2" class="calibre2">Table 5-2</a>.</p>
<span aria-label="202" epub:type="pagebreak" id="pg_202" role="doc-pagebreak"/>
<p class="tt" id="tab5-2"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 5-2:</span></span> <span class="sans_futura_std_book_">Coffee Cooling Problem Data</span></p>
<table class="basic-table">
<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Item</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Value and unit</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">Initial temperature of black coffee</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">92°C</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Volume of black coffee</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">250 mL</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Density of black coffee</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">1 g/mL</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Specific heat capacity of coffee</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">4.19 J/(g °C)</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Initial temperature of refrigerated milk</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">4°C</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Volume of milk added to the coffee</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">25 mL</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Density of milk</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">1.035 g/mL</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Specific heat capacity of milk</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">3.89 J/(g °C)</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Length of the drive from the coffee shop to the office</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">25 minutes</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Heat transfer coefficient for coffee (assumed to be the same with or without milk)</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">0.0116/minute</span></p></td>
</tr>
<tr class="calibre16">
<td class="tbl"><p class="tableheader"><span class="sans_futura_std_book_">Ambient temperature everywhere</span></p></td>
<td class="tbl"><p class="tableheader"><span class="sans_futura_std_book_">20°C</span></p></td>
</tr>
</tbody>
</table>
<p class="tx">Armed with the science of coffee cooling and the data presented in <a href="chapter5.xhtml#tab5-2" class="calibre2">Table 5-2</a>, we can now solve the problem by following these steps:</p>
<p class="listhead"><b class="calibre6">Option 1: Add milk later</b></p>
<p class="listnumber">  1.  Calculate the temperature of black coffee after 25 minutes, starting with the initial temperature of 92°C.</p>
<p class="listnumber2">  2.  Calculate the final temperature of the coffee after adding 25 mL of milk (assuming that mixing and heat exchange happen instantly).</p>
<p class="listhead"><b class="calibre6">Option 2: Add milk at the coffee shop</b></p>
<p class="listnumber">  1.  Calculate the initial temperature of the coffee when milk is added immediately at the coffee shop (assuming that mixing and heat exchange happen instantly).</p>
<p class="listnumber2">  2.  Calculate the final temperature of the coffee after 25 minutes.</p>
<p class="tx">By comparing the final temperatures from options 1 and 2, we’ll know which option will keep the coffee warmer.</p>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h4 class="h1"><span id="sec19"/><span id="h2-96"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">We’ll develop this program as a JavaFX application so we can plot the coffee’s temperature profile over time for both options. For this, we’ll use the same template as in <span><a href="chapter5.xhtml#pre-19" class="calibre2">Project 19</a></span>, with some changes to the problem-specific parts.</p>
<p class="tx">Let’s start with the problem definition and global parameters, along with the problem-specific components in the main application class, <span class="sans_thesansmonocd_w5regular_">MixCoffeeAndMilk</span>.</p>
<pre class="calibre10"><code class="calibre11">// import block
import javafx.application.Application
import javafx.scene.Scene
<span aria-label="203" epub:type="pagebreak" id="pg_203" role="doc-pagebreak"/>import javafx.scene.control.ScrollPane
import javafx.scene.layout.VBox
import javafx.scene.paint.Color
import javafx.scene.chart.*
import javafx.stage.Stage
import java.text.DecimalFormat
import kotlin.math.exp
import kotlin.math.ln
import java.text.DecimalFormat

// data classes
<span aria-label="annotation1" class="codeannotated_codeannotation">❶</span> data class State(
    val time: Double,
    val Temp: Double
)

// problem definition and global parameters
val coffeeT0 = 92.0      // degrees Celsius
val coffeeV = 250.0      // mL
val coffeeS = 4.190      // J/(gm C) - assumed same as water
val coffeeD = 1.0        // gm/mL - assumed same as water
val coffeeK = 0.0116     // 1/min

val milkT0 = 4.0         // degrees Celsius
val milkV = 25.0         // mL
val milkS = 3.890        // J/(gm C)
val milkD = 1.035        // gm/mL

val T_ambient = 20.0     // degrees Celsius
val timeMax = 25.0       // min (length of drive)
<span aria-label="annotation2" class="codeannotated_codeannotation">❷</span> val timeStep = 0.25      // min
val df = DecimalFormat("#.##")

// application class
class MixCoffeeAndMilk : Application() {
    override fun start(primaryStage: Stage) {
        val root = VBox()
        val scroll = ScrollPane()
        scroll.content = root
        val scene = Scene(scroll, 550.0, 600.0, Color.WHITE)
        primaryStage.title = "Coffee Cooling Profile"
        primaryStage.scene = scene
        primaryStage.show()

        // Execute steps for coffee cooling process.
        println("\n  *** Coffee Cooling Problem ***  \n")

        // step 1:
      <span aria-label="annotation3" class="code_codeannotation">❸</span> val state1 =
            newtonCooling(T0 = coffeeT0, Ta = T_ambient,
                          k = coffeeK,tMax = timeMax, dt = timeStep)
        printTimeAndTemp(state1.last(), 1)

<span aria-label="204" epub:type="pagebreak" id="pg_204" role="doc-pagebreak"/>        // step 2:
      <span aria-label="annotation4" class="code_codeannotation">❹</span> val finalT1 =
            tempAfterMixing(d1 = coffeeD, v1 = coffeeV, s1 = coffeeS,
                            T1 = state1.last().Temp,
                            d2 = milkD, v2 = milkV,
                            s2 = milkS, T2 = milkT0)
        println("step 2: final temp with milk: " +
                "${df.format(finalT1)} degrees Celsius\n")

        // step 3:
      <span aria-label="annotation5" class="code_codeannotation">❺</span> val initT2 =
            tempAfterMixing(d1 = coffeeD, v1 = coffeeV, s1 = coffeeS,
                            T1 = coffeeT0, d2 = milkD, v2 = milkV,
                            s2 = milkS, T2 = milkT0)
        println("step 3: initial temp with milk: " +
                "${df.format(initT2)} degrees Celsius")

        // step 4:
      <span aria-label="annotation6" class="code_codeannotation">❻</span> val state2 =
            newtonCooling(T0 = initT2, Ta = T_ambient, k = coffeeK,
                          tMax = timeMax, dt = timeStep)
        printTimeAndTemp(state2.last(), 4)

        // step 5:
      <span aria-label="annotation7" class="code_codeannotation">❼</span> val state3 =
            newtonCooling(T0 = finalT1, Ta = T_ambient,
                          k = coffeeK,tMax = timeMax, dt = timeStep,
                          start = timeMax)

      <span aria-label="annotation8" class="code_codeannotation">❽</span> val state4 =
            newtonCooling(T0 = state2.last().Temp,
                          Ta = T_ambient, k = coffeeK,
                          tMax = timeMax, dt = timeStep, start = timeMax)

        val states =
            listOf(state1, state2, state3, state4)

        createCoolingChart(root, states = states)
    }
}

fun main() {
    Application.launch(MixCoffeeAndMilk::class.java)
}</code></pre>
<p class="tx">The import block for this code segment is similar to that of <span><a href="chapter5.xhtml#pre-19" class="calibre2">Project 19</a></span>, except that we need fewer math functions. In addition to initializing the values from <a href="chapter5.xhtml#tab5-2" class="calibre2">Table 5-2</a>, we declare a data class called <span class="sans_thesansmonocd_w5regular_">State</span> <span aria-label="annotation1" class="codeannotation">❶</span> to save the temperature at a given time. This will help us organize the data to be plotted. Among the parameters, notice that we set <span class="sans_thesansmonocd_w5regular_">timeStep</span> to <span class="sans_thesansmonocd_w5regular_">0.25</span> minutes <span aria-label="annotation2" class="codeannotation">❷</span>. This way, we’ll track and plot the coffee’s cooling progress in 15-second intervals. This time step may seem surprisingly long compared to the very short time intervals from <span><a href="chapter5.xhtml#pre-19" class="calibre2">Project 19</a></span>, but it’s adequate for this problem because the <span aria-label="205" epub:type="pagebreak" id="pg_205" role="doc-pagebreak"/>temperature drops smoothly and slowly. Besides, we’re using an analytical solution and not a numerical approximation; thus, this choice doesn’t affect the accuracy of the calculations.</p>
<p class="tx">The problem-specific part of the code in the main application class follows the same order as the steps outlined in <span>“The Strategy”</span> on <span><a href="#pg_211" class="calibre2">page 211</a></span>, except that we’ve added an extra step (step 5) to further track the coffee as it continues to cool at the office (more on that shortly). The code here relies on two main helper functions: the <span class="sans_thesansmonocd_w5regular_">newtonCooling()</span> function, which calculates how the coffee cools over time, and the <span class="sans_thesansmonocd_w5regular_">tempAfterMixing()</span> function, which calculates the immediate temperature after adding the milk. We deploy these functions as follows:</p>
<ul class="ul">
<li class="listbullet">For step 1, we call <span class="sans_thesansmonocd_w5regular_">newtonCooling()</span> and save the result as <span class="sans_thesansmonocd_w5regular_">state1</span> <span aria-label="annotation3" class="codeannotation">❸</span>. This produces a list of type <span class="sans_thesansmonocd_w5regular_">State</span> containing the data points needed to show how the black coffee gets colder over time between the coffee shop and the office.</li>
<li class="listbullet">For step 2, we call <span class="sans_thesansmonocd_w5regular_">tempAfterMixing()</span> to get the final temperature of the coffee when milk is added after arriving at the office <span aria-label="annotation4" class="codeannotation">❹</span>. This is how warm the coffee will be before you take the first sip if you chose option 1 (add milk later).</li>
<li class="listbullet">For step 3, we call <span class="sans_thesansmonocd_w5regular_">tempAfterMixing()</span> to calculate the temperature of the coffee after adding milk at the coffee shop, before the drive to work <span aria-label="annotation5" class="codeannotation">❺</span>.</li>
<li class="listbullet">For step 4, we call <span class="sans_thesansmonocd_w5regular_">newtonCooling()</span> and save the resulting list of <span class="sans_thesansmonocd_w5regular_">State</span> data points as <span class="sans_thesansmonocd_w5regular_">state2</span> <span aria-label="annotation6" class="codeannotation">❻</span>. The temperature property of the last element of this list will tell us how warm the coffee will be when you arrive at the office after choosing option 2 (add milk first).</li>
</ul>
<p class="tx">During each step, we display some output from the simulation either by using the <span class="sans_thesansmonocd_w5regular_">println()</span> function or by calling the custom <span class="sans_thesansmonocd_w5regular_">printTimeAndTemp()</span> function, defined here:</p>
<pre class="calibre10"><code class="calibre11">fun printTimeAndTemp(datapoint: State, step: Int) {
    val (endTime, endTemp) = datapoint

    println("step $step: end time: ${df.format(endTime)} minutes")
    println("step $step: end temp: ${df.format(endTemp)} " +
            "degrees Celsius")
}</code></pre>
<p class="tx">We have everything we need to solve the problem after step 4, and the results are printed on the console. Let’s have a look at the results first, then come back to step 5 and the code for visualizing the cooling process.</p>
<pre class="calibre10"><code class="calibre11">  *** Coffee Cooling Problem ***

step 1: end time: 25 minutes
step 1: end temp: 73.87 degrees Celsius
step 2: final temp with milk: 67.75 degrees Celsius
<span aria-label="206" epub:type="pagebreak" id="pg_206" role="doc-pagebreak"/>step 3: initial temp with milk: 84.29 degrees Celsius
step 4: end time: 25 minutes
step 4: end temp: 68.1 degrees Celsius</code></pre>
<p class="tx">The final temperature of the coffee is 67.75°C when you add milk at the office versus 68.1°C when you add milk at the coffee shop. Though the difference isn’t that significant (just 0.35°C), you’ll be better off adding the milk at the coffee shop.</p>
<p class="tx">Of course, you could figure this out for yourself without any math or code by investing in a good-quality thermometer and brewing two cups of coffee. The benefit of building a mathematical model of the process, however, is that it not only tells us what the temperature will be after 25 minutes but also how the system will get there, starting from an initial state and considering interventions such as adding milk. Once we have the model, we can play with the parameter values and generate answers to many other questions, without making more coffee, adding more milk, and taking many temperature measurements.</p>
<p class="tx">For example, say you get pulled into a meeting right after you arrive at work. You have just enough time to add milk to your coffee (if you haven’t added it already), but you don’t have time to enjoy said coffee until the meeting ends—another 25 minutes later. What will the temperature of the coffee be at that point, a full 50 minutes after you bought it? Since we already have a mathematical model for how the coffee cools over time, this question is quite easy to answer.</p>
<p class="tx">This brings us to step 5, where we use the final temperatures after the first 25 minutes as the initial temperatures for running the simulation for a further 25 minutes. For this, we use an additional named parameter <span class="sans_thesansmonocd_w5regular_">start</span> in the <span class="sans_thesansmonocd_w5regular_">newtonCooling()</span> function. This parameter lets us offset the time values by <span class="sans_thesansmonocd_w5regular_">25</span> instead of starting the simulation time over at <span class="sans_thesansmonocd_w5regular_">0</span>. We call the function twice, generating lists <span class="sans_thesansmonocd_w5regular_">state3</span> <span aria-label="annotation7" class="codeannotation">❼</span> (for option 1—milk added at the office) and <span class="sans_thesansmonocd_w5regular_">state4</span> <span aria-label="annotation8" class="codeannotation">❽</span> (for option 2—milk added at the coffee shop).</p>
<p class="tx">Once all four states are calculated, we create a list of type <span class="sans_thesansmonocd_w5regular_">State</span> by using the <span class="sans_thesansmonocd_w5regular_">listOf()</span> method and pass this list to the <span class="sans_thesansmonocd_w5regular_">createCoolingChart()</span> function for plotting the temperature profiles for the entire 50-minute period.</p>
<section aria-labelledby="sec20" epub:type="division">
<h5 class="h2"><span id="sec20"/><span id="h3-39"/><span class="sans_futura_std_bold_b_">Calculating the Temperature Changes</span></h5>
<p class="tni">Now let’s review our two helper functions for calculating the temperature changes in the coffee. The <span class="sans_thesansmonocd_w5regular_">newtonCooling()</span> function tracks the temperature change of the coffee over a period of time. The <span class="sans_thesansmonocd_w5regular_">tempAfterMixing()</span> function calculates the instantaneous temperature change when the milk is mixed in.</p>
<pre class="calibre10"><code class="calibre11">fun newtonCooling(T0: Double, Ta: Double, k:Double,
                  tMax: Double, dt: Double,
                  start: Double = 0.0): List&lt;State&gt; {
    val state = mutableListOf&lt;State&gt;()
    var t = 0.0

    while (t &lt;= tMax) {
      <span aria-label="annotation1" class="code_codeannotation">❶</span> val temp = Ta + (T0 - Ta)*exp(-k * t)
      <span aria-label="annotation2" class="code_codeannotation">❷</span> state += State(t+start, temp)
<span aria-label="207" epub:type="pagebreak" id="pg_207" role="doc-pagebreak"/>        t += dt
    }
    return state
}

fun tempAfterMixing(
    d1: Double, v1: Double, s1: Double, T1: Double,
    d2: Double, v2: Double, s2: Double, T2: Double
    ): Double {

    return (d1 * v1 * s1 * T1 + d2 * v2 * s2 * T2) /
           (d1 * v1 * s1 + d2 * v2 * s2)
}</code></pre>
<p class="tx">In the <span class="sans_thesansmonocd_w5regular_">newtonCooling()</span> function, we use Equation 5.20 to calculate the temperature of the coffee at point <span class="sans_thesansmonocd_w5regular_">t</span> in time <span aria-label="annotation1" class="codeannotation">❶</span>. We do this in a <span class="sans_thesansmonocd_w5regular_">while</span> loop, incrementing <span class="sans_thesansmonocd_w5regular_">t</span> by <span class="sans_thesansmonocd_w5regular_">dt</span> (set to <span class="sans_thesansmonocd_w5regular_">timeStep</span>) each iteration, until we get to <span class="sans_thesansmonocd_w5regular_">tMax</span>, giving us time and temperature data points in 15-second intervals, up to 25 minutes, which we store in a list called <span class="sans_thesansmonocd_w5regular_">state</span> <span aria-label="annotation2" class="codeannotation">❷</span>.</p>
<p class="tx">Notice that we add <span class="sans_thesansmonocd_w5regular_">start</span> to each <span class="sans_thesansmonocd_w5regular_">t</span> before storing it in the list. When <span class="sans_thesansmonocd_w5regular_">start</span> isn’t set during the function call, it defaults to <span class="sans_thesansmonocd_w5regular_">0</span> and has no effect. However, when we call the function to create <span class="sans_thesansmonocd_w5regular_">state3</span> and <span class="sans_thesansmonocd_w5regular_">state4</span> (as part of step 5, discussed earlier), we set <span class="sans_thesansmonocd_w5regular_">start</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">timeMax</span> so the timestamps will range from 25 to 50. This allows us to plot all the data in a single chart.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">tempAfterMixing()</span> function takes in the separate density, volume, specific heat capacity, and premixing temperatures for the milk and coffee and returns the final equilibrium temperature once the milk is mixed in, using Equation 5.22.</p>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h5 class="h2"><span id="sec21"/><span id="h3-40"/><span class="sans_futura_std_bold_b_">Plotting the Temperature Profiles</span></h5>
<p class="tni">We’re now ready to plot the two temperature profiles of the cooling coffee. For that, we’ll define the <span class="sans_thesansmonocd_w5regular_">createCoolingChart()</span> function.</p>
<pre class="calibre10"><code class="calibre11">fun createCoolingChart(root: VBox, states: List&lt;List&lt;State&gt;&gt;) {

    val xyChart =
        singleXYChart(states,
            title = "Temperature of Coffee over Time",
            xLabel = "Time",
            yLabel = "Temperature (degrees Celsius)")

   root.children.add(xyChart)
}</code></pre>
<p class="tx">We use this short function mainly to preprocess the information needed by the <span class="sans_thesansmonocd_w5regular_">singleXYChart()</span> function, also used in <span><a href="chapter5.xhtml#pre-19" class="calibre2">Project 19</a></span>. This helps keep the body of the main application class less cluttered. Since we’ve discussed how to use <span class="sans_thesansmonocd_w5regular_">singleXYChart()</span> previously, I’ll skip that part here, except to mention that we’re now passing a list of lists rather than one single list as a collection of data points. Inside the <span class="sans_thesansmonocd_w5regular_">singleXYChart()</span> function, we therefore <span aria-label="208" epub:type="pagebreak" id="pg_208" role="doc-pagebreak"/>create four different series (from the list of lists, <span class="sans_thesansmonocd_w5regular_">states</span>) and plot them on the same chart instead of creating four separate charts. See <span><a href="chapter3.xhtml" class="calibre2">Chapter 3</a></span> for a review of how to plot a single series versus multiple series in the same chart.</p>
<p class="tx">The last line of this function adds the chart object <span class="sans_thesansmonocd_w5regular_">xyChart</span> returned by the <span class="sans_thesansmonocd_w5regular_">singleXYChart()</span> function to the <span class="sans_thesansmonocd_w5regular_">root</span> node for display. <a href="chapter5.xhtml#fig5-10" class="calibre2">Figure 5-10</a> shows the result.</p>
<figure class="img"><img alt="" class="img2" height="774" id="fig5-10" src="../images/Figure5-10.jpg" width="1103"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 5-10: The temperatures of black coffee and coffee with milk over time</span></p></figcaption>
</figure>
<p class="tx">The plot spans the entire 50-minute period of the simulation. We can see the sudden temperature drops when the milk is added either at the coffee shop (at time 0) or at the office (at time 25). After the latter, the temperature profiles appear to be almost identical. When we zoom in, however, as in <a href="chapter5.xhtml#fig5-11" class="calibre2">Figure 5-11</a>, we find a slight difference (less than 1°C).</p>
<figure class="img"><img alt="" class="img2" height="759" id="fig5-11" src="../images/Figure5-11.jpg" width="1094"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 5-11: A closer look at the coffee cooling problem for</span> <span class="sans_futura_std_book_">t</span> <span class="sans_futura_std_book_oblique_">&gt; 25 minutes</span></p></figcaption>
</figure>
<p class="tx"><span aria-label="209" epub:type="pagebreak" id="pg_209" role="doc-pagebreak"/>The gap between the two lines indicates that the coffee with milk added at the shop will always be a tad warmer. If we continue this experiment for a long time, will these temperature profiles still stay separate from each other? Why or why not?</p>
<aside aria-label="box-30" class="box2">
<p class="boxtitle" id="box-30"><span class="sans_futura_std_bold_b_">EXERCISE</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">In this exercise, you’ll apply Newton’s law of cooling to help with a forensic investigation into the death of a person whose body was found in a locked apartment. This is what you know so far: The body was found at 2:00</span> <span class="sans_futura_std_book_sc_">PM</span><span class="sans_futura_std_book_">, when the core body temperature was recorded as 25°C. A second body temperature reading two hours later (in the same room) yielded 23.6°C. The temperature inside the apartment was set to a constant 20°C. Assuming the person died in the same room where the body was found, estimate the approximate time of death.</span></p>
<p class="box1"><span class="sans_futura_std_book_">Hint: Start by writing a new function</span> <span class="sans_thesansmonocd_w5regular_">getHTC()</span> <span class="sans_futura_std_book_">to estimate the heat transfer coefficient</span> <span class="sans_futura_std_book_oblique_">k</span> <span class="sans_futura_std_book_">based on the two recorded body temperatures postmortem. Use the following equation:</span></p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>k</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mi>Δ</mi><mi>t</mi></mrow></mfrac><mi>ln</mi><mtext> </mtext><mfenced><mrow><mfrac><mrow><msub><mi>T</mi><mn>1</mn></msub><mo>−</mo><msub><mi>T</mi><mi>a</mi></msub></mrow><mrow><msub><mi>T</mi><mn>2</mn></msub><mo>−</mo><msub><mi>T</mi><mi>a</mi></msub></mrow></mfrac></mrow></mfenced></mrow></math></span>
<span class="mobi"><img alt="" class="img1" height="90" src="../images/pg209.jpg" width="1235"/></span></figure>
<p class="box1"><span class="sans_futura_std_book_">Here</span> <span class="sans_futura_std_book_oblique_"><span lang="el" xml:lang="el">Δ</span></span><span class="sans_futura_std_book_oblique_">t</span> <span class="sans_futura_std_book_">is the elapsed time between the two temperature readings,</span> <span class="sans_futura_std_book_oblique_">T</span><span class="sans_futura_std_book_sub_">1</span> <span class="sans_futura_std_book_">is the first reading,</span> <span class="sans_futura_std_book_oblique_">T</span><span class="sans_futura_std_book_sub_">2</span> <span class="sans_futura_std_book_">is the second reading, and</span> <span class="sans_futura_std_book_oblique_">T</span><span class="sans_futura_std_book_oblique_sub_">a</span> <span class="sans_futura_std_book_">is the ambient temperature. Next, write a second function using the same equation, but solve it for</span> <span class="sans_futura_std_book_oblique_"><span lang="el" xml:lang="el">Δ</span></span><span class="sans_futura_std_book_oblique_">t</span> <span class="sans_futura_std_book_">when</span> <span class="sans_futura_std_book_oblique_">k</span> <span class="sans_futura_std_book_">is given. This time,</span> <span class="sans_futura_std_book_oblique_">T</span><span class="sans_futura_std_book_sub_">1</span> <span class="sans_futura_std_book_">is the average body temperature of a live human (37°C), and</span> <span class="sans_futura_std_book_oblique_">T</span><span class="sans_futura_std_book_sub_">2</span> <span class="sans_futura_std_book_">is the first temperature reading taken at 2:00 PM.</span></p>
<p class="boxlast"><span class="sans_futura_std_book_">If you do the calculations correctly, you should get</span> <span class="sans_futura_std_book_oblique_"><span lang="el" xml:lang="el">Δ</span></span><span class="sans_futura_std_book_oblique_">t</span> <span class="sans_futura_std_book_">= 7.45 hours, which would place the time of death at approximately 6:33 AM. If this was your finding, congratulations! You have a bright future ahead of you as a forensic investigator.</span></p>
</aside>
<p class="headaexercise" id="pre-21"><span class="sans_dogma_ot_bold_b_15-n">Project 21: Simulate a Binary Star System</span></p>
<p class="tni">In this project, we’ll explore the moves made by “star couples”—not the latest objects of celebrity gossip, but rather the stars we can see when we look up at the night sky. Many of the bright objects in the universe that appear to the naked eye like a single star are in fact two stars in close proximity that “dance” or orbit around a common center of rotation. Depending on the stars’ mass, orbital velocity, and distance from each other, these <i class="calibre9">binary star systems</i> can create interesting and unique orbital patterns. We’ll visualize these patterns by creating a binary star system Kotlin app.</p>
</section>
</section>
<section aria-labelledby="sec22" epub:type="division">
<span aria-label="210" epub:type="pagebreak" id="pg_210" role="doc-pagebreak"/>
<h4 class="h1"><span id="sec22"/><span id="h2-97"/><span class="sans_futura_std_bold_condensed_oblique_">The Science of Binary Star Systems</span></h4>
<p class="tni">Binary star systems are governed by Newton’s laws of gravity and motion. Let’s consider the model binary system in two dimensions shown in <a href="chapter5.xhtml#fig5-12" class="calibre2">Figure 5-12</a>.</p>
<figure class="img"><img alt="" class="img3" height="667" id="fig5-12" src="../images/Figure5-12.jpg" width="815"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 5-12: A two-body system under gravity</span></p></figcaption>
</figure>
<p class="tx">Our binary system is made up of two astronomical bodies, shown as dark circles in the figure. The first body, located at (<i class="calibre9">x</i><sub class="calibre19">1</sub>, <i class="calibre9">y</i><sub class="calibre19">1</sub>), has a mass of <i class="calibre9">M</i><sub class="calibre19">1</sub>, and the second body, located at (<i class="calibre9">x</i><sub class="calibre19">2</sub>, <i class="calibre9">y</i><sub class="calibre19">2</sub>), has a mass of <i class="calibre9">M</i><sub class="calibre19">2</sub>. The distance from the center of <i class="calibre9">M</i><sub class="calibre19">1</sub> to the center of <i class="calibre9">M</i><sub class="calibre19">2</sub> is <i class="calibre9">r</i>, which we can calculate using the Pythagorean theorem:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>r</mi><mo>=</mo><msqrt><mrow><msup><mrow><mfenced><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></mfenced></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mfenced><mrow><msub><mi>y</mi><mn>2</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub></mrow></mfenced></mrow><mn>2</mn></msup></mrow></msqrt></mrow></math> (5.23)</span>
<span class="mobi"><img alt="" class="img1" height="51" src="../images/eq5-23.jpg" width="1387"/></span></figure>
<p class="tx">The law of gravity says that these two bodies will be pulled toward each other. In this example, <b class="calibre6"><i class="calibre9">F</i></b><span class="epub-b-sub">1</span> and <b class="calibre6"><i class="calibre9">F</i></b><span class="epub-b-sub">2</span> are the gravitational forces acting on body 1 and body 2, respectively. Notice that these forces are <i class="calibre9">vectors</i>, meaning they have both magnitude and direction. (We indicate vectors with <b class="calibre6">boldface</b> type.) According to the law of gravity, the force acting on body 1 (<b class="calibre6"><i class="calibre9">F</i></b><span class="epub-b-sub">1</span>) can be expressed as:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msub><mtext class="BI">F</mtext><mtext class="B">1</mtext></msub><mo>=</mo><mi>G</mi><mfrac><mrow><msub><mi>M</mi><mn>1</mn></msub><msub><mi>M</mi><mn>2</mn></msub></mrow><mrow><msub><mi>r</mi><mn>2</mn></msub></mrow></mfrac><mfenced><mrow><mover accent="true"><mtext class="BI">r</mtext><mo stretchy="true">^</mo></mover></mrow></mfenced><mo>=</mo><mi>F</mi><mfenced><mrow><mover accent="true"><mtext class="BI">r</mtext><mo stretchy="true">^</mo></mover></mrow></mfenced></mrow></math> (5.24)</span>
<span class="mobi"><img alt="" class="img1" height="91" src="../images/eq5-24.jpg" width="1387"/></span></figure>
<p class="tx">In Equation 5.24, <i class="calibre9">G</i> is a gravitation constant, <i class="calibre9">F</i> is the magnitude of the force vector, and <b class="calibre6"><i class="calibre9">ȓ</i></b> is a unit vector pointing from body 1 toward body 2. Further, Newton’s second law of motion says that the force <b class="calibre6"><i class="calibre9">F</i></b><span class="epub-b-sub">1</span> acting on body 1 of mass <i class="calibre9">M</i><sub class="calibre19">1</sub> will create an acceleration <b class="calibre6"><i class="calibre9">a</i></b><span class="epub-b-sub">1</span> along the direction of the force such that:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msub><mtext class="BI">F</mtext><mtext class="B">1</mtext></msub><mo>=</mo><msub><mi>M</mi><mn>1</mn></msub><msub><mtext class="BI sans">a</mtext><mtext class="B">1</mtext></msub></mrow></math> (5.25)</span>
<span class="mobi"><img alt="" class="img1" height="43" src="../images/eq5-25.jpg" width="1387"/></span></figure>
<p class="tx">We can combine Equations 5.24 and 5.25 to write expressions for the x- and y-components of acceleration <b class="calibre6"><i class="calibre9">a</i></b><span class="epub-b-sub">1</span> as:</p>
<span aria-label="211" epub:type="pagebreak" id="pg_211" role="doc-pagebreak"/>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msub><mi>a</mi><mrow><mn>1</mn><mi>x</mi></mrow></msub><mo>=</mo><mfenced><mrow><mfrac><mi>F</mi><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow></mfrac></mrow></mfenced><mfenced><mrow><mfrac><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><mi>r</mi></mfrac></mrow></mfenced></mrow></math> (5.26)<span class="sblock"/><math alttext="Equation" display="inline"><mrow><msub><mi>a</mi><mrow><mn>1</mn><mi>y</mi></mrow></msub><mo>=</mo><mfenced><mrow><mfrac><mi>F</mi><mrow><msub><mi>M</mi><mn>1</mn></msub></mrow></mfrac></mrow></mfenced><mfenced><mrow><mfrac><mrow><msub><mi>y</mi><mn>2</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub></mrow><mi>r</mi></mfrac></mrow></mfenced></mrow></math> (5.27)</span>
<span class="mobi"><img alt="" class="img1" height="245" src="../images/eq5-26-27.jpg" width="1383"/></span></figure>
<p class="tx">Finally, Newton’s third law of motion requires that <b class="calibre6"><i class="calibre9">F</i></b><span class="epub-b-sub">1</span> = −<b class="calibre6"><i class="calibre9">F</i></b><span class="epub-b-sub">2</span>. Thus, we can add a negative sign to the right-hand side of Equations 5.26 and 5.27 and replace <i class="calibre9">M</i><sub class="calibre19">1</sub> with <i class="calibre9">M</i><sub class="calibre19">2</sub> to calculate the acceleration components acting on body 2 due to <b class="calibre6"><i class="calibre9">F</i></b><span class="epub-b-sub">2</span> as:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msub><mi>a</mi><mrow><mn>2</mn><mi>x</mi></mrow></msub><mo>=</mo><mo>−</mo><mfenced><mrow><mfrac><mi>F</mi><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow></mfrac></mrow></mfenced><mfenced><mrow><mfrac><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>−</mo><msub><mi>x</mi><mn>1</mn></msub></mrow><mi>r</mi></mfrac></mrow></mfenced></mrow></math> (5.28)<span class="sblock"/><math alttext="Equation" display="inline"><mrow><msub><mi>a</mi><mrow><mn>2</mn><mi>y</mi></mrow></msub><mo>=</mo><mo>−</mo><mfenced><mrow><mfrac><mi>F</mi><mrow><msub><mi>M</mi><mn>2</mn></msub></mrow></mfrac></mrow></mfenced><mfenced><mrow><mfrac><mrow><msub><mi>y</mi><mn>2</mn></msub><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub></mrow><mi>r</mi></mfrac></mrow></mfenced></mrow></math> (5.29)</span>
<span class="mobi"><img alt="" class="img1" height="226" src="../images/eq5-28-29.jpg" width="1383"/></span></figure>
<p class="tx">To simulate the orbits of a binary system, we’ll first use these equations for the x- and y-components of acceleration to calculate the respective velocity components of the stars, then use those velocities to update the positions of the stars of our binary system.</p>
</section>
<section aria-labelledby="sec23" epub:type="division">
<h4 class="h1"><span id="sec23"/><span id="h2-98"/><span class="sans_futura_std_bold_condensed_oblique_">The Strategy</span></h4>
<p class="tni">In this section, we’ll develop a simple algorithm to track the stars in a binary system once they’re set in motion. First, however, we need to consider what units of measurement are appropriate to the cosmic scale of our astronomical calculations. We’ll use the following:</p>
<ul class="ul">
<li class="listbullet">For mass, we’ll use M<sub class="calibre19">ʘ</sub>, which is the mass of our sun. One <span class="listbullet_italic">solar mass</span> is approximately 2 × 10<sup class="calibre8">30</sup> kg, about 333,000 times the mass of Earth.</li>
<li class="listbullet">For distance, we’ll use the <span class="listbullet_italic">astronomical unit (AU)</span>, which is the average distance between the sun and Earth. One AU equals 149,597,870.7 km.</li>
<li class="listbullet">For time, we’ll use the <span class="listbullet_italic">solar year (yr)</span> as the standard unit, which is equal to 365 days, 5 hours, 48 minutes, and 46 seconds.</li>
</ul>
<p class="tni">Given these basic units, the unit for velocity will be AU/yr, and the unit for acceleration will be AU/yr<sup class="calibre8">2</sup>. This, in turn, gives us a gravitational constant <i class="calibre9">G</i> of 4<span class="copyright_accent"><span lang="el" xml:lang="el">π</span></span><sup class="calibre8">2</sup> AU<sup class="calibre8">3</sup> yr<sup class="calibre8">–2</sup> M<sub class="calibre19">ʘ</sub><sup class="calibre8">–1</sup>.</p>
<p class="tx">Now we’re ready to move on to the algorithm, which is similar to the algorithm used in <span><a href="chapter5.xhtml#pre-19" class="calibre2">Project 19</a></span>. Here are the steps we’ll follow to calculate the positions of the binary stars:</p>
<p class="listnumber">  1.  Get the initial position and velocity vectors (in terms of x- and y-components) for the binary stars (including their masses and the gravitation constant, <span class="copyright_italic">G</span>). Use the system of units we just discussed.</p>
<p class="listnumber1">  2.  Calculate the distance <span class="copyright_italic">r</span> between the stars at a given time <span class="copyright_italic">t</span>, using Equation 5.23.</p>
<p class="listnumber1">  3.  Calculate x- and y-components of the accelerations, using Equations 5.26 through 5.29.</p>
<p class="listnumber2"><span aria-label="212" epub:type="pagebreak" id="pg_212" role="doc-pagebreak"/>  4.  Choose a small enough time step <i class="calibre9">dt</i> and update the velocity and position vectors, using the Euler-Cromer rule. The components of the velocity and position vectors along the x-axis can be calculated as:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msub><mi>v</mi><mrow><mi>x</mi><mo>,</mo><mtext> </mtext><mi>t</mi><mtext> </mtext><mo>+</mo><mtext> </mtext><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>v</mi><mrow><mi>x</mi><mo>,</mo><mtext> </mtext><mtext> </mtext><mi>t</mi></mrow></msub><mo>+</mo><mtext> </mtext><msub><mi>a</mi><mrow><mi>x</mi><mo>,</mo><mtext> </mtext><mtext> </mtext><mi>t</mi></mrow></msub><mtext> </mtext><mi>d</mi><mi>t</mi></mrow></math> (5.30)<span class="sblock"/><math alttext="Equation" display="inline"><mrow><msub><mi>x</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>x</mi><mi>t</mi></msub><mo>+</mo><msub><mi>v</mi><mrow><mi>x</mi><mo>,</mo><mtext> </mtext><mi>t</mi><mtext> </mtext><mo>+</mo><mtext> </mtext><mn>1</mn></mrow></msub><mtext> </mtext><mi>d</mi><mi>t</mi></mrow></math> (5.31)</span>
<span class="mobi"><img alt="" class="img1" height="135" src="../images/eq5-30-31.jpg" width="1389"/></span></figure>
<p class="listnumber1">  5.  Repeat step 4 for the components along the y-axis for both stars.</p>
<p class="listnumber1">  6.  Repeat steps 2 through 5 until the stopping condition is met. We’ll set the maximum number of iterations as the stopping condition.</p>
<p class="txs">Of course, the whole point of making all these calculations is to be able to sit back and enjoy watching the dance steps of the stars. After each cycle through the algorithm, we’ll animate the stars’ motion by plotting the new positions by using the canvas feature of JavaFX. We’ll also give each star a trail to better illustrate the orbital paths. A significant part of the code for this app is devoted to displaying and managing the moving objects on the canvas.</p>
</section>
<section aria-labelledby="sec24" epub:type="division">
<h4 class="h1"><span id="sec24"/><span id="h2-99"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">We’ll review the code segments for this project in the same order as they appear in the app. Let’s start with the imports and declarations that come before the <span class="sans_thesansmonocd_w5regular_">SimulateBinarySystem</span> application class.</p>
<pre class="calibre10"><code class="calibre11">// animation-related tools
import javafx.animation.KeyFrame
import javafx.animation.Timeline
import javafx.util.Duration

// graphics-related tools
import javafx.application.Application
import javafx.scene.Scene
import javafx.scene.canvas.Canvas
import javafx.scene.canvas.GraphicsContext
import javafx.scene.layout.Pane
import javafx.scene.paint.Color
import javafx.stage.Stage

// math functions
import kotlin.math.*

// data class
data class Star(
    val mass: Double,
    val size: Double,
    var x: Double,
    var y: Double,
    var vx: Double,
    var vy: Double,
    var xOld: Double = 0.0,
    var yOld: Double = 0.0,
<span aria-label="213" epub:type="pagebreak" id="pg_213" role="doc-pagebreak"/>    var trailCount: Int = 0,
    val color: Color = Color.GOLD
)

// problem definition and global declarations
// initial state of the binary system
val stars = listOf(
    Star(mass = 0.73606507, size = 40.0, x = -35.0, y = 0.0,
         vx = 0.0, vy = 0.3045865, color = Color.BLACK),
    Star(mass = 0.50121162, size = 25.0, x = 51.4, y = 0.0,
         vx = 0.0, vy = -0.447307098, color = Color.BLACK)
)
val G = 4 * PI * PI

// Set canvas/animation parameters.
val canvasW = 800.0
val canvasH = 800.0
val durationMillis = 4.0
val frameCountMax = 50_000

// parameters related to star trails
val TRAIL_CODE = "YES"
val trails = Array(2) {ArrayList&lt;Pair&lt;Double,Double&gt;&gt;()}
val trailMAX = 6500
val trailSize = 2.0
val scaleFactor = 4</code></pre>
<p class="tx">The first three lines of the import block load important tools (<span class="sans_thesansmonocd_w5regular_">KeyFrame</span>, <span class="sans_thesansmonocd_w5regular_">Timeline</span>, and <span class="sans_thesansmonocd_w5regular_">Duration</span>) for creating frame-by-frame animations with JavaFX. The remaining imports are similar to what we’ve used previously in this chapter.</p>
<p class="tx">After the imports, we declare a <span class="sans_thesansmonocd_w5regular_">Star</span> data class to hold the properties needed for representing a star, including its mass, x- and y-coordinates, and velocity components. The <span class="sans_thesansmonocd_w5regular_">size</span> property, specified in pixels, is the diameter of the circle that will represent a particular star; <span class="sans_thesansmonocd_w5regular_">xOld</span> and <span class="sans_thesansmonocd_w5regular_">yOld</span> will hold a copy of the star’s current position vector before updating it (needed to generate its trails); <span class="sans_thesansmonocd_w5regular_">trailCount</span> sets the number of small dots that will follow a star to mark its trail; and <span class="sans_thesansmonocd_w5regular_">color</span> defines the color used to draw the star and its trail. Because this book is printed in black and white, all figures have been generated with the default color (<span class="sans_thesansmonocd_w5regular_">BLACK</span>), but feel free to experiment with any color you like when you run the code on your device.</p>
<p class="tx">The problem definition and global declaration section starts with creating <span class="sans_thesansmonocd_w5regular_">stars</span> as a list of two <span class="sans_thesansmonocd_w5regular_">Star</span> objects. We initialize each with its <span class="sans_thesansmonocd_w5regular_">mass</span>, <span class="sans_thesansmonocd_w5regular_">size</span>, current x- and y-coordinates (<span class="sans_thesansmonocd_w5regular_">x</span>, <span class="sans_thesansmonocd_w5regular_">y</span>), components of the velocity vector along the positive x- and y-axes (<span class="sans_thesansmonocd_w5regular_">vx</span>, <span class="sans_thesansmonocd_w5regular_">vy</span>), and color for drawing the star on the canvas. Since we’re not going to draw the stars to proper scale, I’m just using two arbitrary sizes that might look reasonable given the size of the canvas. You could make them proportional to their masses if you have reason to believe that the stars have similar densities. Also, notice that we’ve set the gravitational constant <span class="sans_thesansmonocd_w5regular_">G</span> to 4<span class="copyright_accent"><span lang="el" xml:lang="el">π</span></span><sup class="calibre8">2</sup> because we’re using the astronomical units mentioned earlier.</p>
<p class="tx"><span aria-label="214" epub:type="pagebreak" id="pg_214" role="doc-pagebreak"/>In the next part of the code, we first set the width (<span class="sans_thesansmonocd_w5regular_">canvasW</span>) and height (<span class="sans_thesansmonocd_w5regular_">canvasH</span>) of the canvas to 800 pixels (without any scaling, this would be equivalent to 800 AU in both directions). The <span class="sans_thesansmonocd_w5regular_">durationMillis</span> parameter sets the duration per animation frame to 4.0 milliseconds. The <span class="sans_thesansmonocd_w5regular_">frameCountMax =</span> <span class="sans_thesansmonocd_w5regular_">50_000</span> means the app will stop simulating the binary system after 50,000 frames. If <span class="sans_thesansmonocd_w5regular_">dt</span> = 1 year, that will be equivalent to observing the system for 50,000 years! You may not need to simulate the system for such a long time (you can terminate the app at any time by closing the animation window). However, it’s a good idea to run a simulation for several rounds of full orbits (when the expected orbit is either a circle or an ellipse) to confirm that the simulated orbits are stable. Once this is confirmed, you can play God with the parameters and see how the movements of the stars go crazy!</p>
<p class="tx">The final code segment in this block sets parameters for the trails, allowing us to visualize the path traced by the stars during live simulations. By default, the <span class="sans_thesansmonocd_w5regular_">TRAIL_CODE</span> is set to <span class="sans_thesansmonocd_w5regular_">YES</span>, which means that trails for both stars will be drawn on the canvas alongside their parent stars. Each trail is composed of small dots or tracers that follow the parent star. The dots’ coordinates are saved in a two-dimensional array called <span class="sans_thesansmonocd_w5regular_">trails</span>, where each element represents x- and y-coordinates stored as a <span class="sans_thesansmonocd_w5regular_">Pair</span> of type <span class="sans_thesansmonocd_w5regular_">&lt;Double, Double&gt;</span>. To ensure that the full orbital path is traced out by the trails when the orbit is stable, we set the number of trail elements to <span class="sans_thesansmonocd_w5regular_">6500</span>. Try to keep this number to a minimum, however; otherwise, too many dots in the trails can slow down the animation and force you to adjust the duration of the frame.</p>
<section aria-labelledby="sec25" epub:type="division">
<h5 class="h2"><span id="sec25"/><span id="h3-41"/><span class="sans_futura_std_bold_b_">The SimulateBinarySystem Application Class</span></h5>
<p class="tni">The core part of the app is the <span class="sans_thesansmonocd_w5regular_">SimulateBinarySystem</span> application class, where we combine Kotlin with JavaFX to drive the key parts of the app and run the animation.</p>
<pre class="calibre10"><code class="calibre11">class SimulateBinarySystem : Application() {
    override fun start(stage: Stage) {
        val root = Pane()
        val canvas = Canvas(canvasW, canvasH)
        val gc = canvas.graphicsContext2D
      <span aria-label="annotation1" class="code_codeannotation">❶</span> gc.translate((canvas.width)/2.0, (canvas.height)/2.0)
      <span aria-label="annotation2" class="code_codeannotation">❷</span> gc.scale(1.0, -1.0)
        root.children.add(canvas)

        val scene = Scene(root, canvasW, canvasH)
        //scene.fill = Color.WHITE
        stage.title = "Binary System Simulation"
        stage.scene = scene
        stage.show()

        // -----------simulation block-----------
        // Set the background and initial positions.
      <span aria-label="annotation3" class="code_codeannotation">❸</span> initialPositions(gc)

        // Start animation.
      <span aria-label="annotation4" class="code_codeannotation">❹</span> val t = Timeline()
        var frameCount = 0
<span aria-label="215" epub:type="pagebreak" id="pg_215" role="doc-pagebreak"/>        val dt = 1.0
        val iterMax = 1

      <span aria-label="annotation5" class="code_codeannotation">❺</span> val k = KeyFrame(Duration.millis(durationMillis), {
            for (i in 1..iterMax)
                updateStarPositions(stars, dt)
            drawStars(gc)
            if (TRAIL_CODE == "YES")
                updateAndDrawTrails(gc)
            frameCount += 1
            // Check the stopping condition.
          <span aria-label="annotation6" class="code_codeannotation">❻</span> if (frameCount &gt;= frameCountMax) {
                println("maximum limit for frameCount reached")
                t.stop()
            }
        })
      <span aria-label="annotation7" class="code_codeannotation">❼</span> t.keyFrames.add(k)
        t.cycleCount = Timeline.INDEFINITE
        t.play()
    }
}

fun main() {
    Application.launch(SimulateBinarySystem::class.java)
}</code></pre>
<p class="tx">The first section of this code segment is boilerplate JavaFX code that we’ve used before. Notice that this time we’re setting the origin of the coordinate system to the center of the canvas <span aria-label="annotation1" class="codeannotation">❶</span>. Also, the positive y-axis direction is set to point upward <span aria-label="annotation2" class="codeannotation">❷</span>.</p>
<p class="tx">Inside the simulation block, we first call the <span class="sans_thesansmonocd_w5regular_">initialPositions()</span> function <span aria-label="annotation3" class="codeannotation">❸</span>, which draws the x- and y-axes on the canvas, places the stars on the canvas based on their position vectors, and initializes an array of type <span class="sans_thesansmonocd_w5regular_">Pair</span> called <span class="sans_thesansmonocd_w5regular_">trails</span> if the <span class="sans_thesansmonocd_w5regular_">TRAIL_CODE</span> is set to <span class="sans_thesansmonocd_w5regular_">YES</span>. Since this function is very short, I’ll show it and the <span class="sans_thesansmonocd_w5regular_">drawAxes()</span> function, which is called from within the <span class="sans_thesansmonocd_w5regular_">initialPositions()</span> function, right here:</p>
<pre class="calibre10"><code class="calibre11">fun initialPositions(gc: GraphicsContext) {
    drawAxes(gc)
    stars.forEachIndexed {index, star -&gt;
        gc.fill = star.color
        gc.fillOval(
            scaleFactor * star.x - star.size/2,
            scaleFactor * star.y - star.size/2,
            star.size, star.size)

        // Place the tracers to initial star position.
        if (TRAIL_CODE == "YES") {
            for (i in 1..trailMAX) {
                trails[index].add(Pair(star.x, star.y))
            }
        }
    }
}

<span aria-label="216" epub:type="pagebreak" id="pg_216" role="doc-pagebreak"/>fun drawAxes(gc: GraphicsContext) {
    // Draw the x- and y-axes.
    with(gc) {
        setLineDashes()
        lineWidth = 0.25
        stroke = Color.BLACK
        strokeLine(-canvasW/2,0.0, canvasW/2,0.0)
        strokeLine(0.0,-canvasH/2, 0.0,canvasH/2)
    }
}</code></pre>
<p class="tx">Notice that we use a <span class="sans_thesansmonocd_w5regular_">forEachIndexed</span> structure for iteration instead of a standard <span class="sans_thesansmonocd_w5regular_">for</span> loop in the <span class="sans_thesansmonocd_w5regular_">initialPositions()</span> function. This is because we need the <span class="sans_thesansmonocd_w5regular_">index</span> property of the stars to create the respective trails in the second part of the function. Each star’s trail consists of <span class="sans_thesansmonocd_w5regular_">trailMAX</span> number of dots, or tracers, which for now we initialize to the same starting position as the star itself.</p>
<p class="tx">Regarding the <span class="sans_thesansmonocd_w5regular_">drawAxes()</span> function, notice how all the graphics commands involving the graphics context <span class="sans_thesansmonocd_w5regular_">gc</span> have been grouped together using the scoping function <span class="sans_thesansmonocd_w5regular_">with()</span>. This saves us from having to type <span class="sans_thesansmonocd_w5regular_">gc</span> multiple times.</p>
<p class="tx">Getting back to the application class, the animation of the binary star system is implemented by using a combination of <span class="sans_thesansmonocd_w5regular_">Timeline</span> and <span class="sans_thesansmonocd_w5regular_">KeyFrame</span> with a <span class="sans_thesansmonocd_w5regular_">{lambda}</span> expression. We first create a <span class="sans_thesansmonocd_w5regular_">Timeline</span> variable <span class="sans_thesansmonocd_w5regular_">t</span> <span aria-label="annotation4" class="codeannotation">❹</span> and set a few other local parameters. The parameter <span class="sans_thesansmonocd_w5regular_">frameCount</span> is initially set to <span class="sans_thesansmonocd_w5regular_">0</span> and later incremented by <span class="sans_thesansmonocd_w5regular_">1</span> per frame. The <span class="sans_thesansmonocd_w5regular_">dt</span> parameter is the time step used in updating the velocity and position vectors. We’ve set it to <span class="sans_thesansmonocd_w5regular_">1</span>, meaning each animation frame represents 1 year (this may seem too large, but it’s all relative; the period for this star system is 722 Earth years long). Notice that the <span class="sans_thesansmonocd_w5regular_">iterMax</span> parameter is set to <span class="sans_thesansmonocd_w5regular_">1</span>, which means the position and velocity vectors are updated only once per frame. If we wanted, we could use a different <span class="sans_thesansmonocd_w5regular_">dt</span> and <span class="sans_thesansmonocd_w5regular_">iterMax</span> combination to carry out <span class="sans_thesansmonocd_w5regular_">iterMax</span> updates of the position and velocity vectors before changing frames.</p>
<p class="tx">Inside the <span class="sans_thesansmonocd_w5regular_">KeyFrame</span> class instance <span aria-label="annotation5" class="codeannotation">❺</span>, the <span class="sans_thesansmonocd_w5regular_">{lambda}</span> expression specifies what happens between the frame updates at a frequency specified by the <span class="sans_thesansmonocd_w5regular_">Duration.millis()</span> function. First, we call <span class="sans_thesansmonocd_w5regular_">updateStarPositions()</span> to calculate each star’s acceleration, velocity, and position. We then call <span class="sans_thesansmonocd_w5regular_">drawStars()</span> to update the positions of the stars on the canvas, and finally, we call <span class="sans_thesansmonocd_w5regular_">updateAndDrawTrails()</span> to trace out the trails for both stars. (We’ll review these functions separately.) Before exiting the <span class="sans_thesansmonocd_w5regular_">KeyFrame</span> block, we check for the stopping condition: if <span class="sans_thesansmonocd_w5regular_">frameCount</span> (the number of frames displayed) reaches <span class="sans_thesansmonocd_w5regular_">frameCountMax</span>, the timeline ends, and the animation is terminated <span aria-label="annotation6" class="codeannotation">❻</span>.</p>
<p class="tx">The final three lines complete the <span class="sans_thesansmonocd_w5regular_">Timeline</span> implementation. First, we supply the <span class="sans_thesansmonocd_w5regular_">KeyFrame</span> instance (<span class="sans_thesansmonocd_w5regular_">k</span>) to the timeline <span aria-label="annotation7" class="codeannotation">❼</span>. Next, we set <span class="sans_thesansmonocd_w5regular_">cycleCount</span> to <span class="sans_thesansmonocd_w5regular_">INDEFINITE</span>, which means continue the timeline until a stopping condition is met inside the <span class="sans_thesansmonocd_w5regular_">KeyFrame</span> or elsewhere in the program. Finally, <span class="sans_thesansmonocd_w5regular_">t.play()</span> starts the animation and sets the stars in motion.</p>
</section>
<section aria-labelledby="sec26" epub:type="division">
<span aria-label="217" epub:type="pagebreak" id="pg_217" role="doc-pagebreak"/>
<h5 class="h2"><span id="sec26"/><span id="h3-42"/><span class="sans_futura_std_bold_b_">The updateStarPositions() Function</span></h5>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">updateStarPositions()</span> function implements the physics of binary stars in motion by using the formulas and algorithms we’ve discussed. The function takes in two arguments—a list of type <span class="sans_thesansmonocd_w5regular_">Star</span> called <span class="sans_thesansmonocd_w5regular_">stars</span> and the time step <span class="sans_thesansmonocd_w5regular_">dt</span>—and doesn’t return anything, since the function makes its updates directly to the globally accessible properties of the stars.</p>
<pre class="calibre10"><code class="calibre11">fun updateStarPositions(stars: List&lt;Star&gt;, dt: Double) {
    val rx = stars[1].x - stars[0].x
    val ry = stars[1].y - stars[0].y
    val r = sqrt(rx * rx + ry * ry)

  <span aria-label="annotation1" class="code_codeannotation">❶</span> val force =
        G * stars[0].mass * stars[1].mass / (r * r)

    var sign = 1
    for (star in stars) {
      <span aria-label="annotation2" class="code_codeannotation">❷</span> // Update the acceleration, velocity, and position of stars.
        val acceleration = force / star.mass
        val ax = acceleration * rx / r
        val ay = acceleration * ry / r
        star.vx += sign * ax * dt
        star.vy += sign * ay * dt

      <span aria-label="annotation3" class="code_codeannotation">❸</span> // These will be needed for updating trails.
        star.xOld = star.x
        star.yOld = star.y

        star.x += star.vx * dt
        star.y += star.vy * dt
      <span aria-label="annotation4" class="code_codeannotation">❹</span> sign = -1
    }
}</code></pre>
<p class="tx">The function starts by calculating the distance between the two stars by using Equation 5.23. We then use the scalar part of Equation 5.24 to calculate the magnitude of the gravitational force that both stars will experience <span aria-label="annotation1" class="codeannotation">❶</span>. Next, we iterate over the <span class="sans_thesansmonocd_w5regular_">stars</span> list and update the acceleration, velocity, and position for both stars per Equations 5.26 through 5.31 <span aria-label="annotation2" class="codeannotation">❷</span>. Notice that we save the current position vectors in the <span class="sans_thesansmonocd_w5regular_">xOld</span> and <span class="sans_thesansmonocd_w5regular_">yOld</span> properties of the stars before updating <span class="sans_thesansmonocd_w5regular_">x</span> and <span class="sans_thesansmonocd_w5regular_">y</span> <span aria-label="annotation3" class="codeannotation">❸</span>. We’ll need these so the stars’ trails will lag the stars themselves by one time step. Also notice how the variable <span class="sans_thesansmonocd_w5regular_">sign</span> switches from <span class="sans_thesansmonocd_w5regular_">1</span> to <span class="sans_thesansmonocd_w5regular_">-1</span> at the end of the first iteration <span aria-label="annotation4" class="codeannotation">❹</span>. This inverts the direction of the force acting on the second star to ensure that <b class="calibre6"><i class="calibre9">F</i></b><span class="epub-b-sub">1</span> = −<b class="calibre6"><i class="calibre9">F</i></b><span class="epub-b-sub">2</span>.</p>
</section>
<section aria-labelledby="sec27" epub:type="division">
<h5 class="h2"><span id="sec27"/><span id="h3-43"/><span class="sans_futura_std_bold_b_">The drawStars() Function</span></h5>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">drawStars()</span> function simply updates the positions of the stars on the canvas to make them move. It takes in one parameter, the graphics context, and returns nothing.</p>
<pre class="calibre10"><code class="calibre11"><span aria-label="218" epub:type="pagebreak" id="pg_218" role="doc-pagebreak"/>fun drawStars(gc: GraphicsContext) {
  <span aria-label="annotation1" class="code_codeannotation">❶</span> gc.clearRect(-canvasW/2, -canvasH/2, canvasW, canvasH)
  <span aria-label="annotation2" class="code_codeannotation">❷</span> drawAxes(gc)

    // Connect the centers of the stars.
  <span aria-label="annotation3" class="code_codeannotation">❸</span> with (gc) {
        lineWidth = 0.5
        stroke = Color.BLACK
        setLineDashes(2.0,4.0,4.0,2.0)
        strokeLine(
            scaleFactor*stars[0].x,
            scaleFactor*stars[0].y,
            scaleFactor*stars[1].x,
            scaleFactor*stars[1].y)
    }

    // Draw the stars using updated positions.
  <span aria-label="annotation4" class="code_codeannotation">❹</span> for (star in stars) {
        gc.fill = star.color
        gc.fillOval(
            scaleFactor * star.x - star.size/2,
            scaleFactor * star.y - star.size/2,
            star.size, star.size)
    }
}</code></pre>
<p class="tx">The function starts by clearing the canvas <span aria-label="annotation1" class="codeannotation">❶</span>. Then we redraw the objects in three stages. First, we call the <span class="sans_thesansmonocd_w5regular_">drawAxes()</span> function, which we’ve already reviewed, to draw the axes <span aria-label="annotation2" class="codeannotation">❷</span>. Since this happens first, the other objects (for example, the stars and the trails) will be drawn on top of the axes.</p>
<p class="tx">Next, we connect the centers of the stars by using a dashed line <span aria-label="annotation3" class="codeannotation">❸</span>. The argument sequence <span class="sans_thesansmonocd_w5regular_">(2.0, 4.0, 4.0, 2.0)</span> means the dash lengths will be set in cycles of 2, 4, 4, and 2 pixels. This line helps identify the center of rotation (the point where it intersects the x-axis) and will grow and shrink like a spring with the movements of the stars, making the simulation more interesting. For a circular and concentric orbit, this line also helps visually confirm that at any moment the binary stars are placed in diametrically opposite positions about the center of rotation.</p>
<p class="tx">Finally, we use a <span class="sans_thesansmonocd_w5regular_">for</span> loop to iterate over the stars and draw them in their new positions <span aria-label="annotation4" class="codeannotation">❹</span>. Notice the use of <span class="sans_thesansmonocd_w5regular_">scaleFactor</span> while drawing the stars. This is a global variable that allows us to change the scale of the simulation on the fly without going through more complicated rescaling schemes that we’ve used elsewhere in the book. For this problem, since the orbit shapes and sizes can vary significantly during the simulations, I suggest that you adjust this scale factor based on your own setup. I used <span class="sans_thesansmonocd_w5regular_">scaleFactor</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">4</span> for the first simulation (for stable circular orbits) and <span class="sans_thesansmonocd_w5regular_">scaleFactor</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">1</span> for the second simulation (for stable elliptical orbits). In the latter case, the distance between the stars <i class="calibre9">r</i> varies significantly during the simulation, and we need to allocate more space on the canvas to fully outline the orbits.</p>
</section>
<section aria-labelledby="sec28" epub:type="division">
<span aria-label="219" epub:type="pagebreak" id="pg_219" role="doc-pagebreak"/>
<h5 class="h2"><span id="sec28"/><span id="h3-44"/><span class="sans_futura_std_bold_b_">The updateAndDrawTrails() Function</span></h5>
<p class="tni">The two-in-one <span class="sans_thesansmonocd_w5regular_">updateAndDrawTrails()</span> function updates the trails and draws them at the same time. It takes one parameter, <span class="sans_thesansmonocd_w5regular_">gc</span>, and doesn’t return anything, just like the <span class="sans_thesansmonocd_w5regular_">drawStars()</span> function.</p>
<pre class="calibre10"><code class="calibre11">fun updateAndDrawTrails(gc: GraphicsContext) {
    // Update the trails.
    stars.forEachIndexed {index, star -&gt;
      <span aria-label="annotation1" class="code_codeannotation">❶</span> if (star.trailCount &gt;= trailMAX) star.trailCount = 0
      <span aria-label="annotation2" class="code_codeannotation">❷</span> trails[index][star.trailCount] =
                      Pair(star.xOld, star.yOld)
        star.trailCount += 1
    }

    // Draw the trails.
    trails.forEachIndexed {index, trail -&gt;
      <span aria-label="annotation3" class="code_codeannotation">❸</span> gc.fill = stars[index].color
      <span aria-label="annotation4" class="code_codeannotation">❹</span> for (point in trail) {
            gc.fillOval(
                scaleFactor * point.first - trailSize / 2,
                scaleFactor * point.second - trailSize / 2,
                trailSize, trailSize
            )
        }
    }
}</code></pre>
<p class="tx">The first block in this function iterates over the <span class="sans_thesansmonocd_w5regular_">stars</span> list and updates the positions of the trail elements. Recall that the <span class="sans_thesansmonocd_w5regular_">initialPositions()</span> function started all the tracers at the same position as the star itself, but we haven’t drawn any of them yet. Now we move the tracers one at a time (for each star). First, we check to see that unassigned tracers are ready to be moved to a new location by ensuring that <span class="sans_thesansmonocd_w5regular_">star.trailCount</span> &lt; <span class="sans_thesansmonocd_w5regular_">trailMAX</span>. Otherwise, we reset <span class="sans_thesansmonocd_w5regular_">trailCount</span> to <span class="sans_thesansmonocd_w5regular_">0</span> <span aria-label="annotation1" class="codeannotation">❶</span>. Each time a star moves to a new position, we assign the star’s old position to the next available tracer—the one at position <span class="sans_thesansmonocd_w5regular_">[index][star.trailCount]</span> in the <span class="sans_thesansmonocd_w5regular_">trails</span> array <span aria-label="annotation2" class="codeannotation">❷</span>. This is why we always save the old positions of the stars before updating them in the <span class="sans_thesansmonocd_w5regular_">updateStarPositions()</span> function.</p>
<p class="tx">This process continues as long as tracers remain to be moved from the initial position. Once all the tracers have been assigned new positions on the canvas (and the stars continue to move), resetting <span class="sans_thesansmonocd_w5regular_">trailCount</span> lets us recycle them by bringing the last one to the first position (right next to the star).</p>
<p class="tx">Now that the tracer positions have been updated, the second block in the function draws the trails for both stars. For each trail, we use the same color as the color of the star it follows <span aria-label="annotation3" class="codeannotation">❸</span> to draw the tracers. Finally, all the trails are drawn on the canvas, based on their most recent coordinates <span aria-label="annotation4" class="codeannotation">❹</span>. Once all the tracers are placed on the canvas, each trail will follow its parent star.</p>
</section>
</section>
<section aria-labelledby="sec29" epub:type="division">
<span aria-label="220" epub:type="pagebreak" id="pg_220" role="doc-pagebreak"/>
<h4 class="h1"><span id="sec29"/><span id="h2-100"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">When you run the app, you should see a dynamic simulation of the binary star system in motion, as opposed to a static image. You’ll see the stars continuously dancing around each other on the screen until you close the window or wait for the <span class="sans_thesansmonocd_w5regular_">frameCount</span> to hit its limit. <a href="chapter5.xhtml#fig5-13" class="calibre2">Figure 5-13</a> shows screenshots of two different runs of the app.</p>
<figure class="img"><img alt="" class="img1" height="757" id="fig5-13" src="../images/Figure5-13.jpg" width="1669"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 5-13: A binary star system with concentric, circular orbits (left) and a binary star system with elliptical orbits (right)</span></p></figcaption>
</figure>
<p class="tx">The example on the left shows a binary star system with concentric, circular orbits, meaning one star’s orbit is entirely contained within the other. For this, we used the initial conditions shown in the code listings. The example on the right simulates a system with elliptical orbits by using the same initial conditions, except <span class="sans_thesansmonocd_w5regular_">x</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">-50.0</span> for star 1, <span class="sans_thesansmonocd_w5regular_">x</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">90.0</span> for star 2, and <span class="sans_thesansmonocd_w5regular_">scaleFactor</span> <span class="sans_thesansmonocd_w5regular_">=</span> <span class="sans_thesansmonocd_w5regular_">1</span>.</p>
<p class="tx">I encourage you to play around with the simulation by tweaking the initial conditions. Depending on the parameters, you may end up with an unstable system, in which case the stars fly off the screen or crash into each other. In fact, it’s much harder to create a stable system like the ones shown in the figure. This instability also happens with real binary star systems as they get perturbed by a variety of external forces that offset the delicate balance needed to maintain a stable orbit.</p>
<aside aria-label="box-31" class="box2">
<p class="boxtitle" id="box-31"><span class="sans_futura_std_bold_b_">EXERCISE</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">The 2D binary star system we developed in this section is helpful for exploring the interactions between the stars driven solely by the gravitational forces created by their own masses. However, many known binary star systems have</span> <span aria-label="221" epub:type="pagebreak" id="pg_221" role="doc-pagebreak"/><span class="sans_futura_std_book_">other companions, such as one or more planets orbiting the stars. Try modifying the project code to add a third object, a planet, attached to one of the stars. In other words, you’ll convert the two-body problem into a three-body problem and solve the resulting system by using the same principles and tools.</span></p>
<p class="boxlast"><span class="sans_futura_std_book_">Hint: Adding a planet is no different than adding another star with a small mass. To create a stable system, you’ll have to do some online research to find real astronomical examples and use that data to set the initial conditions. Most of the functions in the app will require no change, as they’re written in a generic fashion that can handle any number of stars or trails (subject to the limits set by the CPU/GPU and memory of your device). However, you’ll need to change the</span> <span class="sans_thesansmonocd_w5regular_">updateStarPositions()</span> <span class="sans_futura_std_book_">function to consider the impact of the stars on the planet’s orbit, and vice versa. To be realistic, you could also add a feature to check if the stars and the planet get too close or collide, and what happens as a result.</span></p>
</aside>
</section>
<section aria-labelledby="sec30" epub:type="division">
<h3 class="h"><span id="sec30"/><span id="h1-37"/><span class="sans_futura_std_bold_b_">Summary</span></h3>
<p class="tni">In this chapter, we used Kotlin and laws of physics to solve a variety of science problems—from the projectile motion of cannonballs and water jets, to swinging pendulums and cooling cups of coffee, to the out-of-this-world dance of a binary star system. Along the way, we developed increasingly complex mathematical models of physical systems to study their behavior. To do so, we went beyond the basics of Kotlin, harnessing JavaFX’s visualization and animation tools to effectively display the results of our code.</p>
</section>
<section aria-labelledby="sec31" epub:type="division">
<h3 class="h"><span id="sec31"/><span id="h1-38"/><span class="sans_futura_std_bold_b_">Resources</span></h3>
<p class="reference">Bate, Roger R., Donald D. Mueller, Jerry E. White, and William W. Saylor. <i class="calibre9">Fundamentals of Astrodynamics</i>. 2nd ed. Mineola, NY: Dover, 2020.</p>
<p class="reference">Bennett, Andrew G. “Runge-Kutta Methods.” Accessed June 15, 2024. <i class="calibre9"><a href="https://onlinehw.math.ksu.edu/math340book/chap1/xc1.php" class="calibre2">https://onlinehw.math.ksu.edu/math340book/chap1/xc1.php</a></i>.</p>
<p class="reference">Cromer, Alan. “Stable Solutions Using the Euler Approximation.” <i class="calibre9">American Journal of Physics</i> 49, no. 5 (May 1981): 455–459. <i class="calibre9"><a href="https://doi.org/10.1119/1.12478" class="calibre2">https://doi.org/10.1119/1.12478</a></i>.</p>
<p class="reference">Demanet, Laurent. “Introduction to Numerical Analysis.” MIT OpenCourseWare, 2012. Accessed June 15, 2024. <i class="calibre9"><a href="https://ocw.mit.edu/courses/18-330-introduction-to-numerical-analysis-spring-2012/" class="calibre2">https://ocw.mit.edu/courses/18-330-introduction-to-numerical-analysis-spring-2012/</a></i>.</p>
<p class="reference">Halliday, David, Robert Resnick, and Jearl Walker. <i class="calibre9">Fundamentals of Physics</i>. 12th ed. New York: Wiley &amp; Sons, 2021.</p>
<p class="reference"><span aria-label="222" epub:type="pagebreak" id="pg_222" role="doc-pagebreak"/>Seyr, Alexander Josef. “Numerical Simulation of the Planetary Motions in the Solar System with Runge Kutta Methods.” November 6, 2020. <i class="calibre9"><a href="https://static.uni-graz.at/fileadmin/_Persoenliche_Webseite/puschnig_peter/unigrazform/Theses/BachelorThesis_Seyr_2020.pdf" class="calibre2">https://static.uni-graz.at/fileadmin/_Persoenliche_Webseite/puschnig_peter/unigrazform/Theses/BachelorThesis_Seyr_2020.pdf</a></i>.</p>
<p class="reference">Young, Hugh, and Roger Freedman. <i class="calibre9">University Physics</i>. 15th ed. New York: Pearson, 2020.</p>
</section>
</section>
</div></body></html>