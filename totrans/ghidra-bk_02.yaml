- en: '## **1'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **1'
- en: INTRODUCTION TO DISASSEMBLY**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编简介**
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: You may be wondering what to expect in a book dedicated to Ghidra. While obviously
    Ghidra-centric, this book is not intended to come across as *The Ghidra User’s
    Manual*. Instead, we intend to use Ghidra as the enabling tool for discussing
    reverse engineering techniques that you will find useful in analyzing a wide variety
    of software, ranging from vulnerable applications to malware. When appropriate,
    we will provide detailed steps in Ghidra for performing specific actions related
    to the task at hand. As a result, we will take a rather roundabout walk through
    Ghidra’s capabilities, beginning with the basic tasks you will want to perform
    upon initial examination of a file and leading up to advanced uses and customization
    of Ghidra for more challenging reverse engineering problems. We make no attempt
    to cover all of Ghidra’s features. We do, however, cover the features you will
    find most useful in meeting your reverse engineering challenges. This book will
    help make Ghidra the most potent weapon in your arsenal of tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会好奇一本专门介绍Ghidra的书会是什么样子。虽然这本书显然是以Ghidra为中心，但并不打算让它显得像是*Ghidra用户手册*。相反，我们打算将Ghidra作为工具，来讨论逆向工程技巧，这些技巧将帮助你分析各种软件，从易受攻击的应用程序到恶意软件。当适当时，我们将提供在Ghidra中执行特定任务的详细步骤。因此，我们将通过Ghidra的功能进行一个相当曲折的探索，从你在初步检查文件时想要执行的基本任务开始，直到更具挑战性的逆向工程问题时，如何使用和定制Ghidra。我们不会尝试覆盖Ghidra的所有功能。然而，我们会涵盖那些在应对你的逆向工程挑战时最有用的功能。这本书将帮助你将Ghidra打造成你工具库中最强大的武器。
- en: Prior to diving into any Ghidra specifics, we will cover some of the basics
    of the disassembly process and review other tools available for reverse engineering
    compiled code. While these tools may not match the complete range of Ghidra’s
    capabilities, each does address specific subsets of Ghidra functionality and offers
    valuable insight into specific Ghidra features. The remainder of this chapter
    is dedicated to understanding the disassembly process from a high level.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨任何Ghidra的细节之前，我们将介绍一些反汇编过程的基本概念，并回顾其他可用于逆向工程已编译代码的工具。虽然这些工具可能无法匹配Ghidra的全部功能，但每个工具都涵盖了Ghidra功能的特定子集，并且提供了对某些Ghidra特性的有价值的见解。本章的其余部分将专注于从高层次理解反汇编过程。
- en: '**Disassembly Theory**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**反汇编理论**'
- en: 'Anyone who has spent any time at all studying programming languages has probably
    learned about the various generations of languages, but they are summarized here
    for those who may have been sleeping:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 任何曾花时间研究编程语言的人，可能已经学过各种语言的世代，但这里为那些可能还不熟悉的读者做了简要总结：
- en: '**First-generation languages** These are the lowest form of language, generally
    consisting of ones and zeros or a shorthand form, such as hexadecimal, and readable
    only by binary ninjas. Distinguishing data from instructions is difficult at this
    level because all the content looks the same. First-generation languages may also
    be referred to as *machine languages*, and in some cases *byte code*, while machine
    language programs are often referred to as *binaries*.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一代语言** 这些是最低级的语言，通常由一和零组成，或者是像十六进制这样的简写形式，仅能被二进制高手读取。在这一层级中，区分数据和指令非常困难，因为所有内容看起来都相同。第一代语言也可以称为*机器语言*，在某些情况下也称为*字节码*，而机器语言程序通常被称为*二进制文件*。'
- en: '**Second-generation languages** Also called *assembly languages*, second-generation
    languages are a mere table lookup away from machine language and generally map
    specific bit patterns, or operation codes (opcodes), to short but memorable character
    sequences called *mnemonics*. These mnemonics help programmers remember the instructions
    with which they are associated. An *assembler* is a tool used by programmers to
    translate their assembly language programs into machine language suitable for
    execution. In addition to instruction mnemonics, a complete assembly language
    generally includes *directives* to the assembler that help dictate the memory
    layout of code and data in the final binary.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二代语言** 也叫*汇编语言*，第二代语言与机器语言仅一步之遥，通常将特定的比特模式或操作码（opcodes）映射到简短而易记的字符序列，称为*助记符*。这些助记符帮助程序员记住它们所对应的指令。*汇编器*是程序员用来将他们的汇编语言程序翻译成适合执行的机器语言的工具。除了指令助记符外，完整的汇编语言通常还包括一些*指令*，用于告诉汇编器代码和数据在最终二进制文件中的内存布局。'
- en: '**Third-generation languages** These languages take another step toward the
    expressive capability of natural languages by introducing keywords and constructs
    that programmers use as the building blocks for their programs. Third-generation
    languages are generally platform independent, though programs written using them
    may be platform dependent as a result of using features unique to a specific operating
    system. Often-cited examples of third-generation languages include FORTRAN, C,
    and Java. Programmers generally use compilers to translate their programs into
    assembly language or all the way to machine language (or some rough equivalent
    such as byte code).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**第三代语言** 这些语言通过引入关键词和结构，使程序员可以使用它们作为程序的构建模块，从而进一步接近自然语言的表达能力。第三代语言通常是平台无关的，尽管使用它们编写的程序可能因使用特定操作系统的特性而与平台相关。常见的第三代语言包括FORTRAN、C和Java。程序员通常使用编译器将其程序转换为汇编语言，或者直接转换为机器语言（或某种粗略等效的字节码）。'
- en: '**Fourth-generation languages** These exist but aren’t relevant to this book
    and are not discussed.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**第四代语言** 尽管存在，但不相关于本书，因此不作讨论。'
- en: '### **The What of Disassembly**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '### **反汇编的基本概念**'
- en: In a traditional software development model, compilers, assemblers, and linkers
    are used by themselves or in combination to create executable programs. To work
    our way backward (or reverse engineer programs), we use tools to undo the assembly
    and compilation processes. Not surprisingly, such tools are called *disassemblers*
    and *decompilers*, and they do pretty much what their names indicate. A disassembler
    undoes the assembly process, so we should expect assembly language as the output
    (and therefore machine language as input). Decompilers aim to produce output in
    a high-level language when given assembly or even machine language as input.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统软件开发模型中，编译器、汇编器和链接器单独或组合使用来创建可执行程序。为了向后操作（或逆向工程程序），我们使用工具来撤销汇编和编译过程。毫不奇怪，这些工具被称为*反汇编器*和*反编译器*，它们基本上做了它们名称所示的事情。反汇编器撤销汇编过程，因此我们应该期望输出汇编语言（从而输入机器语言）。反编译器旨在在给定汇编甚至机器语言作为输入时生成高级语言的输出。
- en: 'The promise of “source code recovery” will always be attractive in a competitive
    software market, and thus the development of usable decompilers remains an active
    research area in computer science. The following are just a few of the reasons
    that decompilation is difficult:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在竞争激烈的软件市场中，“源代码恢复”的承诺始终具有吸引力，因此可用的反编译器的开发仍然是计算机科学中一个活跃的研究领域。以下是一些解释反编译困难的原因：
- en: '**The compilation process is lossy.** At the machine language level, there
    are no variable or function names, and variable type information can be determined
    only by how the data is used rather than explicit type declarations. When you
    observe 32 bits of data being transferred, you’ll need to do some investigative
    work to determine whether those 32 bits represent an integer, a 32-bit floating
    point value, or a 32-bit pointer.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译过程存在信息损失。** 在机器语言级别上，不存在变量或函数名称，变量类型信息仅能通过数据使用方式来确定，而非显式类型声明。当观察到传输32位数据时，您需要进行一些调查工作来确定这32位数据是表示整数、32位浮点值还是32位指针。'
- en: '**Compilation is a many-to-many operation.** This means that a source program
    can be translated to assembly language in many different ways, and machine language
    can be translated back to source in many different ways. As a result, compiling
    a file and immediately decompiling it commonly yields a source file that is vastly
    different from the original.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译是一对多的操作。** 这意味着源程序可以以许多不同的方式翻译成汇编语言，而机器语言可以以许多不同的方式翻译回源代码。因此，编译文件然后立即反编译它通常会产生与原始文件大不相同的源文件。'
- en: '**Decompilers are language and library dependent.** Processing a binary produced
    by a Delphi compiler with a decompiler designed to generate C code can yield very
    strange results. Similarly, feeding a compiled Windows binary through a decompiler
    that has no knowledge of the Windows programming API may not yield anything useful.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**反编译器依赖于语言和库。** 使用设计为生成C代码的反编译器处理由Delphi编译器生成的二进制文件可能会产生非常奇怪的结果。同样地，将经过编译的Windows二进制文件输入到没有Windows编程API知识的反编译器中可能得不到任何有用的结果。'
- en: '**A nearly perfect disassembly capability is needed in order to accurately
    decompile a binary.** Any errors or omissions in the disassembly phase will almost
    certainly propagate through to the decompiled code. Disassembled code can be verified
    for correctness against appropriate processor reference manuals; however, no canonical
    reference manuals are available to use in verifying the correctness of a decompiler’s
    output.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**为了准确地反编译一个二进制文件，几乎完美的反汇编能力是必需的。** 反汇编阶段的任何错误或遗漏几乎肯定会传播到反编译后的代码中。可以通过适当的处理器参考手册验证反汇编代码的正确性；然而，没有权威的参考手册可用于验证反编译器输出的正确性。'
- en: Ghidra has a built-in decompiler, which is the subject of [Chapter 19](ch19.xhtml#ch19).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra内置了反编译器，这是[第19章](ch19.xhtml#ch19)的主题。
- en: '### **The Why of Disassembly**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '### **反汇编的意义**'
- en: 'The purpose of disassembly tools is often to facilitate understanding of programs
    when source code is unavailable. Common situations in which disassembly is used
    include the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编工具的目的通常是为了在源代码不可用时帮助理解程序。使用反汇编的常见情况包括以下几种：
- en: Analysis of malware
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恶意软件分析
- en: Analysis of closed source software for vulnerabilities
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封闭源代码软件的漏洞分析
- en: Analysis of closed source software for interoperability
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封闭源代码软件的互操作性分析
- en: Analysis of compiler-generated code to validate compiler performance or correctness
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析编译器生成的代码以验证编译器的性能或正确性
- en: Display of program instructions while debugging
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试时程序指令的显示
- en: The subsequent sections explain each situation in more detail.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 后续部分将更详细地解释每种情况。
- en: '***Malware Analysis***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***恶意软件分析***'
- en: Unless you are dealing with script-based malware, malware authors seldom do
    you the favor of providing the source code to their creations. Lacking source
    code, you are faced with a very limited set of options for discovering exactly
    how the malware behaves. The two main techniques for malware analysis are dynamic
    analysis and static analysis. *Dynamic analysis* involves allowing the malware
    to execute in a carefully controlled environment (sandbox) while recording every
    observable aspect of its behavior by using any number of system instrumentation
    utilities. In contrast, *static analysis* attempts to understand the behavior
    of a program simply by reading through the program code, which, in the case of
    malware, generally consists solely of a disassembly listing and possibly a decompiler
    listing.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你正在处理基于脚本的恶意软件，否则恶意软件作者通常不会提供他们创作的源代码。没有源代码，你面临的选项非常有限，用于发现恶意软件具体行为的方式也很有限。恶意软件分析的两种主要技术是动态分析和静态分析。*动态分析*涉及在精心控制的环境（沙箱）中运行恶意软件，并通过使用各种系统工具记录其行为的每个可观察方面。与此相对，*静态分析*尝试仅通过阅读程序代码来理解程序的行为，在恶意软件的情况下，程序代码通常仅由反汇编清单和可能的反编译器清单组成。
- en: '***Vulnerability Analysis***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***漏洞分析***'
- en: 'For the sake of simplification, let’s break the entire security-auditing process
    into three steps: vulnerability discovery, vulnerability analysis, and exploit
    development. The same steps apply whether you have source code or not; however,
    the level of effort increases substantially when all you have is a binary. The
    first step in the process is to discover a potentially exploitable condition in
    a program. This is often accomplished using dynamic techniques such as fuzzing,^([1](footnotes.xhtml#ch01fn1))
    but it can also be performed (usually with much more effort) via static analysis.
    Once a problem has been discovered, further analysis is often required to determine
    whether the problem is exploitable at all and, if so, under what conditions.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们将整个安全审计过程分为三个步骤：漏洞发现、漏洞分析和漏洞利用开发。无论是否有源代码，步骤是相同的；然而，当你只有二进制文件时，所需的工作量会大大增加。该过程的第一步是发现程序中可能被利用的条件。这通常是通过动态技术（如模糊测试）完成的，^([1](footnotes.xhtml#ch01fn1))，但也可以通过静态分析（通常需要更多的努力）来完成。一旦发现问题，通常需要进一步分析以确定问题是否可以被利用，如果可以，被利用的条件是什么。
- en: Identifying variables that can be manipulated to the attacker’s advantage is
    an important early step in vulnerability discovery. Disassembly listings provide
    the level of detail required to understand exactly how the compiler has chosen
    to allocate program variables. For example, it might be useful to know that a
    70-byte character array declared by a programmer was rounded up to 80 bytes when
    allocated by the compiler. Disassembly listings also provide the only means to
    determine exactly how a compiler has chosen to order all of the variables declared
    globally or within functions. Understanding the spatial relationships among variables
    is often essential when attempting to develop exploits. Ultimately, by using a
    disassembler and a debugger together, an exploit may be developed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 识别可以被攻击者利用的变量是发现漏洞的一个重要早期步骤。反汇编清单提供了理解编译器如何分配程序变量所需的详细信息。例如，知道程序员声明的70字节字符数组在编译器分配时被四舍五入为80字节可能是有用的。反汇编清单还提供了唯一的方式来确定编译器如何选择对所有全局或函数内声明的变量进行排序。了解变量之间的空间关系通常是开发利用程序时的关键。最终，通过结合使用反汇编器和调试器，可能会开发出一个漏洞利用程序。
- en: '***Software Interoperability***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***软件互操作性***'
- en: When software is released in binary form only, it is very difficult for competitors
    to create software that can interoperate with it or to provide plugin replacements
    for that software. A common example is driver code released for hardware that
    is supported on only one platform. When a vendor is slow to support or, worse
    yet, refuses to support the use of its hardware with alternative platforms, substantial
    reverse engineering effort may be required in order to develop software drivers
    to support the hardware. In these cases, static code analysis is almost the only
    remedy and often must go beyond the software driver to understand embedded firmware.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当软件仅以二进制形式发布时，竞争对手很难开发能够与之互操作的软件，或为该软件提供插件替代品。一个常见的例子是仅在一个平台上支持的硬件发布的驱动程序代码。当厂商在支持或更糟糕的是，拒绝支持其硬件与其他平台的兼容性时，可能需要大量的逆向工程工作才能开发出支持该硬件的软件驱动程序。在这些情况下，静态代码分析几乎是唯一的解决办法，并且通常需要超越软件驱动程序，以了解嵌入式固件。
- en: '***Compiler Validation***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编译器验证***'
- en: Since the purpose of a compiler (or assembler) is to generate machine language,
    good disassembly tools are often required to verify that the compiler is doing
    its job in accordance with any design specifications. Analysts may also be interested
    in locating additional opportunities for optimizing compiler output and, from
    a security standpoint, ascertaining whether the compiler itself has been compromised
    to the extent that it may be inserting backdoors into generated code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译器（或汇编器）的目的是生成机器语言，通常需要良好的反汇编工具来验证编译器是否按照设计规范执行其任务。分析人员可能还会关注寻找优化编译器输出的其他机会，并且从安全角度出发，确定编译器本身是否已被破坏，是否可能将后门代码插入到生成的代码中。
- en: '***Debugging Displays***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***调试显示***'
- en: Perhaps the single most common use of disassemblers is to generate listings
    within debuggers. Unfortunately, disassemblers embedded within debuggers tend
    to lack sophistication. They are generally incapable of batch disassembly and
    sometimes balk at disassembling when they cannot determine the boundaries of a
    function. This is one of the reasons it is best to use a debugger in conjunction
    with a high-quality disassembler to provide better situational awareness and context
    during debugging.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 也许反汇编器最常见的用途之一是生成调试器中的清单。不幸的是，嵌入调试器中的反汇编器通常缺乏复杂性。它们通常不能批量反汇编，有时在无法确定函数边界时会停止反汇编。这也是为什么最好将调试器与高质量的反汇编器结合使用，以提供更好的情境意识和调试过程中的上下文。
- en: '**The How of Disassembly**'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**反汇编的原理**'
- en: 'Now that you’re well versed in the purposes of disassembly, it’s time to move
    on to how the process actually works. Consider a typical daunting task faced by
    a disassembler: *Take these 100KB, distinguish code from data, convert the code
    to assembly language for display to a user, and please don’t miss anything along
    the way.* We could tack on any number of special requests, such as asking the
    disassembler to locate functions, recognize jump tables, and identify local variables,
    making the disassembler’s job that much more difficult.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然您已经熟悉了反汇编的目的，是时候了解这个过程的实际操作了。考虑反汇编器面临的一个典型而艰巨的任务：*处理这100KB，区分代码和数据，将代码转换为汇编语言并显示给用户，并且请在整个过程中不要遗漏任何部分。*
    我们可以附加任何数量的特殊请求，比如要求反汇编器定位函数、识别跳转表、识别局部变量，使得反汇编器的工作更加困难。
- en: To accommodate all of our demands, any disassembler will need to pick and choose
    from a variety of algorithms as it navigates through the files we feed it. The
    quality of the generated disassembly listing will be directly related to the quality
    of the algorithms utilized and how well they have been implemented.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足我们所有的需求，任何反汇编器在处理我们输入的文件时，都需要从各种算法中挑选合适的算法。生成的反汇编列表的质量将直接与所使用算法的质量以及它们的实现效果相关。
- en: In this section, we discuss two of the fundamental algorithms in use today for
    disassembling machine code. As we present these algorithms, we also point out
    their shortcomings in order to prepare you for situations in which your disassembler
    appears to fail. By understanding a disassembler’s limitations, you will be able
    to manually intervene to improve the overall quality of the disassembly output.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论当前用于反汇编机器代码的两种基本算法。在介绍这些算法时，我们还将指出它们的不足之处，以便让您为反汇编器可能出现的失败情况做好准备。通过理解反汇编器的局限性，您将能够手动干预，以提高反汇编输出的整体质量。
- en: '***A Basic Disassembly Algorithm***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基本反汇编算法***'
- en: 'For starters, let’s develop a simple algorithm for accepting machine language
    as input and producing assembly language as output. In doing so, you will gain
    an understanding of the challenges, assumptions, and compromises that underlie
    an automated disassembly process:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们开发一个简单的算法，用于接受机器语言作为输入，并生成汇编语言作为输出。在此过程中，您将了解自动化反汇编过程背后的挑战、假设和折衷：
- en: The first step in the disassembly process is to identify a region of code to
    disassemble. This is not necessarily as straightforward as it may seem. Instructions
    are generally mixed with data, and it is important to distinguish between the
    two. In the most common case, disassembly of an executable file, the file will
    conform to a common format for executable files such as the *Portable Executable
    (PE)* format used on Windows and the *Executable and Linkable Format (ELF)* common
    on many Unix-based systems. These formats typically contain mechanisms (often
    in the form of hierarchical file headers) for locating the sections of the file
    that contain code and entry points into that code.^([2](footnotes.xhtml#ch01fn2))
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反汇编过程的第一步是确定要反汇编的代码区域。这并不总是看起来那么简单。指令通常与数据混合在一起，因此区分它们非常重要。在最常见的情况下，反汇编可执行文件时，文件将遵循常见的可执行文件格式，如Windows上使用的*可移植可执行（PE）*格式和许多Unix系统上常用的*可执行与可链接格式（ELF）*。这些格式通常包含机制（通常以分层文件头的形式）来定位包含代码的文件部分及其入口点。^([2](footnotes.xhtml#ch01fn2))
- en: Given the address of an instruction, the next step is to read the value or values
    contained at that address (or file offset) and perform a table lookup to match
    the binary opcode value to its assembly language mnemonic. Depending on the complexity
    of the instruction set being disassembled, this may be a trivial process, or it
    may involve several additional operations such as understanding any prefixes that
    may modify the instruction’s behavior and determining any operands required by
    the instruction. For instruction sets with variable-length instructions, such
    as the Intel x86 instruction set, additional instruction bytes may need to be
    retrieved in order to completely disassemble a single instruction.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一条指令的地址，下一步是读取该地址（或文件偏移量）处的值，并执行表查找，将二进制操作码值与其汇编语言助记符匹配。根据所反汇编指令集的复杂性，这可能是一个简单的过程，也可能涉及一些额外的操作，例如理解可能修改指令行为的前缀，并确定指令所需的操作数。对于具有可变长度指令的指令集，例如Intel
    x86指令集，可能需要检索额外的指令字节，以完全反汇编一条指令。
- en: Once an instruction has been fetched and any required operands decoded, its
    assembly language equivalent is formatted and output as part of the disassembly
    listing. It may be possible to choose from more than one assembly language output
    syntax. For example, the two predominant formats for x86 assembly language are
    the Intel format and the AT&T format.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦指令被取出并解码了所需的操作数，它的汇编语言等效指令将被格式化并输出，作为反汇编列表的一部分。可能可以选择多种汇编语言输出语法。例如，x86 汇编语言的两种主要格式是
    Intel 格式和 AT&T 格式。
- en: Following the output of an instruction, we need to advance to the next instruction
    and repeat the previous process until we have disassembled every instruction in
    the file.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输出一条指令后，我们需要推进到下一条指令，并重复之前的过程，直到我们反汇编完文件中的每一条指令。
- en: '**X86 ASSEMBLY SYNTAX: AT&T VS. INTEL**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**X86 汇编语法：AT&T 与 Intel**'
- en: 'Two main syntaxes are used for assembly source code: AT&T and Intel. Even though
    they are second-generation languages, the two vary greatly in syntax—from variable,
    constant, and register access, to segment and instruction size overrides, to indirection
    and offsets. The AT&T assembly syntax is distinguished by its use of the `%` symbol
    to prefix all register names, the use of `$` as a prefix for literal constants
    (also called *immediate operands*), and its operand ordering in which the source
    operand appears on the left and the destination operand appears on the right.
    Using AT&T syntax, the instruction to add 4 to the `EAX` register would be `add
    $0x4,%eax`. The GNU Assembler `(as)` and many other GNU tools, including `gcc`
    and `gdb`, utilize AT&T syntax by default.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编源代码主要使用两种语法：AT&T 和 Intel。尽管它们都是二代语言，但两者在语法上差异很大——从变量、常量和寄存器访问，到段和指令大小重写，再到间接寻址和偏移。AT&T
    汇编语法的特点是使用 `%` 符号作为所有寄存器名称的前缀，使用 `$` 作为字面常量（也称为 *立即数操作数*）的前缀，以及操作数顺序，其中源操作数位于左侧，目标操作数位于右侧。使用
    AT&T 语法，将 4 加到 `EAX` 寄存器的指令是 `add $0x4,%eax`。GNU 汇编器（`as`）和许多其他 GNU 工具（包括 `gcc`
    和 `gdb`）默认使用 AT&T 语法。
- en: Intel syntax differs from AT&T in that it requires no register or literal prefixes,
    and the operand ordering is reversed such that the source operand appears on the
    right and the destination appears on the left. The same `add` instruction using
    the Intel syntax would be `add eax,0x4`. Assemblers utilizing Intel syntax include
    the Microsoft Assembler (MASM) and the Netwide Assembler (NASM).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Intel 语法与 AT&T 的区别在于，它不需要寄存器或字面量前缀，操作数的顺序也被颠倒，源操作数出现在右侧，目标操作数出现在左侧。使用 Intel
    语法的相同 `add` 指令将是 `add eax,0x4`。采用 Intel 语法的汇编器包括 Microsoft 汇编器（MASM）和 Netwide
    汇编器（NASM）。
- en: Various algorithms exist for determining where to begin a disassembly, how to
    choose the next instruction to be disassembled, how to distinguish code from data,
    and how to determine when the last instruction has been disassembled. The two
    predominant disassembly algorithms are linear sweep and recursive descent.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种算法用于确定从哪里开始反汇编，如何选择下一条要反汇编的指令，如何区分代码与数据，以及如何判断最后一条指令是否已经反汇编完成。两种主要的反汇编算法是线性扫描和递归下降。
- en: '***Linear Sweep Disassembly***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***线性扫描反汇编***'
- en: 'The *linear sweep* disassembly algorithm takes a very straightforward approach
    to locating instructions to disassemble: where one instruction ends, another begins.
    As a result, the most difficult decisions faced are where to begin and when to
    stop. The usual solution is to assume that everything contained in sections of
    a program marked as code (typically specified by the program file’s headers) represents
    machine language instructions. Disassembly begins with the first byte in a code
    section and moves, in a linear fashion, through the section, disassembling one
    instruction after another until the end of the section is reached. No effort is
    made to understand the program’s control flow through recognition of nonlinear
    instructions such as branches.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*线性扫描*反汇编算法采用一种非常直接的方法来定位需要反汇编的指令：一条指令结束后，另一条指令开始。因此，最困难的决策是从哪里开始以及何时停止。通常的解决方案是假设程序中标记为代码的部分（通常由程序文件的头部指定）包含机器语言指令。反汇编从代码段中的第一个字节开始，以线性方式遍历该段，逐条反汇编指令，直到到达该段的末尾。不会尝试通过识别非线性指令（如跳转）来理解程序的控制流。'
- en: During the disassembly process, a pointer can be maintained to mark the beginning
    of the instruction currently being disassembled. As part of the disassembly process,
    the length of each instruction is computed and used to determine the location
    of the next instruction to be disassembled. Instruction sets with fixed-length
    instructions (MIPS, for example) are somewhat easier to disassemble, as locating
    subsequent instructions is straightforward.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在反汇编过程中，可以保持一个指针来标记当前正在反汇编的指令的起始位置。作为反汇编过程的一部分，会计算每条指令的长度，并用它来确定下一条指令的位置。对于固定长度指令集（例如
    MIPS），反汇编相对容易一些，因为定位后续指令很直接。
- en: The main advantage of the linear sweep algorithm is that it provides complete
    coverage of a program’s code sections. One of the primary disadvantages of the
    linear sweep method is that it fails to account for data that may be comingled
    with code. This is evident in [Listing 1-1](ch01.xhtml#exa1_1), which shows the
    output of a function disassembled with a linear sweep disassembler.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 线性扫描算法的主要优点在于它可以完全覆盖程序的代码段。线性扫描方法的一个主要缺点是，它未能考虑可能与代码混合的数据。这在[清单 1-1](ch01.xhtml#exa1_1)中得到了体现，该清单展示了使用线性扫描反汇编器反汇编的一个函数的输出。
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 1-1: Linear sweep disassembly*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-1：线性扫描反汇编*'
- en: This function contains a switch statement, and the compiler used in this case
    has elected to implement the switch by using a jump table to resolve case label
    targets. Furthermore, the compiler has elected to embed the jump table within
    the function itself. The `jmp` statement ➊ references an address table ➋. Unfortunately,
    the disassembler treats the address table as if it were a series of instructions
    and incorrectly generates the following assembly language representation.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数包含了一个 `switch` 语句，并且在此案例中使用的编译器选择通过跳转表来实现 `switch`，以解析 case 标签目标。此外，编译器选择将跳转表嵌入到函数内部。`jmp`
    语句 ➊ 引用了一个地址表 ➋。遗憾的是，反汇编器将地址表当作一系列指令来处理，并错误地生成了以下的汇编语言表示。
- en: If we treat successive 4-byte groups in the jump table ➋ as little-endian values,^([3](footnotes.xhtml#ch01fn3))
    we see that each represents a pointer to a nearby address that is in fact the
    destination for one of the various jumps (`004012e0`, `0040128b`, `00401290`,
    . . .). Thus, the `loopne` instruction ➋ is not an instruction at all. Instead,
    it indicates a failure of the linear sweep algorithm to properly distinguish embedded
    data from code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将跳转表 ➋ 中的连续 4 字节组视为小端值^([3](footnotes.xhtml#ch01fn3))，我们会发现每个值代表一个指向附近地址的指针，而这些地址实际上是多个跳转的目的地（`004012e0`、`0040128b`、`00401290`，等等）。因此，`loopne`
    指令 ➋ 根本不是一条指令。相反，它表明线性扫描算法未能正确区分嵌入的数据和代码。
- en: Linear sweep is used by the disassembly engines contained in the GNU debugger
    (gdb), Microsoft’s WinDbg debugger, and the `objdump` utility.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 线性扫描被 GNU 调试器（gdb）、微软的 WinDbg 调试器和 `objdump` 工具所使用。
- en: '***Recursive Descent Disassembly***'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***递归下降反汇编***'
- en: 'The *recursive descent* disassembly algorithm takes a different approach to
    locating instructions: it focuses on the concept of control flow, which determines
    whether an instruction should be disassembled based on whether it is referenced
    by another instruction. To understand recursive descent, it is helpful to classify
    instructions according to how they affect the instruction pointer.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归下降* 反汇编算法采取不同的方法来定位指令：它侧重于控制流的概念，决定是否应当反汇编某条指令，依据的是它是否被其他指令引用。要理解递归下降，帮助理解的一个方法是根据指令如何影响指令指针来分类指令。'
- en: '**Sequential Flow Instructions**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**顺序流指令**'
- en: '*Sequential flow instructions* pass execution to the instruction that immediately
    follows. Examples of sequential flow instructions include simple arithmetic instructions,
    such as `add`; register-to-memory transfer instructions, such as `mov`; and stack-manipulation
    operations, such as `push` and `pop`. For such instructions, disassembly proceeds
    as with linear sweep.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*顺序流指令* 将执行传递给紧跟其后的指令。顺序流指令的例子包括简单的算术指令，如 `add`；寄存器到内存的转移指令，如 `mov`；以及栈操作，如
    `push` 和 `pop`。对于这些指令，反汇编过程与线性扫描相同。'
- en: '**Conditional Branching Instructions**'
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**条件分支指令**'
- en: '*Conditional branching instructions*, such as the x86 `jnz`, offer two possible
    execution paths. If the condition evaluates to true, the branch is taken, and
    the instruction pointer must be changed to reflect the target of the branch. However,
    if the condition is false, execution continues in a linear fashion, and a linear
    sweep methodology can be used to disassemble the next instruction. As it is generally
    not possible in a static context to determine the outcome of a conditional test,
    the recursive descent algorithm disassembles both paths, deferring disassembly
    of the branch target instruction by adding the address of the target instruction
    to a list of addresses to be disassembled at a later point.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*条件跳转指令*，如x86的`jnz`，提供两条可能的执行路径。如果条件为真，则跳转被执行，程序计数器必须更改为反映跳转目标。然而，如果条件为假，执行将继续按线性方式进行，并且可以使用线性扫描方法来反汇编下一条指令。由于在静态环境中通常无法确定条件测试的结果，递归下降算法会反汇编两条路径，通过将目标指令的地址添加到待反汇编的地址列表中，推迟对跳转目标指令的反汇编。'
- en: '**Unconditional Branching Instructions**'
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**无条件跳转指令**'
- en: '*Unconditional branches* do not follow the linear flow model and therefore
    are handled differently by the recursive descent algorithm. As with the sequential
    flow instructions, execution can flow to only one instruction; however, that instruction
    need not immediately follow the branch instruction. In fact, as seen in [Listing
    1-1](ch01.xhtml#exa1_1), there is no requirement at all for an instruction to
    immediately follow an unconditional branch. Therefore, there is no reason to immediately
    disassemble the bytes that follow an unconditional branch.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*无条件跳转*不遵循线性流模型，因此递归下降算法会以不同的方式处理它们。与顺序流指令一样，执行可以流向只有一条指令；然而，该指令不一定紧接着跳转指令。实际上，如[示例
    1-1](ch01.xhtml#exa1_1)所示，没有要求指令必须紧跟在无条件跳转后。因此，没有理由立即反汇编紧随无条件跳转后的字节。'
- en: A recursive descent disassembler attempts to determine the target of the unconditional
    jump and continues disassembly at the target address. Unfortunately, some unconditional
    branches can cause problems for recursive descent disassemblers. When the target
    of a jump instruction depends on a runtime value, it may not be possible to determine
    the destination of the jump by using static analysis. The x86 instruction `jmp`
    `rax` demonstrates this problem. The `rax` register contains a value only when
    the program is actually running. Since the register contains no value during static
    analysis, we have no way to determine the target of the jump instruction, and,
    consequently, we have no way to determine where to continue the disassembly process.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 递归下降反汇编器尝试确定无条件跳转的目标，并在目标地址继续反汇编。不幸的是，一些无条件跳转会给递归下降反汇编器带来问题。当跳转指令的目标依赖于运行时值时，可能无法通过静态分析确定跳转的目的地。x86指令`jmp`
    `rax`就演示了这个问题。只有在程序实际运行时，`rax`寄存器才包含一个值。由于在静态分析期间寄存器没有值，我们无法确定跳转指令的目标，因此也无法确定继续反汇编的地方。
- en: '**Function Call Instructions**'
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**函数调用指令**'
- en: '*Function call instructions* operate similarly to unconditional jump instructions
    (including the inability of the disassembler to determine the target of instructions
    such as `call rax`), with the additional expectation that execution usually returns
    to the instruction immediately following the call instruction after the function
    completes. In this regard, they are similar to conditional branch instructions
    in that they generate two execution paths. The target address of the call instruction
    is added to a list for deferred disassembly, while the instruction immediately
    following the call is disassembled in a manner similar to linear sweep.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数调用指令*的操作方式类似于无条件跳转指令（包括反汇编器无法确定像`call rax`这样的指令目标），但额外的期望是，在函数完成后，执行通常会返回到紧接在调用指令之后的指令。在这一点上，它们与条件跳转指令相似，因为它们生成两个执行路径。调用指令的目标地址会被添加到待定反汇编的地址列表中，而紧随调用指令的指令则按线性扫描的方式反汇编。'
- en: 'Recursive descent can fail if programs do not behave as expected when returning
    from called functions. For example, code in a function can deliberately manipulate
    the return address of that function so that upon completion, control returns to
    a location different from the one expected by the disassembler. A simple example
    is shown in the following incorrect listing, where function `badfunc` simply adds
    1 to the return address before returning to the caller:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序在从调用的函数返回时没有按照预期行为执行，递归下降可能会失败。例如，函数中的代码可以故意修改该函数的返回地址，以便在完成后，控制返回到一个不同于反汇编器预期的地址。以下是不正确的列表示例，其中函数`badfunc`在返回调用者之前，仅仅将返回地址加
    1：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As a result, control does not actually pass to the `add` instruction ➊ following
    the call to `badfunc`. A proper disassembly appears next:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，控制并没有实际传递到`add`指令➊，它位于调用`badfunc`之后。接下来是正确的反汇编：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This listing more clearly shows the flow of the program in which function `badfunc`
    actually returns to the `mov` instruction ➊. It is important to understand that
    a linear sweep disassembler will also fail to properly disassemble this code,
    though for slightly different reasons.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表更清晰地展示了程序的流程，其中`badfunc`函数实际上返回到`mov`指令➊。理解这一点很重要：线性扫描反汇编器也无法正确地反汇编这段代码，尽管原因略有不同。
- en: '**Return Instructions**'
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**返回指令**'
- en: In some cases, the recursive descent algorithm runs out of paths to follow.
    A function *return instruction* (x86 `ret`, for example) offers no information
    about which instruction will be executed next. If the program were actually running,
    an address would be taken from the top of the runtime stack, and execution would
    resume at that address. Disassemblers do not have the benefit of access to a stack.
    Instead, disassembly abruptly comes to a halt. It is at this point that the recursive
    descent disassembler turns to the list of addresses it has been setting aside
    for deferred disassembly. An address is removed from this list, and the disassembly
    process is continued from this address. This is the recursive process that lends
    the disassembly algorithm its name.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，递归下降算法会走到无路可走的地步。一个函数的*返回指令*（例如 x86 的`ret`）并没有提供有关下一条指令的信息。如果程序真的在运行，地址会从运行时堆栈的顶部获取，并在该地址恢复执行。反汇编器无法访问堆栈，因此反汇编过程会突然中断。在这一点上，递归下降反汇编器会转向它之前保留的待反汇编地址列表。一个地址从该列表中移除，反汇编过程会从该地址继续。这就是递归过程，赋予了反汇编算法其名称。
- en: One of the principle advantages of the recursive descent algorithm is its superior
    ability to distinguish code from data. As a control flow-based algorithm, it is
    much less likely to incorrectly disassemble data values as code. The main disadvantage
    of recursive descent is the inability to follow indirect code paths, such as jumps
    or calls, which utilize tables of pointers to look up a target address. However,
    with the addition of some heuristics to identify pointers to code, recursive descent
    disassemblers can provide very complete code coverage and excellent recognition
    of code versus data. [Listing 1-2](ch01.xhtml#exa1_2) shows the output of Ghidra’s
    recursive descent disassembler used on the same switch statement shown earlier
    in [Listing 1-1](ch01.xhtml#exa1_1).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 递归下降算法的主要优势之一是它在区分代码和数据方面的卓越能力。作为一种基于控制流的算法，它不太可能错误地将数据值反汇编为代码。递归下降的主要缺点是无法跟踪间接代码路径，例如使用指针表查找目标地址的跳转或调用。然而，通过加入一些启发式方法来识别指向代码的指针，递归下降反汇编器可以提供非常完整的代码覆盖，并且能够很好地区分代码和数据。[列表
    1-2](ch01.xhtml#exa1_2)展示了使用 Ghidra 递归下降反汇编器对前面[列表 1-1](ch01.xhtml#exa1_1)中展示的相同
    switch 语句的输出。
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 1-2: Recursive descent disassembly*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 1-2：递归下降反汇编*'
- en: Note that this section of the binary has been recognized as a switch statement
    and formatted accordingly. An understanding of the recursive descent process will
    help us recognize situations in which Ghidra may produce less-than-optimal disassemblies
    and allow us to develop strategies to improve Ghidra’s output.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段二进制代码已被识别为一个 switch 语句，并进行了相应的格式化。理解递归下降过程将帮助我们识别 Ghidra 可能产生不尽人意的反汇编情况，并允许我们开发策略来改善
    Ghidra 的输出。
- en: '**Summary**'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Is deep understanding of disassembly algorithms essential when using a disassembler?
    No. Is it useful? Yes! Battling your tools is the last thing you want to spend
    time doing while reverse engineering. One of the many advantages of Ghidra is
    that, as an interactive disassembler, it offers you plenty of opportunity to guide
    and override its decisions. The net result is quite often a disassembly that is
    both thorough and accurate.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用反汇编器时，深入理解反汇编算法是否必要？不。是否有用？是的！在进行逆向工程时，和工具作斗争是你最不希望花时间做的事。Ghidra的众多优点之一是，作为一个交互式反汇编器，它提供了大量的机会让你引导和覆盖它的决策。最终的结果往往是一个既全面又准确的反汇编。
- en: In the next chapter, we review a variety of existing tools that prove useful
    in many reverse engineering situations. While not directly related to Ghidra,
    many of these tools have influenced Ghidra, and they help to explain the wide
    variety of informational displays available in the Ghidra user interface.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾一些在许多逆向工程场景中非常有用的现有工具。虽然这些工具与Ghidra没有直接关系，但它们中的许多对Ghidra产生了影响，并且帮助解释了Ghidra用户界面中各种信息展示的多样性。
