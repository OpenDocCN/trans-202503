- en: Chapter 9. Lists
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章 列表
- en: The programs we’ve written so far have used ordinary variables to store single
    pieces of data. Such variables are not as useful, however, when you want to store
    a bunch of values, such as your friends’ phone numbers, names of books, or a month
    of temperature readings.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写的程序使用普通变量来存储单一数据。但是，当你需要存储一堆值时，比如朋友的电话号码、书名或一个月的温度读数，这种变量就不太实用了。
- en: 'For example, if you wanted your program to remember the phone numbers of 20
    of your friends, you’d need 20 variables! Certainly, writing and maintaining a
    program with 20 variables would be tedious. In this chapter, we’ll explore another
    built-in data type, called a *list*, which offers a convenient way to group related
    values. Here’s what we’ll cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你希望你的程序记住20个朋友的电话号码，你需要20个变量！显然，编写和维护一个包含20个变量的程序会非常繁琐。在本章中，我们将探索另一种内建数据类型——*列表*，它提供了一种方便的方式来组织相关的值。以下是我们将要讨论的内容：
- en: How to create and manipulate lists
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建和操作列表
- en: Initializing and accessing individual elements in a list
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化并访问列表中的单个元素
- en: Basic sorting and search techniques
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的排序和搜索技巧
- en: Using lists to create powerful applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列表创建强大的应用程序
- en: First, I’ll explain how to make lists in Scratch, demonstrate the commands you
    can use with them, and show you how to populate lists with data entered by a user.
    We’ll then discuss numeric lists and common operations performed on them, such
    as finding the minimum, the maximum, and the average value of their elements.
    After that, we’ll learn one algorithm for sorting the elements in a list. We’ll
    end with several example programs that demonstrate some real-world applications
    of lists.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将解释如何在Scratch中创建列表，演示你可以使用的命令，并展示如何用用户输入的数据填充列表。接下来，我们将讨论数字列表和对其执行的常见操作，例如查找最小值、最大值和元素的平均值。之后，我们将学习一种用于对列表中的元素进行排序的算法。最后，我们将通过几个示例程序展示列表的一些实际应用。
- en: Lists in Scratch
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scratch中的列表
- en: A list is like a container where you can store and access multiple values. You
    can think of it as a dresser with many drawers, with each drawer storing a single
    item. When you create a list, you name it just as you would a variable. You can
    then access the individual elements of the list using their storage position in
    the list. [Figure 9-1](ch09.html#list_that_contains_the_days_of_the_week "Figure 9-1. A
    list that contains the days of the week"), for example, depicts a list named `dayList`
    that stores the names of the seven days of the week.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 列表就像一个容器，你可以在其中存储和访问多个值。你可以把它看作一个有许多抽屉的衣柜，每个抽屉存储一个项目。当你创建一个列表时，你需要为它命名，就像你为变量命名一样。然后，你可以通过它们在列表中的存储位置来访问列表的单个元素。[图9-1](ch09.html#list_that_contains_the_days_of_the_week
    "图9-1：包含星期几的列表")中展示了一个名为`dayList`的列表，它存储了星期一到星期日的名称。
- en: You can refer to the items contained in a list using their *storage index* (or
    position). In Scratch, the first item has an index of 1, the second item is 2,
    and so on. For example, since Tuesday is third in the list, it has an index of
    3\. Therefore, you can refer to the third element of our `dayList` using a command
    of the form “item 3 of `dayList`.”
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过*存储索引*（或位置）来引用列表中的项。在Scratch中，第一个项的索引为1，第二个项的索引为2，依此类推。例如，由于星期二是列表中的第三项，因此它的索引为3。因此，你可以通过“item
    3 of `dayList`”命令来引用我们的`dayList`中的第三个元素。
- en: Let’s jump right in and create some lists in Scratch. We’ll also look at the
    commands that allow us to manage and manipulate lists in our programs and learn
    how Scratch responds to invalid list commands.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接开始在Scratch中创建一些列表。我们还将了解一些可以帮助我们管理和操作程序中列表的命令，并学习Scratch如何响应无效的列表命令。
- en: '![A list that contains the days of the week](httpatomoreillycomsourcenostarchimages2134957.png.jpg)Figure 9-1. A
    list that contains the days of the week'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![包含星期几的列表](httpatomoreillycomsourcenostarchimages2134957.png.jpg)图9-1：包含星期几的列表'
- en: Creating Lists
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建列表
- en: Creating a list is almost identical to creating a variable. Select the *Data*
    palette and click **Make a List** to bring up the dialog in [Figure 9-2](ch09.html#creating_a_list_in_scratch_is_similar_to
    "Figure 9-2. Creating a list in Scratch is similar to creating a variable.") (right).
    Next, enter the name of the list (we’ll use `dayList`) and specify its scope.
    Choosing the For all sprites option creates a *global* list that any sprite in
    your application can access, while the For this sprite only option creates a *local*
    list that belongs to the currently selected sprite. Local lists can only be read
    (and written to) by the owner sprite.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 创建列表几乎与创建变量相同。选择*数据*面板并点击**创建列表**，以弹出[图 9-2](ch09.html#creating_a_list_in_scratch_is_similar_to
    "图 9-2. 在 Scratch 中创建列表类似于创建变量.")（右）中的对话框。接下来，输入列表的名称（我们将使用 `dayList`）并指定其作用域。选择“对所有精灵有效”选项会创建一个*全局*列表，应用程序中的任何精灵都可以访问，而选择“仅对该精灵有效”选项会创建一个*局部*列表，仅属于当前选定的精灵。局部列表只能被所属的精灵读取（和写入）。
- en: When you click **OK** to confirm your input, Scratch creates a new *empty list*
    and shows the list-related blocks, as illustrated in [Figure 9-3](ch09.html#command_and_function_blocks_that_you_can
    "Figure 9-3. Command and function blocks that you can use with lists"). This is
    similar to what you’d see when you create a new variable. An empty list is a list
    that does not contain any items.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击**确定**确认输入时，Scratch 会创建一个新的*空列表*并显示与列表相关的块，如[图 9-3](ch09.html#command_and_function_blocks_that_you_can
    "图 9-3. 可以与列表一起使用的命令和功能块")所示。这与创建新变量时看到的情况类似。空列表是指不包含任何项的列表。
- en: You can use these new commands to manipulate the contents of your list while
    your script is running. You can append new items, insert items at specific positions,
    delete certain items, or replace the values of existing items.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些新命令在脚本运行时操作列表的内容。你可以添加新项、在特定位置插入项、删除某些项或替换现有项的值。
- en: '![Creating a list in Scratch is similar to creating a variable.](httpatomoreillycomsourcenostarchimages2134959.png.jpg)Figure 9-2. Creating
    a list in Scratch is similar to creating a variable.![Command and function blocks
    that you can use with lists](httpatomoreillycomsourcenostarchimages2134961.png.jpg)Figure 9-3. Command
    and function blocks that you can use with lists'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![在 Scratch 中创建列表类似于创建变量。](httpatomoreillycomsourcenostarchimages2134959.png.jpg)图
    9-2. 在 Scratch 中创建列表类似于创建变量。![可以与列表一起使用的命令和功能块](httpatomoreillycomsourcenostarchimages2134961.png.jpg)图
    9-3. 可以与列表一起使用的命令和功能块'
- en: When a new list is created, Scratch also shows the list’s monitor on the Stage,
    as illustrated in [Figure 9-4](ch09.html#monitor_of_a_newly_created_list_is_shown
    "Figure 9-4. The monitor of a newly created list is shown on the Stage."). The
    list will initially be empty, so its length starts at 0\. You can use this monitor
    block to add entries to your list as you design a program.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新列表时，Scratch 还会在舞台上显示该列表的监视器，如[图 9-4](ch09.html#monitor_of_a_newly_created_list_is_shown
    "图 9-4. 新创建的列表的监视器会显示在舞台上")所示。该列表最初为空，因此它的长度从 0 开始。你可以使用此监视器块在设计程序时向列表添加条目。
- en: '![The monitor of a newly created list is shown on the Stage.](httpatomoreillycomsourcenostarchimages2134963.png.jpg)Figure 9-4. The
    monitor of a newly created list is shown on the Stage.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![新创建的列表的监视器显示在舞台上。](httpatomoreillycomsourcenostarchimages2134963.png.jpg)图
    9-4. 新创建的列表的监视器显示在舞台上。'
- en: If you know the data that you want to store in the list (as is the case for
    our `dayList`), you can add it to the list at this point. [Figure 9-5](ch09.html#populating_the_daylist
    "Figure 9-5. Populating the dayList") shows how you can add days to the `dayList`
    using its monitor.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道要存储在列表中的数据（就像我们的 `dayList` 一样），你可以在此时将数据添加到列表中。[图 9-5](ch09.html#populating_the_daylist
    "图 9-5. 填充 dayList")展示了如何通过其监视器将天数添加到 `dayList`。
- en: '![Populating the dayList](httpatomoreillycomsourcenostarchimages2134965.png.jpg)Figure 9-5. Populating
    the `dayList`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![填充 dayList](httpatomoreillycomsourcenostarchimages2134965.png.jpg)图 9-5.
    填充 `dayList`'
- en: Click the plus sign at the lower-left corner seven times to create seven entries
    and then enter a day of the week inside each edit box. Use the TAB key to navigate
    through the list items. Pressing TAB once highlights the next list item with a
    yellow border. Pressing TAB another time highlights the editable text of the selected
    item and removes the yellow border. If you click the plus sign while the currently
    selected item is surrounded by a yellow border, the new list item will be added
    after the current item; otherwise, it will be added before the current item. Try
    navigating the list!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在左下角点击加号七次，创建七个条目，然后在每个编辑框中输入一周的某一天。使用 TAB 键在列表项之间导航。按一次 TAB 键会将下一个列表项高亮显示，带有黄色边框。再按一次
    TAB 键会高亮选中的可编辑文本，并去掉黄色边框。如果在当前选中的项目周围有黄色边框时点击加号，新列表项会被添加到当前项之后；否则，它会被添加到当前项之前。试着导航列表吧！
- en: Try It Out 9-1
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9-1
- en: Populate `dayList` with the names of the weekdays, as shown in [Figure 9-5](ch09.html#populating_the_daylist
    "Figure 9-5. Populating the dayList").
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图 9-5](ch09.html#populating_the_daylist "图 9-5. 填充 dayList")所示，使用星期几的名称填充`dayList`。
- en: List Commands
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表命令
- en: '[Figure 9-3](ch09.html#command_and_function_blocks_that_you_can "Figure 9-3. Command
    and function blocks that you can use with lists") described all the blocks that
    Scratch added when we created our `dayList`. In this section, we’ll look more
    closely at these blocks to better understand their function.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-3](ch09.html#command_and_function_blocks_that_you_can "图 9-3. 你可以与列表一起使用的命令和功能块")描述了当我们创建`dayList`时，Scratch
    添加的所有块。在本节中，我们将更详细地查看这些块，以便更好地理解它们的功能。'
- en: Add and Delete
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加和删除
- en: The **add** command places a new item at the end of a list, while the **delete**
    command removes an item from a specific position. [Figure 9-6](ch09.html#list_before_and_after_add_and_delete_are
    "Figure 9-6. A list before and after add and delete are used to change its contents")
    shows these commands in action.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**add**命令将一个新项目添加到列表的末尾，而**delete**命令则从特定位置删除一个项目。[图 9-6](ch09.html#list_before_and_after_add_and_delete_are
    "图 9-6. 使用 add 和 delete 改变列表内容前后的效果")展示了这些命令的实际应用。'
- en: The script first executes the **delete** command to remove the second item of
    the list, which is “Orange.” The script then puts “Lemon” at the end of the list
    using the **add** command.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先执行**delete**命令删除列表中的第二项，即“橙子”。然后，脚本使用**add**命令将“柠檬”添加到列表的末尾。
- en: '![A list before and after add and delete are used to change its contents](httpatomoreillycomsourcenostarchimages2134967.png.jpg)Figure 9-6. A
    list before and after add and delete are used to change its contents'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用 add 和 delete 改变列表内容前后的效果](httpatomoreillycomsourcenostarchimages2134967.png.jpg)图 9-6.
    使用 add 和 delete 改变列表内容前后的效果'
- en: 'The **add** command is straightforward, but let’s examine the **delete** command
    more closely. You can type the index of the element you want to delete directly
    into the block’s parameter slot, or you can click the drop-down arrow. The drop-down
    menu (see [Figure 9-6](ch09.html#list_before_and_after_add_and_delete_are "Figure 9-6. A
    list before and after add and delete are used to change its contents")) shows
    three options: 1, last, and all. Select 1 to delete the first item (“Apple”) from
    the list, select last to delete the last item (“Mango”), or select all to delete
    all the items from the list.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**add**命令非常直接，但让我们更仔细地查看**delete**命令。你可以直接将要删除的元素的索引输入到块的参数框中，或者点击下拉箭头。下拉菜单（参见[图 9-6](ch09.html#list_before_and_after_add_and_delete_are
    "图 9-6. 使用 add 和 delete 改变列表内容前后的效果")）显示了三个选项：1、last 和 all。选择 1 删除列表中的第一个项目（“苹果”），选择
    last 删除最后一个项目（“芒果”），或选择 all 删除列表中的所有项目。'
- en: Insert and Replace
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 插入和替换
- en: Let’s say you want to store your friends’ names and phone numbers alphabetically
    in a list, just like the contacts list in your cell phone. As you make your list,
    you need to insert each friend’s contact information at the proper position. Later,
    if one friend gets a new phone number, you’ll need to edit the list to enter it.
    The **insert** and **replace** commands can help you with these tasks. [Figure 9-7](ch09.html#using_the_insert_and_the_replace_command
    "Figure 9-7. Using the insert and the replace commands to update a list of telephone
    numbers") shows an example of using the **insert** and **replace** commands with
    our `phone` list.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望按字母顺序存储朋友们的姓名和电话号码，就像手机中的联系人列表一样。在制作列表时，您需要将每个朋友的联系信息插入到合适的位置。之后，如果某个朋友有了新电话号码，您将需要编辑列表来输入它。**insert**和**replace**命令可以帮助您完成这些任务。[图9-7](ch09.html#using_the_insert_and_the_replace_command
    "图9-7。使用insert和replace命令更新电话号码列表")展示了如何在我们的`phone`列表中使用**insert**和**replace**命令的示例。
- en: '![Using the insert and the replace commands to update a list of telephone numbers](httpatomoreillycomsourcenostarchimages2134969.png.jpg)Figure 9-7. Using
    the insert and the replace commands to update a list of telephone numbers'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用insert和replace命令更新电话号码列表](httpatomoreillycomsourcenostarchimages2134969.png.jpg)图9-7。使用insert和replace命令更新电话号码列表'
- en: The **replace** command overwrites the current string at slot number 3 with
    Kim’s new phone number. The **insert** command places the phone number of a new
    friend, Mark, at slot number 4 in the list. Notice that the existing elements
    moved down one slot to make room for the new entry.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**replace**命令将位置为3的当前字符串替换为Kim的新电话号码。**insert**命令将在列表的第4个位置插入新朋友Mark的电话号码。请注意，现有的元素下移一个位置，为新的条目腾出空间。'
- en: 'Clicking the item number’s down arrow in both the **replace** and the **insert**
    commands shows a drop-down menu of three options: 1, last, and random (see [Figure 9-7](ch09.html#using_the_insert_and_the_replace_command
    "Figure 9-7. Using the insert and the replace commands to update a list of telephone
    numbers")). If you select random, the selected command will choose an item number
    randomly. You’ll see some useful applications of this feature later in this chapter.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在**replace**和**insert**命令中，点击项目编号的下箭头会显示一个下拉菜单，包含三个选项：1、last 和 random（见[图9-7](ch09.html#using_the_insert_and_the_replace_command
    "图9-7。使用insert和replace命令更新电话号码列表")）。如果选择random，所选命令将随机选择一个项目编号。您将在本章后面看到这一功能的一些有用应用。
- en: Accessing List Elements
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 访问列表元素
- en: As we mentioned earlier, you can access any element in a list using that element’s
    index. For example, the script in [Figure 9-8](ch09.html#this_script_causes_the_sprite_to_display
    "Figure 9-8. This script causes the sprite to display the seven days of our dayList.")
    demonstrates using the **item of** block to access the elements of our `dayList`.
    The script uses a variable named `pos` (short for *position*) to iterate through
    each item of the list, showing the contents via the **say** command.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，您可以使用该元素的索引来访问列表中的任何元素。例如，图[图9-8](ch09.html#this_script_causes_the_sprite_to_display
    "图9-8。该脚本使得精灵显示我们的`dayList`中的七天。")中的脚本演示了使用**item of**块来访问我们的`dayList`中的元素。该脚本使用了一个名为`pos`（*位置*的缩写）的变量，通过它来迭代列表中的每个元素，并通过**say**命令显示内容。
- en: '![This script causes the sprite to display the seven days of our dayList.](httpatomoreillycomsourcenostarchimages2134971.png.jpg)Figure 9-8. This
    script causes the sprite to display the seven days of our `dayList`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![该脚本使得精灵显示我们的`dayList`中的七天。](httpatomoreillycomsourcenostarchimages2134971.png.jpg)图9-8。该脚本使得精灵显示我们的`dayList`中的七天。'
- en: The script initializes the value of `pos` to 1 so it can access the first element
    in `dayList`, and then the script enters a loop. The loop’s repeat count is set
    to 7, the number of elements in our list. On each pass, the loop will say the
    list item with an index equal to `pos` and increment the value of `pos` to access
    the next element. In other words, we’re using `pos` as an index to pinpoint a
    specific element in the list.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本将`pos`的初始值设为1，以便访问`dayList`中的第一个元素，然后进入循环。该循环的重复次数设置为7，这是我们列表中元素的数量。在每次循环中，循环将显示索引等于`pos`的列表项，并将`pos`的值递增，以便访问下一个元素。换句话说，我们正在使用`pos`作为索引来定位列表中的特定元素。
- en: Try It Out 9-2
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9-2
- en: Replace the literal number 7 in the repeat loop with the **length of dayList**
    block. This is what you’d normally do to step through a list if you didn’t know
    how many items it contained. Also, select **random** from the first drop-down
    menu in the **item of** block. This should cause the script to display an item
    from the list at random.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将repeat循环中的数字7替换为**dayList的长度**积木。这通常是你在不知道列表包含多少项时遍历列表的做法。另外，在**item of**积木的第一个下拉菜单中选择**random**。这样应该会使脚本从列表中随机显示一个项目。
- en: The Contains Block
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: contains积木
- en: You can check whether a certain string is in a list by using **contains**, a
    Boolean block that returns true or false based on whether or not the list contains
    your string. The script shown in [Figure 9-9](ch09.html#using_the_contains_block_to_check_whethe
    "Figure 9-9. Using the contains block to check whether a string is in a list")
    illustrates one use of this block. Since `dayList` contains the string “Friday”,
    the **say** command inside the **if** block will be executed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用**contains**来检查某个字符串是否在列表中，这是一个布尔型积木，它会根据列表是否包含该字符串返回真或假。[图9-9](ch09.html#using_the_contains_block_to_check_whethe
    "图9-9. 使用contains积木检查字符串是否在列表中")展示了这个积木的一个使用示例。由于`dayList`包含字符串“Friday”，因此**if**积木内的**say**命令将被执行。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The* **contains** *block is case insensitive. The block* **dayList contains
    friDAY***, for example, would also evaluate to true.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*该* **contains** *积木是不区分大小写的。例如，积木* **dayList contains friDAY***也会返回true。*'
- en: '![Using the contains block to check whether a string is in a list](httpatomoreillycomsourcenostarchimages2134973.png.jpg)Figure 9-9. Using
    the contains block to check whether a string is in a list'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用contains积木检查字符串是否在列表中](httpatomoreillycomsourcenostarchimages2134973.png.jpg)图9-9.
    使用contains积木检查字符串是否在列表中'
- en: Bounds Checking
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 边界检查
- en: The four list blocks (**delete**, **insert**, **replace**, and **item of**)
    require an input parameter that specifies the index of the item you want to access.
    For example, to delete the seventh element of our `dayList`, we use **delete 7
    of dayList**. But what do you think will happen if you use an invalid index with
    one of these blocks? For example, how would Scratch respond if you asked it to
    delete the eighth element of our `dayList` (which only contains seven elements)?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 四个列表积木（**delete**、**insert**、**replace**和**item of**）需要一个输入参数来指定你想访问的项目的索引。例如，要删除`dayList`中的第七个元素，我们使用**delete
    7 of dayList**。但你认为，如果使用无效的索引与这些积木之一一起使用，会发生什么呢？例如，如果你要求Scratch删除我们`dayList`中的第八个元素（它只有七个元素），Scratch会如何响应？
- en: Trying to access an element past the boundaries of a list is, technically, an
    error. Rather than display an error message or abruptly terminate your program,
    however, Scratch silently tries to do something sensible with the offending block.
    For this reason, the absence of error messages does not necessarily mean the absence
    of errors. Problems may still exist in your code, and when they do, you still
    need to fix them. Scratch won’t complain about invalid indexes in your blocks,
    but the outcome usually won’t be what you intended. [Table 9-1](ch09.html#unexpected_results_from_bad_list_indexes
    "Table 9-1. Unexpected Results from Bad List Indexes") shows what can happen when
    you try to access `dayList` using an out-of-range index.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 试图访问超出列表边界的元素，严格来说，是一种错误。然而，Scratch并不会显示错误信息或突然终止程序，而是默默地尝试用合适的方式处理出现问题的积木。因此，缺少错误信息并不意味着没有错误。你的代码中可能仍然存在问题，当这些问题出现时，你仍然需要修复它们。Scratch不会抱怨积木中的无效索引，但结果通常不会是你预期的。[表9-1](ch09.html#unexpected_results_from_bad_list_indexes
    "表9-1. 使用无效列表索引的意外结果")展示了当你尝试使用越界索引访问`dayList`时可能发生的情况。
- en: Table 9-1. Unexpected Results from Bad List Indexes
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 表9-1. 使用无效列表索引的意外结果
- en: '| Command or Function Block | Result |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 命令或功能积木 | 结果 |'
- en: '| --- | --- |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134975.png.jpg)
    | Returns an empty string because `dayList` has only seven items. The same thing
    happens if you use an index less than 1. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| ![没有标题的图片](httpatomoreillycomsourcenostarchimages2134975.png.jpg) | 返回空字符串，因为`dayList`只有七个项目。如果你使用小于1的索引，也会发生相同的情况。
    |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134977.png.jpg)
    | Scratch ignores the .9 and returns the first item of `dayList`, which is “Sunday”.
    Similarly, if you asked for item 5.3, Scratch would return the fifth item, “Thursday”.
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| ![没有标题的图片](httpatomoreillycomsourcenostarchimages2134977.png.jpg) | Scratch忽略.9并返回`dayList`中的第一个项目，“Sunday”。类似地，如果你要求获取第5.3个项目，Scratch将返回第五个项目，“Thursday”。
    |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134979.png.jpg)
    | Scratch ignores this command because it attempts to create a gap in the list.
    The list remains unchanged. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| ![无标题图片](httpatomoreillycomsourcenostarchimages2134979.png.jpg) | Scratch
    会忽略此命令，因为它试图在列表中创建一个间隙。列表保持不变。 |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134981.png.jpg)
    | This has the same effect as the **add** command. It adds “Newday” to the end
    of the list. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| ![无标题图片](httpatomoreillycomsourcenostarchimages2134981.png.jpg) | 这与**add**命令的效果相同。它将“Newday”添加到列表的末尾。
    |'
- en: '| ![image with no caption](httpatomoreillycomsourcenostarchimages2134983.png.jpg)
    | The command is ignored (because `dayList` has only seven elements), and the
    list remains unchanged. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| ![无标题图片](httpatomoreillycomsourcenostarchimages2134983.png.jpg) | 此命令被忽略（因为
    `dayList` 只有七个元素），列表保持不变。 |'
- en: The examples in [Table 9-1](ch09.html#unexpected_results_from_bad_list_indexes
    "Table 9-1. Unexpected Results from Bad List Indexes") demonstrate that, although
    Scratch’s blocks try to do something sensible when their inputs are invalid, they
    won’t necessarily do the right thing. You have to provide your program with the
    right inputs so it works the way you want it to.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 9-1](ch09.html#unexpected_results_from_bad_list_indexes "表格 9-1. 来自错误列表索引的意外结果")中的示例表明，尽管
    Scratch 的积木在输入无效时会尝试做一些合理的处理，但它们不一定会做出正确的操作。你必须为你的程序提供正确的输入，这样它才能按你希望的方式工作。'
- en: 'Up to this point, our examples have used simple lists that we created manually
    using their monitors. The question now is this: What if you don’t know the contents
    of a list when you write your program? For example, you may need to make a list
    of user-entered numbers or fill a list with random values each time the program
    is run. We’ll tackle this problem next.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的示例使用了通过其监视器手动创建的简单列表。现在的问题是：如果你在编写程序时不知道列表的内容该怎么办？例如，你可能需要创建一个用户输入的数字列表，或者每次运行程序时用随机值填充一个列表。我们将在接下来解决这个问题。
- en: Dynamic Lists
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态列表
- en: Lists are powerful because they can grow or shrink dynamically as a program
    is running. Let’s say, for example, that you are writing a grade book application,
    in which teachers can enter students’ test scores for further processing. (The
    teacher might need to find the maximum score, minimum, average, median, and so
    on for a class.) However, the number of students may be different for every class.
    The teacher may need to enter 20 scores for Class 1, 25 scores for Class 2, and
    so on. How can your program know that the teacher has finished entering the scores?
    This section will answer that question.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表之所以强大，是因为它们可以在程序运行时动态增长或缩小。例如，假设你正在编写一个成绩册应用程序，教师可以输入学生的测试成绩以供进一步处理。（教师可能需要为一个班级找出最大分数、最小分数、平均分、中位数等。）然而，每个班级的学生数量可能不同。教师可能需要为班级
    1 输入 20 个成绩，为班级 2 输入 25 个成绩，依此类推。你的程序如何知道教师已经完成了成绩输入？本节将解答这个问题。
- en: First, we’ll introduce two ways to populate lists with data from a user. We’ll
    then explore numeric lists and look at some of the common operations performed
    on them. Once you understand the fundamental concepts, you’ll be ready to adapt
    these techniques to your own applications.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍两种方法来填充用户输入的数据到列表中。然后，我们将探讨数字列表，并查看在它们上面执行的一些常见操作。一旦你理解了这些基本概念，你就能准备好将这些技巧应用到自己的应用程序中。
- en: Filling Lists with User Input
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用用户输入填充列表
- en: There are two common ways to fill a list with data entered by a user. In the
    first method, your program begins by asking how many entries there will be and
    then starts a loop to collect the user’s input. A script that demonstrates this
    technique is shown in [Figure 9-10](ch09.html#asking_the_user_how_many_scores_will_be
    "Figure 9-10. Asking the user how many scores will be entered").
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 填充列表的常见方法有两种。在第一种方法中，程序首先询问将有多少条输入数据，然后开始一个循环来收集用户的输入。演示此技术的脚本见于[图 9-10](ch09.html#asking_the_user_how_many_scores_will_be
    "图 9-10. 询问用户将输入多少分数")。
- en: '![Asking the user how many scores will be entered](httpatomoreillycomsourcenostarchimages2134985.png.jpg)Figure 9-10. Asking
    the user how many scores will be entered'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![询问用户将输入多少分数](httpatomoreillycomsourcenostarchimages2134985.png.jpg)图 9-10.
    询问用户将输入多少分数'
- en: Once the user tells this script how many scores to expect, the script starts
    a loop with a repetition count equal to the user’s input. Each iteration of the
    loop then asks the user for a new score and appends that value to the list, called
    `scoreList`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户告诉脚本期望输入多少个分数，脚本会开始一个循环，循环的重复次数等于用户的输入。每次循环迭代中，脚本会要求用户输入一个新的分数，并将该值添加到名为
    `scoreList` 的列表中。
- en: The second way to dynamically populate a list is to have the user enter a special
    value (known as a *sentinel*) to mark the end of the list. Of course, you should
    choose a sentinel that won’t be mistaken for a member of the list. If you’re expecting
    a list of names or positive numbers, for example, a sentinel of –1 is a good choice.
    If, on the other hand, the user will enter negative values, then –1 won’t be a
    good sentinel. Using a sentinel of –1 will work for our `scoreList`, and the script
    shown in [Figure 9-11](ch09.html#using_a_sentinel_to_control_list_growth "Figure 9-11. Using
    a sentinel to control list growth") uses this sentinel to know when the user is
    done entering values.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 动态填充列表的第二种方法是让用户输入一个特殊的值（称为*哨兵*）来标记列表的结束。当然，你应该选择一个不会与列表成员混淆的哨兵值。例如，如果你预计输入的是一组名字或正数，那么
    –1 是一个不错的选择。另一方面，如果用户会输入负值，那么 –1 就不适合作为哨兵值。使用 –1 作为我们的`scoreList`的哨兵是可行的，示例脚本在[图
    9-11](ch09.html#using_a_sentinel_to_control_list_growth "图 9-11. 使用哨兵控制列表增长")中使用这个哨兵值来判断用户何时完成输入值。
- en: '![Using a sentinel to control list growth](httpatomoreillycomsourcenostarchimages2134987.png.jpg)Figure 9-11. Using
    a sentinel to control list growth'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用哨兵控制列表增长](httpatomoreillycomsourcenostarchimages2134987.png.jpg)图 9-11.
    使用哨兵控制列表增长'
- en: In each iteration of the loop, the script prompts the user to enter a number
    and compares that value to the sentinel. Note that the script specifies the sentinel
    (–1 in this case) in its prompt to the user. If the user enters –1, then the script
    stops because it knows the user is done entering scores. Otherwise, the input
    value is appended to the list, and the user is prompted for another entry. [Figure 9-11](ch09.html#using_a_sentinel_to_control_list_growth
    "Figure 9-11. Using a sentinel to control list growth") shows how `scoreList`
    should look if the user enters three scores followed by the sentinel.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次循环迭代中，脚本会提示用户输入一个数字，并将该值与哨兵进行比较。请注意，脚本在提示用户时会指定哨兵值（在此示例中为 –1）。如果用户输入 –1，脚本会停止，因为它知道用户已经完成了分数的输入。否则，输入的值会被添加到列表中，用户将被提示输入另一个值。[图
    9-11](ch09.html#using_a_sentinel_to_control_list_growth "图 9-11. 使用哨兵控制列表增长")展示了当用户输入三个分数后再输入哨兵值时，`scoreList`
    应该是什么样子。
- en: Creating a Bar Chart
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建柱状图
- en: As a practical example of collecting user input with lists, let’s write an application
    that draws a bar chart (also called a *histogram*) from the user’s numbers. For
    simplicity, we’ll only accept five numbers between 1 and 40\. Once the program
    has received all five numbers, it will draw five bars with heights proportional
    to the entered values. The user interface for our chart maker is illustrated in
    [Figure 9-12](ch09.html#bar_chart_application "Figure 9-12. The Bar Chart application").
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个实际的例子，我们来写一个应用程序，从用户输入的数字中绘制柱状图（也叫做*直方图*）。为了简化，我们只接受1到40之间的五个数字。当程序收集到所有五个数字后，它将绘制五个柱状条，高度与输入值成比例。我们柱状图制作器的用户界面如[图
    9-12](ch09.html#bar_chart_application "图 9-12. 柱状图应用程序")所示。
- en: '*BarChart.sb2*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*BarChart.sb2*'
- en: '![The Bar Chart application](httpatomoreillycomsourcenostarchimages2134989.png.jpg)Figure 9-12. The
    Bar Chart application'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![柱状图应用程序](httpatomoreillycomsourcenostarchimages2134989.png.jpg)图 9-12. 柱状图应用程序'
- en: This application contains three sprites. The `Driver` sprite controls the flow
    of the application; it contains scripts that accept user input, populate the list,
    and tell the `Painter` sprite to start drawing. The `Painter` sprite is an invisible
    sprite that draws the bar chart. The `Frame` sprite is purely cosmetic; it hides
    the bottom of each bar to make it look flat; without it, the bottoms of the vertical
    bars would have rounded tips. The numerical values for the five bars are shown
    using five variables, named `n1` through `n5`, whose monitors are located at the
    right positions on the Stage. When you click the green flag icon to start the
    application, the `Driver` sprite runs the script shown in [Figure 9-13](ch09.html#main_script_for_the_driver_sprite
    "Figure 9-13. The main script for the Driver sprite").
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序包含三个精灵。`Driver`精灵控制应用程序的流程；它包含接受用户输入、填充列表并指示`Painter`精灵开始绘图的脚本。`Painter`精灵是一个不可见的精灵，负责绘制条形图。`Frame`精灵纯粹是装饰性的；它隐藏每个条形的底部，使其看起来平坦；如果没有它，垂直条形的底部会有圆形的尖端。五个条形的数值通过五个变量显示，命名为`n1`到`n5`，它们的显示器位于舞台的右侧。当你点击绿色旗帜图标开始应用程序时，`Driver`精灵运行[图9-13](ch09.html#main_script_for_the_driver_sprite
    "图9-13. Driver精灵的主脚本")中显示的脚本。
- en: '![The main script for the Driver sprite](httpatomoreillycomsourcenostarchimages2134991.png.jpg)Figure 9-13. The
    main script for the `Driver` sprite'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![Driver精灵的主脚本](httpatomoreillycomsourcenostarchimages2134991.png.jpg)图9-13.
    `Driver`精灵的主脚本'
- en: First, the `Driver` sprite appears on the Stage and clears any previous pen
    marks ①. That way, if there is a bar chart already, it will be cleared before
    the new one is drawn. The script then clears `numList` so we can use it to collect
    new entries from the user and calls **ShowValues** ② to set `n1` through `n5`
    so their monitors will be blank.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`Driver`精灵出现在舞台上并清除任何先前的笔迹①。这样，如果已经有条形图，它会在绘制新图之前被清除。脚本随后清空`numList`，以便我们可以用它来收集用户的新输入，并调用**ShowValues**
    ②来设置`n1`到`n5`，以便它们的显示器是空白的。
- en: When the Stage is prepared, the script enters a **repeat** loop ③, which iterates
    five times. Inside the loop, the `Driver` asks the user to enter a number and
    appends that number to `numList`. After collecting all five numbers from the user
    and saving them in `numList`, the `Driver` sprite hides itself ④ to make room
    for the bar chart. It then calls **ShowValues** again to update `n1` through `n5`
    with the user’s new values and broadcasts `Draw` so the `Painter` sprite will
    draw the five bars.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当舞台准备好后，脚本进入**repeat**循环③，循环执行五次。在循环内部，`Driver`提示用户输入一个数字，并将该数字附加到`numList`中。在收集到用户的五个数字并将它们保存在`numList`中后，`Driver`精灵隐藏自己④，为条形图腾出空间。然后它再次调用**ShowValues**，用用户的新值更新`n1`到`n5`，并广播`Draw`消息，这样`Painter`精灵就会绘制五个条形。
- en: Before examining how the `Painter` draws the bars, let’s look at the **ShowValues**
    procedure shown in [Figure 9-14](ch09.html#showvalues_procedure "Figure 9-14. The
    ShowValues procedure").
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看`Painter`如何绘制条形图之前，先来看一下**ShowValues**过程，如[图9-14](ch09.html#showvalues_procedure
    "图9-14. ShowValues过程")所示。
- en: '![The ShowValues procedure](httpatomoreillycomsourcenostarchimages2134993.png.jpg)Figure 9-14. The
    `ShowValues` procedure'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![ShowValues过程](httpatomoreillycomsourcenostarchimages2134993.png.jpg)图9-14.
    `ShowValues`过程'
- en: '**ShowValues** simply sets the variables `n1` through `n5` equal to their corresponding
    entries in `numList`. Since the first call to **ShowValues** is made immediately
    after clearing `numList`, all five variables will contain empty strings after
    this call. This results in clearing the five monitors on the Stage, which is exactly
    what we want. When `numList` contains data from the user, calling **ShowValues**
    displays the data in those same monitors.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**ShowValues**只是将变量`n1`到`n5`设置为它们在`numList`中的相应值。由于第一次调用**ShowValues**是在清空`numList`之后立即进行的，因此在这个调用后，所有五个变量将包含空字符串。这会导致清除舞台上的五个显示器，这正是我们想要的。当`numList`包含来自用户的数据时，调用**ShowValues**会将这些数据展示在相应的显示器上。'
- en: Now let’s explore the **Draw** procedure, which is executed when the `Painter`
    sprite receives the `Draw` message. You can see this script in [Figure 9-15](ch09.html#draw_script_of_the_painter_sprite
    "Figure 9-15. The Draw script of the Painter sprite").
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看**Draw**过程，它在`Painter`精灵收到`Draw`消息时执行。你可以在[图9-15](ch09.html#draw_script_of_the_painter_sprite
    "图9-15. Painter精灵的Draw脚本")中看到这个脚本。
- en: '![The Draw script of the Painter sprite](httpatomoreillycomsourcenostarchimages2134995.png.jpg)Figure 9-15. The
    Draw script of the `Painter` sprite'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![Painter精灵的Draw脚本](httpatomoreillycomsourcenostarchimages2134995.png.jpg)图9-15.
    `Painter`精灵的Draw脚本'
- en: The sprite first sets the pen color. Then it sets the pen’s size to a large
    value to draw the thick bars. To prepare for drawing the five vertical bars, the
    sprite points in the up direction ①.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵首先设置画笔颜色。然后，它将画笔的大小设置为较大的值，以绘制粗条形图。为准备绘制五个垂直条形图，精灵将方向指向上方①。
- en: The script starts a repeat loop to draw the five bars ②. We knew the *x*-position
    of each bar in advance, so we created a list named `xPos` to store those values
    (also shown in the figure). During each iteration of the loop, the `Painter` sprite
    moves to the *x*-position for the current bar, puts its pen down, and then moves
    up to draw a vertical line.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本启动一个重复循环来绘制五根条形图②。我们事先知道每根条形图的* x *位置，因此创建了一个名为`xPos`的列表来存储这些值（如图所示）。在每次循环迭代中，`Painter`精灵移动到当前条形图的*
    x *位置，放下画笔，然后向上移动以绘制垂直线。
- en: The height of each line is proportional to the corresponding value in `numList`.
    Our chart area on the Stage is 224 pixels tall, and since 40 is the highest value,
    an input of 40 should have a bar as tall as the chart. To find the height (in
    pixels) for any number in `numList`, we need to multiply that number by 5.6 (that
    is, 224/40). [Figure 9-16](ch09.html#sample_output_of_the_bar_chart_applicati
    "Figure 9-16. A sample output of the Bar Chart application") shows the output
    of the application after getting some data from the user. Note that the `Frame`
    sprite covers the rounded tip of the wide drawing pen so the bars look flat at
    the bottom.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每条线的高度与`numList`中对应的值成正比。我们舞台上的图表区域高224像素，由于40是最高值，输入40应当使条形图和图表一样高。要找出`numList`中任意数字的高度（以像素为单位），我们需要将该数字乘以5.6（即224/40）。[图9-16](ch09.html#sample_output_of_the_bar_chart_applicati
    "图9-16. 柱状图应用程序的输出示例")显示了在从用户那里获取一些数据后应用程序的输出。注意，`Frame`精灵覆盖了宽画笔的圆顶，使得条形图在底部看起来是平的。
- en: '![A sample output of the Bar Chart application](httpatomoreillycomsourcenostarchimages2134997.png.jpg)Figure 9-16. A
    sample output of the Bar Chart applicationTry It Out 9-3'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![柱状图应用程序的输出示例](httpatomoreillycomsourcenostarchimages2134997.png.jpg)图9-16.
    柱状图应用程序的输出示例试试看9-3'
- en: 'Run this application several times to understand how it works. Change the script
    so that each bar will be drawn in a different color. Hint: Create a new list,
    named `color`, for the `Painter` sprite that stores the color number of the five
    bars and use the following command before drawing each bar:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 多次运行此应用程序以理解其工作原理。修改脚本，使得每个条形图都用不同的颜色绘制。提示：为`Painter`精灵创建一个新的列表，名为`color`，存储五个条形图的颜色编号，并在绘制每个条形图之前使用以下命令：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2134999.png.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2134999.png.jpg)'
- en: Numerical Lists
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字列表
- en: Lists of numbers appear in many practical applications. We can have lists of
    test scores, temperature measurements, product prices, and more. In this section,
    we’ll explore some common operations you might want to perform on numerical lists.
    In particular, we’ll write procedures for finding the maximum or minimum value
    and for finding the average of the numbers stored in a list.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 数字列表在许多实际应用中都会出现。我们可以有考试成绩、温度测量、产品价格等的列表。在本节中，我们将探讨一些你可能想对数字列表执行的常见操作。特别是，我们将编写程序来查找最大值或最小值，并计算存储在列表中的数字的平均值。
- en: Finding Min and Max
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找最小值和最大值
- en: Suppose you’re a teacher and you need to know the highest score from the last
    exam your class took. You could write a program to compare all of those test scores
    and find the maximum value. Our first example, shown in [Figure 9-17](ch09.html#finding_the_maximum_number_in_a_list
    "Figure 9-17. Finding the maximum number in a list"), finds the highest number
    in a list named `score`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是一名教师，需要知道你班级上次考试的最高分。你可以编写程序来比较所有这些考试成绩并找到最大值。我们的第一个例子，见[图9-17](ch09.html#finding_the_maximum_number_in_a_list
    "图9-17. 查找列表中的最大数值")，找到一个名为`score`的列表中的最高分。
- en: '*FindMax.sb2*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*FindMax.sb2*'
- en: The **FindMax** procedure starts by setting the value of the `maxScore` variable
    equal to the first number in the list. It then starts a loop to compare the remaining
    numbers in the list with the current value of `maxScore`. Every time it finds
    a value greater than `maxScore`, it sets `maxScore` equal to that value. When
    the loop terminates, the value stored in `maxScore` will be the largest value
    contained in the list.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**FindMax**过程首先将`maxScore`变量的值设置为列表中的第一个数字。然后，它启动一个循环，比较列表中其余数字与当前`maxScore`的值。每次找到比`maxScore`更大的值时，它就将`maxScore`设置为那个值。当循环结束时，`maxScore`中存储的值将是列表中包含的最大值。'
- en: '![Finding the maximum number in a list](httpatomoreillycomsourcenostarchimages2135001.png.jpg)Figure 9-17. Finding
    the maximum number in a list'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![查找列表中的最大数字](httpatomoreillycomsourcenostarchimages2135001.png.jpg)图9-17.
    查找列表中的最大数字'
- en: Finding the minimum value in a list follows a similar algorithm. We start by
    assuming that the first element in the list is the smallest element and then use
    a loop to check the remaining elements. Each time we find a smaller value, we
    update the variable that holds the minimum value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 查找列表中的最小值遵循类似的算法。我们首先假设列表中的第一个元素是最小的元素，然后使用循环检查其余的元素。每当我们找到一个更小的值时，我们就更新保存最小值的变量。
- en: Try It Out 9-4
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 试试看 9-4
- en: Use what you learned in this section to create a procedure called **FindMin**
    that finds the minimum value of the `score` list.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本节中学到的内容创建一个名为**FindMin**的过程，找到`score`列表中的最小值。
- en: Finding the Average
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算平均值
- en: In our next example, we’ll write a procedure that computes the average score
    of the numbers stored in our `score` list. You can find the average of a sequence
    of *N* numbers by first finding their sum and then dividing the total by *N*.
    The procedure shown in [Figure 9-18](ch09.html#finding_the_average_value_of_a_list_of_n
    "Figure 9-18. Finding the average value of a list of numbers") does exactly that.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将编写一个过程，计算存储在`score`列表中的分数的平均值。你可以通过首先计算这些数字的和，再将总和除以*N*，来找到一系列*N*个数字的平均值。[图9-18](ch09.html#finding_the_average_value_of_a_list_of_n
    "图9-18. 查找一组数字的平均值")中展示的过程正是如此。
- en: '*FindAverage.sb2*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*FindAverage.sb2*'
- en: '![Finding the average value of a list of numbers](httpatomoreillycomsourcenostarchimages2135003.png.jpg)Figure 9-18. Finding
    the average value of a list of numbers'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![查找一组数字的平均值](httpatomoreillycomsourcenostarchimages2135003.png.jpg)图9-18.
    查找一组数字的平均值'
- en: The **FindAverage** procedure uses a loop to step through the scores stored
    in the list, add them together, and store the result in a variable named `sum`.
    (This variable is initialized to 0 before the start of the loop.) When the loop
    terminates, the script calculates the average by dividing `sum` by the number
    of scores, and it saves the result in a variable named `average`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**FindAverage**过程使用循环逐一处理列表中存储的分数，将它们加在一起，并将结果存储在名为`sum`的变量中。（在循环开始之前，这个变量初始化为0。）当循环终止时，脚本通过将`sum`除以分数的数量来计算平均值，并将结果保存在名为`average`的变量中。'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Pay special attention to the way we accumulated the* sum *variable inside
    the loop. This pattern, known as the* accumulator pattern*, comes up very often
    in programming.*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*特别注意我们在循环中如何累积* sum *变量。这个模式，称为*累加器模式*，在编程中非常常见。*'
- en: In the next section, we’ll explore how to search and sort lists, two common
    problems in programming. I’ll also walk you through some simple algorithms for
    performing each operation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何搜索和排序列表，这两个问题在编程中非常常见。我还将带你走过执行每个操作的一些简单算法。
- en: Try It Out 9-5
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 试试看 9-5
- en: Combine **FindAverage**, **FindMax**, and **FindMin** into one procedure (called
    **ProcessList**) that will display the average, maximum, and minimum values for
    the `score` list all at the same time.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将**FindAverage**、**FindMax**和**FindMin**合并为一个过程（称为**ProcessList**），该过程将同时显示`score`列表的平均值、最大值和最小值。
- en: Searching and Sorting Lists
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索和排序列表
- en: Suppose you have a list of contacts that isn’t in any particular order. If you
    wanted to organize the contacts, you might *sort* them into alphabetical order
    based on their names. If you need to know someone’s phone number and you have
    their last name, you’ll need to *search* the list to see if it contains that person’s
    contact information. The goal of this section is to introduce basic programming
    techniques for searching and sorting lists.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个没有特定顺序的联系人列表。如果你想组织这些联系人，你可能会根据他们的名字将其*排序*为字母顺序。如果你需要知道某人的电话号码，而你有他们的姓氏，你就需要*搜索*列表，查看其中是否包含该人的联系信息。本节的目标是介绍搜索和排序列表的基本编程技巧。
- en: Linear Search
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线性搜索
- en: Scratch’s **contains** block provides an easy way to check whether a list contains
    a specific item. If, in addition, we’d like to know the position of the item being
    searched for in a list, then we have to perform the search ourselves.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Scratch的**contains**块提供了一种简单的方法来检查列表中是否包含特定项目。如果我们还想知道所搜索项目在列表中的位置，那么我们必须自己进行搜索。
- en: '*SearchList.sb2*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*SearchList.sb2*'
- en: This section will explain one method for searching lists, called a *linear search*
    (or *sequential search*). The method is easy to understand and implement, and
    it works on any list, whether it is sorted or not. However, because a linear search
    compares the target value with every element in the list, it can take a long time
    if your list is large.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将解释一种查找列表项的方法，称为*线性搜索*（或*顺序搜索*）。这种方法易于理解和实现，适用于任何列表，无论列表是否排序。然而，由于线性搜索会将目标值与列表中的每个元素进行比较，如果列表很大，这种方法可能会花费很长时间。
- en: To illustrate, suppose you’re searching for a specific item in a list named
    `fruit`. If the list contains the item you are looking for, you also need to know
    the exact position of that item. The **SearchList** procedure shown in [Figure 9-19](ch09.html#searchlist_procedure
    "Figure 9-19. The SearchList procedure") performs a linear search on the `fruit`
    list to give us the answers we seek.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，假设你正在寻找名为`fruit`的列表中的特定项。如果列表中包含你要找的项，你还需要知道该项的确切位置。[图9-19](ch09.html#searchlist_procedure
    "图9-19. SearchList过程")中的**SearchList**过程对`fruit`列表进行了线性搜索，以帮助我们找到所需的答案。
- en: '![The SearchList procedure](httpatomoreillycomsourcenostarchimages2135005.png.jpg)Figure 9-19. The
    SearchList procedure'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![SearchList过程](httpatomoreillycomsourcenostarchimages2135005.png.jpg)图9-19.
    SearchList过程'
- en: Starting with the first element, **SearchList** compares the fruits in our list,
    one by one, with the one we’re looking for, which is represented by the `target`
    parameter. The procedure stops if it either finds the value or reaches the end
    of the list. If the script finds the value we want, the `pos` variable will contain
    the location where the item was found. Otherwise, the procedure sets `pos` to
    an invalid value (–1 in this case) to indicate that the target item was not in
    the list. [Figure 9-20](ch09.html#using_the_searchlist_procedure "Figure 9-20. Using
    the SearchList procedure") shows an example of calling this procedure and its
    corresponding output.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一个元素开始，**SearchList**会将列表中的每个水果与我们要找的项进行逐一比较，该项由`target`参数表示。如果该过程找到值或者到达列表末尾，就会停止。如果脚本找到了我们想要的值，`pos`变量将包含该项找到的位置。否则，过程会将`pos`设置为一个无效值（在本例中为-1），以指示目标项不在列表中。[图9-20](ch09.html#using_the_searchlist_procedure
    "图9-20. 使用SearchList过程")展示了调用此过程的一个例子及其相应的输出。
- en: '![Using the SearchList procedure](httpatomoreillycomsourcenostarchimages2135007.png.jpg)Figure 9-20. Using
    the SearchList procedure'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用SearchList过程](httpatomoreillycomsourcenostarchimages2135007.png.jpg)图9-20.
    使用SearchList过程'
- en: 'Examining the value of `pos` tells the caller two things: (a) whether the item
    we’re looking for is in the list or not and (b) if the item exists, its exact
    position. Running this script sets `pos` to 4, indicating that “Peach” was found
    in the fourth position of the `fruit` list.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`pos`的值可以告诉调用者两件事：（a）我们要找的项是否在列表中；（b）如果该项存在，它的确切位置。运行此脚本将`pos`设置为4，表示“桃子”在`fruit`列表的第四个位置找到了。
- en: Frequency of Occurrence
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 出现频率
- en: Suppose that your school conducted a survey about the quality of its cafeteria
    food. Students rated the taste on a 1 to 5 scale (1 = poor, 5 = excellent). All
    votes have been entered into a list, and you are asked to write a program to process
    this data. For now, the school only wants to know how many students completely
    dislike the food (that is, how many gave it a rating of 1). How would you write
    such a program?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的学校对其食堂的食品质量进行了调查。学生们根据1到5的评分标准对口味进行打分（1 = 差，5 = 优秀）。所有投票已被输入到一个列表中，你被要求编写一个程序来处理这些数据。目前，学校只想知道有多少学生完全不喜欢食物（即有多少人打了1分）。你会如何编写这样的程序？
- en: '*ItemCount.sb2*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*ItemCount.sb2*'
- en: Clearly, your program needs a procedure that counts how many times the number
    1 appears in the list. To simulate the students’ votes, let’s use a list that
    contains 100 random votes. The procedure that populates the list is shown in [Figure 9-21](ch09.html#filllist_procedure
    "Figure 9-21. The FillList procedure"). This procedure adds 100 random numbers
    between 1 and 5 to a list called `survey`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你的程序需要一个过程来统计数字1在列表中出现的次数。为了模拟学生的投票，我们使用一个包含100个随机投票的列表。填充该列表的过程如[图9-21](ch09.html#filllist_procedure
    "图9-21. FillList过程")所示。这个过程将100个介于1到5之间的随机数字添加到一个名为`survey`的列表中。
- en: '![The FillList procedure](httpatomoreillycomsourcenostarchimages2135009.png.jpg)Figure 9-21. The
    FillList procedure'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![FillList过程](httpatomoreillycomsourcenostarchimages2135009.png.jpg)图9-21.
    FillList过程'
- en: Now that we have a list of votes, we can count how often a given rating appears
    in that list. We’ll do this with the **GetItemCount** procedure, shown in [Figure 9-22](ch09.html#counting_how_many_times_an_item_appears
    "Figure 9-22. Counting how many times an item appears in a list").
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个投票列表，我们可以统计某个评分在该列表中出现的次数。我们将使用**GetItemCount**过程，如[图9-22](ch09.html#counting_how_many_times_an_item_appears
    "图9-22. 统计列表中某个项目出现的次数")所示。
- en: '![Counting how many times an item appears in a list](httpatomoreillycomsourcenostarchimages2135011.png.jpg)Figure 9-22. Counting
    how many times an item appears in a list'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![统计列表中某个项目出现的次数](httpatomoreillycomsourcenostarchimages2135011.png.jpg)图9-22.
    统计列表中某个项目出现的次数'
- en: The `target` parameter represents the item to search for, while the `itemCount`
    variable tracks the number of times the target item is found. The procedure starts
    by setting `itemCount` to 0, and then it starts a **repeat** loop to search the
    list for the value specified in `target`. During each iteration of the loop, the
    procedure checks the list item at the location indexed by the loop counter, `n`.
    If that item equals the target, the script increases `itemCount` by 1.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`target`参数表示要查找的项目，而`itemCount`变量则跟踪目标项目出现的次数。该过程首先将`itemCount`设置为0，然后开始一个**repeat**循环，在列表中查找`target`中指定的值。在每次循环迭代中，程序检查由循环计数器`n`索引的列表项。如果该项等于目标，脚本会将`itemCount`增加1。'
- en: To give the principal information about disgust with the cafeteria’s food, we
    just need to call **GetItemCount** with an argument of 1, as shown in [Figure 9-23](ch09.html#using_the_getitemcount_procedure
    "Figure 9-23. Using the GetItemCount procedure").
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要提供关于对餐厅食物感到厌恶的主要信息，我们只需要使用参数为1调用**GetItemCount**，如[图9-23](ch09.html#using_the_getitemcount_procedure
    "图9-23. 使用GetItemCount过程")所示。
- en: '![Using the GetItemCount procedure](httpatomoreillycomsourcenostarchimages2135013.png.jpg)Figure 9-23. Using
    the GetItemCount procedureTry It Out 9-6'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用GetItemCount过程](httpatomoreillycomsourcenostarchimages2135013.png.jpg)图9-23.
    使用GetItemCount过程 尝试9-6'
- en: After you provide the answer to this question, the principal suddenly becomes
    curious about how many students gave the cafeteria an excellent rating. The principal
    also wants to know how many students participated in the survey. Modify the program
    and run it again to give the principal the additional information.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你回答了这个问题后，校长突然好奇有多少学生给餐厅打了优异的评分。校长还想知道有多少学生参加了调查。修改程序并再次运行，以提供这些额外的信息。
- en: Bubble Sort
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 冒泡排序
- en: If you have a set of names, game scores, or anything else that you want to show
    in a particular order—alphabetically, from largest to smallest, and so on—you’ll
    have to sort your list. There are many ways to sort lists, and a *bubble sort*
    is one of the simplest algorithms. (The name refers to how values “bubble” up
    through the list to their correct positions.) In this section, we’ll learn about
    bubble sort and write a Scratch program to perform this kind of sort for us.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一组名称、游戏成绩或其他任何你想以特定顺序显示的东西——按字母顺序、从大到小等等——你就必须对列表进行排序。有许多方法可以排序列表，而*冒泡排序*是最简单的算法之一。（这个名字指的是值是如何“冒泡”到它们正确的位置的。）在本节中，我们将学习冒泡排序，并编写一个Scratch程序来执行这种排序。
- en: '*BubbleSort.sb2*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*BubbleSort.sb2*'
- en: Let’s say that we need to sort the list of numbers [6 9 5 7 4 8] in descending
    order. The following steps illustrate how the bubble sort algorithm works.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要按降序排列数字列表[6 9 5 7 4 8]。以下步骤说明了冒泡排序算法是如何工作的。
- en: We’ll start by comparing the first two elements in the list. Since 9 is larger
    than 6, we can swap their positions, as shown below.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先比较列表中的前两个元素。由于9大于6，我们可以交换它们的位置，如下所示。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2135015.png.jpg)'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2135015.png.jpg)'
- en: Now we can compare the second and third elements, which are 6 and 5\. Since
    6 is larger than 5, the two numbers are already in order, and we can move on to
    the next pair.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以比较第二个和第三个元素，它们是6和5。由于6大于5，这两个数字已经按顺序排列，我们可以继续比较下一个元素。
- en: We’ll repeat this process to compare the third and fourth, fourth and fifth,
    and finally the fifth and sixth elements. Take a look at the list after these
    three comparisons, shown below.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重复此过程，比较第三个和第四个、第四个和第五个，最后比较第五个和第六个元素。看一下这三个比较后的列表，如下所示。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2135017.png.jpg)'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2135017.png.jpg)'
- en: 'This pass of the bubble sort is over, but our list still isn’t in the right
    order. We need to perform a second pass, starting from step one. Once more, we’ll
    compare each pair of elements and swap them if needed. Here’s the list after a
    second pass:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次冒泡排序已经结束，但我们的列表仍然没有正确排序。我们需要进行第二次遍历，从第一步开始。再一次，我们将比较每一对元素，如果需要，就交换它们。第二次遍历后的列表如下：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2135019.png.jpg)'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2135019.png.jpg)'
- en: 'We’ll repeat the bubble sort process until no numbers are swapped during a
    pass, meaning that our list is in order. The final three passes of the algorithm
    are shown below:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重复冒泡排序过程，直到在一次遍历中没有交换任何数字，意味着我们的列表已经排序。算法的最后三次遍历如下所示：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2135021.png.jpg)'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2135021.png.jpg)'
- en: Now that you’ve seen how bubble sort works, let’s implement it in Scratch. The
    script, shown in [Figure 9-24](ch09.html#bubblesort_procedure "Figure 9-24. The
    BubbleSort procedure"), has two loops. The inner loop cycles through a list, comparing
    and swapping as needed, and sets a flag (named `done`) to 0 when another pass
    is needed. The outer loop repeats as long as the `done` flag is 0, because that
    value means we aren’t done sorting. If the inner loop completes one pass without
    swapping elements, the outer loop will exit, ending the procedure.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了冒泡排序是如何工作的，让我们在Scratch中实现它。脚本，如[图9-24](ch09.html#bubblesort_procedure
    "图9-24. 冒泡排序过程")所示，有两个循环。内层循环遍历列表，根据需要进行比较和交换，并在需要再次遍历时将标志（名为`done`）设置为0。外层循环会重复，直到`done`标志为0，因为该值表示我们尚未完成排序。如果内层循环在没有交换元素的情况下完成一遍，外层循环将退出，结束过程。
- en: Let’s explore this procedure in more detail. Since we haven’t done any sorting
    yet, it sets `done` to 0 ①. The outer loop uses a **repeat until** block to pass
    through the list until it is sorted (that is, until `done` becomes 1) ②. At the
    beginning of every pass, this loop sets `done` to 1 ③ (that is, it assumes that
    we won’t make any swaps). It also sets `pos` to 1 to start the sort with the first
    number.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨这个过程。由于我们还没有进行任何排序，它将`done`设置为0 ①。外层循环使用**repeat until**块遍历列表，直到它被排序（也就是说，直到`done`变为1）②。在每次遍历开始时，这个循环将`done`设置为1
    ③（即假设我们不会进行任何交换）。它还将`pos`设置为1，从第一个数字开始排序。
- en: The inner loop then compares each pair of elements in the list. The loop needs
    to perform *N* – 1 comparisons ④, where *N* is the number of items in the list.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 内层循环然后比较列表中每对元素。循环需要执行*N* - 1次比较④，其中*N*是列表中项的数量。
- en: If the item at index `pos+1` is greater than the item at `pos` ⑤, the two need
    to be swapped. Otherwise, the procedure adds 1 to `pos` so it can compare the
    next pair of items. If we do need to swap, this procedure does so with the aid
    of a temporary variable named `temp` ⑥.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`pos+1`索引处的项大于`pos`处的项⑤，则需要交换这两个项。否则，过程会将`pos`加1，以便比较下一对项。如果我们确实需要交换，过程将借助名为`temp`的临时变量进行交换⑥。
- en: Once the current pass through the list ends, the inner loop sets `done` back
    to 0 if it swapped numbers or leaves `done=1` if it made no changes ⑦. The outer
    loop will continue until the list is sorted.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当前遍历结束后，如果内层循环交换了数字，它会将`done`重新设置为0；如果没有做出任何更改，则`done`保持为1 ⑦。外层循环将继续，直到列表被排序。
- en: '![The BubbleSort procedure](httpatomoreillycomsourcenostarchimages2135023.png.jpg)Figure 9-24. The
    BubbleSort procedureTry It Out 9-7'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![冒泡排序过程](httpatomoreillycomsourcenostarchimages2135023.png.jpg)图9-24. 冒泡排序过程
    尝试 9-7'
- en: Make a list of names instead of numbers and use the bubble sort script to put
    the list in order. Does the sort still work as it should? Also, what changes do
    you need to make to the procedure to make it sort in ascending order?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 制作一个包含名字的列表，而不是数字，并使用冒泡排序脚本将列表按顺序排列。排序是否仍然能按预期工作？另外，为了使它按升序排序，你需要对过程做出什么更改？
- en: Finding the Median
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找中位数
- en: '*Median.sb2*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*Median.sb2*'
- en: 'Now that we know how to sort a list, we can easily find the median value of
    any sequence of numbers. Recall that the median is the middle value in a sorted
    set of numbers. If we have an odd number of items, we can just take the middle
    number. If we have an even number, the median is the average of the two middle
    numbers. We can describe the median for a sorted list of *N* items as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何对列表进行排序，我们可以轻松找到任何数字序列的中位数值。回忆一下，中位数是排序数字集合中的中间值。如果我们有奇数个项，我们可以直接取中间的数字。如果有偶数个项，则中位数是两个中间数字的平均值。我们可以描述一个排序列表中*N*项的中位数如下：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2135025.png.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages2135025.png.jpg)'
- en: A procedure that performs this calculation is shown in [Figure 9-25](ch09.html#finding_the_median_value_of_a_sorted_lis
    "Figure 9-25. Finding the median value of a sorted list of numbers"). It assumes
    the list is in order.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此计算的过程如[图 9-25](ch09.html#finding_the_median_value_of_a_sorted_lis "图 9-25：寻找排序数字列表的中位数")所示。它假设列表已按顺序排列。
- en: '![Finding the median value of a sorted list of numbers](httpatomoreillycomsourcenostarchimages2135027.png.jpg)Figure 9-25. Finding
    the median value of a sorted list of numbers'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![寻找排序数字列表的中位数](httpatomoreillycomsourcenostarchimages2135027.png.jpg)图 9-25：寻找排序数字列表的中位数'
- en: The procedure uses an **if/else** block to handle the two cases of even and
    odd lists. If the number of items in the list divides by 2 with no remainder (that
    is, the list has an even number of items) ①, the `median` variable is calculated
    as the average of the middle two numbers ②. Otherwise, the list has an odd number
    of items ③, and the `median` variable is set equal to the number in the middle
    of the list ④.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程使用 **if/else** 块来处理偶数和奇数列表的两种情况。如果列表中的项数能够被 2 整除且没有余数（即列表包含偶数个项）①，则 `median`
    变量计算为中间两个数字的平均值 ②。否则，列表包含奇数个项 ③，`median` 变量被设置为列表中间的数字 ④。
- en: We’ve covered a lot of ground so far, so it’s time to apply our newfound knowledge
    to something more challenging. The rest of this chapter walks through several
    examples that demonstrate how to use lists in more complex applications.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了很多内容，是时候将我们新学到的知识应用到更具挑战性的任务中。本章的其余部分将通过几个示例，展示如何在更复杂的应用中使用列表。
- en: Scratch Projects
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scratch 项目
- en: In this section, you’ll explore practical Scratch projects that highlight different
    aspects of lists. I’ll also introduce some new ideas and techniques that you can
    use in your own creations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将探索一些实用的 Scratch 项目，突出展示列表的不同方面。我还将介绍一些新的创意和技术，您可以在自己的创作中使用它们。
- en: The Poet
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 诗人
- en: Let’s kick off this chapter’s projects with a poem generator. Our artificial
    poet selects words randomly from five lists (`article`, `adjective`, `noun`, `verb`,
    and `preposition`) and combines them according to a fixed pattern. To give our
    poems a central theme, all the words in these lists are somehow related to love
    and nature. (Of course, we might still end up with some silly poetry, but that’s
    just as fun!)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从本章的项目开始，首先是一个诗歌生成器。我们的人工诗人从五个列表（`article`、`adjective`、`noun`、`verb` 和 `preposition`）中随机选择单词，并根据固定模式将它们组合起来。为了给我们的诗歌一个中心主题，所有列表中的单词都与爱情和自然有某种关联。（当然，我们可能仍然会写出一些傻乎乎的诗歌，但那也很有趣！）
- en: '*Poet.sb2*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*Poet.sb2*'
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The idea of this program is adapted from Daniel Watt’s* Learning with Logo
    *(McGraw-Hill, 1983). You’ll find the full word lists we’re using in the Scratch
    file for this project,* Poet.sb2*.*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*该程序的思想改编自 Daniel Watt 的* 《Logo 学习》 *(McGraw-Hill，1983年)。您可以在该项目的 Scratch 文件中找到我们使用的完整单词列表，*Poet.sb2*。*'
- en: 'Each poem is composed of three lines that follow these patterns:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每首诗由三行组成，遵循以下模式：
- en: 'Line 1: article, adjective, noun'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 1 行：冠词，形容词，名词
- en: 'Line 2: article, noun, verb, preposition, article, adjective, noun'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 2 行：冠词，名词，动词，介词，冠词，形容词，名词
- en: 'Line 3: adjective, adjective, noun'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 3 行：形容词，形容词，名词
- en: With those constructions in mind, let’s look at the procedure that builds the
    first line of the poem, shown in [Figure 9-26](ch09.html#quotation_markwritingquotation_mark_the
    "Figure 9-26. “Writing” the first line of a poem").
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这些构造后，我们来看看构建诗歌第一行的过程，如[图 9-26](ch09.html#quotation_markwritingquotation_mark_the
    "图 9-26：编写诗歌的第一行")所示。
- en: '![“Writing” the first line of a poem](httpatomoreillycomsourcenostarchimages2135029.png.jpg)Figure 9-26. “Writing”
    the first line of a poem'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![编写诗歌的第一行](httpatomoreillycomsourcenostarchimages2135029.png.jpg)图 9-26：编写诗歌的第一行'
- en: This script selects a random word from the `article` list and stores it in `line1`.
    Then the script appends a white space, a random word from the `adjective` list,
    another white space, and a random word from the `noun` list. Finally, the poet
    sprite says the complete line. I don’t show the procedures for the other two lines
    of the poem here because they’re very similar, but you can open up *Poet.sb2*
    to view them.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本从 `article` 列表中选择一个随机单词并存储在 `line1` 中。然后，脚本添加一个空格，一个随机的 `adjective` 列表中的单词，另一个空格，以及一个随机的
    `noun` 列表中的单词。最后，诗人精灵说出完整的一行。我没有展示诗歌的其他两行的过程，因为它们非常相似，但你可以打开 *Poet.sb2* 来查看它们。
- en: 'Here are two poems created by our machine poet:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的机器诗人创作的两首诗：
- en: each glamorous road
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每条迷人的道路
- en: a fish moves behind each white home
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每条白色房屋后面都有一条鱼在游动
- en: calm blue pond
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宁静的蓝色池塘
- en: every icy drop
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一滴冰冷的水珠
- en: a heart stares under every scary gate
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每扇可怕的门下都有一颗心在注视
- en: shy quiet queen
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 害羞安静的女王
- en: Try It Out 9-8
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 试试看 9-8
- en: Open *Poet.sb2* and run it several times to see what this machine poet is capable
    of authoring. Then change the program so that it uses three sprites, with each
    sprite responsible for one line of the poem, allowing you to read the whole poem
    on the Stage at once.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 *Poet.sb2* 并运行几次，看看这个机器诗人能创作出什么。然后修改程序，使其使用三个精灵，每个精灵负责诗歌的一行，允许你一次性在舞台上阅读整首诗。
- en: '*Poet.sb2*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*Poet.sb2*'
- en: Quadrilateral Classification Game
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 四边形分类游戏
- en: Our next project is a simple game that will help you explore different kinds
    of quadrilaterals. The game shows one of six shapes (parallelogram, rhombus, rectangle,
    square, trapezoid, or kite) on the Stage and asks the player to classify that
    shape by clicking the correct button, as illustrated in [Figure 9-27](ch09.html#user_interface_for_the_quadrilateral_cla
    "Figure 9-27. The user interface for the quadrilateral classification game").
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个项目是一个简单的游戏，帮助你探索不同种类的四边形。游戏会在舞台上显示六种形状之一（平行四边形、菱形、矩形、正方形、梯形或风筝形），并要求玩家通过点击正确的按钮来分类该形状，如[图
    9-27](ch09.html#user_interface_for_the_quadrilateral_cla "图 9-27. 四边形分类游戏的用户界面")所示。
- en: '*QuadClassify.sb2*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*QuadClassify.sb2*'
- en: '![The user interface for the quadrilateral classification game](httpatomoreillycomsourcenostarchimages2135031.png.jpg)Figure 9-27. The
    user interface for the quadrilateral classification game'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![四边形分类游戏的用户界面](httpatomoreillycomsourcenostarchimages2135031.png.jpg)图 9-27.
    四边形分类游戏的用户界面'
- en: 'The game contains seven sprites: six for the answer buttons and a seventh (named
    `Driver`) that contains the main script. As shown in [Figure 9-27](ch09.html#user_interface_for_the_quadrilateral_cla
    "Figure 9-27. The user interface for the quadrilateral classification game"),
    the `Driver` sprite has six costumes that correspond to the six quadrilaterals
    in the game. When the green flag icon is clicked, the `Driver` sprite executes
    the script shown in [Figure 9-28](ch09.html#main_script_of_the_driver_sprite "Figure 9-28. The
    main script of the Driver sprite") to start the game.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏包含七个精灵：六个用于答案按钮，另一个（名为 `Driver`）包含主脚本。如[图 9-27](ch09.html#user_interface_for_the_quadrilateral_cla
    "图 9-27. 四边形分类游戏的用户界面")所示，`Driver` 精灵有六种服装，分别对应游戏中的六种四边形。当点击绿色旗帜图标时，`Driver` 精灵执行[图
    9-28](ch09.html#main_script_of_the_driver_sprite "图 9-28. Driver 精灵的主脚本")所示的脚本以开始游戏。
- en: First, the `Driver` sprite moves to the top drawing layer ① so that no buttons
    will obscure it. In the main loop of the game ②, the script shows a random quadrilateral
    on each pass with **ShowShape** ③. After showing the quadrilateral, the script
    sets the global variable `choice` to 0 to indicate that the user hasn’t answered
    yet ④.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`Driver` 精灵移动到顶部绘图层 ①，确保没有按钮遮挡它。在游戏的主循环中 ②，脚本每次循环时使用 **ShowShape** 显示一个随机的四边形
    ③。显示四边形后，脚本将全局变量 `choice` 设置为 0，表示用户尚未作答 ④。
- en: '![The main script of the Driver sprite](httpatomoreillycomsourcenostarchimages2135033.png.jpg)Figure 9-28. The
    main script of the `Driver` sprite'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![Driver 精灵的主脚本](httpatomoreillycomsourcenostarchimages2135033.png.jpg)图 9-28.
    `Driver` 精灵的主脚本'
- en: The script then waits ⑤ until `choice` changes to a nonzero number, which will
    happen when the player clicks one of the six answer buttons. When the player guesses
    a shape, the script calls **CheckAnswer** ⑥ to tell the player whether or not
    that answer was correct.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，脚本会等待 ⑤，直到 `choice` 变为非零数值，这将在玩家点击六个答案按钮中的一个时发生。当玩家猜测出一个形状时，脚本调用 **CheckAnswer**
    ⑥ 来告诉玩家该答案是否正确。
- en: Now that you know how the main script works, let’s look at the **ShowShape**
    procedure, shown in [Figure 9-29](ch09.html#showshape_procedure_of_the_driver_sprite
    "Figure 9-29. The ShowShape procedure of the Driver sprite").
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了主脚本是如何工作的，接下来我们来看看 **ShowShape** 过程，如[图 9-29](ch09.html#showshape_procedure_of_the_driver_sprite
    "图 9-29. Driver 精灵的 ShowShape 过程")所示。
- en: First, **ShowShape** moves the `Driver` sprite to the center of the stage and
    points it in a random direction ①. It assigns the `shape` variable a random value
    from 1 through 6 and switches the sprite’s costume ② to show a quadrilateral for
    the player to identify.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，**ShowShape** 将 `Driver` 精灵移动到舞台中心并随机指向一个方向 ①。它将 `shape` 变量赋值为 1 到 6 之间的随机值，并切换精灵的服装
    ②，展示一个四边形供玩家识别。
- en: '![The ShowShape procedure of the Driver sprite](httpatomoreillycomsourcenostarchimages2135035.png.jpg)Figure 9-29. The
    ShowShape procedure of the `Driver` sprite'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![Driver精灵的ShowShape过程](httpatomoreillycomsourcenostarchimages2135035.png.jpg)图9-29.
    `Driver`精灵的ShowShape过程'
- en: To keep the background’s grid visible, **ShowShape** sets the transparency level
    ③ to a random value between 25 and 50\. To give the illusion that it is coming
    up with a new shape every round, the procedure also sets the color effect to a
    random value to change the color of the costume ④ and resizes the sprite to 80%,
    90%, ..., or 150% of its original size ⑤.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持背景网格的可见性，**ShowShape**将透明度③设置为25到50之间的随机值。为了给人一种每回合都会出现新形状的错觉，该过程还将颜色效果设置为随机值，以改变服装④的颜色，并将精灵的大小调整为原始大小的80%、90%......或150%⑤。
- en: Next, we’ll look briefly at the scripts for the six button sprites, shown in
    [Figure 9-30](ch09.html#scripts_for_the_button_sprites "Figure 9-30. Scripts for
    the button sprites"). They’re identical except for the value assigned to the `choice`
    variable.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们简要查看六个按钮精灵的脚本，如[图9-30](ch09.html#scripts_for_the_button_sprites "图9-30.
    按钮精灵的脚本")所示。它们除了赋给 `choice` 变量的值不同外，其它完全相同。
- en: '![Scripts for the button sprites](httpatomoreillycomsourcenostarchimages2135037.png.jpg)Figure 9-30. Scripts
    for the button sprites'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![按钮精灵的脚本](httpatomoreillycomsourcenostarchimages2135037.png.jpg)图9-30. 按钮精灵的脚本'
- en: These one-line scripts each set the value of `choice` to a different number
    depending on which button the player presses. Once `choice` contains the player’s
    answer, the **CheckAnswer** procedure, illustrated in [Figure 9-31](ch09.html#checkanswer_procedure
    "Figure 9-31. The CheckAnswer procedure"), can compare it with the value of `shape`,
    which specifies the type of the drawn quadrilateral.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些单行脚本会根据玩家按下的按钮，将`choice`的值设置为不同的数字。一旦`choice`包含了玩家的答案，[**CheckAnswer**过程](ch09.html#checkanswer_procedure
    "图9-31. CheckAnswer过程")就可以将其与`shape`的值进行比较，`shape`指定了所绘制的四边形的类型。
- en: If `choice` and `shape` are equal, then the player’s answer is correct. Otherwise,
    the answer is wrong, and the sprite will say the right shape. **CheckAnswer**
    uses the `shape` variable as an index to a list named `quadName`, which is also
    shown in [Figure 9-31](ch09.html#checkanswer_procedure "Figure 9-31. The CheckAnswer
    procedure"), to get the correct name of the displayed shape.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`choice`和`shape`相等，那么玩家的答案是正确的。否则，答案是错误的，精灵会说出正确的形状。**CheckAnswer**使用`shape`变量作为索引，查找一个名为`quadName`的列表（也见于[图9-31](ch09.html#checkanswer_procedure
    "图9-31. CheckAnswer过程")），以获取显示形状的正确名称。
- en: Try It Out 9-9
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试9-9
- en: Open *QuadClassify.sb2* and run it several times to understand how it works.
    As written, this game runs forever. Modify the program to add a game-end criterion.
    Also, keep track of the number of the player’s correct and incorrect answers.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 *QuadClassify.sb2* 并运行几次，了解它的工作原理。按原样，这个游戏会一直运行下去。修改程序，添加游戏结束的标准。同时，跟踪玩家的正确和错误回答数量。
- en: '*QuadClassify.sb2*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*QuadClassify.sb2*'
- en: '![The CheckAnswer procedure](httpatomoreillycomsourcenostarchimages2135039.png.jpg)Figure 9-31. The
    CheckAnswer procedure'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![CheckAnswer过程](httpatomoreillycomsourcenostarchimages2135039.png.jpg)图9-31.
    CheckAnswer过程'
- en: Math Wizard
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学小 wizard
- en: This application demonstrates two ways to make lists even more useful. We’ll
    explore how to use lists to store nonuniform records (that is, records with different
    sizes) as well as how to use one list as an index to another. A *record* is just
    a collection of related data about a person, place, or thing. In our case, each
    record consists of a puzzle’s answer along with the instructions for that puzzle.
    Whereas each puzzle has a single answer, the number of instructions varies from
    one puzzle to another.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用展示了两种使列表更有用的方法。我们将探讨如何使用列表来存储非统一的记录（即记录大小不同的情况），以及如何使用一个列表作为另一个列表的索引。*记录*就是关于一个人、地点或事物的相关数据集合。在我们的例子中，每个记录包含一个谜题的答案和该谜题的说明。虽然每个谜题只有一个答案，但每个谜题的说明数量不相同。
- en: '*MathWizard.sb2*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*MathWizard.sb2*'
- en: Our math wizard asks the user to think of a “secret” number and perform a sequence
    of mathematical operations on it (double the number, subtract 2, divide the answer
    by 10, and so on). At the end, after the player performs all these calculations,
    the wizard uses magical powers to tell the user what number he has, even though
    the wizard does not know the user’s initial number. [Table 9-2](ch09.html#how_the_math_wizard_works
    "Table 9-2. How the Math Wizard Works") illustrates how the game works.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数学魔法师要求用户想一个“秘密”数字，并对其执行一系列数学操作（例如，数字翻倍、减去 2、将结果除以 10，依此类推）。最后，在玩家完成所有这些计算后，魔法师凭借魔法力量告诉用户他得到了什么数字，即使魔法师并不知道用户最初的数字。[表
    9-2](ch09.html#how_the_math_wizard_works "表 9-2. 数学魔法师的工作原理") 说明了游戏的工作原理。
- en: Table 9-2. How the Math Wizard Works
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-2. 数学魔法师的工作原理
- en: '| Wizard’s Instruction | Your Number |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 魔法师的指令 | 你的数字 |'
- en: '| --- | --- |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Think of a number. | 2 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 想一个数字。 | 2 |'
- en: '| Add 5. | 7 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 加 5。 | 7 |'
- en: '| Multiply by 3. | 21 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 乘以 3。 | 21 |'
- en: '| Subtract 3. | 18 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 减去 3。 | 18 |'
- en: '| Divide by 3. | 6 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 除以 3。 | 6 |'
- en: '| Subtract your original number. | 4 |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 减去你最初的数字。 | 4 |'
- en: After the last instruction, the wizard will tell you that following the instructions
    has given you the number 4, even though the game doesn’t know that you started
    out with 2\. Try this puzzle with different numbers to figure out the wizard’s
    trick!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一条指令后，魔法师会告诉你，按照这些指令你得到了数字 4，尽管游戏并不知道你最初是从 2 开始的。试着用不同的数字来做这个谜题，弄清楚魔法师的诡计！
- en: The interface of the application is shown in [Figure 9-32](ch09.html#user_interface_for_the_math_wizard_appli
    "Figure 9-32. The user interface for the Math Wizard application").
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的界面如 [图 9-32](ch09.html#user_interface_for_the_math_wizard_appli "图 9-32.
    数学魔法师应用程序的用户界面") 所示。
- en: '![The user interface for the Math Wizard application](httpatomoreillycomsourcenostarchimages2135041.png.jpg)Figure 9-32. The
    user interface for the Math Wizard application'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![数学魔法师应用程序的用户界面](httpatomoreillycomsourcenostarchimages2135041.png.jpg)图 9-32.
    数学魔法师应用程序的用户界面'
- en: 'The application contains three sprites: the `Wizard` sprite, which gives the
    instructions to the player, and the `OK` and `New` sprites, for the `OK` and `New
    Game` buttons, respectively. It also uses the two lists illustrated in [Figure 9-33](ch09.html#two_lists_used_by_the_wizard_sprite
    "Figure 9-33. The two lists used by the Wizard sprite").'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序包含三个精灵：`Wizard` 精灵，它给玩家提供指令；`OK` 和 `New` 精灵，分别对应“确定”和“新游戏”按钮。它还使用了 [图 9-33](ch09.html#two_lists_used_by_the_wizard_sprite
    "图 9-33. Wizard 精灵使用的两个列表") 中说明的两个列表。
- en: '![The two lists used by the Wizard sprite](httpatomoreillycomsourcenostarchimages2135043.png.jpg)Figure 9-33. The
    two lists used by the `Wizard` sprite'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![Wizard 精灵使用的两个列表](httpatomoreillycomsourcenostarchimages2135043.png.jpg)图
    9-33. Wizard 精灵使用的两个列表'
- en: 'The `instr` list (right) contains 11 puzzle records. Each record includes (a)
    the answer of the puzzle, (b) the instructions, and (c) an empty element to mark
    the end of that record. The entries in the list on the left (named `index`) identify
    the starting index of each puzzle in the `instr` list. For example, the second
    element in the `index` list is 9, which means the record of the second puzzle
    starts at the ninth position in the `instr` list, as illustrated in [Figure 9-33](ch09.html#two_lists_used_by_the_wizard_sprite
    "Figure 9-33. The two lists used by the Wizard sprite"). Let’s outline a strategy
    for developing this game:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`instr` 列表（右侧）包含 11 条谜题记录。每条记录包括：（a）谜题的答案，（b）指令，（c）一个空元素，用于标记该记录的结束。左侧的列表项（名为
    `index`）标识 `instr` 列表中每个谜题的起始索引。例如，`index` 列表中的第二个元素是 9，这意味着第二个谜题的记录从 `instr`
    列表中的第九个位置开始，如 [图 9-33](ch09.html#two_lists_used_by_the_wizard_sprite "图 9-33.
    Wizard 精灵使用的两个列表") 中所示。我们来概述一个开发该游戏的策略：'
- en: When the user starts a new game, select a random number between 1 and 11 (because
    our game currently contains 11 puzzles).
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户开始新游戏时，选择一个 1 到 11 之间的随机数字（因为我们的游戏当前包含 11 个谜题）。
- en: Consult the `index` list for the starting position of the selected puzzle’s
    record. For example, if the second puzzle is selected, the `index` list tells
    us that the record of this puzzle starts at index 9 in the `instr` list.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查阅 `index` 列表，找到所选谜题记录的起始位置。例如，如果选择第二个谜题，`index` 列表会告诉我们该谜题的记录从 `instr` 列表中的第
    9 个索引位置开始。
- en: Access the `instr` list at the index found in Step 2\. The first element at
    that index is interpreted as the answer of the puzzle. The following elements
    represent the instructions that the wizard will say.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问步骤2中找到的索引位置上的`instr`列表。该索引位置的第一个元素被解释为谜题的答案。接下来的元素代表巫师将要说的指令。
- en: Let the wizard say the puzzle instructions one by one until encountering the
    empty element, which signifies the last instruction. The wizard should wait for
    the user to press the `OK` button before saying a new instruction.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让巫师逐一说出谜题指令，直到遇到空元素，空元素标志着最后一条指令。在说出新指令之前，巫师应该等待用户按下`OK`按钮。
- en: Reveal the answer of the puzzle.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 揭示谜题的答案。
- en: Now that we know how the game should work on a high level, let’s look at the
    scripts for the two buttons, shown in [Figure 9-34](ch09.html#scripts_for_the_two_button_sprites
    "Figure 9-34. The scripts for the two button sprites").
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了游戏的高级工作方式，让我们来看一下[图 9-34](ch09.html#scripts_for_the_two_button_sprites
    "图 9-34. 两个按钮角色的脚本")中显示的两个按钮的脚本。
- en: '![The scripts for the two button sprites](httpatomoreillycomsourcenostarchimages2135045.png.jpg)Figure 9-34. The
    scripts for the two button sprites'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![两个按钮角色的脚本](httpatomoreillycomsourcenostarchimages2135045.png.jpg)图 9-34.
    两个按钮角色的脚本'
- en: The `New Game` button broadcasts the `NewGame` message when clicked. When the
    `OK` button is clicked in response to an instruction, the sprite sets `clicked`
    to 1 to inform the `Wizard` sprite that the player is done with the instruction
    she was asked to perform. When the `Wizard` sprite receives the `NewGame` message,
    it executes the script shown in [Figure 9-35](ch09.html#newgame_script_of_the_wizard_sprite
    "Figure 9-35. The NewGame script of the Wizard sprite").
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`New Game`按钮在点击时广播`NewGame`消息。当用户点击“OK”按钮以响应某个指令时，角色将`clicked`设置为1，通知`Wizard`角色玩家已经完成了她被要求执行的指令。当`Wizard`角色收到`NewGame`消息时，它会执行[图
    9-35](ch09.html#newgame_script_of_the_wizard_sprite "图 9-35. `Wizard`角色的`NewGame`脚本")中显示的脚本。'
- en: '![The NewGame script of the Wizard sprite](httpatomoreillycomsourcenostarchimages2135047.png.jpg)Figure 9-35. The
    `NewGame` script of the `Wizard` sprite'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![巫师角色的`NewGame`脚本](httpatomoreillycomsourcenostarchimages2135047.png.jpg)图
    9-35. `NewGame`脚本的`Wizard`角色'
- en: NewGame starts by clearing the speech bubble from the previous puzzle (if any)
    and initializing the `clicked` variable to 0 ①. It then saves the number of the
    randomly selected puzzle in a variable called `puzzleNum` ②. After that, it reads
    the starting position of the selected puzzle from the `index` list and saves it
    in the `pos` variable ③. The script then uses `pos` to read the answer of that
    puzzle and saves it in `puzzleAnswer` ④. Next, the script adds 1 to `pos` so it
    points to the first puzzle instruction, and it starts a **repeat until** loop
    to say the puzzle’s instructions in order ⑤. After saying each instruction, the
    script waits for the `clicked` variable to be set to 1 before moving to the next
    instruction ⑥. When the loop finds an empty element, it exits, and the script
    says the puzzle’s answer ⑦.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewGame`通过清除前一个谜题的对话框（如果有的话）并将`clicked`变量初始化为0①开始。然后，它将随机选择的谜题的编号保存在名为`puzzleNum`的变量中②。之后，它从`index`列表中读取所选谜题的起始位置，并将其保存在`pos`变量中③。脚本随后使用`pos`读取该谜题的答案并将其保存在`puzzleAnswer`中④。接下来，脚本将1加到`pos`，使其指向第一个谜题指令，并开始一个**repeat
    until**循环，按顺序说出谜题的指令⑤。每说完一个指令，脚本会等待`clicked`变量被设置为1，然后再移动到下一个指令⑥。当循环发现空元素时，它会退出，并且脚本会说出谜题的答案⑦。'
- en: Try It Out 9-10
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 试试看 9-10
- en: If you delete one of the puzzles or change the number of instructions for some
    puzzles, then you would need to rebuild the `index` list to match up with the
    `instr` list. Write a procedure that automatically populates the `index` list
    based on the current contents of the `instr` list. The key is to search for the
    empty strings in the `instr` list, as these indicate the end of one record and
    the start of the next record.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你删除了其中一个谜题或更改了某些谜题的指令数量，那么你需要重新构建`index`列表，以与`instr`列表匹配。编写一个过程，根据`instr`列表的当前内容自动填充`index`列表。关键是要在`instr`列表中搜索空字符串，因为这些空字符串表示一条记录的结束和下一条记录的开始。
- en: Flower Anatomy Quiz
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 花卉解剖学测验
- en: In this section, I’ll use a quiz on the parts of a flower to demonstrate how
    to build simple quizzes in Scratch. [Figure 9-36](ch09.html#user_interface_for_the_flower_quiz
    "Figure 9-36. The user interface for the flower quiz") shows our example application’s
    interface at the beginning of the quiz and after the program checks the user’s
    answers. Anyone taking the quiz will enter the letters to match the labeled parts
    of the flower and then click the `Check` button to check the answers. The program
    compares the user’s answers with the correct ones and provides feedback using
    the green check mark and the red *X* icons next to each answer.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将通过一个关于花朵各部分的测验，演示如何在Scratch中构建简单的测验。[图9-36](ch09.html#user_interface_for_the_flower_quiz
    "图9-36. 花朵测验的用户界面")展示了我们示例应用程序的界面，包括测验开始时和程序检查用户答案后的界面。任何参加测验的人都会输入字母来匹配花朵各部分的标签，然后点击`Check`按钮来检查答案。程序将用户的答案与正确答案进行比较，并通过绿色的勾号和红色的*X*图标为每个答案提供反馈。
- en: '*FlowerAnatomy.sb2*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*FlowerAnatomy.sb2*'
- en: '![The user interface for the flower quiz](httpatomoreillycomsourcenostarchimages2135049.png.jpg)Figure 9-36. The
    user interface for the flower quiz'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![花朵测验的用户界面](httpatomoreillycomsourcenostarchimages2135049.png.jpg)图9-36. 花朵测验的用户界面'
- en: This quiz uses three lists. The first (named `correctAns`) contains the letters
    that correspond to the right answers for the nine parts of the quiz. The second
    list (named `ans`) contains the user’s input, and the third list (named `cellYCenter`)
    contains the 11 vertical positions used by the `Letter` and the `YesNo` sprites
    (so they know where they should stamp their costumes). When the user clicks the
    mouse over any of the answer boxes, the Stage sprite detects the mouse click and
    asks for an answer. The Stage sprite updates the corresponding element of the
    `ans` list to match what the user entered and stamps that letter over the answer
    box. Open *FlowerAnatomy.sb2* to read the scripts that read and display the user’s
    answers.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测验使用了三个列表。第一个列表（命名为`correctAns`）包含了对应于测验九个部分正确答案的字母。第二个列表（命名为`ans`）包含用户的输入，第三个列表（命名为`cellYCenter`）包含了`Letter`和`YesNo`精灵使用的11个垂直位置（以便它们知道应该在哪里盖上它们的服装）。当用户在任何答题框上点击鼠标时，舞台精灵会检测到鼠标点击并请求一个答案。舞台精灵会更新`ans`列表中对应的元素，以匹配用户输入的内容，并将该字母印在答题框上。打开*FlowerAnatomy.sb2*以查看读取和显示用户答案的脚本。
- en: When the user clicks the `Check` button, the `YesNo` sprite, which has the costumes
    for the check mark and *X* images, executes the script shown in [Figure 9-37](ch09.html#check_procedure_of_the_yesno_sprite
    "Figure 9-37. The Check procedure of the YesNo sprite").
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击`Check`按钮时，`YesNo`精灵（它包含勾号和*X*图像的服装）执行[图9-37](ch09.html#check_procedure_of_the_yesno_sprite
    "图9-37. YesNo精灵的检查过程")中显示的脚本。
- en: '![The Check procedure of the YesNo sprite](httpatomoreillycomsourcenostarchimages2135051.png.jpg)Figure 9-37. The
    Check procedure of the `YesNo` sprite'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![YesNo精灵的检查过程](httpatomoreillycomsourcenostarchimages2135051.png.jpg)图9-37.
    `YesNo`精灵的检查过程'
- en: The script compares the elements of the `correctAns` and the `ans` lists one
    by one. If the two values are equal, it stamps a check mark to say the user was
    correct. Otherwise, it stamps the red *X* where the user’s answers were wrong.
    Either way, `Check` consults the `cellYCenter` list to get the correct position
    for stamping the image. See Try It Out 9-11 on the opposite page.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本逐一比较`correctAns`和`ans`列表中的元素。如果两个值相等，它会打上勾，表示用户回答正确。否则，它会在用户答错的地方打上红色的*X*。无论哪种情况，`Check`都会查阅`cellYCenter`列表，获取打上图像的正确位置。请参阅对面页面的尝试一下
    9-11。
- en: Other Applications
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他应用
- en: The extra resources you downloaded from the book’s website (*[http://nostarch.com/learnscratch/](http://nostarch.com/learnscratch/)*)
    contain three more applications that you can explore on your own, with full explanations.
    The first application is a two-player game about sorting fractions and decimals.
    Each player gets 5 random cards from a deck of 31 cards. Each player is then dealt
    one card from the remaining set. You can either discard the new card or drag it
    over one of your current five, replacing the old one. Whoever arranges five cards
    in ascending order first wins the game.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你从本书网站下载的额外资源（*[http://nostarch.com/learnscratch/](http://nostarch.com/learnscratch/)）包含了三个应用程序，你可以自行探索，每个应用都有完整的解释。第一个应用是一个关于排序分数和小数的两人游戏。每位玩家从31张卡牌中随机抽取5张。然后每位玩家从剩下的卡组中抽取一张卡片。你可以选择丢弃这张新卡，或者将它拖到你当前的五张卡片之一，替换掉旧的那张。第一个将五张卡片按升序排列的人赢得游戏。
- en: '*SayThat Number.sb2*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*SayThat Number.sb2*'
- en: Try It Out 9-11
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下 9-11
- en: Open this application and test it. Then, think of other quizzes in different
    subject areas that you can create and implement them. One example, shown below,
    is provided in the file *USMapQuiz.sb2*. Open this file and complete the missing
    parts to make this quiz work.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 打开这个应用程序并测试它。然后，考虑你可以创建并实现的其他不同学科领域的测验。以下是一个示例，展示在文件*USMapQuiz.sb2*中。打开这个文件并完成缺失的部分，使这个测验正常工作。
- en: '*USMapQuiz.sb2*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*USMapQuiz.sb2*'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2135053.png.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![无标题图片](httpatomoreillycomsourcenostarchimages2135053.png.jpg)'
- en: The second application is a program that spells whole numbers. It prompts the
    user to input a number and then says that number in words. If the user inputs
    `3526`, for example, the program will say “three thousand five hundred twenty
    six.” The idea is to break the number, from right to left, into groups of three
    digits. Each group is then spelled out with a multiplier word (thousand, million,
    and so on), if needed.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个应用程序是一个拼写整数的程序。它提示用户输入一个数字，然后用单词拼出这个数字。例如，如果用户输入`3526`，程序将说“three thousand
    five hundred twenty six”。其思路是将数字从右到左分解为三位一组，每组按需附加倍数词（千、百万等）。
- en: '*SortEmOut.sb2*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*SortEmOut.sb2*'
- en: The third program demonstrates the sieve of Eratosthenes, an algorithm for finding
    all prime numbers less than 100.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个程序展示了厄拉多斯筛法，这是一种查找小于100的所有质数的算法。
- en: '*Sieve.sb2*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*Sieve.sb2*'
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Lists are extremely useful in programming, and they provide a convenient way
    to store multiple elements. In this chapter, we explored creating lists in Scratch,
    learned the commands we can use to deal with them, and practiced populating lists
    dynamically with data entered by the user.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 列表在编程中非常有用，它们提供了一种方便的方式来存储多个元素。在这一章中，我们探索了在 Scratch 中创建列表，学习了可以用来处理它们的命令，并通过用户输入的数据动态地填充列表。
- en: We also examined numerical lists and demonstrated how to find the minimum, the
    maximum, and the average value of their elements. After that, we learned simple
    algorithms for searching and sorting lists. We concluded the chapter with several
    programs that demonstrated the use of lists in practical applications.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了数值列表，并演示了如何找到它们元素的最小值、最大值和平均值。之后，我们学习了简单的算法来搜索和排序列表。我们通过几个程序结束了这一章，展示了列表在实际应用中的使用。
- en: Problems
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: '| **Q:** | 1\. Create a list that contains the first 10 prime numbers. Write
    a script to display these numbers using the **say** block. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| **Q:** | 1\. 创建一个包含前10个质数的列表。编写一个脚本，使用**say**块显示这些数字。 |'
- en: '| **Q:** | 2\. Create three lists to store personal records. The first list
    stores names, the second list stores birth dates, and the third list stores phone
    numbers. Write a program that asks the user the name of the person whose contact
    information is needed. If the person’s name exists in the first list, the program
    will say the person’s birth date and phone number. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| **Q:** | 2\. 创建三个列表来存储个人记录。第一个列表存储姓名，第二个列表存储出生日期，第三个列表存储电话号码。编写一个程序，询问用户需要某个人的联系信息。如果此人的姓名存在于第一个列表中，程序将显示该人的出生日期和电话号码。
    |'
- en: '| **Q:** | 3\. Create two lists for storing the items sold in a grocery store
    and their corresponding prices. Write a program that asks the user to enter an
    item’s name and then displays that item’s price, if it is found in the list. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| **Q:** | 3\. 创建两个列表，用于存储在杂货店出售的商品及其对应的价格。编写一个程序，提示用户输入商品名称，然后显示该商品的价格，如果它在列表中找到的话。
    |'
- en: '| **Q:** | 4\. What is stored in `numList` after executing the script shown
    on the next page? Re-create the procedure and run it to check your answer.![image
    with no caption](httpatomoreillycomsourcenostarchimages2135055.png.jpg) |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| **Q:** | 4\. 执行下一页显示的脚本后，`numList`中存储了什么？重新创建该过程并运行，以检查你的答案。![无标题图片](httpatomoreillycomsourcenostarchimages2135055.png.jpg)
    |'
- en: '| **Q:** | 5\. Write a program to double each of the elements stored in a numerical
    list. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| **Q:** | 5\. 编写一个程序，将存储在数值列表中的每个元素翻倍。 |'
- en: '| **Q:** | 6\. Write a program that prompts the user to enter students’ names
    and scores and store these inputs in two lists. Stop collecting data when the
    user enters –1 for a student’s name. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| **Q:** | 6\. 编写一个程序，提示用户输入学生的姓名和成绩，并将这些输入存储在两个列表中。当用户输入 -1 作为学生的姓名时，停止收集数据。
    |'
- en: '| **Q:** | 7\. Write a program that prompts the user to enter the highest and
    lowest temperatures for the 12 months of a year. Store the input values in two
    lists. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| **Q:** | 7\. 编写一个程序，提示用户输入一年的12个月的最高和最低温度。将输入的值存储在两个列表中。 |'
- en: '| **Q:** | 8\. Write a program that prompts the user to enter 10 integers.
    Store each entered number into a list only if it is not a duplicate of a previously
    entered number. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| **Q:** | 8\. 编写一个程序，提示用户输入10个整数。只有当输入的数字不是之前已输入的重复数字时，才将其存入列表中。 |'
- en: '| **Q:** | 9\. Write a program that processes a list of 20 scores on a test
    with 100 items and finds the number of students who scored between 85 and 90.
    |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| **Q:** | 9\. 编写一个程序，处理包含100项的测试的20个分数，并找出得分在85到90之间的学生人数。 |'
