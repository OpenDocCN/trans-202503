<html><head></head><body>
<h2 class="h2"><span epub:type="pagebreak" id="page_274"/><span epub:type="pagebreak" id="page_275"/><span class="big">10</span><br/>TRAC: THE RACKET ALGEBRAIC CALCULATOR</h2>&#13;
<div class="image1"><img alt="Image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">Racket provides an ecosystem for language-oriented programming. It has extensive built-in capabilities to construct macros, lexers, and parser generators. In this final chapter, we unfortunately won’t have time to explore all of these enticing topics. However, we’ll explore a number of new topics in computer science and utilize many of the topics introduced in previous chapters (and especially leverage a number of the computing machine concepts introduced in the previous chapter).</p>&#13;
<p class="indent">In the process, we’ll build a command line program called TRAC (The Racket Algebraic Calculator), which will take a string of characters representing an algebraic expression and compute its value. TRAC is, in fact, a stripped-down version of a programming language. If desired, it can be extended in a number of ways to implement a full-fledged programming language.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_276"/>This program will be able accommodate a dialog such as the following:</p>&#13;
<pre>&gt; <span class="codestrong1">let x = 0.8</span>&#13;
&gt; <span class="codestrong1">let y = 7</span>&#13;
&gt; <span class="codestrong1">(x + 1.2)*(7.7 / y)</span>&#13;
2.2</pre>&#13;
<h3 class="h3" id="ch00lev1sec_56">The TRAC Pipeline</h3>&#13;
<p class="noindent">To build TRAC, we’ll make use of the following pipeline, which processes the input in stages in order to compute the output.</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0276-01.jpg"/></div>&#13;
<p class="noindent">The lexer (or <em>lexical analyzer</em>) is responsible for taking the input string and breaking it into a list of tokens that can then be passed to the parser for further processing. Take the following string, for example:</p>&#13;
<pre>"(x + 1.2)*(7.7 / y)"</pre>&#13;
<p class="noindent">Given the above string, the lexical analyzer will return an output list similar to this:</p>&#13;
<pre>("(" "x" "+" 1.2 ")" "*" "(" 7.7 "/" "Y" ")" )</pre>&#13;
<p class="indent">Once we’ve produced the token list, we can pass it on to the parser. The job of the parser is to determine the structure of the input by building something called the <em>abstract syntax tree</em> (or <em>AST</em>). An AST is a description of the structure of an expression. Mathematical expressions such as the one just introduced have an inverted tree-like structure. The AST for our example expression is shown in <a href="ch10.xhtml#ch10fig1">Figure 10-1</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/10fig01.jpg"/></div>&#13;
<p class="figcap" id="ch10fig1"><em>Figure 10-1: AST for (<em>x</em> + 1.2)*(7.7 / <em>y</em>)</em></p>&#13;
<p class="indent">We can then pass the AST on to the <em>interpreter</em> to evaluate the expression and calculate the result. If we were building a full-blown computer language, the AST would be passed on to a compiler and optimizer, where it would be reduced to machine code for efficient execution. Strictly speaking, if the intent were to only build an interpreter, it wouldn’t be necessary to build an AST, since the parser could simply perform any required computations <span epub:type="pagebreak" id="page_277"/>on the fly, but we’ll see later that having the AST available will allow us to manipulate it to derive other useful results.</p>&#13;
<p class="indent">The processing pipeline (lexer, parser, interpreter), in addition to providing a clear separation of duties, allows us to plug in different modules optimized for specific tasks. For example, an interpreter works well for interactive computations but not so much for long running calculations. In such an instance, we’d want to substitute a compiler for the interpreter. This would permit our code to be converted to machine code and run at full speed by being executed directly by the CPU.</p>&#13;
<p class="indent">We’ll discuss and implement each of these components in turn, until we have a working algebraic calculator; then we’ll look at a few ways to improve TRAC.</p>&#13;
<h3 class="h3" id="ch00lev1sec_57">The Lexical Analyzer</h3>&#13;
<p class="noindent">In order to split the input into tokens, the lexical analyzer scans the input one character at a time looking for certain patterns. At a high level, a token is just some sequence of characters that can be categorized in a certain way. For example, a string of digits such a 19876 can be categorized as an integer token. Strings of characters that start with a letter and are followed by zero or more letters and digits (such as “AVG1” or “SIN") can be categorized as identifier tokens. Lexical analyzers typically ignore nonessential characters such as spaces and tabs (the language Python is a notable exception).</p>&#13;
<p class="indent">Each pattern can be represented by a finite-state machine, or FSM (see <a href="ch09.xhtml">Chapter 9</a>). One such FSM that we’ll use is a recognizer for unsigned integers. In the discussion that follows, certain sets of characters, when grouped together, are referred to as a <em>character class</em>. One such class we’ll need is the characters consisting of the digits from 0 to 9, which we simply designate as the <em>digit</em> class. An unsigned integer is exclusively composed of a string of digits from the digit class, so we can represent its recognizer by the following FSM shown in <a href="ch10.xhtml#ch10fig2">Figure 10-2</a>, where the digit class is represented by an uppercase italic <em>D</em>.</p>&#13;
<div class="image"><img alt="Image" src="../images/10fig02.jpg"/></div>&#13;
<p class="figcap" id="ch10fig2"><em>Figure 10-2: FSM to recognize digits</em></p>&#13;
<p class="indent">This diagram indicates that an unsigned integer always starts with a digit, and may be followed by any number of trailing digits. An alternative method for representing an unsigned integer is with a <em>syntax diagram</em>, such as the one given in <a href="ch10.xhtml#ch10fig3">Figure 10-3</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/10fig03.jpg"/></div>&#13;
<p class="figcap" id="ch10fig3"><em>Figure 10-3: Syntax diagram to recognize digits</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_278"/>In this case, the digit class is represented with a typewriter font like this: <span class="literal">digit</span>. A syntax diagram can sometimes provide a more intuitive representation of the pattern being recognized. The syntax diagram shows that, after accepting a digit, the analyzer can optionally loop back to accept another digit.</p>&#13;
<p class="indent">To be truly useful, TRAC will need to be able to recognize more than just integers. The following syntax diagram in <a href="ch10.xhtml#ch10fig4">Figure 10-4</a> illustrates a recognizer that will accept numbers that consist of unsigned integers, as well as floating-point numbers entered with a decimal point and numbers entered in scientific notation with an embedded <span class="literal">e</span>.</p>&#13;
<div class="image"><img alt="Image" src="../images/10fig04.jpg"/></div>&#13;
<p class="figcap" id="ch10fig4"><em>Figure 10-4: Syntax diagram to recognize numbers</em></p>&#13;
<p class="indent">Note that syntax diagrams can be nested: the boxes in <a href="ch10.xhtml#ch10fig4">Figure 10-4</a> encapsulate the recognizer from <a href="ch10.xhtml#ch10fig3">Figure 10-3</a>. We leave it as an exercise for the reader to construct the corresponding FSM.</p>&#13;
<p class="indent">In addition to recognizing numbers, TRAC recognizes identifiers (like <span class="literal">x</span> in <span class="literal">let x = 4</span>). TRAC identifiers always start with a letter, followed by any number of letters or digits. We’ll designate the letter class with an italic uppercase <em>L</em>. As such, the following FSM (see <a href="ch10.xhtml#ch10fig5">Figure 10-5</a>) will be used to recognize TRAC identifiers:</p>&#13;
<div class="image"><img alt="Image" src="../images/10fig05.jpg"/></div>&#13;
<p class="figcap" id="ch10fig5"><em>Figure 10-5: FSM to recognize identifiers</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_279"/>Here’s the corresponding syntax diagram in <a href="ch10.xhtml#ch10fig6">Figure 10-6</a>.</p>&#13;
<div class="image"><img alt="Image" src="../images/10fig06.jpg"/></div>&#13;
<p class="figcap" id="ch10fig6"><em>Figure 10-6: Syntax diagram to recognize identifiers</em></p>&#13;
<h4 class="h4" id="ch00lev2sec_75"><strong><em>Regular Expressions</em></strong></h4>&#13;
<p class="noindent">So far the discussion has been at a somewhat abstract level. The question now becomes, <em>How does one actually obtain an FSM that recognizes various character patterns?</em> The answer is <em>regular expressions</em>. A regular expression is essentially a special language used to build finite-state machines (in this case Racket builds the FSM for us, given the regular expression). Our tokens (for example, strings of digits constituting integers) are in fact regular languages. Recall from the last chapter that a regular language is one where there exists an FSM that can accept the entire set of strings. A regular expression is something a bit different. A regular expression (as distinct from a regular language) is really a specification used to build an FSM that recognizes a regular language.</p>&#13;
<p class="indent">Here’s a regular expression that can be used to recognize unsigned integers:</p>&#13;
<p class="center"><span class="literal"> [0-9][0-9]*</span></p>&#13;
<p class="noindent">The expression in square brackets is a character class. In this case, it’s the class of digits from 0 to 9. This regular expression contains two character classes, both for recognizing digits. The way to interpret this is that the first class will recognize a single digit, but the second, since it’s immediately followed by an asterisk, will recognize zero or more additional digits (the asterisk is called the <em>Kleene star</em> in honor of Stephen Kleene, who formalized the concept of regular expressions). A more succinct way to do this is with the following regular expression:</p>&#13;
<p class="center"><span class="literal"> [0-9]+</span></p>&#13;
<p class="noindent">The trailing plus sign (called the <em>Kleene plus</em>) indicates that we want to recognize a string of one or more characters in the class.</p>&#13;
<p class="indent">The Kleene star and Kleene plus are called <em>quantifiers</em>. One additional regular expression quantifier is the question mark, <span class="literal">?</span>. The question mark matches zero or one occurrence of a regular expression. If we wanted to capture numbers that have exactly one or two digits, we could specify it this way:</p>&#13;
<p class="center"><span class="literal"> [0-9][0-9]?</span></p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_280"/>There are a number of additional ways to specify a regular expression class. The version we’ve seen for digits specifies a range of values, with the dash (<span class="literal">-</span>) separating the start and end characters. It’s possible to specify multiple ranges in a class. For example, to specify a class for both the upper- and lowercase characters, one could use <span class="literal">[A-Za-z]</span>. A class can also contain any arbitrary set of characters—for example <span class="literal">[abCD]</span>.</p>&#13;
<p class="indent">For our purposes, we’ll define a class consisting of the arithmetic operators: <span class="literal">[-+/*^]</span>. There are a couple of items to note about this particular class. The first is that since the class starts with a dash, the dash isn’t used to specify a range, so it’s treated as an ordinary character. The second is that the circumflex (<span class="literal">^</span>) would be treated differently if it was the first item in the class. For example, the regular expression <span class="literal">[^abc]</span> would match all characters <em>except</em> <span class="literal">a</span>, <span class="literal">b</span>, or <span class="literal">c</span>.</p>&#13;
<p class="indent">These are just the basics. Given this overview, let’s look at how Racket implements regular expressions and in the process dig deeper into the capability of regular expressions.</p>&#13;
<h4 class="h4" id="ch00lev2sec_76"><strong><em>Regular Expressions in Racket</em></strong></h4>&#13;
<p class="noindent">Racket builds regular expressions with the <span class="literal">regexp</span> function, which takes a string and converts it to a regular expression:</p>&#13;
<pre>&gt; <span class="codestrong1">(define unsigned-integer (regexp "[0-9]+"))</span></pre>&#13;
<p class="indent">There’s also a special literal regexp value that starts with <span class="literal">#rx</span>. For example, a regexp value that recognizes unsigned integers is <span class="literal">#rx"[0-9]+"</span> (or <span class="literal">#rx"[0-9][0-9]*"</span> if you like typing). This syntax is a shorthand method of constructing regular expressions.</p>&#13;
<p class="indent">Regexp values are used in conjunction with the functions <span class="literal">regexp-match</span> and <span class="literal">regexp-match-positions</span>. Suppose we wanted to find the integer embedded in the string <span class="literal">"Is the number 1234 an integer?"</span>. One way to do it would be with the following:</p>&#13;
<pre>&gt; <span class="codestrong1">(regexp-match #rx"[0-9]+" "Is the number 1234 an integer?")</span>&#13;
'("1234")</pre>&#13;
<p class="indent">The match is returned in a list. The reason for this is that regular expressions can contain subexpressions that will result in additional matches being returned. We’ll touch on this a bit later. The <span class="literal">regexp-match-positions</span> functions works in a similar fashion to <span class="literal">regexp-match</span>. The difference is that <span class="literal">regexp-match-positions</span> doesn’t return the matched string; instead, it returns the indices that can be used with <span class="literal">substring</span> to extract the match. Here’s an example.</p>&#13;
<pre>&gt; <span class="codestrong1">(regexp-match-positions #rx"[0-9]+" "Is the number 1234 an integer?")</span>&#13;
'((14 . 18))&#13;
&#13;
&gt; <span class="codestrong1">(substring "Is the number 1234 an integer?" 14 18)</span>&#13;
"1234"</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_281"/>These functions have a number of useful optional parameters. Instead of searching the entire string, the range can be limited by specifying start and stop positions. Here are some examples.</p>&#13;
<pre>&gt; <span class="codestrong1">(regexp-match #rx"[0-9]+" "Is the number 1234 an integer?" 14 18)</span>&#13;
'("1234")&#13;
&#13;
&gt; <span class="codestrong1">(regexp-match-positions #rx"[0-9]+" "Is the number 1234 an integer?" 14 18)</span>&#13;
'((14 . 18))&#13;
&#13;
&gt; <span class="codestrong1">(regexp-match #rx"[0-9]+" "Is the number 1234 an integer?" 16)</span>&#13;
'("34")</pre>&#13;
<p class="indent">Notice in the second example that <span class="literal">regexp-match-positions</span> always returns the position of the match from the start of the string and not from the specified starting position. The ending position is optional, and if not specified, the search continues until the end of the string is reached, as seen in the third example.</p>&#13;
<p class="indent">Probably the most basic regular expressions are just literal letters and digits. For example, to determine whether a string contains the string <span class="literal">"gizmo"</span>, one could form this query:</p>&#13;
<pre>&gt; <span class="codestrong1">(regexp-match #rx"gizmo" "Is gizmo here?")</span>&#13;
'("gizmo")&#13;
&#13;
&gt; <span class="codestrong1">(regexp-match #rx"gizmo" "Is gixmo here?")</span>&#13;
#f</pre>&#13;
<p class="indent">Of course this type of functionality could be obtained from <span class="literal">string-contains?</span>, but regular expressions are much more powerful. Used in conjunction with the Kleene star and plus operators, we can form much more sophisticated queries.</p>&#13;
<pre>&gt; <span class="codestrong1">(regexp-match #rx"cats.*dogs" "It's raining cats and dogs!")</span>&#13;
'("cats and dogs")</pre>&#13;
<p class="indent">The period in a regular expression will match any single character, so the regular expression above will match any substring that has the string <span class="literal">"cats"</span> followed somewhere else by the string <span class="literal">"dogs"</span>.</p>&#13;
<p class="indent">What if we just want to know if the string contains <span class="literal">"cats"</span> <em>or</em> <span class="literal">"dogs"</span>? This is where the regular expression <em>or</em> operator, which consists of a vertical bar (<span class="literal">|</span>), comes into play.</p>&#13;
<pre>&gt; <span class="codestrong1">(regexp-match #rx"cats|dogs" "Do you like cats?")</span>&#13;
'("cats")&#13;
&gt; <span class="codestrong1">(regexp-match #rx"cats|dogs" "Or do you like dogs?")</span>&#13;
'("dogs")</pre>&#13;
<p class="indent">The circumflex (<span class="literal">^</span>) and and dollar sign (<span class="literal">$</span>) characters are special regular expression markers. The circumflex indicates that the match must start at the <span epub:type="pagebreak" id="page_282"/>beginning of the string or, if a start position is specified, at the start position. Likewise, the dollar sign indicates that the match must extend to the end of the string or the ending position, if specified.</p>&#13;
<pre>&gt; <span class="codestrong1">(regexp-match #rx"^[0-9]+" "Is the number 1234 an integer?" 16)</span>&#13;
'("34")&#13;
&#13;
&gt; <span class="codestrong1">(regexp-match #rx"^[0-9]+" "Is the number 1234 an integer?")</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(regexp-match #rx"^[0-9]+" "987 is an integer!")</span>&#13;
'("987")&#13;
&#13;
&gt; <span class="codestrong1">(regexp-match #rx"[0-9]+$" "987 is a number?")</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(regexp-match #rx"[0-9]+$" "The number is at the end: 987")</span>&#13;
'("987")</pre>&#13;
<p class="indent"><a href="ch10.xhtml#ch10tab1">Table 10-1</a> provides a summary description of the various regular expression operators. The string “…” in the table represents an arbitrary list of characters.</p>&#13;
<p class="tabcap" id="ch10tab1"><strong>Table 10-1</strong>: Regular Expression Operators</p>&#13;
<table class="table1">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="table-h" style="vertical-align: top;"><p class="taba"><strong>Operator</strong></p></th>&#13;
<th class="table-h" style="vertical-align: top;"><p class="taba"><strong>Description</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">.</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">Match any character</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba"><em>x</em>*</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">Match <em>x</em> zero or more times</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba"><em>x</em>+</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">Match <em>x</em> one or more times</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba"><em>x</em>?</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">Match <em>x</em> zero or one time</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba"><em>x</em>∣<em>y</em></p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">Match <em>x</em> or <em>y</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">^</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">Match from start of string</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">$</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">Match to end of string</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">[…]</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">Define character class</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-h1" style="vertical-align: top;"><p class="taba">[^…]</p></td>&#13;
<td class="table-h1" style="vertical-align: top;"><p class="taba">Define excluded character class</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">One thing that’s not obvious in the discussion so far is that each letter and digit is in fact a regular expression. A string such as <span class="literal">"abc"</span> is actually the concatenation of the letters <span class="literal">a</span>, <span class="literal">b</span>, and <span class="literal">c</span>. Much like multiplication in a mathematical expression such as 3<em>a</em>, concatenation is implicit in regular expressions. Also like multiplication versus addition, concatenation has a higher precedence than the or (<span class="literal">|</span>) operator. This means that an expression like <span class="literal">"abc|def"</span> is interpreted as <span class="literal">"(abc)|(def)"</span> instead of <span class="literal">"ab(c|d)ef"</span> (note the parentheses in these last two strings are just examples of how the regular expression <span class="literal">"abc|def"</span> is <em>interpreted</em>, but see the following for more on how parentheses play into regular expressions).</p>&#13;
<p class="indent">Parentheses are used in regular expressions to group subexpressions together and to specify order of evaluation. Let’s see how this plays out.</p>&#13;
<pre><span epub:type="pagebreak" id="page_283"/>&gt; <span class="codestrong1">(regexp-match #rx"abc|def" "abcdef")</span>&#13;
'("abc")&#13;
&#13;
&gt; <span class="codestrong1">(regexp-match #rx"abc|def" "defabc")</span>&#13;
'("def")&#13;
&#13;
&gt; <span class="codestrong1">(regexp-match #rx"(abc)|(def)" "abcdef")</span>&#13;
'("abc" "abc" #f)&#13;
&#13;
&gt; <span class="codestrong1">(regexp-match #rx"ab(c|d)ef" "abcdef")</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(regexp-match #rx"ab(c|d)ef" "abcef")</span>&#13;
'("abcef" "c")</pre>&#13;
<p class="indent">The first two examples return the first part of the string that matches either <span class="literal">"abc"</span> or <span class="literal">"def"</span>.</p>&#13;
<p class="indent">The third example, using subexpressions, returns three values. The first is the expected match for the overall regular expression. The second value represents the answer to the question: within the first returned value, what is the match for the subexpression <span class="literal">"(abc)"</span>? In this case, the value is just the string <span class="literal">"(abc)"</span>. The third value answers this question: within the first returned value, what is the match for the subexpression <span class="literal">"(def)"</span>? In this case there’s no match, so it returns <span class="literal">#f</span>.</p>&#13;
<p class="indent">In the fourth example, the match fails because the regular expression is looking for a string with either <span class="literal">c</span> or <span class="literal">d</span>, but not both. In the last example, the entire string was matched, which is reflected in the first return value, but the second value reflects the fact that only the <span class="literal">"c"</span> from the subexpression <span class="literal">"(c|d)"</span> was matched.</p>&#13;
<p class="indent">In our lexical analyzer, we’ll want to use subexpressions, but we’ll only want to know whether the overall regular expression found a match, and we won’t be interested in individual subexpression matches (that is, we’re mainly using it to control evaluation). In this case, we’ll use a special parentheses syntax, <span class="literal">"(?&gt;...)"</span>, which indicates that we only want the overall match without bothering to return matched subexpressions (note that <span class="literal">?:</span> works in a similar way to <span class="literal">?&gt;</span>, but <span class="literal">?:</span> allows specifying matching modes, like whether or not the match is case sensitive—see the Racket Documentation for specifics).</p>&#13;
<pre>&gt; <span class="codestrong1">(regexp-match #rx"(?&gt;abc)|(?&gt;def)" "abcdef")</span>&#13;
'("abc")</pre>&#13;
<p class="indent">One interesting variant of <span class="literal">regexp-match</span> is <span class="literal">regexp-match*</span>. This particular function (although we won’t have a need for it in our application) returns the subexpression matches only.</p>&#13;
<pre>&gt; <span class="codestrong1">(regexp-match* #rx"(abc)|(def)" "abcdef")</span>&#13;
'("abc" "def")</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_284"/>Notice that <span class="literal">regexp-match</span> only matches <span class="literal">"abc"</span>, but <span class="literal">regexp-match*</span> returns a list of all matches, so both <span class="literal">"abc"</span> and <span class="literal">"def"</span> are returned. See the Racket Documentation for more on <span class="literal">regexp-match*</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Racket provides an additional form of regular expressions that conform to the ones used in the Perl programming language. The function used to create regular expressions of this form is called <span class="literal">pregexp</span>. There’s also a literal syntax, similar to the <span class="literal">#rx</span> form, but starting with <span class="literal">#px</span> instead. The Perl syntax provides a number of useful extensions, including predefined character classes. Since our needs are fairly simple, we’ll stick with the basic syntax outlined above.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev2sec_77"><strong><em>Regular Expressions in TRAC</em></strong></h4>&#13;
<p class="noindent">In TRAC (or any calculator for that matter), we need to identify valid numeric strings (floating-point numbers, to be exact). In addition we’ll want to define variables, so that means we’ll need to be able to define identifiers. We’ll need to specify mathematical operators for addition, subtraction, and so on as well as a judicious set of elementary function names. These items all dictate the use of regular expressions.</p>&#13;
<p class="indent">For the purposes of our TRAC application, we’ll always specify the starting position for the regular expression search, so each regular expression will start with <span class="literal">^</span>. The recognizer for identifiers is defined as follows:</p>&#13;
<pre>(define regex-ident #rx"^[A-Za-z](?&gt;[A-Za-z]|[0-9])*")</pre>&#13;
<p class="indent">It should be clear from the information above that this will match any string that starts with a letter and is followed by zero or more letters or digits.</p>&#13;
<p class="indent">The recognizer for numbers (below) is a bit more involved, but the only new element is the portion with <span class="literal">\\.</span>. Since the period (<span class="literal">.</span>) is a regular expression that matches any character, it needs to be <em>escaped</em> so that it can be treated as a regular character (if a character has a special meaning in regular expressions, escaping is a means of removing, or <em>escaping</em>, that special meaning). To avoid having to escape the period, we could also have specified <span class="literal">\\.</span> as <span class="literal">[.]</span>, which might be easier to read in some contexts. The regular expression escape character is the backslash (<span class="literal">\</span>), and since it’s embedded in a Racket string, it must also be escaped by prefixing it with another slash.</p>&#13;
<pre>(define regex-number #rx"^[0-9]+(?&gt;\\.[0-9]+)?(?&gt;e[+-]?[0-9]+)?")</pre>&#13;
<p class="indent">While this is a bit long, it closely mirrors the definition specified by the syntax diagram given earlier in <a href="ch10.xhtml#ch10fig4">Figure 10-4</a>. Let’s review a few test cases.</p>&#13;
<pre>&gt; <span class="codestrong1">(regexp-match regex-number "123")</span>&#13;
'("123")&#13;
&#13;
&gt; <span class="codestrong1">(regexp-match regex-number "a123")</span>&#13;
#f&#13;
(@\pagebreak@)&#13;
&gt; <span class="codestrong1">(regexp-match regex-number "123.")</span>&#13;
'("123")</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_285"/>Notice in the last expression that the match didn’t include the decimal point, since we specified that a decimal point must be followed by at least one digit. This is in line with the syntax diagram, since the match is up to but doesn’t include the decimal point. If the regular expression had ended with <span class="literal">$</span>, this match would have failed. Notice the following.</p>&#13;
<pre>&gt; <span class="codestrong1">(regexp-match regex-number "123.0")</span>&#13;
'("123.0")</pre>&#13;
<p class="indent">In this case, the entire string is matched. Here are a few more examples.</p>&#13;
<pre>&gt; <span class="codestrong1">(regexp-match regex-number "123.456")</span>&#13;
'("123.456")&#13;
&#13;
&gt; <span class="codestrong1">(regexp-match regex-number "123.456e")</span>&#13;
'("123.456")</pre>&#13;
<p class="indent">Again, the match didn’t include the <span class="literal">e</span>, since we specified that an <span class="literal">e</span> must be followed by at least one digit.</p>&#13;
<pre>&gt; <span class="codestrong1">(regexp-match regex-number "123.456e23")</span>&#13;
'("123.456e23")&#13;
&#13;
&gt; <span class="codestrong1">(regexp-match regex-number "123.456e+23")</span>&#13;
'("123.456e+23")&#13;
&#13;
&gt; <span class="codestrong1">(regexp-match regex-number "123e+23")</span>&#13;
'("123e+23")&#13;
&#13;
&gt; <span class="codestrong1">(regexp-match regex-number "123e23")</span>&#13;
'("123e23")&#13;
&#13;
&gt; <span class="codestrong1">(regexp-match regex-number "e23")</span>&#13;
#f</pre>&#13;
<p class="indent">The definition for arithmetic operators is obvious.</p>&#13;
<pre>(define regex-op #rx"^[-+*/^=]")</pre>&#13;
<p class="indent">We’ll want to skip over any space characters, so we add this to our toolbox:</p>&#13;
<pre>(define regex-ws #rx"^ *")</pre>&#13;
<p class="indent">To make TRAC truly useful, we include the usual transcendental functions.</p>&#13;
<pre>(define regex-fname #rx"^(sin|cos|tan|asin|acos|atan|log|ln|sqrt)")</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_286"/>Finally, to facilitate variable assignment, we create a regular expression for keywords. For now, <span class="literal">let</span> is our only keyword.</p>&#13;
<pre>(define regex-keyword #rx"^let")</pre>&#13;
<h4 class="h4" id="ch00lev2sec_78"><strong><em>The Lexer</em></strong></h4>&#13;
<p class="noindent">With the essential definitions in place, we move on to actually defining the lexical analyzer. Rather than just returning a list of tokens, we’re going to supplement each token value with its type. For example, if an identifier is matched, we’re going to return a pair: the first element of the pair is the token type, in this case <span class="literal">identifier</span>, and the second element is the matched string. This additional information will make the job of the parser a bit easier.</p>&#13;
<p class="indent">The lexer is (conceptually) fairly simple: it just sequentially tries to match each token type while keeping track of the position of the matched string. If no match is found, the process fails. If a match is found, the token and its position are recorded, and the process repeats at the next position. This continues until the entire input string is consumed.</p>&#13;
<p class="indent">Another point of interest is that we’re using <span class="literal">regexp-match-positions</span> as our matching function. This will allow us to easily get the position of the next location once a match has been made.</p>&#13;
<p class="indent">The TRAC lexical analyzer is a function called <span class="literal">tokenize</span>, as given below. The main body of the code is a few lines long (see the <span class="literal">cond</span> block <span class="ent">➌</span>); the rest of the code is composed of a few helper functions to manage some of the bookkeeping.</p>&#13;
<pre>(define (tokenize instr)&#13;
  (let loop ([i 0])&#13;
    (let* ([str-len (string-length instr)]&#13;
           [next-pos 0]&#13;
        <span class="ent">➊</span> [start (cdar (regexp-match-positions regex-ws instr i))])&#13;
&#13;
      (define (match-reg regex)&#13;
        (let ([v (regexp-match-positions regex instr start)])&#13;
          (if (equal? v #f)&#13;
              (set! next-pos #f)&#13;
              (set! next-pos (cdar v)))&#13;
          next-pos))&#13;
          &#13;
   <span class="ent">➋</span> (define (classify type)&#13;
        (let ([val (substring instr start next-pos)])&#13;
          (if (equal? type 'number)&#13;
              (cons type (string-&gt;number val))&#13;
              (cons type val))))&#13;
              &#13;
      (define (at-end)&#13;
        (or (= str-len next-pos)&#13;
            <span epub:type="pagebreak" id="page_287"/>(let ([c (string-ref instr next-pos)])&#13;
              (not (or (char-numeric? c) (char-alphabetic? c))))))&#13;
              &#13;
      (let ([token&#13;
          <span class="ent">➌</span> (cond [(= start str-len)'()]&#13;
                <span class="ent">➍</span> [(and (match-reg regex-keyword) (at-end))&#13;
                      (classify 'keyword)]&#13;
                   [(and (match-reg regex-fname) (at-end))&#13;
                      (classify 'fname)]&#13;
                   [(match-reg regex-ident) (classify 'ident)]&#13;
                   [(match-reg regex-number) (classify 'number)]&#13;
                   [(match-reg regex-op) (classify 'op)]&#13;
                <span class="ent">➎</span> [(equal? #\( (string-ref instr start))&#13;
                      (set! next-pos (add1 start))&#13;
                      (cons 'lpar "(")]&#13;
                <span class="ent">➏</span> [(equal? #\) (string-ref instr start))&#13;
                      (set! next-pos (add1 start))&#13;
                      (cons 'rpar ")")]&#13;
                   [else #f])])&#13;
        (cond [(equal? token '()) '()]&#13;
           <span class="ent">➐</span> [token (cons token (loop next-pos))]&#13;
           <span class="ent">➑</span> [else (error (format "Invalid token at ~a." start))])))))</pre>&#13;
<p class="indent">At each iteration of the loop beginning on the second line, the variable <span class="literal">i</span> has the current starting position within the input string <span class="literal">instr</span>. After initializing <span class="literal">str-len</span> and <span class="literal">next-pos</span>, the function reads past any whitespace <span class="ent">➊</span>. The <span class="literal">match-reg</span> function executes the regular expression passed to it in <span class="literal">regex</span> and sets <span class="literal">next-pos</span> to the next position in the string if there is a match; otherwise it’s set to <span class="literal">#f</span>. If there’s a match, <span class="literal">next-pos</span> is returned; otherwise the function returns <span class="literal">#f</span>. The <span class="literal">classify</span> function <span class="ent">➋</span> merges the token type and the token value into a Racket <span class="literal">cons</span> cell. If the token is a number, it also converts the string value to the corresponding numeric value. The <span class="literal">at-end</span> function tests whether the tokenizer is at the end of a keyword or function. A string like <span class="literal">sine</span> is a valid variable name, but wouldn’t be valid as the function name <span class="literal">sin</span>, so <span class="literal">at-end</span> allows the tokenizer to differentiate one input type from another.</p>&#13;
<p class="indent">With these functions available, the actual logic to tokenize the string is fairly straightforward. A check is made <span class="ent">➌</span> to see if we’re at the end of the string, and if so, the empty list is returned. Next is a series of checks <span class="ent">➍</span> to see whether the text at the current position in the string matches any one of the specified regular expressions; if so, the matching token is packaged up in a <span class="literal">cons</span> cell by <span class="literal">classify</span> and returned. If no match is found, the <span class="literal">cond</span> statement returns <span class="literal">#f</span>, which results in an error being generated <span class="ent">➑</span>. If the value of <span class="literal">token</span> is anything other than <span class="literal">#f</span>, it’s added to the returned list <span class="ent">➐</span>. We didn’t bother setting up regular expressions for parentheses, since they can be handled easily <span class="ent">➎</span> <span class="ent">➏</span>.</p>&#13;
<p class="indent">The order in which the regular expressions are evaluated is important. If <span class="literal">regex-ident</span> were evaluated before <span class="literal">regex-fname</span>, a function name like <span class="literal">cos</span> could mistakenly be interpreted as an ordinary variable name instead of the <span epub:type="pagebreak" id="page_288"/>cosine function (this could be dealt with in the parser, but it’s better to offload as much work as possible to the lexical analyzer).</p>&#13;
<p class="indent">Here’s an example of the output:</p>&#13;
<pre>&gt; <span class="codestrong1">(tokenize "(x1*cos(45) + 25 *(4e-12 / alpha)^2")</span>&#13;
'((lpar . "(")&#13;
  (ident . "x1")&#13;
  (op . "*")&#13;
  (fname . "cos")&#13;
  (lpar . "(")&#13;
  (number . 45)&#13;
  (rpar . ")")&#13;
  (op . "+")&#13;
  (number . 25)&#13;
  (op . "*")&#13;
  (lpar . "(")&#13;
  (number . 4e-012)&#13;
  (op . "/")&#13;
  (ident . "alpha")&#13;
  (rpar . ")")&#13;
  (op . "^")&#13;
  (number . 2))</pre>&#13;
<h3 class="h3" id="ch00lev1sec_58">The Parser</h3>&#13;
<p class="noindent">Our next major TRAC component is the parser. The parser takes the token list from the lexical analyzer and outputs an abstract syntax tree that can be further processed by either an interpreter or a compiler. We first provide a formal definition of our grammar, which will be used as a guide in the construction of the parser.</p>&#13;
<h4 class="h4" id="ch00lev2sec_79"><strong><em>TRAC Grammar Specification</em></strong></h4>&#13;
<p class="noindent">Computer languages are often specified by a metasyntax (a syntax that describes another syntax) called <em>extended Backus–Naur form (EBNF)</em>. You’ll notice many similarities between EBNF and regular expressions, but EBNF has more expressive power. EBNF can be used to describe <em>context-free grammars</em>, or <em>CFG</em> (see <a href="ch09.xhtml#ch00lev1sec_54">“A Few Words About Languages” on page 272</a>), which are out of the reach of regular expressions. (TRAC utilizes a CFG.) This notation will be used to give a formal definition to TRAC. We’re going to begin simply, by formally defining what’s meant by <span class="literal">digit</span> (we’re actually going to use the lexical analyzer to recognize numbers and identifiers, but for the sake of introducing simple examples of EBNF, we also define them here).</p>&#13;
<p class="programsc5">    digit = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";</p>&#13;
<p class="noindent">This is called a <em>production rule</em>. As in regular expressions, the vertical bar (<span class="literal">|</span>) means <em>or</em>. Items in quotation marks (<span class="literal">"</span>) are called <em>terminals</em>, and the identifier <span epub:type="pagebreak" id="page_289"/><span class="literal">digit</span> is called a <em>nonterminal</em>. A terminal is a sequence of actual characters (such as what you type on your computer terminal). A nonterminal is a label for a rule, such as <span class="literal">digit</span> above. The definition for <span class="literal">letter</span> is similar, but we don’t show it here, because you can figure it out.</p>&#13;
<p class="indent">The production for <span class="literal">unsigned</span> follows directly from <span class="literal">digit</span>:</p>&#13;
<p class="programsc5">    unsigned = digit , { digit };</p>&#13;
<p class="noindent">In EBNF, curly brackets <span class="literal">{</span> and <span class="literal">}</span> function almost exactly like the Kleene star (except that they also allow grouping items together). This means the items within curly brackets can be repeated zero or more times. The comma (<span class="literal">,</span>) is the concatenation operator.</p>&#13;
<p class="indent">With these entities established, we define <span class="literal">identifier</span> as follows:</p>&#13;
<p class="programsc5">    identifier = letter , { letter | digit };</p>&#13;
<p class="indent">The production for <span class="literal">number</span> is as follows:</p>&#13;
<p class="programsc5">    number = unsigned , [ "."  unsigned ] <br/>&#13;
           , [ "e",  [ "+" | "-" ] , unsigned ];</p>&#13;
<p class="noindent">This production introduces the use of square brackets <span class="literal">[</span> and <span class="literal">]</span>. Much like the regular expression <span class="literal">?</span>, square brackets enclose optional items.</p>&#13;
<p class="indent">Function names are defined as follows:</p>&#13;
<p class="programsc5">    fname = "sin" | "cos" | "tan" | "asin" | "acos" | "atan" <br/>&#13;
          | "log" | "ln";</p>&#13;
<p class="noindent">All these productions have regular expression equivalents, so the implementation is managed by the lexer. The parser will implement more complex production rules. Arithmetic expressions typically contain several levels of nested parenthetical expressions; such expressions constitute a context-free grammar. As mentioned in the previous chapter, parsing such expressions exceeds the capability of an FSA (and by extension, regular expressions). Therefore, we now need the expressive power of EBNF to complete our definitions.</p>&#13;
<p class="indent">With these preliminaries out of the way, we can now give the rest of the definition of the TRAC grammar. Since we only use production names without spaces, commas will be omitted, and therefore concatenation is implicit.</p>&#13;
<p class="programsc5">    statement = "let" identifier "=" expr<br/>&#13;
              | expr;<br/>&#13;
	<br/>&#13;
    expr = term { [ "+" | "-" ] term };<br/>&#13;
	<br/>&#13;
    term = neg { [ "*" | "/" ] neg };<br/>&#13;
	<br/>&#13;
    neg = "-" neg <br/>&#13;
        | pow;<br/>&#13;
	<br/>&#13;
    pow = factor | factor "^" pow;<br/>&#13;
	<br/>&#13;
    factor = number <br/>&#13;
           | identifier<br/>&#13;
           | "(" expr ")"<br/>&#13;
           | fname  "(" expr ")";  </p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_290"/>These rules are written in such a way that the higher-precedence operators are nested further down. Because of how EBNF is evaluated (example below), this ensures that multiplication and division occurs before addition and subtraction. Likewise, exponentiation occurs ahead of multiplication and division. Note also that the <span class="literal">pow</span> production is defined recursively, with the recursive call to the right of the operator. This makes exponentiation right-associative, which is how it’s normally handled (that is, <span class="literal">a^b^c</span> is interpreted as <span class="literal">a^(b^c)</span>, where the rightmost exponentiation is performed first).</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10tab2">Table 10-2</a> illustrates how the productions are expanded for the expression <em>a</em> * (1 + <em>b</em>).</p>&#13;
<p class="tabcap" id="ch10tab2"><strong>Table 10-2</strong>: Expansion of <em>a</em> * (1 + <em>b</em>)</p>&#13;
<div class="image7"><img alt="Image" src="../images/p0290.jpg"/></div>&#13;
<p class="indent">Standard typeface is used to designate terminal tokens, and italics are used to designate nonterminal rules. The notation <em>expr-op</em> refers to the expression operators <span class="literal">+</span> and <span class="literal">-</span>, and <em>term-op</em> refers to the term operators <span class="literal">*</span> and <span class="literal">/</span>. Notice that only the leftmost production is expanded until a terminal value <span epub:type="pagebreak" id="page_291"/>is recognized. Expansion starts with the <em>statement</em> rule on row 1. A <em>statement</em> can be an <em>expr</em>, which in turn can be a <em>term</em>; this is reflected on rows 2 and 3.</p>&#13;
<p class="indent">A <em>term</em> can be a <em>neg</em> followed by a <em>term-op</em> followed by a <em>neg</em>. This is shown on row 4. Expansion continues in this fashion until we get to row 7. Notice that our leftmost rule is <em>identifier</em>. We now have a terminal, <span class="literal">a</span>, that satisfies this rule. The expansion of this rule is shown on row 8. The leftmost rule on this row is <em>term-op</em>, which can be expanded to the terminal <span class="literal">*</span>. Expansion continues in this way until we have parsed the entire string on row 22.</p>&#13;
<p class="indent">This grammar is designed in such a way that it’s an <em>LL(1) grammar</em>. The term LL(1) means that it scans its input (the list of tokens from the lexer) left to right, using a leftmost derivation (as we did in the walk-through above), with a lookahead (lookahead just defines how far ahead we need to look into the list of input tokens) of one symbol (token). This particular type of grammar allows parsers to be constructed in such a way that no backtracking is required to parse the input stream. LL(1) grammars are recognized by <em>recursive descent parsers</em> in which each nonterminal production has a procedure (or function) that’s responsible for recognizing its portion of the grammar and returns the corresponding portion of the syntax tree (or generating an error if the input is incorrect).</p>&#13;
<h4 class="h4" id="ch00lev2sec_80"><strong><em>The TRAC Parser</em></strong></h4>&#13;
<p class="noindent">As mentioned in the previous section, TRAC will use a recursive descent parser. A recursive descent parser is mainly a set of mutually recursive functions where there’s a function for each grammar rule. There’s always a starting function (corresponding to the top-level rule—which is why this is called a top-down parser), which calls other functions as defined by the grammar. The <em>descent</em> part of the definition comes about due to the fact that the rules continue to nest down until a terminal (or error) is encountered.</p>&#13;
<p class="indent">We need a few global variables to keep track of the tokens during the parsing process.</p>&#13;
<pre>(define token-symbol #f)&#13;
(define token-value null)&#13;
(define token-list '())</pre>&#13;
<p class="indent">Next are the predicates used to test various operator types.</p>&#13;
<pre>(define (assign?) (equal? token-value "="))&#13;
&#13;
(define (pow?) (equal? token-value "^"))&#13;
&#13;
(define (neg?) (equal? token-value "-"))&#13;
&#13;
(define (term?) (or&#13;
                  (equal? token-value "*")&#13;
                  (equal? token-value "/")))&#13;
&#13;
(define (expr?) (or&#13;
                  <span epub:type="pagebreak" id="page_292"/>(equal? token-value "+")&#13;
                  (equal? token-value "-")))</pre>&#13;
<p class="indent">The following procedure updates the token info whenever the next token value is requested.</p>&#13;
<pre>(define (next-symbol)&#13;
  (unless (null? token-list)&#13;
    (let ([token (car token-list)])&#13;
      (set! token-symbol (car token))&#13;
      (set! token-value (cdr token))&#13;
      (set! token-list (cdr token-list)))))</pre>&#13;
<p class="indent">The <span class="literal">accept</span> function tests whether the input token is of the expected type and, if so, reads in the next token and returns <span class="literal">#t</span>; otherwise, it returns <span class="literal">#f</span>.</p>&#13;
<pre>(define (accept sym)&#13;
  (if (equal? token-symbol sym)&#13;
      (begin&#13;
        (next-symbol)&#13;
        #t)&#13;
      #f))</pre>&#13;
<p class="indent">The <span class="literal">expect</span> function tests whether the input token is of the expected type and, if so, reads in the next token and returns <span class="literal">#t</span>; otherwise, it generates an error.</p>&#13;
<pre>(define (expect sym)&#13;
  (if (accept sym)&#13;
      #t&#13;
      (if (null? token-list)&#13;
          (error "Unexpected end of input.") &#13;
          (error (format "Unexpected symbol '~a' in input." token-value)))))</pre>&#13;
<p class="indent">The reason we have both <span class="literal">accept</span> and <span class="literal">expect</span> is that in some cases we need to test for various token types without generating an error. For example, the <em>factor</em> rule accepts a number of different token types. We don’t want to generate an error if we’re testing for a number and the current token is an identifier, because if the number test fails, we still want to test for an identifier, so we use <span class="literal">accept</span>. On the other hand, if the expected token <em>must</em> be of a particular type, we use the <span class="literal">expect</span> function, which generates an error if the current token isn’t of the expected type.</p>&#13;
<p class="indent">We’re now able to define the functions that correspond to each grammar production. Even though recursive descent parsers are top-down parsers, we’re going to present the code from the bottom up. Since there are fewer dependencies that way, it should be easier to understand. Given that, the first function is <span class="literal">factor</span>:</p>&#13;
<pre>(define (factor)&#13;
  (let ([val token-value])&#13;
    <span epub:type="pagebreak" id="page_293"/>(cond [(accept 'number) (cons 'number val)]&#13;
          [(accept 'ident) (cons 'ident val)]&#13;
       <span class="ent">➊</span> [(accept 'lpar)&#13;
           (let ([v (expr)])&#13;
             (expect 'rpar)&#13;
             v)]&#13;
          [(accept 'fname)&#13;
           (let ([fname val])&#13;
             (expect 'lpar)&#13;
             (let ([v (expr)])&#13;
               (expect 'rpar)&#13;
               (cons 'func-call (cons fname v))))]&#13;
          [else (error (format "Invalid token: ~a." token-value))])))</pre>&#13;
<p class="indent">Note that we need to save the current token value in <span class="literal">val</span> (which is set in the first line of <span class="literal">let</span>). Once <span class="literal">accept</span> is called and a match is found, the variable <span class="literal">token-value</span> is set to the value of the next token, which isn’t what we need in the return value in the <span class="literal">cond</span> section of the code. The correspondence between the various <span class="literal">cond</span> tests and the production for <span class="literal">factor</span> should be self-evident. As a bit of explanation for the third condition branch <span class="ent">➊</span>, if we look back at our rule for <span class="literal">factor</span>, we find <span class="literal">"(" expr ")"</span> as an accepted production. So we see that this portion of the code accepts a left parenthesis, calls <span class="literal">expr</span> to parse that part of the rule, and then <em>expects</em> a right parenthesis (and errors out if that isn’t the current token).</p>&#13;
<p class="indent">For each accepted value, a <span class="literal">cons</span> cell is created where the first element is a symbol identifying the node type and the second element is the value. The function call portion of the <span class="literal">factor</span> rule (<span class="literal">fname "(" expr ")"</span>) wasn’t given a name, but we specify ’<span class="literal">func-call</span> here to identify the node type. This pattern of defining functions for rules will be replicated in all the productions, with the end result being the desired parser to construct the syntax tree.</p>&#13;
<p class="indent">Next up is the code for <span class="literal">pow</span>:</p>&#13;
<pre>(define (pow)&#13;
  (let ([e1 (factor)])&#13;
    (if (pow?)&#13;
        (begin&#13;
          (next-symbol)&#13;
       <span class="ent">➊</span> (let ([e2 (pow)])&#13;
            (cons '^ (cons e1 e2))))&#13;
        e1)))</pre>&#13;
<p class="indent">This is written in such a way to enforce the grammar rule that requires it to be right-associative. This is managed by the recursive call to <span class="literal">pow</span> <span class="ent">➊</span>. The value returned for <span class="literal">pow</span> is either just the value returned from <span class="literal">factor</span> or a new pair (if the symbol <span class="literal">^</span> is recognized). The first element of this new pair is the character <span class="literal">^</span> and the second element is another pair, where the first element is the base number (from <span class="literal">e1</span>) and the second element is the power it’s being raised to (from a recursive call to <span class="literal">pow</span>).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_294"/>The code for <span class="literal">neg</span> (unary minus) is quite simple. If needed, it appends a negation operator to the return value from <span class="literal">pow</span> to generate a node for unary minus.</p>&#13;
<pre>(define (neg)&#13;
  (if (neg?)&#13;
      (begin&#13;
        (next-symbol)&#13;
        (cons 'neg (neg)))&#13;
      (pow)))</pre>&#13;
<p class="indent">Multiplication and division are handled by the next function, <span class="literal">term</span>. As long as it keeps recognizing other <span class="literal">term</span> operators (<span class="literal">*</span> or <span class="literal">/</span>), it loops, gathering values from <span class="literal">neg</span>. Notice how this differs from the code for <span class="literal">pow</span>: this code makes <span class="literal">term</span> operators left-associative whereas the code for <span class="literal">pow</span> makes exponentiation right-associative.</p>&#13;
<pre>(define (term)&#13;
  (let ([e1 (neg)])&#13;
    (let loop ()&#13;
      (when (term?)&#13;
        (let ([op (if (equal? token-value "*") '* '/)])&#13;
          (next-symbol) &#13;
          (let ([e2 (neg)])&#13;
            (set! e1 (cons op (cons e1 e2)))))&#13;
        (loop)))&#13;
    e1))</pre>&#13;
<p class="indent">Addition and subtraction are managed by <span class="literal">expr</span>. This function works analogously to <span class="literal">term</span>.</p>&#13;
<pre>(define (expr)&#13;
  (let ([e1 (term)])&#13;
    (let loop ()&#13;
      (when (expr?)&#13;
        (let ([op (if (equal? token-value "+") '+ '-)])&#13;
          (next-symbol) &#13;
          (let ([e2 (term)])&#13;
            (set! e1 (cons op (cons e1 e2)))))&#13;
        (loop)))&#13;
    e1))</pre>&#13;
<p class="indent">Finally, we get to the top level, where most of the work that needs to be done is to set things up to parse the assignment statement.</p>&#13;
<pre>(define (statement)&#13;
  (if (equal? token-value "let")&#13;
      (begin&#13;
        (next-symbol)&#13;
        (let ([id token-value])&#13;
          <span epub:type="pagebreak" id="page_295"/>(accept 'ident)&#13;
          (if (assign?)&#13;
              (begin&#13;
                (next-symbol)&#13;
                (cons 'assign (cons id (expr))))&#13;
              (error "Invalid let statement"))))&#13;
      (expr)))</pre>&#13;
<p class="indent">The actual parser just has to call <span class="literal">tokenize</span> (the lexer) to convert the input string to a list of tokens and kick off the parsing process by calling <span class="literal">statement</span>.</p>&#13;
<pre>(define (parse instr)&#13;
  (set! token-list (tokenize (string-trim instr)))&#13;
  (next-symbol)&#13;
  (let ([val (statement)])&#13;
    (if (equal? token-list '())&#13;
        val&#13;
        (error "Syntax error in input."))))</pre>&#13;
<p class="indent">Notice that if there’s anything left in <span class="literal">token-list</span>, an error is generated. Without this, an input that starts with a valid expression, but has some dangling tokens. For example, the following would return a partial result (in this case ’<span class="literal">(ident . "x")</span>) without alerting the user that the input was invalid.</p>&#13;
<pre>&gt; <span class="codestrong1">(parse "x y")</span></pre>&#13;
<p class="indent">Here it goes with a test input expression:</p>&#13;
<pre>&gt; <span class="codestrong1">(parse "(x1*cos(45) + 25 *(4e-12 / alpha))^2")</span>&#13;
'(pow (+ (* (ident . "x1") func-call "cos" number . 45) * (number . 25) / (&#13;
     number . 4e-012) ident . "alpha") number . 2)</pre>&#13;
<p class="indent">It seems to work, but it’s a bit difficult to decipher what’s actually going on with this output. We need a procedure that will take the syntax tree and print it in a way that makes the structure more obvious. So here it is!</p>&#13;
<pre>(define (print-tree ast)&#13;
  (let loop ([level 0][node ast])&#13;
    (let ([indent (make-string (* 4 level) #\ )]&#13;
           [sym (car node)]&#13;
           [val (cdr node)])&#13;
      (printf indent)&#13;
      (define (print-op)&#13;
        (printf "Operator: ~a\n"  sym)&#13;
        (loop (add1 level) (car val))&#13;
        (loop (add1 level) (cdr val)))&#13;
      (match sym&#13;
        ['number (printf "Number: ~a\n" val)]&#13;
        ['ident  (printf "Identifier: ~a\n" val)]&#13;
        ['func-call &#13;
           <span epub:type="pagebreak" id="page_296"/>(printf "Function: ~a\n" (car val))&#13;
           (loop (add1 level) (cdr val))]&#13;
        ['+ (print-op)]&#13;
        ['- (print-op)]&#13;
        ['* (print-op)]&#13;
        ['/ (print-op)]&#13;
        ['^ (print-op)]&#13;
        ['neg &#13;
           (printf "Neg:\n")&#13;
           (loop (add1 level) val)]&#13;
        ['assign&#13;
           (printf "Assign: ~a\n" (car val))&#13;
           (loop (add1 level) (cdr val))]&#13;
        [_ (printf "Node: ~a?\n" node)]))))</pre>&#13;
<p class="indent">It’s essentially one big <span class="literal">match</span> statement that matches against the node type of the tree. The indentation varies depending on the depth of the node in the tree. This will provide a visual representation of how the child nodes are lined up. With this, we can generate output that is a bit more decipherable.</p>&#13;
<pre>&gt; <span class="codestrong1">(define ast (parse "(x1*cos(45) + 25 *(4e-12 / alpha))^2"))</span>&#13;
&gt; <span class="codestrong1">(print-tree ast)</span>&#13;
Operator: ^&#13;
    Operator: +&#13;
        Operator: *&#13;
            Identifier: x1&#13;
            Function: cos&#13;
                Number: 45&#13;
        Operator: *&#13;
            Number: 25&#13;
            Operator: /&#13;
                Number: 4e-012&#13;
                Identifier: alpha&#13;
    Number: 2</pre>&#13;
<p class="indent">The parser creates a syntax tree of an input string, and <span class="literal">print-tree</span> prints out a visual representation of the tree. It turns out that <span class="literal">print-tree</span> provides a framework with which to build a routine that can reconstruct the input string from the syntax tree. This can be useful for debugging purposes, since it allows us to see whether an output string constructed from the AST corresponds to the input string. We reverse the process by first creating a token list from the syntax tree, and then we create an output string by appending the tokens together.</p>&#13;
<p class="indent">The biggest issue in creating a tree-to-string conversion function lies in deciding when to add parentheses around an expression. We certainly want to include them when required, but we don’t want to include unnecessary parentheses when they aren’t required. To facilitate this, we create a function that returns the precedence and associativity of each operator. This is <span epub:type="pagebreak" id="page_297"/>needed to determine whether or not parentheses are required (for example, operators with lower precedence will require parentheses, and if the precedence is the same, the need for parentheses is dictated by the associativity).</p>&#13;
<pre>(struct op (prec assoc))&#13;
&#13;
(define get-prop&#13;
  (let ([op-prop&#13;
         (hash&#13;
          'assign (cons 0 'r)&#13;
          '+   (op 10 'l) &#13;
          '-   (op 10 'l) &#13;
          '*   (op 20 'l) &#13;
          '/   (op 20 'l)&#13;
          'neg (op 30 'n)&#13;
          '^   (op 40 'r)&#13;
          'expt   (op 40 'r)&#13;
          'number (op 90 'n)&#13;
          'ident  (op 90 'n)&#13;
          'func-call (op 90 'n))])&#13;
    (λ (sym)&#13;
      (hash-ref op-prop sym (λ () (op 90 'n))))))</pre>&#13;
<p class="indent">If a symbol isn’t in the table, the second λ expression returns a default value of <span class="literal">(info 90</span> ’<span class="literal">n)</span>.</p>&#13;
<p class="indent">With this function at hand, we can produce <span class="literal">ast-&gt;string</span>:</p>&#13;
<pre>(define (ast-&gt;string ast)&#13;
  (let ([expr-port (open-output-string)])&#13;
    (define (push str)&#13;
      (display str expr-port))&#13;
    (let loop ([node ast])&#13;
      (let* ([sym (car node)]&#13;
             [val (cdr node)]&#13;
             [prop (get-prop sym)]&#13;
             [prec (op-prec prop)]&#13;
             [assoc (op-assoc prop)])&#13;
             &#13;
        (define (need-paren arg side)&#13;
          (let ([arg-prec (op-prec (get-prop (car arg)))])&#13;
            (cond [(&lt; arg-prec prec) #t]&#13;
                  [(&gt; arg-prec prec) #f]&#13;
                  [else (not (equal? assoc side))])))&#13;
                  &#13;
        (define (push-op) &#13;
          (let* ([e1 (car val)]&#13;
                 [par1 (need-paren e1 'l)]&#13;
                 [e2 (cdr val)]&#13;
                 <span epub:type="pagebreak" id="page_298"/>[par2 (need-paren e2 'r)])&#13;
            (when par1 (push "("))&#13;
            (loop e1)&#13;
            (when par1 (push ")"))&#13;
            (push (format " ~a "  sym))&#13;
            (when par2 (push "("))&#13;
            (loop e2)&#13;
            (when par2 (push ")"))))&#13;
            &#13;
        (match sym&#13;
          ['number (push (number-&gt;string val))]&#13;
          ['ident (push val)]&#13;
          ['func-call &#13;
           (push (car val))&#13;
           (push "(")&#13;
           (loop (cdr val))&#13;
           (push ")")]&#13;
          ['+ (push-op)]&#13;
          ['- (push-op)]&#13;
          ['* (push-op)]&#13;
          ['/ (push-op)]&#13;
          ['^ (push-op)]&#13;
          ['neg &#13;
           (push "-")&#13;
           (let ([paren (need-paren val 'n)])&#13;
             (when paren (push "("))&#13;
             (loop val)&#13;
             (when paren (push ")")))]&#13;
          ['assign&#13;
           (push (format "let ~a = " (car val)))&#13;
           (loop (cdr val))]&#13;
          [_ (push (format "Node: ~a" sym))])))&#13;
    (get-output-string expr-port)))</pre>&#13;
<p class="indent">A local function called <span class="literal">push</span> has been defined that adds a token to the output string port (<span class="literal">expr-port</span>). One major difference between this code and <span class="literal">print-tree</span> is that all the <span class="literal">print</span> statements have been changed to <span class="literal">push</span> statements. In addition, the function that handles the various operators, <span class="literal">push-op</span> (instead of <span class="literal">print-op</span>), has been expanded to decide when to include parentheses. Aside from these changes, the structural similarities, starting with the <span class="literal">match</span> statement, between <span class="literal">ast-&gt;string</span> and <span class="literal">print-tree</span> should be fairly obvious. So now we can go full circle: input string to abstract syntax tree and back to input string:</p>&#13;
<pre>&gt; <span class="codestrong1">(ast-&gt;string (parse "(x1*cos(45) - 4 + -25 *(4e-12 / alpha))^2"))</span>&#13;
"(x1 * cos(45) - 4 + -25 * (4e-012 / alpha)) ^ 2"</pre>&#13;
<h3 class="h3" id="ch00lev1sec_59"><span epub:type="pagebreak" id="page_299"/>TRAC</h3>&#13;
<p class="noindent">Once the syntax tree has been created, the rest of the work is smooth sailing. The main remaining components are a dictionary to hold our variable values and the code that actually evaluates our input expressions and produces a numeric value. Before we wrap up, we’ll look at a few enhancements, such as adding complex numbers and setting the angular mode.</p>&#13;
<h3 class="h3" id="ch00lev1sec_60">Adding a Dictionary</h3>&#13;
<p class="indent">Since TRAC has the capability to assign values to variables, we’ll need a dictionary to hold the values. We’re actually going to create this in the form of a function, where we pass it an action (for example, <span class="literal">get</span> to retrieve a value and <span class="literal">set</span> to assign a value). This will make it easier to extend its functionality without cluttering up the namespace with additional definitions. This also provides an example of using a single <em>rest-id</em> in a lambda expression. A rest-id is a parameter that takes all the arguments supplied to the function in a single list. The <span class="literal">args</span> parameter in the code below is the rest-id that accepts a list of arguments. Notice that it’s not surrounded by parentheses.</p>&#13;
<pre>(define var&#13;
  (let ([vars (make-hash)])&#13;
    (λ args&#13;
      (match args&#13;
        [(list 'set v n) (hash-set! vars v n)]&#13;
        [(list 'get v)&#13;
         (if (hash-has-key? vars v)&#13;
             (hash-ref vars v)&#13;
             (error (format "Undefined variable: ~a" v)))]))))</pre>&#13;
<p class="indent">Observe that this code actually uses a closure to construct the dictionary (that is, <span class="literal">vars</span>, in the form of a hash table). This function returns a function that has the dictionary embedded in it.</p>&#13;
<p class="indent">With a dictionary to hold variable values in place, we can now define the expression evaluator.</p>&#13;
<pre>(define (eval-ast ast)&#13;
  (let loop ([node ast])&#13;
  <span class="ent">➊</span> (let ([sym (car node)]&#13;
           [val (cdr node)])&#13;
          &#13;
   <span class="ent">➋</span> (define (eval-op)&#13;
        (let ([n1 (loop (car val))]&#13;
              [n2 (loop (cdr val))])&#13;
          (match sym&#13;
            ['+ (+ n1 n2)]&#13;
            ['- (- n1 n2)]&#13;
            ['* (* n1 n2)]&#13;
            ['/ (/ n1 n2)]&#13;
            <span epub:type="pagebreak" id="page_300"/>['^ (expt n1 n2)])))&#13;
            &#13;
   <span class="ent">➌</span> (define (eval-func fname val)&#13;
        (match fname&#13;
          ["sin" (sin val)]&#13;
          ["cos" (cos val)]&#13;
          ["tan" (tan val)]&#13;
          ["asin" (asin val)]&#13;
          ["acos" (acos val)]&#13;
          ["atan" (atan val)]&#13;
          ["ln" (log val)]&#13;
          ["log" (log val 10)]&#13;
          ["sqrt" (sqrt val)] ))&#13;
          &#13;
   <span class="ent">➍</span> (match sym&#13;
        ['number val]&#13;
        ['ident (var 'get val)]&#13;
        ['+ (eval-op)]&#13;
        ['- (eval-op)]&#13;
        ['* (eval-op)]&#13;
        ['/ (eval-op)]&#13;
        ['^ (eval-op)]&#13;
        ['neg (- (loop val))]&#13;
        ['assign (var 'set (car val)&#13;
                      (loop (cdr val)))]&#13;
     <span class="ent">➎</span> ['func-call &#13;
         (eval-func (car val)&#13;
                    (loop (cdr val)))]&#13;
        [_ (error "Unknown symbol")]))))</pre>&#13;
<p class="indent">Notice that it follows a pattern similar to <span class="literal">ast-&gt;string</span> and <span class="literal">print-tree</span>; the difference is that now, instead of returning or printing a string, it traverses the syntax tree and computes the numerical values of the nodes.</p>&#13;
<p class="indent">Let’s walk through what happens. Given the AST, we extract the parsed symbol (<span class="literal">sym</span>) and value (<span class="literal">val</span>) <span class="ent">➊</span>. We then match the symbol <span class="ent">➍</span> and take the appropriate action. If we’re given a literal number, we simply return the value. If we have an identifier, then we extract the value from the dictionary using <span class="literal">(var</span> ’<span class="literal">get val)</span>. An arithmetic operation will result in calling <span class="literal">eval-op</span> <span class="ent">➋</span>, which first recursively extracts arguments <span class="literal">n1</span> and <span class="literal">n2</span>. It then matches the input symbol to determine which operation to perform. A function call <span class="ent">➎</span> recursively extracts its argument via <span class="literal">(loop (cdr val))</span> and calls <span class="literal">eval-func</span> <span class="ent">➌</span> to actually perform the computation.</p>&#13;
<p class="indent">We’re now in a position to actually perform some calculations.</p>&#13;
<pre>&gt; <span class="codestrong1">(eval-ast (parse "let x = 3"))</span>&#13;
&gt; <span class="codestrong1">(eval-ast (parse "let y = 4"))</span>&#13;
&gt; <span class="codestrong1">(eval-ast (parse "sqrt(x^2 + y^2)"))</span>&#13;
5&#13;
&#13;
<span epub:type="pagebreak" id="page_301"/>&gt; <span class="codestrong1">(eval-ast (parse "x + tan(45 * 3.14159 / 180)"))</span>&#13;
3.9999986732059836</pre>&#13;
<p class="indent">To keep from having to call <span class="literal">parse</span> and <span class="literal">eval-ast</span> every time, we need to set up a read-evaluate-print loop (REPL). To do this, we create a <span class="literal">start</span> function that kicks off the process and sets up a few predefined variables.</p>&#13;
<pre>(define (start)&#13;
  (var 'set "pi" pi)&#13;
  (var 'set "e" (exp 1))&#13;
  (display "Welcome to TRAC!\n\n")&#13;
  (let loop ()&#13;
    (display "&gt; ")&#13;
      (let ([v (eval-ast (parse (read-line)))])&#13;
        (when (number? v) (displayln  v)))&#13;
    (loop)))</pre>&#13;
<p class="indent">Now we can exercise TRAC in a more natural way.</p>&#13;
<pre>&gt; <span class="codestrong1">(start)</span>&#13;
Welcome to TRAC!&#13;
&#13;
&gt; <span class="codestrong1">let x = 3</span>&#13;
&gt; <span class="codestrong1">let y = 2+2</span>&#13;
&gt; <span class="codestrong1">sqrt(x^2+y^2)</span>&#13;
5&#13;
&#13;
&gt; <span class="codestrong1">tan(45 * pi / 180)</span>&#13;
0.9999999999999999</pre>&#13;
<h4 class="h4" id="ch00lev2sec_81"><strong><em>A Few Enhancements</em></strong></h4>&#13;
<p class="noindent">We’ve now established the basic functionality of TRAC, but to make it truly useful, we’ll add a few enhancements. One important enhancement is to have it fail gracefully if the user makes an input error. It might also be nice to provide advanced users the ability to work with complex numbers. We’ll explore these topics and more in the sections that follow.</p>&#13;
<h5 class="h5" id="ch00lev3sec_65"><strong>Exception Handling</strong></h5>&#13;
<p class="noindent">As it stands, TRAC is quite fragile. The slightest misstep will cause it to fail:</p>&#13;
<pre>&gt; <span class="codestrong1">let x=3</span>&#13;
&gt; <span class="codestrong1">let y=4</span>&#13;
&gt; <span class="codestrong1">sqrt(x^2 + y^2</span>&#13;
. . Unexpected end of input</pre>&#13;
<p class="indent">It should be more forgiving of erroneous input (we’re human, after all). To alleviate this situation, we leverage Racket’s <em>exception handling</em> capability.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_302"/>When an error occurs in executing Racket code, an exception is raised. An exception will either have a type of <span class="literal">exn</span> or one of its subtypes. The exceptions raised by <span class="literal">error</span> have a type of <span class="literal">exn:fail</span>. To trap such errors, one wraps the code in a <span class="literal">with-handlers</span> form. A modified version of <span class="literal">start</span> that uses <span class="literal">with-handlers</span> is given here.</p>&#13;
<pre>(define (start)&#13;
  (var 'set "pi" pi)&#13;
  (var 'set "e" (exp 1))&#13;
  (display "Welcome to TRAC!\n\n")&#13;
  (let loop ()&#13;
    (display "&gt; ")&#13;
    (with-handlers ([exn:fail? (λ (e) (displayln "An error occured"))])&#13;
      (let ([v (eval-ast (parse (read-line)))])&#13;
        (when (number? v) (displayln v))))&#13;
    (loop)))</pre>&#13;
<p class="indent">The <span class="literal">with-handlers</span> form can trap any number of different types of error. In this case, we use the <span class="literal">exn:fail?</span> predicate to trap generated <span class="literal">exn:fail</span> errors generated by the <span class="literal">error</span> form. Each trapped error type has a corresponding function to manage the trapped error.</p>&#13;
<p class="indent">Here we use a lambda expression to generate the somewhat uninformative <span class="literal">"An error occurred."</span> message. Evaluating the expression with the missing right parenthesis now produces the following outcome.</p>&#13;
<pre>&gt; <span class="codestrong1">sqrt(x^2 + y^2</span>&#13;
An error occurred!&#13;
&gt;</pre>&#13;
<p class="indent">Observe that this time, even though an error has occurred, the <span class="literal">&gt;</span> prompt appears, indicating that the program is still running. The user now has an opportunity to re-enter the expression and continue working.</p>&#13;
<p class="indent">Suppose we want to provide a more informative error message, like the one provided by Racket. The <span class="literal">e</span> parameter handed to the exception handling function is an <span class="literal">exn</span> structure. This structure has a <span class="literal">message</span> field that contains the actual text string of the raised error. So to print the text of the error message, we need to modify the lambda function to read as follows:</p>&#13;
<pre>(λ (e) (displayln (exn-message e)))</pre>&#13;
<p class="indent">With this change in place, a session with an erroneous entry would proceed as follows:</p>&#13;
<pre>&gt; <span class="codestrong1">(start)</span>&#13;
Welcome to TRAC!&#13;
&#13;
&gt; <span class="codestrong1">let x=3</span>&#13;
&gt; <span class="codestrong1">let y=4</span>&#13;
&gt; <span class="codestrong1">sqrt(x^2 + y^2</span>&#13;
Unexpected end of input.&#13;
<span epub:type="pagebreak" id="page_303"/>&gt; <span class="codestrong1">sqrt(x^2 + y^2)</span>&#13;
5&#13;
&gt;</pre>&#13;
<p class="indent">Notice that evaluating an expression such as <span class="literal">sqrt(-1)</span> will produce the complex number <span class="literal">0+1i</span>. This may be confusing to users not familiar with complex numbers. In this case, it may be preferable to raise an error instead of returning a result. To accommodate this, the <span class="literal">start</span> procedure could be modified as follows:</p>&#13;
<pre>(define (start)&#13;
  (reset)&#13;
  (let loop ()&#13;
    (display "&gt; ")&#13;
    (with-handlers ([exn:fail? (λ (e) (displayln (exn-message e)))])&#13;
      (let ([v (eval-ast (parse (read-line)))])&#13;
        (when (number? v)&#13;
          (if (not (real? v))&#13;
              (error "Result undefined.")&#13;
              (displayln v)))))&#13;
    (loop)))</pre>&#13;
<p class="indent">With this change in place, evaluating an expression that returns a complex number would produce the following result:</p>&#13;
<pre>&gt; <span class="codestrong1">sqrt(-2)</span>&#13;
Result undefined.</pre>&#13;
<h5 class="h5" id="ch00lev3sec_66"><strong>Complex Numbers</strong></h5>&#13;
<p class="noindent">In the previous section, we mentioned throwing an exception if a calculation produces a complex number. If users <em>are</em> familiar with complex numbers, the lexer could be modified to accept complex numbers, in which case the original <span class="literal">start</span> procedure could be kept in place. It’s not extremely difficult to modify TRAC’s lexical analyzer such that it works with complex numbers. One might be tempted to create a regular expression that recognizes a complex number such as <span class="literal">1+2i</span>. That would be a big mistake. If one evaluates an expression such as <span class="literal">2*1+2i</span>, the expected result is <span class="literal">2+2i</span> since multiplication has a higher precedence than addition. If the lexer returns the entire expression as a number, the parser will treat the expression <span class="literal">2*1+2i</span> as <span class="literal">2*(1+2i)</span>, which will give the result <span class="literal">2+4i</span>.</p>&#13;
<p class="indent">The actual solution is quite simple. Instead of recognizing the entire complex number, we only recognize the imaginary part. That is, the regular expression for a number becomes as follows:</p>&#13;
<pre>(define regex-number #rx"^[0-9]+(?&gt;\\.[0-9]+)?(?&gt;e[+-]?[0-9]+)?i?")</pre>&#13;
<p class="indent">Notice that the only change in the expression is the inclusion of <span class="literal">i?</span> at the end, which means we accept an optional <span class="literal">i</span> at the end of a numeric input.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_304"/>In addition, we make a small modification to <span class="literal">classify</span> (which is embedded in <span class="literal">tokenize</span>) to handle imaginary numbers.</p>&#13;
<pre>(define (tokenize instr)&#13;
         ⋮&#13;
      (define (classify type)&#13;
        (let ([val (substring instr start next-pos)])&#13;
          (if (equal? type 'number) &#13;
              (cons type&#13;
                    (if (equal? #\i (string-ref val (sub1 (string-length val))))&#13;
                        (string-&gt;number (string-append "0+" val))&#13;
                        (string-&gt;number val)))&#13;
              (cons type val))))&#13;
         ⋮</pre>&#13;
<p class="indent">With these changes in place, we can compute the following in TRAC:</p>&#13;
<pre>&gt; <span class="codestrong1">1i</span>&#13;
0+1i&#13;
&#13;
&gt; <span class="codestrong1">1i^2</span>&#13;
-1&#13;
&#13;
&gt; <span class="codestrong1">2*1+2i</span>&#13;
2+2i&#13;
&#13;
&gt; <span class="codestrong1">2*(1+2i)</span>&#13;
2+4i</pre>&#13;
<h5 class="h5" id="ch00lev3sec_67"><strong>Mode, Reset, and Help Commands</strong></h5>&#13;
<p class="noindent">Most calculators allow the user to compute trigonometric functions using either degrees or radians. We’d be remiss to omit this capability from TRAC. This will require a global variable to contain the trigonometric mode:</p>&#13;
<pre>(define RADIANS 1)&#13;
(define DEGREES (/ pi 180))&#13;
(define trig-mode RADIANS)</pre>&#13;
<p class="indent">TRAC currently handles numeric entries exactly as Racket would. That is, if an exact value is divided by an exact value, a fraction results. For example entering <span class="literal">2/4</span> would return a result of <span class="literal">1/2</span>. This is typically not what’s expected for run-of-the-mill calculations. We’ll thus modify TRAC to give the user the option to treat all entries as floating-point numbers or to retain fractional entries. To enable this, we’ll use a global variable to maintain the numeric mode.</p>&#13;
<pre>(define FRAC 1)&#13;
(define FLOAT 2)&#13;
<span epub:type="pagebreak" id="page_305"/>(define num-mode FLOAT)</pre>&#13;
<p class="indent">It would also be nice to allow the user to reset TRAC to its default start-up state, so TRAC is given a new keyword called <span class="literal">reset</span>, which requires the following change to <span class="literal">regex-keyword</span>.</p>&#13;
<pre>(define regex-keyword #rx"^(let|reset|\\?)")</pre>&#13;
<p class="indent">The question mark at the end will allow TRAC to have a mini–help system, which is accessed by entering <span class="literal">?</span> on the command line (more on this shortly).</p>&#13;
<p class="indent">Entering <span class="literal">reset</span> will result in clearing previous entries in the TRAC dictionary and priming it with the default values. These actions are bundled up into a <span class="literal">reset</span> procedure:</p>&#13;
<pre>(define (reset)&#13;
  (var 'set "pi" pi)&#13;
  (var 'set "e" (exp 1))&#13;
  &#13;
  (var 'set "Rad" RADIANS)&#13;
  (var 'set "Deg" DEGREES)&#13;
  (set! trig-mode RADIANS)&#13;
  &#13;
  (var 'set "Frac" FRAC)&#13;
  (var 'set "Float" FLOAT)&#13;
  (set! num-mode FLOAT)&#13;
  &#13;
  (displayln "** Welcome to TRAC! **\n")&#13;
  (displayln "  Modes: Rad, Float")&#13;
  (displayln "  Enter ? for help.\n")&#13;
  )</pre>&#13;
<p class="indent">The <span class="literal">start</span> procedure then becomes as follows:</p>&#13;
<pre>(define (start)&#13;
  (reset)&#13;
  (let loop ()&#13;
    (display "&gt; ")&#13;
    (with-handlers ([exn:fail? (λ (e) (displayln (exn-message e)))])&#13;
      (let ([v (eval-ast (parse (read-line)))])&#13;
        (when (number? v) (displayln v))))&#13;
    (loop)))</pre>&#13;
<p class="indent">To accommodate the new <span class="literal">reset</span> and <span class="literal">?</span> keywords, the <span class="literal">statement</span> portion of the parser is updated as follows:</p>&#13;
<pre>(define (statement)&#13;
  (cond [(equal? token-value "let")&#13;
         (next-symbol)&#13;
         (let ([id token-value])&#13;
           <span epub:type="pagebreak" id="page_306"/>(accept 'ident)&#13;
           (if (assign?)&#13;
               (begin&#13;
                 (next-symbol)&#13;
                 (cons 'assign (cons id (expr))))&#13;
               (error "Invalid let statement")))]&#13;
        [(equal? token-value "reset") (cons 'reset null)]&#13;
        [(equal? token-value "?") (cons 'help null)]&#13;
        [else (expr)]))</pre>&#13;
<p class="indent">If <span class="literal">reset</span> or <span class="literal">?</span> is entered for input, the function returns immediately without drilling down into the parser so that the expression evaluator can handle these commands directly.</p>&#13;
<p class="indent">Of course we still need to modify the trigonometric functions to work properly depending on the current mode. The handling of numeric entries will also need to be adjusted to ensure that they honor the current numeric mode. Here’s the tweaked version of <span class="literal">ast-eval</span>.</p>&#13;
<pre>(define (eval-ast ast)&#13;
  (let loop ([node ast])&#13;
    (let ([sym (car node)]&#13;
          [val (cdr node)])&#13;
          &#13;
      (define (eval-op)&#13;
        (let ([n1 (loop (car val))]&#13;
              [n2 (loop (cdr val))])&#13;
          (match sym&#13;
            ['+ (+ n1 n2)]&#13;
            ['- (- n1 n2)]&#13;
            ['* (* n1 n2)]&#13;
            ['/ (/ n1 n2)]&#13;
            ['^ (expt n1 n2)])))&#13;
            &#13;
      (define (eval-func fname val)&#13;
        (match fname&#13;
       <span class="ent">➊</span> ["sin" (sin (* val trig-mode))]&#13;
          ["cos" (cos (* val trig-mode))]&#13;
          ["tan" (tan (* val trig-mode))]&#13;
          ["asin" (/ (asin val) trig-mode)]&#13;
          ["acos" (/ (acos val) trig-mode)]&#13;
          ["atan" (/ (atan val) trig-mode)]&#13;
          ["ln" (log val)]&#13;
          ["log" (log val 10)]&#13;
          ["sqrt" (sqrt val)] ))&#13;
          &#13;
      (match sym&#13;
        ['number&#13;
      <span class="ent">➋</span> (if (and (= num-mode FLOAT) (exact? val))&#13;
             <span epub:type="pagebreak" id="page_307"/>(exact-&gt;inexact val)&#13;
             val)]&#13;
        ['ident (var 'get val)]&#13;
        ['+ (eval-op)]&#13;
        ['- (eval-op)]&#13;
        ['* (eval-op)]&#13;
        ['/ (eval-op)]&#13;
        ['^ (eval-op)]&#13;
        ['neg (- (loop val))]&#13;
     <span class="ent">➌</span> ['reset (reset)]&#13;
     <span class="ent">➍</span> ['help (print-help)]&#13;
        ['assign&#13;
         (var 'set (car val)                    &#13;
              (let ([n (loop (cdr val))])&#13;
             <span class="ent">➎</span> (cond [(equal? (car val) "TrigMode")&#13;
                       (if (or (= n RADIANS) (= n DEGREES))&#13;
                           (begin&#13;
                             (set! trig-mode n)&#13;
                             (printf "TrigMode set to ~a.\n\n" (if (= n&#13;
     RADIANS) "Rad" "Deg")))&#13;
                           (error "Invalid TrigMode."))]&#13;
                   <span class="ent">➏</span> [(equal? (car val) "NumMode")&#13;
                       (if (or (= n FRAC) (= n FLOAT))&#13;
                           (begin&#13;
                             (set! num-mode n)&#13;
                             (printf "NumMode set to ~a.\n\n" (if (= n FRAC) "&#13;
     Frac" "Float")))&#13;
                           (error "Invalid NumMode."))]&#13;
                      [else n])))]&#13;
        ['func-call &#13;
         (eval-func (car val)&#13;
                    (loop  (cdr val)))]&#13;
        [_ (error "Unknown symbol")]))))</pre>&#13;
<p class="indent">The actual changes to the trigonometric functions are minor: just a multiplication or division by <span class="literal">mode</span> does the trick (observe how <span class="literal">trig-mode</span> is handled <span class="ent">➊</span>). Code is also added to properly convert exact values to inexact when the mode is set to <span class="literal">FLOAT</span> <span class="ent">➋</span>. Most of the remaining changes involve modifying the assignment statement to trap changes to <span class="literal">TrigMode</span> <span class="ent">➎</span> and <span class="literal">NumMode</span> <span class="ent">➏</span> to ensure that they can only be assigned proper values. Note the additions for <span class="literal">reset</span> <span class="ent">➌</span> and <span class="literal">help</span> <span class="ent">➍</span>. The <span class="literal">print-help</span> procedure is provided here:</p>&#13;
<pre>(define (print-help)&#13;
  (let ([help (list&#13;
               (format "Current TrigMode: ~a"&#13;
                       (if (= trig-mode RADIANS) "Rad" "Deg"))              &#13;
               "To change TrigMode: to radians type:"&#13;
               "   let TrigMode = Rad"&#13;
               <span epub:type="pagebreak" id="page_308"/>"To change TrigMode to degrees type:"&#13;
               "   let TrigMode = Deg"&#13;
               ""   &#13;
               (format "Current NumMode: ~a"&#13;
                       (if (= num-mode FLOAT) "Float" "Frac"))&#13;
               "To change NumMode to float type:"&#13;
               "   let NumMode: = Float"&#13;
               "To change NumMode: to fraction type:"&#13;
               "   let NumMode: = Frac"&#13;
               ""&#13;
               "To reset TRAC to defaults type:"&#13;
               "   reset")])&#13;
    (let loop([h help])&#13;
      (unless (equal? h '())&#13;
        (printf "~a\n" (car h))&#13;
        (loop (cdr h)))))&#13;
  (newline))</pre>&#13;
<p class="indent">Here’s a session illustrating the new functionality.</p>&#13;
<pre>&gt; <span class="codestrong1">(start)</span>&#13;
** Welcome to TRAC! **&#13;
&#13;
  Modes: Rad, Float&#13;
  Enter ? for help.&#13;
&#13;
&gt; <span class="codestrong1">tan(45)</span>&#13;
1.6197751905438615&#13;
&gt; <span class="codestrong1">let TrigMode=Deg</span>&#13;
TrigMode set to Deg.&#13;
&#13;
&gt; <span class="codestrong1">tan(45)</span>&#13;
0.9999999999999999&#13;
&gt; <span class="codestrong1">atan(1)</span>&#13;
45.0&#13;
&gt; <span class="codestrong1">let TrigMode=45</span>&#13;
Invalid TrigMode.&#13;
&gt; <span class="codestrong1">let TrigMode=Rad</span>&#13;
TrigMode set to Rad.&#13;
&#13;
&gt; <span class="codestrong1">cos(pi)</span>&#13;
-1.0&#13;
&gt; <span class="codestrong1">2/4</span>&#13;
0.5&#13;
&gt; <span class="codestrong1">let NumMode=Frac</span>&#13;
NumMode set to Frac.&#13;
&#13;
&gt; <span class="codestrong1">2/4</span>&#13;
<span epub:type="pagebreak" id="page_309"/>1/2&#13;
&gt; <span class="codestrong1">reset</span>&#13;
** Welcome to TRAC! **&#13;
&#13;
  Modes: Rad, Float&#13;
  Enter ? for help.&#13;
&#13;
&gt; <span class="codestrong1">?</span>&#13;
Current TrigMode: Rad&#13;
To change TrigMode: to radians type:&#13;
   let TrigMode = Rad&#13;
To change TrigMode to degrees type:&#13;
   let TrigMode = Deg&#13;
&#13;
Current NumMode: Float&#13;
To change NumMode to float type:&#13;
   let NumMode: = Float&#13;
To change NumMode: to fraction type:&#13;
   let NumMode: = Frac&#13;
&#13;
To reset TRAC to defaults type:&#13;
   reset&#13;
&#13;
&gt;</pre>&#13;
<p class="indent">Pretty cool, eh?</p>&#13;
<h4 class="h4" id="ch00lev2sec_82"><strong><em>Making Sure TRAC Works Properly</em></strong></h4>&#13;
<p class="noindent">Given the nature of this application, it would be nice to have some degree of comfort that it’s performing the calculations properly. If you were using this to calculate the landing trajectory of a spaceship to the moon, it wouldn’t do to have it return a calculation that results in the spaceship flying out into empty space instead.</p>&#13;
<p class="indent">Of course one could sit down and manually enter a large number of test equations into TRAC and verify the results by entering the same equations on some other calculator and seeing if the results are the same. This clearly wouldn’t be much fun (or very efficient, for that matter). No, we want an automated process where we can have the computer do all the work. The approach we’re going to take is to build a procedure that will generate a random Racket expression. This expression can be evaluated using the Racket <span class="literal">eval</span> function to get a numeric value. In addition we’ll need a function that converts the Racket expression into a TRAC expression string. We can evaluate the TRAC expression to see if it returns the same value. We can then have the computer repeat this process thousands of times to make sure we don’t produce any mismatches.</p>&#13;
<p class="indent">Here’s the code for the random Racket expression generator.</p>&#13;
<pre><span epub:type="pagebreak" id="page_310"/>(define ops&#13;
  (vector&#13;
   (cons '+ 2) &#13;
   (cons '- 1) ; unary minus&#13;
   (cons '- 2) ; subtraction&#13;
   (cons '* 2) &#13;
   (cons '/ 2) &#13;
   (cons 'expt 2) &#13;
   (cons 'sin 1) &#13;
   (cons 'cos 1) &#13;
   (cons 'tan 1) &#13;
   (cons 'asin 1) &#13;
   (cons 'acos 1) &#13;
   (cons 'atan 1) &#13;
   (cons 'sqrt 1) &#13;
   (cons 'log 1) ; natural log&#13;
   (cons 'log 2) ; base n log&#13;
   ))&#13;
&#13;
(define (gen-racket)&#13;
  (let ([num-ops (vector-length ops)])&#13;
    (let loop ([d (random 1 5)])&#13;
      (if (= d 0)&#13;
          (exact-&gt;inexact (* (random) 1000000000))&#13;
          (let* ([op (vector-ref ops (random num-ops))]&#13;
                 [sym (car op)]&#13;
                 [args (cdr op)]&#13;
                 [next-d (sub1 d)])&#13;
            (if (= args 1)&#13;
                (list sym (loop next-d))&#13;
                (if (equal? sym 'log)&#13;
                    (list sym (loop next-d) 10)&#13;
                    (list sym (loop next-d) (loop next-d)))))))))</pre>&#13;
<p class="indent">An operator from the <span class="literal">ops</span> vector is randomly selected by the <span class="literal">gen-racket</span> function. Values in <span class="literal">ops</span> include both the operator symbol and the number of arguments it’s expecting (this is called its <em>arity</em>). Notice that both <span class="literal">log</span> and minus (<span class="literal">-</span>) have two different arities. The function call <span class="literal">log(x)</span> (base-10 logarithm) in TRAC is the same as <span class="literal">(log x 10)</span> in Racket. Then <span class="literal">gen-racket</span> will build an expression containing from one to five random operations or functions with random floating-point numeric arguments. The result is an actual Racket expression instead of an AST, where its arguments and functions are populated with random values.</p>&#13;
<p class="indent">Here’s a look at some of the expressions that <span class="literal">gen-racket</span> produces.</p>&#13;
<pre>&gt; <span class="codestrong1">(gen-racket)</span>&#13;
'(* (cos 25563340.24229431) (cos 112137357.31425005))&#13;
&#13;
<span epub:type="pagebreak" id="page_311"/>&gt; <span class="codestrong1">(gen-racket)</span>&#13;
'(log 502944961.7985059 10)&#13;
&#13;
&gt; <span class="codestrong1">(gen-racket)</span>&#13;
'(sqrt (tan (expt (sqrt 721196577.8863264) (+ 739078577.777451 744205482.2563056))))</pre>&#13;
<p class="indent">Most of the work involves converting the Racket expressions into TRAC expressions.</p>&#13;
<pre>(define (racket-&gt;trac expr)&#13;
  (let ([out-port (open-output-string)])&#13;
    (define (push str)&#13;
      (display str out-port))&#13;
    (let loop ([node expr])&#13;
      (if (number? node)&#13;
          (push (number-&gt;string node))&#13;
          (let* ([sym (car node)]&#13;
                 [sym (cond [(equal? sym 'expt) '^]&#13;
                            [(equal? sym 'log)&#13;
                             (if (= (length node) 2) 'ln 'log)]&#13;
                            [(equal? sym '-)&#13;
                             (if (= (length node) 2) 'neg '-)]&#13;
                            [else sym])]&#13;
                 [prop (get-prop sym)]&#13;
                 [prec (op-prec prop)]&#13;
                 [assoc (op-assoc prop)])&#13;
                 &#13;
            (define (need-paren arg side)&#13;
              (if (not (list? arg))&#13;
                  #f&#13;
                  (let ([arg-prec (op-prec (get-prop (car arg)))])&#13;
                    (cond [(&lt; arg-prec prec) #t]&#13;
                          [(&gt; arg-prec prec) #f]&#13;
                          [else (not (equal? assoc side))]))))&#13;
                          &#13;
            (define (push-op)&#13;
              (let* ([e1 (second node)]&#13;
                     [e2 (third node)]&#13;
                     [par1 (need-paren e1 'l)]&#13;
                     [par2 (need-paren e2 'r)])&#13;
                (when par1 (push "("))&#13;
                (loop e1)&#13;
                (when par1 (push ")"))&#13;
                (push (format " ~a "  sym))&#13;
                (when par2 (push "("))&#13;
                (loop e2)&#13;
                (when par2 (push ")"))))&#13;
                &#13;
            <span epub:type="pagebreak" id="page_312"/>(define (push-neg)&#13;
              (let* ([e (second node)]&#13;
                     [paren (need-paren e 'n)])&#13;
                (push "-")&#13;
                (when paren (push "("))&#13;
                (loop e)&#13;
                (when paren (push ")"))))&#13;
                &#13;
            (define (push-func)&#13;
              (push (format "~a"  sym))&#13;
              (push "(")&#13;
              (loop (second node))&#13;
              (push ")"))&#13;
              &#13;
            (match sym&#13;
              ['+ (push-op)]&#13;
              ['- (push-op)]&#13;
              ['* (push-op)]&#13;
              ['/ (push-op)]&#13;
              ['^ (push-op)]&#13;
              ['neg  (push-neg)]&#13;
              ['sin  (push-func)]&#13;
              ['cos  (push-func)]&#13;
              ['tan  (push-func)]&#13;
              ['asin (push-func)]&#13;
              ['acos (push-func)]&#13;
              ['atan (push-func)]&#13;
              ['ln   (push-func)]&#13;
              ['log  (push-func)]&#13;
              ['sqrt (push-func)])))&#13;
      (get-output-string out-port))))</pre>&#13;
<p class="indent">This is largely an adaptation of the <span class="literal">ast-&gt;string</span> function, but using the randomly generated Racket expressions created by <span class="literal">gen-racket</span> as input instead of the TRAC syntax tree. We’ve had to make some accommodations to account for the multiple arities of <span class="literal">-</span> and <span class="literal">log</span>. We also match against the literal function symbols. Aside from these considerations, the code should closely mirror that of <span class="literal">ast-&gt;string</span>. Here are a few samples of its output.</p>&#13;
<pre>&gt; <span class="codestrong1">(racket-&gt;trac (gen-racket))</span>&#13;
&#13;
"asin(tan(944670433.0 - 858658023.0 + (918652763.0 + 285573780.0)))"&#13;
&gt; <span class="codestrong1">(racket-&gt;trac (gen-racket))</span>&#13;
"sin(atan(364076270.0)) / sqrt(ln(536830818.0))"&#13;
&#13;
&gt; <span class="codestrong1">(racket-&gt;trac (gen-racket))</span>&#13;
"atan(978003385.0)"</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_313"/>The basic idea is to automate the following process:</p>&#13;
<pre>&gt; <span class="codestrong1">(define r (gen-racket))</span>&#13;
&gt; <span class="codestrong1">r</span>&#13;
'(+ (cos (atan 142163217.6660815)) (log (cos 528420918.36769867)))&#13;
&#13;
&gt; <span class="codestrong1">(define v1 (eval r))</span>&#13;
&gt; <span class="codestrong1">v1</span>&#13;
-1.021485300993499&#13;
&#13;
&gt; <span class="codestrong1">(define v2 (eval-ast (parse (racket-&gt;trac r))))</span>&#13;
&gt; <span class="codestrong1">v2</span>&#13;
-1.021485300993499&#13;
&#13;
&gt; <span class="codestrong1">(= v1 v2)</span>&#13;
#t</pre>&#13;
<p class="indent">So here’s our test bench:</p>&#13;
<pre>(define (test n)&#13;
  (for ([in-range n])&#13;
    (let* ([expr (gen-racket)]&#13;
           [v1 (eval expr)]&#13;
           [v2 (eval-ast (parse (racket-&gt;trac expr)))]&#13;
           [delta (magnitude (- v1 v2))])&#13;
      (when (&gt; delta 0)&#13;
        (displayln "Mismatch:")&#13;
        (printf "Racket: ~a\n" expr)&#13;
        (printf "TRAC: ~a\n" (racket-&gt;trac expr))&#13;
        (printf "v1: ~a, v2: ~a, delta: ~a\n\n" v1 v2 delta)))))</pre>&#13;
<p class="indent">The result of a computation could potentially result in a complex number (for example, <span class="literal">(sqrt -1)</span>), so we use <span class="literal">magnitude</span> to get the absolute value size of the difference between the values.</p>&#13;
<p class="indent">And here’s the output from an initial test run, which in fact indicated that the TRAC evaluation routine wasn’t always producing the correct results.</p>&#13;
<pre>&gt; <span class="codestrong1">(test 10)</span>&#13;
Mismatch:&#13;
Racket: (atan (atan (expt 137194961.20152807 513552901.52574974)))&#13;
TRAC: atan(atan(137194961.20152807 ^ 513552901.52574974))&#13;
v1: 1.0038848218538872, v2: 0.2553534898896325, delta: 0.7485313319642546&#13;
&#13;
Mismatch:&#13;
Racket: (- (log (expt (+ 67463417.07939068 342883686.1438599) (sin&#13;
     521439863.24302197))) (sqrt (+ (atan 402359159.5913063) (acos&#13;
     213010305.84288383))))&#13;
<span epub:type="pagebreak" id="page_314"/>TRAC: ln((67463417.07939068 + 342883686.1438599) ^ sin(521439863.24302197)) -&#13;
     sqrt(atan(402359159.5913063) + acos(213010305.84288383))&#13;
v1: -23.07001808516913-3.029949988703483i, v2:&#13;
     16.55567328478171+0.11164266488631025i, delta: 39.75003171002113</pre>&#13;
<p class="indent">The common thread in all the mismatches was the exponentiation operator <span class="literal">^</span> (mapped from Racket’s <span class="literal">expt</span> function), which was inadvertently defined with the division operator in <span class="literal">eval-ast</span> (the <span class="literal">eval-ast</span> code given above is correct, but you can introduce the same error if you want to test this). Once the correction was made, another test run produced the following result.</p>&#13;
<pre>&gt; <span class="codestrong1">(test 100000)</span>&#13;
&gt;</pre>&#13;
<p class="indent">In this case, no news is <em>good</em> news.</p>&#13;
<h4 class="h4" id="ch00lev2sec_83"><strong><em>Making an Executable</em></strong></h4>&#13;
<p class="noindent">There’s really no need to have TRAC dependent on the DrRacket environment. Only a few additional steps are required to create an executable file that can be launched without starting DrRacket. The first step is to simply add the <span class="literal">(start)</span> command to the last line of the definitions file (see below) so that the program starts executing immediately when launched.</p>&#13;
<pre>(start)</pre>&#13;
<p class="indent">Racket supports three different types of executables:</p>&#13;
<div class="bq5">&#13;
<p class="noindent"><strong>Launcher</strong> This type of executable will execute the current version of your <span class="literal">.rkt</span> source file, so it will include the path to the source file in the executable. This will allow your executable to immediately reflect any enhancements to your program. The downside is that you can’t move the source file elsewhere or easily share the executable with someone else.</p>&#13;
<p class="noindent"><strong>Standalone</strong> This version embeds the source file in the executable, so there’s no problem moving it to another location on your machine. A standalone executable still depends on the installed Racket DLLs, so it may not work properly if moved to a different machine.</p>&#13;
<p class="noindent"><strong>Distribution archive</strong> A distribution archive bundles all needed files into an install file. The install file can be used to install TRAC on another machine as long as the destination machine uses the same operating system as the one the archive was created on.</p>&#13;
</div>&#13;
<p class="indent">Before you create an executable, it’s recommended that debugging be turned off. This can be done by going to the <strong>Choose Language . . .</strong> dialog <span epub:type="pagebreak" id="page_315"/>(from the Language option on the main menu) and pressing the <strong>Show Details</strong> button. This will open a panel where you should select <strong>No Debugging</strong>. Once this is done, go to the Racket main menu, and from there select <strong>Create Executable . . .</strong> . In the dialog box, you may select which of the three different types of executables you want to create. It’s even possible to select a custom icon to give TRAC that personal touch.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10fig7">Figure 10-7</a> is a screenshot of TRAC running on our machine.</p>&#13;
<div class="image"><img alt="Image" src="../images/10fig07.jpg"/></div>&#13;
<p class="figcap" id="ch10fig7"><em>Figure 10-7: TRAC in action</em></p>&#13;
<h3 class="h3" id="ch00lev1sec_61">Summary</h3>&#13;
<p class="noindent">In this chapter, we leveraged our knowledge of abstract computing machines and various automata (introduced in the previous chapter) to build an interactive command line expression calculator. Along the way we learned about lexers (and using regular expressions to construct them), parsers (which construct abstract syntax trees), and interpreters. We used EBNF (extended Backus–Naur form) to specify our calculator grammar. Once we had our basic calculator built, we enhanced it with additional capabilities, such as handling complex numbers and hand degrees or radians. Just to be sure our calculator doesn’t give us bogus numbers, we built a simple test bench to make certain our code was robust.</p>&#13;
<p class="indent">Well, that just about concludes our Racket journey for now. But we’ve only scratched the tip of the iceberg. There’s much more capability that we haven’t even hinted at. We encourage you to further explore Racket on your own via the Racket website and other available literature. Happy learning!</p>&#13;
</body></html>