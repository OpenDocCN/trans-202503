- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Fracture
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Fracture
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'From our work so far, we have a few MXR Ads credentials, and we’ve uncovered
    the main ways that MXR Ads and GP handle their infrastructure, but we’re not sure
    what to do with our findings. We still have so many opportunities to explore,
    so we go back to the drawing board: a handful of GP and MXR Ads websites that
    we confirmed in Chapter 4 (see Listing 4-3). In Chapter 5, we followed our gut
    by courting the most alluring assets, the S3 buckets, which eventually led us
    to a server-side request forgery (SSRF) vulnerability. But now we’ll abide by
    a steadier and more strenuous approach.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经获得了一些MXR Ads的凭证，并且揭示了MXR Ads和GP处理其基础设施的主要方式，但我们不确定如何处理这些发现。我们仍然有许多机会去探索，因此我们回到原点：我们在第4章中确认的少数几个GP和MXR
    Ads网站（见清单4-3）。在第5章中，我们凭直觉追踪了最具吸引力的资源——S3桶，最终发现了一个服务器端请求伪造（SSRF）漏洞。但现在，我们将采取更稳妥、更艰苦的方法。
- en: We will go through each website, follow each link, inspect every parameter,
    and even gather hidden links in JavaScript files using something like LinkFinder
    ([https://github.com/GerbenJavado/LinkFinder/](https://github.com/GerbenJavado/LinkFinder/)).
    To do this we’ll inject carefully chosen special characters into forms and fields
    here and there until we trigger an anomaly, like an explicit database error, a
    404 (Page Not Found) error, or an unexpected redirection to the main page.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将浏览每个网站，跟踪每个链接，检查每个参数，甚至使用像 LinkFinder（[https://github.com/GerbenJavado/LinkFinder/](https://github.com/GerbenJavado/LinkFinder/)）这样的工具收集
    JavaScript 文件中的隐藏链接。为此，我们将把精心挑选的特殊字符注入到表单和字段中，直到触发异常反应，比如明确的数据库错误、404（页面未找到）错误，或者意外重定向到主页。
- en: 'We’ll rely on Burp to capture all of the parameters surreptitiously sent to
    the server. This maneuver depends heavily on the web framework behind the website,
    the programming language, the operating system, and a few other factors, so to
    help streamline the process we will inject the following payload and compare the
    output to the application’s normal response:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依赖 Burp 来悄悄捕获所有发送到服务器的参数。这个操作高度依赖于网站背后的网络框架、编程语言、操作系统和其他几个因素，因此，为了简化过程，我们将注入以下有效载荷，并将输出与应用程序的正常响应进行比较：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This string covers the most obvious occurrences of injection vulnerabilities
    for different frameworks: (No)SQL, system commands, templates, Lightweight Directory
    Access Protocol (LDAP), and pretty much any component using special characters
    to extend its query interface. The `dddd` part is like a label, some easy-to-spot
    text to help us visually locate the payload in the page’s response. A page that
    reacts even slightly unexpectedly to this string, like with an error page, a curious
    redirection, truncated output, or an input parameter reflected in the page in
    a weird way, is a promising lead worth investigating further. If the web page
    returns an innocuous response but seems to have transformed or filtered the input
    somehow, then we can probe further using more advanced payloads, like adding logical
    operators (`AND 1=0`), pointing to a real file location, trying a real command,
    and so on.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字符串覆盖了不同框架中最明显的注入漏洞：（无）SQL、系统命令、模板、轻量级目录访问协议（LDAP），以及几乎所有使用特殊字符扩展查询接口的组件。`dddd`部分像一个标签，作为一些易于发现的文本，帮助我们在页面响应中直观地定位有效载荷。页面对这个字符串做出轻微异常反应（比如错误页面、奇怪的重定向、截断的输出，或者输入参数以奇怪的方式反映在页面上），都是值得进一步调查的有前景线索。如果网页返回了一个无害的响应，但似乎以某种方式转换或过滤了输入，我们可以通过更先进的有效载荷进一步探测，比如添加逻辑运算符（`AND
    1=0`）、指向真实文件位置、尝试实际命令等等。
- en: We begin injecting this payload into the forms on each site in our list. Soon
    enough, we reach the URL www.surveysandstats.com, the infamous website used to
    collect and probe data on people’s personalities, which we uncovered in Chapter
    4\. This has plenty of fields to inject our promiscuous string into. We enter
    it into a form, hit Submit, and are greeted with the delightful error page in
    [Figure 6-1](#figure6-1).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始将这个有效载荷注入到我们列表中每个网站的表单中。不久，我们到达了网址 www.surveysandstats.com，这是一个臭名昭著的网站，用来收集并探查人们的个性数据，我们在第4章中揭示了这个网站。这里有许多字段可以注入我们的放荡字符串。我们将其输入到一个表单中，点击提交，接着看到令人愉快的错误页面，如[图6-1](#figure6-1)所示。
- en: '![f06001](image_fi/501263c06/f06001.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![f06001](image_fi/501263c06/f06001.png)'
- en: 'Figure 6-1: *Surveysandstats.com* reacts to our string injection'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1：*Surveysandstats.com* 对我们的字符串注入做出反应
- en: Aha! That’s the kind of error that can make a hacker squirm with excitement.
    We turn to Burp and submit the form again, this time with perfectly innocent responses
    to the survey question with no special characters, just plain English, to make
    sure that the form normally works (see [Figure 6-2](#figure6-2)). When performing
    normally, the form should send us an email confirmation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！这就是让黑客兴奋不已的那种错误。我们转向Burp，再次提交表单，这次使用完全无害的调查问题回答，且没有任何特殊字符，仅仅是简单的英文，以确保表单正常工作（见[图6-2](#figure6-2)）。表单正常工作时，应该会发送一封电子邮件确认。
- en: '![f06002](image_fi/501263c06/f06002.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![f06002](image_fi/501263c06/f06002.png)'
- en: 'Figure 6-2: A regular form submission in Burp'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-2：Burp中的常规表单提交
- en: And sure enough, a couple of seconds later, we receive an email with the results
    of the survey (see [Figure 6-3](#figure6-3)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，几秒钟后，我们收到了带有调查结果的电子邮件（见[图6-3](#figure6-3)）。
- en: '![f06003](image_fi/501263c06/f06003.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![f06003](image_fi/501263c06/f06003.png)'
- en: 'Figure 6-3: Email reply from our normal survey submission'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-3：来自我们正常调查提交的电子邮件回复
- en: 'The survey is working just fine, which means it’s likely that it was indeed
    some special character in our payload that caused the page to crash the first
    time. To pin down which character, we replay the previous normal form entry, adding
    one special character from our payload at a time until we close in on the suspect:
    `{{` (the double braces). We may very well be dealing with a server-side template
    injection (SSTI) since templates often rely on double braces.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 调查表运行得很好，这意味着第一次崩溃页面的确很可能是因为我们的有效载荷中某个特殊字符。为了确认是哪个字符，我们重新提交之前的正常表单条目，每次添加一个特殊字符，直到我们确定嫌疑字符：`{{`（双大括号）。我们很可能正在处理服务器端模板注入（SSTI），因为模板通常依赖于双大括号。
- en: Server-Side Template Injection
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端模板注入
- en: 'In many web development frameworks, templates are simple HTML files annotated
    with special variables that get replaced at runtime with dynamic values. Here
    are some of those special variables used in various frameworks:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多Web开发框架中，模板是简单的HTML文件，并带有一些特殊变量，这些变量在运行时会被动态值替换。以下是一些在各种框架中使用的特殊变量：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This separation between the frontend of a web project (visualization in HTML/JavaScript)
    and the backend (controller or model in Python/Ruby/Java) is the cornerstone of
    many development frameworks and indeed many team organizations. The fun begins
    when the template itself is built dynamically using untrusted input. Take the
    following code, for instance. It produces a dynamic template using the `render_template_string`
    function, which is itself built using user input:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Web项目的前端（HTML/JavaScript中的可视化）和后端（Python/Ruby/Java中的控制器或模型）之间的分离是许多开发框架乃至许多团队组织的基石。当模板本身是通过不受信任的输入动态构建时，问题就开始了。比如以下代码，它通过`render_template_string`函数生成动态模板，而该函数本身是通过用户输入构建的：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this Python snippet, if we were to inject a valid template directive like
    `{{8*2}}` in the `user_input` variable, it would be evaluated to 16 by the `render_template_string`
    method, meaning the page would display the result `16`. The tricky thing is that
    every template engine has its own syntax, so not all would evaluate it in this
    way. While some will let you read files and execute arbitrary code, others will
    not even let you perform simple multiplication.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段Python代码中，如果我们在`user_input`变量中注入一个有效的模板指令，如`{{8*2}}`，它将通过`render_template_string`方法计算为16，这意味着页面将显示结果`16`。问题在于，每个模板引擎都有自己独特的语法，因此并不是所有的模板引擎都会这样进行计算。有些模板引擎允许你读取文件并执行任意代码，而其他的则甚至不允许你进行简单的乘法运算。
- en: That’s why our first order of business is to gather more information about this
    potential vulnerability. We need to figure out what language we are dealing with
    and which framework it is running.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们首先要做的事情是收集更多有关该潜在漏洞的信息。我们需要弄清楚正在使用的是什么语言以及运行的是什么框架。
- en: Fingerprinting the Framework
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 框架指纹识别
- en: Since his presentation on SSTI at Black Hat USA 2015, James Kettle’s famous
    diagram depicting ways to fingerprint a templating framework has been ripped off
    in every article you may come across about this vulnerability, including here
    in [Figure 6-4](#figure6-4). To explore how it works, we’ll enter a few different
    expressions in our survey form to see how they’re executed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 自从James Kettle在2015年Black Hat USA大会上展示SSTI以来，他的著名图表描绘了识别模板框架的方法，几乎在每一篇关于该漏洞的文章中都能看到，包括在[图6-4](#figure6-4)中。为了探索它是如何工作的，我们将在调查表中输入一些不同的表达式，看看它们是如何被执行的。
- en: '![f06004](image_fi/501263c06/f06004.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![f06004](image_fi/501263c06/f06004.png)'
- en: 'Figure 6-4: Different SSTI payloads to fingerprint the templating framework'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-4：不同的SSTI载荷用于指纹识别模板框架
- en: 'We send the payload `{{8 * ''2''}}` and receive in response an email containing
    the string `2` repeated a total of eight times, as shown in [Figure 6-5](#figure6-5).
    This behavior is typical of a Python interpreter, as opposed to a PHP environment,
    for example, which would have printed `16` instead:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发送载荷`{{8 * '2'}}`，并收到一封电子邮件，邮件内容是字符串`2`重复八次，如[图6-5](#figure6-5)所示。这种行为是典型的Python解释器行为，而不像PHP环境，后者会打印`16`。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![f06005](image_fi/501263c06/f06005.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![f06005](image_fi/501263c06/f06005.png)'
- en: 'Figure 6-5: Typical Python output for an input of `8 * ''2''`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-5：输入`8 * '2'`的典型Python输出
- en: 'From this we quickly come to the conclusion that we are probably dealing with
    the famous Jinja2 template used in Python environments. Jinja2 usually runs on
    one of two major web frameworks: Flask or Django. There was a time when a quick
    look at the “Server” HTTP response header would reveal which. Unfortunately, nobody
    exposes their Flask/Django application naked on the internet anymore. They instead
    go through Apache and Nginx servers or, in this case, an AWS load balancer that
    covers the original server directive.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们很快得出结论，我们可能正在处理Python环境中著名的Jinja2模板。Jinja2通常运行在两大主流Web框架之一：Flask或Django上。曾几何时，通过快速查看“服务器”HTTP响应头就能知道是哪一个。不幸的是，现在没有人再将Flask/Django应用程序裸露在互联网上了。它们通常通过Apache和Nginx服务器，或者在这个案例中，通过覆盖原始服务器指令的AWS负载均衡器。
- en: 'Not to worry. There is a quick payload that works on both Flask and Django
    Jinja2 templates, and it’s a good one: `request.environ`. In both frameworks,
    this Python object holds information about the current request: HTTP method, headers,
    user data, and, most importantly, environment variables loaded by the app.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心。有一个快速的载荷可以在Flask和Django Jinja2模板中都有效，而且它非常好用：`request.environ`。在这两个框架中，这个Python对象包含有关当前请求的信息：HTTP方法、头信息、用户数据，最重要的是，应用加载的环境变量。
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[Figure 6-6](#figure6-6) shows the response we get from this payload.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-6](#figure6-6)展示了我们从这个载荷获得的响应。'
- en: '![f06006](image_fi/501263c06/f06006.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![f06006](image_fi/501263c06/f06006.png)'
- en: 'Figure 6-6: Response from `request.environ`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-6：来自`request.environ`的响应
- en: 'Django literally appears in the `PYENV_DIR` path. Jackpot. The developers of
    this application seem to have decided to replace the default Django templating
    engine with the more powerful Jinja2 templating framework. This is lucky for us,
    because while Jinja2 supports a subset of Python expressions and operations that
    give it the edge in terms of performance and productivity, this flexibility comes
    at a steep price: we can manipulate Python objects, create lists, call functions,
    and even load modules in some cases.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Django字面上出现在`PYENV_DIR`路径中。中奖了。这个应用程序的开发者似乎决定用更强大的Jinja2模板框架替代默认的Django模板引擎。这对我们来说是幸运的，因为虽然Jinja2支持Python表达式和操作的一个子集，使其在性能和生产力方面更具优势，但这种灵活性是有代价的：我们可以操作Python对象、创建列表、调用函数，甚至在某些情况下加载模块。
- en: Arbitrary Code Execution
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任意代码执行
- en: It’s almost tempting to jump ahead and attempt to access the password files
    with a payload like `{{os.open('/etc/passwd')}}`, but that would not work. The
    `os` object is not likely defined in the current context of the application. We
    can only interact with Python objects and methods defined in the page rendering
    the response. The `request` object we accessed earlier is automatically passed
    by Django to the template, so we can naturally retrieve it. The `os` module? Highly
    unlikely.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎让人忍不住想提前跳跃，尝试通过像`{{os.open('/etc/passwd')}}`这样的载荷来访问密码文件，但那是行不通的。`os`对象很可能在当前应用程序的上下文中未定义。我们只能与在渲染响应的页面中定义的Python对象和方法交互。我们之前访问过的`request`对象是Django自动传递给模板的，因此我们可以自然地检索它。`os`模块？极不可能。
- en: But, and it is a most fortunate *but*, most modern programming languages provide
    us with some degree of introspection and reflection—*reflection* being the ability
    of a program, object, or class to examine itself, including listing its own properties
    and methods, changing its internal state, and so on. This is a common feature
    of many high level languages like C#, Java, Swift—and Python is no exception.
    Any Python object contains attributes and pointers to its own class properties
    and those of its parents.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，*幸运的是*，大多数现代编程语言都为我们提供了某种程度的内省和反射——*反射*是指程序、对象或类能够检查自身的能力，包括列出自己的属性和方法、改变其内部状态等。这是许多高级语言（如C#、Java、Swift）中的常见特性，而Python也不例外。任何Python对象都包含属性以及指向其自身类属性和父类属性的指针。
- en: 'For instance, we can fetch the class of any Python object using the `__class__`
    attribute, which returns a valid Python object referencing this class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用`__class__`属性获取任何Python对象的类，它返回一个有效的Python对象，引用该类：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That class is itself a child class of a higher Python object called `django.http.request.HttpRequest`.
    We did not even have to read the docs to find this out; it’s written in the object
    itself, inside the `__base__` variable, as we can see with this payload:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 该类本身是一个更高层次的Python对象的子类，名为`django.http.request.HttpRequest`。我们甚至不需要阅读文档来发现这一点；它直接写在对象内部，在`__base__`变量里，我们可以通过这个有效载荷看到这一点：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We continue climbing the inheritance chain, adding `__base__` to the payload,
    until we reach the top-most Python object 1, the parent of all classes: `object`.
    In and of itself, the `object` class is useless, but like all other classes, it
    contains references to its subclasses as well. So after climbing up the chain,
    it’s now time to go down using the `__subclasses__` method:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续沿着继承链向上爬升，将`__base__`添加到有效载荷中，直到到达最顶层的Python对象1——所有类的父类：`object`。`object`类本身没有任何用处，但像所有其他类一样，它也包含对其子类的引用。因此，在沿着链向上爬升后，现在是时候使用`__subclasses__`方法向下爬升了：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: More than 300 classes show up. These are all the classes inheriting directly
    from the `object` class and loaded by the current Python interpreter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 超过300个类出现在这里。这些是所有直接从`object`类继承并由当前Python解释器加载的类。
- en: 'I hope you caught the `subprocess.Popen` class 1! This is the class used to
    execute system commands. We can call that object right here, right now, by referencing
    its offset in the list of subclasses, which happens to be number 282 in this particular
    case (figured out with a manual count). We can capture the output of the `env`
    command using the `communicate` method:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你已经注意到`subprocess.Popen`类1！这是用于执行系统命令的类。我们可以立即在这里调用该对象，通过引用它在子类列表中的偏移量，在这个特定情况下它是第282个（通过手动计数得出的）。我们可以使用`communicate`方法捕获`env`命令的输出：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We just achieved arbitrary code execution! Let’s see what we have of use. All
    Django settings are usually declared in a file called *settings.py* located at
    the root of the application. This file can contain anything from a simple declaration
    of the admin email to secret API keys. We know from the environment variables
    that the application’s full path is */opt/Django/surveysapp*, and the *settings*
    file is usually one directory below that (with the same name). In [Listing 6-1](#listing6-1),
    we try to access it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚实现了任意代码执行！让我们看看我们能用什么。所有Django设置通常都在一个名为*settings.py*的文件中声明，该文件位于应用程序的根目录。这个文件可以包含从简单的管理员电子邮件声明到秘密API密钥的任何内容。从环境变量中我们知道应用程序的完整路径是*/opt/Django/surveysapp*，而*settings*文件通常位于该路径下一级目录（同名）。在[列表6-1](#listing6-1)中，我们尝试访问它。
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 6-1: Accessing the *surveysandstats.com* settings file'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-1：访问*surveysandstats.com*设置文件
- en: We get some credentials for SES 12 (Simple Email Service), an AWS-managed email
    service that provides an SMTP gateway, POP3 server, and so forth. This is totally
    expected, since the application’s main activity is to send email results to candidates.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取了SES 12（简单邮件服务）的凭据，它是一个AWS托管的邮件服务，提供SMTP网关、POP3服务器等。这完全是预料之中的，因为应用程序的主要活动是将电子邮件结果发送给候选人。
- en: 'These credentials will probably have a very narrow scope of action, like sending
    emails. We can try to be creative and phish some admins using this newly acquired
    capability, but right now, these credentials will serve a more pressing goal:
    confirming that *surveysandstats.com* indeed belongs to MXR Ads or is at least
    running in the same AWS environment before we spend any more time on it.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些凭证可能具有非常有限的作用范围，比如发送邮件。我们可以尝试发挥创意，利用这个新获得的能力钓鱼攻击一些管理员，但现在，这些凭证将服务于一个更迫切的目标：在我们花更多时间之前，确认
    *surveysandstats.com* 确实属于 MXR Ads 或至少在相同的 AWS 环境中运行。
- en: Confirming the Owner
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确认所有者
- en: You might remember that we found the sketchy *surveysandstats.com* website while
    hunting for public notes on Gist and Pastebin in Chapter 4\. For all we know,
    this could be an entirely separate organization unrelated to our true target.
    Let’s find out. First, we’ll try to get the account ID, which is one API call
    away and does not require any set of special permissions, so we can use the SES
    keys we just found. Every AWS IAM user by default has access to this information.
    In [Listing 6-2](#listing6-2), we use the access key 1 and secret key 2 we got
    from [Listing 6-1](#listing6-1) to grab the account ID.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得我们在第四章中通过在 Gist 和 Pastebin 上查找公共笔记时，发现了那个可疑的 *surveysandstats.com* 网站。根据我们目前知道的，它可能是一个与我们的真正目标无关的完全独立的组织。让我们查明真相。首先，我们将尝试获取账户
    ID，这只需一次 API 调用，并且不需要任何特殊权限，因此我们可以使用刚刚找到的 SES 密钥。每个默认情况下都有访问此信息的 AWS IAM 用户。在
    [清单 6-2](#listing6-2) 中，我们使用了从 [清单 6-1](#listing6-1) 获取的访问密钥 1 和秘密密钥 2 来获取账户 ID。
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 6-2: Tracing the *surveysandstats**.com* account ID'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-2：追踪 *surveysandstats.com* 账户 ID
- en: 'Right on track: 886371554408 is the same AWS account ID we found for the MXR
    Ads demo application in Chapter 5\. We are in business!'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正在按计划进行：886371554408 是我们在第五章中找到的与 MXR Ads 演示应用程序相关的相同 AWS 账户 ID。我们成功了！
- en: Smuggling Buckets
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 偷运桶
- en: Now, we want nothing more than to drop a reverse shell and quietly sip a cup
    of coffee while some post-exploit plug-in sifts through gigabytes of data looking
    for passwords, secrets, and other gems. But life doesn’t always cooperate.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们唯一想做的就是植入一个反向 Shell，然后安静地喝着咖啡，同时让一些后期利用插件筛查几GB的数据，寻找密码、秘密和其他宝贵的东西。但生活并不总是如此顺利。
- en: 'When we try loading any file from the custom domain we created in Chapter 3
    as part of our attacking infrastructure, the request never makes it home:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试从我们在第三章创建的自定义域加载任何文件时，请求始终无法到达目标：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Some sort of filter seems to block HTTP requests going to the outside world.
    Fair enough. We’ll try going in the opposite direction and query the metadata
    API 169.254.169.254\. This default AWS endpoint helped us glean much information
    on the demo app in Chapter 5\. Hopefully, it will give us more credentials to
    play with . . . or not:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 某种过滤器似乎阻止了 HTTP 请求向外界发送。也没关系。我们将尝试反向操作，查询元数据 API 169.254.169.254。这个默认的 AWS 端点帮助我们在第五章的示例应用程序中获取了很多信息。希望它能为我们提供更多的凭证供我们操作……或者不会：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Unfortunately, every time we exploit this SSTI vulnerability, we’re triggering
    emails carrying the command’s output. Not exactly a stealthy attack vector. MXR
    Ads sure did a good job locking its egress traffic. Though this a common security
    recommendation, very few companies actually dare to implement traffic filtering
    systematically on its machines, mainly because it requires a heavy setup to handle
    a few legitimate edge cases, such as checking updates and downloading new packages.
    The mxrads-dl bucket we came across in Chapter 5 makes total sense now: it must
    act like a local repository mirroring all public packages needed by servers. Not
    an easy environment to maintain, but it pays off in situations like this one.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，每次我们利用这个 SSTI 漏洞时，都会触发带有命令输出的邮件。可不是一个隐秘的攻击向量。MXR Ads 还真是做得不错，锁住了它的外发流量。虽然这是一个常见的安全建议，但很少有公司敢于在其机器上系统性地实施流量过滤，主要是因为这需要大量的设置来处理一些合法的边缘案例，比如检查更新和下载新包。我们在第五章中遇到的
    mxrads-dl 桶现在完全有意义：它必须充当一个本地仓库，镜像所有服务器需要的公共包。这样的环境不容易维护，但在像这样的情况下却是值得的。
- en: 'One question, though: how does MXR Ads explicitly allow traffic to the mxrads-dl
    bucket? Security groups (AWS Firewall rules) are layer 4 components that only
    understand IP addresses, which in the case of an S3 bucket may change, depending
    on many factors. So how can the *surveysandstats.com* website still reach the
    mxrads-dl bucket, yet fail to send packets to the rest of the internet?'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 不过有一个问题：MXR Ads是如何明确允许流量访问mxrads-dl存储桶的呢？安全组（AWS防火墙规则）是第4层组件，只能识别IP地址，而S3存储桶的IP地址可能会发生变化，这取决于许多因素。那么，*surveysandstats.com*网站是如何仍然能够访问mxrads-dl存储桶，却无法向互联网的其他部分发送数据包的呢？
- en: One possible solution is to whitelist all of S3’s IP range in a given region,
    like 52.218.0.0/17, 54.231.128.0/19, and so on. However, this method is ugly,
    flaky at best, and barely gets the job done.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是将S3在给定区域的所有IP范围列入白名单，例如52.218.0.0/17、54.231.128.0/19等。然而，这种方法不仅丑陋，而且非常不稳定，勉强能完成任务。
- en: 'A more scalable and cloud-friendly approach is to create an S3 VPC endpoint
    (see [https://docs.aws.amazon.com/glue/latest/dg/vpc-endpoints-s3.html](https://docs.aws.amazon.com/glue/latest/dg/vpc-endpoints-s3.html)for
    details). It’s simpler than it sounds: a *virtual private cloud* (VPC), is an
    isolated private network from which companies run their machines. It can be broken
    into many subnets, just like any regular router interface. AWS can plug a special
    endpoint URL into that VPC that will route traffic to its core services, like
    S3\. Instead of going through the internet to reach S3, machines on that VPC will
    contact that special URL, which channels traffic through Amazon’s internal network
    to reach S3\. That way, rather than whitelisting external IPs, one can simply
    whitelist the VPC’s internal range (10.0.0.0/8), thus avoiding any security issues.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更具可扩展性且适应云环境的方法是创建一个S3 VPC端点（详见[https://docs.aws.amazon.com/glue/latest/dg/vpc-endpoints-s3.html](https://docs.aws.amazon.com/glue/latest/dg/vpc-endpoints-s3.html)）。这比听起来简单：*虚拟私有云*（VPC）是一个与外界隔离的私有网络，企业在其中运行自己的机器。它可以被划分为多个子网，就像任何普通的路由器接口一样。AWS可以将一个特殊的端点URL插入到这个VPC中，该URL会将流量路由到其核心服务，比如S3。机器不会通过互联网访问S3，而是会联系这个特殊的URL，流量通过亚马逊的内部网络被传递到S3。这样，与其在外部IP地址上设置白名单，不如简单地将VPC的内部地址范围（10.0.0.0/8）加入白名单，从而避免任何安全问题。
- en: The devil is in the details, though, as a VPC endpoint is only ever aware of
    the AWS service the machine is trying to reach. It does not care about the bucket
    or the file it is looking for. The bucket could even belong to another AWS account,
    and the traffic would still flow through the VPC endpoint to its destination!
    So technically, even though MXR Ads seemingly sealed off the survey app from the
    internet, we could still smuggle in a request to a bucket in our own AWS account
    and get the app to run a file we control. Let’s test this theory.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但问题的关键在于细节，因为VPC端点仅关注机器试图访问的AWS服务。它并不关心存储桶或文件。存储桶甚至可能属于另一个AWS账户，但流量仍然会通过VPC端点流向目标！因此，从技术上讲，即使MXR
    Ads似乎封锁了调查应用程序与互联网的连接，我们仍然可以偷偷地向自己AWS账户中的存储桶发出请求，并让该应用程序运行我们控制的文件。让我们来测试这个理论。
- en: We’ll upload a dummy HTML file named *beaconTest.html* to one of our buckets
    and make it public by granting `GetObject` permission to everyone.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将上传一个名为*beaconTest.html*的虚拟HTML文件到我们的某个存储桶，并通过授予`GetObject`权限给所有人，使其公开。
- en: 'We first create a bucket called mxrads-archives-packets-linux:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为mxrads-archives-packets-linux的存储桶：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we upload a dummy file to our bucket and name it *beaconTest.html*:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们将一个虚拟文件上传到我们的存储桶并命名为*beaconTest.html*：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We then make that file public:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将该文件设为公开：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we proceed to fetch *beaconTest.html* through the *surveysandstats.com*
    website. If everything works as anticipated, we should get dummy HTML content
    back in response:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们开始通过*surveysandstats.com*网站获取*beaconTest.html*文件。如果一切按预期工作，我们应该会收到虚拟HTML内容的响应：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It was a long shot, but boy did it pay off! We’ve found a reliable way to communicate
    with the outside world from this otherwise sealed-off survey app. Using S3 files,
    we can now design a quasi-interactive protocol to execute code on this isolated
    machine.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这虽然是个长远的尝试，但确实值得！我们找到了一个可靠的方式，可以从这个完全封闭的调查应用程序与外界进行通信。通过使用S3文件，我们现在可以设计一个准互动协议，在这个隔离的机器上执行代码。
- en: Quality Backdoor Using S3
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用S3的质量后门
- en: We’ll develop an agent-operator system to easily execute code and retrieve the
    output on the surveysandstatsmachine. The first program on our server, known as
    the *operator*, will write commands to a file called *hello_req.txt*. A second
    program running on the survey site—the *agent*—will fetch *hello_req.txt* every
    couple of seconds, execute its contents, and upload the results to the file *hello_resp.txt*
    on S3\. Our operator will routinely inspect this file and print its contents.
    This exchange is illustrated in [Figure 6-7](#figure6-7).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个代理-操作员系统，以便轻松执行代码并在`surveysandstatsmachine`上获取输出。我们服务器上的第一个程序，被称为*操作员*，将命令写入一个名为*hello_req.txt*的文件。运行在调查网站上的第二个程序——*代理*——每隔几秒钟会获取一次*hello_req.txt*文件，执行其内容，并将结果上传到S3上的*hello_resp.txt*文件。我们的操作员将定期检查这个文件并打印其内容。这个交换过程在[图6-7](#figure6-7)中有所展示。
- en: '![f06007](image_fi/501263c06/f06007.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![f06007](image_fi/501263c06/f06007.png)'
- en: 'Figure 6-7: Command execution through S3 files'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-7：通过S3文件执行命令
- en: The operator will have full access to the mxrads-archives-packets-linux bucket
    since it will be running on our own trusted server with the required AWS credentials.
    The agent only needs the `PutObject` permission on the *hello_resp.txt* file and
    `GetObject` on *hello_req.txt*. That way, even if an analyst ventures too close,
    they will only be able to take a peek at the last command sent, not the actual
    response.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员将拥有对`mxrads-archives-packets-linux`桶的完全访问权限，因为它将在我们自己信任的服务器上运行，并且具有所需的AWS凭证。代理只需要对*hello_resp.txt*文件具有`PutObject`权限，并对*hello_req.txt*文件具有`GetObject`权限。这样，即使分析师靠得太近，他们也只能看到最后发送的命令，而无法看到实际的响应。
- en: I’ve made a basic implementation of the operator and agent available on GitHub
    at [https://github.com/HackLikeAPornstar/GreschPolitico/tree/master/S3Backdoor/](https://github.com/HackLikeAPornstar/GreschPolitico/tree/master/S3Backdoor/)if
    you would like to play with them, tweak them, and extend them with even more features.
    We will go through some of the highlights of the code in the following sections.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在GitHub上提供了操作员和代理的基本实现，地址是[https://github.com/HackLikeAPornstar/GreschPolitico/tree/master/S3Backdoor/](https://github.com/HackLikeAPornstar/GreschPolitico/tree/master/S3Backdoor/)，如果你想进行实验、调整或为其添加更多功能，可以随意操作。接下来的章节中我们将回顾一些代码的亮点。
- en: Creating the Agent
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建代理
- en: As you may have noticed if you glanced at the repo, I decided to write the agent
    in Golang, because it’s fast, yields a statically linked executable, and is much
    more productive and friendlier than C/C++. The `main` function sets up the required
    variables, like the filenames and the HTTP connector, and then enters the main
    loop, as shown in [Listing 6-3](#listing6-3).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能从仓库中一瞥中注意到的，我决定用Golang编写代理，因为它运行速度快，生成的是静态链接的可执行文件，并且比C/C++更高效、友好。`main`函数设置所需的变量，如文件名和HTTP连接器，然后进入主循环，如[清单6-3](#listing6-3)所示。
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 6-3: Setting up the agent variables'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-3：设置代理变量
- en: Our interactions with S3 will be through HTTP REST queries (GET for fetching
    content and PUT for uploading data) to avoid any weird permission overlap with
    the machine’s role. See this book’s resources at [https://nostarch.com/how-hack-ghost/](https://nostarch.com/how-hack-ghost/)
    for the appropriate S3 policy to put in place.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与S3的交互将通过HTTP REST查询（GET用于获取内容，PUT用于上传数据）进行，以避免与机器角色产生任何奇怪的权限重叠。有关适当的S3策略，请参见本书的资源：[https://nostarch.com/how-hack-ghost/](https://nostarch.com/how-hack-ghost/)。
- en: In [Listing 6-4](#listing6-4), we set the agent to download data to execute
    from the `reqURL` by executing the `fetchData` method every two seconds.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单6-4](#listing6-4)中，我们通过每两秒执行一次`fetchData`方法，设置代理从`reqURL`下载要执行的数据。
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 6-4: Downloading the data'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-4：下载数据
- en: If the file has been altered since the last visit (HTTP status code 200 indicates
    an alteration), then new commands are available for execution via the `execCmd`
    method. Otherwise, we receive an HTTP 304 (Not Modified) response and silently
    try again in a few seconds.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自上次访问以来文件已被修改（HTTP状态码200表示已修改），那么新的命令将通过`execCmd`方法可供执行。否则，我们会收到HTTP 304（未修改）响应，并在几秒钟后悄悄重试。
- en: Results are then sent back to the bucket (via the `uploadData` method). The
    next section, shown in [Listing 6-5](#listing6-5), creates the `uploadData` method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 结果随后将通过`uploadData`方法返回到桶中。下一个部分（见[清单6-5](#listing6-5)）创建了`uploadData`方法。
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 6-5: The `uploadData` method of the agent'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-5：代理的`uploadData`方法
- en: 'The `uploadData` method is a classic HTTP PUT request, but here we have one
    small extra subtlety: the `x-amz-acl` header. This header instructs AWS to transfer
    ownership of the uploaded file to the destination bucket owner, which is us. Otherwise,
    the file would keep its original ownership and we wouldn’t be able to use the
    S3 API to retrieve it. If you’re curious about the anatomy of the functions `execCmd`,
    `fetchData`, and `uploadData`, do not hesitate to check out the code in the book’s
    GitHub repo.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`uploadData`方法是一个经典的HTTP PUT请求，但这里有一个小的额外细节：`x-amz-acl`头部。这个头部指示AWS将上传文件的所有权转移到目标桶的所有者，即我们。如果没有这个头部，文件将保持原来的所有权，我们将无法使用S3
    API来检索它。如果你对`execCmd`、`fetchData`和`uploadData`函数的实现感兴趣，别犹豫，去看看书本GitHub仓库里的代码。'
- en: The first crucial requirement in writing such an agent is stability. We will
    drop it behind enemy lines, so we need to properly handle all errors and edge
    cases. The wrong exception could crash the agent and, with it, our remote access.
    Who knows if the template injection vulnerability will still be there the next
    day?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 编写此类代理程序的第一个关键要求是稳定性。我们将其投放到敌方阵地，因此需要妥善处理所有错误和边缘情况。错误的异常可能导致代理崩溃，从而失去我们的远程访问权限。谁知道模板注入漏洞第二天还会不会存在呢？
- en: Golang takes care of exceptions by not having them in the first place. Most
    calls return an error code that should be checked before moving forward. As long
    as we religiously follow this practice, along with a couple of other good coding
    practices like checking for nil pointers before dereferencing, we should be relatively
    safe. Second comes concurrency. We do not want to lose the program because it
    is busy running a `find` command that drains the agent’s resources for 20 minutes.
    That’s why we encapsulated the `execCmd` and `uploadData` methods in a goroutine
    (prefix `go func()`. . .).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Golang通过从一开始就不引入异常来处理异常。大多数调用返回一个错误代码，在继续之前应该检查该错误代码。只要我们严格遵循这一做法，并且遵守其他一些良好的编码习惯，比如在解引用之前检查空指针，我们应该相对安全。其次是并发性。我们不希望因为程序在执行一个`find`命令而导致代理的资源消耗20分钟，进而使程序崩溃。这就是为什么我们将`execCmd`和`uploadData`方法封装在一个goroutine中（前缀`go
    func()...`）。
- en: Think of a goroutine as a set of instructions running in parallel to the rest
    of the code. All routines share the same thread as the main program, thus sparing
    a few data structures and the expensive context switching usually performed by
    the kernel when jumping from one thread to another. To give you a practical comparison,
    a goroutine allocates around 4KB of memory, whereas an OS thread roughly takes
    1MB. You can easily run hundreds of thousands of goroutines on a regular computer
    without breaking a sweat.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将goroutine看作是与其余代码并行执行的一组指令。所有的goroutine共享与主程序相同的线程，从而节省了一些数据结构和通常由内核在从一个线程切换到另一个线程时所做的昂贵的上下文切换。为了给你一个实际的对比，goroutine分配大约4KB的内存，而操作系统线程大约需要1MB。你可以在一台普通计算机上轻松运行数十万个goroutine而不会出现问题。
- en: 'We compile the source code into an executable called *runcdd* and upload it
    to our S3 bucket where it will sit tight, ready to serve:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将源代码编译成一个名为*runcdd*的可执行文件，并将其上传到我们的S3桶中，它将静静地待在那里，随时待命：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: One of a few annoying things with Go is that it bloats the final binary with
    symbols, file paths, and other compromising data. We strip off some symbols with
    the `-s` flag and debug info with `-w`, but know that an analyst can dig up a
    good deal of information about the environment used to produce this executable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Go的一些令人烦恼的地方之一是，它会将最终的二进制文件膨胀，包含符号、文件路径以及其他敏感数据。我们使用`-s`标志去除一些符号，使用`-w`去除调试信息，但要知道，分析人员仍然可以挖掘出关于用于生成此可执行文件的环境的很多信息。
- en: Creating the Operator
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建操作符
- en: 'The operator part follows a very similar but reversed logic: it pushes commands
    and retrieves results while mimicking an interactive shell. You will find the
    code—in Python this time—in the same repository:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符部分遵循非常相似但相反的逻辑：它推送命令并获取结果，同时模仿交互式Shell。你将会在相同的仓库中找到这次使用Python编写的代码：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We head over to our vulnerable form on *surveysandstats.com* and submit the
    following payload to download and run the agent:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们访问我们的易受攻击的表单*surveysandstats.com*，并提交以下有效载荷来下载并运行代理：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Decoded, the payload is multiple lines:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 解码后的有效载荷是多行的：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We then run the operator on our machine:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在机器上运行操作符：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That took some time, but we finally have a functioning shell 1 inside MXR Ads’
    trusted environment. Let the fun begin.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这花了一些时间，但我们终于在MXR Ads的受信环境内拥有了一个可用的Shell 1。让乐趣开始吧。
- en: Trying to Break Free
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试突破
- en: We finally made it into a server inside one of MXR Ads’ coveted VPCs, and we
    have root access . . . or do we? Does anyone still run a production application
    as root nowadays? Chances are, we are actually just inside a container, and the
    user “root” in this namespace is mapped to some random unprivileged user ID on
    the host.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终进入了MXR Ads的一个受欢迎的VPC内的服务器，并获得了root访问权限……还是说我们真的有呢？现在还有人敢以root身份运行生产应用程序吗？很可能，我们实际上只是进入了一个容器，而这个命名空间中的“root”用户被映射到了主机上的某个随机非特权用户ID。
- en: 'A quick way to corroborate our hypothesis is to look more closely at the process
    bearing the PID number 1: examine its command line attributes, cgroups, and mounted
    folders. We can explore these different attributes in the */proc* folder—a virtual
    filesystem that stores information about processes, file handles, kernel options,
    and so on (see [Listing 6-6](#listing6-6)).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 验证我们假设的一个快捷方法是仔细查看PID编号为1的进程：检查其命令行属性、cgroups和挂载的文件夹。我们可以在*/proc*文件夹中查看这些不同的属性——这是一个虚拟文件系统，存储着关于进程、文件句柄、内核选项等的信息（参见[列表6-6](#listing6-6)）。
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 6-6: Listing attributes of the process bearing PID 1 in the */proc*
    folder'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-6：列出*/proc*文件夹中PID为1的进程的属性
- en: We could keep going, but it is pretty clear from the mentions of Docker in the
    cgroup names and mount points that we are trapped inside a container. Plus, in
    a typical modern Linux system, the command starting the first process should be
    akin to */sbin/init* or */usr/lib/systemd*, not */bin/sh*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续，但从cgroup名称和挂载点中提到Docker来看，我们显然已经被困在一个容器里。此外，在典型的现代Linux系统中，启动第一个进程的命令应该类似于*/sbin/init*或*/usr/lib/systemd*，而不是*/bin/sh*。
- en: Being root inside a container still gives us the power to install packages and
    access root-protected files, mind you, but we can only exert that power over resources
    belonging to our narrow and very limited namespace.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在容器内是root用户，仍然可以安装软件包并访问root保护的文件，但我们只能对属于我们狭窄且非常有限命名空间的资源行使这种权力。
- en: One of the very first reflexes to have when landing in a container is to check
    whether it is running in privileged mode.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 进入容器后，第一个反应就是检查是否在特权模式下运行。
- en: Checking for Privileged Mode
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查特权模式
- en: 'In *privileged execution mode*, Docker merely acts as a packaging environment:
    it maintains the namespace isolation but grants wide access to all device files,
    like the hard drive, as well as all the Linux capabilities (more on that in the
    next section).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在*特权执行模式*下，Docker仅充当一个打包环境：它保持命名空间隔离，但允许广泛访问所有设备文件，如硬盘，以及所有Linux功能（更多内容请见下一节）。
- en: 'The container can therefore alter any resource on the host system, such as
    the kernel features, hard drive, network, and so on. If we find we’re in privileged
    mode, we can just mount the main partition, slip an SSH key in any home folder,
    and open a new admin shell on the host. Here’s a quick proof of concept of just
    that in the lab for illustration purposes:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，容器可以更改主机系统上的任何资源，如内核特性、硬盘、网络等。如果我们发现自己处于特权模式下，我们可以直接挂载主分区，在任意主目录中插入一个SSH密钥，并在主机上打开一个新的管理员Shell。以下是在实验室中为说明目的展示的概念验证：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You would think that nobody would dare run a container in privileged mode, especially
    in a production environment, but life is full of surprises, and some folks may
    require it. Take a developer who needs to adjust something as simple as the TCP
    timeout value (a kernel option). To do this, the developer would naturally browse
    the Docker documentation and come across the `sysctl` Docker flag, which essentially
    runs the `sysctl` command from within the container. However, when run, this command
    will, of course, fail to change the kernel TCP timeout option unless it’s invoked
    in privileged mode. The fact that putting the container in privileged mode is
    a security risk would not even cross this developer’s mind—`sysctl`is an official
    and supported flag described in the Docker documentation, for heaven’s sake!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为没有人敢在特权模式下运行容器，特别是在生产环境中，但生活总是充满惊喜，有些人可能确实需要这样做。例如，某个开发者可能需要调整一个像TCP超时值这样的简单设置（一个内核选项）。为此，开发者自然会浏览Docker文档，并找到`sysctl`
    Docker标志，它实际上是在容器内运行`sysctl`命令。然而，当执行该命令时，除非以特权模式调用，否则该命令当然无法更改内核的TCP超时选项。让容器进入特权模式是一个安全风险这一事实，甚至不会引起这个开发者的注意——`sysctl`可是Docker文档中正式支持的标志，天哪！
- en: Linux Capabilities
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux功能
- en: Now we can return to our survey app to check whether we can easily break namespace
    isolation. We list the */dev* folder’s contents, but the result lacks all the
    classic pseudo-device files like *tty*,* *sda*, and *mem* that imply privileged
    mode. Some admins trade the privileged mode for a list of individual permissions
    or capabilities. Think of *capabilities* as a fine-grained breakdown of the permissions
    classically attributed to the all-powerful root user on Linux. A user with the
    capability `CAP_NET_ADMIN` would be allowed to perform root operations on the
    network stack, such as changing the IP address, binding to lower ports, and entering
    promiscuous mode to sniff traffic. The user would, however, be prevented from
    mounting filesystems, for instance. That action requires the `CAP_SYS_ADMIN` capability.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以回到我们的调查应用程序，检查我们是否能轻松突破命名空间隔离。我们列出了 */dev* 文件夹的内容，但结果缺少了所有经典的伪设备文件，如 *tty*、*sda*
    和 *mem*，这些文件通常暗示着特权模式。一些管理员用一系列个体权限或能力来替代特权模式。可以把 *能力* 看作是对传统上归属于 Linux 上万能 root
    用户的权限的精细化分解。拥有 `CAP_NET_ADMIN` 能力的用户可以在网络堆栈上执行 root 操作，例如更改 IP 地址、绑定低端端口以及进入混杂模式嗅探流量。然而，该用户将无法挂载文件系统，例如。那项操作需要
    `CAP_SYS_ADMIN` 能力。
- en: When instructed to do so by the container’s owner with the `--add-cap` flag,
    Docker can attach additional capabilities to a container. Some of these powerful
    capabilities can be leveraged to break namespace isolation and reach other containers
    or even compromise the host by sniffing packets routed to other containers, loading
    kernel modules that execute code on the host, or mounting other containers’ filesystems.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器所有者通过 `--add-cap` 标志指示时，Docker 可以向容器附加额外的能力。这些强大的能力中的一些可以用来突破命名空间隔离，访问其他容器，甚至通过嗅探路由到其他容器的包、加载在主机上执行代码的内核模块或挂载其他容器的文件系统来危及主机。
- en: 'We list the current capabilities of the surveysapp container by inspecting
    the */proc* filesystem and then decode them into meaningful permissions using
    the `capsh` tool:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过检查 */proc* 文件系统来列出当前 surveysapp 容器的能力，然后使用 `capsh` 工具将其解码为有意义的权限：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The effective and permitted capabilities of our current user are `CapPrm` and
    `CapEff`, which amount to the normal set of permissions we can expect from root
    inside a container: kill processes (`CAP_KILL`), change file owners (`CAP_CHOWN`),
    and so on. All these operations are tightly confined to the current namespace,
    so we are still pretty much stuck.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前用户的有效和允许的能力是 `CapPrm` 和 `CapEff`，这相当于我们在容器内可以从 root 用户那里期望得到的正常权限集合：终止进程（`CAP_KILL`）、更改文件所有者（`CAP_CHOWN`）等等。所有这些操作都严格限制在当前命名空间内，因此我们仍然被困在这里。
- en: Docker Socket
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 套接字
- en: 'Next we look for the */var/run/docker.sock* file, which is the REST API used
    to communicate with the Docker daemon on the host. If we can reach this socket
    from within the container, using a simple `curl` for instance, we can instruct
    it to launch a privileged container and then gain root access to the host system.
    We begin by checking for *docker.sock*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们查找 */var/run/docker.sock* 文件，这是与主机上的 Docker 守护进程通信的 REST API。如果我们能从容器内访问这个套接字，例如通过简单的
    `curl` 命令，我们可以指示它启动一个特权容器，然后获得对主机系统的 root 访问权限。我们首先检查 *docker.sock*：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'No luck there. We then check the kernel’s version, hoping for one that has
    some documented exploits to land on the host, but we strike out once more. The
    machine is running a 4.14.146 kernel, which at the time I ran this was only a
    couple of versions behind the latest version:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有运气。我们随后检查了内核的版本，希望能找到一个带有文档漏洞的版本来攻破主机，但我们再次失败。该机器运行的是 4.14.146 内核，在我运行这个时，这个版本仅比最新版本落后几版：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: All in all, we are running as a relatively powerless root user inside an up-to-date
    machine without any obvious misconfigurations or exploits. We can always set up
    a similar kernel in a lab and then drill down into memory structures and `syscalls`
    until we find a zero-day to break namespace isolation, but let’s leave that as
    a last resort kind of thing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们在一台没有明显配置错误或漏洞的最新机器上以一个相对无能的 root 用户身份运行。我们始终可以在实验室里设置一个类似的内核，然后深入研究内存结构和
    `syscalls`，直到找到一个零日漏洞来突破命名空间隔离，但我们把这当作最后的手段来使用。
- en: The first impulse of any sane person trapped in a cage is to try to break free.
    It’s a noble sentiment. But if we can achieve our most devious goals while locked
    behind bars, why spend time sawing through them in the first place?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 任何理智的人被困在笼子里时，第一反应就是试图挣脱。这是一个高尚的情感。但是，如果我们可以在被禁锢的情况下实现我们最阴险的目标，那为什么一开始要浪费时间去锯开笼子呢？
- en: It sure would be great to land on the host and potentially inspect other containers,
    but given the current environment, I believe it’s time we pull back from the barred
    window, drop the useless blunt shank, and focus instead on the bigger picture.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 降落到主机上并检查其他容器当然很好，但考虑到当前的环境，我认为是时候从这扇被锁住的窗户后退一步，放下那把无用的钝锤，转而关注更大的局面了。
- en: Forget about breaking free from this single insignificant host. How about crushing
    the entire floor—nay, the entire building—with a single stroke? Now that would
    be a tale worth telling.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 忘了从这个单一、无关紧要的主机上突破吧。如何一举摧毁整个楼层——不，整个大楼呢？那才是值得一说的故事。
- en: Remember how we dumped environment variables in “Arbitrary Code Execution” on
    page 92? We confirmed the template injection vulnerability and focused on Django-related
    variables because that was the main task at hand, but if you paid close attention,
    you may have caught a glimpse of something tremendously more important. Something
    much more grandiose.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在第92页的“任意代码执行”中如何转储环境变量吗？我们确认了模板注入漏洞，并重点关注了与Django相关的变量，因为那是当前任务的核心，但如果你仔细观察，或许会发现更为重要的线索。一些更宏大的东西。
- en: 'Let me show you the output once more:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我再展示一次输出结果：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We are running inside a container managed by a Kubernetes cluster! Never mind
    this lonely, overstaffed worker machine; we have a chance of bringing down the
    whole kingdom!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在一个由Kubernetes集群管理的容器内运行！别管这个孤独的、人员过多的工作机器；我们有机会摧毁整个王国！
- en: Resources
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源
- en: Burp is famous for its Active Scanner, which automates much of the parameter
    reconnaissance phase. Alternatively, you can try some extensions that fuzz for
    various vulnerabilities. Snoopy Security maintains an interesting compilation
    of such extensions at [https://github.com/snoopysecurity/awesome-burp-extensions/](https://github.com/snoopysecurity/awesome-burp-extensions/)*.*
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Burp以其主动扫描器而闻名，它可以自动化大部分参数侦察阶段。你也可以尝试一些扩展来对各种漏洞进行模糊测试。Snoopy Security维护了一个有趣的扩展合集，地址是[https://github.com/snoopysecurity/awesome-burp-extensions/](https://github.com/snoopysecurity/awesome-burp-extensions/)*。
- en: 'Check out James Kettle’s talk “Server-Side Template Injection: RCE for the
    Modern Webapp” to learn about various exploitation techniques: [https://www.youtube.com/watch?v=3cT0uE7Y87s](https://www.youtube.com/watch?v=3cT0uE7Y87s).'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '查看James Kettle的演讲《Server-Side Template Injection: RCE for the Modern Webapp》，了解各种利用技术：[https://www.youtube.com/watch?v=3cT0uE7Y87s](https://www.youtube.com/watch?v=3cT0uE7Y87s)。'
- en: The Docker reference is available at *[https://dockr.ly/2sgaVhj](https://dockr.ly/2sgaVhj).*
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker的参考资料可以在 *[https://dockr.ly/2sgaVhj](https://dockr.ly/2sgaVhj).* 找到。
- en: '**   A great article about container breakout is “The Route to Root: Container
    Escape Using Kernel Exploitation,” where Nimrod Stoler uses CVE-2017-7308 to escape
    isolation: [http://bit.ly/2TfZHV1](http://bit.ly/2TfZHV1).*   Find descriptions
    of other exploits at [https://unit42.paloaltonetworks.com/](https://unit42.paloaltonetworks.com/).*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于容器突破的精彩文章是《The Route to Root: Container Escape Using Kernel Exploitation》，在这篇文章中，Nimrod
    Stoler利用CVE-2017-7308实现了逃离隔离的过程：[http://bit.ly/2TfZHV1](http://bit.ly/2TfZHV1)。**   其他漏洞的描述可以在[https://unit42.paloaltonetworks.com/](https://unit42.paloaltonetworks.com/)找到。*'
