["```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Slowly increase the scrollSpeed as the game progresses\n\n    scrollSpeed\n += 0.01\n\n    // Determine the elapsed time since the last update call\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Slowly increase the scrollSpeed as the game progresses\n\n    scrollSpeed\n += 0.01\n\n    // Determine the elapsed time since the last update call\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Slowly increase the scrollSpeed as the game progresses\n\n    scrollSpeed\n += 0.01\n\n    // Determine the elapsed time since the last update call\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Slowly increase the scrollSpeed as the game progresses\n\n    scrollSpeed\n += 0.01\n\n    // Determine the elapsed time since the last update call\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Slowly increase the scrollSpeed as the game progresses\n\n    scrollSpeed\n += 0.01\n\n    // Determine the elapsed time since the last update call\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Slowly increase the scrollSpeed as the game progresses\n\n    scrollSpeed\n += 0.01\n\n    // Determine the elapsed time since the last update call\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Slowly increase the scrollSpeed as the game progresses\n\n    scrollSpeed\n += 0.01\n\n    // Determine the elapsed time since the last update call\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    // Slowly increase the scrollSpeed as the game progresses\n\n    scrollSpeed\n += 0.01\n\n    // Determine the elapsed time since the last update call\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nclass GameScene: SKScene, SKPhysicsContactDelegate {\n\n    // Enum for y-position spawn points for bricks\n\n    // Ground bricks are low and upper platform bricks are high\n\n  ➊\n enum\n BrickLevel: ➋\n CGFloat\n {\n\n     ➌\n case\n low = 0.0\n\n     ➍\n case\n high = 100.0\n\n    }\n\n    // An array that holds all the current sidewalk bricks\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nvar brickSize = CGSize.zero\n\n// The current brick level determines the y-position of new bricks\n\nvar\n brickLevel = BrickLevel\n .low\n\n// Setting for how fast the game is scrolling to the right\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    scrollSpeed = startingScrollSpeed\n\n    brickLevel\n = .low\n\n    lastUpdateTime = nil\n\n    --\n *snip* \n --\n\n}\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nwhile farthestRightBrickX < frame.width {\n\n    var brickX = farthestRightBrickX + brickSize.width + 1.0\n\n    let\n brickY = (brickSize\n .height\n / 2.0\n ) + brickLevel\n .rawValue\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n    if randomNumber < 5 {\n\n        --\n *snip* \n --\n\n    }\n\n ➊\n else\n if\n randomNumber < 10\n {\n\n         // There is a 5 percent chance that the brick level will change\n\n        if\n brickLevel\n == .high\n {\n\n            brickLevel\n = .low\n\n        }\n\n        else\n if\n brickLevel\n == .low\n {\n\n            brickLevel\n = .high\n\n        }\n\n    }\n\n    // Spawn a new brick and update the rightmost brick\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nvar bricks = [SKSpriteNode]()\n\n// An array that holds all the current gems\n\nvar\n gems = [SKSpriteNode\n ]()\n\n// The size of the sidewalk brick graphics used\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\n  func spawnBrick(atPosition position: CGPoint) -> SKSpriteNode {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n spawnGem(atPosition position: CGPoint\n ) {\n\n      // Create a gem sprite and add it to the scene\n\n    ➋\n let\n gem = SKSpriteNode\n (imageNamed: \"gem\"\n )\n\n      gem.position\n = position\n\n      gem.zPosition\n = 9\n\n      addChild\n (gem)\n\n    ➌\n gem.physicsBody\n = SKPhysicsBody\n (rectangleOf: gem.size\n , \n\n          center: gem.centerRect\n .origin\n )\n\n    ➍\n gem.physicsBody\n ?.categoryBitMask\n = PhysicsCategory\n .gem\n\n    ➎\n gem.physicsBody\n ?.affectedByGravity\n = false\n\n      // Add the new gem to the array of gems\n\n    ➏\n gems\n .append\n (gem)\n\n  }\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n  ➊\n if randomNumber < 5 {\n\n        // There is a 5 percent chance that we will leave a gap between bricks\n\n        let gap = 20.0 * scrollSpeed\n\n        brickX += gap\n\n        // At each gap, add a gem\n\n     ➋\n let\n randomGemYAmount = CGFloat\n (arc4random_uniform(150\n ))\n\n     ➌\n let\n newGemY = brickY + skater\n .size\n .height\n + randomGemYAmount\n\n     ➍\n let\n newGemX = brickX - gap / 2.0\n\n     ➎\n spawnGem\n (atPosition: CGPoint\n (x: newGemX, y: newGemY))\n\n  }\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc spawnGem(atPosition position: CGPoint) {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n removeGem(_\n gem: SKSpriteNode\n ) {\n\n  ➊\n gem.removeFromParent\n ()\n\n  ➋\n if\n let\n gemIndex = gems\n .index\n (of: gem) {\n\n      ➌\n gems\n .remove\n (at: gemIndex)\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc startGame() {\n\n    --\n *snip* \n --\n\n    bricks.removeAll(keepingCapacity: true)\n\n    for\n gem in\n gems\n {\n\n        removeGem\n (gem)\n\n    }\n\n}\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\n  func updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n      --\n *snip* \n --\n\n  }\n\n➊\n func\n updateGems(withScrollAmount currentScrollAmount: CGFloat\n ) {\n\n      for\n gem in\n gems\n {\n\n          // Update each gem's position\n\n       ➋\n let\n thisGemX = gem.position\n .x\n - currentScrollAmount\n\n       ➌\n gem.position\n = CGPoint\n (x: thisGemX, y: gem.position\n .y\n )\n\n          // Remove any gems that have moved offscreen\n\n       ➍\n if\n gem.position\n .x\n < 0.0\n {\n\n             removeGem\n (gem)\n\n          }\n\n      }\n\n  }\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateBricks(withScrollAmount: currentScrollAmount)\n\n    updateSkater()\n\n    updateGems\n (withScrollAmount: currentScrollAmount)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    // Check if the contact is between the skater and a brick\n\n    if contact.bodyA.categoryBitMask == PhysicsCategory.skater &&\n\n        contact.bodyB.categoryBitMask == PhysicsCategory.brick {\n\n    --\n *snip* \n --\n\n    }\n\n  ➊\n else if\n contact.bodyA\n .categoryBitMask\n == PhysicsCategory\n .skater\n && \n\n        contact.bodyB\n .categoryBitMask\n == PhysicsCategory\n .gem\n {\n\n        // Skater touched a gem, so remove it\n\n      ➋\n if\n let\n gem = contact.bodyB\n .node\n as\n ? SKSpriteNode\n {\n\n            removeGem\n (gem)\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc resetSkater() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n setupLabels() {\n\n    // Label that says \"score\" in the upper left\n\n  ➊\n let\n scoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"score\"\n )\n\n  ➋\n scoreTextLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 20.0\n )\n\n  ➌\n scoreTextLabel.horizontalAlignmentMode\n = .left\n\n}\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    scoreTextLabel.horizontalAlignmentMode = .left\n\n  ➊\n scoreTextLabel.fontName\n = \"Courier-Bold\"\n\n  ➋\n scoreTextLabel.fontSize\n = 14.0\n\n  ➌\n scoreTextLabel.zPosition\n = 20\n\n    addChild\n (scoreTextLabel)\n\n}\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n    addChild(scoreTextLabel)\n\n    // Label that shows the player's actual score\n\n  ➊\n let\n scoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n  ➋\n scoreLabel.position\n = CGPoint\n (x: 14.0\n , y: frame\n .size\n .height\n - 40.0\n )\n\n  ➌\n scoreLabel.horizontalAlignmentMode\n = .left\n\n    scoreLabel.fontName\n = \"Courier-Bold\"\n\n    scoreLabel.fontSize\n = 18.0\n\n  ➍\n scoreLabel.name\n = \"scoreLabel\"\n\n    scoreLabel.zPosition\n = 20\n\n    addChild\n (scoreLabel)\n\n    // Label that says \"high score\" in the upper right\n\n    let\n highScoreTextLabel: SKLabelNode\n = SKLabelNode\n (text: \"high score\"\n )\n\n    highScoreTextLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 20.0\n )\n\n  ➎\n highScoreTextLabel.horizontalAlignmentMode\n = .right\n\n    highScoreTextLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreTextLabel.fontSize\n = 14.0\n\n    highScoreTextLabel.zPosition\n = 20\n\n    addChild\n (highScoreTextLabel)\n\n    // Label that shows the player's actual highest score\n\n    let\n highScoreLabel: SKLabelNode\n = SKLabelNode\n (text: \"0\"\n )\n\n    highScoreLabel.position\n = CGPoint\n (x: frame\n .size\n .width\n - 14.0\n , \n\n        y: frame\n .size\n .height\n - 40.0\n )\n\n    highScoreLabel.horizontalAlignmentMode\n = .right\n\n    highScoreLabel.fontName\n = \"Courier-Bold\"\n\n    highScoreLabel.fontSize\n = 18.0\n\n  ➏\n highScoreLabel.name\n = \"highScoreLabel\"\n\n    highScoreLabel.zPosition\n = 20\n\n    addChild\n (highScoreLabel)\n\n}\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\noverride func didMove(to view: SKView) {\n\n    --\n *snip* \n --\n\n    addChild(background)\n\n    setupLabels\n ()\n\n    // Set up the skater and add her to the scene\n\n    --\n *snip* \n --\n\n}\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\n  let gravitySpeed: CGFloat = 1.5\n\n  // Properties for score-tracking\n\n➊\n var\n score: Int\n = 0\n\n➋\n var\n highScore: Int\n = 0\n\n➌\n var\n lastScoreUpdateTime: TimeInterval\n = 0.0\n\n  // The timestamp of the last update method call\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc setupLabels() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateScoreLabelText() {\n\n ➊\n if\n let\n scoreLabel = childNode\n (withName: \"scoreLabel\"\n ) as\n ? SKLabelNode\n {\n\n     ➋\n scoreLabel.text\n = String\n (format: \"%04d\"\n , score\n )\n\n    }\n\n}\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc startGame() {\n\n    // When a new game is started, reset to starting conditions\n\n    resetSkater()\n\n    score\n = 0\n\n    scrollSpeed = startingScrollSpeed\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc\n updateScore(withCurrentTime currentTime: TimeInterval\n ) {\n\n    // The player's score increases the longer they survive\n\n    // Only update score every 1 second\n\n  ➊\n let\n elapsedTime = currentTime - lastScoreUpdateTime\n\n    if\n elapsedTime > 1.0\n {\n\n        // Increase the score\n\n     ➋\n score\n += Int\n (scrollSpeed\n )\n\n        // Reset the lastScoreUpdateTime to the current time\n\n     ➌\n lastScoreUpdateTime\n = currentTime\n\n        updateScoreLabelText\n ()\n\n    }\n\n}\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\noverride func update(_ currentTime: TimeInterval) {\n\n    --\n *snip* \n --\n\n    updateGems(withScrollAmount: currentScrollAmount)\n\n    updateScore\n (withCurrentTime: currentTime)\n\n}\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc didBegin(_ contact: SKPhysicsContact) {\n\n    --\n *snip* \n --\n\n        // Skater touched a gem, so remove it\n\n        if let gem = contact.bodyB.node as? SKSpriteNode {\n\n            removeGem(gem)\n\n            // Give the player 50 points for getting a gem\n\n            score\n += 50\n\n            updateScoreLabelText\n ()\n\n        }\n\n    }\n\n}\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateScoreLabelText() {\n\n    --\n *snip* \n --\n\n}\n\nfunc\n updateHighScoreLabelText() {\n\n    if\n let\n highScoreLabel = childNode\n (withName: \"highScoreLabel\"\n ) \n\n        as\n ? SKLabelNode\n {\n\n        highScoreLabel.text\n = String\n (format: \"%04d\"\n , highScore\n )\n\n    }\n\n}\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc gameOver() {\n\n    // When the game ends, see if the player got a new high score\n\n    if\n score\n > highScore\n {\n\n        highScore\n = score\n\n        updateHighScoreLabelText\n ()\n\n    }\n\n    startGame()\n\n}\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nfunc updateBricks(withScrollAmount currentScrollAmount: CGFloat) {\n\n    --\n *snip* \n --\n\n        let randomNumber = arc4random_uniform(99)\n\n        if\n randomNumber < 2\n && score\n > 10\n {\n\n            // There is a 2 percent chance that we will leave a gap between\n\n            // bricks after the player has reached a score of 10\n\n            let gap = 20.0 * scrollSpeed\n\n            brickX += gap\n\n            --\n *snip* \n --\n\n        }\n\n        else\n if\n randomNumber < 4\n && score\n > 20\n {\n\n            // There is a 2 percent chance that the brick Y level will change\n\n            // after the player has reached a score of 20\n\n            if brickLevel == .high {\n\n                brickLevel = .low\n\n            }\n\n        --\n *snip* \n --\n\n}\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```", "```\nphysicsBody?.density = 6.0\n\nphysicsBody\n ?.allowsRotation\n = false\n\nphysicsBody?.angularDamping = 1.0\n\n```"]