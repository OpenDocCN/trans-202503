<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch28"><span epub:type="pagebreak" id="page_535"/><span class="big">28</span><br/>THE LORENTZ FORCE LAW</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">We’ve seen that modern electromagnetic theory is a field theory. The existence of electric and magnetic fields explains electric and magnetic phenomena. Electric charge (and its moving form, current) is both the source of these fields and the recipient of force from these fields. Electromagnetic theory, then, has two aspects: charge creates electric and magnetic fields, and electric and magnetic fields apply force to charge. In the last four chapters, we dealt with the first of these aspects in static and steady situations. We showed how charge creates electric fields and how current creates magnetic fields.</p>&#13;
<p class="indent">In this chapter, we’ll consider the <em>Lorentz force law</em>, which addresses the second aspect of electromagnetic theory by describing how electric and magnetic fields apply force to charge. Then, in the next and final chapter of this book, we’ll return to the first aspect of electromagnetic theory with the <em>Maxwell equations</em>, which describe how electric and magnetic fields are created and evolve in dynamic situations.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_536"/>Our goal in this chapter is to describe the motion of a charged particle in the presence of an electric field and a magnetic field. After a short discussion about statics and dynamics in electromagnetic theory, we’ll turn to the question of an appropriate state for a particle in the presence of electric and magnetic fields. We’ll then introduce the Lorentz force law, which describes the force on such a particle. We’ll explain the purpose of the electric field and then address the question of how to perform state-update functions on a particle experiencing forces from electric and magnetic fields. We’ll describe a particle’s response to an imposed electric and magnetic field, but we will save consideration of the electromagnetic field radiated by moving charges for the final chapter of the book. We’ll finish the chapter by making some animations of a particle in electric and magnetic fields.</p>&#13;
<p class="indent">Let’s begin with some introductory code.</p>&#13;
<h3 class="h3" id="ch28lev1">Introductory Code</h3>&#13;
<p class="noindent"><a href="ch28.xhtml#ch28list1">Listing 28-1</a> shows the first lines of code in the <code>Lorentz</code> module we will write in this chapter.</p>&#13;
<pre id="ch28list1">{-# OPTIONS -Wall #-}&#13;
{-# LANGUAGE MultiParamTypeClasses #-}&#13;
&#13;
module Lorentz where&#13;
&#13;
import SimpleVec ( R, Vec, (^+^), (*^), (^*), (^/), (&gt;&lt;), zeroV, magnitude )&#13;
import Mechanics1D ( RealVectorSpace(..), Diff(..), rungeKutta4 )&#13;
import Mechanics3D ( HasTime(..), simulateVis )&#13;
import CoordinateSystems ( Position(..), VectorField, cart, v3FromPos, origin&#13;
                         , shiftPosition, addVectorFields, visVec )&#13;
import qualified Vis as V</pre>&#13;
<p class="listing"><em>Listing 28-1: Opening lines of code for the <code>Lorentz</code> module</em></p>&#13;
<p class="indent">We use types and functions from the <code>SimpleVec</code> module of <a href="ch10.xhtml">Chapter 10</a>, the <code>Mechanics1D</code> module of <a href="ch15.xhtml">Chapter 15</a>, the <code>Mechanics3D</code> module of <a href="ch16.xhtml">Chapter 16</a>, and the <code>CoordinateSystems</code> module of <a href="ch22.xhtml">Chapter 22</a>.</p>&#13;
<p class="indent">This is the first time we’re dealing with the dynamics of electromagnetic theory, so a short discussion of statics and dynamics will help set the stage for this chapter.</p>&#13;
<h3 class="h3" id="ch28lev2">Statics and Dynamics</h3>&#13;
<p class="noindent"><a href="part02.xhtml">Part II</a> of this book dealt with mechanics, which is a <em>dynamic</em> subject, in that the quantities we’re interested in, including position, velocity, acceleration, force, momentum, and energy, are all changing in time. Newton’s second law, in particular, is a dynamic equation because it tells us how the velocity of a particle changes in the presence of forces on the particle. So far in <a href="part03.xhtml">Part III</a> of this book, electromagnetic theory has appeared to be a <em>static</em> <span epub:type="pagebreak" id="page_537"/>subject, in that electric and magnetic fields were not changing in time. In the last four chapters, we spent our time exploring how static charges produce electric fields and how steady currents produce magnetic fields. But in fact, electromagnetic theory is just as much a dynamic subject as mechanics.</p>&#13;
<p class="indent">Each of the two aspects of electromagnetic theory has dynamics associated with it. Because charges move and accelerate, electric and magnetic fields change in time. The Maxwell equations we’ll explore in the last chapter of this book describe how these fields change in time. Because a particle experiences forces, electromagnetic or otherwise, its velocity changes in time. This is the dynamics of mechanics we discussed in <a href="part02.xhtml">Part II</a>. Once we know the forces that act on a particle, we use Newton’s second law and the ideas in <a href="part02.xhtml">Part II</a> to find the motion of the particle.</p>&#13;
<p class="indent">A good way to deal with dynamics is to ask how the state of a physical system changes with time. The practice of focusing on how the state of a physical system evolves in time will be just as useful in electromagnetic theory as it was in mechanics. Deciding what state variables to include in the state is just as important a question now as it was then. The strategy of choosing state variables and finding a differential equation that expresses how those variables change in time is one that transcends many theories in physics and beyond. It is not the only way to view physics, but it is a very important and useful way.</p>&#13;
<p class="indent">In preparation to do electrodynamics, then, we need to give some thought to an appropriate state. What do we put in a state? We can start with quantities we care about. In mechanics, we certainly care about the positions of particles, so we put them in the state. If the rate of change of a quantity we care about depends on other quantities, we may need to put them in the state as well. In mechanics, the rate of change of position is velocity, so we put velocity in the state. The rate of change of velocity depends on the forces that act on the particle, so we might choose to put quantities on which the forces depend in the state.</p>&#13;
<p class="indent">Thus, we’re going to include the electric field and the magnetic field in the state. Conceptually and computationally, this is a pretty big step upward in complexity. Conceptually, this is the first time we are including functions in the state. Computationally, the sheer amount of information we need to keep track of in the state gets a major bump upward in going from mechanics to electromagnetic theory. In the mechanics of point particles, we need six numbers in the state for each particle in our system. We live in three-dimensional space, so we need three numbers to record the position of each particle, and we need three numbers to record the velocity of each particle. The electric field, a function from space to vectors, is closer to an infinite collection of numbers since the electric field contains a vector for every point in space.</p>&#13;
<p class="indent">There are two reasons to include electric and magnetic fields in the state of a system. One reason is that we care about the electric and magnetic fields, and we want to know how they change in time, although we won’t address the changes in electric and magnetic fields until the next chapter. A second reason to include the fields in the state is that they are needed to <span epub:type="pagebreak" id="page_538"/>determine the electric force and the magnetic force on particles. We’ll deal with this issue in the present chapter.</p>&#13;
<p class="indent">Besides the electric and magnetic fields, what else should we include in the state? One option for state is to keep track only of the electric field and the magnetic field, excluding particle information from the state. This choice for state is useful for electromagnetic waves, or radiation from a known source, but it is not useful if we care about the motion of particles, as we do in this chapter. Hence, we will not pursue this option in this chapter.</p>&#13;
<p class="indent">A second option for state is to include the position and velocity of each particle we care about in addition to the electric and magnetic fields. The two-body force we introduced in <a href="ch21.xhtml">Chapter 21</a> to describe the Coulomb force between charged particles would no longer be needed because the electric and magnetic fields are now the entities that produce force on particles. The Maxwell equations would describe how the electric and magnetic fields change based on the charged particles present in the system. Newton’s second law would describe how the velocities of the particles change from electromagnetic and possibly other forces. In fact, removing two-body forces by introducing fields has been a theme in physics since 1865. Newton’s law of universal gravity, a two-body force, can be removed once the field theory of general relativity is incorporated.</p>&#13;
<p class="indent">However, there is a technical problem with this combination of multiple particles and fields. The problem is that each particle contributes to the electric field and the magnetic field. The contribution that a charged point particle makes to the electric field increases without bound as the field point approaches the location of the particle. Applying the equations in the most obvious, naive way provides an infinite, or undefined, force on every particle, produced by itself. This is both conceptually and computationally troubling. The best conceptual resolution is to argue that point particles had to be an idealization anyway and to treat charge as spread throughout some volume, abandoning the particle theory of charge for a field theory of charge. One computational “quick fix” is, for each particle, to keep track of the fields produced only by the other particles. We don’t want to get involved in any of these complexities, interesting as they may be, so we will not consider a state of multiple particles and fields.</p>&#13;
<p class="indent">Instead, we will choose a third option: a state that includes the position and velocity for a single particle, along with the electric and magnetic fields. This will allow us to focus on the motion of a single particle in an electric and a magnetic field. Let’s see what this state looks like.</p>&#13;
<h3 class="h3" id="ch28lev3">State of One Particle and Fields</h3>&#13;
<p class="noindent">By adding vector fields for the electric field and the magnetic field, we extend the type <code>ParticleState</code> we used in <a href="ch16.xhtml">Chapter 16</a> for one particle to the type <code>ParticleFieldState</code>, which includes the fields. Here’s the definition of the data type using record syntax:</p>&#13;
<pre>data ParticleFieldState = ParticleFieldState { mass          :: R&#13;
                                             , charge        :: R&#13;
                                             , time          :: R&#13;
                                             , position      :: Position&#13;
                                             , velocity      :: Vec&#13;
                                             , electricField :: VectorField&#13;
                                             , magneticField :: VectorField }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_539"/>As you can see, we have mass, charge, time, position, and velocity in the state, the same five state variables in <code>ParticleState</code> from <a href="ch16.xhtml">Chapter 16</a>. Now, we also include the electric and magnetic fields. Besides the two new slots for the fields, we are making one small change from the <code>ParticleState</code> type we used in <a href="ch16.xhtml">Chapter 16</a>. We are now using the <code>Position</code> data type we defined in <a href="ch22.xhtml">Chapter 22</a> for position, rather than the <code>Vec</code> we used in <a href="part02.xhtml">Part II</a>.</p>&#13;
<p class="indent">As we have done in past chapters, when we write a new data type for state, we also write a new data type for state derivative. In other words, we write a data structure to hold the time derivatives of the state variables. Following the pattern we’ve used for naming this state derivative type, we call the new type <code>DParticleFieldState</code>.</p>&#13;
<pre>data DParticleFieldState = DParticleFieldState { dmdt :: R&#13;
                                               , dqdt :: R&#13;
                                               , dtdt :: R&#13;
                                               , drdt :: Vec&#13;
                                               , dvdt :: Vec&#13;
                                               , dEdt :: VectorField&#13;
                                               , dBdt :: VectorField }</pre>&#13;
<p class="indent">We want to be able to use the Euler and fourth-order Runge-Kutta methods for solving differential equations in this setting, and that requires us to make the new data type an instance of the <code>RealVectorSpace</code> type class. This amounts to defining what it means to add <code>ParticleFieldState</code>s and to scale such expressions by real numbers. Here is the instance declaration:</p>&#13;
<pre>instance RealVectorSpace DParticleFieldState where&#13;
    dst1 +++ dst2&#13;
        = DParticleFieldState { dmdt = dmdt dst1  +  dmdt dst2&#13;
                              , dqdt = dqdt dst1  +  dqdt dst2&#13;
                              , dtdt = dtdt dst1  +  dtdt dst2&#13;
                              , drdt = drdt dst1 ^+^ drdt dst2&#13;
                              , dvdt = dvdt dst1 ^+^ dvdt dst2&#13;
                              , dEdt = addVectorFields [dEdt dst1, dEdt dst2]&#13;
                              , dBdt = addVectorFields [dBdt dst1, dBdt dst2]&#13;
                              }&#13;
    scale w dst&#13;
        = DParticleFieldState { dmdt = w *  dmdt dst&#13;
                              , dqdt = w *  dqdt dst&#13;
                              <span epub:type="pagebreak" id="page_540"/>, dtdt = w *  dtdt dst&#13;
                              , drdt = w *^ drdt dst&#13;
                              , dvdt = w *^ dvdt dst&#13;
                              , dEdt = (w *^) . (dEdt dst)&#13;
                              , dBdt = (w *^) . (dBdt dst)&#13;
                              }</pre>&#13;
<div class="note">&#13;
<p class="note-title"><span class="bg1">NOTE</span></p>&#13;
<p class="note-para"><em>Unfortunately, this code is some of the most repetitive and uninformative code in the book. It just recounts the obvious thing we must mean by adding or scaling each of the derivatives of state variables. It gives me pain to write such repetitive, boilerplate code. It’s a very interesting question to ask how we might avoid writing such code. I would love to give you the answer, but we must stay focused on the task at hand, which is defining a new data type and making sure it can be used with code we’ve already written.</em></p>&#13;
</div>&#13;
<p class="indent">We need a <code>Diff</code> instance to describe how the types <code>ParticleFieldState</code> and <code>DParticleFieldState</code> are related. Recall that this involves defining the function <code>shift</code> to show how state variables are shifted by derivatives over a small time interval.</p>&#13;
<pre>instance Diff ParticleFieldState DParticleFieldState where&#13;
    shift dt dst st&#13;
        = ParticleFieldState&#13;
          { mass          = mass     st  +  dmdt dst  * dt&#13;
          , charge        = charge   st  +  dqdt dst  * dt&#13;
          , time          = time     st  +  dtdt dst  * dt&#13;
          , position      = shiftPosition (drdt dst ^* dt) (position st)&#13;
          , velocity      = velocity st ^+^ dvdt dst ^* dt&#13;
          , electricField = \r -&gt; electricField st r ^+^ dEdt dst r ^* dt&#13;
          , magneticField = \r -&gt; magneticField st r ^+^ dBdt dst r ^* dt&#13;
          }</pre>&#13;
<p class="indent">As usual, we shift each state variable by the product of the corresponding derivative and the time step.</p>&#13;
<p class="indent">There is one more type class instance declaration we need. When we wrote the <code>simulateVis</code> function in <a href="ch16.xhtml">Chapter 16</a> to make 3D animations, we wanted to use it with any of the state spaces we had defined, or any we might define in the future. The one requirement that <code>simulateVis</code> made on a state space was that it include a notion of time. The instance declaration below simply gives the function that returns the time of a state.</p>&#13;
<pre>instance HasTime ParticleFieldState where&#13;
    timeOf = time</pre>&#13;
<p class="indent">Now that we’ve defined a new data type for the state of one particle with the electric and magnetic fields, let’s turn to a discussion of the force that electric and magnetic fields apply to a particle.</p>&#13;
<h3 class="h3" id="ch28lev4"><span epub:type="pagebreak" id="page_541"/>Lorentz Force Law</h3>&#13;
<p class="noindent">Electric and magnetic fields produce forces on a charged particle. The force on a particle with charge <em>q</em>, position <strong>r</strong>(<em>t</em>), and velocity <strong>v</strong>(<em>t</em>) in an electric field <strong>E</strong> and a magnetic field <strong>B</strong> is given by the Lorentz force law.</p>&#13;
<div class="imagec"><img src="Images/541equ02.jpg" alt="Image" width="498" height="21"/></div>&#13;
<p class="noindent">The electric force,</p>&#13;
<p class="centere"><strong>F</strong><sub>electric</sub> = <em>q</em><strong>E</strong>(<strong>r</strong>(<em>t</em>))</p>&#13;
<p class="noindent">gives a sense of the meaning of the electric field. The electric field represents a force per unit charge at a position in space. There may or may not be any charge at a point in space, but if there is, the product of the charge and the electric field vector at that point gives the force on the charge. Positive charge feels a force in the same direction as the electric field vector; negative charge feels a force in the opposite direction.</p>&#13;
<p class="indent">The magnetic force</p>&#13;
<p class="centere"><strong>F</strong><sub>magnetic</sub> = <em>q</em><strong>v</strong>(<em>t</em>) × <strong>B</strong>(<strong>r</strong>(<em>t</em>))</p>&#13;
<p class="noindent">is harder to interpret because of the cross product, which indicates that the magnetic force on a charged particle is perpendicular to the magnetic field vector at the location of the particle and to the velocity of the particle. There is some symmetry between the creation of a magnetic field by a moving charge and the force from a magnetic field on a moving charge in that both processes are governed by equations containing a cross product. The appearance of charge and velocity in the magnetic force equation means that to feel a magnetic force, a particle must have charge and be moving. This is another symmetry between the creation and effect of magnetic field. Just as moving charge, or current, creates a magnetic field, it’s moving charge that feels a force from the field.</p>&#13;
<p class="indent">The Lorentz force law, Equation 28.1, is simply the sum of the electric and magnetic forces. The function <code>lorentzForce</code> expresses the Lorentz force law in Haskell.</p>&#13;
<pre>lorentzForce :: ParticleFieldState -&gt; Vec&#13;
lorentzForce (ParticleFieldState _m q _t r v eF bF)&#13;
    = q *^ (eF r ^+^ v &gt;&lt; bF r)</pre>&#13;
<p class="indent">Two of the terms, <code>eF</code> and <code>bF</code>, belong to the fields that produce the force. Three of the terms, <code>q</code>, <code>r</code>, and <code>v</code>, belong to the particle that feels the force. Because our state contains state variables for both the particle and the fields, the Lorentz force depends only on the state of the system.</p>&#13;
<h3 class="h3" id="ch28lev5">Do We Really Need an Electric Field?</h3>&#13;
<p class="noindent">If we use the two-part modern view of electricity to first calculate the electric field <strong>E</strong> produced by a particle with charge <em>q</em><sub>1</sub> at position <strong>r</strong><sub>1</sub></p>&#13;
<div class="imagec"><img src="Images/541equ01.jpg" alt="Image" width="169" height="52"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_542"/>and then apply the Lorentz force law to find the force on a particle with charge <em>q</em><sub>2</sub> at position <strong>r</strong><sub>2</sub></p>&#13;
<div class="imagec"><img src="Images/542equ01.jpg" alt="Image" width="407" height="52"/></div>&#13;
<p class="noindent">we recover Equation 21.2, Coulomb’s 18th century electricity law. This is somewhat comforting since it gives us an opportunity to see how the electric field relates to Coulomb’s law. But what have we gained by introducing the electric field? It appears to be nothing but a large piece of ontological and mathematical baggage! Why introduce the electric field if we just get back Coulomb’s result?</p>&#13;
<p class="indent">The answer is that the electric field offers no new predictions over Coulomb’s theory in static situations, which is when charges are not moving or accelerating. In the world of statics, the electric field is at best a convenience and at worst an irritation. However, when charges are moving or accelerating, Coulomb’s law, as embodied in Equations 21.1, 21.2, and 21.3, no longer holds. The methods we developed in <a href="ch25.xhtml">Chapter 25</a> also cease to hold. If charged particles move slowly, Coulomb’s law and the equations of <a href="ch25.xhtml">Chapter 25</a> are good approximations, but as charges approach the speed of light, those theories fail completely.</p>&#13;
<p class="indent">What’s more, when charged particles accelerate, they radiate. In other words, they produce electric and magnetic fields that carry energy and momentum far away from the accelerating particle. The electric and magnetic fields take on a life of their own, and their description becomes an important part of the state of the system. Radiating electromagnetic fields are not treated in this chapter, but we do cover them in the final chapter of the book.</p>&#13;
<p class="indent">The electric and magnetic fields help enforce a principle of locality, the idea that interactions between entities (particles or fields) happen close to each other, not at a distance. Newton’s law of universal gravitation and Coulomb’s law are examples of <em>action at a distance</em>. They suggest that one object has a direct and instantaneous effect on another object arbitrarily far away. People have discussed the philosophical implications of this for centuries. Mathematically, it is no problem to have action at a distance in a framework that accommodates the idea of universal time. If a particle far away wiggles now, I feel the gravitational differences now. But since the acceptance of Einstein’s relativity, we have given up the idea of a universal time. What’s more, relativity tells us that the notion of simultaneity is observer dependent (or at least reference-frame dependent). In a framework of relativity, action-at-a-distance laws like Newton’s universal gravity and Coulomb’s law are quite problematic. Einstein realized that his 1905 special relativity was incompatible with Newton’s universal gravity, and by 1915 he had developed a new theory of gravity called general relativity.</p>&#13;
<p class="indent">By 1865, Faraday and Maxwell had done for electricity what Einstein did for gravity in 1915. If a charged particle wiggles in one place, that modifies the electric field produced by the particle. Changes ripple through the electric field at the speed of light, and only later affect a second particle. Faraday and Maxwell made electromagnetic theory into a field theory that removed <span epub:type="pagebreak" id="page_543"/>the need for action at a distance, explained the relationships between electricity and magnetism, predicted radiation, and gave a theory of light. The electric field is now viewed as a small price to pay for all these benefits.</p>&#13;
<p class="indent">Now that we’ve introduced the Lorentz force law, discussed it a bit, and seen how it governs the aspect of electromagnetic theory in which fields apply force to charge, let’s combine it with the state-based approach to dynamics that will allow us to predict the motion of a charged particle in electric and magnetic fields.</p>&#13;
<h3 class="h3" id="ch28lev6">State Update</h3>&#13;
<p class="noindent">Unlike our previous chapters on mechanics in <a href="part02.xhtml">Part II</a>, in which we considered a list of forces from any source that act on a particle, in this chapter we’ll assume that the electric and magnetic forces that comprise the Lorentz force are the only forces acting on our particle. The reason for this is simply to keep our focus on electromagnetic theory. It is not too difficult to extend the code we write in this chapter to include arbitrary forces beyond electromagnetism that act on a particle.</p>&#13;
<p class="indent">The function <code>newtonSecondPFS</code> (<code>PFS</code> for <code>ParticleFieldState</code>) expresses the differential equation that gives the rates of change of the state variables. The only interesting rate of change is that of the velocity, which is based on the net force on the particle divided by its mass, according to Newton’s second law.</p>&#13;
<pre>newtonSecondPFS :: ParticleFieldState -&gt; DParticleFieldState&#13;
newtonSecondPFS st&#13;
    = let v = velocity st&#13;
          a = lorentzForce st ^/ mass st&#13;
      in DParticleFieldState { dmdt = 0           -- dm/dt&#13;
                             , dqdt = 0           -- dq/dt&#13;
                             , dtdt = 1           -- dt/dt&#13;
                             , drdt = v           -- dr/dt&#13;
                             , dvdt = a           -- dv/dt&#13;
                             , dEdt = const zeroV -- dE/dt&#13;
                             , dBdt = const zeroV -- dB/dt&#13;
                             }</pre>&#13;
<p class="indent">The mass and charge of the particle do not change, so their rates are 0. Time changes at a rate of 1 second per second, so its rate is 1. Position changes at a rate given by velocity; that’s just the definition of velocity. Velocity changes at a rate given by acceleration, which by Newton’s second law is net force divided by mass. Net force here is just the Lorentz force since we decided to limit our attention to electromagnetic forces. In this chapter, we are not allowing the electric and magnetic fields to change, so their rates are 0. Since they are vector functions, their rates of change are the constant function that returns the zero vector, <code>const zeroV</code>.</p>&#13;
<p class="indent"><a href="ch28.xhtml#ch28tab1">Table 28-1</a> compares the function <code>newtonSecondPFS</code> to the other functions that expressed Newton’s second law in <a href="part02.xhtml">Part II</a> when we worked with other state spaces. Because we are confining our attention to electromagnetic <span epub:type="pagebreak" id="page_544"/>forces, and because these forces can be determined solely by information contained in the state of the particle-field system, the function <code>newtonSecondPFS</code> does not require a list of forces as input, as all of the other functions in the table do.</p>&#13;
<p class="tabcap" id="ch28tab1"><strong>Table 28-1:</strong> Functions for Newton’s Second Law</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Function</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Type</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort1"><p class="taba"><code>newtonSecondV</code></p></td>&#13;
<td style="vertical-align: top;" class="backcolort1"><p class="taba"><code>Mass -&gt; [Velocity -&gt; Force] -&gt; Velocity -&gt; R</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><code>newtonSecondTV</code></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><code>Mass -&gt;</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"> </p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><code>[(Time, Velocity) -&gt; Force] -&gt; (Time, Velocity) -&gt; (R, R)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><code>newtonSecond1D</code></p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><code>Mass -&gt; [State1D -&gt; Force] -&gt; State1D -&gt; (R, R, R)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><code>newtonSecondPS</code></p></td>&#13;
<td style="vertical-align: top;"><p class="taba"><code>[OneBodyForce] -&gt; ParticleState -&gt; DParticleState</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><code>newtonSecondMPS</code></p></td>&#13;
<td style="vertical-align: top;" class="backcolort"><p class="taba"><code>[Force] -&gt; MultiParticleState -&gt; DMultiParticleState</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>newtonSecondPFS</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba"><code>ParticleFieldState -&gt; DParticleFieldState</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Recall that a numerical method allows us to transform a differential equation into a state-update function. State-update functions are important for animation and also for solving problems by obtaining a list of states.</p>&#13;
<p class="indent">The function <code>pfsUpdate</code> (<code>pfs</code> for <code>ParticleFieldState</code>, but lowercase since functions must begin with a lowercase letter) will serve as a state-update function for animation, or for producing a list of states.</p>&#13;
<pre>pfsUpdate :: R  -- time step&#13;
          -&gt; ParticleFieldState -&gt; ParticleFieldState&#13;
pfsUpdate dt = rungeKutta4 dt newtonSecondPFS</pre>&#13;
<p class="indent">The function uses fourth-order Runge-Kutta, simply because it tends to give the best results, but we could use any numerical method.</p>&#13;
<p class="indent">With a state-update function in hand, we are ready to animate the motion of a charged particle in electric and magnetic fields.</p>&#13;
<h3 class="h3" id="ch28lev7">Animating a Particle in Electric and Magnetic Fields</h3>&#13;
<p class="noindent">We want to use the <code>simulateVis</code> function to do 3D animation. This requires that we supply the five inputs to that function, which are a time-scale factor, an animation rate, an initial state, a display function, and a state-update function. The function <code>pfsUpdate</code> will serve as our state-update function.</p>&#13;
<p class="indent">Providing an initial state is made easier by defining a default state. With a default state in hand, we can specify an initial state by listing the items that differ from the default state. The default state has every state variable set to 0.</p>&#13;
<pre>defaultPFS :: ParticleFieldState&#13;
defaultPFS = ParticleFieldState { mass          = 0&#13;
                                , charge        = 0&#13;
                                , time          = 0&#13;
                                , position      = origin&#13;
                                , velocity      = zeroV&#13;
                                <span epub:type="pagebreak" id="page_545"/>, electricField = const zeroV&#13;
                                , magneticField = const zeroV }</pre>&#13;
<p class="indent">The following function, <code>pfsVisObject</code>, is a display function that displays the particle as a green sphere, the electric field as a collection of blue vectors, and the magnetic field as a collection of red vectors.</p>&#13;
<pre>pfsVisObject :: R  -- cube width&#13;
             -&gt; ParticleFieldState -&gt; V.VisObject R&#13;
pfsVisObject width st&#13;
    = let r = position st&#13;
          xs = [-width/2, width/2]&#13;
          es :: [(Position,Vec)]&#13;
          es = [(cart x y z, electricField st (cart x y z))&#13;
                    | x &lt;- xs, y &lt;- xs, z &lt;- xs]&#13;
          maxE = maximum $ map (magnitude . snd) es&#13;
          bs :: [(Position,Vec)]&#13;
          bs = [(cart x y z, magneticField st (cart x y z))&#13;
                    | x &lt;- xs, y &lt;- xs, z &lt;- xs]&#13;
          maxB = maximum $ map (magnitude . snd) bs&#13;
          metersPerVis = width/2&#13;
      in V.VisObjects [ vectorsVisObject metersPerVis (2*maxE) es V.blue&#13;
                      , vectorsVisObject metersPerVis (2*maxB) bs V.red&#13;
                      , V.Trans (v3FromPos (scalePos metersPerVis r))&#13;
                            (V.Sphere 0.1 V.Solid V.green)&#13;
                      ]</pre>&#13;
<p class="indent">This function takes a real number as input that specifies the width of the cube of space we want to display. It calculates the electric field at a collection of eight locations and then finds the maximum electric field magnitude so that it can scale the displayed electric field vectors. It then calculates the magnetic field at the same eight locations and finds the maximum magnetic field magnitude so that it can scale the displayed magnetic field vectors.</p>&#13;
<p class="indent">The function uses another function, called <code>vectorsVisObject</code>, to make the pictures of electric field and magnetic field.</p>&#13;
<pre>vectorsVisObject :: R  -- scale factor, meters per Vis unit&#13;
                 -&gt; R  -- scale factor, vector field units per Vis unit&#13;
                 -&gt; [(Position,Vec)]  -- positions to show the field&#13;
                 -&gt; V.Color&#13;
                 -&gt; V.VisObject R&#13;
vectorsVisObject metersPerVis unitsPerVis pvs color&#13;
    = V.VisObjects [V.Trans (v3FromPos (scalePos metersPerVis r)) $&#13;
                     visVec color (v ^/ unitsPerVis) | (r,v) &lt;- pvs]</pre>&#13;
<p class="indent">This function takes two scale factors as input: one specifying the number of meters per Vis unit, and another giving the number of vector field units per Vis unit. It then takes a list of pairs of positions and vectors to <span epub:type="pagebreak" id="page_546"/>be displayed and a color for the vectors. The function <code>pfsVisObject</code> uses <code>vectorsVisObject</code> twice: once for the electric field and once for the magnetic field.</p>&#13;
<p class="indent">Both <code>pfsVisObject</code> and <code>vectorsVisObject</code> use another helping function, called <code>scalePos</code>, that scales positions.</p>&#13;
<pre>scalePos :: R -&gt; Position -&gt; Position&#13;
scalePos metersPerVis (Cart x y z)&#13;
    = Cart (x/metersPerVis) (y/metersPerVis) (z/metersPerVis)</pre>&#13;
<p class="indent">This function works by scaling each position coordinate.</p>&#13;
<p class="indent">Our main program, called <code>animatePFS</code>, is a fun toy to play with. We can set the electric and magnetic fields to be whatever we wish and the initial conditions of the particle to be whatever we wish, and we can see what happens.</p>&#13;
<pre>animatePFS :: R                   -- time scale factor&#13;
           -&gt; Int                 -- animation rate&#13;
           -&gt; R                   -- display width&#13;
           -&gt; ParticleFieldState  -- initial state&#13;
           -&gt; IO ()&#13;
animatePFS tsf ar width st&#13;
    = simulateVis tsf ar st (pfsVisObject width) pfsUpdate</pre>&#13;
<p class="indent">The function takes a time-scale factor and an animation rate as inputs, along with a display width and an initial state. It calls <code>simulateVis</code> to do the animation.</p>&#13;
<p class="indent">The next two subsections show specific animations for a proton in uniform electric and magnetic fields and for a classical electron orbiting a proton.</p>&#13;
<h4 class="h4" id="ch28lev8">Uniform Fields</h4>&#13;
<p class="noindent"><a href="ch28.xhtml#ch28list1">Listing 28-1</a> displays the motion of a proton in uniform electric and magnetic fields. The initial state of the system gives the proton mass, the proton charge, the initial proton velocity, the electric field, and the magnetic field. The electric field is a uniform field in the y-direction, and the magnetic field is a uniform field in the z-direction. The proton makes a curious hopping motion in the presence of these fields.</p>&#13;
<pre id="ch28list2">{-# OPTIONS -Wall #-}&#13;
&#13;
import SimpleVec ( vec )&#13;
import Electricity ( elementaryCharge )&#13;
import Lorentz ( ParticleFieldState(..), animatePFS, defaultPFS )&#13;
&#13;
main :: IO ()&#13;
main = animatePFS 1e-5 30 0.05&#13;
       ( defaultPFS { mass          = 1.673e-27  -- proton in kg&#13;
                    , charge        = elementaryCharge&#13;
                    <span epub:type="pagebreak" id="page_547"/>, velocity      = vec 0 2000 0&#13;
                    , electricField = \_ -&gt; vec 0 20 0&#13;
                    , magneticField = \_ -&gt; vec 0  0 0.01 } )</pre>&#13;
<p class="listing"><em>Listing 28-2: Stand-alone program animating a proton in uniform electric and magnetic fields</em></p>&#13;
<p class="indent">By changing the electric field, the magnetic field, or the initial velocity of the proton, you can see many different sorts of motion. <a href="ch28.xhtml#ch28fig1">Figure 28-1</a> shows a snapshot of the animation.</p>&#13;
<div class="imagel" id="ch28fig1"><img src="Images/547fig01.jpg" alt="Image" width="575" height="327"/></div>&#13;
<p class="figcap"><em>Figure 28-1: A screenshot of the animation showing the motion of a proton in particular electric and magnetic fields</em></p>&#13;
<h4 class="h4" id="ch28lev9">Classical Hydrogen</h4>&#13;
<p class="noindent">Our second specific animation is a classical hydrogen atom. Hydrogen is the simplest atom, composed only of a proton and an electron. We need quantum mechanics to describe the properties of hydrogen correctly, but we will explore the Newtonian motion of an electron in the electric field created by a proton. This electric field provides an example of a non-uniform field, showing that our code can handle arbitrary electric and magnetic fields. It is important to note that our classical hydrogen atom uses the classical theory of Newtonian mechanics, but it does not use the full Faraday-Maxwell theory of electrodynamics, which is often regarded as “classical” because it is non-quantum. The Faraday-Maxwell theory, which we explore in the final chapter of this book, predicts that the electron radiates electromagnetic energy, causing it to spiral inward. Here we treat a simpler version of classical hydrogen in which the electron does not radiate.</p>&#13;
<p class="indent"><a href="ch28.xhtml#ch28list3">Listing 28-3</a> displays the motion of an electron in the presence of the electric field produced by a proton at the origin.</p>&#13;
<pre id="ch28list3">{-# OPTIONS -Wall #-}&#13;
&#13;
import SimpleVec ( vec )&#13;
import Electricity ( elementaryCharge )&#13;
import CoordinateSystems ( cart )&#13;
<span epub:type="pagebreak" id="page_548"/>import Charge ( protonOrigin )&#13;
import ElectricField ( eField, epsilon0 )&#13;
import Lorentz ( ParticleFieldState(..), animatePFS, defaultPFS )&#13;
&#13;
main :: IO ()&#13;
main = animatePFS period 30 (4*bohrRadius)&#13;
       ( defaultPFS { mass          = electronMass&#13;
                    , charge        = -elementaryCharge  -- electron charge&#13;
                    , position      = cart bohrRadius 0 0&#13;
                    , velocity      = vec 0 v0 0&#13;
                    , electricField = eField protonOrigin } )&#13;
           where electronMass = 9.109e-31  -- kg&#13;
                 bohrRadius   = 0.529e-10  -- meters&#13;
                 v0 = elementaryCharge&#13;
                      / sqrt (4 * pi * epsilon0 * electronMass * bohrRadius)&#13;
                 period = 2 * pi * bohrRadius / v0</pre>&#13;
<p class="listing"><em>Listing 28-3: Stand-alone program animating the electron in classical hydrogen</em></p>&#13;
<p class="indent">In this case, we use several local variables to determine the initial velocity for circular motion, which is needed in the initial state, and the period of the motion, which is used in the time-scale factor. The electron executes circular motion, much like a satellite orbiting a planet. <a href="ch28.xhtml#ch28fig2">Figure 28-2</a> shows a snapshot of the animation of the electron in the electric field produced by a proton.</p>&#13;
<div class="imagel" id="ch28fig2"><img src="Images/548fig01.jpg" alt="Image" width="575" height="327"/></div>&#13;
<p class="figcap"><em>Figure 28-2: A screenshot of the animation showing the motion of an electron in the electric field produced by a proton</em></p>&#13;
<h3 class="h3" id="ch28lev10">Summary</h3>&#13;
<p class="noindent">This chapter dealt with the aspect of electromagnetic theory in which fields apply force to charge. The Lorentz force law describes the force that electric and magnetic fields exert on charge. We then found the motion of a charged particle in electric and magnetic fields by using Newton’s second <span epub:type="pagebreak" id="page_549"/>law, as we did in <a href="part02.xhtml">Part II</a> of the book. We defined a new state space for one particle with electric and magnetic fields. Our differential equation and state-update rule modified only the particle state, leaving the state of the electric and magnetic fields unchanged. We complete the state-update project in the next chapter, where the Maxwell equations describe how the electric and magnetic fields change in time.</p>&#13;
<h3 class="h3" id="ch28lev11">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 28.1.</strong> Write a function called <code>eulerCromerPFS</code>, analogous to the function <code>eulerCromerPS</code> from <a href="ch16.xhtml">Chapter 16</a>, that implements the Euler-Cromer method with the <code>ParticleFieldState</code> data type. Test it out by rewriting <code>pfsUpdate</code> with <code>eulerCromerPFS</code> in place of <code>rungeKutta4</code>. Recompile the animation code and see if there are any noticeable differences.</p>&#13;
<p class="noindentts"><strong>Exercise 28.2.</strong> Suppose a particle with charge 9 nC is fixed at the origin. (9 nC is about the charge your sock might have coming out of the dryer.) A proton released from rest a distance 1 mm away will accelerate away from the origin. Make graphs of the proton position and proton velocity as functions of time.</p>&#13;
<p class="noindentts"><strong>Exercise 28.3.</strong> Suppose a 1-m × 1-m plate has a uniform surface charge density of 9 nC/m<sup>2</sup>. (9 nC of charge would raise its potential to a few tens of volts.) A proton is released from rest a distance 1 mm from the center of the plate and accelerates away from the plate. Make graphs of the proton position, velocity, and acceleration as functions of time.</p>&#13;
<p class="noindentts"><strong>Exercise 28.4.</strong> A current loop with a radius of 10 cm carries a current of 100 A. (A 100-A current is usually the maximum a small house or large apartment will draw.) Let’s fix the loop in the xy-plane, center it at the origin, and have the current flow counterclockwise as viewed from the positive z-axis. We wish to see the effect on a proton traveling near the loop. Let’s start the proton at position</p>&#13;
<p class="centere">(<em>x, y, z</em>) = (11 cm, −1 m, 0)</p>&#13;
<p class="noindentts">and give it an initial velocity in the positive y-direction. The proton should deflect to the left when it gets near the current loop since currents flowing in the same direction attract. Make pictures of the proton’s trajectory in the xy-plane. Explore how the deflection depends on the initial proton velocity.</p>&#13;
<p class="noindentts"><strong>Exercise 28.5.</strong> Explore the motion of a proton in a uniform magnetic field with no electric field. By changing the initial velocity, you should be able to get the proton to move in a circle, a helix, and a line. Which initial velocities produce each motion?</p>&#13;
<p class="noindentts"><strong>Exercise 28.6.</strong> Rewrite the function <code>newtonSecondPFS</code> so that it takes a list of non-electromagnetic forces as input.</p>&#13;
<pre>newtonSecondPFS' :: [ParticleFieldState -&gt; Vec]&#13;
                 -&gt; ParticleFieldState -&gt; DParticleFieldState&#13;
newtonSecondPFS' fs st = undefined fs st<span epub:type="pagebreak" id="page_550"/></pre>&#13;
</div></body></html>