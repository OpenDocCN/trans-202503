- en: '[4](nsp-boxall502581-0008.xhtml#rch04)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communicating with the Outside World using the USART
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/nsp-boxall502581-ct.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter will teach you to use the *universal synchronous and asynchronous
    receiver-transmitter (USART)* , a dedicated two-way port that transfers information
    from the AVR to a computer and allows the two to communicate. The USART lets you
    control your AVR projects from a computer. It can also help you debug your projects, since
    you can send status reports from the AVR back to the computer to keep track of
    the code’s progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter you will:'
  prefs: []
  type: TYPE_NORMAL
- en: • Use terminal emulation software on your computer to act as an input and output
    device for your AVR-based projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Send serial data between your AVR and your computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Transfer data, including numbers and letters, from an AVR to a computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Familiarize yourself with ASCII codes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along the way, you’ll learn to log temperature readings from a thermometer to
    a PC for later analysis and build a simple calculator.
  prefs: []
  type: TYPE_NORMAL
- en: '[Introducing the USART](nsp-boxall502581-0008.xhtml#rah0601)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways for computers to communicate with one another. One method
    is to use *serial data* , the process of sequentially sending data one bit at
    a time. AVR-based projects do this using the AVR’s USART. The USART on the ATmega328P-PU
    microcontroller uses pin 2 to receive data and pin 3 to send data. Data is sent
    and received in *bytes* , where each byte represents 8 bits of data.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of sending 1s and 0s, which is how computers represent bytes, their
    values are represented by changing voltage levels over a certain time period.
    A high voltage represents a 1, while a low voltage represents a 0\. Each byte
    begins with a start bit, which is always a 0, and an end bit, which is always
    a 1\. The byte of data is sent and received with the rightmost or least significant
    bit first.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll demonstrate what these bytes of data look like with a digital storage oscilloscope,
    which, as you saw in [Chapter 3](nsp-boxall502581-0013.xhtml#ch03) , is a device
    that can display the change in voltage over a period of time. For example, consider
    [Figure 4-1](nsp-boxall502581-0014.xhtml#f04001) , which shows a byte of data
    representing the number 10 sent from the USART.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing a graph of voltage going low and high with the numbers
    0010100001 below accordingly](images/nsp-boxall502581-f04001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-1: A byte of data represented on the DSO'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how to translate this into the decimal number 10\. The start bit is
    always 0, so the voltage is first low, then low again (0), then high (1), then
    low, then high, then low for four periods, followed by high (the end bit, which
    is always 1). This gives us the binary number 01010000, but because bytes are
    sent and received with the LSB first, we have to flip it around. This leaves us
    with 00001010, the binary representation of the decimal number 10.
  prefs: []
  type: TYPE_NORMAL
- en: Data is sent and received at various speeds. In [Figure 4-1](nsp-boxall502581-0014.xhtml#f04001)
    , and all our projects in this chapter, the data speed is 4,800bps (bits per second).
  prefs: []
  type: TYPE_NORMAL
- en: '[Hardware and Software for USART Communication](nsp-boxall502581-0008.xhtml#rah0602)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To prepare your computer to send and receive data to and from your AVR microcontroller,
    you’ll need two things: a USB-to-serial converter and suitable terminal software
    on your computer.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with the *USB-to-serial converter* , the easiest way to connect
    your AVR projects to a computer. There are many different types of these converters,
    but for this book, I recommend using one built into a cable for convenience. I
    use a PL2303TA-type USB-to-serial cable, like the one shown in [Figure 4-2](nsp-boxall502581-0014.xhtml#f04002)
    . CP2102 and CP2104 cables are also popular. Install the drivers for your converter
    cable as instructed by the supplier.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image of a PL2303TA USB-to-serial converter cable](images/nsp-boxall502581-f04002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-2: A PL2303TA-type USB-to-serial converter cable'
  prefs: []
  type: TYPE_NORMAL
- en: To interact with your computer via your AVR-based project, you’ll also need
    a *terminal emulator* , a simple program that captures and displays incoming data
    from your AVR and lets you send data from your computer to the AVR. CoolTerm is
    an excellent terminal emulator by Roger Meier available for various platforms;
    you can download it from his website at [http://freeware.the-meiers.org/](http://freeware.the-meiers.org/)
    . The software is free, but please consider donating via the website to support
    Meier’s efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have downloaded and installed CoolTerm, plug your USB-to-serial converter
    into your computer, open CoolTerm, and click the **Options** button located at
    the top of the window. The screen in [Figure 4-3](nsp-boxall502581-0014.xhtml#f04003)
    should appear.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of CoolTerm’s Connection Options window, displaying the Serial
    Port configuration options. Port is set to COM5, Baudrate to 4800, and Data Bits
    to 8; the remaining options use the default values.](images/nsp-boxall502581-f04003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-3: CoolTerm’s Serial Port Options configuration screen'
  prefs: []
  type: TYPE_NORMAL
- en: I use Windows in my examples throughout this book, but CoolTerm should look
    similar when running on other platforms. Change the serial port options settings
    to match those shown in [Figure 4-3](nsp-boxall502581-0014.xhtml#f04003) , except
    for Port, which will vary depending on your computer—change it to match the name
    of your USB converter. For example, for Windows PCs, use the drop-down menu beside
    Port to select the COM port your USB-to-serial converter is using.
  prefs: []
  type: TYPE_NORMAL
- en: Next, select the **Terminal** option from the list on the left, change the settings
    to match those shown in [Figure 4-4](nsp-boxall502581-0014.xhtml#f04004) , and
    click **OK** .
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of CoolTerm’s Connection Options window displaying the terminal
    options. The Terminal Mode option is set to Line Mode and the other options are
    the defaults.](images/nsp-boxall502581-f04004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-4: CoolTerm’s Terminal Options configuration screen'
  prefs: []
  type: TYPE_NORMAL
- en: Once CoolTerm is configured correctly, the window shown in [Figure 4-5](nsp-boxall502581-0014.xhtml#f04005)
    should appear, indicating CoolTerm is ready for use.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the CoolTerm terminal software ready for use, but not
    connected to the serial port](images/nsp-boxall502581-f04005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-5: CoolTerm ready for use'
  prefs: []
  type: TYPE_NORMAL
- en: You’re now ready to put your USB-to-serial converter and terminal software to
    the test.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 16: Testing the USART](nsp-boxall502581-0008.xhtml#rpro16)'
  prefs: []
  type: TYPE_NORMAL
- en: In this project you’ll use the USART for the first time, testing your USB-to-serial
    connection and hardware. This will prepare you for more advanced projects in which
    you send data from your AVR back to the computer to debug your code and check
    its progress.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0601)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this project, you’ll need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • USB-to-serial converter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Connect the USBasp to your microcontroller via the solderless breadboard, as
    you have for the previous projects. Next, find the four connections on your USB-to-serial
    converter: GND, TX, RX, and V [CC] (or 5 V). Connect the first three pins to the
    microcontroller as directed in [Table 4-1](nsp-boxall502581-0014.xhtml#tab0401)
    . If you are using the PL2303TA cable shown in [Figure 4-2](nsp-boxall502581-0014.xhtml#f04002)
    , the white wire is RX and the green wire is TX. If you are using a different
    model, consult the supplier’s instructions to determine the correct wires.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Table 4-1 : USB-to-Serial Converter to Microcontroller Connections |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| USB-to-serial converter pin | ATmega328P-PU pin |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GND | 8 GND |'
  prefs: []
  type: TYPE_TB
- en: '| TX | 2 RX |'
  prefs: []
  type: TYPE_TB
- en: '| RX | 3 TX |'
  prefs: []
  type: TYPE_TB
- en: You’ll be using this hardware for the next three projects in this chapter, so
    keep it intact once you’ve assembled it.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0602)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 16* subfolder of this book’s
    *Chapter 4* folder, and enter the `make flash` command. The toolchain should compile
    the program files in the subfolder and then upload the data to the microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: Next, switch over to the terminal software and click the **Connect** button.
    After a moment, the CoolTerm window should fill with the timeless message `Hello
    world` , as shown in [Figure 4-6](nsp-boxall502581-0014.xhtml#f04006) .
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the CoolTerm terminal receiving text from the AVR project
    via the serial-to-USB adaptor. The text “Hello world” is displayed repeatedly
    on a series of lines, as this is what the project is transmitting.](images/nsp-boxall502581-f04006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-6: Success! The [Project 16](nsp-boxall502581-0014.xhtml#pro16) code
    prints “Hello world” across the terminal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this is accomplished, open the *main.c* file located in the *Project
    16* subfolder, which contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Before using the USART, you must initialize it and set the data speed (4800bps
    in this example) ❶. All the initialization code is inside the `USARTInit()` function
    ❷, which needs to be called once during the main loop in the code ❺.
  prefs: []
  type: TYPE_NORMAL
- en: The `USARTSendByte()` function ❸ sends a byte of data from the USART to your
    computer. This function waits for the USART to clear old data before sending the
    new byte of data in the form of an 8-bit integer (the data type `uint8_t` ).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the text “Hello world” is sent using the `HelloWorld()` function ❹.
    Notice that instead of directly sending letters, we send numbers that each represent
    a letter. For reference, I’ve commented in the code which letters each number
    corresponds to. These numbers are part of *ASCII code* , originally devised for
    sending messages between telegraph and older communications systems. You can find
    a copy of the ASCII control code chart at [https://en.wikipedia.org/wiki/ASCII](https://en.wikipedia.org/wiki/ASCII)
    .
  prefs: []
  type: TYPE_NORMAL
- en: You can experiment with this code by changing the text sent to the computer;
    just substitute your own ASCII codes in the `USARTSendByte()` function calls.
    Don’t spend too long on this, though, because the [next project](nsp-boxall502581-0014.xhtml#pro17)
    shows you a better way to transmit text.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, always click **Disconnect** in CoolTerm when you’ve finished monitoring
    the USART.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 17: Sending Text with the USART](nsp-boxall502581-0008.xhtml#rpro17)'
  prefs: []
  type: TYPE_NORMAL
- en: This project uses the same hardware as [Project 16](nsp-boxall502581-0014.xhtml#pro16)
    . Open a terminal window, navigate to the *Project 17* subfolder of this book’s
    *Chapter 4* folder, and enter the `make flash` command to upload the code from
    [Project 17](nsp-boxall502581-0014.xhtml#pro17) as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Next, switch over to the terminal software and click the **Connect** button.
    After a moment, the screen should once again fill with `Hello, world` —this time
    in a single column, as shown in [Figure 4-7](nsp-boxall502581-0014.xhtml#f04007)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the CoolTerm terminal software displaying the text “Hello,
    world” repeatedly, once per line](images/nsp-boxall502581-f04007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-7: Example result from [Project 17](nsp-boxall502581-0014.xhtml#pro17)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for [Project 17](nsp-boxall502581-0014.xhtml#pro17) is the same as
    that for [Project 16](nsp-boxall502581-0014.xhtml#pro16) , except that it except
    it uses a *character array* to simplify the process of sending text. These arrays
    store one or more characters, which can be letters, numbers, symbols, and anything
    else you can generate with your keyboard. They are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: where `x` is the maximum number of characters that can appear in the array (it’s
    always a good idea to include this).
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how to transmit text in this way, open the *main.c* file located in
    the *Project 17* subfolder, which contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the main loop, we define a character array with our `Hello, world` message
    ❷. The `\r` and `\n` beside that message are *silent control codes* , also known
    as *escape sequences* , which send information to the terminal software but aren’t
    themselves displayed. `\r` instructs the software to move the cursor to the start
    of the line and `\n` instructs it to move the cursor down to the next vertical
    position; the combination `\r\n` thus moves the cursor to the start of the next
    line in the terminal display, so that the output is printed in an organized column.
  prefs: []
  type: TYPE_NORMAL
- en: We use a new function called `sendString()` ❶ to read each character of the
    array we defined and send them to the USART one by one, by looping from zero (the
    first position of an array is always zero) until there are no more characters.
    During each iteration of the loop, the AVR sends the current byte in the array
    to the USART.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you receive an error message after entering your code, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: that means you’re using the wrong kind of quotes to define your character array.
    Make sure you are using straight quotes ( `"` ) and not curly quotes ( `”` ).
    You may need to change the auto-correct settings in your text editor to prevent
    the incorrect quotes from appearing.
  prefs: []
  type: TYPE_NORMAL
- en: In the [next project](nsp-boxall502581-0014.xhtml#pro18) , you’ll learn how
    to send data from the AVR to the terminal software on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 18: Sending Numbers with the USART](nsp-boxall502581-0008.xhtml#rpro18)'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll often need to send numbers between your AVR and your computer. For example,
    you may want to log data generated by your hardware, send output from an interface
    you created, or just send simple status reports from your AVR when debugging a
    project. In this project, you’ll learn how to send both integers and floating-point
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: This project once again uses the same hardware as [Project 16](nsp-boxall502581-0014.xhtml#pro16)
    . Open a terminal window, navigate to the *Project 18* subfolder of this book’s
    *Chapter 4* folder, and enter the `make flash` command to upload the code as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Next, switch over to the terminal software and click the **Connect** button.
    After a moment the terminal software should display an integer and a floating-point
    number in turn, as shown in [Figure 4-8](nsp-boxall502581-0014.xhtml#f04008) .
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the CoolTerm terminal software displaying the output from
    Project 18: alternating lines of “Float— -12345.67” and “Integer— -32767.”](images/nsp-boxall502581-f04008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-8: Results of [Project 18](nsp-boxall502581-0014.xhtml#pro18)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open the *main.c* file located in the *Project 18* subfolder, which contains
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This code sends text stored in character arrays to the computer, just like
    in [Project 17](nsp-boxall502581-0014.xhtml#pro17) . However, it includes some
    incredibly useful new functions. Before we can send floating-point and integer
    variables to the USART, we need to convert them into character arrays themselves.
    We do so with the `dtostrf()` function, included by default in AVR C compilers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This function takes the floating-point number `j` and places it into character
    array `t[]` . The variable `d` sets the number of decimal places for the fraction,
    and the variable `w` sets the total number of characters that display the array.
    We use the `dtostrf()` function in the project code to convert our floating-point
    variable to a character array before sending it to the USART ❶. To convert an
    integer to a character array, we use the same function but place the prefix `(float)`
    before the integer variable ❷.
  prefs: []
  type: TYPE_NORMAL
- en: In the [next project](nsp-boxall502581-0014.xhtml#pro19) , you’ll put your newfound
    knowledge of converting integers and floats into character arrays to good use
    by sending thermometer data to your PC.
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 19: Creating a Temperature Data Logger](nsp-boxall502581-0008.xhtml#rpro19)'
  prefs: []
  type: TYPE_NORMAL
- en: In this project you’ll send readings from the TMP36 temperature sensor you used
    in [Project 15](nsp-boxall502581-0013.xhtml#pro15) in [Chapter 3](nsp-boxall502581-0013.xhtml#ch03)
    to your computer. The terminal software will capture the data in a text file,
    which you can then open in a spreadsheet for further analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Hardware](nsp-boxall502581-0008.xhtml#rbh0603)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: • USBasp programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 5 V breadboard power supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • ATmega328P-PU microcontroller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • One TMP36 temperature sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • 0.1 μF ceramic capacitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • USB-to-serial converter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble your circuit as shown in [Figure 4-9](nsp-boxall502581-0014.xhtml#f04009)
    , then connect your USB-to-serial converter as usual.
  prefs: []
  type: TYPE_NORMAL
- en: '![Schematic diagram for Project 19](images/nsp-boxall502581-f04009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-9: Schematic for [Project 19](nsp-boxall502581-0014.xhtml#pro19)'
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal window, navigate to the *Project 19* subfolder of this book’s
    *Chapter 4* folder, and enter the `make flash` command to upload the code for
    [Project 19](nsp-boxall502581-0014.xhtml#pro19) .
  prefs: []
  type: TYPE_NORMAL
- en: Next, switch over to the terminal software and click the **Connect** button.
    After a moment, the terminal software should begin displaying the ambient temperature
    as measured by the sensor, as shown in [Figure 4-10](nsp-boxall502581-0014.xhtml#f04010)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of Project 19 in operation. Temperature output from the AVR
    is displayed in CoolTerm and is updated around once per second, varying between
    10.80 and 14.60 degrees Celsius.](images/nsp-boxall502581-f04010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-10: The temperature sensor at work'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this project combines your existing knowledge of the temperature
    sensor and sending text and numbers to the terminal software via the USART. To
    show some variance in the example output, I used a small fan to change the airflow
    around the temperature sensor. This helped change the measured temperature, which
    is captured once per second.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-boxall502581-0008.xhtml#rbh0604)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To see how the functions used in this project convert the temperature into
    an array and send it out, open the *main.c* file located in the *Project 19* subfolder
    and take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the code between ❶ and ❷ the microcontroller’s ADCs are initialized, then
    used. Next, we convert the ADC data to a temperature in degrees Celsius ❸. Finally,
    we convert the temperature to a character array, which we send to the terminal
    emulator to create a nice output ❹. This is repeated once per second.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the terminal emulator software can capture the data received
    from the microcontroller into a text file, which you can open in a text editor
    or a spreadsheet for further analysis. To enable this in CoolTerm, select **Connection**
    ▸ **Capture to Text/Binary File** ▸ **Start** , as shown in [Figure 4-11](nsp-boxall502581-0014.xhtml#f04011)
    .
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the CoolTerm software in operation displaying temperature
    data sent from the project, with the Connection menu open and set to start recording
    by capturing data to a text file on the PC.](images/nsp-boxall502581-f04011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-11: Start recording data from the terminal.'
  prefs: []
  type: TYPE_NORMAL
- en: CoolTerm then asks you to select a location and name for the text file, as shown
    in [Figure 4-12](nsp-boxall502581-0014.xhtml#f04012) . Once you’ve done that,
    click **Save** , and the recording should start. You can pause and finish recording
    using the Pause and Stop options, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-boxall502581-f04012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-12: Select the filename and location to store the text file.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have captured all the temperature data you want, stop the recording
    in the terminal emulator software ( **Connection** ▸ **Capture to Text/Binary
    File** ▸ **Stop** ) and open the resulting text file in your spreadsheet software.
    For demonstration purposes, I’ve used Excel. Because this is a text file, you
    will be prompted to select a *text delimiter* , a single character to insert between
    data values to allow other software to easily collate the data. Select a space
    as your delimiter, as shown in [Figure 4-13](nsp-boxall502581-0014.xhtml#f04013)
    . Note that in the screenshot, “Treat consecutive delimiters as one” is selected;
    this removes duplicate blank columns if there are double spaces in your file.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the Text Import Wizard in Microsoft Excel, with Space
    selected as the delimiter and the “Treat consecutive delimiters as one” box checked.
    A preview of the data is provided at the bottom of the screen.](images/nsp-boxall502581-f04013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-13: Select the delimiter and preview the data.'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** to import the data. This should create a neat temperature data
    spreadsheet like the one in [Figure 4-14](nsp-boxall502581-0014.xhtml#f04014)
    , which you can analyze to your heart’s content.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of Microsoft Excel showing temperature data on the left in numeric
    form, and in a line graph on the right](images/nsp-boxall502581-f04014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-14: Temperature data ready for analysis'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this project uses temperature data, you can log anything sent from
    the AVR’s USART using the method demonstrated here. Keep this in mind if you need
    to record data in future experiments. For now, we’ll turn to our [next project](nsp-boxall502581-0014.xhtml#pro20)
    : sending data from the terminal software on the computer back to the AVR.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 20: Receiving Data from Your Computer](nsp-boxall502581-0008.xhtml#rpro20)'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll learn how to use your computer to control your AVR-based
    projects or make your own input device by sending data between your computer and
    the microcontroller in both directions via the USART.
  prefs: []
  type: TYPE_NORMAL
- en: This project uses the same hardware as [Project 16](nsp-boxall502581-0014.xhtml#pro16)
    . After reproducing that, open a terminal window, navigate to the *Project 20*
    subfolder of this book’s *Chapter 4* folder, and enter the `make flash` command
    to upload the code for [Project 20](nsp-boxall502581-0014.xhtml#pro20) .
  prefs: []
  type: TYPE_NORMAL
- en: Next, switch over to the terminal emulation software and click the **Options**
    button, then select **Terminal** from the list on the left-hand side of the window.
    Set Terminal Mode to **Raw Mode** , as shown in [Figure 4-15](nsp-boxall502581-0014.xhtml#f04015)
    , then click **OK** , then **Connect** .
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the Connection Options window in CoolTerm, with the Terminal
    Mode set to Raw Mode](images/nsp-boxall502581-f04015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-15: Changing the terminal emulator back to raw mode'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the terminal emulator in raw mode, type something on your keyboard.
    Every keystroke you type is sent to the AVR, which then sends it back to the terminal
    emulator for display. Whatever you type should appear in the terminal window,
    and the TX and RX indicators should blink.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how the USART receives your keystrokes and sends them back out, open
    the *main.c* file located in the *Project 20* subfolder and take a look at the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This code should be quite familiar to you now; it begins with the usual functions
    to initialize the USART and send bytes to the computer. However, it includes a
    new function called `USARTReceiveByte()` ❶, which waits for a byte of data to
    arrive at the USART, then places that data into an integer variable. In this case,
    the function places the incoming byte into the variable `tempByte` ❷. The `USARTSendByte()`
    function then sends the same byte of data back to the terminal emulator ❸. It’s
    as simple as that: a byte comes in and is sent back out.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Project 21: Building a Four-Function Calculator](nsp-boxall502581-0008.xhtml#rpro21)'
  prefs: []
  type: TYPE_NORMAL
- en: By now, you’ve learned to send and receive data between your AVR projects and
    a computer so that your projects can work with external data and commands. In
    this project you’ll use all the knowledge you’ve acquired in this and previous
    chapters to make a simple four-function calculator.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the previous projects in this chapter, you’ll use the basic AVR and USB-to-serial
    converter. After reproducing that setup, open a terminal window, navigate to the
    *Project 21* subfolder of this book’s *Chapter 4* folder, and enter the `make
    flash` command to upload this project’s code. When you flash the microcontroller
    with the code, you might receive a warning such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That’s okay, you can just continue as normal.
  prefs: []
  type: TYPE_NORMAL
- en: Next, open the terminal emulator, make sure the terminal mode is set to raw
    mode as in [Project 20](nsp-boxall502581-0014.xhtml#pro20) , then click **Connect**
    . After a moment, the calculator interface should appear in the terminal window,
    and you should be prompted to enter a command. This calculator can add, subtract,
    multiply, and divide single-digit numbers. [Figure 4-16](nsp-boxall502581-0014.xhtml#f04016)
    shows some examples; have fun and enter your own commands to see the results.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of CoolTerm showing the output of Project 21 in use. The output
    is examples of the user making calculations with all four operators.](images/nsp-boxall502581-f04016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-16: The calculator at work'
  prefs: []
  type: TYPE_NORMAL
- en: Open the *main.c* file in the *Project 21* subfolder. The code is just a sequence
    of events using functions from previous projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we first initialize the variables inside the `main()` function,
    then initialize the USART with the lines beginning at ❶. The program prompts the
    user to enter a command consisting of 3 bytes of data: the first digit, the operator,
    and then the second digit. The USART receives the first digit ❷, the operator
    ❺, and the second digit ❼ and sends them back to the terminal to give visual feedback
    at ❸, ❻, and ❽, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: When the user enters a digit, the terminal emulator sends the ASCII code for
    the digit, not the digit itself, to the AVR. The program then converts the ASCII
    code into the actual digit ❹ and places it in an integer variable ❾. This same
    process for converting ASCII codes to digits also determines which operator has
    been entered (for example, `+` , `-` , `*` , or `/` ).
  prefs: []
  type: TYPE_NORMAL
- en: The program then performs the required calculation on the two digits via the
    functions in the code’s last `switch()` function. Finally, the calculation’s result
    is converted to a character array and sent back to the terminal emulator with
    `sendString(b)` for the user to read ⓿. The calculator is now ready for another
    calculation.
  prefs: []
  type: TYPE_NORMAL
- en: The projects in this chapter showed you how to use your computer as a terminal
    with your AVR to send and receive data, preparing you to record and analyze data.
    In the [next chapter](nsp-boxall502581-0015.xhtml#ch05) I’ll show you how to use
    interrupts, a neat way to let your AVR to respond to input whenever it occurs,
    instead of at a planned moment in time.
  prefs: []
  type: TYPE_NORMAL
