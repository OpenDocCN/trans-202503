<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_9"/><strong><span class="big">2</span><br/>SELF-SUPERVISED LEARNING</strong></h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image" width="252" height="252"/></div>&#13;
<p class="noindent">What is self-supervised learning, when is it useful, and what are the main approaches to implementing it?</p>&#13;
<p class="indent"><em>Self-supervised learning</em> is a pretraining procedure that lets neural networks leverage large, unlabeled datasets in a supervised fashion. This chapter compares self-supervised learning to transfer learning, a related method for pretraining neural networks, and discusses the practical applications of self-supervised learning. Finally, it outlines the main categories of self-supervised learning.</p>&#13;
<h3 class="h3" id="ch00lev10"><strong>Self-Supervised Learning vs. Transfer Learning</strong></h3>&#13;
<p class="noindent">Self-supervised learning is related to transfer learning, a technique in which a model pretrained on one task is reused as the starting point for a model on a second task. For example, suppose we are interested in training an image classifier to classify bird species. In transfer learning, we would pretrain a convolutional neural network on the ImageNet dataset, a large, labeled image dataset with many different categories, including various objects and animals. After pretraining on the general ImageNet dataset, we would take that pretrained model and train it on the smaller, more specific target dataset that contains the bird species of interest. (Often, we just have to change the <span epub:type="pagebreak" id="page_10"/>class-specific output layer, but we can otherwise adopt the pretrained network as is.)</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig1">Figure 2-1</a> illustrates the process of transfer learning.</p>&#13;
<div class="image"><img id="ch2fig1" src="../images/02fig01.jpg" alt="Image" width="665" height="552"/></div>&#13;
<p class="figcap"><em>Figure 2-1: Pretraining with conventional transfer learning</em></p>&#13;
<p class="indent">Self-supervised learning is an alternative approach to transfer learning in which the model is pretrained not on labeled data but on <em>unlabeled</em> data. We consider an unlabeled dataset for which we do not have label information, and then we find a way to obtain labels from the dataset’s structure to formulate a prediction task for the neural network, as illustrated in <a href="ch02.xhtml#ch2fig2">Figure 2-2</a>. These self-supervised training tasks are also called <em>pretext tasks</em>.</p>&#13;
<div class="image"><img id="ch2fig2" src="../images/02fig02.jpg" alt="Image" width="685" height="534"/></div>&#13;
<p class="figcap"><em>Figure 2-2: Pretraining with self-supervised learning</em><span epub:type="pagebreak" id="page_11"/></p>&#13;
<p class="indent">The main difference between transfer learning and self-supervised learning lies in how we obtain the labels during step 1 in <a href="ch02.xhtml#ch2fig1">Figures 2-1</a> and <a href="ch02.xhtml#ch2fig2">2-2</a>. In transfer learning, we assume that the labels are provided along with the data-set; they are typically created by human labelers. In self-supervised learning, the labels can be directly derived from the training examples.</p>&#13;
<p class="indent">A self-supervised learning task could be a missing-word prediction in a natural language processing context. For example, given the sentence “It is beautiful and sunny outside,” we can mask out the word <em>sunny</em>, feed the network the input “It is beautiful and [MASK] outside,” and have the network predict the missing word in the “[MASK]” location. Similarly, we could remove image patches in a computer vision context and have the neural network fill in the blanks. These are just two examples of self-supervised learning tasks; many more methods and paradigms for this type of learning exist.</p>&#13;
<p class="indent">In sum, we can think of self-supervised learning on the pretext task as <em>representation learning</em>. We can take the pretrained model to fine-tune it on the target task (also known as the <em>downstream</em> task).</p>&#13;
<h3 class="h3" id="ch00lev11"><strong>Leveraging Unlabeled Data</strong></h3>&#13;
<p class="noindent">Large neural network architectures require large amounts of labeled data to perform and generalize well. However, for many problem areas, we don’t have access to large labeled datasets. With self-supervised learning, we can leverage unlabeled data. Hence, self-supervised learning is likely to be useful when working with large neural networks and with a limited quantity of labeled training data.</p>&#13;
<p class="indent">Transformer-based architectures that form the basis of LLMs and vision transformers are known to require self-supervised learning for pretraining to perform well.</p>&#13;
<p class="indent">For small neural network models such as multilayer perceptrons with two or three layers, self-supervised learning is typically considered neither useful nor necessary.</p>&#13;
<p class="indent">Self-supervised learning likewise isn’t useful in traditional machine learning with nonparametric models such as tree-based random forests or gradient boosting. Conventional tree-based methods do not have a fixed parameter structure (in contrast to the weight matrices, for example). Thus, conventional tree-based methods are not capable of transfer learning and are incompatible with self-supervised learning.</p>&#13;
<h3 class="h3" id="ch00lev12"><strong>Self-Prediction and Contrastive Self-Supervised Learning</strong></h3>&#13;
<p class="noindent">There are two main categories of self-supervised learning: self-prediction and contrastive self-supervised learning. In <em>self-prediction</em>, illustrated in <a href="ch02.xhtml#ch2fig3">Figure 2-3</a>, we typically change or hide parts of the input and train the model to reconstruct the original inputs, such as by using a perturbation mask that obfuscates certain pixels in an image.<span epub:type="pagebreak" id="page_12"/></p>&#13;
<div class="image"><img id="ch2fig3" src="../images/02fig03.jpg" alt="Image" width="425" height="221"/></div>&#13;
<p class="figcap"><em>Figure 2-3: Self-prediction after applying a perturbation mask</em></p>&#13;
<p class="indent">A classic example is a denoising autoencoder that learns to remove noise from an input image. Alternatively, consider a masked autoencoder that reconstructs the missing parts of an image, as shown in <a href="ch02.xhtml#ch2fig4">Figure 2-4</a>.</p>&#13;
<div class="image"><img id="ch2fig4" src="../images/02fig04.jpg" alt="Image" width="923" height="293"/></div>&#13;
<p class="figcap"><em>Figure 2-4: A masked autoencoder reconstructing a masked image</em></p>&#13;
<p class="indent">Missing (masked) input self-prediction methods are also commonly used in natural language processing contexts. Many generative LLMs, such as GPT, are trained on a next-word prediction pretext task (GPT will be discussed at greater length in <a href="ch14.xhtml">Chapters 14</a> and <a href="ch17.xhtml">17</a>). Here, we feed the network text fragments, where it has to predict the next word in the sequence (as we’ll discuss further in <a href="ch17.xhtml">Chapter 17</a>).</p>&#13;
<p class="indent">In <em>contrastive self-supervised learning</em>, we train the neural network to learn an embedding space where similar inputs are close to each other and dissimilar inputs are far apart. In other words, we train the network to produce embeddings that minimize the distance between similar training inputs and maximize the distance between dissimilar training examples.</p>&#13;
<p class="indent">Let’s discuss contrastive learning using concrete example inputs. Suppose we have a dataset consisting of random animal images. First, we draw a random image of a cat (the network does not know the label, because we assume that the dataset is unlabeled). We then augment, corrupt, or perturb this cat image, such as by adding a random noise layer and cropping it differently, as shown in <a href="ch02.xhtml#ch2fig5">Figure 2-5</a>.<span epub:type="pagebreak" id="page_13"/></p>&#13;
<div class="image"><img id="ch2fig5" src="../images/02fig05.jpg" alt="Image" width="838" height="425"/></div>&#13;
<p class="figcap"><em>Figure 2-5: Image pairs encountered in contrastive learning</em></p>&#13;
<p class="indent">The perturbed cat image in this figure still shows the same cat, so we want the network to produce a similar embedding vector. We also consider a random image drawn from the training set (for example, an elephant, but again, the network doesn’t know the label).</p>&#13;
<p class="indent">For the cat-elephant pair, we want the network to produce dissimilar embeddings. This way, we implicitly force the network to capture the image’s core content while being somewhat agnostic to small differences and noise. For example, the simplest form of a contrastive loss is the <em>L</em><sub>2</sub>-norm (Euclidean distance) between the embeddings produced by model <em>M</em>(<em>·</em>). Let’s say we update the model weights to decrease the distance ||<em>M</em>(cat) – <em>M</em>(cat<em>′</em>)||<sub>2</sub> and increase the distance ||<em>M</em>(<em>cat</em>) – <em>M</em>(<em>elephant</em>)||<sub>2</sub>.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig6">Figure 2-6</a> summarizes the central concept behind contrastive learning for the perturbed image scenario. The model is shown twice, which is known as a <em>siamese network</em> setup. Essentially, the same model is utilized in two instances: first, to generate the embedding for the original training example, and second, to produce the embedding for the perturbed version of the sample.</p>&#13;
<div class="image"><img id="ch2fig6" src="../images/02fig06.jpg" alt="Image" width="857" height="329"/></div>&#13;
<p class="figcap"><em>Figure 2-6: Contrastive learning</em><span epub:type="pagebreak" id="page_14"/></p>&#13;
<p class="indent">This example outlines the main idea behind contrastive learning, but many subvariants exist. Broadly, we can categorize these into <em>sample</em> contrastive and <em>dimension</em> contrastive methods. The elephant-cat example in <a href="ch02.xhtml#ch2fig6">Figure 2-6</a> illustrates a sample contrastive method, where we focus on learning embeddings to minimize and maximize distances between training pairs. In <em>dimension</em>-contrastive approaches, on the other hand, we focus on making only certain variables in the embedding representations of similar training pairs appear close to each other while maximizing the distance of others.</p>&#13;
<h3 class="h3" id="ch00lev13"><strong>Exercises</strong></h3>&#13;
<p class="number"><strong>2-1.</strong> How could we apply self-supervised learning to video data?</p>&#13;
<p class="number"><strong>2-2.</strong> Can self-supervised learning be used for tabular data represented as rows and columns? If so, how could we approach this?</p>&#13;
<h3 class="h3" id="ch00lev14"><strong>References</strong></h3>&#13;
<ul>&#13;
<li class="noindent">For more on the ImageNet dataset: <em><a href="https://en.wikipedia.org/wiki/ImageNet">https://en.wikipedia.org/wiki/ImageNet</a></em>.</li>&#13;
<li class="noindent">An example of a contrastive self-supervised learning method: Ting Chen et al., “A Simple Framework for Contrastive Learning of Visual Representations” (2020), <em><a href="https://arxiv.org/abs/2002.05709">https://arxiv.org/abs/2002.05709</a></em>.</li>&#13;
<li class="noindent">An example of a dimension-contrastive method: Adrien Bardes, Jean Ponce, and Yann LeCun, “VICRegL: Self-Supervised Learning of Local Visual Features” (2022), <em><a href="https://arxiv.org/abs/2210.01571">https://arxiv.org/abs/2210.01571</a></em>.</li>&#13;
<li class="noindent">If you plan to employ self-supervised learning in practice: Randall Balestriero et al., “A Cookbook of Self-Supervised Learning” (2023), <em><a href="https://arxiv.org/abs/2304.12210">https://arxiv.org/abs/2304.12210</a></em>.</li>&#13;
<li class="noindent">A paper proposing a method of transfer learning and self-supervised learning for relatively small multilayer perceptrons on tabular datasets: Dara Bahri et al., “SCARF: Self-Supervised Contrastive Learning Using Random Feature Corruption” (2021), <em><a href="https://arxiv.org/abs/2106.15147">https://arxiv.org/abs/2106.15147</a></em>.</li>&#13;
<li class="noindent">A second paper proposing such a method: Roman Levin et al., “Transfer Learning with Deep Tabular Models” (2022), <em><a href="https://arxiv.org/abs/2206.15306">https://arxiv.org/abs/2206.15306</a></em>.</li>&#13;
</ul>&#13;
</div>
</div>
</body></html>