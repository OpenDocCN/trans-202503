<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Package Management"><div class="titlepage"><div><div><h1 class="title"><a id="package_management"/>Chapter 3. Package Management</h1></div></div></div><p><a id="iddle2383" class="indexterm"/>In this chapter, we take an in-depth look at Android package management. We begin with a description of Android’s package format and code signing implementation, and then detail the APK install process. Next, we explore Android’s support for encrypted APKs and secure application containers, which are used to implement a form of DRM for paid applications. Finally, we describe Android’s package verification mechanism and its most widely used implementation: the Google Play application verification service.</p><div class="sect1" title="Android Application Package Format"><div class="titlepage"><div><div><h1 class="title"><a id="android_application_package_format"/>Android Application Package Format</h1></div></div></div><p>Android applications are distributed and installed in the form of application package (APK) files, which are usually referred to as <span class="emphasis"><em>APK files</em></span>. APK files are container files that include both application code and resources, as well as the application manifest file. They can also include a code signature. The <a id="iddle1177" class="indexterm"/><a id="iddle1390" class="indexterm"/><a id="iddle2207" class="indexterm"/><a id="iddle2605" class="indexterm"/><a id="iddle3159" class="indexterm"/>APK format is an extension of the Java JAR format,<sup>[<a id="ch03fn01" href="#ftn.ch03fn01" class="footnote">17</a>]</sup> which in turn is an extension of the popular ZIP file format. APK files typically have the <span class="emphasis"><em>.apk</em></span> extension and are associated with the <span class="emphasis"><em>application/vnd.android.package-archive</em></span> MIME type.</p><p>Because APK files are simply ZIP files, you can easily examine their contents by extracting them with any compression utility that supports the ZIP format. <a class="xref" href="ch03.html#contents_of_a_typical_apk_file" title="Example 3-1. Contents of a typical APK file">Example 3-1</a> shows the contents of a typical APK file after it has been extracted.</p><div class="example"><a id="contents_of_a_typical_apk_file"/><p class="title">Example 3-1. Contents of a typical APK file</p><div class="example-contents"><pre class="programlisting">apk/
|-- AndroidManifest.xml➊
|-- classes.dex➋
|-- resources.arsc➌
|-- assets/➍
|-- lib/➎
|   |-- armeabi/
|   |   `-- libapp.so
|   `-- armeabi-v7a/
|       `-- libapp.so
|-- META-INF/➏
|   |-- CERT.RSA
|   |-- CERT.SF
|   `-- MANIFEST.MF
`-- res/➐
    |-- anim/
    |-- color/
    |-- drawable/
    |-- layout/
    |-- menu/
    |-- raw/
    `-- xml/</pre></div></div><p>Every APK file includes an <span class="emphasis"><em>AndroidManifest.xml</em></span> file ➊ which declares the application’s package name, version, components, and other metadata. The <span class="emphasis"><em>classes.dex</em></span> file ➋ contains the executable code of the application and is in the native DEX format of the Dalvik VM. The <span class="emphasis"><em>resources.arsc</em></span> ➌ packages all of the application’s compiled resources such as strings and styles. The <span class="emphasis"><em>assets</em></span> directory ➍ is used to bundle raw asset files with the application, such as fonts or music files.</p><p>Applications that take advantage of native libraries via JNI contain a <span class="emphasis"><em>lib</em></span> directory ➎, with subdirectories for each supported platform architecture. Resources that are directly referenced from Android code, either directly using the <code class="literal">android.content.res.Resources</code> class or indirectly via higher-level APIs, are stored in the <span class="emphasis"><em>res</em></span> directory ➐, with separate directories for each resource type (animations, images, menu definitions, and so on). Like JAR files, APK files also contain a <span class="emphasis"><em>META-INF</em></span> directory ➏, which hosts the package manifest file and code signatures. We’ll describe the contents of this directory in the next section.</p></div><div class="sect1" title="Code signing"><div class="titlepage"><div><div><h1 class="title"><a id="code_signing"/>Code signing</h1></div></div></div><p><a id="iddle1824" class="indexterm"/><a id="iddle2191" class="indexterm"/>As we learned in <a class="xref" href="ch02.html" title="Chapter 2. Permissions">Chapter 2</a>, Android uses APK code signing, in particular the APK signing certificate, in order to control which applications can be granted permission with the <span class="emphasis"><em>signature</em></span> protection level. The APK signing certificate is also used for various checks during the application installation process, so before we get into details about APK installation, we should become more familiar with code signing in Android. This section provides some details about Java code signing in general and highlights the differences with Android’s implementation.</p><p>Let’s start with a few words about code signing in general. Why would anyone want to sign code? For the usual reasons: integrity and authenticity. Before executing any third-party program, you want to make sure that it hasn’t been tampered with (integrity) and that it was actually created by the entity that it claims to come from (authenticity). These features are usually implemented by a digital signature scheme, which guarantees that only the entity owning the signing key can produce a valid code signature.</p><p>The signature verification process verifies both that the code has not been tampered with and that the signature was produced with the expected key. But one problem that code signing doesn’t solve directly is whether the code signer (software publisher) can be trusted. The usual way to establish trust is to require that the code signer holds a digital certificate and attaches it to the signed code. Verifiers decide whether to trust the certificate based on a trust model (such as PKI or web of trust) or on a case-by-case basis.</p><p>Another problem that code signing does not even attempt to solve is whether the signed code is safe to run. As Flame<sup>[<a id="ch03fn02" href="#ftn.ch03fn02" class="footnote">18</a>]</sup> and other code-signed malware have demonstrated, even code that appears to have been signed by a trusted third party might not be safe.</p><div class="sect2" title="Java Code Signing"><div class="titlepage"><div><div><h2 class="title"><a id="java_code_signing"/>Java Code Signing</h2></div></div></div><p>Java code signing is performed at the JAR file level. It reuses and extends JAR manifest files in order to add a code signature to the JAR archive. The main JAR manifest file (<span class="emphasis"><em>MANIFEST.MF</em></span>) has entries with the filename and digest value of each file in the archive. For example, <a class="xref" href="ch03.html#jar_manifest_file_excerpt" title="Example 3-2. JAR manifest file excerpt">Example 3-2</a> shows the start of the JAR manifest file of a typical APK file. (We’ll use APKs instead of regular JARs for all examples in this section.)</p><div class="example"><a id="jar_manifest_file_excerpt"/><p class="title">Example 3-2. JAR manifest file excerpt</p><div class="example-contents"><pre class="programlisting">Manifest-Version: 1.0
Created-By: 1.0 (Android)

Name: res/drawable-xhdpi/ic_launcher.png
SHA1-Digest: K/0Rd/lt0qSlgDD/9DY7aCNlBvU=
Name: res/menu/main.xml
SHA1-Digest: kG8WDil9ur0f+F2AxgcSSKDhjn0=

Name: ...</pre></div></div><div class="sect3" title="Implementation"><div class="titlepage"><div><div><h3 class="title"><a id="implementation"/>Implementation</h3></div></div></div><p><a id="iddle2393" class="indexterm"/><a id="iddle2828" class="indexterm"/>Java code signing is implemented by adding another manifest file called a <span class="emphasis"><em>signature file</em></span> (with extension <span class="emphasis"><em>.SF</em></span>), which contains the data to be signed, and a digital signature over it. The digital signature is called a <span class="emphasis"><em>signature block file</em></span> and is stored in the archive as a binary file with one of the <span class="emphasis"><em>.RSA</em></span>, <span class="emphasis"><em>.DSA</em></span>, or <span class="emphasis"><em>.EC</em></span> extensions, depending on the signature algorithm used. As shown in <a class="xref" href="ch03.html#jar_signature_file_excerpt" title="Example 3-3. JAR signature file excerpt">Example 3-3</a>, the signature file is very similar to the manifest.</p><div class="example"><a id="jar_signature_file_excerpt"/><p class="title">Example 3-3. JAR signature file excerpt</p><div class="example-contents"><pre class="programlisting">Signature-Version: 1.0
SHA1-Digest-Manifest-Main-Attributes: ZKXxNW/3Rg7JA1r0+RlbJIP6IMA=
Created-By: 1.7.0_51 (Sun Microsystems Inc.)
SHA1-Digest-Manifest: zb0XjEhVBxE0z2ZC+B4OW25WBxo=➊

Name: res/drawable-xhdpi/ic_launcher.png
SHA1-Digest: jTeE2Y5L3uBdQ2g40PB2n72L3dE=➋

Name: res/menu/main.xml
SHA1-Digest: kSQDLtTE07cLhTH/cY54UjbbNBo=➌

Name: ...</pre></div></div><p>The signature file contains the digest of the whole manifest file (<span class="emphasis"><em>SHA1-Digest-Manifest</em></span> ➊), as well as digests for each entry in <span class="emphasis"><em>MANIFEST.MF</em></span> (➋ and ➌). SHA-1 was the default digest algorithm until Java 6, but Java 7 and later can generate file and manifest digests using the SHA-256 and SHA-512 hash algorithms, in which case the digest attributes become <span class="emphasis"><em>SHA-256-Digest</em></span> and <span class="emphasis"><em>SHA-512-Digest</em></span>, respectively. Since version 4.3, Android supports SHA-256 and SHA-512 digests.</p><p>The digests in the signature file can easily be verified by using the following OpenSSL commands, as shown in <a class="xref" href="ch03.html#verifying_jar_signature_file_digests_usi" title="Example 3-4. Verifying JAR signature file digests using OpenSSL">Example 3-4</a>.</p><div class="example"><a id="verifying_jar_signature_file_digests_usi"/><p class="title">Example 3-4. Verifying JAR signature file digests using OpenSSL</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>openssl sha1 -binary MANIFEST.MF |openssl base64</strong></span>➊
zb0XjEhVBxE0z2ZC+B4OW25WBxo=
$ <span class="strong"><strong>echo -en "Name: res/drawable-xhdpi/ic_launcher.png\r\nSHA1-Digest: \</strong></span>
<span class="strong"><strong>K/0Rd/lt0qSlgDD/9DY7aCNlBvU=\r\n\r\n"|openssl sha1 -binary |openssl base64</strong></span>➋
jTeE2Y5L3uBdQ2g40PB2n72L3dE=</pre></div></div><p>The first command ➊ takes the SHA-1 digest of the entire manifest file and encodes it to Base64 to produce the <span class="emphasis"><em>SHA1-Digest-Manifest</em></span> value. The <a id="iddle2635" class="indexterm"/>second command ➋ simulates the way the digest of a single manifest entry is calculated. It also demonstrates the attribute canonicalization format required by the JAR specification.</p><p>The actual digital signature is in binary PKCS#7<sup>[<a id="ch03fn03" href="#ftn.ch03fn03" class="footnote">19</a>]</sup> (or more generally, CMS<sup>[<a id="ch03fn04" href="#ftn.ch03fn04" class="footnote">20</a>]</sup>) format and includes the signature value and signing certificate. Signature block files produced using the RSA algorithm are saved with the extension <span class="emphasis"><em>.RSA</em></span>, and those generated with DSA or EC keys are saved with <span class="emphasis"><em>.DSA</em></span> or <span class="emphasis"><em>.EC</em></span> extensions. Multiple signatures can also be performed, resulting in multiple <span class="emphasis"><em>.SF</em></span> and <span class="emphasis"><em>.RSA/DSA/EC</em></span> files in the JAR file’s <span class="emphasis"><em>META-INF</em></span> directory.</p><p>The CMS format is rather involved, allowing for signing <span class="emphasis"><em>and</em></span> encryption, both with different algorithms and parameters. It’s also extensible via custom signed or unsigned attributes. A thorough discussion is beyond the scope of this chapter (see RFC 5652 for details about CMS), but as used for JAR signing, a CMS structure basically contains the digest algorithm, signing certificate, and signature value. The CMS specifications allows for including signed data in the <code class="literal">SignedData</code> CMS structure (a format variation called <span class="emphasis"><em>attached signature</em></span>), but JAR signatures don’t include it. When the signed data is not included in the CMS structure, the signature is called a <span class="emphasis"><em>detached signature</em></span> and verifiers need to have a copy of the original signed data in order to verify it. <a class="xref" href="ch03.html#contents_of_a_jar_file_signature_block" title="Example 3-5. Contents of a JAR file signature block">Example 3-5</a> shows an RSA signature block file parsed into <span class="emphasis"><em>ASN.1</em></span>,<sup>[<a id="ch03fn05" href="#ftn.ch03fn05" class="footnote">21</a>]</sup> with the certificate details trimmed:</p><div class="example"><a id="contents_of_a_jar_file_signature_block"/><p class="title">Example 3-5. Contents of a JAR file signature block</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>openssl asn1parse -i -inform DER -in CERT.RSA</strong></span>
    0:d=0  hl=4 l= 888 cons: SEQUENCE
    4:d=1  hl=2 l=   9 prim:  OBJECT            :pkcs7-signedData➊
   15:d=1  hl=4 l= 873 cons:  cont [ 0 ]
   19:d=2  hl=4 l= 869 cons:   SEQUENCE
   23:d=3  hl=2 l=   1 prim:    INTEGER           :01➋
   26:d=3  hl=2 l=  11 cons:    SET
   28:d=4  hl=2 l=   9 cons:     SEQUENCE
   30:d=5  hl=2 l=   5 prim:      OBJECT            :sha1➌
   37:d=5  hl=2 l=   0 prim:      NULL
   39:d=3  hl=2 l=  11 cons:    SEQUENCE
   41:d=4  hl=2 l=   9 prim:     OBJECT            :pkcs7-data➍
   52:d=3  hl=4 l= 607 cons:    cont [ 0 ]➎
   56:d=4  hl=4 l= 603 cons:     SEQUENCE
   60:d=5  hl=4 l= 452 cons:      SEQUENCE
   64:d=6  hl=2 l=   3 cons:       cont [ 0 ]
   66:d=7  hl=2 l=   1 prim:        INTEGER           :02
   69:d=6  hl=2 l=   1 prim:       INTEGER           :04
   72:d=6  hl=2 l=  13 cons:       SEQUENCE
   74:d=7  hl=2 l=   9 prim:        OBJECT            :sha1WithRSAEncryption
   85:d=7  hl=2 l=   0 prim:        NULL
   87:d=6  hl=2 l=  56 cons:       SEQUENCE
   89:d=7  hl=2 l=  11 cons:       SET
   91:d=8  hl=2 l=   9 cons:        SEQUENCE
   93:d=9  hl=2 l=   3 prim:         OBJECT            :countryName
   98:d=9  hl=2 l=   2 prim:         PRINTABLESTRING   :JP
  --<span class="emphasis"><em>snip</em></span>--
  735:d=5  hl=2 l=   9 cons:     SEQUENCE
  737:d=6  hl=2 l=   5 prim:      OBJECT            :sha1➏
  744:d=6  hl=2 l=   0 prim:      NULL
  746:d=5  hl=2 l=  13 cons:     SEQUENCE
  748:d=6  hl=2 l=   9 prim:      OBJECT            :rsaEncryption➐
  759:d=6  hl=2 l=   0 prim:      NULL
  761:d=5  hl=3 l= 128 prim:    OCTET STRING       [HEX DUMP]:892744D30DCEDF74933007...➑</pre></div></div><p>The signature block contains an object identifier ➊ that describes the type of data (ASN.1 object) that follows: <code class="literal">SignedData</code>, and the data itself. The included <code class="literal">SignedData</code> object contains a version ➋ (1); a set of hash algorithm identifiers used ➌ (only one for a single signer, SHA-1 in this example); the type of data that was signed ➍ (<span class="emphasis"><em>pkcs7-data</em></span>, which simply means “arbitrary binary data”); the set of signing certificates ➎; and one or more (one for each signer) <code class="literal">SignerInfo</code> structures that encapsulates the signature value (not shown in full in <a class="xref" href="ch03.html#contents_of_a_jar_file_signature_block" title="Example 3-5. Contents of a JAR file signature block">Example 3-5</a>). <code class="literal">SignerInfo</code> contains a version; a <code class="literal">SignerIdentifier</code> object, which typically contains the DN of the certificate issuer and the certificate serial number (not shown); the digest algorithm used ➏ (SHA-1, included in ➌); the digest encryption algorithm used to generate the signature value ➐; and the encrypted digest (signature value) itself ➑.</p><p>The most important elements of the <code class="literal">SignedData</code> structure, with regard to JAR and APK signatures, are the set of signing certificates ➎ and the signature value ➑ (or values, when signed by multiple signers).</p><p>If we extract the contents of a JAR file, we can use the OpenSSL <code class="literal">smime</code> command to verify its signature by specifying the signature file as the content or signed data. The <code class="literal">smime</code> command prints the signed data and the verification result as shown in <a class="xref" href="ch03.html#verifying_a_jar_file_signature_block" title="Example 3-6. Verifying a JAR file signature block">Example 3-6</a>:</p><div class="example"><a id="verifying_a_jar_file_signature_block"/><p class="title">Example 3-6. Verifying a JAR file signature block</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>openssl smime -verify -in CERT.RSA -inform DER -content CERT.SF signing-cert.pem</strong></span>
Signature-Version: 1.0
SHA1-Digest-Manifest-Main-Attributes: ZKXxNW/3Rg7JA1r0+RlbJIP6IMA=
Created-By: 1.7.0_51 (Sun Microsystems Inc.)
SHA1-Digest-Manifest: zb0XjEhVBxE0z2ZC+B4OW25WBxo=

Name: res/drawable-xhdpi/ic_launcher.png
SHA1-Digest: jTeE2Y5L3uBdQ2g40PB2n72L3dE=

--<span class="emphasis"><em>snip</em></span>--
Verification successful</pre></div></div></div><div class="sect3" title="JAR File Signing"><div class="titlepage"><div><div><h3 class="title"><a id="jar_file_signing"/>JAR File Signing</h3></div></div></div><p><a id="iddle2003" class="indexterm"/><a id="iddle2819" class="indexterm"/><a id="iddle2919" class="indexterm"/><a id="iddle2943" class="indexterm"/>The official JDK tools for JAR signing and verification are the <code class="literal">jarsigner</code> and <code class="literal">keytool</code> commands. Since Java 5.0 <code class="literal">jarsigner</code> also supports timestamping the signature by a Timestamping Authority (TSA), which can be quite useful when you need to ascertain whether a signature was produced before or after the signing certificate expired. However, this feature is not widely used and is not supported on Android.</p><p>A JAR file is signed using the <code class="literal">jarsigner</code> command by specifying a key-store file (see <a class="xref" href="ch05.html" title="Chapter 5. Cryptographic Providers">Chapter 5</a>) together with the alias of the key to use for signing (the first eight characters of the alias become the base name for the signature block file, unless the <code class="literal">-sigfile</code> option is specified) and optionally a signature algorithm. See ➊ in <a class="xref" href="ch03.html#signing_an_apk_file_and_verifying_the_si" title="Example 3-7. Signing an APK file and verifying the signature using the jarsigner command">Example 3-7</a> for an example invocation of <code class="literal">jarsigner</code>.</p><div class="note" title="Note"><h3 class="title"><a id="ch03note01"/>Note</h3><p><span class="emphasis"><em>Since Java 7, the default algorithm has changed to</em></span> SHA256withRSA,<span class="emphasis"><em> so you need to specify it explicitly if you want to use SHA-1 for backward compatibility. SHA-256-and SHA-512-based signatures have been supported since Android 4.3.</em></span></p></div><div class="example"><a id="signing_an_apk_file_and_verifying_the_si"/><p class="title">Example 3-7. Signing an APK file and verifying the signature using the <code class="literal">jarsigner</code> command</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>jarsigner -keystore debug.keystore -sigalg SHA1withRSA test.apk androiddebugkey</strong></span>➊
$ <span class="strong"><strong>jarsigner -keystore debug.keystore -verify -verbose -certs test.apk</strong></span>➋
--<span class="emphasis"><em>snip</em></span>--

smk      965 Sat Mar 08 23:55:34 JST 2014 res/drawable-xxhdpi/ic_launcher.png

      X.509, CN=Android Debug, O=Android, C=US (androiddebugkey)➌
      [certificate is valid from 6/18/11 7:31 PM to 6/10/41 7:31 PM]

smk   458072 Sun Mar 09 01:16:18 JST 2013 classes.dex

      X.509, CN=Android Debug, O=Android, C=US (androiddebugkey)➍
      [certificate is valid from 6/18/11 7:31 PM to 6/10/41 7:31 PM]

         903 Sun Mar 09 01:16:18 JST 2014 META-INF/MANIFEST.MF
         956 Sun Mar 09 01:16:18 JST 2014 META-INF/CERT.SF
         776 Sun Mar 09 01:16:18 JST 2014 META-INF/CERT.RSA

  s = signature was verified
  m = entry is listed in manifest
  k = at least one certificate was found in keystore
  i = at least one certificate was found in identity scope

jar verified.</pre></div></div><p>The <code class="literal">jarsigner</code> tool can use all keystore types supported by the platform, as well as keystores that are not natively supported and that require a dedicated JCA provider, such as those backed by a smart card, HSM, or another hardware device. The type of store to be used for signing is specified with <a id="iddle1360" class="indexterm"/><a id="iddle2004" class="indexterm"/><a id="iddle2126" class="indexterm"/><a id="iddle2192" class="indexterm"/><a id="iddle2821" class="indexterm"/>the <code class="literal">-storetype</code> option, and the provider name and class with the <code class="literal">-providerName</code> and <code class="literal">-providerClass</code> options. Newer versions of the Android-specific <code class="literal">signapk</code> tool (discussed in “<a class="xref" href="ch03.html#android_code_signing_tools" title="Android Code Signing Tools">Android Code Signing Tools</a>”), also support the <code class="literal">-providerClass</code> option.</p></div><div class="sect3" title="JAR File Verification"><div class="titlepage"><div><div><h3 class="title"><a id="jar_file_verification"/>JAR File Verification</h3></div></div></div><p>JAR file verification is performed using the <code class="literal">jarsigner</code> command by specifying the <code class="literal">-verify</code> option. The second <code class="literal">jarsigner</code> command at ➋ in <a class="xref" href="ch03.html#signing_an_apk_file_and_verifying_the_si" title="Example 3-7. Signing an APK file and verifying the signature using the jarsigner command">Example 3-7</a> first verifies the signature block and signing certificate, ensuring that the signature file has not been tampered with. Next it verifies that each digest in the signature file (<span class="emphasis"><em>CERT.SF</em></span>) matches its corresponding section in the manifest file (<span class="emphasis"><em>MANIFEST.MF</em></span>). (The number of entries in the signature file does not have to match those in the manifest file. Files can be added to a signed JAR without invalidating its signature: as long as none of the original files have been changed, verification succeeds.)</p><p>Finally, <code class="literal">jarsigner</code> reads each manifest entry and checks that the file digest matches the actual file contents. If a keystore has been specified with the <code class="literal">-keystore</code> option (as in our example), <code class="literal">jarsigner</code> also checks to see whether the signing certificate is present in the specified keystore. As of Java 7, there is a new <code class="literal">-strict</code> option that enables additional certificate validations, including a time validity check and certificate chain verification. Validation errors are treated as warnings and are reflected in the exit code of the <code class="literal">jarsigner</code> command.</p></div><div class="sect3" title="Viewing or Extracting Signer Information"><div class="titlepage"><div><div><h3 class="title"><a id="viewing_or_extracting_signer_information"/>Viewing or Extracting Signer Information</h3></div></div></div><p>As you can see in <a class="xref" href="ch03.html#signing_an_apk_file_and_verifying_the_si" title="Example 3-7. Signing an APK file and verifying the signature using the jarsigner command">Example 3-7</a>, by default, <code class="literal">jarsigner</code> prints certificate details for each entry (➌ and ➍) even though they are the same for all entries. A slightly better way to view signer info when using Java 7 is to specify the <code class="literal">-verbose:summary</code> or <code class="literal">-verbose:grouped</code> options, or alternatively use the <code class="literal">keytool</code> command, as shown in <a class="xref" href="ch03.html#viewing_apk_signer_information_using_the" title="Example 3-8. Viewing APK signer information using the keytool command">Example 3-8</a>.</p><div class="example"><a id="viewing_apk_signer_information_using_the"/><p class="title">Example 3-8. Viewing APK signer information using the <code class="literal">keytool</code> command</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>keytool -list -printcert -jarfile test.apk</strong></span>
Signer #1:
Signature:
Owner: CN=Android Debug, O=Android, C=US
Issuer: CN=Android Debug, O=Android, C=US
Serial number: 4dfc7e9a
Valid from: Sat Jun 18 19:31:54 JST 2011 until: Mon Jun 10 19:31:54 JST 2041
Certificate fingerprints:
         MD5: E8:93:6E:43:99:61:C8:37:E1:30:36:14:CF:71:C2:32
         SHA1: 08:53:74:41:50:26:07:E7:8F:A5:5F:56:4B:11:62:52:06:54:83:BE
         Signature algorithm name: SHA1withRSA
         Version: 3</pre></div></div><p>Once you have found the signature block filename (by listing the archive contents for example), you can use OpenSSL with the <code class="literal">unzip</code> command to easily extract the signing certificate to a file, as shown in <a class="xref" href="ch03.html#extracting_the_apk_signing_certificate_u" title="Example 3-9. Extracting the APK signing certificate using the unzip and OpenSSL pkcs7 commands">Example 3-9</a>. (If the <a id="iddle2392" class="indexterm"/><code class="literal">SignedData</code> structure includes more than one certificate, all certificates will be extracted. In that case, you will need to parse the <code class="literal">SignedInfo</code> structure to find the identifier of the actual signing certificate.)</p><div class="example"><a id="extracting_the_apk_signing_certificate_u"/><p class="title">Example 3-9. Extracting the APK signing certificate using the <code class="literal">unzip</code> and OpenSSL <code class="literal">pkcs7</code> commands</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>unzip -q -c test.apk META-INF/CERT.RSA|openssl pkcs7 -inform DER -print_certs -out cert.pem</strong></span></pre></div></div></div></div><div class="sect2" title="Android Code Signing"><div class="titlepage"><div><div><h2 class="title"><a id="android_code_signing"/>Android Code Signing</h2></div></div></div><p>Because Android code signing is based on Java JAR signing, it uses public key cryptography and X.509 certificates like many code signing schemes, but that’s where the similarities end.</p><p>In practically all other platforms that use code signing (such as Java ME and Windows Phone), code signing certificates must be issued by a CA that the platform trusts. While there are many CAs that issue code signing certificates, it can prove quite difficult to obtain a certificate that is trusted by all targeted devices. Android solves this problem quite simply: it doesn’t care about the contents or signer of the signing certificate. Thus you do not need to have it issued by a CA, and virtually all code signing certificates used in Android are self-signed. Additionally, you don’t need to assert your identity in any way: you can use pretty much anything as the subject name. (The Google Play Store does have a few checks to weed out some common names, but not the Android OS itself.) Android treats signing certificates as binary blobs, and the fact that they are in X.509 format is merely a consequence of using the JAR format.</p><p>Android doesn’t validate certificates in the PKI sense (see <a class="xref" href="ch06.html" title="Chapter 6. Network Security and PKI">Chapter 6</a>). In fact, if a certificate is not self-signed, the signing CA’s certificate does not have to be present or trusted; Android will even happily install apps with an expired signing certificate. If you are coming from a traditional PKI background, this may sound like heresy, but keep in mind that Android does not use PKI for code signing, it only uses the same certificate and signature formats.</p><p>Another difference between Android and “standard” JAR signing is that all APK entries must be signed by the same set of certificates. The JAR file format allows each file to be signed by a different signer and permits unsigned entries. This makes sense in the Java sandboxing and access control mechanism, which was originally designed for applets, because that model defines a <span class="emphasis"><em>code source</em></span> as a combination of a signer certificate and code origin URL. However, Android assigns signers per-APK (usually only one, but multiple signers are supported) and does not allow different signers for different APK file entries.</p><p>Android’s code signing model, coupled with the poor interface of the <code class="literal">java.util.jar.JarFile</code> class, which is not a good abstraction for the complexities of the underlying CMS signature format, makes it rather difficult to properly verify the signature of APK files. While Android manages to both verify APK integrity and ensure that all APK file entries have been signed by <a id="iddle1695" class="indexterm"/><a id="iddle1705" class="indexterm"/><a id="iddle2352" class="indexterm"/><a id="iddle2822" class="indexterm"/><a id="iddle3129" class="indexterm"/>the same set of certificates by adding additional signing certificate checks to its package parsing routines, it is evident that the JAR file format was not the best choice for Android code signing.</p><div class="sect3" title="Android Code Signing Tools"><div class="titlepage"><div><div><h3 class="title"><a id="android_code_signing_tools"/>Android Code Signing Tools</h3></div></div></div><p>As the examples in the “<a class="xref" href="ch03.html#java_code_signing" title="Java Code Signing">Java Code Signing</a>” section showed, you can use the regular JDK code signing tools to sign or verify APKs. In addition to these tools, the AOSP <span class="emphasis"><em>build/</em></span> directory contains an Android-specific tool called <code class="literal">signapk</code>. This tool performs pretty much the same task as <code class="literal">jarsigner</code> in signing mode, with a few notable differences. For one, while <code class="literal">jarsigner</code> requires that keys be stored in a compatible keystore file, <code class="literal">signapk</code> takes a separate signing key (in DER-encoded <span class="emphasis"><em>PKCS#8</em></span> format<sup>[<a id="ch03fn06" href="#ftn.ch03fn06" class="footnote">22</a>]</sup>) and certificate file (in DER-encoded X.509 format) as input. The advantage of the PKCS#8 format, which is the standard key encoding format in Java, is that it includes an explicit algorithm identifier that describes the type of the encoded private key. The encoded private key might include key material, possibly encrypted, or it might contain only a reference, such as a key ID, to a key stored in a hardware device.</p><p>As of Android 4.4, the <code class="literal">signapk</code> can only produce signatures with the <span class="emphasis"><em>SHA1withRSA</em></span> or <span class="emphasis"><em>SHA256withRSA</em></span> (added to the platform in Android 4.3) mechanisms. As of this writing, the version of <code class="literal">signapk</code> found in AOSP’s master branch has been extended to support ECDSA signatures.</p><p>While raw private keys in PKCS#8 format are somewhat hard to come by, you can easily generate a test key pair and a self-signed certificate using the <code class="literal">make_key</code> script found in <span class="emphasis"><em>development/tools/</em></span>. If you have existing OpenSSL keys, you’ll have to convert them to PKCS#8 format first, using something like OpenSSL’s <code class="literal">pkcs8</code> command as shown in <a class="xref" href="ch03.html#converting_an_openssl_key_to_pkcshash8_f" title="Example 3-10. Converting an OpenSSL key to PKCS#8 format">Example 3-10</a>:</p><div class="example"><a id="converting_an_openssl_key_to_pkcshash8_f"/><p class="title">Example 3-10. Converting an OpenSSL key to PKCS#8 format</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>echo "keypwd"|openssl pkcs8 -in mykey.pem -topk8 -outform DER -out mykey.pk8 -passout stdin</strong></span></pre></div></div><p>Once you have the needed keys, you can sign an APK using <code class="literal">signapk</code> as shown in <a class="xref" href="ch03.html#signing_an_apk_using_the_signapk_tool" title="Example 3-11. Signing an APK using the signapk tool">Example 3-11</a>.</p><div class="example"><a id="signing_an_apk_using_the_signapk_tool"/><p class="title">Example 3-11. Signing an APK using the <code class="literal">signapk</code> tool</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>java -jar signapk.jar cert.cer key.pk8 test.apk test-signed.apk</strong></span></pre></div></div></div><div class="sect3" title="OTA File Code Signing"><div class="titlepage"><div><div><h3 class="title"><a id="ota_file_code_signing"/>OTA File Code Signing</h3></div></div></div><p>Besides its default APK signing mode, the <code class="literal">signapk</code> tool also has a “sign whole file” mode that can be enabled with the <code class="literal">-w</code> option. When in this mode, in addition to signing each individual JAR entry, the tool generates a signature over the whole archive as well. This mode is not supported by <code class="literal">jarsigner</code> and is specific to Android.</p><p><a id="iddle1088" class="indexterm"/><a id="iddle2499" class="indexterm"/>Why sign the whole archive when each file is already signed? In order to support over-the-air (OTA) updates. OTA packages are ZIP files in a format similar to JAR files that contain updated files and the scripts to apply them. The packages include a <span class="emphasis"><em>META-INF/</em></span> directory, manifests, a signature block, and a few extra files, including <span class="emphasis"><em>META-INF/com/android/otacert</em></span>, which contains the update signing certificate (in PEM format). Before booting into recovery to apply updates, Android verifies the package signature and then checks to see if the signing certificate is trusted to sign updates. OTA-trusted certificates are separate from the “regular” system trust store (see <a class="xref" href="ch06.html" title="Chapter 6. Network Security and PKI">Chapter 6</a>), and reside in a ZIP file that is usually stored as <span class="emphasis"><em>/system/ etc/security/otacerts.zip</em></span>. On a production device, this file typically contains a single file usually named <span class="emphasis"><em>releasekey.x509.pem</em></span>. After the device reboots, the recovery OS verifies the OTA package signature once again before applying it in order to make sure that the OTA file has not been tampered with in the meantime.</p><p>If OTA files are like JAR files, and JAR files don’t support whole-file signatures, where does the signature go? The Android <code class="literal">signapk</code> tool slightly abuses the ZIP format by adding a null-terminated string comment in the ZIP comment section, followed by the binary signature block and a 6-byte final record containing the signature offset and the size of the entire comment section. Adding the offset record to the end of the file makes it easy to verify the package by first reading and verifying the signature block from the end of the file, and only reading the rest of the file (which could be in the hundreds of megabytes) if the signature checks out.</p></div></div></div><div class="sect1" title="APK Install Process"><div class="titlepage"><div><div><h1 class="title"><a id="apk_install_process"/>APK Install Process</h1></div></div></div><p>There are a few ways to install Android applications:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Via an application store client (such as the Google Play Store). This is how most users install applications.</p></li><li class="listitem"><p>Directly on the device by opening downloaded app files (if the “Unknown sources” option in system settings is enabled). This method is commonly referred to as <span class="emphasis"><em>sideloading</em></span> an app.</p></li><li class="listitem"><p>From a USB-connected computer with the <code class="literal">adb install</code> Android SDK command which, in turn invokes the <code class="literal">pm</code> command line utility with the <code class="literal">install</code> parameter. This method is used mostly by application developers.</p></li><li class="listitem"><p>By directly copying an APK file to one of the system application directories using the Android shell. Because application directories are not accessible on production builds, this method can only be used on devices running an engineering (development) build.</p></li></ul></div><p>When an APK file is copied directly to one of the application directories it is automatically detected and installed by the package manager, which watches these directories for changes. In the case of all other install methods, the installer application (whether Google Play Store client, default system package install activity, <code class="literal">pm</code> command, or other) invokes one of the <a id="iddle2390" class="indexterm"/><code class="literal">installPackage()</code> methods of the system package manager, which then copies the APK to one of the application directories and installs it. In the following sections, we’ll explore the main steps of the Android package install process, and discuss some of the more complex installation steps like encrypted container creation and package verification.</p><p>Android’s package management functionality is distributed across several system components that interact with each other during package installation, as shown in <a class="xref" href="ch03.html#package_management_components" title="Figure 3-1. Package management components">Figure 3-1</a>. Solid arrows in the figure represent dependencies between components, as well as function calls. Dashed arrows point to files or directories that are monitored for changes by a component, but which are not directly modified by that component.</p><div class="figure"><a id="package_management_components"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00006"/><img src="figs/web/03fig01.png.jpg" alt="Package management components"/></div></div><p class="title">Figure 3-1. Package management components</p></div><div class="sect2" title="Location of Application Packages and Data"><div class="titlepage"><div><div><h2 class="title"><a id="location_of_application_packages_and_dat"/>Location of Application Packages and Data</h2></div></div></div><p>Recall from <a class="xref" href="ch01.html" title="Chapter 1. Android’s Security Model">Chapter 1</a> that Android distinguishes between system- and user-installed applications. System applications are found on the read-only <span class="emphasis"><em>system</em></span> partition (bottom left in <a class="xref" href="ch03.html#package_management_components" title="Figure 3-1. Package management components">Figure 3-1</a>) and cannot be changed or uninstalled on production devices. System applications are therefore considered trusted and are given more privileges, and have some signature checks relaxed. Most system applications are found in the <span class="emphasis"><em>/system/app/</em></span> directory, while <span class="emphasis"><em>/system/ priv-app/</em></span> holds privileged apps that can be granted permission with the <a id="iddle1191" class="indexterm"/><a id="iddle1516" class="indexterm"/><a id="iddle1607" class="indexterm"/><a id="iddle1958" class="indexterm"/><a id="iddle2359" class="indexterm"/><a id="iddle2384" class="indexterm"/><a id="iddle2412" class="indexterm"/><a id="iddle2529" class="indexterm"/><a id="iddle2830" class="indexterm"/><a id="iddle2975" class="indexterm"/><span class="emphasis"><em>signatureOrSystem</em></span> protection level (as discussed in <a class="xref" href="ch02.html" title="Chapter 2. Permissions">Chapter 2</a>). The <span class="emphasis"><em>/system/ vendor/app/</em></span> directory hosts vendor-specific applications. User-installed applications live on the read-write <span class="emphasis"><em>userdata</em></span> partition (shown at the bottom right in <a class="xref" href="ch03.html#package_management_components" title="Figure 3-1. Package management components">Figure 3-1</a>) and can be uninstalled or replaced at any time. Most user-installed applications are installed in the <span class="emphasis"><em>/data/app/</em></span> directory.</p><p>Data directories for both system and user-installed applications are created on the <span class="emphasis"><em>userdata</em></span> partition under the <span class="emphasis"><em>/data/data/</em></span> directory. The <span class="emphasis"><em>userdata</em></span> partition also hosts the optimized DEX files for user-installed applications (in /<span class="emphasis"><em>data/dalvik-cache/</em></span>), the system package database (in <span class="emphasis"><em>/data/system/packages.xml</em></span>), and other system databases and settings files. (We’ll discuss the rest of the <span class="emphasis"><em>userdata</em></span> partition directories shown in <a class="xref" href="ch03.html#package_management_components" title="Figure 3-1. Package management components">Figure 3-1</a> when we cover the APK install process.)</p></div><div class="sect2" title="Active Components"><div class="titlepage"><div><div><h2 class="title"><a id="active_components"/>Active Components</h2></div></div></div><p>Having established the roles of the <span class="emphasis"><em>userdata</em></span> and <span class="emphasis"><em>system</em></span> partitions, let’s introduce the active components that play a role during package installation.</p><div class="sect3" title="PackageInstaller System Application"><div class="titlepage"><div><div><h3 class="title"><a id="packageinstaller_system_application"/>PackageInstaller System Application</h3></div></div></div><p>This is the default APK file handler. It provides a basic GUI for package management and when passed an APK file URI with the <code class="literal">VIEW</code> or <code class="literal">INSTALL_ACTION</code> intent action, it parses the package and displays an install confirmation screen showing the permissions the application requires (see <a class="xref" href="ch02.html#default_android_application_install_conf" title="Figure 2-1. Default Android application install confirmation dialog">Figure 2-1</a>). Installation using the <code class="literal">PackageInstaller</code> application is only possible if the user has enabled the Unknown Sources option in the device’s security settings (see <a class="xref" href="ch03.html#application_install_security_settings" title="Figure 3-2. Application install security settings">Figure 3-2</a>). If Unknown Sources is not enabled, <code class="literal">PackageInstaller</code> will show a dialog informing the user that installation of apps obtained from unknown sources is blocked.</p><div class="figure"><a id="application_install_security_settings"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00007"/><img src="figs/web/03fig02.png.jpg" alt="Application install security settings"/></div></div><p class="title">Figure 3-2. Application install security settings</p></div><p>What is considered an “unknown source”? While the on-screen hint defines it as “apps from sources other than the Play Store,” the actual definition is a bit more broad. When started, <code class="literal">PackageInstaller</code> retrieves the UID and package of the app that requested APK installation and checks to see if it is a privileged app (installed in <a id="iddle1074" class="indexterm"/><a id="iddle1972" class="indexterm"/><a id="iddle2882" class="indexterm"/><span class="emphasis"><em>/system/priv-app/</em></span>). If the requesting app is unprivileged, it is considered an unknown source. If the Unknown Sources option is selected and the user okays the install dialog, <code class="literal">PackageInstaller</code> calls the <code class="literal">PackageManagerService</code>, which performs the actual installation. The <code class="literal">PackageInstaller</code> GUI is also shown when upgrading side-loaded packages or uninstalling apps from the Apps screen of System Settings.</p></div><div class="sect3" title="pm command"><div class="titlepage"><div><div><h3 class="title"><a id="pm_command"/>pm command</h3></div></div></div><p>The <code class="literal">pm</code> command (introduced in <a class="xref" href="ch02.html" title="Chapter 2. Permissions">Chapter 2</a>) provides a command-line interface to some of the functions of the system package manager. It can be used to install or uninstall packages when invoked as <code class="literal">pm install</code> or <code class="literal">pm uninstall</code> from the Android shell, respectively. Additionally, the <span class="emphasis"><em>Android Debug Bridge (ADB)</em></span> client provides the <code class="literal">adb install/uninstall</code> shortcuts.</p><p>Unlike the <code class="literal">PackageInstaller</code>, <code class="literal">pm install</code> does not depend on the Unknown Sources system option and does not display a GUI, and it provides various useful options for testing package installation that cannot be specified via the <code class="literal">PackageInstaller</code> GUI. To start the install process, it calls the same <code class="literal">PackageManager</code> API as the GUI installer.</p></div><div class="sect3" title="PackageManagerService"><div class="titlepage"><div><div><h3 class="title"><a id="packagemanagerservice"/>PackageManagerService</h3></div></div></div><p>The <code class="literal">PackageManagerService</code> (<code class="literal">PackageManager</code> in <a class="xref" href="ch03.html#package_management_components" title="Figure 3-1. Package management components">Figure 3-1</a>) is the central object in Android’s package management infrastructure. It is responsible for parsing APK files, starting the application install, upgrading and uninstalling packages, maintaining the package database, and managing permissions.</p><p>The <code class="literal">PackageManagerService</code> also provides a number of <code class="literal">installPackage()</code> methods that can perform package installation with various options. The most general of these is the <code class="literal">installPackageWithVerificationAndEncryption()</code>, which allows for the installation of an encrypted APK file, and package verification by a verification agent. (We’ll discuss app encryption and verification later in “<a class="xref" href="ch03.html#installing_encrypted_apks" title="Installing Encrypted APKs">Installing Encrypted APKs</a>” and “<a class="xref" href="ch03.html#package_verification" title="Package Verification">Package Verification</a>”.)</p><div class="note" title="Note"><h3 class="title"><a id="ch03note02"/>Note</h3><p><span class="emphasis"><em>The <code class="literal">android.content.pm.PackageManager</code> Android SDK facade class exposes a subset of the functionality of the <code class="literal">PackageManagerService</code> to third-party applications.</em></span></p></div></div><div class="sect3" title="Installer class"><div class="titlepage"><div><div><h3 class="title"><a id="installer_class"/>Installer class</h3></div></div></div><p>While the <code class="literal">PackageManagerService</code> is one of the most privileged Android system services, it still runs inside the system server process (with the <span class="emphasis"><em>system</em></span> UID) and lacks root privileges. However, because creating, deleting, and changing the ownership of application directories requires superuser capabilities, the <code class="literal">PackageManagerService</code> delegates those operations to the <span class="emphasis"><em>installd</em></span> daemon (discussed next). The <code class="literal">Installer</code> class connects to the <span class="emphasis"><em>installd</em></span> daemon through the <span class="emphasis"><em>/dev/socket/installd</em></span> Unix domain socket and encapsulates the <span class="emphasis"><em>installd</em></span> command-oriented protocol.</p></div><div class="sect3" title="installd Daemon"><div class="titlepage"><div><div><h3 class="title"><a id="installd_daemon"/>installd Daemon</h3></div></div></div><p><a id="iddle1314" class="indexterm"/><a id="iddle1315" class="indexterm"/><a id="iddle1608" class="indexterm"/><a id="iddle2329" class="indexterm"/><a id="iddle2346" class="indexterm"/><a id="iddle2632" class="indexterm"/>The <span class="emphasis"><em>installd</em></span> daemon is a native daemon with elevated privileges that provides application and user directory management functionality (for multi-user devices) to the system package manager. It is also used to start the <code class="literal">dexopt</code> command, which generates optimized DEX files for newly installed packages.</p><p>The <span class="emphasis"><em>installd</em></span> daemon is accessed via the <span class="emphasis"><em>installd</em></span> local socket, which is only accessible to processes running as the <span class="emphasis"><em>system</em></span> UID. The <span class="emphasis"><em>installd</em></span> daemon does not execute as root (although it used to do so in earlier Android versions), but instead takes advantage of the <code class="literal">CAP_DAC_OVERRIDE</code> and <code class="literal">CAP_CHOWN</code> Linux capabilities<sup>[<a id="ch03fn07" href="#ftn.ch03fn07" class="footnote">23</a>]</sup> in order to be able to set the owner and group UID of the application directories and files it creates to those of the owning application.</p></div><div class="sect3" title="MountService"><div class="titlepage"><div><div><h3 class="title"><a id="mountservice"/>MountService</h3></div></div></div><p>The <code class="literal">MountService</code> is responsible for mounting detachable external storage such as SD cards, as well as <span class="emphasis"><em>opaque binary blob (OBB) files</em></span>, which are used as expansion files for applications. It is also used to kick off device encryption (see <a class="xref" href="ch10.html" title="Chapter 10. Device Security">Chapter 10</a>) and to change the encryption password.</p><p><code class="literal">MountService</code> also manages <span class="emphasis"><em>secure containers</em></span>, which hold applications files that should not be accessible to non-system applications. Secure containers are encrypted and used to implement a form of DRM called <span class="emphasis"><em>forward locking</em></span> (discussed in “<a class="xref" href="ch03.html#forward_locking" title="Forward Locking">Forward Locking</a>” and “<a class="xref" href="ch03.html#android_4dot1_forward_locking_implementa" title="Android 4.1 Forward Locking Implementation">Android 4.1 Forward Locking Implementation</a>”). Forward locking is used primarily when installing paid applications in order to ensure that their APK files cannot be easily copied off the device and redistributed.</p></div><div class="sect3" title="vold daemon"><div class="titlepage"><div><div><h3 class="title"><a id="vold_daemon"/>vold daemon</h3></div></div></div><p><span class="emphasis"><em>vold</em></span> is Android’s volume management daemon. While the <code class="literal">MountService</code> contains most system APIs that deal with volume management, because it runs as the <span class="emphasis"><em>system</em></span> user it lacks the privileges required to actually mount and unmount disk volumes. Those privileged operations are implemented in the <span class="emphasis"><em>vold</em></span> daemon, which runs as root.</p><p><span class="emphasis"><em>vold</em></span> has a local socket interface which is exposed via the <span class="emphasis"><em>/dev/socket/ vold</em></span> Unix domain socket that is only accessible to root and members of the <span class="emphasis"><em>mount</em></span> group. Because the list of supplementary GIDs of the <span class="emphasis"><em>system_server</em></span> process (which hosts <code class="literal">MountService</code>) includes <span class="emphasis"><em>mount</em></span> (GID 1009), <code class="literal">MountService</code> is allowed to access <span class="emphasis"><em>vold</em></span>’s command socket. Besides mounting and unmounting volumes, <span class="emphasis"><em>vold</em></span> can also create and format filesystems and manage secure containers.</p></div><div class="sect3" title="MediaContainerService"><div class="titlepage"><div><div><h3 class="title"><a id="mediacontainerservice"/>MediaContainerService</h3></div></div></div><p>The <code class="literal">MediaContainerService</code> copies APK files to their final install location or to an encrypted container, and allows the <code class="literal">PackageManagerService</code> to access files on removable storage. APK files obtained from a remote location (either <a id="iddle1667" class="indexterm"/><a id="iddle1970" class="indexterm"/><a id="iddle2381" class="indexterm"/><a id="iddle2389" class="indexterm"/><a id="iddle2976" class="indexterm"/>directly or through an application market) are downloaded using Android’s <code class="literal">DownloadManager</code> service and the downloaded files are accessed through <code class="literal">DownloadManager</code>’s content provider interface. The <code class="literal">PackageManager</code> grants temporary access to each downloaded APK to the <code class="literal">MediaContainerService</code> process. If the APK file is encrypted, <code class="literal">MediaContainerService</code> decrypts the file first (as discussed in “<a class="xref" href="ch03.html#installing_an_encrypted_apk_with_integri" title="Installing an Encrypted APK with Integrity Check">Installing an Encrypted APK with Integrity Check</a>”). If an encrypted container was requested, <code class="literal">MediaContainerService</code> delegates encrypted container creation to the <code class="literal">MountService</code> and copies the protected part of the APK (both code and assets) into the newly created container. Files that do not need to be protected by a container are copied directly to the filesystem.</p></div><div class="sect3" title="AppDirObserver"><div class="titlepage"><div><div><h3 class="title"><a id="appdirobserver"/>AppDirObserver</h3></div></div></div><p>An <code class="literal">AppDirObserver</code> is a component that monitors an application directory for APK file changes<sup>[<a id="ch03fn08" href="#ftn.ch03fn08" class="footnote">24</a>]</sup> and calls the appropriate <code class="literal">PackageManagerService</code> method based on the event type. When an APK file is added to the system, <code class="literal">AppDirObserver</code> kicks off a package scan which either installs or updates the application. When an APK file is removed, <code class="literal">AppDirObserver</code> starts the uninstall process, which removes app directories and the app entry in the system package database.</p><p><a class="xref" href="ch03.html#package_management_components" title="Figure 3-1. Package management components">Figure 3-1</a> shows a single <code class="literal">AppDirObserver</code> instance due to space constraints, but there is a dedicated instance for each watched directory. The directories monitored on the <span class="emphasis"><em>system</em></span> partition are <span class="emphasis"><em>/system/framework/</em></span> (which holds the framework resource package <span class="emphasis"><em>framework-res.apk</em></span>); <span class="emphasis"><em>/system/ app/</em></span> and <span class="emphasis"><em>/system/priv-app/</em></span> (system packages); and the vendor package directory <span class="emphasis"><em>/system/vendor/app/</em></span>. The directories monitored on the <span class="emphasis"><em>userdata</em></span> partition are <span class="emphasis"><em>/data/app/</em></span> and <span class="emphasis"><em>/data/app-private/</em></span> which hosts “old style” (pre-Android 4.1) forward locked APKs and temporary files produced during APK decryption.</p></div></div><div class="sect2" title="Installing a Local Package"><div class="titlepage"><div><div><h2 class="title"><a id="installing_a_local_package"/>Installing a Local Package</h2></div></div></div><p>Now that we know what Android components are involved in package installation, we’ll cover the install process, beginning with the simplest case: installing an unencrypted local package without verification and forward locking.</p><div class="sect3" title="Parsing and Verifying the Package"><div class="titlepage"><div><div><h3 class="title"><a id="parsing_and_verifying_the_package"/>Parsing and Verifying the Package</h3></div></div></div><p>Opening a local APK file starts the <span class="emphasis"><em>application/vnd.android.package-archive</em></span> handler, typically the <code class="literal">PackageInstallerActivity</code> from the <code class="literal">PackageInstaller</code> system application. <code class="literal">PackageInstallerActivity</code> first checks to see if the application that requested the install is trusted (that is, not considered from an “unknown source”). If it is not, and the <code class="literal">Settings.Global.INSTALL_NON_MARKET_APPS</code> is <code class="literal">false</code> (it <a id="iddle1145" class="indexterm"/><a id="iddle1146" class="indexterm"/><a id="iddle1959" class="indexterm"/><a id="iddle1971" class="indexterm"/><a id="iddle2382" class="indexterm"/><a id="iddle2876" class="indexterm"/>is set to <code class="literal">true</code> when the Unknown sources checkbox in <a class="xref" href="ch03.html#application_install_security_settings" title="Figure 3-2. Application install security settings">Figure 3-2</a> is checked), <code class="literal">PackageInstaller</code> shows a warning dialog and ends the install process.</p><p>If the installation is allowed, the <code class="literal">PackageInstallerActivity</code> parses the APK file and collects information from the <span class="emphasis"><em>AndroidManifest.xml</em></span> file and package signature. The integrity of the APK file is verified automatically while extracting the signing certificates for each of its entries using the <code class="literal">java.util.jar.JarFile</code> and related classes. This implementation is necessary because the API of the <code class="literal">JarFile</code> class lacks any explicit methods to verify the signature of the whole file or of a particular entry. (System applications are implicitly trusted and only the integrity of the <span class="emphasis"><em>AndroidManifest.xml</em></span> file is verified when parsing their APK files. However, all APK entries are verified for packages that are not part of the system image, such as user-installed applications or updates for system applications.) The hash value of the <span class="emphasis"><em>AndroidManifest.xml</em></span> file is also calculated as part of APK parsing and passed to subsequent install steps, which use it to verify that the APK file was not replaced between the time when the user pressed OK in the install dialog and the APK copy process was started.</p><div class="note" title="Note"><h3 class="title"><a id="ch03note03"/>Note</h3><p><span class="emphasis"><em>Another noteworthy detail is that while at install time, APK file integrity is verified using standard Java library classes, at runtime, the Dalvik virtual machine loads APK files using its own native implementation of a ZIP/JAR file parser. Subtle differences in their implementations have been the source of several Android bugs, most notably bug #8219321 (commonly known as the</em></span> Android Master Key<span class="emphasis"><em>) which allows a signed APK file to be modified and still considered valid without resigning. A <code class="literal">StrictJarFile</code> class, which uses the same ZIP file parsing implementation as Dalvik, has been added in AOSP’s master branch in order to address this. <code class="literal">StrictJarFile</code> is used by the system package manager when parsing APK files, ensuring that both Dalvik and the package manager parse APK files in the same way. This new unified implementation should be incorporated in future Android versions.</em></span></p></div></div><div class="sect3" title="Accepting Permissions and Starting the Install Process"><div class="titlepage"><div><div><h3 class="title"><a id="accepting_permissions_and_starting_the_i"/>Accepting Permissions and Starting the Install Process</h3></div></div></div><p>Once the APK has been parsed, <code class="literal">PackageInstallerActivity</code> displays information about the application and the permissions it requires in a dialog similar to the one shown in <a class="xref" href="ch02.html#default_android_application_install_conf" title="Figure 2-1. Default Android application install confirmation dialog">Figure 2-1</a>. If the user OK’s the install, <code class="literal">PackageInstallerActivity</code> forwards the APK file and its manifest digest, along with install metadata such as the referrer URL, the installer package name, and originating UID to the <code class="literal">InstallAppProgress</code> activity, which starts the actual package install process. <code class="literal">InstallAppProgress</code> then passes the APK URI and install metadata to the <code class="literal">installPackageWithVerificationAndEncryption()</code> method of the <code class="literal">PackageManagerService</code>, starting the install process. It then waits for the process to complete and handles any errors.</p><p>The install method first verifies that the caller has the <code class="literal">INSTALL_PACKAGES</code> permission, which has a protection-level <span class="emphasis"><em>signature</em></span> and is reserved for system applications. On multi-user devices, the method also verifies whether the calling user is allowed to install applications. Next, it determines the preferred install location, which is either internal or external storage.</p></div><div class="sect3" title="Copying to the Application Directory"><div class="titlepage"><div><div><h3 class="title"><a id="copying_to_the_application_directory"/>Copying to the Application Directory</h3></div></div></div><p><a id="iddle2197" class="indexterm"/><a id="iddle2397" class="indexterm"/><a id="iddle2653" class="indexterm"/><a id="iddle2724" class="indexterm"/>If the APK file is not encrypted and no verification is required, the next step is to copy it to the application directory (<span class="emphasis"><em>/data/app/</em></span>). To copy the file, the <code class="literal">PackageManagerService</code> first creates a temporary file in the application directory (with the <span class="emphasis"><em>vmdl</em></span> prefix and <span class="emphasis"><em>.tmp</em></span> extension) and then delegates copying to the <code class="literal">MediaContainerService</code>. The file is not copied directly because it might need to be decrypted, or an encrypted container created for it if it will be forward locked. Because the <code class="literal">MediaContainerServices</code> encapsulates these tasks, the <code class="literal">PackageManagerService</code> does not need to be concerned with the underlying implementation.</p><p>When the APK file is successfully copied, any native libraries it contains are extracted to a dedicated app directory under the system’s native library directory (<span class="emphasis"><em>/data/app-lib/</em></span>). Next, the temporary APK file and the library directory are renamed to their final names, which are based on the package name, such as <span class="emphasis"><em>com.example.app-1.apk</em></span> for the APK and <span class="emphasis"><em>/data/app-lib/com.example.app-1</em></span> for the library directory. Finally, the APK file permissions are set to <span class="emphasis"><em>0644</em></span> and its SELinux context is set (see <a class="xref" href="ch12.html" title="Chapter 12. Selinux">Chapter 12</a>).</p><div class="note" title="Note"><h3 class="title"><a id="ch03note04"/>Note</h3><p><span class="emphasis"><em>By default, APK files are world-readable and any other application can access them. This facilitates sharing public app resources and allows the development of third-party launchers and other applications that need to show a list of all installed packages. However, those default permissions also allow anyone to extract APK files from a device, which is problematic for paid applications distributed via an application market. APK file forward locking provides a way for APK resources to remain public, while limiting access to code and assets.</em></span></p></div></div><div class="sect3" title="The Package Scan"><div class="titlepage"><div><div><h3 class="title"><a id="package_scan"/>The Package Scan</h3></div></div></div><p>The next step in the install process is to trigger a package scan by calling the <code class="literal">scanPackageLI()</code> method of <code class="literal">PackageManagerService</code>. (If the install process stops before scanning the new APK file, it will eventually be picked up by the <code class="literal">AppDirObserver</code> instance which monitors the <span class="emphasis"><em>/data/app/</em></span> directory and also triggers a package scan.)</p><p>In the case of a new install, the package manager first creates a new <code class="literal">PackageSettings</code> structure that contains the package name, code path, a separate resource path if the package is forward-locked, and a native library path. It then assigns a UID to the new package and stores it in the settings structure. Once the new app has a UID, its data directory can be created.</p></div><div class="sect3" title="Creating Data Directories"><div class="titlepage"><div><div><h3 class="title"><a id="creating_data_directories"/>Creating Data Directories</h3></div></div></div><p>Because the <code class="literal">PackageManagerService</code> does not have enough privileges to create and set ownership of app directories, it delegates directory creation to the <span class="emphasis"><em>installd</em></span> daemon by sending it the <code class="literal">install</code> command which takes the package name, UID, GID, and <span class="emphasis"><em>seinfo</em></span> tag (used by SELinux) as parameters. The <span class="emphasis"><em>installd</em></span> daemon creates the package data directory (for example, <a id="iddle1151" class="indexterm"/><a id="iddle1226" class="indexterm"/><a id="iddle1605" class="indexterm"/><a id="iddle2214" class="indexterm"/><a id="iddle2816" class="indexterm"/><span class="emphasis"><em>/data/data/com.example.app/</em></span> when installing the <span class="emphasis"><em>com.example.app</em></span> package), shared native library directory (<span class="emphasis"><em>/data/app-lib/com.example.app/</em></span>), and local library directory (<span class="emphasis"><em>/data/data/com.example.app/lib/</em></span>). It then sets the package directory permissions to <span class="emphasis"><em>0751</em></span> and creates symbolic links for the app’s native libraries (if any) in the local library directory. Finally, it sets the SELinux context of the package directory and changes its owner to the UID and GID assigned to the app.</p><p>If the system has more than one user, the next step is to create data directories for each user by sending the <code class="literal">mkuserdata</code> command to <span class="emphasis"><em>installd</em></span> (see <a class="xref" href="ch04.html" title="Chapter 4. User Management">Chapter 4</a>). When all the necessary directories are created, control returns to the <code class="literal">PackageManagerService</code>, which extracts any native libraries to the application’s native library directory and creates symbolic links in <span class="emphasis"><em>/data/data/com.example.app/lib/</em></span>.</p></div><div class="sect3" title="Generating Optimized DEX"><div class="titlepage"><div><div><h3 class="title"><a id="generating_optimized_dex"/>Generating Optimized DEX</h3></div></div></div><p>The next step is to generate optimized DEX for the application’s code. This operation is also delegated to <span class="emphasis"><em>installd</em></span> by sending it the <code class="literal">dexopt</code> command. The <span class="emphasis"><em>installd</em></span> daemon forks a <span class="emphasis"><em>dexopt</em></span> process, which creates the optimized DEX file in the <span class="emphasis"><em>/data/dalivk-cache/</em></span> directory. (The optimization process is also referred to as “sharpening.”)</p><div class="note" title="Note"><h3 class="title"><a id="ch03note05"/>Note</h3><p><span class="emphasis"><em>If the device is using the experimental Android Runtime (ART) introduced in version 4.4 instead of generating optimized DEX,</em></span> installd <span class="emphasis"><em>generates native code using the <code class="literal">dex2oat</code> command.</em></span></p></div></div><div class="sect3" title="File and Directory Structure"><div class="titlepage"><div><div><h3 class="title"><a id="file_and_directory_structure"/>File and Directory Structure</h3></div></div></div><p>When all of the above processes have completed, the application’s files and directories might look something like <a class="xref" href="ch03.html#files_and_directories_created_after_inst" title="Example 3-12. Files and directories created after installing an application">Example 3-12</a>. (Timestamps and file sizes have been omitted.)</p><div class="example"><a id="files_and_directories_created_after_inst"/><p class="title">Example 3-12. Files and directories created after installing an application</p><div class="example-contents"><pre class="programlisting">-rw-r--r-- system   system   ... /data/app/com.example.app-1.apk➊
-rwxr-xr-x system   system   ... /data/app-lib/com.example.app-1/libapp.so➋
-rw-r--r-- system   all_a215 ... /data/dalvik-cache/data@app@com.example.app-1.apk@classes.dex➌
drwxr-x--x u0_a215  u0_a215  ... /data/data/com.example.app➍
drwxrwx--x u0_a215  u0_a215  ... /data/data/com.example.app/databases➎
drwxrwx--x u0_a215  u0_a215  ... /data/data/com.example.app/files
lrwxrwxrwx install  install  ... /data/data/com.example.app/lib -&gt; /data/app-lib/com.example.app-1➏
drwxrwx--x u0_a215  u0_a215  ... /data/data/com.example.app/shared_prefs</pre></div></div><p>Here, ➊ is the APK file and ➋ is the extracted native library file. Both files are owned by <span class="emphasis"><em>system</em></span> and are world readable. The file at ➌ is the optimized DEX file for the application’s code. Its owner is set to <span class="emphasis"><em>system</em></span> and its group is set to the special <span class="emphasis"><em>all_a215</em></span> group, which includes all device users that have installed the app. This allows all users to share the same optimized DEX file, thus avoiding the need to create a copy for each user, which could take up too much disk space on a multi-user device. The application’s data directory ➍ and its subdirectories (such as <span class="emphasis"><em>databases/</em></span> ➎) are owned by the dedicated Linux user created by combining the ID of the device user that installed the application (<span class="emphasis"><em>u0</em></span>, the sole user on single-user devices) and the app ID (<span class="emphasis"><em>a215</em></span>) to produce <span class="emphasis"><em>u0_a215</em></span>. (App data directories are not readable or writable by other users in accordance with Android’s sandboxing security model. The <span class="emphasis"><em>lib/</em></span> directory ➏ is merely a symbolic link to the app’s shared library directory in <span class="emphasis"><em>/data/app-lib/</em></span>.)</p></div><div class="sect3" title="Adding the New Package to packages.xml"><div class="titlepage"><div><div><h3 class="title"><a id="adding_the_new_package_to_packagesdotxml"/>Adding the New Package to packages.xml</h3></div></div></div><p>The next step is to add the package to the system package database. A new package entry that looks like <a class="xref" href="ch03.html#package_database_entry_for_a_newly_insta" title="Example 3-13. Package database entry for a newly installed application">Example 3-13</a> is generated and added to <span class="emphasis"><em>packages.xml</em></span>.</p><div class="example"><a id="package_database_entry_for_a_newly_insta"/><p class="title">Example 3-13. Package database entry for a newly installed application</p><div class="example-contents"><pre class="programlisting">&lt;package name="com.google.android.apps.chrometophone"
         codePath="/data/app/com.google.android.apps.chrometophone-2.apk"
         nativeLibraryPath="/data/app-lib/com.google.android.apps.chrometophone-2"
         flags="572996"
         ft="142dfa0e588"
         it="142cbeac305"
         ut="142dfa0e8d7"
         version="16"
         userId="10088"
         installer="com.android.vending"&gt;➊
    &lt;sigs count="1"&gt;
        &lt;cert index="7" key="30820252..." /&gt;
    &lt;/sigs&gt;➋
    &lt;perms&gt;
        &lt;item name="android.permission.USE_CREDENTIALS" /&gt;
        &lt;item name="com.google.android.apps.chrometophone.permission.C2D_MESSAGE" /&gt;
        &lt;item name="android.permission.GET_ACCOUNTS" /&gt;
        &lt;item name="android.permission.INTERNET" /&gt;
        &lt;item name="android.permission.WAKE_LOCK" /&gt;
        &lt;item name="com.google.android.c2dm.permission.RECEIVE" /&gt;
    &lt;/perms&gt;➌
    &lt;signing-keyset identifier="2" /&gt;➍
&lt;/package&gt;</pre></div></div><p>Here, the <code class="literal">&lt;sigs&gt;</code> ➋ element holds the DER-encoded values of the package signing certificates (typically only one) in hexadecimal string format, or a reference to the first occurrence of the certificate in the case of multiple apps signed by the same key and certificate. The <code class="literal">&lt;perms&gt;</code> ➌ elements holds the permissions granted to the application, as described in <a class="xref" href="ch02.html" title="Chapter 2. Permissions">Chapter 2</a>.</p><p>The <code class="literal">&lt;signing-keyset&gt;</code> ➍ element is new in Android 4.4 and holds a reference to the signing key set of the application, which contains all public keys (but <span class="emphasis"><em>not</em></span> certificates) that have signed files inside the APK. The <a id="iddle1402" class="indexterm"/><a id="iddle1820" class="indexterm"/><a id="iddle1837" class="indexterm"/><a id="iddle1962" class="indexterm"/><a id="iddle1998" class="indexterm"/><a id="iddle2263" class="indexterm"/><a id="iddle2264" class="indexterm"/><a id="iddle2604" class="indexterm"/><a id="iddle2815" class="indexterm"/><a id="iddle3002" class="indexterm"/><a id="iddle3053" class="indexterm"/><a id="iddle3069" class="indexterm"/><code class="literal">PackageManagerService</code> collects and stores signing keys for all applications in a global <code class="literal">&lt;keyset-settings&gt;</code> element, but key sets are not checked or otherwise used as of Android 4.4.</p></div><div class="sect3" title="Package Attributes"><div class="titlepage"><div><div><h3 class="title"><a id="package_attributes"/>Package Attributes</h3></div></div></div><p>The root element <code class="literal">&lt;package&gt;</code> ➊ (shown in <a class="xref" href="ch03.html#package_database_entry_for_a_newly_insta" title="Example 3-13. Package database entry for a newly installed application">Example 3-13</a>) holds the core attributes of each package, such as install location and version. The main package attributes are listed in <a class="xref" href="ch03.html#package_attributes-id00005" title="Table 3-1. Package Attributes">Table 3-1</a>. The information in each package entry can be obtained via the <code class="literal">getPackageInfo(String packageName, int flags)</code> method of the <code class="literal">android.content.pm.PackageManager</code> SDK class, which should return a <code class="literal">PackageInfo</code> instance that encapsulates the attributes available in each <span class="emphasis"><em>packages.xml</em></span> entry, as well as information about components, permissions, and features defined in the application’s manifest.</p><div class="table"><a id="package_attributes-id00005"/><p class="title">Table 3-1. Package Attributes</p><div class="table-contents"><table summary="Package Attributes" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p>Attribute Name</p></th><th style="border-bottom: 0.5pt solid ; " valign="top"><p>Description</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">name</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The package name.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">codePath</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Full path to the location of the package.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">resourcePath</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Full path to the location of the publicly available parts of the package (primary resource package and manifest). Only set on forward-locked apps.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">nativeLibraryPath</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Full path to the directory where native libraries are stored.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">flags</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>Flags associated with the application.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">ft</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>APK file timestamp (Unix time in milliseconds, as per <code class="literal">System.currentTimeMillis()</code>).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">it</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The time at which the app was first installed (Unix time in milliseconds).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">ut</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The time the app was last updated (Unix time in milliseconds).</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">version</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The version number of the package, as specified by the <code class="literal">versionCode</code> attribute in the app manifest.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">userId</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The kernel UID assigned to the application.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">installer</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>The package name of the application that installed the app.</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">sharedUserId</code></p></td><td style="" valign="top"><p>The shared user ID name of the package, as specified by the <code class="literal">sharedUserId</code> attribute in the manifest.</p></td></tr></tbody></table></div></div></div><div class="sect3" title="Updating Components and Permissions"><div class="titlepage"><div><div><h3 class="title"><a id="updating_components_and_permissions"/>Updating Components and Permissions</h3></div></div></div><p>After creating the <span class="emphasis"><em>packages.xml</em></span> entry, the <code class="literal">PackageManagerService</code> scans all Android components defined in the new application’s manifests and adds them to its internal on-memory component registry. Next, any permission groups and permissions the app declares are scanned and added to the permission registry.</p><div class="note" title="Note"><h3 class="title"><a id="ch03note06"/>Note</h3><p><a id="iddle1062" class="indexterm"/><a id="iddle2391" class="indexterm"/><a id="iddle2921" class="indexterm"/><a id="iddle2939" class="indexterm"/><span class="emphasis"><em>Custom permissions defined by applications are registered using a “first one wins” strategy: if both app A and B define permission P, and A is installed first, A’s permission definition is registered and B’s permission definition is ignored (because P is already registered). This is possible because permission names are not bound to the defining app package in any way, and thus any app can define any permission. This “first one wins” strategy can result in permission protection level downgrade: if A’s permission definition has a lower protection level (for example,</em></span> normal<span class="emphasis"><em>) than B’s definition (for example,</em></span> signature<span class="emphasis"><em>), and A is installed first, access to B’s components protected by P will not require callers to be signed with the same key as B. Therefore, when using custom permissions to protect components, be sure to check whether the currently registered permission has the protection level your app expects.</em></span><sup>[<a id="ch03fn09" href="#ftn.ch03fn09" class="footnote">25</a>]</sup></p></div><p>Finally, changes to the package database (the package entry and any new permissions) are saved to disk and the <code class="literal">PackageManagerService</code> sends the <code class="literal">ACTION_PACKAGE_ADDED</code> to notify other components about the newly added application.</p></div></div><div class="sect2" title="Updating a Package"><div class="titlepage"><div><div><h2 class="title"><a id="updating_a_package"/>Updating a Package</h2></div></div></div><p>The process of updating a package follows most of the same steps as installing a package, so we’ll highlight only the differences here.</p><div class="sect3" title="Signature Verification"><div class="titlepage"><div><div><h3 class="title"><a id="signature_verification"/>Signature Verification</h3></div></div></div><p>The first step is to check whether the new package has been signed by the same set of signers as the existing one. This rule is referred to as <span class="emphasis"><em>same origin policy</em></span>, or <span class="emphasis"><em>Trust On First Use (TOFU)</em></span>. This signature check guarantees that the update is produced by the same entity as the original application (assuming that the signing key has not been compromised) and establishes a trust relationship between the update and the existing application. As we shall see in “<a class="xref" href="ch03.html#updating_non-system_apps" title="Updating Non-System Apps">Updating Non-System Apps</a>”, the update inherits the data of the original application.</p><div class="note" title="Note"><h3 class="title"><a id="ch03note07"/>Note</h3><p><span class="emphasis"><em>When signing certificates are compared for equality, the certificates are not validated in the PKI sense of the word (time validity, trusted issuer, revocation, and so on are not checked).</em></span></p></div><p>The certificate equality check is performed by the <code class="literal">PackageManagerService.compareSignatrues()</code> method as shown in <a class="xref" href="ch03.html#package_signature_comparison_method" title="Example 3-14. Package signature comparison method">Example 3-14</a>.</p><div class="example"><a id="package_signature_comparison_method"/><p class="title">Example 3-14. Package signature comparison method</p><div class="example-contents"><pre class="programlisting">static int compareSignatures(Signature[] s1, Signature[] s2) {
    if (s1 == null) {
        return s2 == null
            ? PackageManager.SIGNATURE_NEITHER_SIGNED
            : PackageManager.SIGNATURE_FIRST_NOT_SIGNED;
    }
    if (s2 == null) {
        return PackageManager.SIGNATURE_SECOND_NOT_SIGNED;
    }
    HashSet&lt;Signature&gt; set1 = new HashSet&lt;Signature&gt;();
    for (Signature sig : s1) {
        set1.add(sig);
    }
    HashSet&lt;Signature&gt; set2 = new HashSet&lt;Signature&gt;();
    for (Signature sig : s2) {
        set2.add(sig);
    }
    // Make sure s2 contains all signatures in s1.
    if (set1.equals(set2)) {➊
        return PackageManager.SIGNATURE_MATCH;
    }
    return PackageManager.SIGNATURE_NO_MATCH;
}</pre></div></div><p><a id="iddle2823" class="indexterm"/>Here, the <code class="literal">Signature</code> class serves as an “opaque, immutable representation of a signature associated with an application package.” <sup>[<a id="ch03fn10" href="#ftn.ch03fn10" class="footnote">26</a>]</sup> In practice, it is a wrapper for the DER-encoded signing certificate associated with an APK file. <a class="xref" href="ch03.html#package_signature_representation" title="Example 3-15. Package signature representation">Example 3-15</a> shows an excerpt, focusing on its <code class="literal">equals()</code> and <code class="literal">hashCode()</code> methods.</p><div class="example"><a id="package_signature_representation"/><p class="title">Example 3-15. Package signature representation</p><div class="example-contents"><pre class="programlisting">public class Signature implements Parcelable {
    private final byte[] mSignature;
    private int mHashCode;
    private boolean mHaveHashCode;
    --<span class="emphasis"><em>snip</em></span>--
    public Signature(byte[] signature) {
        mSignature = signature.clone();
    }

    public PublicKey getPublicKey() throws CertificateException {
        final CertificateFactory certFactory =
                CertificateFactory.getInstance("X.509");
        final ByteArrayInputStream bais = new ByteArrayInputStream(mSignature);
        final Certificate cert = certFactory.generateCertificate(bais);
        return cert.getPublicKey();
    }

    @Override
    public boolean equals(Object obj) {
        try {
            if (obj != null) {
                Signature other = (Signature)obj;
                return this == other
                    || Arrays.equals(mSignature, other.mSignature);➊
            }
        } catch (ClassCastException e) {
        }
        return false;
    }

    @Override
    public int hashCode() {
        if (mHaveHashCode) {
            return mHashCode;
        }
        mHashCode = Arrays.hashCode(mSignature);➋
        mHaveHashCode = true;
        return mHashCode;
    }
--<span class="emphasis"><em>snip</em></span>--
}</pre></div></div><p><a id="iddle1410" class="indexterm"/><a id="iddle1974" class="indexterm"/>As you can see at ➊, two signature classes are considered equal if the DER-encoding of the underlying X.509 certificates match exactly, and the <code class="literal">Signature</code> class hash code is calculated solely based on the encoded certificate ➋. If the signing certificates do not match, the <code class="literal">compareSignatures()</code> methods returns the <code class="literal">INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES</code> error code.</p><p>This binary certificate comparison naturally knows nothing about CAs or expiration dates. One consequence of this is that after an app (identified by a unique package name) is installed, updates need to use the same signing certificates (with the exception of system app updates, as discussed in “<a class="xref" href="ch03.html#updating_system_apps" title="Updating System Apps">Updating System Apps</a>”).</p><p>While multiple signatures on Android apps are rare, they do occur. If the original application was signed by more than one signer, any updates need to be signed by the same signers, each using its original signing certificate (enforced by ➊ in <a class="xref" href="ch03.html#package_signature_comparison_method" title="Example 3-14. Package signature comparison method">Example 3-14</a>). This means that if a developer’s signing certificate(s) expires or he loses access to his signing key, he cannot update the app and must release a new one instead. This would result in not only losing any existing user base or ratings, but more importantly losing access to the legacy app’s data and settings.</p><p>The solution to this problem is straightforward, if not ideal: back up your signing key and don’t let your certificate expire. The currently recommended validity period is at least 25 years, and the Google Play Store requires validity until at least October 2033. While technically this only amounts to putting off the problem, proper certificate migration support might eventually be added to the platform.</p><p>When the package manager establishes that the update has been signed with the same certificate, it proceeds with updating the package. The process is different for system and user-installed apps, as described next.</p></div><div class="sect3" title="Updating Non-System Apps"><div class="titlepage"><div><div><h3 class="title"><a id="updating_non-system_apps"/>Updating Non-System Apps</h3></div></div></div><p><a id="iddle2408" class="indexterm"/><a id="iddle2654" class="indexterm"/>Non-system apps are updated by essentially reinstalling the app while retaining its data directory. The first step is to kill any process of the package being updated. Next, the package is removed from internal structures and the package database, which removes all components that the app has registered as well. Next, the <code class="literal">PackageManagerService</code> triggers a package scan by calling the <code class="literal">scanPackageLI()</code> method. The scan proceeds as it would with new installs, except that it updates the package’s code, resource path, version, and timestamp. The package manifest is scanned and any defined components are registered with the system. Next, permissions for all packages are re-granted to ensure that they match any definitions in the updated package. Finally, the updated packaged database is written to disk and a <code class="literal">PACKAGE_REPLACED</code> system broadcast is sent.</p></div><div class="sect3" title="Updating System Apps"><div class="titlepage"><div><div><h3 class="title"><a id="updating_system_apps"/>Updating System Apps</h3></div></div></div><p>As with user-installed apps, preinstalled apps (usually found in <span class="emphasis"><em>/system/app/</em></span>) can be updated without a full-blown system update, usually via the Google Play Store or a similar app distribution service. Though because the <span class="emphasis"><em>system</em></span> partition is mounted read-only, updates are installed in <span class="emphasis"><em>/data/app/</em></span>, while the original app is left intact. In addition to a <code class="literal">&lt;package&gt;</code> entry, the updated app will also have an <code class="literal">&lt;updated-package&gt;</code> entry that might look like the example in <a class="xref" href="ch03.html#package_database_entries_for_an_updated" title="Example 3-16. Package database entries for an updated system package">Example 3-16</a>.</p><div class="example"><a id="package_database_entries_for_an_updated"/><p class="title">Example 3-16. Package database entries for an updated system package</p><div class="example-contents"><pre class="programlisting">&lt;package name="com.google.android.keep"
         codePath="/data/app/com.google.android.keep-1.apk"➊
         nativeLibraryPath="/data/app-lib/com.google.android.keep-1"
         flags="4767461"➋
         ft="142ee64d980"
         it="14206f3e320"
         ut="142ee64dfcb"
         version="2101"
         userId="10053"➌
         installer="com.android.vending"&gt;
    &lt;sigs count="1"&gt;
        &lt;cert index="2" /&gt;
    &lt;/sigs&gt;
    &lt;signing-keyset identifier="3" /&gt;
    &lt;signing-keyset identifier="34" /&gt;
&lt;/package&gt;
--<span class="emphasis"><em>snip</em></span>--
&lt;updated-package name="com.google.android.keep"
                 codePath="/system/app/Keep.apk"
                 nativeLibraryPath="/data/app-lib/Keep"
                 ft="ddc8dee8"
                 it="14206f3e320"
                 ut="ddc8dee8"
                 version="2051"
                 userId="10053"&gt;➍
    &lt;perms&gt;
        &lt;item name="android.permission.READ_EXTERNAL_STORAGE" /&gt;
        &lt;item name="android.permission.USE_CREDENTIALS" /&gt;
        &lt;item name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
        --<span class="emphasis"><em>snip</em></span>--
    &lt;/perms&gt;
&lt;/updated-package&gt;</pre></div></div><p><a id="iddle1089" class="indexterm"/><a id="iddle1090" class="indexterm"/><a id="iddle1153" class="indexterm"/><a id="iddle1227" class="indexterm"/><a id="iddle1823" class="indexterm"/><a id="iddle2388" class="indexterm"/><a id="iddle2502" class="indexterm"/>The update’s <code class="literal">codePath</code> attribute is set to the path of the new APK in <span class="emphasis"><em>/data/app/</em></span> ➊. It inherits the original app’s permissions and UID (➌ and ➍) and is marked as an update to a system app by adding the <code class="literal">FLAG_UPDATED_SYSTEM_APP</code> (0x80) to its <code class="literal">flags</code> attribute ➋.</p><p>System apps can be updated directly in the <span class="emphasis"><em>system</em></span> partition as well, usually as the result of an OTA system update, and in such case the updated system APK is allowed to be signed with a different certificate. The rationale behind this is that if the installer has enough privileges to write to the <span class="emphasis"><em>system</em></span> partition, it can be trusted to change the signing certificate as well. The UID, and any files and permissions, are retained. The exception is that if the package is part of a shared user (discussed in <a class="xref" href="ch02.html" title="Chapter 2. Permissions">Chapter 2</a>), the signature cannot be updated, because doing so would affect other apps. In the reverse case, when a new system app is signed by a different certificate than that of the currently installed non-system app (with the same package name), the non-system app will be deleted first.</p></div></div><div class="sect2" title="Installing Encrypted APKs"><div class="titlepage"><div><div><h2 class="title"><a id="installing_encrypted_apks"/>Installing Encrypted APKs</h2></div></div></div><p>Support for installing encrypted APKs was added in Android 4.1 along with support for forward locking using ASEC containers. Both features were announced as <span class="emphasis"><em>app encryption</em></span>, but we’ll discuss them separately, beginning with support for encrypted APK files. But first let’s see how to install encrypted APKs.</p><p>Encrypted APKs can be installed using the Google Play Store client, or with the <code class="literal">pm</code> command from the Android shell, but the system <code class="literal">PackageInstaller</code> does not support encrypted APKs. Because we can’t control the Google Play Store installation flow, in order to install an encrypted APK we need to either use the <code class="literal">pm</code> command or write our own installer app. We’ll take the easy route and use the <code class="literal">pm</code> command.</p><div class="sect3" title="Creating and Installing an Encrypted APK"><div class="titlepage"><div><div><h3 class="title"><a id="creating_and_installing_an_encrypted_apk"/>Creating and Installing an Encrypted APK</h3></div></div></div><p>The <code class="literal">adb install</code> command both copies the APK file to a temporary file on the device and starts the install process. The command provides a convenient wrapper to the <code class="literal">adb push</code> and <code class="literal">pm install</code> commands. <code class="literal">adb install</code> gained three new parameters in Android 4.1 in order to support encrypted APKs (see <a class="xref" href="ch03.html#adb_install_command_options" title="Example 3-17. adb install command options">Example 3-17</a>).</p><div class="example"><a id="adb_install_command_options"/><p class="title">Example 3-17. <code class="literal">adb install</code> command options</p><div class="example-contents"><pre class="programlisting">adb install [-l] [-r] [-s] [--algo &lt;algorithm name&gt; --key &lt;hex-encoded key&gt;
--iv &lt;hex-encoded iv&gt;] &lt;file&gt;</pre></div></div><p><a id="iddle1127" class="indexterm"/><a id="iddle1973" class="indexterm"/><a id="iddle2002" class="indexterm"/><a id="iddle2118" class="indexterm"/><a id="iddle2354" class="indexterm"/><a id="iddle2355" class="indexterm"/><a id="iddle2398" class="indexterm"/>The <code class="literal">--algo</code>, <code class="literal">--key</code>, and <code class="literal">--iv</code> parameters let you specify the encryption algorithm, key, and initialization vector (IV), respectively. But in order to use those new parameters, we need to create an encrypted APK first.</p><p>An APK file can be encrypted using the <code class="literal">enc</code> OpenSSL commands as shown in <a class="xref" href="ch03.html#encrypting_an_apk_file_using_openssl" title="Example 3-18. Encrypting an APK file using OpenSSL">Example 3-18</a>. Here we use AES in CBC mode with a 128-bit key, and specify an IV that is the same as the key in order to make things simpler.</p><div class="example"><a id="encrypting_an_apk_file_using_openssl"/><p class="title">Example 3-18. Encrypting an APK file using OpenSSL</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>openssl enc -aes-128-cbc -K 000102030405060708090A0B0C0D0E0F</strong></span>
<span class="strong"><strong>-iv 000102030405060708090A0B0C0D0E0F -in my-app.apk -out my-app-enc.apk</strong></span></pre></div></div><p>Next, we install our encrypted APK by passing the encryption algorithm key (in <code class="literal">javax.crypto.Cipher</code> transformation string format, which is discussed in <a class="xref" href="ch05.html" title="Chapter 5. Cryptographic Providers">Chapter 5</a>) and IV bytes to the <code class="literal">adb install</code> command as shown in <a class="xref" href="ch03.html#installing_an_encrypted_apk_using_adb_in" title="Example 3-19. Installing an encrypted APK using adb install">Example 3-19</a>.</p><div class="example"><a id="installing_an_encrypted_apk_using_adb_in"/><p class="title">Example 3-19. Installing an encrypted APK using <code class="literal">adb install</code></p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>adb install --algo 'AES/CBC/PKCS5Padding' \</strong></span>
<span class="strong"><strong>--key 000102030405060708090A0B0C0D0E0F \</strong></span>
<span class="strong"><strong>--iv 000102030405060708090A0B0C0D0E0F my-app-enc.apk</strong></span>
        pkg: /data/local/tmp/my-app-enc.apk
Success</pre></div></div><p>As the <code class="literal">Success</code> output indicates, the APK installs without errors. The actual APK file is copied into <span class="emphasis"><em>/data/app/</em></span>, and comparing its hash with our encrypted APK reveals that it is in fact a different file. The hash value is exactly the same as that of the original (unencrypted) APK, so we conclude that the APK is decrypted at install time using the provided encryption parameters (algorithm, key, and IV).</p></div><div class="sect3" title="Implementation and Encryption Parameters"><div class="titlepage"><div><div><h3 class="title"><a id="implementation_and_encryption_parameters"/>Implementation and Encryption Parameters</h3></div></div></div><p>Let’s see how this is implemented. After it has transferred the APK to the device, <code class="literal">adb install</code> calls the <code class="literal">pm</code> Android command-line utility with the <code class="literal">install</code> parameter and the path to the copied APK file. The component responsible for installing apps on Android is <code class="literal">PackageManagerService</code> and the <code class="literal">pm</code> command is just a convenient frontend for some of its functionality. When started with the <code class="literal">install</code> parameter, <code class="literal">pm</code> calls the method <code class="literal">installPackageWithVerificationAndEncryption()</code>, converting its options to the relevant parameters as necessary. <a class="xref" href="ch03.html#packagemanagerservicedotinstallpackagewi" title="Example 3-20. PackageManagerService.installPackageWithVerificationAndEncryption() method signature">Example 3-20</a> shows the method’s full signature.</p><div class="example"><a id="packagemanagerservicedotinstallpackagewi"/><p class="title">Example 3-20. <code class="literal">PackageManagerService.installPackageWithVerificationAndEncryption()</code> method signature</p><div class="example-contents"><pre class="programlisting">public void installPackageWithVerificationAndEncryption(Uri packageURI,
        IPackageInstallObserver observer, int flags,
        String installerPackageName,
        VerificationParams verificationParams,
        ContainerEncryptionParams encryptionParams) {
--<span class="emphasis"><em>snip</em></span>--
}</pre></div></div><p><a id="iddle1417" class="indexterm"/><a id="iddle2168" class="indexterm"/><a id="iddle2172" class="indexterm"/><a id="iddle2217" class="indexterm"/><a id="iddle2218" class="indexterm"/><a id="iddle2220" class="indexterm"/><a id="iddle2503" class="indexterm"/><a id="iddle2912" class="indexterm"/><a id="iddle3055" class="indexterm"/>We discussed most of the method’s parameters in “<a class="xref" href="ch03.html#apk_install_process" title="APK Install Process">APK Install Process</a>” earlier, but we have yet to encounter the <code class="literal">VerificationParams</code> and <code class="literal">ContainerEncryptionParams</code> classes. As the name implies, the <code class="literal">VerificationParams</code> class encapsulates a parameter used during package verification, which we will discuss in “<a class="xref" href="ch03.html#package_verification" title="Package Verification">Package Verification</a>”. The <code class="literal">ContainerEncryptionParams</code> class holds encryption parameters, including the values passed via the <code class="literal">--algo</code>, <code class="literal">--key</code>, and <code class="literal">--iv</code> options of <code class="literal">adb install</code>. <a class="xref" href="ch03.html#containerencryptionparams_data_members" title="Example 3-21. ContainerEncryptionParams data members">Example 3-21</a> shows its data members.</p><div class="example"><a id="containerencryptionparams_data_members"/><p class="title">Example 3-21. <code class="literal">ContainerEncryptionParams</code> data members</p><div class="example-contents"><pre class="programlisting">public class ContainerEncryptionParams implements Parcelable {
    private final String mEncryptionAlgorithm;
    private final IvParameterSpec mEncryptionSpec;
    private final SecretKey mEncryptionKey;
    private final String mMacAlgorithm;
    private final AlgorithmParameterSpec mMacSpec;
    private final SecretKey mMacKey;
    private final byte[] mMacTag;
    private final long mAuthenticatedDataStart;
    private final long mEncryptedDataStart;
    private final long mDataEnd;
    --<span class="emphasis"><em>snip</em></span>--
}</pre></div></div><p>The <code class="literal">adb install</code> parameters above correspond to the first three fields of the class. While not available through the <code class="literal">adb install</code> wrapper, the <code class="literal">pm install</code> command also takes the <code class="literal">--macalgo</code>, <code class="literal">--mackey</code>, and <code class="literal">--tag</code> parameters, which correspond to the <code class="literal">mMacAlgorithm</code>, <code class="literal">mMacKey</code>, and <code class="literal">mMacTag</code> fields of the <code class="literal">ContainerEncryptionParams</code> class. In order to use those parameters, we need to calculate the MAC value of the encrypted APK first, which we accomplish with the OpenSSL <code class="literal">dgst</code> command as shown in <a class="xref" href="ch03.html#calculating_the_mac_of_an_encrypted_apk" title="Example 3-22. Calculating the MAC of an encrypted APK">Example 3-22</a>.</p><div class="example"><a id="calculating_the_mac_of_an_encrypted_apk"/><p class="title">Example 3-22. Calculating the MAC of an encrypted APK</p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>openssl dgst -hmac 'hmac_key_1' -sha1 -hex my-app-enc.apk</strong></span>
HMAC-SHA1(my-app-enc.apk)= 962ecdb4e99551f6c2cf72f641362d657164f55a</pre></div></div><div class="note" title="Note"><h3 class="title"><a id="ch03note08"/>Note</h3><p><a id="iddle1418" class="indexterm"/><a id="iddle1426" class="indexterm"/><a id="iddle1964" class="indexterm"/><a id="iddle2198" class="indexterm"/><a id="iddle2387" class="indexterm"/><span class="emphasis"><em>The <code class="literal">dgst</code> command doesn’t allow you to specify the HMAC key using hexadecimal or Base64, so we’re limited to ASCII characters. This may not be a good idea for production use, so consider using a real key and calculating the MAC in some other way (for example, using a JCE program).</em></span></p></div></div><div class="sect3" title="Installing an Encrypted APK with Integrity Check"><div class="titlepage"><div><div><h3 class="title"><a id="installing_an_encrypted_apk_with_integri"/>Installing an Encrypted APK with Integrity Check</h3></div></div></div><p>We can now install an encrypted APK and verify its integrity by opening the Android shell using <code class="literal">adb shell</code> and executing the command shown in <a class="xref" href="ch03.html#installing_an_encrypted_apk_with-id00006" title="Example 3-23. Installing an encrypted APK with integrity verification using pm install">Example 3-23</a>.</p><div class="example"><a id="installing_an_encrypted_apk_with-id00006"/><p class="title">Example 3-23. Installing an encrypted APK with integrity verification using <code class="literal">pm install</code></p><div class="example-contents"><pre class="programlisting">$ <span class="strong"><strong>pm install -r --algo 'AES/CBC/PKCS5Padding' \</strong></span>
<span class="strong"><strong>--key 000102030405060708090A0B0C0D0E0F \</strong></span>
<span class="strong"><strong>--iv 000102030405060708090A0B0C0D0E0F \</strong></span>
<span class="strong"><strong>--macalgo HmacSHA1 --mackey 686d61635f6b65795f31 \</strong></span>
<span class="strong"><strong>--tag 962ecdb4e99551f6c2cf72f641362d657164f55a /sdcard/my-app-enc.apk</strong></span>
        pkg: /sdcard/kr-enc.apk
Success</pre></div></div><p>The app’s integrity is checked by comparing the specified MAC tag with the value calculated based on the actual file contents, the contents are decrypted, and the decrypted APK is copied to <span class="emphasis"><em>/data/app/</em></span>. (To test that MAC verification is indeed performed, change the tag value slightly. Doing so should result in an install error with error code <code class="literal">INSTALL_FAILED_INVALID_APK</code>.)</p><p>As we saw in <a class="xref" href="ch03.html#installing_an_encrypted_apk_using_adb_in" title="Example 3-19. Installing an encrypted APK using adb install">Example 3-19</a> and <a class="xref" href="ch03.html#installing_an_encrypted_apk_with-id00006" title="Example 3-23. Installing an encrypted APK with integrity verification using pm install">Example 3-23</a>, the APK files that are ultimately copied to <span class="emphasis"><em>/data/app/</em></span> are not encrypted and thus the installation process is the same as for unencrypted APKs, except for file decryption and the optional integrity verification. Decryption and integrity verification are performed transparently by the <code class="literal">MediaContainerService</code> while copying the APK to the application directory. If a <code class="literal">ContainerEncryptionParams</code> instance is passed to its <code class="literal">copyResource()</code> method, it uses the provided encryption parameters to instantiate the JCA classes <code class="literal">Cipher</code> and <code class="literal">Mac</code> (see <a class="xref" href="ch05.html" title="Chapter 5. Cryptographic Providers">Chapter 5</a>) that can perform decryption and integrity checking.</p><div class="note" title="Note"><h3 class="title"><a id="ch03note09"/>Note</h3><p><span class="emphasis"><em>The MAC tag and encrypted APK can be bundled in a single file, in which case the <code class="literal">MediaContainerService</code> uses the <code class="literal">mAuthenticatedDataStart</code>, <code class="literal">mEncryptedDataStart</code>, and <code class="literal">mDataEnd</code> members to extract the MAC and APK data from the file.</em></span></p></div></div></div><div class="sect2" title="Forward Locking"><div class="titlepage"><div><div><h2 class="title"><a id="forward_locking"/>Forward Locking</h2></div></div></div><p>Forward locking appeared around the time ringtones, wallpapers, and other digital “goods” started selling on feature phones. Because installed APK files are world readable on Android, it’s relatively easy to extract apps from even a production device. In an attempt to lock down paid apps (and prevent a user from forwarding them to another user) without losing any of the OS’s flexibility, early Android versions introduced forward locking (also called <span class="emphasis"><em>copy protection</em></span>).</p><p><a id="iddle1767" class="indexterm"/><a id="iddle1806" class="indexterm"/><a id="iddle2209" class="indexterm"/>The idea behind forward locking was to split app packages into two parts: a world-readable part that contains resources and the manifest (in <span class="emphasis"><em>/data/app/</em></span>), and a package that is readable only by the <span class="emphasis"><em>system</em></span> user and which contains executable code (in <span class="emphasis"><em>/data/app-private/</em></span>). The code package was protected by filesystem permissions, which made it inaccessible to users on most consumer devices, but it could be extracted from devices with root access, and this early forward locking mechanism was quickly deprecated and replaced with an online application licensing service called Google Play Licensing.</p><p>The problem with Google Play Licensing was that it shifted app protection implementation from the OS to app developers, and it had mixed results. The forward locking implementation was redesigned in Android 4.1, and now offers the ability to store APKs in an encrypted container that requires a device-specific key to be mounted at runtime. Let’s look at it in a bit more detail.</p></div><div class="sect2" title="Android 4.1 Forward Locking Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="android_4dot1_forward_locking_implementa"/>Android 4.1 Forward Locking Implementation</h2></div></div></div><p>While the use of encrypted app containers as a forward locking mechanism was introduced in Android version 4.1, encrypted containers were originally introduced in Android 2.2. At that time (mid-2010), most Android devices came with limited internal storage and relatively large (a few gigabytes) external storage, usually in the form of a microSD card. To make file sharing easier, external storage was formatted using the FAT filesystem, which lacks file permissions. As a result, files on the SD card could be read and written by any application.</p><p>To prevent users from simply copying paid apps from the SD card, Android 2.2 created an encrypted filesystem image file and stored the APK in it when a user opted to move an app to external storage. The system would then create a mount point for the encrypted image, and mount it using Linux’s device-mapper. Android loaded each app’s files from its mount point at runtime.</p><p>Android 4.1 built on this idea by making the container use the ext4 filesystem, which allows for file permissions. A typical forward-locked app’s mount point now looks like <a class="xref" href="ch03.html#contents_of_a_forward-locked_appapostrop" title="Example 3-24. Contents of a forward-locked app’s mount point">Example 3-24</a> (timestamps omitted).</p><div class="example"><a id="contents_of_a_forward-locked_appapostrop"/><p class="title">Example 3-24. Contents of a forward-locked app’s mount point</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>ls -l /mnt/asec/com.example.app-1</strong></span>
drwxr-xr-x system   system             lib
drwx------ root     root               lost+found
-rw-r----- system   u0_a96     1319057 pkg.apk
-rw-r--r-- system   system      526091 res.zip</pre></div></div><p>Here, the <span class="emphasis"><em>res.zip</em></span> holds app resources and the manifest file and is world readable, while the <span class="emphasis"><em>pkg.apk</em></span> file that holds the full APK is only readable by the system and the app’s dedicated user (<span class="emphasis"><em>u0_a96</em></span>). The actual app containers are stored in <span class="emphasis"><em>/data/app-asec/</em></span> in files with the <span class="emphasis"><em>.asec</em></span> extension.</p><div class="sect3" title="Encrypted App Containers"><div class="titlepage"><div><div><h3 class="title"><a id="encrypted_app_containers"/>Encrypted App Containers</h3></div></div></div><p><a id="iddle1154" class="indexterm"/><a id="iddle1228" class="indexterm"/><a id="iddle1229" class="indexterm"/><a id="iddle1230" class="indexterm"/><a id="iddle1231" class="indexterm"/>Encrypted app containers are referred to as <span class="emphasis"><em>Android Secure External Caches</em></span>, or <span class="emphasis"><em>ASEC containers.</em></span> ASEC container management (creating, deleting, mounting, and unmounting) is implemented in the system volume daemon (<span class="emphasis"><em>vold</em></span>), and the <code class="literal">MountService</code> provides an interface to its functionality to framework services. We can also use the <code class="literal">vdc</code> command-line utility to interact with <span class="emphasis"><em>vold</em></span> in order to manage forward-locked apps from Android’s shell (see <a class="xref" href="ch03.html#issuing_asec_management_commands_with_vd" title="Example 3-25. Issuing ASEC management commands with vdc">Example 3-25</a>).</p><div class="example"><a id="issuing_asec_management_commands_with_vd"/><p class="title">Example 3-25. Issuing ASEC management commands with <code class="literal">vdc</code></p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>vdc asec list</strong></span>➊
vdc asec list
111 0 com.example.app-1
111 0 org.foo.app-1
200 0 asec operation succeeded

# <span class="strong"><strong>vdc asec path com.example.app-1</strong></span>➋
vdc asec path com.example.app-1
211 0 /mnt/asec/com.example.app-1

# <span class="strong"><strong>vdc asec unmount org.example.app-1</strong></span>➌
200 0 asec operation succeeded

# <span class="strong"><strong>vdc asec mount com.example.app-1 000102030405060708090a0b0c0d0e0f 1000</strong></span>➍
com.example.app-1 000102030405060708090a0b0c0d0e0f 1000
200 0 asec operation succeeded</pre></div></div><p>Here, the <code class="literal">asec list</code> command ➊ lists the namespace IDs of mounted ASEC containers. Namespace IDs are based on the package name and have the same format as APK filenames for non-forward-locked applications. All other commands take a namespace ID as a parameter.</p><p>The <code class="literal">asec path</code> command ➋ shows the mount point of the specified ASEC container, while the <code class="literal">asec unmount</code> command unmounts it ➌. In addition to a namespace ID, <code class="literal">asec mount</code> ➍ requires that you specify the encryption key and the mount point’s owner UID (1000 is <span class="emphasis"><em>system</em></span>).</p><p>The ASEC container encryption algorithm and the key length are unchanged from the original Android 2.2 apps-to-SD implementation: Twofish with a 128-bit key stored in <span class="emphasis"><em>/data/misc/systemkeys/</em></span>, as shown in <a class="xref" href="ch03.html#asec_container_encryption_key_location_a" title="Example 3-26. ASEC container encryption key location and contents">Example 3-26</a>.</p><div class="example"><a id="asec_container_encryption_key_location_a"/><p class="title">Example 3-26. ASEC container encryption key location and contents</p><div class="example-contents"><pre class="programlisting"># <span class="strong"><strong>ls -l /data/misc/systemkeys</strong></span>
-rw------- system   system         16 AppsOnSD.sks
# <span class="strong"><strong>od -t x1 /data/misc/systemkeys/AppsOnSD.sks</strong></span>
0000000 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f
0000020</pre></div></div><p>Forward locking an application is triggered by specifying the <code class="literal">-l</code> option of <code class="literal">pm install</code> or by specifying the <code class="literal">INSTALL_FORWARD_LOCK</code> flag when calling one of <code class="literal">PackageManager</code>’s <code class="literal">installPackage()</code> methods.</p></div><div class="sect3" title="Installing Forward-Locked APKs"><div class="titlepage"><div><div><h3 class="title"><a id="installing_forward-locked_apks"/>Installing Forward-Locked APKs</h3></div></div></div><p><a id="iddle1431" class="indexterm"/><a id="iddle1921" class="indexterm"/><a id="iddle1969" class="indexterm"/><a id="iddle2199" class="indexterm"/><a id="iddle2227" class="indexterm"/><a id="iddle2385" class="indexterm"/><a id="iddle2386" class="indexterm"/>The install process of forward-locked APKs involves two additional steps: creating and mounting the secure container, and extracting the public resource files from the APK file. As with encrypted APKs, those steps are encapsulated by the <code class="literal">MediaContainerService</code> and are performed while copying the APK to the application directory. As the <code class="literal">MediaContainerService</code> does not have enough privileges to create and mount secure containers, it delegates container management to the <span class="emphasis"><em>vold</em></span> daemon by calling the appropriate <code class="literal">MountService</code> methods (<code class="literal">createSecureContainer()</code>, <code class="literal">mountSecureContainer()</code>, and so on).</p></div></div><div class="sect2" title="Encrypted Apps and Google Play"><div class="titlepage"><div><div><h2 class="title"><a id="encrypted_apps_and_google_play"/>Encrypted Apps and Google Play</h2></div></div></div><p>Because installing apps without user interaction, encrypted or otherwise, requires system permissions, only system applications can install applications. Google’s own Play Store Android client takes advantage of both encrypted apps and forward locking. While describing exactly how the Google Play client works would require detailed knowledge of the underlying protocol (which is not open and is constantly evolving), a casual look into the implementation of a recent Google Play Store client reveals a few useful pieces of information.</p><p>Google Play servers send quite a bit of metadata about the app you are about to download and install, such as download URL, APK file size, version code, and refund window. Among these, the <code class="literal">EncryptionParams</code> shown in <a class="xref" href="ch03.html#encryptionparams_used_in_the_google_play" title="Example 3-27. EncryptionParams used in the Google Play Store protocol">Example 3-27</a> looks very similar to the <code class="literal">ContainerEncryptionParams</code> shown in <a class="xref" href="ch03.html#containerencryptionparams_data_members" title="Example 3-21. ContainerEncryptionParams data members">Example 3-21</a>.</p><div class="example"><a id="encryptionparams_used_in_the_google_play"/><p class="title">Example 3-27. <code class="literal">EncryptionParams</code> used in the Google Play Store protocol</p><div class="example-contents"><pre class="programlisting">class AndroidAppDelivery$EncryptionParams {
  --<span class="emphasis"><em>snip</em></span>--
  private String encryptionKey;
  private String hmacKey;
  private int version;
}</pre></div></div><p>The encryption algorithm and the HMAC algorithm of paid applications downloaded from Google Play are always set to <span class="emphasis"><em>AES/CBC/PKCS5Padding</em></span> and <span class="emphasis"><em>HMACSHA1</em></span>, respectively. The IV and the MAC tag are bundled with the encrypted APK in a single blob. After all parameters are read and verified, they are essentially converted to a <code class="literal">ContainerEncryptionParams</code> instance, and the app is installed using the <code class="literal">PackageManager.installPackageWithVerification()</code> method.</p><p>The <code class="literal">INSTALL_FORWARD_LOCK</code> flag is set when installing a paid app in order to enable forward locking. The OS takes it from here, and the process is as described in the previous two sections: free apps are decrypted and the APKs end up in <span class="emphasis"><em>/data/app/</em></span>, while an encrypted container in <span class="emphasis"><em>/data/app-asec/</em></span> is created and mounted under <span class="emphasis"><em>/mnt/asec/&lt;package-name&gt;</em></span> for paid apps.</p><p><a id="iddle1252" class="indexterm"/><a id="iddle2475" class="indexterm"/><a id="iddle2855" class="indexterm"/>How secure is this in practice? Google Play can now claim that paid apps are always transferred and stored in encrypted form, and so can your own app distribution channel if you decide to implement it using the app encryption facilities that Android provides. The APK file contents have to be made available to the OS at some point though, so if you have root access to a running Android device, it’s still possible to extract a forward-locked APK or the container encryption key.</p></div></div><div class="sect1" title="Package Verification"><div class="titlepage"><div><div><h1 class="title"><a id="package_verification"/>Package Verification</h1></div></div></div><p>Package verification was introduced as an official Android feature in version 4.2 as <span class="emphasis"><em>application verification</em></span> and was later backported to all versions running Android 2.3 and later and the Google Play Store. The infrastructure that makes package verification possible is built into the OS, but Android doesn’t ship with any built-in verifiers. The most widely used package verification implementation is the one built into the Google Play Store client and backed by Google’s app analysis infrastructure. It’s designed to protect Android devices from what Google calls “potentially harmful applications”<sup>[<a id="ch03fn11" href="#ftn.ch03fn11" class="footnote">27</a>]</sup> (backdoors, phishing applications, spyware, and so on), commonly known simply as <span class="emphasis"><em>malware</em></span>.</p><div class="figure"><a id="application_verification_warning_dialog"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00008"/><img src="figs/web/03fig03.png.jpg" alt="Application verification warning dialog"/></div></div><p class="title">Figure 3-3. Application verification warning dialog</p></div><p>When package verification is turned on, APKs are scanned by a verifier prior to installation, and the system shows a warning (see <a class="xref" href="ch03.html#application_verification_warning_dialog" title="Figure 3-3. Application verification warning dialog">Figure 3-3</a>) or blocks installation if the verifier deems the APK potentially harmful. Verification is on by default on supported devices but requires one-time user approval on first use, as it sends application data to Google. Application verification can be toggled via the Verify Apps option on the system settings Security screen (see <a class="xref" href="ch03.html#application_install_security_settings" title="Figure 3-2. Application install security settings">Figure 3-2</a>).</p><p>The following sections discuss the Android package verification infrastructure and then take a brief look at Google Play’s implementation.</p><div class="sect2" title="Android Support for Package Verification"><div class="titlepage"><div><div><h2 class="title"><a id="android_support_for_package_verification"/>Android Support for Package Verification</h2></div></div></div><p><a id="iddle2394" class="indexterm"/><a id="iddle2399" class="indexterm"/><a id="iddle2406" class="indexterm"/><a id="iddle2413" class="indexterm"/><a id="iddle2416" class="indexterm"/>As with most things that deal with application management, package verification is implemented in the <code class="literal">PackageManagerService</code>, and has been available since Android 4.0 (API level 14). Package verification is performed by one or more <span class="emphasis"><em>verification agents</em></span>, and has a <span class="emphasis"><em>required verifier</em></span> and zero or more <span class="emphasis"><em>sufficient verifiers</em></span>. Verification is considered complete when the required verifier and at least one of the sufficient verifiers return a positive result. An application can register itself as a required verifier by declaring a broadcast receiver with an intent filter that matches the <code class="literal">PACKAGE_NEEDS_VERIFICATION</code> action and the APK file MIME type (<span class="emphasis"><em>application/vnd.android.package-archive</em></span>), as shown in <a class="xref" href="ch03.html#required_verification_declaration_in_and" title="Example 3-28. Required verification declaration in AndroidManifest.xml">Example 3-28</a>.</p><div class="example"><a id="required_verification_declaration_in_and"/><p class="title">Example 3-28. Required verification declaration in <span class="roman">AndroidManifest.xml</span></p><div class="example-contents"><pre class="programlisting">&lt;receiver android:name=".MyPackageVerificationReceiver"
          android:permission="android.permission.BIND_PACKAGE_VERIFIER"&gt;
    &lt;intent-filter&gt;
        &lt;action
             android:name="android.intent.action.PACKAGE_NEEDS_VERIFICATION" /&gt;
        &lt;action android:name="android.intent.action.PACKAGE_VERIFIED" /&gt;
        &lt;data android:mimeType="application/vnd.android.package-archive" /&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;</pre></div></div><p>In addition, the declaring application needs to be granted the <code class="literal">PACKAGE_VERIFICATION_AGENT</code> permission. As this is a signature permission reserved for system applications (<code class="literal">signature|system</code>), only system applications can become the required verification agent.</p><p>Applications can register sufficient verifiers by adding a <code class="literal">&lt;package-verifier&gt;</code> tag to their manifest and listing the sufficient verifier’s package name and public key in the tag’s attributes, as shown in <a class="xref" href="ch03.html#sufficient_verifier_declaration_in_andro" title="Example 3-29. Sufficient verifier declaration in AndroidManifest.xml">Example 3-29</a>.</p><div class="example"><a id="sufficient_verifier_declaration_in_andro"/><p class="title">Example 3-29. Sufficient verifier declaration in <span class="roman">AndroidManifest.xml</span></p><div class="example-contents"><pre class="programlisting">&lt;manifest 
        package="com.example.app"&gt;
        &lt;package-verifier android:name="com.example.verifier"
                          android:publicKey="MIIB..." /&gt;
    &lt;application ...&gt;
     --<span class="emphasis"><em>snip</em></span>--
    &lt;/application&gt;
&lt;/manifest&gt;</pre></div></div><p>When installing a package, the <code class="literal">PackageManagerService</code> performs verification when a required verifier is installed and the <code class="literal">Settings.Global.PACKAGE_ VERIFIER_ENABLE</code> system setting is set to <code class="literal">true</code>. Verification is enabled by adding the APK to a queue of pending installs and sending the <code class="literal">ACTION_PACKAGE_NEEDS_ VERIFICATION</code> broadcast to registered verifiers.</p><p><a id="iddle1968" class="indexterm"/><a id="iddle2395" class="indexterm"/><a id="iddle2400" class="indexterm"/><a id="iddle2414" class="indexterm"/><a id="iddle2415" class="indexterm"/><a id="iddle3067" class="indexterm"/>The broadcasts contains a unique verification ID, and various metadata about the package being verified. Verification agents respond by calling the <code class="literal">verifyPendingInstall()</code> method and passing the verification ID and a verification status. Calling the method requires the <code class="literal">PACKAGE_VERIFICATION_AGENT</code> permission, which guarantees that non-system apps cannot participate in package verification. Each time the <code class="literal">verifyPendingInstall()</code> is called, the <code class="literal">PackageManagerService</code> checks to see whether sufficient verification for the pending install has been received. If so, it removes the pending install from the queue, sends the <code class="literal">PACKAGE_VERIFIED</code> broadcast, and starts the package installation process. If the package is rejected by verification agents, or sufficient verification is not received within the allotted time, installation fails with the <code class="literal">INSTALL_FAILED_VERIFICATION_FAILURE</code> error.</p></div><div class="sect2" title="Google Play Implementation"><div class="titlepage"><div><div><h2 class="title"><a id="google_play_implementation"/>Google Play Implementation</h2></div></div></div><p>Google’s application verification implementation is built into the Google Play Store client. The Google Play Store app registers itself as a required verification agent and if the Verify apps option is turned on, it receives a broadcast each time an application is about to be installed, whether through the Google Play Store client itself, the <code class="literal">PackgeInstaller</code> application, or via <code class="literal">adb install</code>.</p><p>The implementation is not open source, and few details are publicly available, but Google’s “Protect against harmful apps” Android help page states, “When you verify applications, Google receives log information, URLs related to the app, and general information about the device, such as the Device ID, version of the operating system, and IP address.”<sup>[<a id="ch03fn12" href="#ftn.ch03fn12" class="footnote">28</a>]</sup> We can observe that, as of this writing, in addition to this information, the Play Store client sends the APK file’s SHA-256 hash value, file size, the app package name, the names of its resources along with their SHA-256 hashes, the SHA-256 hashes of the app’s manifest and classes files, its version code and signing certificates, as well as some metadata about the installing application and referrer URLs, if available. Based on that information, Google’s APK analysis algorithms determine whether the APK is potentially harmful and return a result to the Play Store client that includes a status code and an error message to display in case the APK is deemed potentially harmful. In turn, the Play Store client calls the <code class="literal">verifyPendingInstall()</code> method of the <code class="literal">PackageManagerService</code> with the appropriate status code. Application install is accepted or rejected based on the algorithm described in the previous section.</p><p>In practice (at least on “Google experience” devices), the Google Play Store verifier is usually the sole verification agent, so whether the package is installed or rejected depends only on the response of Google’s online verification service.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00007"/>Summary</h1></div></div></div><p>Android application packages (APK files) are an extension of the JAR file format and contain resources, code, and a manifest file. APK files are signed using the JAR file code signing format, but require that all files are signed with the same set of certificates. Android uses the code signer certificate to establish the same origin of apps and their updates and to establish trust relationships between apps. APK files are installed by copying them to the <span class="emphasis"><em>/data/app/</em></span> directory and creating a dedicated data directory for each application under <span class="emphasis"><em>/data/data/</em></span>.</p><p>Android supports encrypted APK files and secure app containers for forward locked apps. Encrypted apps are automatically decrypted before being copied to the application directory. Forward locked apps are split into a resource and manifest part, which is publicly accessible, and a private code and asset part, which is stored in a dedicated encrypted container, directly accessible only by the OS.</p><p>Android can optionally verify apps before installing them by consulting one or more verification agents. Currently, the most widely used verification agent is built into the Google Play Store client applications and uses Google’s online app verification service in order to detect potentially harmful applications.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a id="ftn.ch03fn01" href="#ch03fn01" class="para">17</a>] </sup>Oracle, <span class="emphasis"><em>JAR File Specification</em></span>, <span class="emphasis"><em><a class="ulink" href="http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html">http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch03fn02" href="#ch03fn02" class="para">18</a>] </sup>Microsoft Corporation, <span class="emphasis"><em>Flame malware collision attack explained</em></span>, <span class="emphasis"><em><a class="ulink" href="http://blogs.technet.com/b/srd/archive/2012/06/06/more-information-about-the-digital-certificates-used-to-sign-the-flame-malware.aspx">http://blogs.technet.com/b/srd/archive/2012/06/06/more-information-about-the-digital-certificates-used-to-sign-the-flame-malware.aspx</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch03fn03" href="#ch03fn03" class="para">19</a>] </sup>EMC RSA Laboratories, <span class="emphasis"><em>PKCS #7: Cryptographic Message Syntax Standard</em></span>, <span class="emphasis"><em><a class="ulink" href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-7-cryptographic-message-syntax-standar.htm">http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-7-cryptographic-message-syntax-standar.htm</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch03fn04" href="#ch03fn04" class="para">20</a>] </sup>Housley, <span class="emphasis"><em>RFC 5652 – Cryptographic Message Syntax (CMS)</em></span>, <span class="emphasis"><em><a class="ulink" href="http://tools.ietf.org/html/rfc5652">http://tools.ietf.org/html/rfc5652</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch03fn05" href="#ch03fn05" class="para">21</a>] </sup><span class="emphasis"><em>Abstract Syntax Notation One (ASN.1)</em></span> is a standard notation that describes rules and structures for encoding data in telecommunications and computer networking. It’s used extensively in cryptography standards to define the structure of cryptographic objects.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch03fn06" href="#ch03fn06" class="para">22</a>] </sup>EMC RSA Laboratories, <span class="emphasis"><em>PKCS #8: Private-Key Information Syntax Standard</em></span>, <span class="emphasis"><em><a class="ulink" href="http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-8-private-key-information-syntax-stand.htm">http://www.emc.com/emc-plus/rsa-labs/standards-initiatives/pkcs-8-private-key-information-syntax-stand.htm</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch03fn07" href="#ch03fn07" class="para">23</a>] </sup>For a discussion of Linux capabilities, see Chapter 39 of Michael Kerrisk’s <span class="emphasis"><em>The Linux Programming Interface: A Linux and UNIX System Programming Handbook</em></span>, No Starch Press, 2010.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch03fn08" href="#ch03fn08" class="para">24</a>] </sup>File monitoring is implemented using Linux’s <span class="emphasis"><em>inotify</em></span> facility. For more details about <span class="emphasis"><em>inotify</em></span>, see Chapter 19 of Michael Kerrisk’s <span class="emphasis"><em>The Linux Programming Interface: A Linux and UNIX System Programming Handbook</em></span>, No Starch Press, 2010.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch03fn09" href="#ch03fn09" class="para">25</a>] </sup>See CommonsWare, <span class="emphasis"><em>CWAC-Security</em></span>, <span class="emphasis"><em><a class="ulink" href="https://github.com/commonsguy/cwac-security">https://github.com/commonsguy/cwac-security</a></em></span>, for further discussion and a sample project that shows how to perform the check.</p></div><div class="footnote"><p><sup>[<a id="ftn.ch03fn10" href="#ch03fn10" class="para">26</a>] </sup>Google, <span class="emphasis"><em>Android API Reference,</em></span> “Signature,” <span class="emphasis"><em><a class="ulink" href="https://developer.android.com/reference/android/content/pm/Signature.html">https://developer.android.com/reference/android/content/pm/Signature.html</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch03fn11" href="#ch03fn11" class="para">27</a>] </sup>Google, <span class="emphasis"><em>Android Practical Security from the Ground Up</em></span>, presented at VirusBulletin 2013. Retrieved from <span class="emphasis"><em><a class="ulink" href="https://docs.google.com/presentation/d/1YDYUrD22Xq12nKkhBfwoJBfw2Q-OReMr0BrDfHyfyPw">https://docs.google.com/presentation/d/1YDYUrD22Xq12nKkhBfwoJBfw2Q-OReMr0BrDfHyfyPw</a></em></span></p></div><div class="footnote"><p><sup>[<a id="ftn.ch03fn12" href="#ch03fn12" class="para">28</a>] </sup>Google<span class="emphasis"><em>, Protect against harmful apps</em></span>, <span class="emphasis"><em><a class="ulink" href="https://support.google.com/accounts/answer/2812853">https://support.google.com/accounts/answer/2812853</a></em></span></p></div></div></div></body></html>