<html><head></head><body>
<h2 class="h2" id="ch8"><span epub:type="pagebreak" id="page_145"/><span class="big">8</span><br/>AUTHENTICATED ENCRYPTION</h2>
<div class="image9"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">This chapter is about a type of algorithm that protects not only a message’s confidentiality but also its authenticity. Recall from <a href="ch07.xhtml#ch7">Chapter 7</a> that message authentication codes (MACs) are algorithms that protect a message’s authenticity by creating a tag, which is a kind of signature. Like MACs, the authenticated encryption (AE) algorithms we’ll discuss in this chapter produce an authentication tag, but they also encrypt the message. In other words, a single AE algorithm offers the features of both a normal cipher and a MAC.</p>
<p class="indent">Combining a cipher and a MAC can achieve varying levels of authenticated encryption, as you’ll learn throughout this chapter. I’ll review several possible ways to combine MACs with ciphers, explain which methods are the most secure, and introduce you to ciphers that produce both a ciphertext <span epub:type="pagebreak" id="page_146"/>and an authentication tag. We’ll then look at four important authenticated ciphers: three block cipher–based constructions, with a focus on the popular Advanced Encryption Standard in Galois Counter Mode (AES-GCM), and a cipher that uses only a permutation algorithm.</p>
<h3 class="h3" id="lev1sec52">Authenticated Encryption Using MACs</h3>
<p class="noindent">As shown in <a href="ch08.xhtml#ch8fig1">Figure 8-1</a>, MACs and ciphers can be combined in one of three ways to both encrypt and authenticate a plaintext: encrypt-and-MAC, MAC-then-encrypt, and encrypt-then-MAC.</p>
<div class="image"><img src="../images/f08-01.jpg" alt="image"/></div>
<p class="figcap"><a id="ch8fig1"/><em>Figure 8-1: Cipher and MAC combinations</em></p>
<p class="indentt">The three combinations differ in the order in which encryption is applied and the authentication tag is generated. However, the choice of a specific MAC or cipher algorithm is unimportant as long as each is secure in its own right, and the MAC and cipher use distinct keys.</p>
<p class="indent">As you can see in <a href="ch08.xhtml#ch8fig1">Figure 8-1</a>, in the encrypt-and-MAC composition, the plaintext is encrypted and an authentication tag is generated from the plaintext directly, such that the two operations (encryption and authentication) are independent of each other and can therefore be computed in parallel. In the MAC-then-encrypt scheme, the tag is generated from the plaintext first, and then the plaintext and MAC are encrypted together. In contrast, in the case of the encrypt-then-MAC method, the plaintext is encrypted first, and then the tag is generated from the ciphertext.</p>
<p class="indent">All three approaches are about equally resource intensive. Let’s see which method is likely to be the most secure.</p>
<h4 class="h4" id="lev2sec100"><em>Encrypt-and-MAC</em></h4>
<p class="noindent">The <em>encrypt-and-MAC</em> approach computes a ciphertext and a MAC tag separately. Given a plaintext (<em>P</em>), the sender computes a ciphertext <em>C</em> = <strong>E</strong>(<em>K</em><sub>1</sub>, <em>P</em>), where <strong>E</strong> is an encryption algorithm and <em>C</em> is the resulting ciphertext. The authentication tag (<em>T</em>) is calculated from the plaintext as <em>T</em> = <strong>MAC</strong>(<em>K</em><sub>2</sub>, <em>P</em>). You can compute <em>C</em> and <em>T</em> first or in parallel.</p>
<p class="indent">Once the ciphertext and authentication tag have been generated, the sender transmits both to the intended recipient. When the recipient <span epub:type="pagebreak" id="page_147"/>receives <em>C</em> and <em>T</em>, they decrypt <em>C</em> to obtain the plaintext <em>P</em> by computing <em>P</em> = <strong>D</strong>(<em>K</em><sub>1</sub>, <em>C</em>). Next, they compute <strong>MAC</strong>(<em>K</em><sub>2</sub>, <em>P</em>) using the decrypted plaintext and compare the result to the <em>T</em> received. This verification will fail if either <em>C</em> or <em>T</em> was corrupted, and the message will be deemed invalid.</p>
<p class="indent">At least in theory, encrypt-and-MAC is the least secure MAC and cipher composition because even a secure MAC could leak information on <em>P</em>, which would make <em>P</em> easier to recover. Because the goal of using MACs is simply to make tags unforgeable, and because tags aren’t necessarily random looking, the authentication tag (<em>T</em>) of a plaintext (<em>P</em>) could still leak information even though the MAC is considered secure! (Of course, if the MAC is a pseudorandom function, the tag won’t leak anything on <em>P</em>.)</p>
<p class="indent">Still, despite its relative weakness, encrypt-and-MAC continues to be supported by many systems, including the secure transport layer protocol SSH, wherein each encrypted packet <em>C</em> is followed by the tag <em>T</em> = <strong>MAC</strong>(<em>K</em>, <em>N</em> || <em>P</em>) sent in the unencrypted plaintext packet <em>P</em>. <em>N</em> in this equation is a 32-bit sequence number that is incremented for each sent packet, in order to help ensure that the received packets are processed in the right order. In practice, encrypt-and-MAC has proven good enough for use with SSH, thanks to the use of strong MAC algorithms like HMAC-SHA-256 that don’t leak information on <em>P</em>.</p>
<h4 class="h4" id="lev2sec101"><em>MAC-then-Encrypt</em></h4>
<p class="noindent">The <em>MAC-then-encrypt</em> composition protects a message, <em>P</em>, by first computing the authentication tag <em>T</em> = <strong>MAC</strong>(<em>K</em><sub>2</sub>, <em>P</em>). Next, it creates the ciphertext by encrypting the plaintext and tag together, according to <em>C</em> = <strong>E</strong>(<em>K</em><sub>1</sub>, <em>P</em> || <em>T</em>).</p>
<p class="indent">Once these steps have been completed, the sender transmits only <em>C</em>, which contains both the encrypted plaintext and tag. Upon receipt, the recipient decrypts <em>C</em> by computing <em>P</em> || <em>T</em> = <strong>D</strong>(<em>K</em><sub>1</sub>, <em>C</em>) to obtain the plaintext and tag <em>T</em>. Next, the recipient verifies the received tag <em>T</em> by computing a tag directly from the plaintext according to <strong>MAC</strong>(<em>K</em><sub>2</sub>, <em>P</em>) in order to confirm that the computed tag is equal to the tag <em>T</em>.</p>
<p class="indent">As with encrypt-and-MAC, when MAC-then-encrypt is used, the recipient must decrypt <em>C</em> before they can determine whether they are receiving corrupted packets—a process that exposes potentially corrupted plaintexts to the receiver. Nevertheless, MAC-then-encrypt is more secure than encrypt-and-MAC because it hides the plaintext’s authentication tag, thus preventing the tag from leaking information on the plaintext.</p>
<p class="indent">MAC-then-encrypt has been used in the TLS protocol for years, but TLS 1.3 replaced MAC-then-encrypt with authenticated ciphers (see <a href="ch13.xhtml#ch13">Chapter 13</a> for more on TLS 1.3).</p>
<h4 class="h4" id="lev2sec102"><em>Encrypt-then-MAC</em></h4>
<p class="noindent">The encrypt-then-MAC composition sends two values to the recipient: the ciphertext produced by <em>C</em> = <strong>E</strong>(<em>K</em><sub>1</sub>, <em>P</em>) and a tag based on the ciphertext, <em>T</em> = <strong>MAC</strong>(<em>K</em><sub>2</sub>, <em>C</em>). The receiver computes the tag using <strong>MAC</strong>(<em>K</em><sub>2</sub>, <em>C</em>) and verifies that it equals the <em>T</em> received. If the values are equal, the plaintext is computed as <em>P</em> = <strong>D</strong>(<em>K</em><sub>1</sub>, <em>C</em>); if they are not equal, the plaintext is discarded.</p>
<p class="indent"><span epub:type="pagebreak" id="page_148"/>One advantage with this method is that the receiver only needs to compute a MAC in order to detect corrupt messages, meaning that there is no need to decrypt a corrupt ciphertext. Another advantage is that attackers can’t send pairs of <em>C</em> and <em>T</em> to the receiver to decrypt unless they have broken the MAC, which makes it harder for attackers to transmit malicious data to the recipient.</p>
<p class="indent">This combination of features makes encrypt-then-MAC stronger than the encrypt-and-MAC and MAC-then-encrypt approaches. This is one reason why the widely used IPSec secure communications protocol suite uses it to protect packets (for example, within VPN tunnels).</p>
<p class="indent">But then why don’t SSH and TLS use encrypt-then-MAC? The simple answer is that when SSH and TLS were created, other approaches appeared adequate—not because theoretical weaknesses didn’t exist but because theoretical weaknesses don’t necessarily become actual vulnerabilities.</p>
<h3 class="h3" id="lev1sec53">Authenticated Ciphers</h3>
<p class="noindent"><em>Authenticated ciphers</em> are an alternative to the cipher and MAC combinations. They are like normal ciphers except that they return an authentication tag together with the ciphertext.</p>
<p class="indent">The authenticated cipher encryption is represented as <strong>AE</strong>(<em>K</em>, <em>P</em>) = (<em>C</em>, <em>T</em>). The term <strong>AE</strong> stands for <em>authenticated encryption</em>, which as you can see from this equation is based on a key (<em>K</em>) and a plaintext (<em>P</em>) and returns a ciphertext (<em>C</em>) and a generated authentication tag pair (<em>T</em>). In other words, a single authenticated cipher algorithm does the same job as a cipher and MAC combination, making it simpler, faster, and often more secure.</p>
<p class="indent">Authenticated cipher decryption is represented by <strong>AD</strong>(<em>K</em>, <em>C</em>, <em>T</em>) = <em>P</em>. Here, <strong>AD</strong> stands for <em>authenticated decryption</em>, which returns a plainte (<em>P</em>) given a ciphertext (<em>C</em>), tag (<em>T</em>), and key (<em>K</em>). If either or both <em>C</em> and <em>T</em> are invalid, <strong>AD</strong> will return an error to prevent the recipient from processing a plaintext that may have been forged. By the same token, if <strong>AD</strong> returns a plaintext, you can be sure that it has been encrypted by someone or something that knows the secret key.</p>
<p class="indent">The basic security requirements of an authenticated cipher are simple: its authentication should be as strong as a MAC’s, meaning that it should be impossible to forge a ciphertext and tag pair (<em>C</em>, <em>T</em>) that the decryption function <strong>AD</strong> will accept and decrypt.</p>
<p class="indent">As far as confidentiality is concerned, an authenticated cipher is fundamentally stronger than a basic cipher because systems holding the secret key will only decrypt a ciphertext if the authentication tag is valid. If the tag is invalid, the plaintext will be discarded. This characteristic prevents attackers from performing chosen-ciphertext queries, an attack where they create ciphertexts and ask for the corresponding plaintext.</p>
<h4 class="h4" id="lev2sec103"><span epub:type="pagebreak" id="page_149"/><em>Authenticated Encryption with Associated Data</em></h4>
<p class="noindent">Cryptographers define <em>associated data</em> as any data processed by an authenticated cipher such that the data is authenticated (thanks to the authentication tag) but not encrypted. Indeed, by default, all plaintext data fed to an authenticated cipher is encrypted <em>and</em> authenticated.</p>
<p class="indent">But what if you simply want to authenticate all of a message, including its unencrypted parts, but not encrypt the entire message? That is, you want to authenticate and transmit data in addition to an encrypted message. For example, if a cipher processes a network packet composed of a header followed by a payload, you might choose to encrypt the payload to hide the actual data transmitted, but not encrypt the header since it contains information required to deliver the packet to its final recipient. At the same time, you might still like to authenticate the header’s data to make sure that it is received from the expected sender.</p>
<p class="indent">In order to accomplish these goals, cryptographers have created the notion of authenticated encryption with associated data (AEAD). An AEAD algorithm allows you to attach cleartext data to a ciphertext in such a way that if the cleartext data is corrupted, the authentication tag will not validate and the ciphertext will not be decrypted.</p>
<p class="indent">We can write an AEAD operation as <strong>AEAD</strong>(<em>K</em>, <em>P</em>, <em>A</em>) = (<em>C</em>, <em>A</em>, <em>T</em>). Given a key (<em>K</em>), plaintext (<em>P</em>), and associated data (<em>A</em>), AEAD returns the ciphertext, the unencrypted associated data <em>A</em>, and an authentication tag. AEAD leaves the unencrypted associated data unchanged, and the ciphertext is the encryption of plaintext. The authentication tag depends on both <em>P</em> and <em>A</em>, and will only be verified as valid if neither <em>C</em> nor <em>A</em> has been modified.</p>
<p class="indent">Because the authenticated tag depends on <em>A</em>, decryption with associated data is computed by <strong>ADAD</strong>(<em>K</em>, <em>C</em>, <em>A</em>, <em>T</em>) = (<em>P</em>, <em>A</em>). Decryption requires the key, ciphertext, associated data, and tag in order to compute the plaintext and associated data, and it will fail if either <em>C</em> or <em>A</em> has been corrupted.</p>
<p class="indent">One thing to note when using AEAD is that you can leave <em>A</em> or <em>P</em> empty. If the associated data <em>A</em> is empty, AEAD becomes a normal authenticated cipher; if <em>P</em> is empty, it’s just a MAC.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>As of this writing, AEAD is the current norm for authenticated encryption. Because nearly all authenticated ciphers in use today support associated data, when referring to authenticated ciphers throughout this book, I am referring to AEAD unless stated otherwise. When discussing AEAD operations of encryption and decryption, I’ll refer to them as <strong>AE</strong> and <strong>AD</strong>, respectively.</em></p>
</div>
<h4 class="h4" id="lev2sec104"><em>Avoiding Predictability with Nonces</em></h4>
<p class="noindent">Recall from <a href="ch01.xhtml#ch1">Chapter 1</a> that in order to be secure, encryption schemes must be unpredictable and return different ciphertexts when called repeatedly to encrypt the same plaintext—otherwise, an attacker can determine whether <span epub:type="pagebreak" id="page_150"/>the same plaintext was encrypted twice. In order to be unpredictable, block ciphers and stream ciphers feed the cipher an extra parameter: the initial value (IV) or nonce—a number that can be used only once. Authenticated ciphers use the same trick. Thus, authenticated encryption can be expressed as <strong>AE</strong>(<em>K</em>, <em>P</em>, <em>A</em>, <em>N</em>), where <em>N</em> is a nonce. It’s up to the encryption operation to pick a nonce that has never been used before with the same key.</p>
<p class="indent">As with block and stream ciphers, decryption with an authenticated cipher requires the nonce used for encryption in order to perform correctly. We can thus express decryption as <strong>AD</strong>(<em>K</em>, <em>C</em>, <em>A</em>, <em>T</em>, <em>N</em>) = (<em>P</em>, <em>A</em>), where <em>N</em> is the nonce used to create <em>C</em> and <em>T</em>.</p>
<h4 class="h4" id="lev2sec105"><em>What Makes a Good Authenticated Cipher?</em></h4>
<p class="noindent">Researchers have been struggling since the early 2000s to define what makes a good authenticated cipher, and as I write this, the answer is still elusive. Because of AEAD’s many inputs that play different roles, it’s harder to define a notion of security than it is for basic ciphers that only encrypt a message. Nevertheless, in this section, I’ll summarize the most important criteria to consider when evaluating the security, performance, and functionality of an authenticated cipher.</p>
<h5 class="h5">Security Criteria</h5>
<p class="noindent">The most important criteria used to measure the strength of an authenticated cipher are its ability to protect the confidentiality of data (that is, the secrecy of the plaintext) and the authenticity and integrity of the communication (as with the MAC’s ability to detect corrupted messages). An authenticated cipher must compete in both leagues: its confidentiality must be as strong as that of the strongest cipher, and its authenticity as strong as that of the best MAC. In other words, if you remove the authentication part in an AEAD, you should get a secure cipher, and if you remove the encryption part, you should get a strong MAC.</p>
<p class="indent">Another measure of the strength of an authenticated cipher’s security is based on something a bit more subtle—namely, its fragility when faced with repeated nonces. For example, if a nonce is reused, can an attacker decrypt ciphertexts or learn the difference between plaintexts?</p>
<p class="indent">Researchers call this notion of robustness <em>misuse resistance</em>, and have designed misuse-resistant authenticated ciphers to weigh the impact of a repeated nonce and attempt to determine whether confidentiality, authenticity, or both would be compromised in the face of such an attack, as well as what information about the encrypted data would likely be leaked.</p>
<h5 class="h5">Performance Criteria</h5>
<p class="noindent">As with every cryptographic algorithm, the throughput of an authenticated cipher can be measured in bits processed per second. This speed depends on the number of operations performed by the cipher’s algorithm and on the extra cost of the authentication functionality. As you might imagine, the extra security features of authenticated ciphers come with a performance <span epub:type="pagebreak" id="page_151"/>hit. However, the measure of a cipher’s performance isn’t just about pure speed. It’s also about parallelizability, structure, and whether the cipher is streamable. Let’s examine these notions more closely.</p>
<p class="indent">A cipher’s <em>parallelizability</em> is a measure of its ability to process multiple data blocks simultaneously without waiting for the previous block’s processing to complete. Block cipher–based designs can be easily parallelizable when each block can be processed independently of the other blocks. For example, the CTR block cipher mode discussed in <a href="ch04.xhtml#ch4">Chapter 4</a> is parallelizable, whereas the CBC encryption mode is not, because blocks are chained.</p>
<p class="indent">The internal structure of an authenticated cipher is another important performance criteria. There are two main types of structure: one-layer and two-layer. In a two-layer structure (for example, in the widely used AES-GCM), one algorithm processes the plaintext and then a second algorithm processes the result. Typically, the first layer is the encryption layer and the second is the authentication layer. But as you might expect, a two-layer structure complicates implementation and tends to slow down computations.</p>
<p class="indent">An authenticated cipher is <em>streamable</em> (also called an <em>online</em> cipher) when it can process a message block-by-block and discard any already-processed blocks. In contrast, nonstreamable ciphers must store the entire message, typically because they need to make two consecutive passes over the data: one from the start to the end, and the other from the end to the start of the data obtained from the first pass.</p>
<p class="indent">Due to potentially high memory requirements, some applications won’t work with nonstreamable ciphers. For example, a router could receive an encrypted block of data, decrypt it, and then return the plaintext block before moving on to decrypt the subsequent block of the message, though the recipient of the decrypted message would still have to verify the authentication tag sent at the end of the decrypted data stream.</p>
<h5 class="h5">Functional Criteria</h5>
<p class="noindent">Functional criteria are the features of a cipher or its implementation that don’t directly relate to either security or performance. For example, some authenticated ciphers only allow associated data to precede the data to be encrypted (because they need access to it in order to start encryption). Others require associated data to follow the data to be encrypted or support the inclusion of associated data anywhere—even between chunks of plaintext. This last case is the best, because it enables users to protect their data in any possible situation, but it’s also the hardest to design securely: as always, more features often bring more complexity—and more potential vulnerabilities.</p>
<p class="indent">Another piece of functional criteria to consider relates to whether you can use the same core algorithm for both encryption and decryption. For example, many authenticated ciphers are based on the AES block cipher, which specifies the use of two similar algorithms for encrypting and decrypting a block. As discussed in <a href="ch04.xhtml#ch4">Chapter 4</a>, the CBC block cipher mode requires both algorithms, but the CTR mode requires only the <span epub:type="pagebreak" id="page_152"/>encryption algorithm. Likewise, authenticated ciphers may not need both algorithms. Although the extra cost of implementing both encryption and decryption algorithms won’t impact most software, it’s often noticeable on low-cost dedicated hardware, where implementation cost is measured in terms of logic gates, or the silicon area occupied by the cryptography.</p>
<h3 class="h3" id="lev1sec54">AES-GCM: The Authenticated Cipher Standard</h3>
<p class="noindent">AES-GCM is the most widely used authenticated cipher. AES-GCM is, of course, based on the AES algorithm, and the Galois counter mode (GCM) of operation is essentially a tweak of the CTR mode that incorporates a small and efficient component to compute an authentication tag. As I write this, AES-GCM is the only authenticated cipher that is a NIST standard (SP 800-38D). AES-GCM is also part of NSA’s Suite B and of the Internet Engineering Task Force (IETF) for the secure network protocols IPSec, SSH, and TLS 1.2.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Although GCM works with any block cipher, you’ll probably only see it used with AES. Some people don’t want to use AES because it’s American, but they won’t use GCM either, for the same reason. Therefore, GCM is rarely paired with other ciphers.</em></p>
</div>
<h4 class="h4" id="lev2sec106"><em>GCM Internals: CTR and GHASH</em></h4>
<div class="image"><img src="../images/f08-02.jpg" alt="image"/></div>
<p class="figcap"><a id="ch8fig2"/><em>Figure 8-2: The AES-GCM mode, applied to one associated data block,</em> A<sub>1</sub>, <em>and two plaintext blocks</em>, P<sub>1</sub> <em>and</em> P<sub>2</sub>. <em>The circled multiplication sign represents polynomial multiplication by</em> H, <em>the authentication key derived from</em> K.</p>
<p class="noindent"><a href="ch08.xhtml#ch8fig2">Figure 8-2</a> shows how AES-GCM works: AES instances parameterized by a secret key (<em>K</em>) transform a block composed of the nonce (<em>N</em>) concatenated with a counter (starting here at 1, then incremented to 2, 3, and so on) and then XOR the result with a plaintext block to obtain a ciphertext block. So far, that’s nothing new compared to the CTR mode.</p>
<p class="indent">Next, the ciphertext blocks are mixed using a combination of XORs and multiplications (as you’ll see next). You can see AES-GCM as doing 1) an encryption in CTR mode and 2) a MAC over the ciphertext blocks. Therefore, AES-GCM is essentially an encrypt-then-MAC construction, where AES-CTR encrypts using a 128-bit key (<em>K</em>) and a 96-bit nonce (<em>N</em>), with the minor difference that the counter starts from 1, not 0, as in normal CTR mode (which doesn’t matter, as far as security is concerned).</p>
<p class="indent">To authenticate the ciphertext, GCM uses a Wegman–Carter MAC (see <a href="ch07.xhtml#ch7">Chapter 7</a>) to authenticate the ciphertext, <span epub:type="pagebreak" id="page_153"/>which XORs the value <strong>AES</strong>(<em>K</em>, <em>N</em> || 0) with the output of a universal hash function called <em>GHASH</em>. In <a href="ch08.xhtml#ch8fig2">Figure 8-2</a>, GHASH corresponds to the series of operations “⊗<sub>H</sub>” followed by the XOR with len(<em>A</em>) || len(<em>C</em>), or the bit length of <em>A</em> (the associated data) followed by the bit length of <em>C</em> (the ciphertext).</p>
<p class="indent">We can thus express the authentication tag’s value as <em>T</em> = <strong>GHASH</strong>(<em>H</em>, <em>C</em>) ⊕ <strong>AES</strong>(<em>K</em>, <em>N</em> || 0), where <em>C</em> is the ciphertext and <em>H</em> is the <em>hash key</em>, or <em>authentication key</em>. This key is determined as <em>H</em> = <strong>AES</strong>(<em>K</em>, 0), which is the encryption of the block equal to a sequence of null bytes (this step does not appear in <a href="ch08.xhtml#ch8fig2">Figure 8-2</a>, for clarity).</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In GCM, GHASH doesn’t use</em> K <em>directly in order to ensure that if GHASH’s key is compromised, the master key</em> K <em>remains secret. Given</em> K, <em>you can get</em> H <em>by computing <strong>AES</strong></em>(K, <em>0), but you can’t recover</em> K <em>from that value since</em> K <em>acts here as AES’s key.</em></p>
</div>
<p class="indent">As <a href="ch08.xhtml#ch8fig2">Figure 8-2</a> shows, GHASH uses <em>polynomial notation</em> to multiply each ciphertext block with the authentication key <em>H</em>. This use of polynomial multiplication makes GHASH fast in hardware as well as in software, thanks to a special polynomial multiplication instruction available in many common microprocessors (<span class="literal">CLMUL</span>, for carry-less multiplication).</p>
<p class="indent">Alas, GHASH is far from ideal. For one thing, its speed is suboptimal. Even when the <span class="literal">CLMUL</span> instruction is used, the AES-CTR layer that encrypts the plaintext remains faster than the GHASH MAC. Second, GHASH is painful to implement correctly. In fact, even the experienced developers of the OpenSSL project, by far the most-used cryptographic piece of software in the world, got AES-GCM’s GHASH wrong. One commit had a bug in a function called <span class="literal">gcm_ghash_clmul</span> that allowed attackers to forge valid MACs for the AES-GCM. (Fortunately, the error was spotted by Intel engineers before the bug entered the next OpenSSL release.)</p>
<div class="sidebar">
<p class="sidebart">POLYNOMIAL MULTIPLICATION</p>
<p class="spara">While clearly more complicated for us than classic integer arithmetic, polynomial multiplication is simpler for computers because there are no carries. For example, say we want to compute the product of the polynomials (1 + <em>X</em> + <em>X</em><sup>2</sup>) and (<em>X</em> + <em>X</em><sup>3</sup>). We first multiply the two polynomials (1 + <em>X</em> + <em>X</em><sup>2</sup>) and (<em>X</em> + <em>X</em><sup>3</sup>) as though we were doing normal polynomial multiplication, thus giving us the following (the two terms <em>X</em><sup>3</sup> cancel each other out):</p>
<p class="center">(1 + <em>X</em> + <em>X</em><sup>2</sup>) ⊕ (<em>X</em> + <em>X</em><sup>3</sup>) = <em>X</em> + <em>X</em><sup>3</sup> + <em>X</em><sup>2</sup> + <em>X</em><sup>4</sup> + <em>X</em><sup>3</sup> + <em>X</em><sup>5</sup> = <em>X</em> + <em>X</em><sup>2</sup> + <em>X</em><sup>4</sup> + <em>X</em><sup>5</sup></p>
<p class="spara1">We now apply modulo reduction, reducing <em>X</em> + <em>X</em><sup>2</sup> + <em>X</em><sup>4</sup> + <em>X</em><sup>5</sup> modulo 1 + <em>X</em><sup>3</sup> +<em>X</em><sup>4</sup> to give us <em>X</em><sup>2</sup>, because <em>X</em> + <em>X</em><sup>2</sup> + <em>X</em><sup>4</sup> + <em>X</em><sup>5</sup> can be written as <em>X</em> + <em>X</em><sup>2</sup> + <em>X</em><sup>4</sup> + <em>X</em><sup>5</sup> = <em>X</em> ⊗ (1 + <em>X</em><sup>3</sup> + <em>X</em><sup>4</sup>) + <em>X</em><sup>2</sup>. In more general terms, <em>A</em> + <em>BC</em> modulo <em>B</em> is equal to <em>A</em>, by definition of modular reduction.</p>
</div>
<h4 class="h4" id="lev2sec107"><span epub:type="pagebreak" id="page_154"/><em>GCM Security</em></h4>
<p class="noindent">AES-GCM’s biggest weakness is its fragility in the face of nonce repetition. If the same nonce <em>N</em> is used twice in an AES-GCM implementation, an attacker can get the authentication key <em>H</em> and use it to forge tags for any ciphertext, associated data, or combination thereof.</p>
<p class="indent">A look at the basic algebra behind AES-GCM’s computations (as shown in <a href="ch08.xhtml#ch8fig2">Figure 8-2</a>) will help make this fragility clear. Specifically, a tag (<em>T</em>) is computed as <em>T</em> = <strong>GHASH</strong>(<em>H</em>, <em>A</em>, <em>C</em>) ⊕ <strong>AES</strong>(<em>K</em>, <em>N</em> || 0), where GHASH is a universal hash function with linearly related inputs and outputs.</p>
<p class="indent">Now what happens if you get two tags, <em>T</em><sub>1</sub> and <em>T</em><sub>2</sub>, computed with the same nonce <em>N</em> ? Right, the AES part will vanish. If we have two tags, <em>T</em><sub>1</sub> = <strong>GHASH</strong>(<em>H</em>, <em>A</em><sub>1</sub>, <em>C</em><sub>1</sub>) ⊕ <strong>AES</strong>(<em>K</em>, <em>N</em> || 0) and <em>T</em><sub>2</sub> = <strong>GHASH</strong>(<em>H</em>, <em>A</em><sub>1</sub>, <em>C</em><sub>1</sub>) ⊕ <strong>AES</strong>(<em>K</em>, <em>N</em> || 0), then XORing them together gives the following:</p>
<div class="image1"><img src="../images/f0154-01.jpg" alt="image"/></div>
<p class="indent">If the same nonce is used twice, an attacker can thus recover the value <strong>GHASH</strong>(<em>H</em>, <em>A</em><sub>1</sub>, <em>C</em><sub>1</sub>) ⊕ <strong>GHASH</strong>(<em>H</em>, <em>A</em><sub>2</sub>, <em>C</em><sub>2</sub>) for some known <em>A</em><sub>1</sub>, <em>C</em><sub>1</sub>, <em>A</em><sub>2</sub>, and <em>C</em><sub>2</sub>. The linearity of GHASH then allows an attacker to easily determine <em>H</em>. (It would have been worse if GHASH had used the same key <em>K</em> as the encryption part, but because <em>H</em> = <strong>AES</strong>(<em>K</em>, 0), there’s no way to find <em>K</em> from <em>H</em>.)</p>
<p class="indent">As recently as 2016, researchers scanned the internet for instances of AES-GCM exposed through HTTPS servers, in search of systems with repeating nonces (see <em><a href="https://eprint.iacr.org/2016/475/">https://eprint.iacr.org/2016/475/</a></em>). They found 184 servers with repeating nonces, including 23 that always used the all-zero string as a nonce.</p>
<h4 class="h4" id="lev2sec108"><em>GCM Efficiency</em></h4>
<p class="noindent">One advantage of GCM mode is that both GCM encryption and decryption are parallelizable, allowing you to encrypt or decrypt different plaintext blocks independently. However, the AES-GCM MAC computation isn’t parallelizable, because it must be computed from the beginning to the end of the ciphertext once GHASH has processed any associated data. This lack of parallelizability means that any system that receives the plaintext first and then the associated data will have to wait until all associated data is read and hashed before hashing the first ciphertext block.</p>
<p class="indent">Nevertheless, GCM is streamable: since the computations in its two layers can be pipelined, there’s no need to store all ciphertext blocks before computing GHASH because GHASH will process each block as it’s encrypted. In other words, <em>P</em><sub>1</sub> is encrypted to <em>C</em><sub>1</sub>, then GHASH processes <em>C</em><sub>1</sub> while <em>P</em><sub>2</sub> is encrypted to <em>C</em><sub>2</sub>, then <em>P</em><sub>1</sub> and <em>C</em><sub>1</sub> are no longer needed, and so on.</p>
<h3 class="h3" id="lev1sec55"><span epub:type="pagebreak" id="page_155"/>OCB: An Authenticated Cipher Faster than GCM</h3>
<p class="noindent">The acronym <em>OCB</em> stands for <em>offset codebook</em> (though its designer, Phil Rogaway, prefers to simply call it OCB). First developed in 2001, OCB predates GCM, and like GCM it produces an authenticated cipher from a block cipher, though it does so faster and more simply. Then why hasn’t OCB seen wider adoption? Unfortunately, until 2013, all uses of OCB required a license from the inventor. Fortunately, as I write this, Rogaway grants free licenses for nonmilitary software implementations (see <em><a href="http://web.cs.ucdavis.edu/~rogaway/ocb/license.htm">http://web.cs.ucdavis.edu/~rogaway/ocb/license.htm</a></em>). Therefore, although OCB is not yet a formal standard, perhaps we will begin to see wider adoption.</p>
<p class="indent">Unlike GCM, OCB blends encryption and authentication into one processing layer that uses only one key. There’s no separate authentication component, so OCB gets you authentication mostly for free and performs almost as many block cipher calls as a non-authenticated cipher. Actually, OCB is almost as simple as the ECB mode (see <a href="ch04.xhtml#ch4">Chapter 4</a>), except that it’s secure.</p>
<h4 class="h4" id="lev2sec109"><em>OCB Internals</em></h4>
<p class="noindent"><a href="ch08.xhtml#ch8fig3">Figure 8-3</a> shows how OCB works: OCB encrypts each plaintext block <em>P</em> to a ciphertext block <em>C</em> = <strong>E</strong>(<em>K</em>, <em>P</em> ⊕ <em>O</em>) ⊕ <em>O</em>, where <strong>E</strong> is a block cipher encryption function. Here, <em>O</em> (called the <em>offset</em>) is a value that depends on the key and the nonce incremented for each new block processed.</p>
<p class="indent">To produce the authentication tag, OCB first XORs the plaintext blocks together to compute <em>S</em> = <em>P</em><sub>1</sub> ⊕ <em>P</em><sub>2</sub> ⊕ <em>P</em><sub>3</sub> ⊕ … (that is, the XOR of all plaintext blocks). The authentication tag is then <em>T</em> = <strong>E</strong>(<em>K</em>, <em>S</em> ⊕ <em>O</em><sup>*</sup>), where <em>O</em><sup>*</sup> is an offset value computed from the offset of the last plaintext block processed.</p>
<div class="image"><img src="../images/f08-03.jpg" alt="image"/></div>
<p class="figcap"><a id="ch8fig3"/><em>Figure 8-3: The OCB encryption process when run on two plaintext blocks, with no associated data</em></p>
<p class="indentt">Like AES-GCM, OCB also supports associated data as a series of blocks, <em>A</em><sub>1</sub>, <em>A</em><sub>2</sub>, and so on. When an OCB encrypted message contains associated data, the authentication tag is calculated according to the formula</p>
<p class="center"><em>T</em> = <strong>E</strong>(<em>K</em>, <em>S</em> ⊕ <em>O</em><sup>*</sup>) ⊕ <strong>E</strong>(<em>K</em>, <em>A</em><sub>1</sub> ⊕ <em>O</em><sub>1</sub>) ⊕ <strong>E</strong>(<em>K</em>, <em>A</em><sub>2</sub> ⊕ <em>O</em><sub>2</sub>) ⊕ …</p>
<p class="noindentt">where OCB specifies offset values that are different from those used to encrypt <em>P</em>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_156"/>Unlike GCM and encrypt-then-MAC, which create an authentication tag by combining ciphertext, OCB calculates the authentication tag by combining plaintext data. There’s nothing wrong with this approach, and OCB is backed by solid security proofs.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>For more on how to implement OCB correctly, see either RFC 7253 or the 2011 paper “The Software Performance of Authenticated-Encryption Modes” by Krovetz and Rogaway, which covers the latest and best version of OCB, OCB3. For further details on OCB, see the OCB FAQ at</em> <a href="http://web.cs.ucdavis.edu/~rogaway/ocb/ocb-faq.htm">http://web.cs.ucdavis.edu/~rogaway/ocb/ocb-faq.htm</a>.</p>
</div>
<h4 class="h4" id="lev2sec110"><em>OCB Security</em></h4>
<p class="noindent">OCB is a bit less fragile than GCM against repeated nonces. For example, if a nonce is used twice, an attacker that sees the two ciphertexts will notice that, say, the third plaintext block of the first message is identical to the third plaintext block of the second message. With GCM, attackers can find not only duplicates but also XOR differences between blocks at the same position. The impact of repeated nonces is therefore worse with GCM than it is with OCB.</p>
<p class="indent">As with GCM, repeated nonces can break the authenticity of OCB, though less effectively. For example, an attacker could combine blocks from two messages authenticated with OCB to create another encrypted message with the same checksum and tag as one of the original two messages, but the attacker would not be able to recover a secret key as with GCM.</p>
<h4 class="h4" id="lev2sec111"><em>OCB Efficiency</em></h4>
<p class="noindent">OCB and GCM are about equally fast. Like GCM, OCB is parallelizable and streamable. In terms of raw efficiency, GCM and OCB will make about as many calls to the underlying block cipher (usually AES), but OCB is slightly more efficient than GCM because it simply XORs the plaintext rather than performing something like the relatively expensive GHASH computation. (In earlier generations of Intel microprocessors, AES-GCM used to be more than three times slower than AES-OCB because AES and GHASH instructions had to compete for CPU resources and couldn’t be run in parallel.)</p>
<p class="indent">One important difference between OCB and GCM implementations is that OCB needs both the block cipher’s encryption and decryption functions in order to encrypt and decrypt, which increases the cost of hardware implementations when only limited silicon is available for crypto components. In contrast, GCM uses only the encryption function for both encryption and decryption.</p>
<h3 class="h3" id="lev1sec56">SIV: The Safest Authenticated Cipher?</h3>
<p class="noindent"><em>Synthetic IV</em>, also known as <em>SIV</em>, is an authenticated cipher mode typically used with AES. Unlike GCM and OCB, SIV is secure even if you use the same nonce twice: if an attacker gets two ciphertexts encrypted using the same <span epub:type="pagebreak" id="page_157"/>nonce, they’ll only be able to learn whether the same plaintext was encrypted twice. Unlike with messages encrypted with GCM or OCB, the attacker would be unable to tell whether the first block of the two messages is the same because the nonce used to encrypt is first computed as a combination of the given nonce and the plaintext.</p>
<p class="indent">The SIV construction specification is more general than that of GCM. Instead of specifying detailed internals as with GCM’s GHASH, SIV simply tells you how to combine a cipher (<strong>E</strong>) and a pseudorandom function (<strong>PRF</strong>) to get an authenticated cipher. Specifically, you compute the tag <em>T</em> = <strong>PRF</strong>(<em>K</em><sub>1</sub>, <em>N</em> || <em>P</em>) and then compute the ciphertext <em>C</em> = <strong>E</strong>(<em>K</em><sub>2</sub>, <em>T</em>, <em>P</em>), where <em>T</em> acts as the nonce of <strong>E</strong>. Thus, SIV needs two keys (<em>K</em><sub>1</sub> and <em>K</em><sub>2</sub>) and a nonce (<em>N</em>).</p>
<p class="indent">The major problem with SIV is that it’s not streamable: after computing <em>T</em>, it must keep the entire plaintext <em>P</em> in memory. In other words, in order to encrypt a 100GB plaintext with SIV, you must first store the 100GB of plaintext so that SIV encryption can read it.</p>
<p class="indent">The document RFC 5297, based on the 2006 paper “Deterministic Authenticated-Encryption” by Rogaway and Shrimpton, specifies SIV as using CMAC-AES (a MAC construction using AES) as a PRF and AES-CTR as a cipher. In 2015, a more efficient version of SIV was proposed, called GCM-SIV, that combines GCM’s fast GHASH function and SIV’s mode and is nearly as fast as GCM. Like the original SIV, however, GCM-SIV isn’t streamable. (For more information, see <em><a href="https://eprint.iacr.org/2015/102/">https://eprint.iacr.org/2015/102/</a></em>.)</p>
<h3 class="h3" id="lev1sec57">Permutation-Based AEAD</h3>
<p class="noindent">Now for a totally different approach to building an authenticated cipher: instead of building a mode of operation around a block cipher like AES, we’ll look at a cipher that builds a mode around a permutation. A permutation simply transforms an input to an output of the same size, reversibly, without using a key, that’s the simplest component imaginable. Better still, the resulting AEAD is fast, provably secure, and more resistant to nonce reuse than GCM and OCB.</p>
<p class="indent"><a href="ch08.xhtml#ch8fig4">Figure 8-4</a> shows how a permutation-based AEAD works: from some fixed initial state <em>H</em><sub>0</sub>, you XOR the key <em>K</em> followed by the nonce <em>N</em> to the internal state, to obtain a new value of the internal state that is the same size as the original. You then transform the new state with <strong>P</strong> and get another new value of the state. Now you XOR the first plaintext block <em>P</em><sub>1</sub> to the current state and take the resulting value as the first ciphertext block <em>C</em><sub>1</sub>, where <em>P</em><sub>1</sub> and <em>C</em><sub>1</sub> are equal in size but smaller than the state.</p>
<p class="indent">To encrypt a second block, you transform the state with <strong>P</strong>, XOR the next plaintext block <em>P</em><sub>2</sub> to the current state, and take the resulting value as <em>C</em><sub>2</sub>. You then iterate over all plaintext blocks and, following the last call to <strong>P</strong>, take bits from the internal state as the authentication tag <em>T</em>, as shown at the right of <a href="ch08.xhtml#ch8fig4">Figure 8-4</a>.</p>
<div class="image"><img src="../images/f08-04.jpg" alt="image"/></div>
<p class="figcap"><span epub:type="pagebreak" id="page_158"/><a id="ch8fig4"/><em>Figure 8-4: Permutation-based authenticated cipher</em></p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The mode shown in <a href="ch08.xhtml#ch8fig4">Figure 8-4</a> can be adapted to support associated data, but the process is a bit more complicated, so we’ll skip its description.</em></p>
</div>
<p class="indent">Designing permutation-based authenticated ciphers has certain requirements in order to ensure security. For one thing, note that you only XOR input values to a part of the state: the larger this part, the more control a successful attacker has on the internal state, and thus the lower the cipher’s security. Indeed, all security relies on the secrecy of the internal state.</p>
<p class="indent">Also, blocks must be padded properly with extra bits, in a way that ensures that any two different messages will yield different results. As a counterexample, if the last plaintext block is shorter than a complete block, it should not just be padded with zeroes; otherwise, a plaintext block of, say, two bytes (0000) would result in a complete plaintext block (0000 … 0000), as would a block of three bytes (000000). As a result, you’d get the same tag for both messages, although they differ in size.</p>
<p class="indent">What if a nonce is reused in such a permutation-based cipher? The good news is that the impact isn’t as bad as with GCM or OCB—the strength of the authentication tag won’t be compromised. If a nonce is repeated, a successful attacker would only be able to learn whether the two encrypted messages begin with the same value, as well as the length of this common value, or prefix. For example, although encrypting the two six-block messages <em>ABCXYZ</em> and <em>ABCDYZ</em> (each letter symbolizing a block here) with the same nonce might yield the two ciphertexts <em>JKLTUV</em> and <em>JKLMNO</em>, which have identical prefixes, attackers would not be able to learn that the two plaintexts shared the same final two blocks (<em>YZ</em>).</p>
<p class="indent">In terms of performance, permutation-based ciphers offer the benefits of a single layer of operations, streamable processing, and the use of a single core algorithm for encryption and decryption. However, they are not parallelizable like GCM or OCB because new calls to <strong>P</strong> need to wait for the previous call to complete.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>If you’re tempted to pick your favorite permutation and make up your own authenticated cipher, don’t. You’re likely to get the details wrong and end up with an insecure cipher. Read the specifications written by experienced cryptographers for algorithms such as Keyak (an algorithm derived from Keccak) and NORX (designed by Philipp Jovanovic, Samuel Neves, and myself), and you’ll see that permutation-based ciphers are way more complex than they may first appear.</em></p>
</div>
<h3 class="h3" id="lev1sec58"><span epub:type="pagebreak" id="page_159"/>How Things Can Go Wrong</h3>
<p class="noindent">Authenticated ciphers have a larger attack surface than hash functions or block ciphers because they aim to achieve both confidentiality <em>and</em> authenticity. They take several different input values, and must remain secure regardless of the input—whether that contains only associated data and no encrypted data, extremely large plaintexts, or different key sizes. They must also be secure for all nonce values against attackers who collect numerous message/tag pairs and, to some extent, against accidental repetition of nonces.</p>
<p class="indent">That’s a lot to ask, and as you’ll see next, even AES-GCM has several imperfections.</p>
<h4 class="h4" id="lev2sec112"><em>AES-GCM and Weak Hash Keys</em></h4>
<p class="noindent">One of AES-GCM’s weaknesses is found in its authentication algorithm GHASH: certain values of the hash key <em>H</em> greatly simplify attacks against GCM’s authentication mechanism. Specifically, if the value <em>H</em> belongs to some specific, mathematically defined subgroups of all 128-bit strings, attackers might be able to guess a valid authentication tag for some message simply by shuffling the blocks of a previous message.</p>
<p class="indent">In order to understand this weakness, let’s look at how GHASH works.</p>
<h5 class="h5">GHASH Internals</h5>
<p class="noindent">As you saw in <a href="ch08.xhtml#ch8fig2">Figure 8-2</a>, GHASH starts with a 128-bit value, <em>H</em>, initially set to <strong>AES</strong>(<em>K</em>, 0), and then repeatedly computes</p>
<p class="center"><em>X<sub>i</sub></em> = (<em>X</em><sub><em>i</em> − 1</sub> ⊕ <em>C<sub>i</sub></em>) ⊗ <em>H</em></p>
<p class="noindentt">starting from <em>X</em><sub>0</sub> = 0 and processing ciphertext blocks <em>C</em><sub>1</sub>, <em>C</em><sub>2</sub>, and so on. The final <em>X</em><sub><em>i</em></sub> is returned by GHASH to compute the final tag.</p>
<p class="indent">Now say for the sake of simplicity that all <em>C</em><sub><em>i</em></sub> values are equal to 1, so that for any <em>i</em> we have this:</p>
<p class="center"><em>C<sub>i</sub></em> ⊗ = 1 ⊗ <em>H</em> = <em>H</em></p>
<p class="indent1">Next, from the GHASH equation</p>
<p class="center"><em>X<sub>i</sub></em> = (<em>X</em><sub>i − 1</sub> ⊕ <em>C<sub>i</sub></em>) ⊗ <em>H</em></p>
<p class="noindentt">we derive</p>
<p class="center"><em>X</em><sub>1</sub> = (<em>X</em><sub>0</sub> ⊕ <em>C</em><sub>1</sub>) ⊕ <em>H</em> = (0 ⊕ 1) ⊗ <em>H</em> = <em>H</em></p>
<p class="noindent1">substituting <em>X</em><sub>0</sub> with 0 and <em>C</em><sub>1</sub> with 1, to yield the following:</p>
<p class="center">(0 ⊕ 1) = 1</p>
<p class="indent1"><span epub:type="pagebreak" id="page_160"/>Thanks to the distributive property of ⊗ over ⊕, we substitute <em>X</em> with <em>H</em> and <em>C</em><sub>2</sub> with 1 and then compute the next value <em>X</em><sub>2</sub> as</p>
<p class="center"><em>X</em><sub>2</sub>= (<em>X</em><sub>1</sub> ⊕ <em>X</em><sub>2</sub>) ⊗ <em>H</em> = (<em>H</em> ⊕ 1) ⊗ <em>H</em> = <em>H</em><sup>2</sup> ⊕ <em>H</em></p>
<p class="noindentt">where <em>H</em><sup>2</sup> is <em>H</em> squared, or <em>H</em> ⊗ <em>H</em>.</p>
<p class="indent">Now we derive <em>X</em><sub>3</sub> by substituting <em>X</em><sub>2</sub> for its derivation, and obtain the following:</p>
<p class="center"><em>X</em><sub>3</sub> = (<em>X</em><sub>2</sub> ⊕ <em>C</em><sub>3</sub>) ⊗ <em>H</em> = (<em>H</em><sup>2</sup> ⊕ <em>H</em> ⊕ 1) ⊗ <em>H</em> = <em>H</em><sup>3</sup> ⊕ <em>H</em><sup>2</sup> ⊕ <em>H</em></p>
<p class="indent1">Next, we derive <em>X</em><sub>4</sub> to be <em>X</em><sub>4</sub> = <em>H</em> <sup>4</sup> ⊕ <em>H</em> <sup>3</sup> ⊕ <em>H</em> <sup>2</sup> ⊕ <em>H</em>, and so on, and eventually the last <em>X</em><sub><em>i</em></sub> is this:</p>
<p class="center"><em>X<sub>n</sub></em> = <em>H<sup>n</sup></em> ⊕ <em>H</em><sup><em>n</em> − 1</sup> ⊕ <em>H</em><sup><em>n</em> − 2</sup> ⊕ … ⊕ <em>H</em><sup>2</sup> ⊕ <em>H</em></p>
<p class="indent1">Remember that we set all blocks <em>C</em><sub><em>i</em></sub> equal to 1. If instead those values were arbitrary values, we would end up with the following:</p>
<p class="center"><em>X<sub>n</sub></em> = <em>C</em><sub>1</sub> ⊕ <em>H<sup>n</sup></em> ⊕ <em>C</em><sub>2</sub> ⊕ <em>H</em><sup><em>n</em> − 1</sup> ⊕ <em>C</em><sub>3</sub> <em>H</em><sup><em>n</em> − 2</sup> ⊕ … ⊕ <em>C</em><sub><em>n</em> − 1</sub> <em>H</em><sup>2</sup> ⊕ <em>C</em><sub><em>n</em></sub> ⊕ <em>H</em></p>
<p class="indentt">GHASH then would XOR the message’s length to this last <em>X</em><sub><em>n</em></sub>, multiply the result by <em>H</em>, and then XOR this value with <strong>AES</strong>(<em>K</em>, <em>N</em> || 0) to create the final authentication tag, <em>T</em>.</p>
<h5 class="h5">Where Things Break</h5>
<p class="noindent">What can go wrong from here? Let’s look first at the two simplest cases:</p>
<ul>
<li class="noindent">If <em>H</em> = 0, then <em>X</em><sub><em>n</em></sub> = 0 regardless of the <em>C</em><sub><em>i</em></sub> values, and thus regardless of the message. That is, all messages will have the same authentication tag if <em>H</em> is 0.</li>
<li class="noindent">If <em>H</em> = 1, then the tag is just an XOR of the ciphertext blocks, and reordering the ciphertext blocks will give the same authentication tag.</li>
</ul>
<p class="indentt">Of course, 0 and 1 are only two values of 2<sup>128</sup> possible values of <em>H</em>, so there is only a 2/2<sup>128</sup> = 1/2<sup>127</sup> chance of these occurring. But there are other weak values as well—namely, all values of <em>H</em> that belong to a <em>short cycle</em> when raised to <em>i</em>th powers. For example, the value <em>H</em> = 10d04d25f93556e69f58ce2f8d035a4 belongs to a cycle of length five, as it satisfies <em>H</em> <sup>5</sup> = <em>H</em>, and therefore <em>H</em><sup><em>e</em></sup> = <em>H</em> for any <em>e</em> that is a multiple of five (the very definition of cycle with respect to fifth powers). Consequently, in the preceding expression of the final GHASH value <em>X</em><sub><em>n</em></sub>, swapping the blocks <em>C</em><sub><em>n</em></sub> (multiplied to <em>H</em>) and the block <em>C</em><sub><em>n</em> – 4</sub> (multiplied to <em>H</em> <sup>5</sup>) will leave the authentication tag unchanged, which amounts to a forgery. An attacker may exploit this property to construct a new message and its valid tag without knowing the key, which should be impossible for a secure authenticated cipher.</p>
<p class="indent">The preceding example is based on a cycle of length five, but there are many cycles of greater length and therefore many values of <em>H</em> that are <span epub:type="pagebreak" id="page_161"/>weaker than they should be. The upshot is that, in the unlikely case that <em>H</em> belongs to a short cycle of values and attackers can forge as many authentication tags as they want, unless they know <em>H</em> or <em>K</em>, they cannot determine <em>H</em>’s cycle length. So although this vulnerability can’t be exploited, it could have been avoided by more carefully choosing the polynomial used for modulo reductions.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>For further details on this attack, read “Cycling Attacks on GCM, GHASH and Other Polynomial MACs and Hashes” by Markku-Juhani O. Saarinen, available at</em> <a href="https://eprint.iacr.org/2011/202/">https://eprint.iacr.org/2011/202/</a>.</p>
</div>
<h4 class="h4" id="lev2sec113"><em>AES-GCM and Small Tags</em></h4>
<p class="noindent">In practice, AES-GCM usually returns 128-bit tags, but it can produce tags of any length. Unfortunately, when shorter tags are used, the probability of forgery increases significantly.</p>
<p class="indent">When a 128-bit tag is used, an attacker who attempts a forgery should succeed with a probability of 1/2<sup>128</sup> because there are 2<sup>128</sup> possible 128-bit tags. (Generally, with an <em>n</em>-bit tag, the probability of success should be 1/2<sup><em>n</em></sup>, where 2<sup><em>n</em></sup> is the number of possible values of an <em>n</em>-bit tag.) But when shorter tags are used, the probability of forgery is much higher than 1/2<sup><em>n</em></sup> due to weaknesses in the structure of GCM that are beyond the scope of this discussion. For example, a 32-bit tag will allow an attacker who knows the authentication tag of some 2MB message to succeed with a chance of 1/2<sup>16</sup> instead of 1/2<sup>32</sup>.</p>
<p class="indent">Generally, with <em>n</em>-bit tags, the probability of forgery isn’t 1/2<sup><em>n</em></sup> but rather 2<sup><em>m</em></sup>/2<sup><em>n</em></sup>, where 2<sup><em>m</em></sup> is the number of blocks of the longest message for which a successful attacker observed the tag. For example, if you use 48-bit tags and process messages of 4GB (or 2<sup>28</sup> blocks of 16 bytes each), the probability of a forgery will be 2<sup>28</sup>/2<sup>48</sup> = 1/2<sup>20</sup>, or about one chance in a million. That’s a relatively high chance as far as cryptography is concerned. (For more information on this attack, see the 2005 paper “Authentication Weaknesses in GCM” by Niels Ferguson.)</p>
<h3 class="h3" id="lev1sec59">Further Reading</h3>
<p class="noindent">To learn more about authenticated ciphers, visit the home page of CAESAR, the Competition for Authenticated Encryption: Security, Applicability, and Robustness (<em><a href="http://competitions.cr.yp.to/caesar.html">http://competitions.cr.yp.to/caesar.html</a></em>). Begun in 2012, CAESAR is a crypto competition in the style of the AES and SHA-3 competitions, though it isn’t organized by NIST.</p>
<p class="indent">The CAESAR competition has attracted an impressive number of innovative designs: from OCB-like modes to permutation-based modes, as well as new core algorithms. Examples include the previously mentioned NORX and Keyak permutation-based authenticated ciphers; AEZ (as in AEasy), <span epub:type="pagebreak" id="page_162"/>which is built on a nonstreamable two-layer mode that makes it misuse resistant; AEGIS, a beautifully simple authenticated cipher that leverages AES’s round function.</p>
<p class="indent">In this chapter, I’ve focused on GCM, but a handful of other modes are used in real applications as well. Specifically, the counter with CBC-MAC (CCM) and EAX modes competed with GCM for standardization in the early 2000s, and although GCM was selected, the two competitors are used in a few applications. For example, CCM is used in the WPA2 Wi-Fi encryption protocol. You may want to read these ciphers’ specifications and review their relative security and performance merits.</p>
<p class="indent">This concludes our discussion of symmetric-key cryptography! You’ve seen block ciphers, stream ciphers, (keyed) hash functions, and now authenticated ciphers—or all the main cryptography components that work with a symmetric key, or no key at all. Before we move to <em>asymmetric</em> cryptography, <a href="ch09.xhtml#ch9">Chapter 9</a> will focus more on computer science and math, to provide background for asymmetric schemes such as RSA (<a href="ch10.xhtml#ch10">Chapter 10</a>) and Diffie–Hellman (<a href="ch11.xhtml#ch11">Chapter 11</a>).</p>
</body></html>