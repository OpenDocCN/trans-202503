<html><head></head><body>
<h2 class="h2c" id="ch03"><span epub:type="pagebreak" id="page_49"/><span class="big1"><strong>3</strong></span><br/><strong>RECONNAISSANCE WITH PROCESS MONITOR AND PROCESS EXPLORER</strong></h2>&#13;
<div class="image"><img src="../images/common.jpg" alt="image"/></div>&#13;
<p class="noindent">Cheat Engine and OllyDbg can help you tear apart a game’s memory and code, but you also need to understand how the game interacts with files, registry values, network connections, and other processes. To learn how those interactions work, you must use two tools that excel at monitoring the external actions of processes: Process Monitor and Process Explorer. With these tools, you can track down the complete game map, locate save files, identify registry keys used to store settings, and enumerate the Internet Protocol (IP) addresses of remote game servers.</p>&#13;
<p class="indent">In this chapter, I’ll teach you how to use both Process Monitor and Process Explorer to log system events and inspect them to see how a game was involved. Useful mainly for initial reconnaissance, these tools are <span epub:type="pagebreak" id="page_50"/>amazing at giving a clear, verbose picture of exactly how a game interacts with your system. You can download both programs from the Windows Sysinternals website (<em><a href="https://technet.microsoft.com/en-us/sysinternals/">https://technet.microsoft.com/en-us/sysinternals/</a></em>).</p>&#13;
<h3 class="h3" id="ch00lev1sec58"><strong>Process Monitor</strong></h3>&#13;
<p class="noindent">You can learn a lot about a game simply by exploring how it interacts with the registry, filesystem, and network. Process Monitor is a powerful system-monitoring tool that logs such events in real time and lets you seamlessly integrate the data into a debugging session. This tool provides extensive amounts of useful data regarding a game’s interaction with the external environment. With calculated review (and sometimes, spontaneous intuition) on your part, this data can reveal details about data files, network connections, and registry events that are helpful to your ability to see and manipulate how the game functions.</p>&#13;
<p class="indent">In this section, I’ll show you how to use Process Monitor to log data, navigate it, and make educated guesses about the files a game interacts with. After this interface tour, you’ll have a chance to try out Process Monitor for yourself in “<a href="ch03.xhtml#ch03sb01">Finding a High Score File</a>” on <a href="ch03.xhtml#page_55">page 55</a>.</p>&#13;
<h4 class="h4" id="ch00lev1sec59"><strong><em>Logging In-Game Events</em></strong></h4>&#13;
<p class="noindent">Process Monitor’s logs can hold all sorts of potentially useful information, but their most practical use is to help you figure out where data files, such as in-game item definitions, might be stored. When you start Process Monitor, the first dialog you see is the Process Monitor Filter, shown in <a href="ch03.xhtml#ch3fig1">Figure 3-1</a>.</p>&#13;
<div class="image"><img src="../images/f03-01.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch3fig1"/><em>Figure 3-1: Process Monitor Filter dialog</em></p>&#13;
<p class="indent">This dialog allows you to show or suppress events based on a number of dynamic properties they possess. To start monitoring processes, select <strong>Process Name</strong> <span class="ent">▸</span> <strong>Is</strong> <span class="ent">▸</span> <em><strong>YourGameFilename.exe</strong></em> <span class="ent">▸</span> <strong>Include</strong> and then press <strong>Add</strong>, <span epub:type="pagebreak" id="page_51"/><strong>Apply</strong>, and <strong>OK</strong>. This tells Process Monitor to show events invoked by <em>YourGameFilename.exe</em>. With the proper filters set, you will be taken to the main window shown in <a href="ch03.xhtml#ch3fig2">Figure 3-2</a>.</p>&#13;
<div class="image"><img src="../images/f03-02.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch3fig2"/><em>Figure 3-2: Process Monitor main window</em></p>&#13;
<p class="indentb">To configure the columns displayed in Process Monitor’s log area, right-click on the header and choose <strong>Select Columns</strong>. There’s an impressive number of options, but I recommend seven.</p>&#13;
<p class="noindenth"><strong>Time of Day</strong> Lets you see when actions are happening.</p>&#13;
<p class="noindenth"><strong>Process Name</strong> Is useful if you’re monitoring multiple processes, but with the single-process filter that is typically used for games; disabling this option can save precious space.</p>&#13;
<p class="noindenth"><strong>Process ID</strong> Is like Process Name, but it shows the ID rather than the name.</p>&#13;
<p class="noindenth"><strong>Operation</strong> Shows what action was performed; thus, this option is compulsory.</p>&#13;
<p class="noindenth"><strong>Path</strong> Shows the path of the action’s target; also compulsory.</p>&#13;
<p class="noindenth"><strong>Detail</strong> Is useful only in some cases, but enabling it won’t hurt.</p>&#13;
<p class="noindenth"><strong>Result</strong> Shows when actions, such as loading files, fail.</p>&#13;
<p class="indentt">As you show more columns, the log can get very crowded, but sticking with these options should help keep the output succinct.</p>&#13;
<p class="indentb">Once the monitor is running and you’ve defined the columns you wish to see, there are five event class filters, outlined in black in <a href="ch03.xhtml#ch3fig2">Figure 3-2</a>, that you can toggle to clean up your logs even further. Event class filters let you choose which events to show in the log, based on type. From left to right, these filters are as follows:</p>&#13;
<p class="noindenth"><strong>Registry</strong> Shows all registry activity. There will be a lot of white noise in the registry upon process creation, as games rarely use the registry and Windows libraries always use it. Leaving this filter disabled can save a lot of space in the log.</p>&#13;
<p class="noindenth"><span epub:type="pagebreak" id="page_52"/><strong>Filesystem</strong> Shows all filesystem activity. This is the most important event class filter, since knowing where data files are stored and how they are accessed is integral to writing an effective bot.</p>&#13;
<p class="noindenth"><strong>Network</strong> Shows all network activity. The call stack on network events can be useful in finding network-related code within a game.</p>&#13;
<p class="noindenth"><strong>Process and thread activity</strong> Shows all process and thread actions. The call stack on these events can give you insight into how a game’s code handles threads.</p>&#13;
<p class="noindenth"><strong>Process profiling</strong> Periodically shows information about the memory and CPU usage of each running process; a game hacker will rarely use it.</p>&#13;
<p class="indentt">If class-level event filtering is still not precise enough to filter out unwanted pollution in your logs, right-click on specific events for event-level filtering options. Once you have your event filtering configured to log only what you need, you can begin navigating the log. <a href="ch03.xhtml#ch3tab1">Table 3-1</a> lists some useful hotkeys for controlling the log’s behavior.</p>&#13;
<p class="tablecap"><a id="ch3tab1"/><strong>Table 3-1:</strong> Process Monitor Hotkeys</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Hotkey</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Action</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><small>CTRL</small>-E</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Toggles logging.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><small>CTRL</small>-A</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Toggles automatic scrolling of the log.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><small>CTRL</small>-X</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Clears the log.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><small>CTRL</small>-L</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Displays the Filter dialog.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><small>CTRL</small>-H</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Displays the Highlight dialog. This dialog looks very similar to the Filter dialog, but it is used to indicate which events should be highlighted.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><small>CTRL</small>-F</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Displays the Search dialog.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><small>CTRL</small>-P</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Displays the Event Properties dialog for the selected event.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">As you navigate the log, you can examine the operations recorded to see the fine-grained details of an event.</p>&#13;
<h4 class="h4" id="ch00lev1sec60"><strong><em>Inspecting Events in the Process Monitor Log</em></strong></h4>&#13;
<p class="noindent">Process Monitor logs every data point it possibly can about an event, enabling you to learn more about these events than just the files they act upon. Carefully inspecting data-rich columns, such as Result and Detail, can yield some very interesting information.</p>&#13;
<p class="indent">For example, I’ve found that games sometimes read data structures, element by element, directly from files. This behavior is apparent when a log contains a large number of reads to the same file, where each read has sequential offsets but differing lengths. Consider the hypothetical event log shown in <a href="ch03.xhtml#ch3tab2">Table 3-2</a>.</p>&#13;
<p class="tablecap"><span epub:type="pagebreak" id="page_53"/><a id="ch3tab2"/><strong>Table 3-2:</strong> Example Event Log</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Operation</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Path</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Detail</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Create File</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><em>C:\file.dat</em></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Desired Access: Read</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Read File</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><em>C:\file.dat</em></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Offset: 0 Size: 4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Read File</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><em>C:\file.dat</em></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Offset: 4 Size: 2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Read File</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><em>C:\file.dat</em></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Offset: 6 Size: 2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Read File</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><em>C:\file.dat</em></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Offset: 8 Size: 4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Read File</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><em>C:\file.dat</em></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Offset: 12 Size: 4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">...</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><em>...</em></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">...Continues to read chunks of 4 bytes for a while</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">This log reveals that the game is reading a structure from the file piece by piece, disclosing some hints about what the structure looks like. For example, let’s say that these reads reflect the following data file:</p>&#13;
<pre>struct myDataFile<br/>{<br/>    int header;        // 4 bytes (offset 0)<br/>    short effectCount; // 2 bytes (offset 4)<br/>    short itemCount;   // 2 bytes (offset 6)<br/>    int* effects;<br/>    int* items;<br/>};</pre>&#13;
<p class="indent">Compare the log in <a href="ch03.xhtml#ch3tab2">Table 3-2</a> with this structure. First, the game reads the 4 <code>header</code> bytes. Then, it reads two 2-byte values: <code>effectCount</code> and <code>itemCount</code>. It then creates two integer arrays, <code>effects</code> and <code>items</code>, of respective lengths <code>effectCount</code> and <code>itemCount</code>. The game then fills these arrays with data from the file, reading 4 bytes <code>effectCount + itemCount</code> times.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Developers definitely shouldn’t use a process like this to read data from a file, but you’d be amazed at how often it happens. Fortunately for you, naïveté like this just makes your analysis easier.</em></p>&#13;
</div>&#13;
<p class="indent">In this case, the event log can identify small pieces of information within a file. But keep in mind that, while correlating the reads with the known structure is easy, it’s much harder to reverse engineer an unknown structure from nothing but an event log. Typically, game hackers will use a debugger to get more context about each interesting event, and the data from Process Monitor can be seamlessly integrated into a debugging session, effectively tying together the two powerful reverse engineering paradigms.</p>&#13;
<h4 class="h4" id="ch00lev1sec61"><strong><em>Debugging a Game to Collect More Data</em></strong></h4>&#13;
<p class="noindent">Let’s step away from this hypothetical file read and look at how Process Monitor lets you transition from event logging to debugging. Process Monitor stores a complete stack trace for each event, showing the full execution <span epub:type="pagebreak" id="page_54"/>chain that led to the event being triggered. You can view these stack traces in the Stack tab of the Event Properties window (double-click the event or press <small>CTRL</small>-P), as shown in <a href="ch03.xhtml#ch3fig3">Figure 3-3</a>.</p>&#13;
<div class="image"><img src="../images/f03-03.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch3fig3"/><em>Figure 3-3: Process Monitor event call stack</em></p>&#13;
<p class="indent">The stack trace is displayed in a table starting with a Frame column <span class="ent">➊</span>, which shows the execution mode and stack frame index. A pink <em>K</em> in this column means the call happened in kernel mode, while a blue <em>U</em> means it happened in user mode. Since game hackers typically work in user mode, kernel mode operations are usually meaningless.</p>&#13;
<p class="indent">The Module column <span class="ent">➋</span> shows the executable module where the calling code was located. Each module is just the name of the binary that made the call; this makes it easy to identify which calls were actually made from within a game binary.</p>&#13;
<p class="indent">The Location column <span class="ent">➌</span> shows the name of the function that made each call, as well as the call offset. These function names are deduced from the export table of the module and will generally not be present for the functions within a game binary. When no function names are present, the Location column instead shows the module name and the call’s <em>offset</em> (how many bytes past the origin address the call is in memory) from the module’s base address.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_55"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In the context of code, the offset is how many bytes of assembly code are between an item and its origin.</em></p>&#13;
</div>&#13;
<p class="indent">The Address column <span class="ent">➍</span> shows the code address of the call, which is very useful because you can jump to the address in the OllyDbg disassembler. Finally, the Path column <span class="ent">➎</span> shows the path to the module that made the call.</p>&#13;
<p class="indent">In my opinion, the stack trace is, by far, the most powerful feature in Process Monitor. It reveals the entire context that led to an event, which can be immensely useful when you are debugging a game. You can use it to find the exact code that triggered an event, crawl up the call chain to see how it got there, and even determine exactly what libraries were used to complete each action.</p>&#13;
<p class="indent">Process Monitor’s sister application, Process Explorer, doesn’t have many capabilities beyond those in Process Monitor or OllyDbg. But it does expose some of those capabilities much more effectively, making it an ideal pick in certain situations.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart" id="ch03sb01"><strong>FINDING A HIGH SCORE FILE</strong></p>&#13;
<p class="noindent">If you’re ready to test your Process Monitor skills, you’ve come to the right place. Open the <em>GameHackingExamples/Chapter3_FindingFiles</em> directory and execute <em>FindingFiles.exe</em>. You’ll see that it is a game of Pong, like the one in “<a href="ch02.xhtml#ch02sb01">Patching an <code>if()</code> Statement</a>” on <a href="ch02.xhtml#page_46">page 46</a>. Unlike in <a href="ch02.xhtml#ch02">Chapter 2</a>, though, now the game is actually playable. It also displays your current score and your all-time-high score.</p>&#13;
<p class="indent">Now restart the game, firing up Process Monitor before executing it for the second time. Filtering for filesystem activity and creating any other filters you see fit, try to locate where the game stores the high-score file. For bonus points, try to modify this file to make the game show the highest possible score.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec62"><strong>Process Explorer</strong></h3>&#13;
<p class="noindent">Process Explorer is an advanced task manager (it even has a button you can press to make it your default task manager), and it’s very handy when you’re starting to understand how a game operates. It provides complex data about running processes, such as parent and child processes, CPU usage, memory usage, loaded modules, open handles, and command line arguments, and it can manipulate those processes. It exceeds at showing you high-level information, such as process trees, memory consumption, file access, and process IDs, all of which can be very useful.</p>&#13;
<p class="indent">Of course, none of this data is specifically useful in isolation. But with a keen eye, you can make correlations and draw some useful conclusions about what global objects—including files, mutexes, and shared memory <span epub:type="pagebreak" id="page_56"/>segments—a game has access to. Additionally, the data shown in Process Explorer can be even more valuable when cross-referenced with data gathered in a debugging session.</p>&#13;
<p class="indent">This section introduces the Process Explorer interface, discusses the properties it shows, and describes how you can use this tool to manipulate <em>handles</em> (references to system resources). After this introduction, use “<a href="ch03.xhtml#ch03sb02">Finding and Closing a Mutex</a>” on <a href="ch03.xhtml#page_60">page 60</a> to hone your skills.</p>&#13;
<h4 class="h4" id="ch00lev1sec63"><strong><em>Process Explorer’s User Interface and Controls</em></strong></h4>&#13;
<p class="noindent">When you open Process Explorer, you see a window that is split into three distinct sections, as in <a href="ch03.xhtml#ch3fig4">Figure 3-4</a>.</p>&#13;
<div class="image"><img src="../images/f03-04.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch3fig4"/><em>Figure 3-4: Process Explorer main window</em></p>&#13;
<p class="indent">Those three sections are the toolbar <span class="ent">➊</span>, an upper pane <span class="ent">➋</span>, and a lower pane <span class="ent">➌</span>. The upper pane shows a list of processes, utilizing a tree structure to display their parent/child relationships. Different processes are highlighted with different colors; if you don’t like the current colors, click <strong>Options</strong> <span class="ent">▸</span> <strong>Configure Colors</strong> to display a dialog that allows you to view and change them.</p>&#13;
<p class="indent">Just as in Process Monitor, the display for this table is highly versatile, and you can customize it by right-clicking on the table header and choosing Select Columns. There are probably more than 100 customization options, but I find that the defaults with the addition of the ASLR Enabled column work just fine.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_57"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep">Address Space Layout Randomization (ASLR) <em>is a Windows security feature that allocates executable images at unpredictable locations, and knowing whether it’s on is invaluable when you’re trying to alter game state values in memory.</em></p>&#13;
</div>&#13;
<p class="indent">The lower pane has three possible states: Hidden, DLLs, and Handles. The Hidden option hides the pane from view, DLLs displays a list of Dynamic Link Libraries loaded within the current process, and Handles shows a list of handles held by the process (visible in <a href="ch03.xhtml#ch3fig4">Figure 3-4</a>). You can hide or unhide the entire lower pane by toggling View <span class="ent">▸</span> Show Lower Pane. When it is visible, you can change the information display by selecting either View <span class="ent">▸</span> Lower Pane View <span class="ent">▸</span> DLLs or View <span class="ent">▸</span> Lower Pane View <span class="ent">▸</span> Handles.</p>&#13;
<p class="indent">You can also use hotkeys to quickly change between lower pane modes without affecting processes in the upper pane. These hotkeys are listed in <a href="ch03.xhtml#ch3tab3">Table 3-3</a>.</p>&#13;
<p class="tablecap"><a id="ch3tab3"/><strong>Table 3-3:</strong> Process Explorer Hotkeys</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Hotkey</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Action</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><small>CTRL</small>-F</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Search through lower pane data sets for a value.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><small>CTRL</small>-L</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Toggle the lower pane between hidden and visible.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><small>CTRL</small>-D</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Toggle the lower pane to display DLLs.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><small>CTRL</small>-H</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Toggle the lower pane to display handles.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">spacebar</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Toggle process list autorefresh.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><small>ENTER</small></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Display the Properties dialog for the selected process.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><small>DEL</small></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Kill the selected process.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><small>SHIFT</small>-<small>DEL</small></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Kill the selected process and all child processes.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Use the GUI or hotkeys to practice changing modes. When you’re acquainted with the main window, we’ll look at another important Process Explorer dialog, called Properties.</p>&#13;
<h4 class="h4" id="ch00lev1sec64"><strong><em>Examining Process Properties</em></strong></h4>&#13;
<p class="noindent">Much like Process Monitor, Process Explorer has a very kinetic approach to data gathering; the end result is a broad and verbose spectrum of information. In fact, if you open the Properties dialog (shown in <a href="ch03.xhtml#ch3fig5">Figure 3-5</a>) for a process, you’ll see a massive tab bar containing 10 tabs.</p>&#13;
<p class="indent">The Image tab, selected by default and shown in <a href="ch03.xhtml#ch3fig5">Figure 3-5</a>, displays the executable name, version, build date, and complete path. It also displays the current working directory and the Address Space Layout Randomization status of the executable. ASLR status is the most important piece of information here, because it has a direct effect on how a bot can read the memory from a game. I’ll talk about this more in <a href="ch06.xhtml#ch06">Chapter 6</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_58"/><img src="../images/f03-05.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch3fig5"/><em>Figure 3-5: Process Explorer Properties dialog</em></p>&#13;
<p class="indent">The Performance, Performance Graph, Disk and Network, and GPU Graph tabs display a myriad of metrics about the CPU, memory, disk, network, and GPU usage of the process. If you create a bot that injects into a game, this information can be very useful to determine how much of a performance impact your bot has on the game.</p>&#13;
<p class="indent">The TCP/IP tab displays a list of active TCP connections, which you can use to find any game server IP addresses that a game connects to. If you’re trying to test connection speed, terminate connections, or research a game’s network protocol, this information is critical.</p>&#13;
<p class="indent">The Strings tab displays a list of strings found in either the binary or the memory of the process. Unlike the string list in OllyDbg, which shows only strings referenced by assembly code, the list includes any occurrences of three or more consecutive readable characters, followed by a null terminator. When a game binary is updated, you can use a diffing tool on this list from each game version to determine whether there are any new strings that you want to investigate.</p>&#13;
<p class="indent">The Threads tab shows you a list of threads running within the process and allows you to pause, resume, or kill each thread; the Security tab displays the security privileges of the process; and the Environment tab displays any environment variables known to or set by the process.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_59"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you open the Properties dialog for a .NET process, you’ll notice two additional tabs: .NET Assemblies and .NET Performance. The data in these tabs is pretty self-explanatory. Please keep in mind that a majority of the techniques in this book won’t work with games written in .NET.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec65"><strong><em>Handle Manipulation Options</em></strong></h4>&#13;
<p class="noindent">As you’ve seen, Process Explorer can provide you with a wealth of information about a process. That’s not all it’s good for, though: it can also manipulate certain parts of a process. For example, you can view and manipulate open handles from the comfort of Process Explorer’s lower pane (see <a href="ch03.xhtml#ch3fig4">Figure 3-4</a>). This alone makes a strong argument for adding Process Explorer to your toolbox. Closing a handle is as simple as right-clicking on it and selecting Close Handle. This can come in handy when you want, for instance, to close mutexes, which is essential to certain types of hacks.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You can right-click on the lower pane header and click Select Columns to customize the display. One column you might find particularly useful is Handle Value, which can help when you see a handle being passed around in OllyDbg and want to know what it does.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch00lev1sec66"><strong>Closing Mutexes</strong></h5>&#13;
<p class="noindent">Games often allow only one client to run at a time; this is called <em>single-instance limitation</em>. You can implement single-instance limitation in a number of ways, but using a system mutex is common because mutexes are sessionwide and can be accessed by a simple name. It’s trivial to limit instances with mutexes, and thanks to Process Explorer, it’s just as trivial to remove that limit, allowing you to run multiple instances of a game at the same time.</p>&#13;
<p class="indent">First, here’s how a game might tackle single-instance limitation with a mutex:</p>&#13;
<pre>int main(int argc, char *argv[]) {<br/>    // create the mutex<br/>    HANDLE mutex = CreateMutex(NULL, FALSE, "onlyoneplease");<br/>    if (GetLastError() == ERROR_ALREADY_EXISTS) {<br/>        // the mutex already exists, so exit<br/>        ErrorBox("An instance is already running.");<br/>        return 0;<br/>    }<br/>    // the mutex didn't exist; it was just created, so<br/>    // let the game run<br/>    RunGame();<br/>    // the game is over; close the mutex to free it up<br/>    // for future instances<br/>    if (mutex)<br/>        CloseHandle(mutex);<br/>    return 0;<br/>}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_60"/>This example code creates a mutex named <code>onlyoneplease</code>. Next, the function checks <code>GetLastError()</code> to see whether the mutex was already created, and if so, it closes the game. If the mutex doesn’t already exist, the game creates the first instance, thereby blocking any future game clients from running. In this example, the game runs normally, and once it finishes, <code>CloseHandle()</code> is called to close the mutex and allow future game instances to run.</p>&#13;
<p class="indent">You can use Process Explorer to close instance-limiting mutexes and run many game instances simultaneously. To do so, choose the Handles view of the lower pane, look for all handles with a type of <code>Mutant</code>, determine which one is limiting instances of the game, and close that mutex.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>Mutexes are also used to synchronize data across threads and processes. Close one only if you’re sure that its sole purpose is the one you’re trying to subvert!</em></p>&#13;
</div>&#13;
<p class="indent">Multiclient hacks are generally in high demand, so being able to quickly develop them for emerging games is crucial to your overall success as a bot developer within that market. Since mutexes are one of the most common ways to achieve single-instance limitation, Process Explorer is an integral tool for prototyping these kinds of hacks.</p>&#13;
<h5 class="h5" id="ch00lev1sec67"><strong>Inspecting File Accesses</strong></h5>&#13;
<p class="noindent">Unlike Process Monitor, Process Explorer can’t show a list of filesystem calls. On the other hand, the Handles view of Process Explorer’s lower pane can show all file handles that a game currently has open, revealing exactly what files are in continuous use without the need to set up advanced filtering criteria in Process Monitor. Just look for handles with a type of <code>File</code> to see all files the game is currently using.</p>&#13;
<p class="indent">This functionality can come in handy if you’re trying to locate logfiles or save files. Moreover, you can locate named pipes that are used for interprocess communication (IPC); these are files prefixed with <em>\Device\NamedPipe\</em>. Seeing one of these pipes is often a hint that the game is talking to another process.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart" id="ch03sb02"><strong>FINDING AND CLOSING A MUTEX</strong></p>&#13;
<p class="noindent">To put your Process Explorer skills to use, go to the <em>GameHackingExamples/Chapter3_CloseMutex</em> directory and execute <em>CloseMutex.exe</em>. This game plays exactly like the one in “<a href="ch03.xhtml#ch03sb01">Finding a High Score File</a>” on <a href="ch03.xhtml#page_55">page 55</a>, but it prevents you from simultaneously running multiple instances. As you might have guessed, it does this using a single-instance-limitation mutex. Using Process Explorer’s Handles view in the lower pane, find the mutex responsible for this limitation and close it. If you succeed, you’ll be able to open a second instance of the game.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec68"><span epub:type="pagebreak" id="page_61"/><strong>Closing Thoughts</strong></h3>&#13;
<p class="noindent">To be effective when using Process Monitor and Process Explorer, you need, above all else, a deep familiarity with the data that these applications display as well as the interfaces they use to display it. While this chapter’s overview is a good baseline, the intricacies of these applications can be learned only through experience, so I encourage you to play around with them on your system.</p>&#13;
<p class="indent">You won’t use these tools on a regular basis, but at some point, they’ll save the day: as you struggle to figure out how some code works, you’ll recall an obscure piece of information that caught your eye during a previous Process Explorer or Process Monitor session. That’s why I consider them useful reconnaissance tools.<span epub:type="pagebreak" id="page_62"/></p>&#13;
</body></html>