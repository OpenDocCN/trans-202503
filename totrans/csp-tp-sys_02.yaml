- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">VALUE
    AND REFERENCE TYPES</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: We can create new types in C# in several ways, and we need to consider the individual
    characteristics of each approach to determine which best suits our goals. In particular,
    knowing how value types differ from reference types helps us choose the right
    way forward, because these differences have significant and sometimes unconsidered
    implications when we’re defining our own types. Certain trade-offs will affect
    how we design our type and what we can use it for. In this chapter, we’ll investigate
    those differences and what they mean for our programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What choices we have when creating our own types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why C# has both reference types and value types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How choosing one or the other affects construction, null checking, and other
    type behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why value type is not the same as value semantics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where different types are stored in memory and how that affects an object’s
    lifetime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">User-Defined Types</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most modern programming languages allow you to create custom types. The basic
    principles of user-defined types in C# will be familiar to programmers of many
    other languages, but some of the details are different. Therefore, in this section
    we’ll examine the four kinds of user-defined types: structs, classes, and the
    newer records and record structs (introduced in C# v9.0 and v10.0, respectively).'
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to recognize that the behavior of these types relies heavily
    on whether they are reference types or value types. Let’s look briefly at each
    kind of user-defined type with these differences in mind.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Structs and Classes</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Listing 2-1](#list2-1) defines a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    to represent colors.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-1: Defining a simple
    struct</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct is marked
    <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> to indicate that
    instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> are immutable—that
    is, they never change their value. Correspondingly, none of the three properties
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>) has a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor, so their values can’t be changed after they’ve been given initial values
    using the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor in this example uses the expression body syntax (<samp class="SANS_TheSansMonoCd_W5Regular_11">=></samp>),
    which you saw in [Chapter 1](chapter1.xhtml), instead of a body enclosed between
    braces <samp class="SANS_TheSansMonoCd_W5Regular_11">{…}</samp>. We make the expression
    body a single-line statement by using *tuple assignment*, which assigns the tuple
    of three parameter values <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    to the tuple of three properties. The compiler translates this syntax into an
    efficient assignment from the parameter values directly to the respective backing
    fields for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> keyword in
    the struct’s definition is not mandatory but reinforces that instances of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> are immutable. Immutable
    value types make our code easier to comprehend and may allow some optimizations
    by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, if we define a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    class instead of a struct, we can’t use the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>
    keyword in its definition, although we can make it immutable by not providing
    <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessors for the properties.
    The only other difference in defining <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    as a class is the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp>
    keyword in the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    is otherwise identical to that in [Listing 2-1](#list2-1).
  prefs: []
  type: TYPE_NORMAL
- en: The principal difference between these two types is that a class is a reference
    type, and a struct is a value type. Before we analyze the implications of this
    difference, let’s look at record and record struct types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Records and Record
    Structs</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of C# v9.0, we can define a record type with the <samp class="SANS_TheSansMonoCd_W5Regular_11">record</samp>
    keyword. Records introduce a new syntax for compactly defining a type. [Listing
    2-2](#list2-2) creates a record type named <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-2: Defining a record</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This example shows a *positional* record; the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type has no body, but the type definition has its own positional parameters that
    are used by the compiler to generate a complete type. Behind the scenes, the compiler
    translates the record into a class definition, meaning that records are reference
    types. The compiler also translates the parameter names <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>
    into public properties of the same name, along with a public constructor with
    matching parameters to initialize the property values. The positional parameters
    are also used by the compiler to generate other methods, including <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>,
    which are overrides of their counterparts in the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    base class.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-3](#list2-3) creates a new instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    record and uses its properties exactly as if it were a class or a struct.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-3: Creating an instance
    of Color</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use named arguments when constructing the <samp class="SANS_TheSansMonoCd_W5Regular_11">tomato</samp>
    variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> to
    emphasize the names given by the compiler to the constructor parameters. Note
    that the property names used in the assertions are identical to the names used
    in the constructor, and that both match the names used in the record definition.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*One important difference between records and structs or classes relates to
    handling equality comparisons between two instances, a topic we’ll examine in
    more detail in “Identity Equality vs. Value Equality” on [page 47](#sec19).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Very closely related to records are record structs, introduced in C# v10.0\.
    In contrast to records, which are compiled as classes, record structs are translated
    by the compiler into struct definitions, making them value types. Otherwise, they’re
    the same as records. Record structs are denoted by the <samp class="SANS_TheSansMonoCd_W5Regular_11">record
    struct</samp> keywords, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This record struct, much like the struct in [Listing 2-1](#list2-1), is marked
    <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>. If we left out
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> keyword, the
    properties generated by the compiler would be read-write properties, with both
    <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessors. Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>
    keyword makes <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> an immutable
    record struct.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Inheritance</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One common way of representing relationships between classes and between records
    is to use *inheritance*, or deriving one type from another. However, we can’t
    apply inheritance to structs or record structs; it’s available only to reference
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Another restriction of inheritance is that a record can inherit from another
    record but not explicitly from a class. Similarly, classes can’t inherit from
    records. In every other respect, records follow the same rules and have the same
    characteristics as classes as far as inheritance is concerned. Classes and records
    can define virtual methods and properties, allowing a more derived type to provide
    its own behavior by overriding the method or property, and we can choose to ignore,
    override, or hide any virtual methods in a derived type.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, structs and record structs are implicitly *sealed*, meaning that
    inheriting from them is prohibited. If we attempt to derive from a struct or record
    struct, we get a compile-time error. Structs and record structs can’t inherit
    from another user-defined type either.
  prefs: []
  type: TYPE_NORMAL
- en: Another restriction for a class or record is that it can inherit from only one
    base type. Any attempt at multiple inheritance results in a compiler error. If
    no base type is explicitly specified, <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    becomes the implied base class. As you’ll see in “The Common Type System” on [page
    45](#sec16), every type ultimately inherits from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>,
    either directly or indirectly. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>
    class in [Listing 2-4](#list2-4) implicitly derives from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>,
    while the <samp class="SANS_TheSansMonoCd_W5Regular_11">DummyCommand</samp> class
    derives explicitly from <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>,
    implicitly inheriting from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    via the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> base class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-4: Inheritance syntax</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> base class
    defines a virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">RunQuery</samp>
    method, which is overridden in the derived <samp class="SANS_TheSansMonoCd_W5Regular_11">DummyCommand</samp>
    class to alter the method’s behavior. A stub implementation like <samp class="SANS_TheSansMonoCd_W5Regular_11">DummyCommand</samp>
    might be used during testing to avoid having the test code depend on the underlying
    data store’s contents.
  prefs: []
  type: TYPE_NORMAL
- en: Any type may *implement* multiple interfaces, but it’s important to understand
    that inheritance is quite different from interface implementation. When we implement
    an interface, the implementing method is, by default, *not* virtual. A class or
    record implementing a method from an interface can choose to make its implementation
    of the method virtual, but a struct or record struct cannot.
  prefs: []
  type: TYPE_NORMAL
- en: We can explicitly designate any member of a class or record as <samp class="SANS_TheSansMonoCd_W5Regular_11">protected</samp>,
    as opposed to <samp class="SANS_TheSansMonoCd_W5Regular_11">public</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">private</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">internal</samp>.
    A protected member is accessible within the class declaring it and to any types
    that inherit from that class, but it’s not visible to any other code. Since value
    types are sealed, it makes no sense for them to have virtual or protected members.
    If we try to make a method virtual in a value type definition or to define any
    protected fields, properties, or methods, we’re rewarded with a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: We can choose to declare a class or record type as <samp class="SANS_TheSansMonoCd_W5Regular_11">sealed</samp>
    so that it can’t be used for further inheritance. Sealing a class does not affect
    what *it* can inherit, only what can inherit from it. It’s common to seal classes
    that have value-like characteristics, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>,
    or when we wish to restrict a class’s behavior to that defined in our own implementation.
    If a class is intended to be immutable, whether or not it’s intended to have value-like
    characteristics, sealing it ensures that its immutability can’t be subverted by
    a mutable derived class.
  prefs: []
  type: TYPE_NORMAL
- en: Records are specifically intended to be value-like types and have value-like
    behavior defined for them by the compiler. This means we should seal record types
    unless we have a compelling reason not to do so. We’ll look in detail at the meaning
    of *value-like* and why such types should be sealed in [Chapters 6](chapter6.xhtml)
    and [7](chapter7.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is a central feature of object-oriented code, but it applies exclusively
    to reference types. Inheritance—as well as the features that support it, such
    as virtual methods—is not appropriate for value types, in part because of the
    way value type instances use memory.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Instance Lifetimes</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Value types and reference types differ in the way each uses memory and, more
    specifically, in the lifetime of their instances. Value type instances are short-lived,
    and their lifetime is bound to the lifetime of the variables that represent them.
    For value types, the variable *is* the instance; when we create a new instance
    of a value type, the target variable effectively contains the instance data—that
    is, the value of each field of the type.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, the lifetime of a variable is defined by a block, such as a method
    body or a <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> loop. Any
    local variables within the block cease to exist when the block ends. Alternatively,
    a variable might be contained in another object, in which case the variable’s
    lifetime is defined by the lifetime of the enclosing object. Whenever we copy
    a value type variable by assigning it to another variable or passing it as an
    argument to a method, the copy is a whole new instance of the type in a *different*
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Reference type instances, on the other hand, are generally long-lived and can
    be referred to by many variables. When we create a new instance of a reference
    type, we’re given a reference to that instance in memory. Whenever we copy that
    reference, we’re not also copying the instance. The original reference and the
    copy both refer to the same instance. References are stored in *reference variables*.
  prefs: []
  type: TYPE_NORMAL
- en: All reference type instances are allocated on the heap. Their lifetime is managed
    by automatic garbage collection, which releases their memory when they’re no longer
    needed by the program. An object is considered unused when the garbage collector
    determines that no other live references to that instance exist. While reference
    type instances are not subject to their scope, reference variables *are* subject
    to scope, so when one goes out of scope, it’s no longer a live reference to an
    instance. The lifetime of a reference type instance, then, is determined by the
    lifetimes of *all* the references to that instance.
  prefs: []
  type: TYPE_NORMAL
- en: A cost is associated with being allocated on the heap, because the garbage collection
    process takes time while the program is running. Ensuring that unused heap memory
    is properly cleaned up is a complex operation and may interrupt a program’s normal
    execution for a short time, so an overhead is associated with reference types.
  prefs: []
  type: TYPE_NORMAL
- en: Value types don’t require the overhead associated with garbage collection. The
    memory used by a value type instance can be freed when the lifetime of its variable
    ends. To understand lifetime a little better, let’s look more closely at what
    we mean by *variable* in different contexts.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Variables</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *variable* is simply a named area of memory. We use this name—or *identifier*—
    to manipulate a memory location during the variable’s lifetime. C# has five main
    kinds of variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local variables**'
  prefs: []
  type: TYPE_NORMAL
- en: These are block-scope variables, where a *block* might be a method with a statement
    body, the body of a loop, or any section of code delimited by matching braces,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>. When control leaves a
    block at the closing brace, any variables that are local to the block go out of
    scope. When an exception is thrown in a block, the control flow also leaves that
    scope and any containing scope until the exception is caught or the program exits.
  prefs: []
  type: TYPE_NORMAL
- en: '**Instance fields**'
  prefs: []
  type: TYPE_NORMAL
- en: These are normal data members, known as *fields*, of structs and non-static
    classes. Each instance of a type has its own copies of any instance fields. The
    lifetime of an instance field is defined by the lifetime of the object to which
    it belongs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Static fields**'
  prefs: []
  type: TYPE_NORMAL
- en: These fields are associated with a type, rather than individual instances of
    the type. The lifetime of a static field is normally tied to an application, so
    the instances associated with static fields are usually released when an application
    exits.
  prefs: []
  type: TYPE_NORMAL
- en: '**Array elements**'
  prefs: []
  type: TYPE_NORMAL
- en: Individual elements in an array are all variables. We can access a particular
    element by its index and alter the element instance if it is mutable.
  prefs: []
  type: TYPE_NORMAL
- en: '**Method parameters**'
  prefs: []
  type: TYPE_NORMAL
- en: The parameters in a method definition are technically called *formal parameters*
    but are commonly known as just *parameters*. A parameter’s scope is the body of
    the method, exactly as if the parameter were declared as a local variable within
    the method’s body. In code that calls a method, we pass *actual parameters*, better
    known as *arguments*, that correspond to the method’s parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of its kind, a variable always has an associated type. This might
    be an explicitly declared type, as in the declaration <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    size</samp>, or, for local variables, the type might be implied with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">var</samp> keyword. If the variable’s
    type is a reference type, the variable’s *value* is a reference. A non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference is a handle to an instance somewhere on the heap. If the variable’s
    type is a value type, the variable’s value is an instance of the type.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variables vs. Values</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s not always easy to intuit what counts as a variable and what counts as
    a value, but the distinction is important:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Variables* can be assigned to, although a <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>
    field variable can be assigned only within a constructor of the type of which
    it is a member, or using field initialization (which we’ll discuss in “Field Initializers”
    on [page 58](#sec30)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Values* are the results of expressions—such as the result of calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">new</samp>, the return value from a method,
    or a constant expression such as a literal number or <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    literal. Values *can’t* be assigned to, but we use them to initialize variables
    by using assignment or passing them as arguments to method parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Variables, for the most part, have names. Strictly speaking, individual array
    elements don’t have their own names, but for an array variable <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>,
    the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">index</samp>] is essentially
    the element’s identifier. A value can have a name but doesn’t require one: the
    expression <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> produces a new value, but
    it is anonymous unless we assign that value to a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: The type of a value defines what an *instance* looks like. Among other things,
    the type might have multiple fields that need space allocated in memory when an
    instance of the type is created. The type of a variable defines the sort of value
    it can contain.
  prefs: []
  type: TYPE_NORMAL
- en: A value is just a pattern of bits. The type is a formal specification for interpreting
    that bit pattern to give it meaning in a program. Two values with identical bit
    patterns may be interpreted differently if they are different types. A pattern
    of bits that are all <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> means
    one thing if the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>,
    but something else entirely if the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: A variable of value type directly contains its data, whereas a variable of reference
    type contains a reference to its data. More precisely, reference variables have
    a value that is a reference to an object somewhere on the heap. Put simply, a
    reference refers to an instance of a reference type; the value of a reference
    type variable is a reference.
  prefs: []
  type: TYPE_NORMAL
- en: The relationship between variables and values is that all variables *have* a
    value, although the value can’t be accessed until the variable has been definitely
    assigned.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Definite Assignment</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can’t read the value of a variable unless the compiler is satisfied that
    the variable has definitely been given an initial value. More formally, a variable
    can be read only after a value has been *definitely assigned* to it. The C# Language
    Specification precisely defines what constitutes definite assignment, but the
    essence is that a variable must have been assigned or initialized with a value
    at least once before its value is read.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to obtain the value of any variable that hasn’t been definitely assigned,
    the compiler raises an error to tell us that this isn’t allowed. For example,
    when we declare a local variable within a method, it is uninitialized unless or
    until we assign a value to it. Such variables are initially considered *un*assigned.
    Conceptually, at least, an unassigned variable doesn’t have a value.
  prefs: []
  type: TYPE_NORMAL
- en: When we assign something to a variable, we give that variable a new value. When
    we read from a variable, we obtain its value. Variables and values are both *expressions*,
    meaning we can evaluate them to produce a value, as long as they have been definitely
    assigned.
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, attempting to read a value from any variable that hasn’t yet been
    definitely assigned is an error. When we use a <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    declaration for a local variable, we must provide an initial value where the variable
    is declared, because the type of the variable is inferred from the type of the
    value being assigned to it.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Instances and Storage</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve clearly defined variables and values, we can explore how they
    relate to type instances. Whether an instance is a value type or a reference type
    affects where it is allocated and managed in memory; as a result, value type variables
    have some peculiarities that don’t apply to references.
  prefs: []
  type: TYPE_NORMAL
- en: Value types do not always live on the stack, despite common misconceptions.
    Values for local variables are most often tied to the block scope of a method,
    and so might be associated with a stack frame for the method, but values can also
    be contained within another object as a member or an element in an array. Let’s
    examine this more closely by looking at some examples of how variables are embedded
    in objects.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Embedded Values</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a variable is a field embedded within an instance of another type, its value
    is allocated within the memory for its enclosing object. This is especially important
    for value type variables that directly contain the instance of their type. Consider
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct in [Listing
    2-5](#list2-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-5: Defining a Color
    struct with multiple fields</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct has three
    properties representing the components of an RGB color. When a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    value is used as a field or property in a class, an instance of that class will
    wholly contain a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value
    on the heap. Take, for example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    class in [Listing 2-6](#list2-6), which has several fields, one of which is a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-6: A Color value
    embedded within the Brush class</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> type is a class
    and therefore a reference type. When we create an instance of any reference type,
    it’s allocated on the heap. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    class has three fields, one of which is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instance, which itself has three fields (<samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>).
    An instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> might
    look roughly like [Figure 2-1](#fig2-1) in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: A Color value embedded
    in a Brush instance on the heap</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>,
    the instance is created on the heap and we’re given a reference to it. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">color</samp> field occupies memory directly
    within the memory space for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    instance. If we implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    as a record struct instead of a struct, the outcome would be the same. Record
    structs are value types in exactly the same way as structs and are allocated directly
    within the memory space of any enclosing object.
  prefs: []
  type: TYPE_NORMAL
- en: Value type instances are not individually garbage collected, but if a value
    type instance is embedded in another object that has been allocated on the heap,
    the *memory* used by the value type instance will be reclaimed during garbage
    collection of the enclosing object.
  prefs: []
  type: TYPE_NORMAL
- en: The lifetime of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instance represented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp>
    field is tied to the lifetime of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    instance. When the garbage collector determines that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    instance is no longer used, it will free up the memory for that instance, including
    the embedded <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Array Elements</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When a value type instance is an element in an array, it isn’t (strictly speaking)
    a field of the array object, but the value is still embedded within the memory
    for the array. Arrays are always allocated on the heap, regardless of the type
    of their elements. When we create an array, we’re given a reference to it. To
    illustrate, consider this array of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    values, where <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is a
    struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp> variable here
    is a reference to an array of three <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances on the heap. The memory layout of the <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp>
    array might look like [Figure 2-2](#fig2-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: An array of Color
    structs in memory</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In the <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp> array, each
    element is large enough to store the three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    backing fields. If the element type had more fields, each element would require
    more space on the heap. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type were a record struct rather than a struct, the layout would be identical;
    recall that the compiler translates record structs into structs.
  prefs: []
  type: TYPE_NORMAL
- en: Reference variables, by contrast, are all the same size, regardless of the number
    of fields declared in the type definition. The memory required for an array of
    references is determined only by the number of elements, not the size of each
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Whether the elements of an array are references or value type instances, the
    array is always on the heap, and the array variable refers to its elements. If
    the garbage collector determines that the array is no longer in use—that is, no
    live reference variables to it exist—then the memory for all of its elements is
    freed in one go.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Embedded References</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Reference fields are also embedded in their enclosing type, but their instances
    are not. If we had implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    as a reference type in [Listing 2-5](#list2-5), rather than a value type, the
    layout of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> instance
    would be somewhat different. The <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp>
    field of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> class
    would be a reference, as illustrated in [Figure 2-3](#fig2-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-3: A color reference
    field embedded in a Brush instance</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of containing the entire instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    within its own memory, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    type’s <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp> field refers
    to a separate <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instance
    somewhere else on the heap. Reference type instances are always allocated on the
    heap and are independent of one another. This applies to any reference type, so
    it would be true if we implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    as either a class or a record.
  prefs: []
  type: TYPE_NORMAL
- en: The lifetime of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instance here is *independent* of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    instance. When the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    instance is no longer used and its memory is released, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instance will remain in memory until the garbage collector determines that it’s
    no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Field and Property Layout</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All user-defined types can contain instance fields and properties. However,
    structs and record structs have one restriction that does not apply to classes
    or records: a value type definition can’t embed a field of its own type.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve already seen how value type instances directly contain their fields.
    If a type has a field that is itself a value type, that field also directly contains
    *its* data. If the type of that field is the same as its containing type, the
    compiler is unable to determine how to create it. Consider the simple struct in
    [Listing 2-7](#list2-7) that embeds an instance of *itself* as a field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-7: A struct containing
    an instance of itself</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This example will not compile. The compiler can’t know how to lay out the contained
    field named <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>, because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">p</samp>’s type isn’t fully defined at
    the point where it is declared. The same is true of properties, because even automatic
    properties require a backing field, though that field is hidden from us.
  prefs: []
  type: TYPE_NORMAL
- en: The same reasoning applies to an indirect dependency, illustrated in [Listing
    2-8](#list2-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-8: A struct with
    a cyclic dependency</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Neither the <samp class="SANS_TheSansMonoCd_W5Regular_11">Tree</samp> type
    nor the <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> type can be
    created here because the layout of each depends on the other. This might sound
    draconian, but in practice it’s rarely a problem, and we have an easy workaround:
    if we change the definition of either <samp class="SANS_TheSansMonoCd_W5Regular_11">Tree</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> to make it a reference
    type, the compiler will accept this code. The rule applies only to value types
    because, as mentioned previously, references are always the same size regardless
    of the type to which they refer. This means the compiler doesn’t need to know
    the layout of a class or record to establish a reference to it.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Boxed Values</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: References can refer only to objects on the heap and can’t refer to individual
    value type instances, even those enclosed within a reference type object. The
    only way for a reference variable to individually refer to a value type instance
    is to make a copy of the value, put that copy on the heap, and refer to the copy
    with a new reference. The process of creating a copy and storing it on the heap,
    known as *boxing*, is automatic when the type of the variable is a reference type.
    A boxed value can always be converted back to its original value type, a process
    called *unboxing*, where the value contained in the box is *copied* into the target
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Boxing happens automatically when we refer to a value using a reference variable
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, or when we
    pass a value as an argument to a method that takes a reference type parameter.
    Unboxing is always *explicit*: we need to cast the boxed variable back to its
    correct value type, as shown in [Listing 2-9](#list2-9).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-9: Boxing and unboxing</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> variable
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, and is therefore
    a reference, so the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">green</samp>
    gets boxed into <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> ❶. Similarly,
    calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">object.Equals</samp>
    method boxes the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp>,
    because the method takes two <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    parameters ❷. We don’t need to explicitly cast the value to the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    type; it’s boxed implicitly. We do require an explicit cast to unbox the value
    stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> into a new
    variable ❸.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll see shortly when we cover the Common Type System, <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    is the base class of every type, meaning we can always use <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    to refer to any other variable, including value type instances. A struct can also
    implement one or more interfaces. Interfaces are reference types, so if we use
    either <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> or an interface
    type to refer to a value, that value is automatically boxed onto the heap.
  prefs: []
  type: TYPE_NORMAL
- en: A boxed value can be unboxed only to its original type. We can’t, for instance,
    unbox an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> value into a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, even though an implicit
    built-in conversion exists from <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. If we attempt
    to unbox a value to anything other than its original type, we’ll get an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">InvalidCastException</samp> at run time.
  prefs: []
  type: TYPE_NORMAL
- en: Boxed values are copied to the heap, which means the box is no longer subject
    to the scope of its variable and may exist beyond the lifespan of its original
    value. It’s up to the garbage collector to clean up boxed values. [Chapter 4](chapter4.xhtml)
    discusses boxing in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Semantics and Type</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Value types have semantic implications that go beyond being an instance of a
    struct or record struct. Choosing a value type instead of a reference type when
    we define our own types requires much more than a consideration of possible optimizations.
    Records, in particular, differ from classes, because even though records are compiled
    into classes and are therefore reference types, they share some important behavioral
    characteristics with value types.
  prefs: []
  type: TYPE_NORMAL
- en: Before delving into the behavior of record and record struct types, we need
    to better understand how structs differ from classes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Common Type System</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C# has a hierarchical type system, known as the *Common Type System*, in which
    all types derive from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>,
    a keyword alias for the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Object</samp>
    type. This is why we can always use <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    to refer to any other variable—although, as you just saw, in the case of value
    types, the instances are boxed so they can be referred to by <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    references.
  prefs: []
  type: TYPE_NORMAL
- en: Even the built-in types, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>, inherit from <samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp>. In fact, all built-in types
    are aliases for types in the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp>
    namespace. The <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> types
    that underlie the numeric types are all structs and therefore value types. For
    example, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is an alias
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">public readonly struct Int32</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Enumeration types created with the <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    keyword are not aliases to <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp>
    types, although they all *derive* from the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Enum</samp>
    class. The individual values of an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    declaration have an underlying numeric type, which by default is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    We could specify a different numeric type—for example, if we wanted to allow the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> elements to have values
    larger or smaller than is permitted for an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The non-numeric built-ins <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> are aliases to
    classes in the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> namespace,
    so they’re both reference types.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">record</samp> keyword to define
    our own reference type, our new type derives directly from the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    base class unless it explicitly inherits from another type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    base class is neither an interface nor <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract</samp>.
    It has a mix of virtual, nonvirtual, and static members, which provide the default
    implementations common to all objects.
  prefs: []
  type: TYPE_NORMAL
- en: All struct types (including record structs) and the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Enum</samp>
    type implicitly derive from <samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType</samp>
    (for which there’s no keyword alias), which in turn derives from the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    base class, so all struct types derive *indirectly* from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>.
    Value types, unlike reference types, have an intermediate base class defined by
    the language.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*ValueType itself is* not *a struct, which is sometimes overlooked. All structs
    implicitly inherit from ValueType, so ValueType itself must be a class. Moreover,
    ValueType is an* abstract *class, meaning we can create an instance of object
    but not of ValueType.*'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> class overrides
    all the virtual methods defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    base class—<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>—and
    customizes their implementations to provide behavior tailored for value types.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> implementations
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    are extremely important because they provide the *value-based* definition of equality
    that distinguishes value types from reference types. The difference between these
    implementations has to do with the way values are copied.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Copy Semantics</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The difference between where reference types and value types store their instance
    data has important implications when we copy variables, because copying a reference
    does not copy the instance. [Listing 2-10](#list2-10) shows a simple example to
    illustrate the difference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-10: Copying a variable</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here we’re copying the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp>
    variable into a new variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp>
    ❶. Then we assign a new value to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Host</samp>
    property of <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> ❷. The test
    checks that the properties of the original variable haven’t changed. The success
    of the test assertion depends on whether <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>
    is a value type or a reference type.
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, all variables have a value that we may copy to a new variable.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a value type,
    any copy we make is a new instance of the type, so if we modify any fields of
    that copy, those changes have no effect on the fields of the original value. Therefore,
    if <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a struct or a
    record struct, the test will pass.
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a reference
    type, on the other hand, the <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp>
    variable’s value is a reference. When we copy a reference, only the value of the
    reference is copied, and it refers to the same instance as the original variable’s
    value. This means if we modify the instance using one reference, that change is
    reflected in *all* the references to it. Thus, if <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>
    is a class or a record, the test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Locks and Reference Semantics</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some situations require the behavior of reference type variables, and using
    a value type instance would be incorrect or even disallowed. For example, we can’t
    use a value type in a <samp class="SANS_TheSansMonoCd_W5Regular_11">lock</samp>
    statement to prevent a section of code from being executed concurrently by multiple
    threads. The compiler forbids it because the variable used as a lock needs to
    be a reference to an object on the heap. The purpose of locking an object is to
    allow only a single thread to execute the code it protects at any given time.
    The object instance identifies the lock and can then have multiple references
    to it from different threads.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying mechanism for the <samp class="SANS_TheSansMonoCd_W5Regular_11">lock</samp>
    statement is the <samp class="SANS_TheSansMonoCd_W5Regular_11">System .Threading.Monitor</samp>
    class. The <samp class="SANS_TheSansMonoCd_W5Regular_11">lock</samp> statement
    translates to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Enter</samp> method
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor</samp>, which takes <samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp> as its parameter. Any instance
    of a value type passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor.Enter</samp>
    as an argument will automatically be boxed. Each thread calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor.Enter</samp>
    will box the value separately, and the acquisition of the lock would never fail,
    rendering it pointless.
  prefs: []
  type: TYPE_NORMAL
- en: When we’ve finished with the lock, we need to call <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor.Exit</samp>
    and pass the *same* reference used to acquire the lock with <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor.Enter</samp>.
    The compiler inserts the code to call <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor.Exit</samp>
    at the closing brace of a <samp class="SANS_TheSansMonoCd_W5Regular_11">lock</samp>
    block. If we use a value type, the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Exit</samp>
    will result in a new boxed value on the heap, and so will be a different reference
    to that used in the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Enter</samp>.
    The result is that releasing the lock will fail with a <samp class="SANS_TheSansMonoCd_W5Regular_11">SynchronizationLockException</samp>
    error.
  prefs: []
  type: TYPE_NORMAL
- en: This is one situation actively requiring reference semantics, because passing
    a reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Enter</samp>
    method doesn’t copy the instance. The <samp class="SANS_TheSansMonoCd_W5Regular_11">monitor</samp>
    and the code using the lock both have a reference to the same instance.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Identity Equality vs. Value
    Equality</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we say we’re comparing variables to see whether they’re equal, what we
    really mean is that we’re comparing the variables’ *values*. If two variables
    have the same value, they’re considered equal. The type of each value plays an
    important role: the values being compared must be the same type, although one
    or both values may have resulted from an implicit conversion.'
  prefs: []
  type: TYPE_NORMAL
- en: If we compare the values of two variables of the same reference type, their
    respective values are references, which compare equal by default if they both
    refer to the same object in memory. This is known as an *identity comparison*.
    We can override the default identity comparison behavior in our own reference
    types (a topic we’ll examine in detail in [Chapter 5](chapter5.xhtml)), but two
    references to separate instances that have identical field values compare *unequal*
    according to the default identity comparison because they refer to different objects.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, two value type instances compare equal—again by default, because
    we can modify this behavior—if all the fields of one compare equal with their
    counterparts on the other. The difference in equality comparison behavior between
    value type instances and reference type instances is directly related to their
    respective copy semantics. Since a copy of a value type instance is a new independent
    instance with identical *state*, an identity comparison makes no sense. The two
    concepts of copying and equality are therefore intimately related.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to compare two values to see whether they are equal is often underappreciated.
    Even if we rarely need to compare variables in our own code, commonly used classes
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">List<</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">T</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary<</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>,
    and the LINQ methods that work on collections may be making those comparisons
    out of sight. <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is a
    virtual method defined by the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    base class, which is a clue to how fundamental it really is, because it means
    we can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    on *any* value to compare it with any other.
  prefs: []
  type: TYPE_NORMAL
- en: However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">object.Equals</samp>
    implementation always performs an identity comparison, which, again, is pointless
    for value types. For this reason, all structs implicitly inherit the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    class. <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> overrides
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method to perform
    a value-based comparison.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between what equality means for reference types and value types
    affects the way our code behaves at run time. Consider [Listing 2-11](#list2-11),
    where the <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> type has
    not yet been allocated as a reference type or value type and does not explicitly
    override the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method.
    Here, we create two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>
    with the same value for their <samp class="SANS_TheSansMonoCd_W5Regular_11">Host</samp>
    property. What happens when we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    depends entirely on whether <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>
    is a class, record, struct, or record struct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-11: Comparing equality
    of two independent variables</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This assertion will fail if <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>
    is a class, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">object.Equals</samp>
    method will return <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> only
    if both <samp class="SANS_TheSansMonoCd_W5Regular_11">clone</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp>
    are references to the same instance, and they’re not. The assertion will pass
    if <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a struct, because
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> implementation
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    if both <samp class="SANS_TheSansMonoCd_W5Regular_11">clone</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp>
    have the same value; that is, all their fields compare equal.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">clone</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp>
    variables also compare equal if <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>
    is either a record or a record struct because they also use a value-based comparison
    for equality.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Records, Structs,
    and Value Semantics</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Records are reference types but have value-like behavior when it comes to comparing
    two record variables for equality. When a record type is compiled, the compiler
    generates a class definition with an overridden implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method unless we define one ourselves. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method generated for records compares two instances to determine if they have
    the same state, rather than just comparing two references to determine if they
    refer to the same instance.
  prefs: []
  type: TYPE_NORMAL
- en: In a struct, on the other hand, if we don’t override <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    the equality comparison relies on the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    provided by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    base class. Records, as reference types, don’t inherit from <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>.
    Record structs do inherit from <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>,
    but, as with records, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    is overridden by a compiler-generated implementation, because <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    might not be the optimal implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> implementation
    is necessarily general; it must work for *any* struct type, regardless of the
    types of the struct’s fields. If a field of the type has a custom implementation
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, instances of the
    containing type must use that field’s implementation for comparisons; a simple
    structural or bitwise comparison of the instances may not always be correct. The
    implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    provided by <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> relies
    on reflection at run time to determine how to compare the fields and will use
    an overridden implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    to compare a field if the type of that field has one.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to avoid the overhead of reflection in a struct, we must override
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> with our own implementation
    to compare each field and property with its corresponding field or property in
    the instance being compared. If each field and property value compares equal,
    using its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method where
    required, then the two instances are equal. This is essentially the implementation
    provided by the compiler for records and record structs.
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, structs, records, and record structs all employ a value-based
    comparison of their state to implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, but for records and record structs, the implementation is generated automatically
    by the compiler, freeing us from the responsibility of providing our own custom
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The variables we use for records—but not record structs—are references, and
    when we assign one record reference to another variable, we still get two references
    to the same record instance, just as we do if the type is a class. Records therefore
    have reference semantics for copying and value semantics for equality comparison.
  prefs: []
  type: TYPE_NORMAL
- en: The different comparison and copy semantics for value types and reference types
    have important consequences for the way instances of those types behave at run
    time. However, important differences also exist in the way those instances are
    created in the first place. In the next section, we’ll look at how construction
    and initialization differ depending on whether the type of the instance is a value
    type or reference type.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Construction and Initialization</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a new object is superficially a simple operation, but behind the scenes
    the compiler goes to a great deal of trouble to make the process as efficient
    as possible. In principle, creating an object involves allocating the memory for
    an instance of a type and then calling a constructor whose job is to initialize
    the instance’s fields. The syntax is identical for both value types and reference
    types, but <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp> treats them
    differently and hides some complexity around how and where different types are
    allocated in memory. In other words, the <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    expression is an abstraction that shields us from the implementation details of
    how memory is allocated and used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, the memory for reference type instances is allocated dynamically.
    When a new instance of a class or record type is created, the memory is allocated
    on the heap at run time. Instances of struct and record struct types are allocated
    differently, depending on how the resulting instance is used. Consider this code,
    which initializes a variable with a new instance of a type named <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This basic syntax for creating an object and assigning it to a variable is the
    same whether <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a class,
    struct, record, or record struct. As you’ll see over the coming sections, this
    code depends on <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> having
    an accessible constructor that can be invoked with no arguments, which isn’t necessarily
    the case when <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a
    reference type. For the time being, though, let’s assume that <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>
    instances can be created this way. If <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>
    is a class or a record, <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    causes memory to be allocated on the heap at run time and returns a reference
    to the new object, which is assigned to the <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp>
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a struct or
    a record struct, the new instance is assigned to the <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp>
    variable. However, this code may or may not allocate memory for a new instance
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> and may or may not
    call a constructor. The reason is that construction and initialization are separate
    processes. Part of the difference is related to whether a <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>
    is a value type or reference type.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Default Initialization</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Default initialization* means that each of a type’s fields, including the
    backing fields for properties, is given a default value, which is defined in the
    language to mean one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: References are set to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in numeric value type variables are set to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other value types are default-initialized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default-initialized reference type fields are a common cause of errors. For
    example, the simple <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    struct in [Listing 2-12](#list2-12) relies on us manually initializing an instance
    by setting its properties. If we neglect to set suitable values for the properties
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> instance,
    we may be rewarded with an exception when we use the instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-12: Initializing
    reference type fields</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp> causes
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference exception
    because the <samp class="SANS_TheSansMonoCd_W5Regular_11">defaultTrack</samp>
    value has been default-initialized. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>
    method calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ToUpper</samp> on its
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Artist</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>
    properties, whose default-initialized value is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    We need to be alert to any uses of default-initialized references in order to
    avoid such problems resulting from accessing a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference. One way to minimize the impact of default-initialized values is by
    providing our own instance constructors.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Instance Constructors</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An instance constructor, like a method, can have zero or more parameters. Also
    like methods, constructors can be overloaded, so we can define several constructors
    for a type, each with a different number of parameters, or parameters of different
    types. Constructor definitions for classes, structs, records, and record structs
    have many similarities, but several important differences exist.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 2-13](#list2-13), we add a constructor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    struct and use the parameter values to initialize the instance’s property values.
    We use the null-coalescing operator <samp class="SANS_TheSansMonoCd_W5Regular_11">??</samp>
    to assign an empty string for each property if its corresponding parameter is
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-13: Adding an instance
    constructor with parameters</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: By adding a constructor, we no longer have to rely on <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    users setting the properties explicitly, since the initial values for those properties
    are set in the constructor. We have made those properties <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>-only—that
    is, they can be given a value only in the constructor—and made <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> struct. However,
    we must still be cautious of using the property values inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>
    method because instances of any value type can always be default-initialized,
    regardless of the presence of a user-defined constructor definition. Adding our
    own constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    to give meaningful values to the properties isn’t sufficient protection against
    exceptions that occur from calling methods using a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference, because <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    is a struct type.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the nullable reference type feature is enabled (see “Nullable Reference
    Types” on [page 64](#sec38) for more), the constructor’s parameters will be non-nullable
    variables, meaning that passing <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    for either argument would cause a compiler warning. Using non-nullable parameters
    doesn’t mean that <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> can’t
    be passed as an argument, but we may decide that the warning is sufficient protection,
    potentially allowing us to omit the null-coalescing assignments in the constructor.
    The nullable reference type feature doesn’t, however, mean we can avoid verifying
    that the property values are not <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    prior to using them in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>
    method. Fortunately, the null-conditional operator makes the check straightforward
    and safe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here the presence of the null-conditional operator, a <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>
    appended to each property name, means that in each case the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToUpper</samp>
    method will be called only if the property is a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    value. If either property is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    the result of the expression between the braces within the string is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    which the string interpolation treats as an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'If <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> were a class
    or record, the presence of our own constructor would mean we could no longer create
    an instance without passing arguments like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we attempt to create a default-constructed instance, we get the following
    compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If we don’t provide any constructors for a class or record, the compiler inserts
    a default constructor for us. If we define a constructor when we define our own
    reference type, however, the compiler will not generate the default constructor.
    The compiler doesn’t create a default constructor for value types, but an instance
    of a struct or record struct can be default-initialized whether or not we define
    our own constructor.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Default and Generated Constructors</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The behavior of reference types and value types differs partly because reference
    types are allocated on the heap, but value types might not be. The compiler generates
    a default constructor for reference types because instances of such types are
    allocated dynamically, and their instances are initialized at run time. When a
    reference type instance is allocated on the heap, the memory for it is set to
    zero, effectively default-initializing the instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Value types are treated differently because their memory isn’t necessarily
    allocated at run time: for local value type variables, the compiler may *reserve*
    memory for the instance data, and the program accesses that memory directly. The
    underlying Common Intermediate Language (CIL) has an efficient instruction for
    default-initializing value type instances that effectively zeroes out the memory
    used by the instance, wherever its memory actually resides.'
  prefs: []
  type: TYPE_NORMAL
- en: We can think of the default initialization of a struct or record struct as being
    performed by a compiler-provided default constructor, because the result is identical
    in any case. Default-initializing value types offers a minor performance advantage
    because it doesn’t require a method call to a constructor, although it’s almost
    never the most significant optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a positional record or a positional record struct, the compiler generates
    a public constructor based on the parameters we use in the type definition, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    in this example tell the compiler to create public properties using those names
    and their types. The compiler also creates a constructor with the same signature
    as the record’s parameter list, where the properties are assigned their values.
    The constructor generated by the compiler is the equivalent of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Although the constructor has been generated by the compiler, it’s still considered
    a user-defined constructor and therefore still suppresses the default constructor
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of its type, an instance is always default-initialized when it’s
    first created, whether its memory is being allocated on the heap or elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: When we define our own constructor for a class, we can rely on all the fields
    having been default-initialized prior to the constructor’s body; the fields of
    a class are considered *initially assigned* within the constructor. In a struct’s
    constructor, the fields are *initially unassigned*, so we must definitely assign
    a value for every field of a struct or record struct, even if it’s simply to replace
    the value with its default-initialized equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Overloaded Constructors</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can provide a constructor with parameters for any type, and we can overload
    the constructor by defining several constructors that have different numbers or
    types of parameters. This is useful when we want to support different ways to
    construct our type. For instance, [Listing 2-14](#list2-14) shows a struct that
    has two constructors with differing signatures.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-14: Overloading constructors</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first constructor initializes the three properties from three separate parameters
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">green</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">blue</samp>). The second constructor
    receives a numeric representation of an RGB value and initializes the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>
    properties by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unpack</samp>
    method (not shown here) to unpack the number into its component parts. We select
    the different overloads when using the constructor by passing different arguments,
    as shown in [Listing 2-15](#list2-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-15: Selecting the
    correct overload</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the <samp class="SANS_TheSansMonoCd_W5Regular_11">orange</samp> variable
    is created using the constructor with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">uint</samp>
    parameter (the second constructor in [Listing 2-14](#list2-14)), and the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">yellow</samp> variable uses the constructor
    with three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> parameters
    (the first constructor in [Listing 2-14](#list2-14)).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Parameterless Constructors</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As noted earlier, defining our own constructor for a class type will inhibit
    the compiler-generated default constructor, meaning that we can create new instances
    of the type only by passing arguments to our own constructor’s parameters. If
    we need to create instances of such a reference type without arguments, we can
    define our own *parameterless constructor*, which we might use to initialize reference
    type fields and properties to non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    values. This is common when a class contains a collection that needs to be initialized
    but can be empty, as demonstrated in [Listing 2-16](#list2-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-16: Defining a parameterless
    constructor</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The two constructors defined here allow us to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Playlist</samp>
    either by passing a sequence of items to populate the queue ❶ or by passing no
    arguments ❷. If we pass no arguments, the <samp class="SANS_TheSansMonoCd_W5Regular_11">queue</samp>
    field is initialized as an empty queue, ensuring that it isn’t <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Both constructors initialize the <samp class="SANS_TheSansMonoCd_W5Regular_11">queue</samp>
    field by using type inference, a feature called *target-typed new*, introduced
    in C# v9.0\. The compiler deduces the type required by <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    from the type of the target variable being initialized—in this example, a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Queue< MusicTrack></samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">queue</samp>
    field is guaranteed to be non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    for any <samp class="SANS_TheSansMonoCd_W5Regular_11">Playlist</samp> instance,
    so we don’t need to check for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Playlist.Append</samp> method.
  prefs: []
  type: TYPE_NORMAL
- en: In a positional record, the compiler creates a constructor based on the positional
    arguments for the record, so by default, instances of a positional record can’t
    be created without arguments. We can define our own parameterless constructor
    for a positional record if we require that behavior. A struct or positional record
    struct, on the other hand, can *always* be created without arguments, whether
    or not we define our own constructors.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Structs and Default Values</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As of C# v10.0, we can define our own parameterless constructors for value types
    to help ensure that any reference fields are non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    However, we still need to check for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    in a value type’s implementation because an instance of a struct or record struct
    can always be default-initialized, effectively bypassing any constructors we define.
    This is illustrated in [Listing 2-17](#list2-17), where we add a parameterless
    constructor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    struct that explicitly initializes the two <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-17: Adding a parameterless
    constructor for a struct</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameterless constructor sets both reference type properties to a non-<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp> value, so calling <samp class="SANS_TheSansMonoCd_W5Regular_11">ToUpper</samp>
    on either property is safe when we’re using a <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    instance that was created using <samp class="SANS_TheSansMonoCd_W5Regular_11">new
    MusicTrack</samp>. However, this doesn’t mean we can omit the null-conditional
    checks in <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>. It’s
    still possible for <samp class="SANS_TheSansMonoCd_W5Regular_11">Artist</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> to be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    if the instance is a default-initialized <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>—for
    example, when it’s an element in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Without the checks for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>, this code would
    cause <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp> to throw a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NullReferenceException</samp> because
    the creation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">favorites</samp>
    array doesn’t call our parameterless constructor on its elements. Each element
    is default-initialized, leaving the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Artist</samp> properties with
    their default value of <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    so attempting to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToUpper</samp>
    method on a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference
    causes the exception.
  prefs: []
  type: TYPE_NORMAL
- en: Array elements are default-initialized without invoking any parameterless constructor
    we provide. The parameterless constructor is reserved for when we create a new
    instance by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Value Type Initialization</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One quite subtle consequence of the way value type instances are allocated in
    memory is that if a value type’s fields are all public, we can definitely assign
    a value for each field outside the constructor (as long as they’re not read-only),
    which results in the whole instance being fully assigned.
  prefs: []
  type: TYPE_NORMAL
- en: For example, [Listing 2-18](#list2-18) assigns a value to each field of an uninitialized
    struct variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-18: Definitely assigning
    a struct</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This code compiles, and the test passes. We can read the value of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">red</samp> field, even though we’ve never
    allocated the <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp>
    variable with <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp> or invoked
    a constructor for it. The same would be true if <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    were a record struct instead.
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates that value type variables directly contain an instance
    of their type. Assigning to each field means we don’t need to explicitly construct
    an instance. However, relying on this behavior is likely to cause other problems,
    not the least of which is that using public fields leaves the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type open to misuse, intended or not. In practice, a constructor is a much better
    way to initialize a value type’s fields, which should all be private and read-only.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if we alter the public fields to be publicly mutable properties, this
    code will fail to compile. We can’t access a property of a value type in any way
    until the instance itself has been fully, and definitely, assigned. Every property
    has a backing field generated by the compiler, and that backing field is always
    private.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Constructor Accessibility</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Constructors with parameters can be made public or private in any type. Private
    constructors are useful when we want to prevent users from creating instances
    with certain arguments. We used this technique in “[Static Creation Methods](chapter1.xhtml#sec23)”
    in Chapter 1 to force users to call the static class factory methods we defined
    in order to create certain values, rather than using the <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    keyword directly. In a class or record, we can make the parameterless constructor
    private to prevent users from creating default-constructed instances, shown for
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record in [Listing
    2-19](#list2-19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-19: Making constructors
    private for reference types</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    is marked <samp class="SANS_TheSansMonoCd_W5Regular_11">private</samp>, we can
    use it to initialize the static <samp class="SANS_TheSansMonoCd_W5Regular_11">Black</samp>
    property value and any other static or instance members of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>,
    but it’s inaccessible to code outside of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type. If users of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> forget
    and attempt to create an instance with <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>,
    the compiler forbids it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Classes and records can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">protected</samp>
    keyword on a constructor, making it available to inheriting types. Since structs
    and record structs can’t be inherited, the compiler will prevent the use of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">protected</samp> in a value type.
  prefs: []
  type: TYPE_NORMAL
- en: In a struct or record struct, if we define our own parameterless constructor,
    it *must* be public. Struct and record struct instances can *always* be default-initialized,
    whether or not we provide a parameterless constructor.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Field Initializers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a class or record definition, and in structs or record structs after C# v10.0,
    we can assign initial values to fields inline by using *field initializers*. We
    can do the same with automatic properties by using *property initializers*, which
    initialize the hidden backing field associated with the property. [Listing 2-20](#list2-20)
    uses a field initializer for the <samp class="SANS_TheSansMonoCd_W5Regular_11">queue</samp>
    field of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Playlist</samp> class
    from [Listing 2-16](#list2-16) to assign an initial value and adds a <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>
    property for <samp class="SANS_TheSansMonoCd_W5Regular_11">Playlist</samp> that
    we also assign an initial value by using a property initializer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-20: Assigning initial
    values for fields and properties</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Field and property initializers are part of object construction but are not
    applied when a value type instance is being default-initialized. Conceptually,
    initializers are applied just before the body of a constructor. As noted previously,
    the compiler creates a default constructor for class and record types if no user-defined
    or positional constructors are present; however, the compiler won’t synthesize
    a parameterless constructor for any value type. Therefore, if we want to use field
    or property initializers for struct or record struct types, we must also define
    at least one constructor of our own. This can be a parameterless constructor or
    a constructor taking one or more parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Field initializers can’t reference any instance members. However, since static
    fields are guaranteed to be definitely assigned before any instance fields, a
    field initializer can reference a static value. Static fields can also have initializers
    and can reference other static fields. However, we need to take care when referencing
    one static field from another static field because they’re initialized in the
    order in which they appear in the class.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Object Initializers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With *object initializers*, we set values for publicly mutable properties of
    a variable at the point of creating a new instance, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Classes, records, structs, and record structs accept this syntax, and they
    all behave the same way. The initialization process is the same for each: a constructor
    is invoked in the usual way to create an instance, and then the value is assigned
    to the property of the instance. In this example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    is created using a parameterless constructor (or one with all-optional parameters),
    but we can call any constructor before the initialization expression inside the
    braces. In the special case of a constructor that requires no arguments, we can
    leave out the parentheses for the constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: Classes and records require an accessible parameterless constructor to use this
    syntax. If the parameterless constructor of a class or record is hidden or nonpublic,
    we *must* invoke a valid constructor before the object initialization within the
    braces. We don’t have to worry about this for struct or record struct types because
    they can always be default-initialized if the type has no parameterless constructor.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">init-Only Properties</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As of C# v9.0, any property can be *init-only*, meaning it can be written to
    only during the creation of a new instance. Prior to C# v9.0, object initialization
    required properties to have a public <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor, meaning object initialization couldn’t be used with immutable properties.
    Object initialization requires the value of the property to be set after the constructor
    has completed, which wasn’t permitted for properties without a public <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor. An <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> accessor
    allows a property to be set during object initialization and then makes the property
    immutable after the initialization is complete.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct in [Listing
    2-21](#list2-21) demonstrates how <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only
    properties are used during object initialization.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-21: Setting properties
    as init-only</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we create the <samp class="SANS_TheSansMonoCd_W5Regular_11">orange</samp>
    variable, a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is
    first default-constructed, giving each property its default value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
    The object initializer between the braces gives new values to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp> properties, leaving
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp> property with its
    default value. Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    is a <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> struct, which
    requires that the struct has no mutable properties.
  prefs: []
  type: TYPE_NORMAL
- en: We can assign a value to an <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only
    property in an instance constructor or by using object initialization, but we
    can’t assign a new value after the instance has been created. An <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only
    property is immutable. The <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>
    accessor syntax can be used for properties and indexers for any type, although
    it was introduced in C# v9.0 to support a special initialization syntax supported
    by records and known as *non-destructive mutation*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Non-destructive Mutation</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Records and record structs support the non-destructive mutation syntax, and
    as of C# v10.0, so do structs and anonymous types. Syntactically, non-destructive
    mutation is similar to object initialization, except that it initializes a new
    instance by copying an existing one and providing new values for selected properties
    in that copy. [Listing 2-22](#list2-22) demonstrates this syntax, using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">with</samp> keyword to copy the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">orange</samp> record variable to a new
    variable named <samp class="SANS_TheSansMonoCd_W5Regular_11">yellow</samp>, and
    then assigning a new value to one of the properties of the copy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-22: Initializing
    a copy of a record with non-destructive mutation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> expression we
    use when we create the <samp class="SANS_TheSansMonoCd_W5Regular_11">yellow</samp>
    variable creates a new instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    record with property values identical to the original <samp class="SANS_TheSansMonoCd_W5Regular_11">orange</samp>
    instance. Those properties specified between the braces following <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp>
    are then assigned the values by using the same syntax as object initialization.
    This approach is called *non-destructive* mutation because no changes are made
    to the original record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructors and initializers are both ways we can create new instances with
    known values. However, sometimes we can’t provide an initial value for a variable,
    but leaving it uninitialized is too restrictive: we can’t even test it to see
    whether it has a value, owing to the rules governing definite assignment. In the
    next section, we’ll examine the options open to us when we need a variable with
    no value, and how value types and reference types differ here too.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">null Values and Default Values</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A plain value type variable can never be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    An instance of a value type directly contains all of its fields, and there’s not
    necessarily a representation of “no value.” A default-initialized instance of
    a value type is not the same thing—it’s a complete instance of the type, just
    with the default-initialized values for each of its fields.
  prefs: []
  type: TYPE_NORMAL
- en: We can employ a nullable value type, which can be assigned and compared with
    the value <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, as you’ll
    see shortly, but plain value type instances are incompatible with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> constant expression
    is a reference and therefore can be assigned only to reference variables. One
    of the implications of not being able to assign <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    to a value type variable is that we can’t pass <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    as an argument to a value type method parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, attempting to *compare* a value with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    makes no sense. If we do, as shown in [Listing 2-23](#list2-23), the compiler
    rejects the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-23: Comparing a value
    type variable with null</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The error from the compiler is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can, however, compare any reference type with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    and, as of C# v8.0, we can use a constant pattern to make this comparison more
    direct by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">is</samp> keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Comparing any value type with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    makes no sense, whatever method we choose, because <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    is a reference and as such is represented differently than a value type. That
    said, the rule against comparing value types with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    has one exception: generic types.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generics and null</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a generic class or method, an unconstrained type parameter variable can be
    compared with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. An unconstrained
    generic type can be either a value type or a reference type. To illustrate, the
    simple example in [Listing 2-24](#list2-24) compares an instance of a generic
    parameter type with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-24: Comparing a generic
    type parameter instance with null</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Compare</samp> generic method
    has a type parameter named <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    that might represent either a value type or a reference type, because it has no
    type constraints. In this instance, <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    is not known to be a value type, so the compiler allows the syntax. If <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>’s
    type is determined at run time to be a value type, the whole expression simply
    evaluates as <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler still prevents us from assigning <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    to a variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>,
    because if <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> were a value
    type, the assignment would fail at run time. Similarly, we can’t return <samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp> through an unconstrained type
    parameter, demonstrated in [Listing 2-25](#list2-25).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-25: Trying to return
    null as a generic parameter type</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the difficulty arises because <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    is unconstrained. It might represent a struct or record struct type, for which
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> is not a valid value.
    The error message gives us a clue that instead of returning <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    we can return a *default* value for <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>.
    Default values have other, more significant use cases too, but also some limitations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generics and Default
    Values</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of a default value is closely related to a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    value, especially in the context of generic types and methods. At times, we—and
    the compiler—must ensure that an instance of a generic parameter type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    is definitely assigned, even when <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>’s
    type is not known at compile time. We can’t just use <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    to make a new instance of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    because the compiler isn’t able to determine which constructors are available
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is a value type, we
    can *always* make a default instance by using default initialization or by calling
    a parameterless constructor, but if <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    is a reference type, it might not have an accessible default or parameterless
    constructor. We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    constraint on <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, meaning
    that our generic type or method will work only with types that have an accessible
    parameterless constructor, but this might be too restrictive.
  prefs: []
  type: TYPE_NORMAL
- en: In a generic type, we can use the generic parameter to denote a field or property
    of the generic parameter type. Generic value types must ensure that *all* their
    fields are definitely assigned before control leaves the constructor. To make
    that possible, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    keyword to initialize a default instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>,
    as in the generic struct shown in [Listing 2-26](#list2-26).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-26: Initializing
    a default instance of a type parameter</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> constructor,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">contained</samp> field is assigned
    the default value of its type by using the target-typed default literal (available
    since C# v7.1), which is equivalent to the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">default(T)</samp>.
    Where <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is a class or record,
    its default value is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    and where <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is a struct or
    record struct, the default value is a default-initialized instance. Note that
    initializing a value by using <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    does not invoke a parameterless constructor, if we have defined one. This code
    is valid because we can always create a default *value* for a variable of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>: if <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    is a value type, the value is a default instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>,
    and if <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is a reference type,
    a default <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> keyword has many
    uses outside of generic types and methods, but within generic code it’s indispensable.'
  prefs: []
  type: TYPE_NORMAL
- en: Default values are useful, but they’re not sufficient to identify a particular
    value type instance as invalid. In other words, we can’t use a default when what
    we really mean is *no value present*. The default value of a struct or record
    struct is a default-initialized instance and might therefore be a *valid* value.
    Consider [Listing 2-27](#list2-27).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-27: Default values
    can be valid.</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The default value for an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    type is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, which we may use
    to indicate an invalid number in some circumstances but not all. Whether that
    matters, especially for our own value types, depends on the context in which instances
    of the type are used, but limiting valid integers to only nonzero values would
    be very restrictive. Fortunately, we have an alternative.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nullable Value Types</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Nullable value types* allow us to have a representation of a value type that
    means *no value present*. A nullable value type is a wrapper around a value type,
    and a nullable value type variable may or may not have a value. A nullable value
    type variable can also be assigned the value <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    demonstrated by using a simple test in [Listing 2-28](#list2-28).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-28: Using nullable
    values</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> following the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    variable is shorthand for saying that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable< int></samp>. We can
    now represent an invalid value for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    that’s distinct from any valid values for <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    We can use a nullable variable for any value type, not just built-ins. The default
    value for a nullable is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This test passes because <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are both <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    The declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> in the
    first line doesn’t initialize a default <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    but rather a default <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable< int></samp>.
    Equality comparison between nullable values compares the underlying value if there
    is one. Two nullable values are equal if they both have no value, or values that
    themselves compare equal. <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable<
    T ></samp> is a struct and overrides the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method to provide this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a consequence of not being able to assign <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    to a plain value type variable, we can’t use a plain value type on the right-hand
    side of an <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp> expression,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> is a struct or
    record struct, this code won’t compile, because if the cast fails, the <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp>
    operator will return <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    As we know, <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> can’t be
    assigned to a value. The solution is to use a nullable value type as the source
    of the conversion, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">actual</samp>
    variable is a nullable <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    in this example and will have the value <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    if the conversion fails—that is, if the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    variable is not in fact a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    type.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nullable Reference
    Types</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C# v8.0 introduced *nullable reference types*, a feature that allows the compiler
    to warn us when a reference is or might be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    and we expect it to have a real value. While reference variables have always been
    able to have a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> value,
    the nullable reference type feature allows us to express whether we *intend* for
    them to. In other words, when we use a nullable reference type variable, we’re
    being explicit about our intention that <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    is an *expected* potential value for a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Reference variables are non-nullable by default. In the declaration in [Listing
    2-29](#list2-29), the <samp class="SANS_TheSansMonoCd_W5Regular_11">brush</samp>
    variable is a *non-nullable* reference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-29: Declaring a non-nullable
    reference variable</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler performs static analysis that enables it to issue a warning if
    a non-nullable reference can’t be guaranteed to be non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    To state that with fewer negatives, the compiler issues a warning if a value that
    may be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> is assigned to
    a non-nullable reference. In particular, assigning <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    to a non-nullable reference, as we just did, provokes this warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If we attempt to pass a possibly <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    value as an argument to a non-nullable method parameter, we’ll get a warning from
    the compiler. Consider the method in [Listing 2-30](#list2-30), which capitalizes
    the first character of each word in a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-30: Defining the
    ToTitleCase method with a non-nullable reference parameter</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Within the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>
    method, we should be able to depend on the <samp class="SANS_TheSansMonoCd_W5Regular_11">original</samp>
    parameter having a real, non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    value, because it’s a non-nullable string. That means we can avoid explicitly
    writing code to check that it isn’t <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    When we call <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>,
    if the compiler can’t guarantee that the argument we pass isn’t <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    it will give us a warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might have a legitimate need for a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference, however, in which case we mark the type of a variable as nullable to
    suppress the compiler warnings about possible null assignment. The syntax is the
    same as for nullable value types: we append a <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>
    to the type. [Listing 2-31](#list2-31) shows a collection of nullable <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    elements designated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">string?</samp>
    type name.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-31: Passing a possibly
    null argument for a non-nullable parameter</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we apply the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>
    method from [Listing 2-30](#list2-30) to this collection, we get a similar compiler
    warning as with [Listing 2-29](#list2-29), where we explicitly assigned <samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp> to a non-nullable reference
    type variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We’re given this warning because the compiler can’t guarantee that the collection
    contains no <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> elements.
    The compiler assumes any of the elements may be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    because the element type of the collection is a nullable reference.
  prefs: []
  type: TYPE_NORMAL
- en: If we explicitly check each element before making the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>,
    the compiler can determine that we’re not using a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference as an argument to the method. To achieve that, we could unpack the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> expression into a loop,
    such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> loop
    in [Listing 2-32](#list2-32).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-32: Explicitly using
    a non-null reference</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This code doesn’t prompt a warning about the argument in the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>
    because the compiler can perform enough analysis on the code preceding the method
    call to guarantee that the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    argument isn’t <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes the compiler needs our help to determine whether it’s safe
    to assign a variable to a non-nullable reference or to call a method with a non-nullable
    parameter. [Listing 2-33](#list2-33) shows a slightly modified version of [Listing
    2-31](#list2-31) calling <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>,
    where any <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> elements are
    filtered out before the method is called.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-33: Removing null
    elements before the method call</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This code gives us the same warning as in [Listing 2-31](#list2-31), however,
    because the compiler can’t be certain <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>
    won’t be invoked with a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    argument. Although it looks as if the check for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    is being made inline, in fact we’re calling a lambda function to make that comparison,
    and the compiler doesn’t attempt to analyze every possible code path to make this
    safe. Fortunately, we have a workaround.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Null-Forgiving
    Operator</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use the *null-forgiving operator* to inform the compiler that we definitely
    know what we’re doing and that no <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    references are used as arguments to a non-nullable parameter. The null-forgiving
    operator is an <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp> appended
    to the variable, which is why it’s also referred to as the *dammit operator,*
    as in, “It’s definitely not <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    dammit!” When we’ve filtered out all the <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    elements from our collection, we apply the dammit operator to the argument for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>, as shown in
    [Listing 2-34](#list2-34).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-34: Using the null-forgiving
    operator</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Using the null-forgiving operator with the argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>
    convinces the compiler that it is safe to call the method having a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference type parameter. If we were to inadvertently pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference, we’d (justifiably) get the dreaded <samp class="SANS_TheSansMonoCd_W5Regular_11">Object
    reference not set to an instance of an object</samp> exception. We must take care
    when using the null-forgiving operator that we really do know that the variable
    can’t be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Nullable reference types, while having the same syntax as nullable value types,
    are just a device that indicates to the compiler that we’re making certain assumptions
    about the variable. Unlike nullable value types, which are underpinned by a distinct
    type with behavior injected by the compiler, nullable reference types are a purely
    compile-time mechanism, used for static analysis, and do not change the behavior
    of our code in any way. At run time, nullable and non-nullable references are
    just references. Nevertheless, distinguishing between them in code is useful for
    encoding our assumptions about nullability.
  prefs: []
  type: TYPE_NORMAL
- en: Unexpected <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference
    exceptions are the curse of many programs and a class of error that programmers
    everywhere go to great lengths to try to avoid. The nullable reference type feature
    of modern C# is one that shifts some of that responsibility away from the programmer
    and onto the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*My goal was to ensure that all use of references should be absolutely safe,
    with checking performed automatically by the compiler. But I couldn’t resist the
    temptation to put in a null reference, simply because it was so easy to implement.
    This has led to innumerable errors, vulnerabilities, and system crashes, which
    have probably caused a billion dollars of pain and damage in the last forty years.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Tony (C.A.R.) Hoare
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The type system in C# is broadly similar to many other programming languages,
    including its support for user-defined types. C# differs in its distinction between
    reference types and value types. Although there are various recommendations on
    when to choose to define a value type instead of a reference type, including documentation
    from Microsoft, those guidelines often take only part of the story into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: The technical purpose of distinguishing value types from reference types is
    to allow the compiler and Common Language Runtime to make assumptions about values
    that may allow certain opportunities for optimization. Some of the differences
    we’ve discussed result from the way reference and value type instances are stored
    and managed in memory. That value type variables are not independently subject
    to garbage collection can itself be a big win. However, we can’t just turn our
    classes into structs or record structs and expect that our programs will suddenly
    use less memory or run more quickly. Value semantics involves much more than just
    declaring something as a value type.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, the copy-by-value behavior of value types is more than just a side
    effect of the way values use memory. Copying by value gives rise to many of the
    constraints that are imposed on value types and for which reference types have
    no need. Using value types where they’re appropriate can make our code clearer
    and simpler in subtle ways, like not having to check for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    values on every use of a value. The characteristics of copying values also affect
    the behavior of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method; although comparing variables to see if they are equal may sound inconsequential,
    it’s an essential aspect of working with variables.
  prefs: []
  type: TYPE_NORMAL
- en: The distinction between value types and reference types, then, is not just a
    list of *restrictions*. Genuine semantic differences affect our programs’ behavior
    and can bring tangible benefits. One advantage of value types is that they can
    never be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. Constantly
    having to check references to ensure that they’re valid can be tiresome and error-prone.
    Using the non-nullable reference type feature is one way we reduce the occurrence
    of unexpected errors arising from dereferencing a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: One of the great strengths of C# being a compiled and type-safe language is
    that the compiler can identify many kinds of errors *before* our program is ever
    run.
  prefs: []
  type: TYPE_NORMAL
