- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">VALUE
    AND REFERENCE TYPES</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp> <samp class="SANS_Dogma_OT_Bold_B_11">值类型与引用类型</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: We can create new types in C# in several ways, and we need to consider the individual
    characteristics of each approach to determine which best suits our goals. In particular,
    knowing how value types differ from reference types helps us choose the right
    way forward, because these differences have significant and sometimes unconsidered
    implications when we’re defining our own types. Certain trade-offs will affect
    how we design our type and what we can use it for. In this chapter, we’ll investigate
    those differences and what they mean for our programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过多种方式在 C# 中创建新类型，并且我们需要考虑每种方法的个别特征，以确定哪种方法最适合我们的目标。特别是，了解值类型与引用类型的区别有助于我们选择合适的前进方式，因为这些差异在定义我们自己的类型时，可能会带来重要且有时未曾考虑到的影响。某些权衡将影响我们如何设计类型以及可以将其用于哪些场景。在本章中，我们将探讨这些差异以及它们对我们程序的意义。
- en: 'We’ll explore the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨以下内容：
- en: What choices we have when creating our own types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们自己类型时可选择的选项
- en: Why C# has both reference types and value types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么 C# 同时具有引用类型和值类型
- en: How choosing one or the other affects construction, null checking, and other
    type behavior
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择其中一种类型如何影响构造、空值检查以及其他类型行为
- en: Why value type is not the same as value semantics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么值类型不同于值语义
- en: Where different types are stored in memory and how that affects an object’s
    lifetime
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型如何在内存中存储，以及这如何影响对象的生命周期
- en: <samp class="SANS_Futura_Std_Bold_B_11">User-Defined Types</samp>
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">用户定义类型</samp>
- en: 'Most modern programming languages allow you to create custom types. The basic
    principles of user-defined types in C# will be familiar to programmers of many
    other languages, but some of the details are different. Therefore, in this section
    we’ll examine the four kinds of user-defined types: structs, classes, and the
    newer records and record structs (introduced in C# v9.0 and v10.0, respectively).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代编程语言都允许你创建自定义类型。C# 中用户定义类型的基本原理对于许多其他语言的程序员来说是熟悉的，但一些细节有所不同。因此，在本节中，我们将探讨四种用户定义类型：结构体、类以及较新的记录类型和记录结构体（分别在
    C# v9.0 和 v10.0 中引入）。
- en: It’s important to recognize that the behavior of these types relies heavily
    on whether they are reference types or value types. Let’s look briefly at each
    kind of user-defined type with these differences in mind.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这些类型的行为在很大程度上依赖于它们是引用类型还是值类型。让我们简要看看每种用户定义类型，并考虑这些差异。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Structs and Classes</samp>
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">结构体与类</samp>
- en: '[Listing 2-1](#list2-1) defines a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp>
    to represent colors.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-1](#list2-1) 定义了一个简单的 <samp class="SANS_TheSansMonoCd_W5Regular_11">结构体</samp>
    来表示颜色。'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-1: Defining a simple
    struct</samp>'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 2-1：定义一个简单的结构体</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct is marked
    <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> to indicate that
    instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> are immutable—that
    is, they never change their value. Correspondingly, none of the three properties
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>) has a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor, so their values can’t be changed after they’ve been given initial values
    using the constructor.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 结构体被标记为 <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>，表示
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 的实例是不可变的——也就是说，它们的值永远不会改变。相应地，三个属性（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>）都没有 <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    访问器，因此在使用构造函数初始化它们的值之后，它们的值不能再被更改。
- en: The constructor in this example uses the expression body syntax (<samp class="SANS_TheSansMonoCd_W5Regular_11">=></samp>),
    which you saw in [Chapter 1](chapter1.xhtml), instead of a body enclosed between
    braces <samp class="SANS_TheSansMonoCd_W5Regular_11">{…}</samp>. We make the expression
    body a single-line statement by using *tuple assignment*, which assigns the tuple
    of three parameter values <samp class="SANS_TheSansMonoCd_W5Regular_11">r</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    to the tuple of three properties. The compiler translates this syntax into an
    efficient assignment from the parameter values directly to the respective backing
    fields for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>
    properties.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> keyword in
    the struct’s definition is not mandatory but reinforces that instances of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> are immutable. Immutable
    value types make our code easier to comprehend and may allow some optimizations
    by the compiler.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, if we define a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    class instead of a struct, we can’t use the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>
    keyword in its definition, although we can make it immutable by not providing
    <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessors for the properties.
    The only other difference in defining <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    as a class is the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp>
    keyword in the definition:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    is otherwise identical to that in [Listing 2-1](#list2-1).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The principal difference between these two types is that a class is a reference
    type, and a struct is a value type. Before we analyze the implications of this
    difference, let’s look at record and record struct types.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Records and Record
    Structs</samp>
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of C# v9.0, we can define a record type with the <samp class="SANS_TheSansMonoCd_W5Regular_11">record</samp>
    keyword. Records introduce a new syntax for compactly defining a type. [Listing
    2-2](#list2-2) creates a record type named <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-2: Defining a record</samp>'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: This example shows a *positional* record; the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type has no body, but the type definition has its own positional parameters that
    are used by the compiler to generate a complete type. Behind the scenes, the compiler
    translates the record into a class definition, meaning that records are reference
    types. The compiler also translates the parameter names <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>
    into public properties of the same name, along with a public constructor with
    matching parameters to initialize the property values. The positional parameters
    are also used by the compiler to generate other methods, including <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>,
    which are overrides of their counterparts in the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    base class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了一个 *位置型* 记录；<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    类型没有定义主体，但类型定义有自己的位置参数，编译器使用这些位置参数来生成完整的类型。在后台，编译器将记录转换为类定义，这意味着记录是引用类型。编译器还将参数名称
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp> 转换为同名的公共属性，并生成一个公共构造函数，通过匹配的参数初始化属性值。位置参数也被编译器用来生成其他方法，包括
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>，这些方法是对 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    基类中对应方法的重写。
- en: '[Listing 2-3](#list2-3) creates a new instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    record and uses its properties exactly as if it were a class or a struct.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-3](#list2-3) 创建了一个新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    记录实例，并像使用类或结构体一样使用其属性。'
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-3: Creating an instance
    of Color</samp>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 2-3：创建 Color 实例</samp>
- en: Here, we use named arguments when constructing the <samp class="SANS_TheSansMonoCd_W5Regular_11">tomato</samp>
    variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> to
    emphasize the names given by the compiler to the constructor parameters. Note
    that the property names used in the assertions are identical to the names used
    in the constructor, and that both match the names used in the record definition.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在构造类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">tomato</samp> 变量时使用了命名参数，以强调编译器为构造函数参数所赋予的名称。请注意，断言中使用的属性名称与构造函数中使用的名称完全相同，并且都与记录定义中的名称一致。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*One important difference between records and structs or classes relates to
    handling equality comparisons between two instances, a topic we’ll examine in
    more detail in “Identity Equality vs. Value Equality” on [page 47](#sec19).*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*记录与结构体或类之间的一个重要区别，涉及到处理两个实例之间的相等比较，这是我们将在“身份相等与值相等”一节中更详细地讨论的主题，见[第47页](#sec19)。*'
- en: 'Very closely related to records are record structs, introduced in C# v10.0\.
    In contrast to records, which are compiled as classes, record structs are translated
    by the compiler into struct definitions, making them value types. Otherwise, they’re
    the same as records. Record structs are denoted by the <samp class="SANS_TheSansMonoCd_W5Regular_11">record
    struct</samp> keywords, as shown here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与记录紧密相关的是记录结构体，它是在 C# v10.0 中引入的。与记录不同，记录结构体被编译为结构体定义，使它们成为值类型。除此之外，它们与记录相同。记录结构体由
    <samp class="SANS_TheSansMonoCd_W5Regular_11">record struct</samp> 关键字标识，如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This record struct, much like the struct in [Listing 2-1](#list2-1), is marked
    <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>. If we left out
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> keyword, the
    properties generated by the compiler would be read-write properties, with both
    <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessors. Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>
    keyword makes <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> an immutable
    record struct.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个记录结构体，就像[清单 2-1](#list2-1)中的结构体一样，被标记为<samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>。如果我们省略了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>关键字，编译器生成的属性将是读写属性，既有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">get</samp>访问器，也有<samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>访问器。使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>关键字使得<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>成为不可变的记录结构体。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Inheritance</samp>
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">继承</samp>
- en: One common way of representing relationships between classes and between records
    is to use *inheritance*, or deriving one type from another. However, we can’t
    apply inheritance to structs or record structs; it’s available only to reference
    types.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表示类与类之间、记录与记录之间关系的常见方法是使用*继承*，即将一个类型从另一个类型派生。然而，我们不能将继承应用于结构体或记录结构体；它仅适用于引用类型。
- en: Another restriction of inheritance is that a record can inherit from another
    record but not explicitly from a class. Similarly, classes can’t inherit from
    records. In every other respect, records follow the same rules and have the same
    characteristics as classes as far as inheritance is concerned. Classes and records
    can define virtual methods and properties, allowing a more derived type to provide
    its own behavior by overriding the method or property, and we can choose to ignore,
    override, or hide any virtual methods in a derived type.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的另一个限制是，记录可以继承自另一个记录，但不能显式地继承自类。同样，类也不能继承自记录。在其他方面，记录与类在继承方面遵循相同的规则，并具有相同的特性。类和记录可以定义虚方法和属性，允许更派生的类型通过重写方法或属性来提供其自己的行为，我们可以选择忽略、重写或隐藏派生类型中的任何虚方法。
- en: In contrast, structs and record structs are implicitly *sealed*, meaning that
    inheriting from them is prohibited. If we attempt to derive from a struct or record
    struct, we get a compile-time error. Structs and record structs can’t inherit
    from another user-defined type either.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，结构体和记录结构体默认是*密封的*，这意味着禁止从它们继承。如果我们试图从结构体或记录结构体派生，将会遇到编译时错误。结构体和记录结构体也不能从其他用户定义的类型继承。
- en: Another restriction for a class or record is that it can inherit from only one
    base type. Any attempt at multiple inheritance results in a compiler error. If
    no base type is explicitly specified, <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    becomes the implied base class. As you’ll see in “The Common Type System” on [page
    45](#sec16), every type ultimately inherits from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>,
    either directly or indirectly. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>
    class in [Listing 2-4](#list2-4) implicitly derives from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>,
    while the <samp class="SANS_TheSansMonoCd_W5Regular_11">DummyCommand</samp> class
    derives explicitly from <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>,
    implicitly inheriting from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    via the <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> base class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类或记录的另一个限制是它只能继承一个基类型。任何多重继承的尝试都会导致编译器错误。如果没有显式指定基类型，<samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>将成为隐式的基类。正如你在“公共类型系统”章节中看到的，在[第45页](#sec16)，每个类型最终都会直接或间接地继承自<samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp>。例如，[清单 2-4](#list2-4)中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>类隐式继承自<samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>，而<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DummyCommand</samp>类则显式继承自<samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>，通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>基类隐式继承<samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>。
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-4: Inheritance syntax</samp>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 2-4：继承语法</samp>
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp> base class
    defines a virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">RunQuery</samp>
    method, which is overridden in the derived <samp class="SANS_TheSansMonoCd_W5Regular_11">DummyCommand</samp>
    class to alter the method’s behavior. A stub implementation like <samp class="SANS_TheSansMonoCd_W5Regular_11">DummyCommand</samp>
    might be used during testing to avoid having the test code depend on the underlying
    data store’s contents.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个<samp class="SANS_TheSansMonoCd_W5Regular_11">Command</samp>基类定义了一个虚方法<samp
    class="SANS_TheSansMonoCd_W5Regular_11">RunQuery</samp>，该方法在派生类<samp class="SANS_TheSansMonoCd_W5Regular_11">DummyCommand</samp>中被重写，以改变方法的行为。像<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DummyCommand</samp>这样的存根实现可能在测试中使用，以避免测试代码依赖于底层数据存储的内容。
- en: Any type may *implement* multiple interfaces, but it’s important to understand
    that inheritance is quite different from interface implementation. When we implement
    an interface, the implementing method is, by default, *not* virtual. A class or
    record implementing a method from an interface can choose to make its implementation
    of the method virtual, but a struct or record struct cannot.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型都可以*实现*多个接口，但重要的是要理解继承与接口实现是完全不同的。当我们实现一个接口时，默认情况下，实现的方法*不是*虚方法。一个实现了接口方法的类或记录可以选择将其方法实现标记为虚方法，但结构体或记录结构体不能这么做。
- en: We can explicitly designate any member of a class or record as <samp class="SANS_TheSansMonoCd_W5Regular_11">protected</samp>,
    as opposed to <samp class="SANS_TheSansMonoCd_W5Regular_11">public</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">private</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">internal</samp>.
    A protected member is accessible within the class declaring it and to any types
    that inherit from that class, but it’s not visible to any other code. Since value
    types are sealed, it makes no sense for them to have virtual or protected members.
    If we try to make a method virtual in a value type definition or to define any
    protected fields, properties, or methods, we’re rewarded with a compiler error.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以显式地将类或记录的任何成员指定为<samp class="SANS_TheSansMonoCd_W5Regular_11">protected</samp>，与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">public</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">private</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">internal</samp>相对。受保护的成员可以在声明它的类内部访问，也可以在继承该类的任何类型中访问，但对其他代码不可见。由于值类型是封闭的，因此它们不可能拥有虚方法或受保护的成员。如果我们试图在值类型定义中将方法声明为虚方法，或定义任何受保护的字段、属性或方法，编译器将报错。
- en: We can choose to declare a class or record type as <samp class="SANS_TheSansMonoCd_W5Regular_11">sealed</samp>
    so that it can’t be used for further inheritance. Sealing a class does not affect
    what *it* can inherit, only what can inherit from it. It’s common to seal classes
    that have value-like characteristics, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>,
    or when we wish to restrict a class’s behavior to that defined in our own implementation.
    If a class is intended to be immutable, whether or not it’s intended to have value-like
    characteristics, sealing it ensures that its immutability can’t be subverted by
    a mutable derived class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择将类或记录类型声明为<samp class="SANS_TheSansMonoCd_W5Regular_11">sealed</samp>，这样就不能再被继承。封闭类不会影响它自己能继承什么，只影响什么可以继承它。通常会封闭具有值类型特征的类，如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">string</samp>，或者当我们希望限制类的行为仅限于我们自己的实现时。如果一个类被设计为不可变的，无论它是否具有值类型特征，封闭它可以确保其不可变性不会被可变的派生类破坏。
- en: Records are specifically intended to be value-like types and have value-like
    behavior defined for them by the compiler. This means we should seal record types
    unless we have a compelling reason not to do so. We’ll look in detail at the meaning
    of *value-like* and why such types should be sealed in [Chapters 6](chapter6.xhtml)
    and [7](chapter7.xhtml).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类型专门用于作为值类型，并由编译器定义了值类型行为。这意味着除非有充分的理由，否则我们应当封闭记录类型。我们将在[第6章](chapter6.xhtml)和[第7章](chapter7.xhtml)中详细讨论*值类型*的含义，以及为什么这样的类型应当被封闭。
- en: Inheritance is a central feature of object-oriented code, but it applies exclusively
    to reference types. Inheritance—as well as the features that support it, such
    as virtual methods—is not appropriate for value types, in part because of the
    way value type instances use memory.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是面向对象代码的核心特性，但它仅适用于引用类型。继承以及支持继承的特性（如虚方法）并不适用于值类型，部分原因是值类型实例使用内存的方式不同。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Type Instance Lifetimes</samp>
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">类型实例生命周期</samp>
- en: Value types and reference types differ in the way each uses memory and, more
    specifically, in the lifetime of their instances. Value type instances are short-lived,
    and their lifetime is bound to the lifetime of the variables that represent them.
    For value types, the variable *is* the instance; when we create a new instance
    of a value type, the target variable effectively contains the instance data—that
    is, the value of each field of the type.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型和引用类型在内存使用方式上有所不同，具体来说，主要体现在它们实例的生命周期上。值类型实例的生命周期较短，它们的生命周期与表示它们的变量的生命周期绑定。对于值类型来说，变量*就是*实例；当我们创建一个值类型的新实例时，目标变量实际上包含了实例数据——也就是类型中每个字段的值。
- en: In many cases, the lifetime of a variable is defined by a block, such as a method
    body or a <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> loop. Any
    local variables within the block cease to exist when the block ends. Alternatively,
    a variable might be contained in another object, in which case the variable’s
    lifetime is defined by the lifetime of the enclosing object. Whenever we copy
    a value type variable by assigning it to another variable or passing it as an
    argument to a method, the copy is a whole new instance of the type in a *different*
    variable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，变量的生命周期由一个代码块定义，比如方法体或一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp>
    循环。块内的任何局部变量在块结束时会停止存在。另一种情况是，变量可能被包含在另一个对象中，在这种情况下，变量的生命周期由包含对象的生命周期决定。每当我们通过将值类型变量赋值给另一个变量或将其作为参数传递给方法来复制变量时，这个副本就是类型的一个全新实例，存储在*不同*的变量中。
- en: Reference type instances, on the other hand, are generally long-lived and can
    be referred to by many variables. When we create a new instance of a reference
    type, we’re given a reference to that instance in memory. Whenever we copy that
    reference, we’re not also copying the instance. The original reference and the
    copy both refer to the same instance. References are stored in *reference variables*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，引用类型实例通常生命周期较长，并且可以被多个变量引用。当我们创建一个引用类型的新实例时，我们会获得该实例在内存中的引用。每当我们复制该引用时，我们并不是在复制实例。原始引用和副本都指向相同的实例。引用存储在*引用变量*中。
- en: All reference type instances are allocated on the heap. Their lifetime is managed
    by automatic garbage collection, which releases their memory when they’re no longer
    needed by the program. An object is considered unused when the garbage collector
    determines that no other live references to that instance exist. While reference
    type instances are not subject to their scope, reference variables *are* subject
    to scope, so when one goes out of scope, it’s no longer a live reference to an
    instance. The lifetime of a reference type instance, then, is determined by the
    lifetimes of *all* the references to that instance.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所有引用类型实例都分配在堆上。它们的生命周期由自动垃圾回收管理，当程序不再需要它们时，垃圾回收会释放它们的内存。当垃圾回收器确定没有其他活动引用指向该实例时，对象被认为是未使用的。虽然引用类型实例不受其作用域的限制，但引用变量*是*受作用域限制的，因此当引用变量超出作用域时，它将不再是对实例的有效引用。因此，引用类型实例的生命周期由*所有*指向该实例的引用的生命周期决定。
- en: A cost is associated with being allocated on the heap, because the garbage collection
    process takes time while the program is running. Ensuring that unused heap memory
    is properly cleaned up is a complex operation and may interrupt a program’s normal
    execution for a short time, so an overhead is associated with reference types.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 分配到堆上是有代价的，因为垃圾回收过程需要时间，而程序在运行时必须处理它。确保未使用的堆内存被适当地清理是一项复杂的操作，并且可能会在短时间内中断程序的正常执行，因此引用类型会有额外的开销。
- en: Value types don’t require the overhead associated with garbage collection. The
    memory used by a value type instance can be freed when the lifetime of its variable
    ends. To understand lifetime a little better, let’s look more closely at what
    we mean by *variable* in different contexts.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型不需要与垃圾回收相关的开销。当值类型实例的变量生命周期结束时，它所使用的内存可以被释放。为了更好地理解生命周期，我们可以更仔细地看一下在不同上下文中*变量*的含义。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Variables</samp>
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">变量</samp>
- en: 'A *variable* is simply a named area of memory. We use this name—or *identifier*—
    to manipulate a memory location during the variable’s lifetime. C# has five main
    kinds of variables:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量*只是一个命名的内存区域。我们使用这个名称——或者*标识符*——来在变量的生命周期内操作内存位置。C# 有五种主要的变量类型：'
- en: '**Local variables**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**局部变量**'
- en: These are block-scope variables, where a *block* might be a method with a statement
    body, the body of a loop, or any section of code delimited by matching braces,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>. When control leaves a
    block at the closing brace, any variables that are local to the block go out of
    scope. When an exception is thrown in a block, the control flow also leaves that
    scope and any containing scope until the exception is caught or the program exits.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是块作用域变量，其中一个*块*可能是一个带有语句体的方法、循环体，或是任何由匹配的大括号 <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>
    限定的代码块。当控制流离开一个块时，位于该块内的局部变量将超出作用域。当一个异常在块内被抛出时，控制流也会离开该作用域以及任何包含该作用域的范围，直到异常被捕获或程序退出。
- en: '**Instance fields**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**实例字段**'
- en: These are normal data members, known as *fields*, of structs and non-static
    classes. Each instance of a type has its own copies of any instance fields. The
    lifetime of an instance field is defined by the lifetime of the object to which
    it belongs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是结构体和非静态类的普通数据成员，称为*字段*。每个类型的实例都有其自身的字段副本。实例字段的生命周期由它所属对象的生命周期决定。
- en: '**Static fields**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态字段**'
- en: These fields are associated with a type, rather than individual instances of
    the type. The lifetime of a static field is normally tied to an application, so
    the instances associated with static fields are usually released when an application
    exits.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段与类型相关，而不是与类型的单个实例相关。静态字段的生命周期通常与应用程序绑定，因此与静态字段关联的实例通常在应用程序退出时被释放。
- en: '**Array elements**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组元素**'
- en: Individual elements in an array are all variables. We can access a particular
    element by its index and alter the element instance if it is mutable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的各个元素都是变量。我们可以通过索引访问特定元素，并且如果该元素是可变的，可以修改其实例。
- en: '**Method parameters**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法参数**'
- en: The parameters in a method definition are technically called *formal parameters*
    but are commonly known as just *parameters*. A parameter’s scope is the body of
    the method, exactly as if the parameter were declared as a local variable within
    the method’s body. In code that calls a method, we pass *actual parameters*, better
    known as *arguments*, that correspond to the method’s parameters.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义中的参数技术上称为*形式参数*，但通常称为*参数*。参数的作用域是方法体，就像该参数在方法体内被声明为局部变量一样。在调用方法的代码中，我们传递与方法参数对应的*实际参数*，更常被称为*实参*。
- en: Regardless of its kind, a variable always has an associated type. This might
    be an explicitly declared type, as in the declaration <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    size</samp>, or, for local variables, the type might be implied with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">var</samp> keyword. If the variable’s
    type is a reference type, the variable’s *value* is a reference. A non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference is a handle to an instance somewhere on the heap. If the variable’s
    type is a value type, the variable’s value is an instance of the type.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 无论类型如何，变量总是有一个关联类型。这可能是显式声明的类型，比如声明 <samp class="SANS_TheSansMonoCd_W5Regular_11">int
    size</samp>，或者对于局部变量，类型可能通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    关键字隐式推断。如果变量的类型是引用类型，则该变量的*值*是一个引用。非<sup class="SANS_TheSansMonoCd_W5Regular_11">null</sup>的引用是指向堆中某个实例的句柄。如果变量的类型是值类型，则变量的值是该类型的一个实例。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variables vs. Values</samp>
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">变量与值</samp>
- en: 'It’s not always easy to intuit what counts as a variable and what counts as
    a value, but the distinction is important:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 判断什么是变量、什么是值并不总是直观的，但这种区分很重要：
- en: '*Variables* can be assigned to, although a <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>
    field variable can be assigned only within a constructor of the type of which
    it is a member, or using field initialization (which we’ll discuss in “Field Initializers”
    on [page 58](#sec30)).'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*变量*是可以赋值的，尽管<sup class="SANS_TheSansMonoCd_W5Regular_11">readonly</sup>字段变量只能在其类型的构造函数中赋值，或者通过字段初始化赋值（我们将在“字段初始化器”一节中讨论，[第58页](#sec30)）。'
- en: '*Values* are the results of expressions—such as the result of calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">new</samp>, the return value from a method,
    or a constant expression such as a literal number or <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    literal. Values *can’t* be assigned to, but we use them to initialize variables
    by using assignment or passing them as arguments to method parameters.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*值*是表达式的结果——例如调用<samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>的结果、方法的返回值，或者常量表达式，如字面量数字或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">string</samp>字面量。*值*不能被赋值，但我们通过赋值或将它们作为参数传递给方法来初始化变量。'
- en: 'Variables, for the most part, have names. Strictly speaking, individual array
    elements don’t have their own names, but for an array variable <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>,
    the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">arr[</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">index</samp>] is essentially
    the element’s identifier. A value can have a name but doesn’t require one: the
    expression <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> produces a new value, but
    it is anonymous unless we assign that value to a variable.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 变量大多数情况下都有名称。严格来说，单个数组元素没有自己的名称，但对于一个数组变量<samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>，表达式<samp
    class="SANS_TheSansMonoCd_W5Regular_11">arr[</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">index</samp>]
    本质上是元素的标识符。一个值可以有名称，但不需要有名称：表达式<samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    生成一个新值，但它是匿名的，除非我们将该值赋给一个变量。
- en: The type of a value defines what an *instance* looks like. Among other things,
    the type might have multiple fields that need space allocated in memory when an
    instance of the type is created. The type of a variable defines the sort of value
    it can contain.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 值的类型定义了*实例*的样子。除此之外，类型可能有多个字段，当类型的实例创建时，需要在内存中分配空间。变量的类型定义了它可以包含的值的种类。
- en: A value is just a pattern of bits. The type is a formal specification for interpreting
    that bit pattern to give it meaning in a program. Two values with identical bit
    patterns may be interpreted differently if they are different types. A pattern
    of bits that are all <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> means
    one thing if the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>,
    but something else entirely if the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值仅仅是位模式。类型是一个正式的规范，用来解释该位模式并赋予它在程序中的意义。如果两个值具有相同的位模式，但它们的类型不同，它们可能会被不同地解释。如果类型是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">long</samp>，则一组全是<samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>的位表示一种含义；如果类型是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>，则它完全表示另一种含义。
- en: A variable of value type directly contains its data, whereas a variable of reference
    type contains a reference to its data. More precisely, reference variables have
    a value that is a reference to an object somewhere on the heap. Put simply, a
    reference refers to an instance of a reference type; the value of a reference
    type variable is a reference.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型的变量直接包含其数据，而引用类型的变量包含对其数据的引用。更准确地说，引用变量的值是对堆中某个对象的引用。简单来说，引用是指向引用类型实例的；引用类型变量的值是一个引用。
- en: The relationship between variables and values is that all variables *have* a
    value, although the value can’t be accessed until the variable has been definitely
    assigned.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 变量和值之间的关系是所有变量*都有*一个值，尽管在变量被确定赋值之前无法访问该值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Definite Assignment</samp>
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">确定赋值</samp>
- en: We can’t read the value of a variable unless the compiler is satisfied that
    the variable has definitely been given an initial value. More formally, a variable
    can be read only after a value has been *definitely assigned* to it. The C# Language
    Specification precisely defines what constitutes definite assignment, but the
    essence is that a variable must have been assigned or initialized with a value
    at least once before its value is read.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法读取一个变量的值，除非编译器确认该变量已经被明确地赋予了初始值。更正式地说，只有在变量*已确定赋值*之后，才能读取它的值。C#语言规范精确定义了什么构成了确定赋值，但本质上是变量必须至少被赋值或初始化一次，才能读取它的值。
- en: If we try to obtain the value of any variable that hasn’t been definitely assigned,
    the compiler raises an error to tell us that this isn’t allowed. For example,
    when we declare a local variable within a method, it is uninitialized unless or
    until we assign a value to it. Such variables are initially considered *un*assigned.
    Conceptually, at least, an unassigned variable doesn’t have a value.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: When we assign something to a variable, we give that variable a new value. When
    we read from a variable, we obtain its value. Variables and values are both *expressions*,
    meaning we can evaluate them to produce a value, as long as they have been definitely
    assigned.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, attempting to read a value from any variable that hasn’t yet been
    definitely assigned is an error. When we use a <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp>
    declaration for a local variable, we must provide an initial value where the variable
    is declared, because the type of the variable is inferred from the type of the
    value being assigned to it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Instances and Storage</samp>
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve clearly defined variables and values, we can explore how they
    relate to type instances. Whether an instance is a value type or a reference type
    affects where it is allocated and managed in memory; as a result, value type variables
    have some peculiarities that don’t apply to references.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Value types do not always live on the stack, despite common misconceptions.
    Values for local variables are most often tied to the block scope of a method,
    and so might be associated with a stack frame for the method, but values can also
    be contained within another object as a member or an element in an array. Let’s
    examine this more closely by looking at some examples of how variables are embedded
    in objects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Embedded Values</samp>
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a variable is a field embedded within an instance of another type, its value
    is allocated within the memory for its enclosing object. This is especially important
    for value type variables that directly contain the instance of their type. Consider
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct in [Listing
    2-5](#list2-5).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-5: Defining a Color
    struct with multiple fields</samp>'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct has three
    properties representing the components of an RGB color. When a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    value is used as a field or property in a class, an instance of that class will
    wholly contain a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value
    on the heap. Take, for example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    class in [Listing 2-6](#list2-6), which has several fields, one of which is a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-6: A Color value
    embedded within the Brush class</samp>'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> type is a class
    and therefore a reference type. When we create an instance of any reference type,
    it’s allocated on the heap. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    class has three fields, one of which is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instance, which itself has three fields (<samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>).
    An instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> might
    look roughly like [Figure 2-1](#fig2-1) in memory.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-1.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: A Color value embedded
    in a Brush instance on the heap</samp>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: When we create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>,
    the instance is created on the heap and we’re given a reference to it. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">color</samp> field occupies memory directly
    within the memory space for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    instance. If we implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    as a record struct instead of a struct, the outcome would be the same. Record
    structs are value types in exactly the same way as structs and are allocated directly
    within the memory space of any enclosing object.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Value type instances are not individually garbage collected, but if a value
    type instance is embedded in another object that has been allocated on the heap,
    the *memory* used by the value type instance will be reclaimed during garbage
    collection of the enclosing object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The lifetime of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instance represented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp>
    field is tied to the lifetime of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    instance. When the garbage collector determines that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    instance is no longer used, it will free up the memory for that instance, including
    the embedded <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Array Elements</samp>
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When a value type instance is an element in an array, it isn’t (strictly speaking)
    a field of the array object, but the value is still embedded within the memory
    for the array. Arrays are always allocated on the heap, regardless of the type
    of their elements. When we create an array, we’re given a reference to it. To
    illustrate, consider this array of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    values, where <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is a
    struct:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp> variable here
    is a reference to an array of three <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances on the heap. The memory layout of the <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp>
    array might look like [Figure 2-2](#fig2-2).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-2.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: An array of Color
    structs in memory</samp>'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: In the <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp> array, each
    element is large enough to store the three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    backing fields. If the element type had more fields, each element would require
    more space on the heap. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type were a record struct rather than a struct, the layout would be identical;
    recall that the compiler translates record structs into structs.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Reference variables, by contrast, are all the same size, regardless of the number
    of fields declared in the type definition. The memory required for an array of
    references is determined only by the number of elements, not the size of each
    instance.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Whether the elements of an array are references or value type instances, the
    array is always on the heap, and the array variable refers to its elements. If
    the garbage collector determines that the array is no longer in use—that is, no
    live reference variables to it exist—then the memory for all of its elements is
    freed in one go.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Embedded References</samp>
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Reference fields are also embedded in their enclosing type, but their instances
    are not. If we had implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    as a reference type in [Listing 2-5](#list2-5), rather than a value type, the
    layout of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> instance
    would be somewhat different. The <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp>
    field of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp> class
    would be a reference, as illustrated in [Figure 2-3](#fig2-3).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-3.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-3: A color reference
    field embedded in a Brush instance</samp>'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Instead of containing the entire instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    within its own memory, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    type’s <samp class="SANS_TheSansMonoCd_W5Regular_11">color</samp> field refers
    to a separate <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instance
    somewhere else on the heap. Reference type instances are always allocated on the
    heap and are independent of one another. This applies to any reference type, so
    it would be true if we implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    as either a class or a record.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The lifetime of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instance here is *independent* of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    instance. When the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    instance is no longer used and its memory is released, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instance will remain in memory until the garbage collector determines that it’s
    no longer needed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Field and Property Layout</samp>
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All user-defined types can contain instance fields and properties. However,
    structs and record structs have one restriction that does not apply to classes
    or records: a value type definition can’t embed a field of its own type.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: You’ve already seen how value type instances directly contain their fields.
    If a type has a field that is itself a value type, that field also directly contains
    *its* data. If the type of that field is the same as its containing type, the
    compiler is unable to determine how to create it. Consider the simple struct in
    [Listing 2-7](#list2-7) that embeds an instance of *itself* as a field.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-7: A struct containing
    an instance of itself</samp>'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: This example will not compile. The compiler can’t know how to lay out the contained
    field named <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>, because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">p</samp>’s type isn’t fully defined at
    the point where it is declared. The same is true of properties, because even automatic
    properties require a backing field, though that field is hidden from us.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The same reasoning applies to an indirect dependency, illustrated in [Listing
    2-8](#list2-8).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-8: A struct with
    a cyclic dependency</samp>'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Neither the <samp class="SANS_TheSansMonoCd_W5Regular_11">Tree</samp> type
    nor the <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> type can be
    created here because the layout of each depends on the other. This might sound
    draconian, but in practice it’s rarely a problem, and we have an easy workaround:
    if we change the definition of either <samp class="SANS_TheSansMonoCd_W5Regular_11">Tree</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> to make it a reference
    type, the compiler will accept this code. The rule applies only to value types
    because, as mentioned previously, references are always the same size regardless
    of the type to which they refer. This means the compiler doesn’t need to know
    the layout of a class or record to establish a reference to it.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Boxed Values</samp>
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: References can refer only to objects on the heap and can’t refer to individual
    value type instances, even those enclosed within a reference type object. The
    only way for a reference variable to individually refer to a value type instance
    is to make a copy of the value, put that copy on the heap, and refer to the copy
    with a new reference. The process of creating a copy and storing it on the heap,
    known as *boxing*, is automatic when the type of the variable is a reference type.
    A boxed value can always be converted back to its original value type, a process
    called *unboxing*, where the value contained in the box is *copied* into the target
    variable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Boxing happens automatically when we refer to a value using a reference variable
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, or when we
    pass a value as an argument to a method that takes a reference type parameter.
    Unboxing is always *explicit*: we need to cast the boxed variable back to its
    correct value type, as shown in [Listing 2-9](#list2-9).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-9: Boxing and unboxing</samp>'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> variable
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>, and is therefore
    a reference, so the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">green</samp>
    gets boxed into <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> ❶. Similarly,
    calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">object.Equals</samp>
    method boxes the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp>,
    because the method takes two <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    parameters ❷. We don’t need to explicitly cast the value to the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    type; it’s boxed implicitly. We do require an explicit cast to unbox the value
    stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> into a new
    variable ❸.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll see shortly when we cover the Common Type System, <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    is the base class of every type, meaning we can always use <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    to refer to any other variable, including value type instances. A struct can also
    implement one or more interfaces. Interfaces are reference types, so if we use
    either <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> or an interface
    type to refer to a value, that value is automatically boxed onto the heap.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: A boxed value can be unboxed only to its original type. We can’t, for instance,
    unbox an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> value into a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, even though an implicit
    built-in conversion exists from <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. If we attempt
    to unbox a value to anything other than its original type, we’ll get an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">InvalidCastException</samp> at run time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Boxed values are copied to the heap, which means the box is no longer subject
    to the scope of its variable and may exist beyond the lifespan of its original
    value. It’s up to the garbage collector to clean up boxed values. [Chapter 4](chapter4.xhtml)
    discusses boxing in more detail.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Semantics and Type</samp>
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Value types have semantic implications that go beyond being an instance of a
    struct or record struct. Choosing a value type instead of a reference type when
    we define our own types requires much more than a consideration of possible optimizations.
    Records, in particular, differ from classes, because even though records are compiled
    into classes and are therefore reference types, they share some important behavioral
    characteristics with value types.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Before delving into the behavior of record and record struct types, we need
    to better understand how structs differ from classes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Common Type System</samp>
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C# has a hierarchical type system, known as the *Common Type System*, in which
    all types derive from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>,
    a keyword alias for the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Object</samp>
    type. This is why we can always use <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    to refer to any other variable—although, as you just saw, in the case of value
    types, the instances are boxed so they can be referred to by <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    references.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Even the built-in types, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">float</samp>, inherit from <samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp>. In fact, all built-in types
    are aliases for types in the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp>
    namespace. The <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> types
    that underlie the numeric types are all structs and therefore value types. For
    example, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is an alias
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">public readonly struct Int32</samp>.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Enumeration types created with the <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    keyword are not aliases to <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp>
    types, although they all *derive* from the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Enum</samp>
    class. The individual values of an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    declaration have an underlying numeric type, which by default is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    We could specify a different numeric type—for example, if we wanted to allow the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> elements to have values
    larger or smaller than is permitted for an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The non-numeric built-ins <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> are aliases to
    classes in the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> namespace,
    so they’re both reference types.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: When we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp> or
    <samp class="SANS_TheSansMonoCd_W5Regular_11">record</samp> keyword to define
    our own reference type, our new type derives directly from the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    base class unless it explicitly inherits from another type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    base class is neither an interface nor <samp class="SANS_TheSansMonoCd_W5Regular_11">abstract</samp>.
    It has a mix of virtual, nonvirtual, and static members, which provide the default
    implementations common to all objects.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: All struct types (including record structs) and the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Enum</samp>
    type implicitly derive from <samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType</samp>
    (for which there’s no keyword alias), which in turn derives from the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    base class, so all struct types derive *indirectly* from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>.
    Value types, unlike reference types, have an intermediate base class defined by
    the language.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*ValueType itself is* not *a struct, which is sometimes overlooked. All structs
    implicitly inherit from ValueType, so ValueType itself must be a class. Moreover,
    ValueType is an* abstract *class, meaning we can create an instance of object
    but not of ValueType.*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> class overrides
    all the virtual methods defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    base class—<samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>—and
    customizes their implementations to provide behavior tailored for value types.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> implementations
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    are extremely important because they provide the *value-based* definition of equality
    that distinguishes value types from reference types. The difference between these
    implementations has to do with the way values are copied.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Copy Semantics</samp>
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The difference between where reference types and value types store their instance
    data has important implications when we copy variables, because copying a reference
    does not copy the instance. [Listing 2-10](#list2-10) shows a simple example to
    illustrate the difference.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-10: Copying a variable</samp>'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Here we’re copying the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp>
    variable into a new variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp>
    ❶. Then we assign a new value to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Host</samp>
    property of <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> ❷. The test
    checks that the properties of the original variable haven’t changed. The success
    of the test assertion depends on whether <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>
    is a value type or a reference type.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, all variables have a value that we may copy to a new variable.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a value type,
    any copy we make is a new instance of the type, so if we modify any fields of
    that copy, those changes have no effect on the fields of the original value. Therefore,
    if <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a struct or a
    record struct, the test will pass.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a reference
    type, on the other hand, the <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp>
    variable’s value is a reference. When we copy a reference, only the value of the
    reference is copied, and it refers to the same instance as the original variable’s
    value. This means if we modify the instance using one reference, that change is
    reflected in *all* the references to it. Thus, if <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>
    is a class or a record, the test will fail.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Locks and Reference Semantics</samp>
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some situations require the behavior of reference type variables, and using
    a value type instance would be incorrect or even disallowed. For example, we can’t
    use a value type in a <samp class="SANS_TheSansMonoCd_W5Regular_11">lock</samp>
    statement to prevent a section of code from being executed concurrently by multiple
    threads. The compiler forbids it because the variable used as a lock needs to
    be a reference to an object on the heap. The purpose of locking an object is to
    allow only a single thread to execute the code it protects at any given time.
    The object instance identifies the lock and can then have multiple references
    to it from different threads.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The underlying mechanism for the <samp class="SANS_TheSansMonoCd_W5Regular_11">lock</samp>
    statement is the <samp class="SANS_TheSansMonoCd_W5Regular_11">System .Threading.Monitor</samp>
    class. The <samp class="SANS_TheSansMonoCd_W5Regular_11">lock</samp> statement
    translates to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Enter</samp> method
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor</samp>, which takes <samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp> as its parameter. Any instance
    of a value type passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor.Enter</samp>
    as an argument will automatically be boxed. Each thread calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor.Enter</samp>
    will box the value separately, and the acquisition of the lock would never fail,
    rendering it pointless.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: When we’ve finished with the lock, we need to call <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor.Exit</samp>
    and pass the *same* reference used to acquire the lock with <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor.Enter</samp>.
    The compiler inserts the code to call <samp class="SANS_TheSansMonoCd_W5Regular_11">Monitor.Exit</samp>
    at the closing brace of a <samp class="SANS_TheSansMonoCd_W5Regular_11">lock</samp>
    block. If we use a value type, the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Exit</samp>
    will result in a new boxed value on the heap, and so will be a different reference
    to that used in the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Enter</samp>.
    The result is that releasing the lock will fail with a <samp class="SANS_TheSansMonoCd_W5Regular_11">SynchronizationLockException</samp>
    error.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: This is one situation actively requiring reference semantics, because passing
    a reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Enter</samp>
    method doesn’t copy the instance. The <samp class="SANS_TheSansMonoCd_W5Regular_11">monitor</samp>
    and the code using the lock both have a reference to the same instance.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Identity Equality vs. Value
    Equality</samp>
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we say we’re comparing variables to see whether they’re equal, what we
    really mean is that we’re comparing the variables’ *values*. If two variables
    have the same value, they’re considered equal. The type of each value plays an
    important role: the values being compared must be the same type, although one
    or both values may have resulted from an implicit conversion.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: If we compare the values of two variables of the same reference type, their
    respective values are references, which compare equal by default if they both
    refer to the same object in memory. This is known as an *identity comparison*.
    We can override the default identity comparison behavior in our own reference
    types (a topic we’ll examine in detail in [Chapter 5](chapter5.xhtml)), but two
    references to separate instances that have identical field values compare *unequal*
    according to the default identity comparison because they refer to different objects.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, two value type instances compare equal—again by default, because
    we can modify this behavior—if all the fields of one compare equal with their
    counterparts on the other. The difference in equality comparison behavior between
    value type instances and reference type instances is directly related to their
    respective copy semantics. Since a copy of a value type instance is a new independent
    instance with identical *state*, an identity comparison makes no sense. The two
    concepts of copying and equality are therefore intimately related.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The ability to compare two values to see whether they are equal is often underappreciated.
    Even if we rarely need to compare variables in our own code, commonly used classes
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">List<</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">T</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Dictionary<</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp>,
    and the LINQ methods that work on collections may be making those comparisons
    out of sight. <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> is a
    virtual method defined by the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    base class, which is a clue to how fundamental it really is, because it means
    we can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    on *any* value to compare it with any other.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">object.Equals</samp>
    implementation always performs an identity comparison, which, again, is pointless
    for value types. For this reason, all structs implicitly inherit the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    class. <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> overrides
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method to perform
    a value-based comparison.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The difference between what equality means for reference types and value types
    affects the way our code behaves at run time. Consider [Listing 2-11](#list2-11),
    where the <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> type has
    not yet been allocated as a reference type or value type and does not explicitly
    override the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method.
    Here, we create two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>
    with the same value for their <samp class="SANS_TheSansMonoCd_W5Regular_11">Host</samp>
    property. What happens when we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    depends entirely on whether <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>
    is a class, record, struct, or record struct.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-11: Comparing equality
    of two independent variables</samp>'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: This assertion will fail if <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>
    is a class, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">object.Equals</samp>
    method will return <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> only
    if both <samp class="SANS_TheSansMonoCd_W5Regular_11">clone</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp>
    are references to the same instance, and they’re not. The assertion will pass
    if <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a struct, because
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> implementation
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    if both <samp class="SANS_TheSansMonoCd_W5Regular_11">clone</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp>
    have the same value; that is, all their fields compare equal.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">clone</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp>
    variables also compare equal if <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>
    is either a record or a record struct because they also use a value-based comparison
    for equality.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Records, Structs,
    and Value Semantics</samp>
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Records are reference types but have value-like behavior when it comes to comparing
    two record variables for equality. When a record type is compiled, the compiler
    generates a class definition with an overridden implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method unless we define one ourselves. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method generated for records compares two instances to determine if they have
    the same state, rather than just comparing two references to determine if they
    refer to the same instance.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: In a struct, on the other hand, if we don’t override <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    the equality comparison relies on the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    provided by the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>
    base class. Records, as reference types, don’t inherit from <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>.
    Record structs do inherit from <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>,
    but, as with records, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    is overridden by a compiler-generated implementation, because <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType.Equals</samp>
    might not be the optimal implementation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> implementation
    is necessarily general; it must work for *any* struct type, regardless of the
    types of the struct’s fields. If a field of the type has a custom implementation
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>, instances of the
    containing type must use that field’s implementation for comparisons; a simple
    structural or bitwise comparison of the instances may not always be correct. The
    implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    provided by <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> relies
    on reflection at run time to determine how to compare the fields and will use
    an overridden implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    to compare a field if the type of that field has one.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: If we want to avoid the overhead of reflection in a struct, we must override
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> with our own implementation
    to compare each field and property with its corresponding field or property in
    the instance being compared. If each field and property value compares equal,
    using its <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method where
    required, then the two instances are equal. This is essentially the implementation
    provided by the compiler for records and record structs.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: To reiterate, structs, records, and record structs all employ a value-based
    comparison of their state to implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, but for records and record structs, the implementation is generated automatically
    by the compiler, freeing us from the responsibility of providing our own custom
    implementation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The variables we use for records—but not record structs—are references, and
    when we assign one record reference to another variable, we still get two references
    to the same record instance, just as we do if the type is a class. Records therefore
    have reference semantics for copying and value semantics for equality comparison.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The different comparison and copy semantics for value types and reference types
    have important consequences for the way instances of those types behave at run
    time. However, important differences also exist in the way those instances are
    created in the first place. In the next section, we’ll look at how construction
    and initialization differ depending on whether the type of the instance is a value
    type or reference type.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Construction and Initialization</samp>
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a new object is superficially a simple operation, but behind the scenes
    the compiler goes to a great deal of trouble to make the process as efficient
    as possible. In principle, creating an object involves allocating the memory for
    an instance of a type and then calling a constructor whose job is to initialize
    the instance’s fields. The syntax is identical for both value types and reference
    types, but <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp> treats them
    differently and hides some complexity around how and where different types are
    allocated in memory. In other words, the <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    expression is an abstraction that shields us from the implementation details of
    how memory is allocated and used.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, the memory for reference type instances is allocated dynamically.
    When a new instance of a class or record type is created, the memory is allocated
    on the heap at run time. Instances of struct and record struct types are allocated
    differently, depending on how the resulting instance is used. Consider this code,
    which initializes a variable with a new instance of a type named <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This basic syntax for creating an object and assigning it to a variable is the
    same whether <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a class,
    struct, record, or record struct. As you’ll see over the coming sections, this
    code depends on <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> having
    an accessible constructor that can be invoked with no arguments, which isn’t necessarily
    the case when <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a
    reference type. For the time being, though, let’s assume that <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>
    instances can be created this way. If <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>
    is a class or a record, <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    causes memory to be allocated on the heap at run time and returns a reference
    to the new object, which is assigned to the <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp>
    variable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> is a struct or
    a record struct, the new instance is assigned to the <samp class="SANS_TheSansMonoCd_W5Regular_11">thing</samp>
    variable. However, this code may or may not allocate memory for a new instance
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp> and may or may not
    call a constructor. The reason is that construction and initialization are separate
    processes. Part of the difference is related to whether a <samp class="SANS_TheSansMonoCd_W5Regular_11">Thing</samp>
    is a value type or reference type.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Default Initialization</samp>
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Default initialization* means that each of a type’s fields, including the
    backing fields for properties, is given a default value, which is defined in the
    language to mean one of the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: References are set to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in numeric value type variables are set to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other value types are default-initialized.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default-initialized reference type fields are a common cause of errors. For
    example, the simple <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    struct in [Listing 2-12](#list2-12) relies on us manually initializing an instance
    by setting its properties. If we neglect to set suitable values for the properties
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> instance,
    we may be rewarded with an exception when we use the instance.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-12: Initializing
    reference type fields</samp>'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp> causes
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference exception
    because the <samp class="SANS_TheSansMonoCd_W5Regular_11">defaultTrack</samp>
    value has been default-initialized. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>
    method calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ToUpper</samp> on its
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Artist</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>
    properties, whose default-initialized value is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    We need to be alert to any uses of default-initialized references in order to
    avoid such problems resulting from accessing a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference. One way to minimize the impact of default-initialized values is by
    providing our own instance constructors.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Instance Constructors</samp>
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An instance constructor, like a method, can have zero or more parameters. Also
    like methods, constructors can be overloaded, so we can define several constructors
    for a type, each with a different number of parameters, or parameters of different
    types. Constructor definitions for classes, structs, records, and record structs
    have many similarities, but several important differences exist.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 2-13](#list2-13), we add a constructor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    struct and use the parameter values to initialize the instance’s property values.
    We use the null-coalescing operator <samp class="SANS_TheSansMonoCd_W5Regular_11">??</samp>
    to assign an empty string for each property if its corresponding parameter is
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-13: Adding an instance
    constructor with parameters</samp>'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: By adding a constructor, we no longer have to rely on <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    users setting the properties explicitly, since the initial values for those properties
    are set in the constructor. We have made those properties <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>-only—that
    is, they can be given a value only in the constructor—and made <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> struct. However,
    we must still be cautious of using the property values inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>
    method because instances of any value type can always be default-initialized,
    regardless of the presence of a user-defined constructor definition. Adding our
    own constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    to give meaningful values to the properties isn’t sufficient protection against
    exceptions that occur from calling methods using a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference, because <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    is a struct type.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'If the nullable reference type feature is enabled (see “Nullable Reference
    Types” on [page 64](#sec38) for more), the constructor’s parameters will be non-nullable
    variables, meaning that passing <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    for either argument would cause a compiler warning. Using non-nullable parameters
    doesn’t mean that <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> can’t
    be passed as an argument, but we may decide that the warning is sufficient protection,
    potentially allowing us to omit the null-coalescing assignments in the constructor.
    The nullable reference type feature doesn’t, however, mean we can avoid verifying
    that the property values are not <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    prior to using them in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>
    method. Fortunately, the null-conditional operator makes the check straightforward
    and safe:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here the presence of the null-conditional operator, a <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>
    appended to each property name, means that in each case the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToUpper</samp>
    method will be called only if the property is a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    value. If either property is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    the result of the expression between the braces within the string is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    which the string interpolation treats as an empty string.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'If <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp> were a class
    or record, the presence of our own constructor would mean we could no longer create
    an instance without passing arguments like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we attempt to create a default-constructed instance, we get the following
    compiler error:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If we don’t provide any constructors for a class or record, the compiler inserts
    a default constructor for us. If we define a constructor when we define our own
    reference type, however, the compiler will not generate the default constructor.
    The compiler doesn’t create a default constructor for value types, but an instance
    of a struct or record struct can be default-initialized whether or not we define
    our own constructor.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Default and Generated Constructors</samp>
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The behavior of reference types and value types differs partly because reference
    types are allocated on the heap, but value types might not be. The compiler generates
    a default constructor for reference types because instances of such types are
    allocated dynamically, and their instances are initialized at run time. When a
    reference type instance is allocated on the heap, the memory for it is set to
    zero, effectively default-initializing the instance.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Value types are treated differently because their memory isn’t necessarily
    allocated at run time: for local value type variables, the compiler may *reserve*
    memory for the instance data, and the program accesses that memory directly. The
    underlying Common Intermediate Language (CIL) has an efficient instruction for
    default-initializing value type instances that effectively zeroes out the memory
    used by the instance, wherever its memory actually resides.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: We can think of the default initialization of a struct or record struct as being
    performed by a compiler-provided default constructor, because the result is identical
    in any case. Default-initializing value types offers a minor performance advantage
    because it doesn’t require a method call to a constructor, although it’s almost
    never the most significant optimization.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'In a positional record or a positional record struct, the compiler generates
    a public constructor based on the parameters we use in the type definition, like
    this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The parameters to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    in this example tell the compiler to create public properties using those names
    and their types. The compiler also creates a constructor with the same signature
    as the record’s parameter list, where the properties are assigned their values.
    The constructor generated by the compiler is the equivalent of this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Although the constructor has been generated by the compiler, it’s still considered
    a user-defined constructor and therefore still suppresses the default constructor
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of its type, an instance is always default-initialized when it’s
    first created, whether its memory is being allocated on the heap or elsewhere.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: When we define our own constructor for a class, we can rely on all the fields
    having been default-initialized prior to the constructor’s body; the fields of
    a class are considered *initially assigned* within the constructor. In a struct’s
    constructor, the fields are *initially unassigned*, so we must definitely assign
    a value for every field of a struct or record struct, even if it’s simply to replace
    the value with its default-initialized equivalent.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Overloaded Constructors</samp>
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can provide a constructor with parameters for any type, and we can overload
    the constructor by defining several constructors that have different numbers or
    types of parameters. This is useful when we want to support different ways to
    construct our type. For instance, [Listing 2-14](#list2-14) shows a struct that
    has two constructors with differing signatures.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-14: Overloading constructors</samp>'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The first constructor initializes the three properties from three separate parameters
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">green</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">blue</samp>). The second constructor
    receives a numeric representation of an RGB value and initializes the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>
    properties by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Unpack</samp>
    method (not shown here) to unpack the number into its component parts. We select
    the different overloads when using the constructor by passing different arguments,
    as shown in [Listing 2-15](#list2-15).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-15: Selecting the
    correct overload</samp>'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Here, the <samp class="SANS_TheSansMonoCd_W5Regular_11">orange</samp> variable
    is created using the constructor with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">uint</samp>
    parameter (the second constructor in [Listing 2-14](#list2-14)), and the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">yellow</samp> variable uses the constructor
    with three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> parameters
    (the first constructor in [Listing 2-14](#list2-14)).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Parameterless Constructors</samp>
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As noted earlier, defining our own constructor for a class type will inhibit
    the compiler-generated default constructor, meaning that we can create new instances
    of the type only by passing arguments to our own constructor’s parameters. If
    we need to create instances of such a reference type without arguments, we can
    define our own *parameterless constructor*, which we might use to initialize reference
    type fields and properties to non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    values. This is common when a class contains a collection that needs to be initialized
    but can be empty, as demonstrated in [Listing 2-16](#list2-16).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-16: Defining a parameterless
    constructor</samp>'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The two constructors defined here allow us to create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Playlist</samp>
    either by passing a sequence of items to populate the queue ❶ or by passing no
    arguments ❷. If we pass no arguments, the <samp class="SANS_TheSansMonoCd_W5Regular_11">queue</samp>
    field is initialized as an empty queue, ensuring that it isn’t <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Both constructors initialize the <samp class="SANS_TheSansMonoCd_W5Regular_11">queue</samp>
    field by using type inference, a feature called *target-typed new*, introduced
    in C# v9.0\. The compiler deduces the type required by <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    from the type of the target variable being initialized—in this example, a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Queue< MusicTrack></samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">queue</samp>
    field is guaranteed to be non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    for any <samp class="SANS_TheSansMonoCd_W5Regular_11">Playlist</samp> instance,
    so we don’t need to check for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Playlist.Append</samp> method.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: In a positional record, the compiler creates a constructor based on the positional
    arguments for the record, so by default, instances of a positional record can’t
    be created without arguments. We can define our own parameterless constructor
    for a positional record if we require that behavior. A struct or positional record
    struct, on the other hand, can *always* be created without arguments, whether
    or not we define our own constructors.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Structs and Default Values</samp>
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As of C# v10.0, we can define our own parameterless constructors for value types
    to help ensure that any reference fields are non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    However, we still need to check for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    in a value type’s implementation because an instance of a struct or record struct
    can always be default-initialized, effectively bypassing any constructors we define.
    This is illustrated in [Listing 2-17](#list2-17), where we add a parameterless
    constructor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    struct that explicitly initializes the two <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    properties.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-17: Adding a parameterless
    constructor for a struct</samp>'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameterless constructor sets both reference type properties to a non-<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp> value, so calling <samp class="SANS_TheSansMonoCd_W5Regular_11">ToUpper</samp>
    on either property is safe when we’re using a <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>
    instance that was created using <samp class="SANS_TheSansMonoCd_W5Regular_11">new
    MusicTrack</samp>. However, this doesn’t mean we can omit the null-conditional
    checks in <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>. It’s
    still possible for <samp class="SANS_TheSansMonoCd_W5Regular_11">Artist</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp> to be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    if the instance is a default-initialized <samp class="SANS_TheSansMonoCd_W5Regular_11">MusicTrack</samp>—for
    example, when it’s an element in an array:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Without the checks for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>, this code would
    cause <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp> to throw a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NullReferenceException</samp> because
    the creation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">favorites</samp>
    array doesn’t call our parameterless constructor on its elements. Each element
    is default-initialized, leaving the <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Artist</samp> properties with
    their default value of <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    so attempting to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToUpper</samp>
    method on a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference
    causes the exception.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Array elements are default-initialized without invoking any parameterless constructor
    we provide. The parameterless constructor is reserved for when we create a new
    instance by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    keyword.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Value Type Initialization</samp>
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One quite subtle consequence of the way value type instances are allocated in
    memory is that if a value type’s fields are all public, we can definitely assign
    a value for each field outside the constructor (as long as they’re not read-only),
    which results in the whole instance being fully assigned.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: For example, [Listing 2-18](#list2-18) assigns a value to each field of an uninitialized
    struct variable.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-18: Definitely assigning
    a struct</samp>'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: This code compiles, and the test passes. We can read the value of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">red</samp> field, even though we’ve never
    allocated the <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp>
    variable with <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp> or invoked
    a constructor for it. The same would be true if <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    were a record struct instead.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates that value type variables directly contain an instance
    of their type. Assigning to each field means we don’t need to explicitly construct
    an instance. However, relying on this behavior is likely to cause other problems,
    not the least of which is that using public fields leaves the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type open to misuse, intended or not. In practice, a constructor is a much better
    way to initialize a value type’s fields, which should all be private and read-only.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Note that if we alter the public fields to be publicly mutable properties, this
    code will fail to compile. We can’t access a property of a value type in any way
    until the instance itself has been fully, and definitely, assigned. Every property
    has a backing field generated by the compiler, and that backing field is always
    private.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Constructor Accessibility</samp>
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Constructors with parameters can be made public or private in any type. Private
    constructors are useful when we want to prevent users from creating instances
    with certain arguments. We used this technique in “[Static Creation Methods](chapter1.xhtml#sec23)”
    in Chapter 1 to force users to call the static class factory methods we defined
    in order to create certain values, rather than using the <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    keyword directly. In a class or record, we can make the parameterless constructor
    private to prevent users from creating default-constructed instances, shown for
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record in [Listing
    2-19](#list2-19).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-19: Making constructors
    private for reference types</samp>'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    is marked <samp class="SANS_TheSansMonoCd_W5Regular_11">private</samp>, we can
    use it to initialize the static <samp class="SANS_TheSansMonoCd_W5Regular_11">Black</samp>
    property value and any other static or instance members of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>,
    but it’s inaccessible to code outside of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type. If users of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> forget
    and attempt to create an instance with <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>,
    the compiler forbids it:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Classes and records can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">protected</samp>
    keyword on a constructor, making it available to inheriting types. Since structs
    and record structs can’t be inherited, the compiler will prevent the use of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">protected</samp> in a value type.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: In a struct or record struct, if we define our own parameterless constructor,
    it *must* be public. Struct and record struct instances can *always* be default-initialized,
    whether or not we provide a parameterless constructor.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Field Initializers</samp>
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a class or record definition, and in structs or record structs after C# v10.0,
    we can assign initial values to fields inline by using *field initializers*. We
    can do the same with automatic properties by using *property initializers*, which
    initialize the hidden backing field associated with the property. [Listing 2-20](#list2-20)
    uses a field initializer for the <samp class="SANS_TheSansMonoCd_W5Regular_11">queue</samp>
    field of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Playlist</samp> class
    from [Listing 2-16](#list2-16) to assign an initial value and adds a <samp class="SANS_TheSansMonoCd_W5Regular_11">Name</samp>
    property for <samp class="SANS_TheSansMonoCd_W5Regular_11">Playlist</samp> that
    we also assign an initial value by using a property initializer.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-20: Assigning initial
    values for fields and properties</samp>'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Field and property initializers are part of object construction but are not
    applied when a value type instance is being default-initialized. Conceptually,
    initializers are applied just before the body of a constructor. As noted previously,
    the compiler creates a default constructor for class and record types if no user-defined
    or positional constructors are present; however, the compiler won’t synthesize
    a parameterless constructor for any value type. Therefore, if we want to use field
    or property initializers for struct or record struct types, we must also define
    at least one constructor of our own. This can be a parameterless constructor or
    a constructor taking one or more parameters.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Field initializers can’t reference any instance members. However, since static
    fields are guaranteed to be definitely assigned before any instance fields, a
    field initializer can reference a static value. Static fields can also have initializers
    and can reference other static fields. However, we need to take care when referencing
    one static field from another static field because they’re initialized in the
    order in which they appear in the class.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Object Initializers</samp>
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With *object initializers*, we set values for publicly mutable properties of
    a variable at the point of creating a new instance, like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Classes, records, structs, and record structs accept this syntax, and they
    all behave the same way. The initialization process is the same for each: a constructor
    is invoked in the usual way to create an instance, and then the value is assigned
    to the property of the instance. In this example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    is created using a parameterless constructor (or one with all-optional parameters),
    but we can call any constructor before the initialization expression inside the
    braces. In the special case of a constructor that requires no arguments, we can
    leave out the parentheses for the constructor.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Classes and records require an accessible parameterless constructor to use this
    syntax. If the parameterless constructor of a class or record is hidden or nonpublic,
    we *must* invoke a valid constructor before the object initialization within the
    braces. We don’t have to worry about this for struct or record struct types because
    they can always be default-initialized if the type has no parameterless constructor.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">init-Only Properties</samp>
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As of C# v9.0, any property can be *init-only*, meaning it can be written to
    only during the creation of a new instance. Prior to C# v9.0, object initialization
    required properties to have a public <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor, meaning object initialization couldn’t be used with immutable properties.
    Object initialization requires the value of the property to be set after the constructor
    has completed, which wasn’t permitted for properties without a public <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor. An <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> accessor
    allows a property to be set during object initialization and then makes the property
    immutable after the initialization is complete.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> struct in [Listing
    2-21](#list2-21) demonstrates how <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only
    properties are used during object initialization.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-21: Setting properties
    as init-only</samp>'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: When we create the <samp class="SANS_TheSansMonoCd_W5Regular_11">orange</samp>
    variable, a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is
    first default-constructed, giving each property its default value of <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
    The object initializer between the braces gives new values to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp> properties, leaving
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp> property with its
    default value. Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    is a <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> struct, which
    requires that the struct has no mutable properties.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: We can assign a value to an <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only
    property in an instance constructor or by using object initialization, but we
    can’t assign a new value after the instance has been created. An <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only
    property is immutable. The <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>
    accessor syntax can be used for properties and indexers for any type, although
    it was introduced in C# v9.0 to support a special initialization syntax supported
    by records and known as *non-destructive mutation*.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Non-destructive Mutation</samp>
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Records and record structs support the non-destructive mutation syntax, and
    as of C# v10.0, so do structs and anonymous types. Syntactically, non-destructive
    mutation is similar to object initialization, except that it initializes a new
    instance by copying an existing one and providing new values for selected properties
    in that copy. [Listing 2-22](#list2-22) demonstrates this syntax, using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">with</samp> keyword to copy the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">orange</samp> record variable to a new
    variable named <samp class="SANS_TheSansMonoCd_W5Regular_11">yellow</samp>, and
    then assigning a new value to one of the properties of the copy.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-22: Initializing
    a copy of a record with non-destructive mutation</samp>'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> expression we
    use when we create the <samp class="SANS_TheSansMonoCd_W5Regular_11">yellow</samp>
    variable creates a new instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    record with property values identical to the original <samp class="SANS_TheSansMonoCd_W5Regular_11">orange</samp>
    instance. Those properties specified between the braces following <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp>
    are then assigned the values by using the same syntax as object initialization.
    This approach is called *non-destructive* mutation because no changes are made
    to the original record.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructors and initializers are both ways we can create new instances with
    known values. However, sometimes we can’t provide an initial value for a variable,
    but leaving it uninitialized is too restrictive: we can’t even test it to see
    whether it has a value, owing to the rules governing definite assignment. In the
    next section, we’ll examine the options open to us when we need a variable with
    no value, and how value types and reference types differ here too.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">null Values and Default Values</samp>
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A plain value type variable can never be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    An instance of a value type directly contains all of its fields, and there’s not
    necessarily a representation of “no value.” A default-initialized instance of
    a value type is not the same thing—it’s a complete instance of the type, just
    with the default-initialized values for each of its fields.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: We can employ a nullable value type, which can be assigned and compared with
    the value <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, as you’ll
    see shortly, but plain value type instances are incompatible with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> constant expression
    is a reference and therefore can be assigned only to reference variables. One
    of the implications of not being able to assign <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    to a value type variable is that we can’t pass <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    as an argument to a value type method parameter.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, attempting to *compare* a value with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    makes no sense. If we do, as shown in [Listing 2-23](#list2-23), the compiler
    rejects the code.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-23: Comparing a value
    type variable with null</samp>'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'The error from the compiler is shown here:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can, however, compare any reference type with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    and, as of C# v8.0, we can use a constant pattern to make this comparison more
    direct by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">is</samp> keyword:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Comparing any value type with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    makes no sense, whatever method we choose, because <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    is a reference and as such is represented differently than a value type. That
    said, the rule against comparing value types with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    has one exception: generic types.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generics and null</samp>
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a generic class or method, an unconstrained type parameter variable can be
    compared with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. An unconstrained
    generic type can be either a value type or a reference type. To illustrate, the
    simple example in [Listing 2-24](#list2-24) compares an instance of a generic
    parameter type with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-24: Comparing a generic
    type parameter instance with null</samp>'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Compare</samp> generic method
    has a type parameter named <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    that might represent either a value type or a reference type, because it has no
    type constraints. In this instance, <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    is not known to be a value type, so the compiler allows the syntax. If <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>’s
    type is determined at run time to be a value type, the whole expression simply
    evaluates as <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: The compiler still prevents us from assigning <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    to a variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>,
    because if <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> were a value
    type, the assignment would fail at run time. Similarly, we can’t return <samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp> through an unconstrained type
    parameter, demonstrated in [Listing 2-25](#list2-25).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-25: Trying to return
    null as a generic parameter type</samp>'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives the following error:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this example, the difficulty arises because <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    is unconstrained. It might represent a struct or record struct type, for which
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> is not a valid value.
    The error message gives us a clue that instead of returning <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    we can return a *default* value for <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>.
    Default values have other, more significant use cases too, but also some limitations.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generics and Default
    Values</samp>
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of a default value is closely related to a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    value, especially in the context of generic types and methods. At times, we—and
    the compiler—must ensure that an instance of a generic parameter type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    is definitely assigned, even when <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>’s
    type is not known at compile time. We can’t just use <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    to make a new instance of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    because the compiler isn’t able to determine which constructors are available
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is a value type, we
    can *always* make a default instance by using default initialization or by calling
    a parameterless constructor, but if <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    is a reference type, it might not have an accessible default or parameterless
    constructor. We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    constraint on <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, meaning
    that our generic type or method will work only with types that have an accessible
    parameterless constructor, but this might be too restrictive.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: In a generic type, we can use the generic parameter to denote a field or property
    of the generic parameter type. Generic value types must ensure that *all* their
    fields are definitely assigned before control leaves the constructor. To make
    that possible, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    keyword to initialize a default instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>,
    as in the generic struct shown in [Listing 2-26](#list2-26).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-26: Initializing
    a default instance of a type parameter</samp>'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> constructor,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">contained</samp> field is assigned
    the default value of its type by using the target-typed default literal (available
    since C# v7.1), which is equivalent to the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">default(T)</samp>.
    Where <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is a class or record,
    its default value is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    and where <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is a struct or
    record struct, the default value is a default-initialized instance. Note that
    initializing a value by using <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp>
    does not invoke a parameterless constructor, if we have defined one. This code
    is valid because we can always create a default *value* for a variable of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>: if <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    is a value type, the value is a default instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>,
    and if <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is a reference type,
    a default <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> keyword has many
    uses outside of generic types and methods, but within generic code it’s indispensable.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Default values are useful, but they’re not sufficient to identify a particular
    value type instance as invalid. In other words, we can’t use a default when what
    we really mean is *no value present*. The default value of a struct or record
    struct is a default-initialized instance and might therefore be a *valid* value.
    Consider [Listing 2-27](#list2-27).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-27: Default values
    can be valid.</samp>'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: The default value for an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    type is <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, which we may use
    to indicate an invalid number in some circumstances but not all. Whether that
    matters, especially for our own value types, depends on the context in which instances
    of the type are used, but limiting valid integers to only nonzero values would
    be very restrictive. Fortunately, we have an alternative.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nullable Value Types</samp>
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Nullable value types* allow us to have a representation of a value type that
    means *no value present*. A nullable value type is a wrapper around a value type,
    and a nullable value type variable may or may not have a value. A nullable value
    type variable can also be assigned the value <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    demonstrated by using a simple test in [Listing 2-28](#list2-28).'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-28: Using nullable
    values</samp>'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp> following the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    variable is shorthand for saying that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable< int></samp>. We can
    now represent an invalid value for <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    that’s distinct from any valid values for <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
    We can use a nullable variable for any value type, not just built-ins. The default
    value for a nullable is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    as shown here:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This test passes because <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> are both <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    The declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> in the
    first line doesn’t initialize a default <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    but rather a default <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable< int></samp>.
    Equality comparison between nullable values compares the underlying value if there
    is one. Two nullable values are equal if they both have no value, or values that
    themselves compare equal. <samp class="SANS_TheSansMonoCd_W5Regular_11">Nullable<
    T ></samp> is a struct and overrides the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method to provide this behavior.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'As a consequence of not being able to assign <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    to a plain value type variable, we can’t use a plain value type on the right-hand
    side of an <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp> expression,
    like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> is a struct or
    record struct, this code won’t compile, because if the cast fails, the <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp>
    operator will return <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    As we know, <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> can’t be
    assigned to a value. The solution is to use a nullable value type as the source
    of the conversion, as shown here:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">actual</samp>
    variable is a nullable <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    in this example and will have the value <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    if the conversion fails—that is, if the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    variable is not in fact a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    type.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nullable Reference
    Types</samp>
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: C# v8.0 introduced *nullable reference types*, a feature that allows the compiler
    to warn us when a reference is or might be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    and we expect it to have a real value. While reference variables have always been
    able to have a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> value,
    the nullable reference type feature allows us to express whether we *intend* for
    them to. In other words, when we use a nullable reference type variable, we’re
    being explicit about our intention that <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    is an *expected* potential value for a variable.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Reference variables are non-nullable by default. In the declaration in [Listing
    2-29](#list2-29), the <samp class="SANS_TheSansMonoCd_W5Regular_11">brush</samp>
    variable is a *non-nullable* reference.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-29: Declaring a non-nullable
    reference variable</samp>'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler performs static analysis that enables it to issue a warning if
    a non-nullable reference can’t be guaranteed to be non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    To state that with fewer negatives, the compiler issues a warning if a value that
    may be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> is assigned to
    a non-nullable reference. In particular, assigning <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    to a non-nullable reference, as we just did, provokes this warning:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If we attempt to pass a possibly <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    value as an argument to a non-nullable method parameter, we’ll get a warning from
    the compiler. Consider the method in [Listing 2-30](#list2-30), which capitalizes
    the first character of each word in a string.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-30: Defining the
    ToTitleCase method with a non-nullable reference parameter</samp>'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Within the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>
    method, we should be able to depend on the <samp class="SANS_TheSansMonoCd_W5Regular_11">original</samp>
    parameter having a real, non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    value, because it’s a non-nullable string. That means we can avoid explicitly
    writing code to check that it isn’t <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    When we call <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>,
    if the compiler can’t guarantee that the argument we pass isn’t <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    it will give us a warning.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'We might have a legitimate need for a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference, however, in which case we mark the type of a variable as nullable to
    suppress the compiler warnings about possible null assignment. The syntax is the
    same as for nullable value types: we append a <samp class="SANS_TheSansMonoCd_W5Regular_11">?</samp>
    to the type. [Listing 2-31](#list2-31) shows a collection of nullable <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    elements designated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">string?</samp>
    type name.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-31: Passing a possibly
    null argument for a non-nullable parameter</samp>'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'If we apply the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>
    method from [Listing 2-30](#list2-30) to this collection, we get a similar compiler
    warning as with [Listing 2-29](#list2-29), where we explicitly assigned <samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp> to a non-nullable reference
    type variable:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We’re given this warning because the compiler can’t guarantee that the collection
    contains no <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> elements.
    The compiler assumes any of the elements may be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    because the element type of the collection is a nullable reference.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: If we explicitly check each element before making the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>,
    the compiler can determine that we’re not using a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference as an argument to the method. To achieve that, we could unpack the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> expression into a loop,
    such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">foreach</samp> loop
    in [Listing 2-32](#list2-32).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-32: Explicitly using
    a non-null reference</samp>'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: This code doesn’t prompt a warning about the argument in the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>
    because the compiler can perform enough analysis on the code preceding the method
    call to guarantee that the <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>
    argument isn’t <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes the compiler needs our help to determine whether it’s safe
    to assign a variable to a non-nullable reference or to call a method with a non-nullable
    parameter. [Listing 2-33](#list2-33) shows a slightly modified version of [Listing
    2-31](#list2-31) calling <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>,
    where any <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> elements are
    filtered out before the method is called.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-33: Removing null
    elements before the method call</samp>'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: This code gives us the same warning as in [Listing 2-31](#list2-31), however,
    because the compiler can’t be certain <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>
    won’t be invoked with a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    argument. Although it looks as if the check for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    is being made inline, in fact we’re calling a lambda function to make that comparison,
    and the compiler doesn’t attempt to analyze every possible code path to make this
    safe. Fortunately, we have a workaround.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Null-Forgiving
    Operator</samp>
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use the *null-forgiving operator* to inform the compiler that we definitely
    know what we’re doing and that no <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    references are used as arguments to a non-nullable parameter. The null-forgiving
    operator is an <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp> appended
    to the variable, which is why it’s also referred to as the *dammit operator,*
    as in, “It’s definitely not <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    dammit!” When we’ve filtered out all the <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    elements from our collection, we apply the dammit operator to the argument for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>, as shown in
    [Listing 2-34](#list2-34).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 2-34: Using the null-forgiving
    operator</samp>'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Using the null-forgiving operator with the argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">ToTitleCase</samp>
    convinces the compiler that it is safe to call the method having a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference type parameter. If we were to inadvertently pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference, we’d (justifiably) get the dreaded <samp class="SANS_TheSansMonoCd_W5Regular_11">Object
    reference not set to an instance of an object</samp> exception. We must take care
    when using the null-forgiving operator that we really do know that the variable
    can’t be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Nullable reference types, while having the same syntax as nullable value types,
    are just a device that indicates to the compiler that we’re making certain assumptions
    about the variable. Unlike nullable value types, which are underpinned by a distinct
    type with behavior injected by the compiler, nullable reference types are a purely
    compile-time mechanism, used for static analysis, and do not change the behavior
    of our code in any way. At run time, nullable and non-nullable references are
    just references. Nevertheless, distinguishing between them in code is useful for
    encoding our assumptions about nullability.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Unexpected <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference
    exceptions are the curse of many programs and a class of error that programmers
    everywhere go to great lengths to try to avoid. The nullable reference type feature
    of modern C# is one that shifts some of that responsibility away from the programmer
    and onto the compiler.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*My goal was to ensure that all use of references should be absolutely safe,
    with checking performed automatically by the compiler. But I couldn’t resist the
    temptation to put in a null reference, simply because it was so easy to implement.
    This has led to innumerable errors, vulnerabilities, and system crashes, which
    have probably caused a billion dollars of pain and damage in the last forty years.*'
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Tony (C.A.R.) Hoare
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The type system in C# is broadly similar to many other programming languages,
    including its support for user-defined types. C# differs in its distinction between
    reference types and value types. Although there are various recommendations on
    when to choose to define a value type instead of a reference type, including documentation
    from Microsoft, those guidelines often take only part of the story into consideration.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: The technical purpose of distinguishing value types from reference types is
    to allow the compiler and Common Language Runtime to make assumptions about values
    that may allow certain opportunities for optimization. Some of the differences
    we’ve discussed result from the way reference and value type instances are stored
    and managed in memory. That value type variables are not independently subject
    to garbage collection can itself be a big win. However, we can’t just turn our
    classes into structs or record structs and expect that our programs will suddenly
    use less memory or run more quickly. Value semantics involves much more than just
    declaring something as a value type.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, the copy-by-value behavior of value types is more than just a side
    effect of the way values use memory. Copying by value gives rise to many of the
    constraints that are imposed on value types and for which reference types have
    no need. Using value types where they’re appropriate can make our code clearer
    and simpler in subtle ways, like not having to check for <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    values on every use of a value. The characteristics of copying values also affect
    the behavior of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method; although comparing variables to see if they are equal may sound inconsequential,
    it’s an essential aspect of working with variables.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: The distinction between value types and reference types, then, is not just a
    list of *restrictions*. Genuine semantic differences affect our programs’ behavior
    and can bring tangible benefits. One advantage of value types is that they can
    never be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. Constantly
    having to check references to ensure that they’re valid can be tiresome and error-prone.
    Using the non-nullable reference type feature is one way we reduce the occurrence
    of unexpected errors arising from dereferencing a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: One of the great strengths of C# being a compiled and type-safe language is
    that the compiler can identify many kinds of errors *before* our program is ever
    run.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
