<html><head></head><body>
<section aria-labelledby="ch5" epub:type="chapter" role="doc-chapter">
<span aria-label="97" epub:type="pagebreak" id="pg_97" role="doc-pagebreak"/>
<hgroup>

<h1 class="CHAPTER" id="ch5">
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">CONTROL FLOW</samp></span>
</h1>
</hgroup>
<figure class="opener"><img alt="" class="opener" src="../images/opener.jpg"/>
</figure>
<p class="COS">In this chapter, you’ll learn how to control the order in which individual statements are evaluated. We’ll start by going over expression statements and compound statements that define the work to be performed. We’ll then cover three kinds of statements that determine which code blocks are executed and in what order: selection, iteration, and jump statements.</p>
<section aria-labelledby="sec1" epub:type="division">

<h2 class="H1" id="sec1"><span id="h1-49"/><samp class="SANS_Futura_Std_Bold_B_11">Expression Statements</samp></h2>
<p class="TNI">An <i>expression statement</i> is an optional expression terminated by a semicolon. It’s one of the most common statements and a basic unit of work. The following examples show different expression statements.</p>
<p class="ListPlainFirst"><span aria-label="98" epub:type="pagebreak" id="pg_98" role="doc-pagebreak"/>Assigns a value to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>:</p>

<pre><code>a = 6;</code></pre>
<p class="ListPlain">Assigns the sum of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>:</p>

<pre><code>c = a + b;</code></pre>
<p class="ListPlain">A null statement:</p>

<pre><code>; // null statement, does nothing</code></pre>
<p class="ListPlainFirst">You can use a null statement when the syntax of the language requires a statement but no expression needs to be evaluated. Null statements are commonly used as placeholders in iteration statements.</p>
<p class="ListPlain">The following expression statement increments the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>:</p>

<pre><code><samp class="SANS_TheSansMonoCd_W5Regular_11">++count;</samp></code></pre>
<p class="TX">After each full expression has been evaluated, its value (if any) is discarded (including assignment expressions in which the assignment itself is a side effect of the operation) so that any useful results occur as the consequence of side effects (as discussed in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>). Three of the four expression statements in this example have side effects (the null statement does nothing). Once all side effects have completed, execution proceeds to the statement following the semicolon.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">

<h2 class="H1" id="sec2"><span id="h1-50"/><samp class="SANS_Futura_Std_Bold_B_11">Compound Statements</samp></h2>
<p class="TNI">A <i>compound statement</i>, or <i>block</i>, is a list of zero or more statements, surrounded by braces. The statements in the block may be any kind of statement described throughout this chapter. Some of these statements may be declarations. (In early versions of C, declarations within the block had to precede all nondeclarations, but that restriction no longer applies.) Each statement in the block is executed in sequence unless modified by a control statement. After the final statement has been evaluated, execution proceeds to after the closing brace:</p>

<pre><code>{
  static int count = 0;
  c += a;
  ++count;
}</code></pre>
<p class="TX">This example declares a static variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> called <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>. The second line increases a variable <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> declared in an outer scope by the value stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>. Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> is incremented to track how many times this block has been executed.</p>
<p class="TX"><span aria-label="99" epub:type="pagebreak" id="pg_99" role="doc-pagebreak"/>Compound statements can be nested so that one compound statement fully encloses another. You may also have blocks with no statements at all (just the empty braces).</p>
<aside aria-label="box-6" class="box">
<p class="BoxTitle" id="box-6"><samp class="SANS_Dogma_OT_Bold_B_11">CODE STYLE</samp></p>
<p class="BoxFirst"><samp class="SANS_Futura_Std_Book_11">Competing coding styles disagree on when and where to place braces. If you’re modifying existing code, it would be wise to follow the style already in use for the project. Otherwise, look at styles you see in code written by experienced C programmers and choose one that seems clear. For example, some programmers line up the opening and closing braces to make it easy to find the mate for a given brace. Others follow the style used in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">The C Programming Language</samp><samp class="SANS_Futura_Std_Book_11">, 2nd edition, by Brian Kernighan and Dennis Ritchie (Pearson, 1988), wherein the opening brace is placed at the end of the preceding line and the closing brace gets a line to itself. Once you have chosen a style, use it consistently.</samp></p>
</aside>
</section>
<section aria-labelledby="sec3" epub:type="division">

<h2 class="H1" id="sec3"><span id="h1-51"/><samp class="SANS_Futura_Std_Bold_B_11">Selection Statements</samp></h2>
<p class="TNI"><i>Selection statements</i> allow you to conditionally execute a substatement depending on the value of a controlling expression. The <i>controlling expression</i> determines which statements are executed based on a condition. Selection statements include the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement and the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement.</p>
<section aria-labelledby="sec4" epub:type="division">

<h3 class="H2" id="sec4"><span id="h2-59"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">if</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement allows a programmer to execute a substatement based on the value of a controlling expression of scalar type.</p>
<p class="TX">There are two kinds of <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements. The first conditionally determines whether the substatement is executed:</p>

<pre><code>if (<var>expression</var>)
  <var>substatement</var></code></pre>
<p class="TX">In this case, the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement</samp> is executed if the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp> is not equal to 0. Only the single <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement</samp> of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement is conditionally executed, although it can be a compound statement.</p>
<p class="TX"><a href="chapter5.xhtml#Lis5-1">Listing 5-1</a> shows a division function that uses <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements. It divides a specified dividend by a specified divisor and returns the result in the object referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">quotient</samp>. The function tests for both division by zero and signed integer overflow and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> in either case.</p>
<span id="Lis5-1"/>
<pre><code>bool safediv(int dividend, int divisor, int *quotient) {
<span aria-label="annotation1" class="code_CodeAnnotation">❶</span> if (!quotient) return false;
<span aria-label="annotation2" class="code_CodeAnnotation">❷</span> if ((divisor == 0) || ((dividend == INT_MIN) &amp;&amp; (divisor == -1)))
  <span aria-label="annotation3" class="code_CodeAnnotation">❸</span> return false;
<span aria-label="100" epub:type="pagebreak" id="pg_100" role="doc-pagebreak"/><span aria-label="annotation4" class="code_CodeAnnotation">❹</span> *quotient = dividend / divisor;
  return true;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-1: A safe division function</samp></p>
<p class="TX">The first line of this function <span aria-label="annotation1" class="CodeAnnotation">❶</span> tests <samp class="SANS_TheSansMonoCd_W5Regular_11">quotient</samp> to ensure that it’s not null. If it is null, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> to indicate that it is unable to return a value. (We cover <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statements later in this chapter.)</p>
<p class="TX">The second line of the function <span aria-label="annotation2" class="CodeAnnotation">❷</span> contains a more complex <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement. Its controlling expression tests whether the divisor is 0 or whether the division would result in signed integer overflow if unchecked. If the result of this expression is not equal to 0, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> <span aria-label="annotation3" class="CodeAnnotation">❸</span> to indicate that it is unable to produce a quotient. If the controlling expression of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement evaluates to 0, the function does not return, and the remaining statements <span aria-label="annotation4" class="CodeAnnotation">❹</span> are executed to calculate the quotient and return <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.</p>
<p class="TX">The second kind of <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement includes an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause, which selects an alternative substatement to execute when the initial substatement is not selected:</p>

<pre><code>if (<var>expression</var>)
  <var>substatement1</var>
else
  <var>substatement2</var></code></pre>
<p class="TX">In this form, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement1</samp> is executed if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp> is not equal to 0, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement2</samp> is executed if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp> is equal to 0. One of these substatements is executed, but never both.</p>
<p class="TX">For either form of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, the conditionally executed substatement may also be an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement. A common use of this is the <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> ladder, shown in <a href="chapter5.xhtml#Lis5-2">Listing 5-2</a>.</p>
<span id="Lis5-2"/>
<pre><code>if (<var>expr1</var>)
  <var>substatement1</var>
else if (<var>expr2</var>)
  <var>substatement2</var>
else if (<var>expr3</var>)
  <var>substatement3</var>
else
  <var>substatement4</var></code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-2: The</samp> <samp class="I">if...else</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">ladder syntax</samp></p>
<p class="TX">One (and only one) of the four statements in an <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> ladder will execute:</p>
<ul class="ul">
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement1</samp> executes if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr1</samp> does not equal 0.</li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement2</samp> executes if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr1</samp> equals 0 and if <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr2</samp> does not equal 0.</li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement3</samp> executes if both <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr2</samp> equal 0 and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expr3</samp> does not equal 0.</li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">substatement4</samp> executes only if the preceding conditions are all equal to 0.</li>
</ul>
<p class="TX"><span aria-label="101" epub:type="pagebreak" id="pg_101" role="doc-pagebreak"/>The example shown in <a href="chapter5.xhtml#Lis5-3">Listing 5-3</a> uses an <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> ladder to print grades.</p>
<span id="Lis5-3"/>
<pre><code>void printgrade(unsigned int marks) {
  if (marks &gt;= 90) {
    puts("YOUR GRADE : A");
  } else if (marks &gt;= 80) {
    puts("YOUR GRADE : B");
  } else if (marks &gt;= 70) {
    puts("YOUR GRADE : C");
  } else {
    puts("YOUR GRADE : Failed");
  }
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-3: Using an</samp> <samp class="I">if...else</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">ladder to print grades</samp></p>
<p class="TX">In this <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> ladder, the <samp class="SANS_TheSansMonoCd_W5Regular_11">printgrade</samp> function tests the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp> to determine whether it is greater than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">90</samp>. If so, the function prints <samp class="SANS_TheSansMonoCd_W5Regular_11">YOUR GRADE : A</samp>. Otherwise, it tests whether <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp> is greater than or equal to 80, and so forth down the <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> ladder. If <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp> is not greater than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">70</samp>, the function prints <samp class="SANS_TheSansMonoCd_W5Regular_11">YOUR GRADE : Failed</samp>. This example uses a coding style in which the closing brace is followed by the <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> clause on the same line.</p>
<p class="TX">Only a single statement following the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement is executed. For example, in the following code snippet, <samp class="SANS_TheSansMonoCd_W5Regular_11">conditionally_executed</samp> is executed only if <samp class="SANS_TheSansMonoCd_W5Regular_11">condition</samp> is not equal to 0, but <samp class="SANS_TheSansMonoCd_W5Regular_11">unconditionally_executed</samp> is always executed:</p>

<pre><code>if (condition)
  conditionally_executed();
unconditionally_executed(); // always executed</code></pre>
<p class="TX">Attempting to add another conditionally executed function is a common source of errors:</p>

<pre><code>if (condition)
  conditionally_executed();
  also_conditionally_executed(); // ????
unconditionally_executed(); // always executed</code></pre>
<p class="TX">In this code snippet, <samp class="SANS_TheSansMonoCd_W5Regular_11">also_conditionally_executed</samp> is <i>unconditionally</i> executed. The name and indented formatting are deceptive because whitespace (in general) and indentation (in particular) are meaningless to the syntax. This code can be fixed by adding braces to delimit a single compound statement or block. This block is then executed as the single conditionally executed statement:</p>

<pre><code>if (condition) {
  conditionally_executed();
  also_conditionally_executed(); // fixed it
}
unconditionally_executed(); // always executed</code></pre>
<p class="TX"><span aria-label="102" epub:type="pagebreak" id="pg_102" role="doc-pagebreak"/>While the original code snippet was not incorrect, many coding guidelines recommend always including braces to avoid this kind of error:</p>

<pre><code>if (condition) {
  conditionally_executed();
}
unconditionally_executed(); // always executed</code></pre>
<p class="TX">My personal style is to omit the braces only when I can include the conditionally executed statement on the same line as the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement:</p>

<pre><code>if (!quotient) return false;</code></pre>
<p class="TX">This issue is less problematic when you let your integrated development environment (IDE) format your code for you, as it won’t be fooled by code indentation when formatting your code. The GCC and Clang compilers provide a <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wmisleading-indentation</samp> compiler flag that checks code indentation and warns when it doesn’t correspond to the control flow.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">

<h3 class="H2" id="sec5"><span id="h2-60"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">switch</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement works just like the <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> ladder, except that the controlling expression must have an integer type. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement in <a href="chapter5.xhtml#Lis5-4">Listing 5-4</a> performs the same function as the <samp class="SANS_TheSansMonoCd_W5Regular_11">if...else</samp> ladder from <a href="chapter5.xhtml#Lis5-3">Listing 5-3</a>, provided that <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp> is an integer in the range of 0 to 109. If <samp class="SANS_TheSansMonoCd_W5Regular_11">marks</samp> is greater than 109, it will result in a failed grade because the resulting quotient will be greater than 10 and will consequently be caught by the default case.</p>
<span id="Lis5-4"/>
<pre><code>switch (marks/10) {
  case 10:
  case 9:
    puts("YOUR GRADE : A");
    break;
  case 8:
    puts("YOUR GRADE : B");
    break;
  case 7:
    puts("YOUR GRADE : C");
    break;
  default:
    puts("YOUR GRADE : Failed");
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-4: Using a</samp> <samp class="I">switch</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement to print out grades</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement causes control to jump to one of the three substatements, depending on the value of the controlling expression and the constant expressions in each <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> label. Following the jump, code is executed sequentially until the next control flow statement is reached. In our example, a jump to <samp class="SANS_TheSansMonoCd_W5Regular_11">case 10</samp> (which is empty) flows through and executes <span aria-label="103" epub:type="pagebreak" id="pg_103" role="doc-pagebreak"/>the subsequent statements in <samp class="SANS_TheSansMonoCd_W5Regular_11">case 9</samp>. This is necessary to the logic so that a perfect grade of 100 results in an A and not an F.</p>
<p class="TX">You can terminate the execution of the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> by inserting a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement, causing control to jump to the execution of the statement directly following the overall <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement. (We discuss <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statements in more detail later in this chapter.) Make sure you remember to include a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement before the next <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> label. If omitted, the control flow falls through to the next <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement—a common source of errors. Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement isn’t required, omitting it doesn’t typically produce compiler diagnostics. GCC issues a warning for fall-through if you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wimplicit-fallthrough</samp> flag. The C23 standard introduces the <samp class="SANS_TheSansMonoCd_W5Regular_11">[[fallthrough]]</samp> attribute as a way for a programmer to specify that fall-through behavior is desirable, under the assumption that silent fall-through is an accidental omission of a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement.</p>
<p class="TX">Integer promotions are performed on the controlling expression. The constant expression in each <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> label is converted to the promoted type of the controlling expression. If a converted value matches that of the promoted controlling expression, control jumps to the statement following the matched <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> label. Otherwise, if there is no match but there is a <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> label, control jumps to the labeled statement. If no converted <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> constant expression matches and there is no <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> label, no part of the switch body is executed. When <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statements are nested, a <samp class="SANS_TheSansMonoCd_W5Regular_11">case</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> label is accessible only within the closest enclosing <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement.</p>
<p class="TX">There are best practices regarding the use of <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statements. <a href="chapter5.xhtml#Lis5-5">Listing 5-5</a> shows a less-than-ideal implementation of a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement that assigns interest rates to an account based on the account type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp> enumeration represents the fixed number of account types offered by the bank.</p>
<span id="Lis5-5"/>
<pre><code>typedef enum {Savings, Checking, MoneyMarket} AccountType;
void assignInterestRate(AccountType account) {
  double interest_rate;
  switch (account) {
    case Savings:
      interest_rate = 3.0;
      break;
    case Checking:
      interest_rate = 1.0;
      break;
    case MoneyMarket:
      interest_rate = 4.5;
      break;
  }
  printf("Interest rate = %g.\n", interest_rate);
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-5: A</samp> <samp class="I">switch</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement without a</samp> <samp class="I">default</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">label</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">assignInterestRate</samp> function defines a single parameter of the enumeration type <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp> and switches on it to assign the appropriate interest rate associated with each account type.</p>
<p class="TX"><span aria-label="104" epub:type="pagebreak" id="pg_104" role="doc-pagebreak"/>Nothing is wrong with the code as written, but it requires programmers to update the code in at least two separate places if they want to make any changes. Let’s say the bank introduces a new type of account: a certificate of deposit. A programmer updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp> enumeration as follows:</p>

<pre><code>typedef enum {Savings, Checking, MoneyMarket, CD} AccountType;</code></pre>
<p class="TX">However, if the programmer neglects to modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement in the <samp class="SANS_TheSansMonoCd_W5Regular_11">assignInterestRate</samp> function, the <samp class="SANS_TheSansMonoCd_W5Regular_11">interest_rate</samp> isn’t assigned, resulting in an uninitialized read when the function attempts to print that value. This problem is common because the enumeration may be declared far from the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement, and the program may contain many similar <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statements that all reference an object of type <samp class="SANS_TheSansMonoCd_W5Regular_11">AccountType</samp> in their controlling expression.</p>
<p class="TX">Both Clang and GCC help diagnose these problems at compilation time when you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">-Wswitch-enum</samp> flag. Alternatively, you can protect against such errors and improve the testability of this code by adding this <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> case to the <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement, as shown in <a href="chapter5.xhtml#Lis5-6">Listing 5-6</a>.</p>
<span id="Lis5-6"/>
<pre><code>typedef enum {Savings, Checking, MoneyMarket, CD} AccountType;
void assignInterestRate(AccountType account) {
  double interest_rate;
  switch (account) {
    case Savings:
      interest_rate = 3.0;
      break;
    case Checking:
      interest_rate = 1.0;
      break;
    case MoneyMarket:
      interest_rate = 4.5;
      break;
    case CD:
      interest_rate = 7.5;
      break;
<b>    default: abort();</b>
  }
  printf("Interest rate = %g.\n", interest_rate);
  return;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-6: A</samp> <samp class="I">switch</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement with a</samp> <samp class="I">default</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">label</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement now includes a case for <samp class="SANS_TheSansMonoCd_W5Regular_11">CD</samp>, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> clause is unused. However, retaining the <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> clause is good practice, in case another account type is added in the future.</p>
<p class="TX">Including a <samp class="SANS_TheSansMonoCd_W5Regular_11">default</samp> clause does have the drawback of suppressing compiler warnings and not diagnosing the problem until runtime. Compiler warnings (if supported by your compiler) are therefore a better approach.</p>
</section>
</section>
<section aria-labelledby="sec6" epub:type="division">
<span aria-label="105" epub:type="pagebreak" id="pg_105" role="doc-pagebreak"/>
<h2 class="H1" id="sec6"><span id="h1-52"/><samp class="SANS_Futura_Std_Bold_B_11">Iteration Statements</samp></h2>
<p class="TNI"><i>Iteration statements</i> cause substatements (or compound statements) to be executed zero or more times, subject to termination criteria. The English word <i>iteration</i> means “the repetition of a process.” Iteration statements are more informally and commonly referred to as loops. A <i>loop</i> is “a process, the end of which is connected to the beginning.”</p>
<section aria-labelledby="sec7" epub:type="division">

<h3 class="H2" id="sec7"><span id="h2-61"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">while</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> statement causes the loop body to execute repeatedly until the controlling expression is equal to 0. The evaluation of the controlling expression occurs before each execution of the loop body. Consider the following example:</p>

<pre><code>void f(unsigned int x) {
  while (x &gt; 0) {
    printf("%d\n," x);
    --x;
  }
  return;
}</code></pre>
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is not initially greater than 0, the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop exits without executing the loop body. If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is greater than 0, its value is output and then decremented. Once the end of the loop is reached, the controlling expression is tested again. This pattern repeats until the expression evaluates to 0. Overall, this loop will count down from <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> to 1.</p>
<p class="TX">A <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop is an entry-controlled loop that executes until its controlling expression evaluates to 0. <a href="chapter5.xhtml#Lis5-7">Listing 5-7</a> shows an implementation of the C standard library <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> function. This function copies the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp> (converted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>) into each of the first <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> characters of the object pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp>.</p>
<span id="Lis5-7"/>
<pre><code>void *memset(void *dest, int val, size_t n) {
  unsigned char *ptr = (unsigned char*)dest;
  while (n-- &gt; 0)
    *ptr++ = (unsigned char)val;
  return dest;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-7: The C standard library</samp> <samp class="I">memset</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp></p>
<p class="TX">The first line of the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> function converts <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp> to a pointer to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> and assigns the resulting value to the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp>. This lets us preserve the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp> to return on the last line of the function. The remaining two lines of the function form a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop that copies the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp> (converted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>) into each of the first <span aria-label="106" epub:type="pagebreak" id="pg_106" role="doc-pagebreak"/><samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> characters of the object <samp class="SANS_TheSansMonoCd_W5Regular_11">dest</samp> points to. The controlling expression of the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop tests that <samp class="SANS_TheSansMonoCd_W5Regular_11">n-- &gt; 0</samp>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> argument is a loop counter that’s decremented on each iteration of the loop as a side effect of the evaluation of the controlling expression. The loop counter in this case monotonically decreases until it reaches the minimum value (0). The loop performs <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> repetitions, where <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> is less than or equal to the bound of the memory that <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> references.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> pointer designates a sequence of objects of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp>, from <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> through <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">n - 1</samp>. The value of <samp class="SANS_TheSansMonoCd_W5Regular_11">val</samp> is converted to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned char</samp> and written to each object in turn. If <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> is greater than the bound of the object that <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> references, the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop writes to memory outside the bounds of this object. This is undefined behavior and a common security flaw, referred to as a <i>buffer overflow</i>, or <i>overrun</i>. Provided the object referenced by <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr</samp> has at least <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> bytes, the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop terminates without undefined behavior. In the final iteration of the loop, the controlling expression <samp class="SANS_TheSansMonoCd_W5Regular_11">n-- &gt; 0</samp> evaluates to 0, causing the loop to terminate.</p>
<p class="TX">It’s possible to write an <i>infinite loop</i>—a loop that never terminates. To avoid writing a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop that inadvertently runs forever, be sure you initialize any objects referenced by the controlling expression before the start of the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop. Also make sure that the controlling expression changes during the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop’s execution in a manner that causes the loop to terminate after iterating an appropriate number of times.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">

<h3 class="H2" id="sec8"><span id="h2-62"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">do...while</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> statement is similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> statement, except that the evaluation of the controlling expression occurs after each execution of the loop body rather than before. As a result, the loop body is guaranteed to execute once before the condition is tested. The <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> iteration statement has the following syntax:</p>

<pre><code>do
  <var>statement</var>
while (<var>expression</var>);</code></pre>
<p class="TX">In a <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> iteration, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">statement</samp> is unconditionally executed once, after which <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp> is evaluated. If <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression</samp> is not equal to 0, control returns to the top of the loop and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">statement</samp> is executed again. Otherwise, execution passes to the statement following the loop.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">do...while</samp> iteration statement is commonly used in input/output (I/O), where it makes sense to read from a stream before testing the state of the stream, as shown in <a href="chapter5.xhtml#Lis5-8">Listing 5-8</a>.</p>
<span id="Lis5-8"/>
<pre><code>#include &lt;stdio.h&gt;
// <var>--snip--</var>
int count;
float quant;
<span aria-label="107" epub:type="pagebreak" id="pg_107" role="doc-pagebreak"/>char units[21], item[21];
do {
  count = fscanf(stdin, "%f%20s of %20s", &amp;quant, units, item);
  fscanf(stdin,"%*[^\n]");
} while (!feof(stdin) &amp;&amp; !ferror(stdin));
// <var>--snip--</var></code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-8: An input loop</samp></p>
<p class="TX">This code inputs a floating-point quantity, a unit of measure (as a string), and an item name (also as a string) from the standard input stream <samp class="SANS_TheSansMonoCd_W5Regular_11">stdin</samp> until the end-of-file indicator has been set or a read error has occurred. We’ll discuss I/O in detail in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">

<h3 class="H2" id="sec9"><span id="h2-63"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">for</samp></h3>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> statement might be the most C-like thing about C. The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> statement repeatedly executes a statement and is typically used when the number of iterations is known before entering the loop. It has the following syntax:</p>

<pre><code>for (<var>clause1</var>; <var>expression2</var>; <var>expression3</var>)
  <var>statement</var></code></pre>
<p class="TX">The controlling expression (<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression2</samp>) is evaluated before each execution of the loop body, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression3</samp> is evaluated after each execution of the loop body. If <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">clause1</samp> is a declaration, the scope of any identifiers it declares is the remainder of the declaration and the entire loop, including the other two expressions.</p>
<p class="TX">The purpose of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">clause1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression3</samp> is apparent when we translate the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> statement into an equivalent <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop, as shown in <a href="chapter5.xhtml#fig5-1">Figure 5-1</a>.</p>
<figure class="IMG"><img alt="" class="img1" id="fig5-1" src="../images/f05001.jpg"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: Translating a <samp class="I">for</samp> loop into a <samp class="I">while</samp> loop</samp></p></figcaption>
</figure>
<p class="TX"><a href="chapter5.xhtml#Lis5-9">Listing 5-9</a> shows a modified version of the <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp> implementation from <a href="chapter5.xhtml#Lis5-7">Listing 5-7</a>; we have replaced the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop with a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop.</p>
<span id="Lis5-9"/>
<pre><code>void *memset(void *dest, int val, size_t n) {
  unsigned char *ptr = (unsigned char *)dest;
  for (<span aria-label="annotation1" class="CodeAnnotation">❶</span> size_t i = 0; <span aria-label="annotation2" class="CodeAnnotation">❷</span> i &lt; n; <span aria-label="annotation3" class="CodeAnnotation">❸</span> ++i) {
<span aria-label="108" epub:type="pagebreak" id="pg_108" role="doc-pagebreak"/>    *(ptr + i) = (unsigned char)val;
  }
  return dest;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-9: Filling a character array by using a</samp> <samp class="I">for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">loop</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is popular among C programmers because it provides a convenient location for declaring and/or initializing the loop counter <span aria-label="annotation1" class="CodeAnnotation">❶</span>, specifying the controlling expression for the loop <span aria-label="annotation2" class="CodeAnnotation">❷</span>, and incrementing the loop counter <span aria-label="annotation3" class="CodeAnnotation">❸</span>, all on the same line. The <samp class="SANS_TheSansMonoCd_W5Regular_11">*(ptr</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">i)</samp> lvalue expression could be written equivalently using the index operator as <samp class="SANS_TheSansMonoCd_W5Regular_11">ptr[i]</samp>.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop can also be somewhat misleading. Let’s take the example of a singly linked list in C that declares a <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp> structure consisting of a <samp class="SANS_TheSansMonoCd_W5Regular_11">data</samp> element and a pointer to the <samp class="SANS_TheSansMonoCd_W5Regular_11">next</samp> node in the list. We also define a pointer <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> to the <samp class="SANS_TheSansMonoCd_W5Regular_11">node</samp> structure:</p>

<pre><code>struct node {
  int data;
  struct node *next;
};
struct node *p;</code></pre>
<p class="TX">Using the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>, the following example (used to deallocate the storage for a linked list) erroneously reads the value <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> after it has been freed:</p>

<pre><code>for (p = head; p != nullptr; p = p-&gt;next) {
  free(p);
}</code></pre>
<p class="TX">Reading <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> after it has been freed is undefined behavior.</p>
<p class="TX">If this loop were rewritten as a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop, it would become apparent that the code reads <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> after it was freed:</p>

<pre><code>p = head;
while (p != nullptr) {
  free(p);
  p = p-&gt;next;
}</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop can be confusing because it evaluates <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">expression3</samp> after the main body of the loop, even though lexically it appears before the loop’s body.</p>
<p class="TX">The correct way to perform this operation is to save the required pointer before freeing it, like this:</p>

<pre><code>for (p = head; p != nullptr; p = q) {
  q = p-&gt;next;
  free(p);
}</code></pre>
<p class="TX">You can read more about dynamic memory management in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>.</p>
</section>
</section>
<section aria-labelledby="sec10" epub:type="division">
<span aria-label="109" epub:type="pagebreak" id="pg_109" role="doc-pagebreak"/>
<h2 class="H1" id="sec10"><span id="h1-53"/><samp class="SANS_Futura_Std_Bold_B_11">Jump Statements</samp></h2>
<p class="TNI">A <i>jump statement</i> unconditionally transfers control to another section of the same function when encountered. These are the lowest-level control flow statements and generally correspond closely to the underlying assembly language code.</p>
<section aria-labelledby="sec11" epub:type="division">

<h3 class="H2" id="sec11"><span id="h2-64"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">goto</samp></h3>
<p class="TNI">Any statement may be preceded by a <i>label</i>, which is an identifier followed by a colon. C23 also allows you to place labels in front of declarations and at the end of a compound statement, which was not allowed in previous versions of C. A <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> statement causes a jump to the statement prefixed by the named label in the enclosing function. The jump is unconditional, meaning it happens every time the <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> statement is executed. Here’s an example of a <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> statement:</p>

<pre><code>  /* executed statements */
  goto location;
  /* skipped statements */
location:
  /* executed statements */</code></pre>
<p class="TX">Execution continues until the <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> statement is reached, at which point control jumps to the statement following the <samp class="SANS_TheSansMonoCd_W5Regular_11">location</samp> label, where execution continues. Statements between the <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> statement and the label are passed over.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> statement has had a bad reputation since Edsger Dijkstra wrote a paper titled “Go To Statement Considered Harmful” (1968). His criticism was that <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> statements can result in <i>spaghetti code</i> (code with a complex and tangled control structure, resulting in a program flow that’s conceptually twisted and tangled like a bowl of spaghetti) if used haphazardly. However, <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> statements can also make code easier to read if used in a clear, consistent manner.</p>
<p class="TX">One helpful way to use <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> statements is to chain them together to release allocated resources (such as dynamic allocated memory or an open file) when an error occurs and you must leave a function. This scenario happens when a program allocates multiple resources; each allocation can fail, and resources must be released to prevent leaking. If the first resource allocation fails, no cleanup is needed, because no resources have been allocated. However, if the second resource cannot be allocated, the first resource needs to be released. Similarly, if the third resource cannot be allocated, the second and first resources allocated need to be released, and so forth. This pattern results in duplicated cleanup code, and it can be error-prone because of the duplication and additional complexity.</p>
<p class="TX"><span aria-label="110" epub:type="pagebreak" id="pg_110" role="doc-pagebreak"/>One solution is to use nested <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements, which can also become difficult to read if nested too deeply. Instead, we can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> chain as shown in <a href="chapter5.xhtml#Lis5-10">Listing 5-10</a> to release resources.</p>
<span id="Lis5-10"/>
<pre><code>int do_something(void) {
  FILE *file1, *file2;
  object_t *obj;
  int ret_val = 0; // initially assume a successful return value

  file1 = fopen("a_file", "w");
  if (file1 == nullptr) {
    return -1;
  }

  file2 = fopen("another_file", "w");
  if (file2 == nullptr) {
    ret_val = -1;
<b>    goto FAIL_FILE2;</b>
  }

  obj = malloc(sizeof(*obj));
  if (obj == nullptr) {
    ret_val = -1;
<b>    goto FAIL_OBJ;</b>
  }

  // operate on allocated resources

  // clean up everything
  free(obj);
<b>FAIL_OBJ:</b>  // otherwise, close only the resources we opened
  fclose(file2);
<b>FAIL_FILE2:</b>
  fclose(file1);
  return ret_val;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-10: Using a</samp> <samp class="I">goto</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">chain to release resources</samp></p>
<p class="TX">The code follows a simple pattern: resources are allocated in a certain order, operated upon, and then released in reverse (last in, first out) order. If an error occurs while allocating a resource, the code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> to jump to the appropriate location in cleanup code and releases only those resources that have been allocated.</p>
<p class="TX">Used like this, <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> statements can make code easier to read. A real-world example is the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy_process</samp> function from <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel/fork.c</samp> from v6.7 of the Linux kernel (<i><a href="https://elixir.bootlin.com/linux/v6.7/source/kernel/fork.c#L2245">https://<wbr/>elixir<wbr/>.bootlin<wbr/>.com<wbr/>/linux<wbr/>/v6<wbr/>.7<wbr/>/source<wbr/>/kernel<wbr/>/fork<wbr/>.c#L2245</a></i>), which uses 20 <samp class="SANS_TheSansMonoCd_W5Regular_11">goto</samp> labels to perform cleanup code when an internal function fails.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<span aria-label="111" epub:type="pagebreak" id="pg_111" role="doc-pagebreak"/>
<h3 class="H2" id="sec12"><span id="h2-65"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">continue</samp></h3>
<p class="TNI">You can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement inside a loop to jump to the end of the loop body, skipping the execution of the remaining statements inside the loop body for the current iteration. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">goto END_LOOP_BODY;</samp> in each of the loops shown in <a href="chapter5.xhtml#Lis5-11">Listing 5-11</a>.</p>

<pre><code>while (/* _ */) {
  // <var>--snip--</var>
  continue;
  // <var>--snip--</var>
END_LOOP_BODY: ;
}</code></pre>

<pre><code>do {
  // <var>--snip--</var>
  continue;
  // <var>--snip--</var>
END_LOOP_BODY: ;
} while (/* _ */);</code></pre>
<span id="Lis5-11"/>
<pre><code>for (/* _ */) {
  // <var>--snip--</var>
  continue;
  // <var>--snip--</var>
END_LOOP_BODY: ;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-11: Using the</samp> <samp class="I">continue</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement is used in conjunction with a conditional statement so that processing may continue with the subsequent loop iteration after the objective of the current loop iteration has been achieved.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">

<h3 class="H2" id="sec13"><span id="h2-66"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">break</samp></h3>
<p class="TNI">A <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement terminates execution of a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> or iteration statement. We used <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> within a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp> statement in <a href="chapter5.xhtml#Lis5-4">Listing 5-4</a>. Within a loop, a <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement causes the loop to terminate and the program execution to resume at the statement following the loop. For instance, the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop in the following example exits only when the uppercase or lowercase Q key is pressed on the keyboard:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(void) {
  char c;
  for(;;) {
    puts("Press any key, Q to quit: ");
    c = toupper(getchar());
    if (c == 'Q') <b>break</b>;
    // <var>--snip--</var>
  }
} // loop exits when either q or Q is pressed</code></pre>
<p class="TX">We typically use <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statements to discontinue the execution of the loop when the work it was performing has been completed. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement in <a href="chapter5.xhtml#Lis5-12">Listing 5-12</a> exits the loop after it finds the specified key in an array. Assuming that <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp> is unique in <samp class="SANS_TheSansMonoCd_W5Regular_11">arr</samp>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">find_element</samp> function would behave the same without the <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> statement but, depending on the length of the array and the point at which <samp class="SANS_TheSansMonoCd_W5Regular_11">key</samp> is discovered, could run much slower.</p>
<span id="Lis5-12"/>
<pre><code>size_t find_element(size_t len, int arr[len], int key) {
  size_t pos = (size_t)-1;
  // traverse arr and search for key
  for (size_t i = 0; i &lt; len; ++i) {
<span aria-label="112" epub:type="pagebreak" id="pg_112" role="doc-pagebreak"/>    if (arr[i] == key) {
      pos = i;
<b>      break</b>;<b>  </b>// terminate loop
    }
  }
  return pos;
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-12: Breaking out of a loop</samp></p>
<p class="TX">Because <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">break</samp> bypass part of a loop body, use these statements carefully: the code following these statements is not executed.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">

<h3 class="H2" id="sec14"><span id="h2-67"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">return</samp></h3>
<p class="TNI">A <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement terminates execution of the current function and returns control to its caller. You’ve already seen many examples of <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statements in this book. A function may have zero or more <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statements.</p>
<p class="TX">A <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement can simply return, or it can return an expression. Within a <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> function (a function that doesn’t return a value), the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement should simply return. When a function returns a value, the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement should return an expression that produces a value of the return type. If a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement with an expression is executed, the value of the expression is returned to the caller as the value of the function call expression:</p>

<pre><code>int sum(int x, int y, int z) {
  return x + y + z;
}</code></pre>
<p class="TX">This simple function sums its parameters and returns the sum. The return expression <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp> produces a value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, which matches the return type of the function. If this expression produced a different type, it would be implicitly converted to an object having the return type of the function. The return expression can also be as simple as returning 0 or 1. The function result may then be used in an expression or assigned to a variable.</p>
<p class="TX">Be aware that if control reaches the closing brace of a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> function (a function declared to return a value) without evaluating a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement with an expression, using the return value of the function call is undefined behavior. For example, the following function fails to return a value when <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is nonnegative because the condition <samp class="SANS_TheSansMonoCd_W5Regular_11">a &lt; 0</samp> is false:</p>

<pre><code>int absolute_value(int a) {
  if (a &lt; 0) {
    return -a;
  }
}</code></pre>
<p class="TX"><span aria-label="113" epub:type="pagebreak" id="pg_113" role="doc-pagebreak"/>We can easily repair this defect by providing a return value when <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is nonnegative, as shown in <a href="chapter5.xhtml#Lis5-13">Listing 5-13</a>.</p>
<span id="Lis5-13"/>
<pre><code>int absolute_value(int a) {
  if (a &lt; 0) {
    return -a;
  }
<b>  return a;</b>
}</code></pre>
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-13: The</samp> <samp class="I">absolute_value</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function returns a value along all paths.</samp></p>
<p class="TX">However, this code still has a bug (see <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>). Identifying this bug is left as an exercise for you.</p>
<aside aria-label="box-7" class="box1">
<p class="BoxTitle" id="box-7"><samp class="SANS_Dogma_OT_Bold_B_11">EXERCISES</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Book_11">1.  Modify the function from <a href="chapter5.xhtml#Lis5-10">Listing 5-10</a> to make it clear to the caller which file could not be opened.</samp></p>
<p class="BoxListNumber"><samp class="SANS_Futura_Std_Book_11">2.  Fix the remaining bug in the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">absolute_value</samp> <samp class="SANS_Futura_Std_Book_11">function in <a href="chapter5.xhtml#Lis5-13">Listing 5-13</a>.</samp></p>
</aside>
</section>
</section>
<section aria-labelledby="sec15" epub:type="division">

<h2 class="H1" id="sec15"><span id="h1-54"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h2>
<p class="TNI">In this chapter, you learned about control flow statements. Control flow statements allow you to create flexible programs that can repeat tasks and alter their execution based on program inputs:</p>
<ul class="ul">
<li class="ListBullet">Selection statements, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">switch</samp>, allow you to select from a set of statements depending on the value of a controlling expression.</li>
<li class="ListBullet">Iteration statements repeatedly execute a loop body until a controlling expression equals 0.</li>
<li class="ListBullet">Jump statements unconditionally transfer control to a new location.</li>
</ul>
<p class="TX">In the next chapter, you’ll learn about dynamically allocated memory. Similar to control flow statements, you can use dynamic memory to create flexible programs that allocate memory based on program inputs.</p>
</section>
</section>
</body></html>