<html><head></head><body>
<section><header>
<h1 class="Appendix"><span class="AppendixNumber"><span epub:type="pagebreak" title="935" id="Page_935"/>E</span><br/>
<span class="AppendixTitle">Answers to Questions</span></h1>
</header>
<h2 id="h1-501089b05-0001">	E.1	Answers to Questions in Chapter 1</h2>
<ol class="decimal">
<li value="1"><em>cmd.exe</em></li>
<li value="2"><em>ml64.exe</em></li>
<li value="3">Address, data, and control</li>
<li value="4">AL, AH, AX, and EAX</li>
<li value="5">BL, BH, BX, and EBX</li>
<li value="6">SIL, SI, and ESI</li>
<li value="7">R8B, R8W, and R8D</li>
<li value="8">FLAGS, EFLAGS, or RFLAGS</li>
<li value="9">(a) 2, (b) 4, (c) 16, (d) 32, (e) 8</li>
<li value="10">Any 8-bit register and any constant that can be represented with 8 bits</li>
<li value="11">32</li>
<li value="12"><span epub:type="pagebreak" title="936" id="Page_936"/>
<table id="tabular-501089b05-0001" border="1"><tbody>
<tr>
<td><b>Destination</b></td>
<td><b>Constant size</b></td>
</tr>
<tr>
<td>RAX</td>
<td>32</td>
</tr>
<tr>
<td>EAX</td>
<td>32</td>
</tr>
<tr>
<td>AX</td>
<td>16</td>
</tr>
<tr>
<td>AL</td>
<td>8</td>
</tr>
<tr>
<td>AH</td>
<td>8</td>
</tr>
<tr>
<td>mem<sub>32</sub></td>
<td>32</td>
</tr>
<tr>
<td>mem<sub>64</sub></td>
<td>32</td>
</tr>
</tbody>
</table>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	64-bit add operands support only 32-bit constants.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside></li>
<li value="13">64<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Technically the x86-64 allows 16- and 32-bit registers as <code>lea</code> destination operands for legacy reasons; however, such instructions are not generally useful for calculating actual memory addresses (though they might be useful for sneaky addition operations).</p>
<div class="bottom hr"><hr/></div>
</section>
</aside></li>
<li value="14">Any memory operand will work, regardless of its size.</li>
<li value="15"><code>call</code></li>
<li value="16"><code>ret</code></li>
<li value="17">Application binary interface</li>
<li value="18">(a) AL, (b) AX, (c) EAX, (d) RAX, (e) XMM0, (f) RAX</li>
<li value="19">RCX for integer operands, XMM0 for floating-point/vector operands</li>
<li value="20">RDX for integer operands, XMM1 for floating-point/vector operands</li>
<li value="21">R8 for integer operands, XMM2 for floating-point/vector operands</li>
<li value="22">R9 for integer operands, XMM3 for floating-point/vector operands</li>
<li value="23"><code>dword</code> or <code>sdword</code></li>
<li value="24"><code>qword</code></li>
</ol>
<h2 id="h1-501089b05-0002">	E.2	Answers to Questions in Chapter 2</h2>
<ol class="decimal">
<li value="1">9 × 10<sup>3 </sup>+ 3 × 10<sup>2 </sup>+ 8 × 10<sup>1 </sup>+ 4 × 10<sup>0 </sup>+ 5 × 10<sup>-1 </sup>+ 7 × 10<sup>-2 </sup>+ 6 × 10<sup>-3</sup></li>
<li value="2">(a) 10, (b) 12, (c) 7, (d) 9, (e) 3, (f) 15</li>
<li value="3">(a) A, (b) E, (c) B, (d) D, (e) 2, (f) C, (g) CF, (h) 98D1</li>
<li value="4">(a) 0001_0010_1010_1111, (b) 1001_1011_1110_0111, (c) 0100_1010, (d) 0001_0011_0111_1111, (e) 1111_0000_0000_1101, (f) 1011_1110_1010_1101, (g) 0100_1001_0011_1000</li>
<li value="5">(a) 10, (b) 11, (c) 15, (d) 13, (e) 14, (f) 12</li>
<li value="6"><span epub:type="pagebreak" title="937" id="Page_937"/>(a) 16, (b) 64, (c) 128, (d) 32, (e) 4, (f) 8, (g) 4</li>
<li value="7">(a) 2, (b) 4, (c) 8, (d) 16</li>
<li value="8">(a) 16, (b) 256, (c) 65,636, (d) 2</li>
<li value="9">4</li>
<li value="10">0 through 7</li>
<li value="11">Bit 0</li>
<li value="12">Bit 31</li>
<li value="13">(a) 0, (b) 0, (c) 0, (d) 1</li>
<li value="14">(a) 0, (b) 1, (c) 1, (d) 1</li>
<li value="15">(a) 0, (b) 1, (c) 1, (d) 0</li>
<li value="16">1</li>
<li value="17">AND</li>
<li value="18">OR</li>
<li value="19">NOT</li>
<li value="20">XOR</li>
<li value="21"><code>not</code></li>
<li value="22">1111_1011</li>
<li value="23">0000_0010</li>
<li value="24">(a) and (c) and (e)</li>
<li value="25"><code>neg</code></li>
<li value="26">(a) and (c) and (d) </li>
<li value="27"><code>jmp</code></li>
<li value="28"><em>label:</em></li>
<li value="29">Carry, overflow, zero, and sign</li>
<li value="30">JZ</li>
<li value="31">JC</li>
<li value="32">JA, JAE, JBE, JB, JE, JNE (and the synonyms JNA, JNAE, JNB, JNBE, plus other synonyms)</li>
<li value="33">JG, JGE, JL, JLE, JE, JNE (and the synonyms JNG, JNGE, JNL, and JNLE)</li>
<li value="34">ZF = 1 if the result of the shift is 0.</li>
<li value="35">The HO bit shifted out of the operand goes into the carry flag.</li>
<li value="36">If the next-to-HO bit is different from the HO bit <em>before</em> the shift, the OF will be set; otherwise, it is cleared, though only for 1-bit shifts.</li>
<li value="37">The SF is set equal to the HO bit of the result.</li>
<li value="38">ZF = 1 if the result of the shift is 0.</li>
<li value="39">The LO bit shifted out of the operand goes into the carry flag.</li>
<li value="40">If the next-to-HO bit is different from the HO bit <em>before</em> the shift, the OF will be set; otherwise, it is cleared, but only for 1-bit shifts.</li>
<li value="41"><span epub:type="pagebreak" title="938" id="Page_938"/>The SF is always clear after the SHR instruction because a 0 is always shifted into the HO bit of the result.</li>
<li value="42">ZF = 1 if the result of the shift is 0.</li>
<li value="43">The LO bit shifted out of the operand goes into the carry flag.</li>
<li value="44">The OF is always clear after SAR as it is impossible for the sign to change.</li>
<li value="45">The SF is set equal to the HO bit of the result, though technically it will never change.</li>
<li value="46">The HO bit shifted out of the operand goes into the carry flag.</li>
<li value="47">It doesn’t affect the ZF.</li>
<li value="48">The LO bit shifted out of the operand goes into the carry flag.</li>
<li value="49">It doesn’t affect the sign flag.</li>
<li value="50">Multiplication by 2</li>
<li value="51">Division by 2</li>
<li value="52">Multiplication and division</li>
<li value="53">Subtract them and see if their difference is less than a small error value.</li>
<li value="54">A value that has a 1 bit in the HO mantissa position</li>
<li value="55">7</li>
<li value="56">30h through 39h</li>
<li value="57">Apostrophes and quotes</li>
<li value="58">UTF-8, UTF-16, and UTF-32</li>
<li value="59">A scalar integer value that represents a single Unicode character</li>
<li value="60">A block of 65,536 different Unicode characters</li>
</ol>
<h2 id="h1-501089b05-0003">	E.3	Answers to Questions in Chapter 3</h2>
<ol class="decimal">
<li value="1">RIP</li>
<li value="2">Operation code, the numeric encoding for a machine instruction</li>
<li value="3">Static and scalar variables</li>
<li value="4">±2GB</li>
<li value="5">The address of the memory location to access</li>
<li value="6">RAX</li>
<li value="7"><code>lea</code></li>
<li value="8">The final address obtained after all addressing mode calculations are completed</li>
<li value="9">1, 2, 4, or 8</li>
<li value="10">2GB total memory</li>
<li value="11">You can use the VAR[REG] addressing mode(s) to directly access elements of an array using a 64-bit register as an index into the array without first loading the address of the array into a separate base register.</li>
<li value="12"><span epub:type="pagebreak" title="939" id="Page_939"/>The <code>.data</code> section can hold initialized data values; the <code>.data?</code> section can contain only uninitialized variables.</li>
<li value="13"><code>.code</code> and <code>.const</code></li>
<li value="14"><code>.data</code> and <code>.data?</code></li>
<li value="15">An offset into a particular section (for example, <code>.data</code>)</li>
<li value="16">Use <var>some_ID</var><code> label </code><var>some_type</var> to inform MASM that the following data is of type <var>some_type</var> when, in fact, it could be another type.</li>
<li value="17">MASM will combine them into a single section.</li>
<li value="18">Use the <code>align 8</code> statement.</li>
<li value="19">Memory management unit</li>
<li value="20">If <code>b</code> is at an address that is at the last byte in an MMU page and the next page is not readable, loading a word from the memory location starting with <code>b</code> will produce a general protection fault.</li>
<li value="21">A constant expression plus the base address of a variable in memory</li>
<li value="22">To coerce the following operand type to a different type</li>
<li value="23">Little-endian values appear in memory with their LO byte at the lowest address and the HO byte at the highest address. Big-endian values are the opposite: their HO byte appears at the lowest address, and their LO byte appears at the highest address in memory.</li>
<li value="24"><code>xchg al, ah</code> or <code>xchg ah, al</code></li>
<li value="25"><code>bswap eax</code></li>
<li value="26"><code>bswap rax</code></li>
<li value="27">(a) Subtract 8 from RSP, (b) Store the value in RAX at the location pointed at by RSP.</li>
<li value="28">(a) Load RAX from the 8 bytes pointed at by RSP, (b) Add 8 to RSP.</li>
<li value="29">Reverse</li>
<li value="30">Last in, first out</li>
<li value="31">Move the data to and from the stack using the <code>[RSP ± </code><var>const</var><code>]</code> addressing mode.</li>
<li value="32">The Windows ABI requires the stack to be aligned on a 16-byte boundary; pushing RAX might make the stack aligned on an 8-byte (but not 16-byte) boundary.</li>
</ol>
<h2 id="h1-501089b05-0004">	E.4	Answers to Questions in Chapter 4</h2>
<ol class="decimal">
<li value="1"><code>imul </code><var>reg</var><code>, </code><var>constant</var></li>
<li value="2"><code>imul </code><var>destreg</var><code>, </code><var>srcreg</var><code>, </code><var>constant</var></li>
<li value="3"><code>imul </code><var>destreg</var><code>, </code><var>srcreg</var></li>
<li value="4">A symbolic (named) constant for which MASM will substitute the literal constant for the name everywhere it appears in the source file</li>
<li value="5"><code>=</code>, <code>equ</code>, <code>textequ</code></li>
<li value="6"><span epub:type="pagebreak" title="940" id="Page_940"/>Text equates substitute a textual string that can be any text; numeric equates must be assigned a numeric constant value that can be represented with a 64-bit integer.</li>
<li value="7">Use the text delimiters <code>&lt;</code> and <code>&gt;</code> around the string literal; for example, <code>&lt;"a long string"&gt;</code>.</li>
<li value="8">An arithmetic expression whose value MASM can calculate during assembly</li>
<li value="9"><code>lengthof</code></li>
<li value="10">The offset into the current section</li>
<li value="11"><code>this</code> and <code>$</code></li>
<li value="12">Use the constant expression <code>$-startingLocation</code>.</li>
<li value="13">Use a series of (numeric) equates, with each successive equate set to the value of the previous equate plus one; for example:
<pre><code>val1 = 0
val2 = val1 + 1
val3 = val2 + 1
etc.</code></pre></li>
<li value="14">Using the <code>typedef</code> directive</li>
<li value="15">A pointer is a variable in memory that holds the address of another object in memory.</li>
<li value="16">Load the pointer variable into a 64-bit register and use the register-indirect addressing mode to reference that address.</li>
<li value="17">Using a <code>qword</code> data declaration, or another data type that is 64 bits in size</li>
<li value="18">The <code>offset</code> operator</li>
<li value="19">(a) Uninitialized pointers, (b) Using pointers to hold an illegal value, (c) Using a pointer after its storage has been freed (dangling pointers), (d) Failing to free storage after it is no longer being used (memory leak), (e) Accessing indirect data by using the wrong data type</li>
<li value="20">Using a pointer after its storage has been freed</li>
<li value="21">Failing to free storage after you are done using it</li>
<li value="22">An aggregate type composed of smaller data objects</li>
<li value="23">A sequence of characters ending with a 0 byte (or other 0 value)</li>
<li value="24">A string containing a length value as its first element</li>
<li value="25">A descriptor is a data type containing a pointer (to the character data), string length, and possibly other information that describes the string data.</li>
<li value="26">A homogenous collection of data elements (all with the same type)</li>
<li value="27">The memory address of the first element of the array</li>
<li value="28"><code>array byte 10 dup (?)</code> (as an example)</li>
<li value="29"><span epub:type="pagebreak" title="941" id="Page_941"/>Simply fill in the initial values as the operand field of a byte, word, dword, or other data declaration directive. Also, you could use a sequence of one or more constant values as the <code>dup</code> operator operand; for example, <code>5 dup (2, 3)</code>.</li>
<li value="30">(a) <var>base_address</var><code> + </code><var>index</var><code> * 4</code> (4 is the element size), (b) <code>W[i,j] = </code><var>base_address</var><code> + (i * 8 + j) * 2</code> (2 is the element size), (c) <code>R[i,j,k] = </code><var>base_address</var><code> +(((i * 4) + j) * 6 + k) * 8</code> (8 is the element size)</li>
<li value="31">An organization for multidimensional arrays where you store the elements of each row in the array in contiguous memory locations and then store each row, one after the other, in memory</li>
<li value="32">An organization for multidimensional arrays where you store the elements of each column in the array in contiguous memory locations and then store each column, one after the other, in memory</li>
<li value="33"><code>W word 4 dup (8 dup (?))</code></li>
<li value="34">A heterogeneous collection of data elements (each field could have different types)</li>
<li value="35"><code>struct</code> and <code>ends</code></li>
<li value="36">The dot operator</li>
<li value="37">A heterogeneous collection of data elements (each field could have different types); the offset of each field in the union begins at 0.</li>
<li value="38"><code>union</code> and <code>ends</code></li>
<li value="39">The fields of a record and struct appear at successive memory locations within the struct (each field has its own block of bytes); the fields of a union overlap one another, with each field beginning at offset zero in the union.</li>
<li value="40">An unnamed union whose fields are treated as fields of the enclosing struct</li>
</ol>
<h2 id="h1-501089b05-0005">	E.5	Answers to Questions in Chapter 5</h2>
<ol class="decimal">
<li value="1">It pushes the return address onto the stack (the address of the next instruction after the call) and then jumps to the address specified by the operand.</li>
<li value="2">It pops a return address off the stack and moves the address into the RIP register, transferring control to the instruction just beyond the call to the current procedure.</li>
<li value="3">After popping the return address, the CPU adds this value to RSP, removing that number of bytes of parameters from the stack.</li>
<li value="4">The address of the instruction just beyond the call to the procedure</li>
<li value="5">Namespace pollution occurs when so many symbols, identifiers, or names are defined in a source file that it becomes difficult to select new, unique names to use in that source file.</li>
<li value="6">Put two colons after the name; for example, <code>id::</code>.</li>
<li value="7"><span epub:type="pagebreak" title="942" id="Page_942"/>Use the <code>option noscoped</code> directive just before the procedure.</li>
<li value="8">Use the <code>push</code> instruction to save the register values on the stack upon entry into the procedure; then use the <code>pop</code> instruction to restore the register values immediately before returning from the procedure.</li>
<li value="9">Code is difficult to maintain. (A secondary issue, though minor, is that it takes more space.)</li>
<li value="10">Performance—because you’re often preserving registers that don’t need to be preserved for the calling code</li>
<li value="11">When the subroutine attempts to return, it uses the garbage you left on the stack as the return address, which usually produces undefined results (a program crash).</li>
<li value="12">The subroutine uses whatever was on the stack prior to the call as the return address, with undefined results.</li>
<li value="13">A collection of data, including parameters, local variables, the return address, and other items, associated with the call (activation) of a procedure</li>
<li value="14">RBP</li>
<li value="15">8 bytes (64 bits)</li>
<li value="16">
<pre><code>push rbp
mov  rbp, rsp
sub  rsp, sizeOfLocals ; Assuming there are local variables</code></pre></li>
<li value="17">
<pre><code>leave
ret</code></pre></li>
<li value="18"><code>and rsp, -16</code></li>
<li value="19">The section of the source file (usually the body of a procedure) where the symbol is visible and usable in the program</li>
<li value="20">From the moment storage is allocated for the variable to the point the system deallocates that storage</li>
<li value="21">Variables whose storage is automatically allocated upon entry into a block of code (usually a procedure) and automatically deallocated upon exiting that block of code</li>
<li value="22">Upon entry into a procedure (or the block of code associated with that automatic variable)</li>
<li value="23">Using <code>textequ</code> directives or the MASM local directive</li>
<li value="24"><code>var1</code>: –2; <code>local2</code>: –8 (MASM aligns variable on dword boundary); <code>dVar</code>: –9; <code>qArray</code>: –32 (base address of array is the lowest memory address); <code>rlocal</code>: –40 (base address of array is the lowest memory address); <code>ptrVar</code>: –48</li>
<li value="25"><code>option prologue:PrologueDef</code> and <code>option epilogue:EpilogueDef</code>. Should also supply <code>option prologue:none</code> and <code>option epilogue:none</code> to turn this off.</li>
<li value="26"><span epub:type="pagebreak" title="943" id="Page_943"/>Before MASM emits any code for the procedure, after all the local directives</li>
<li value="27">Wherever a <code>ret</code> instruction appears</li>
<li value="28">The actual parameter’s value</li>
<li value="29">The memory address of the actual parameter’s value</li>
<li value="30">RCX, RDX, R8, and R9 (or smaller subcomponents of these registers)</li>
<li value="31">XMM0, XMM1, XMM2, or XMM3</li>
<li value="32">On the stack, above the shadow locations (32 bytes) reserved for the arguments passed in the registers</li>
<li value="33">Procedures are free to modify volatile registers without preserving their values; procedures must preserve the values of nonvolatile registers across a procedure invocation.</li>
<li value="34">RAX, RCX, RDX, R8, R9, R10, R11, XMM0, XMM1, XMM2, XMM3, XMM4, XMM5, and the HO 128 bits of all the YMM and ZMM registers</li>
<li value="35">RBX, RSI, RDI, RBP, RSP, R12, R13, R14, R15, and XMM6–XMM15. Also, the direction flag must be clear upon return from a procedure.</li>
<li value="36">Using positive offsets from the RBP register</li>
<li value="37">Storage reserved on the stack for parameters the caller passes in the RCX, RDX, R8 and R9 registers</li>
<li value="38">32 bytes</li>
<li value="39">32 bytes</li>
<li value="40">32 bytes <aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Shadow storage is the same regardless of how many parameters you pass (including none).</p>
<div class="bottom hr"><hr/></div>
</section>
</aside></li>
<li value="41"><code>parm1</code>: RBP + 16; <code>parm2</code>: RBP + 24; <code>parm3</code>: RBP + 32; <code>parm4</code>: RBP + 40</li>
<li value="42">
<pre><code>mov rax, parm4
mov al, [rax]</code></pre></li>
<li value="43"><code>lclVar1</code>: RBP – 1; <code>lclVar2</code>: RBP – 4 (aligned to 2-byte boundary); <code>lclVar3</code>: RBP – 8; <code>lclVar4</code>: RBP – 16</li>
<li value="44">By reference</li>
<li value="45">Application binary interface</li>
<li value="46">In the RAX register</li>
<li value="47">The address of a procedure passed as a parameter</li>
<li value="48">Indirectly. Typically by using a <code>call </code><var>parm</var> instruction, where <var>parm</var> is the procedural parameter, a qword variable containing the address of the procedure. You could also load the parameter value into a 64-bit register and indirectly call the procedure through that register.</li>
<li value="49"><span epub:type="pagebreak" title="944" id="Page_944"/>Allocate local storage to hold the register values to preserve and move the register data into that storage upon procedure entry, and then move the data back into the registers just before returning from the procedure.</li>
</ol>
<h2 id="h1-501089b05-0006">	E.6	Answers to Questions in Chapter 6</h2>
<ol class="decimal">
<li value="1">AL for 8-bit operands, AX for 16-bit operands, EAX for 32-bit operands, and RAX for 64-bit operands</li>
<li value="2">8-bit <code>mul</code> operation: 16 bits; 16-bit <code>mul</code> operation: 32 bits; 32-bit <code>mul</code> operation: 64 bits; 64-bit <code>mul</code> operator: 128 bits. The CPU put the products at AX for 8×8 products, DX:AX for 16×16 products, EDX:EAX for 32×32 products, and RDX:RAX for 64×64 products.</li>
<li value="3">The quotient in AL, AX, EAX, or RAX and the remainder in AH, DX, EDX, or RDX</li>
<li value="4">Sign-extend AX into DX.</li>
<li value="5">Zero-extend EAX into EDX.</li>
<li value="6">A division by 0 and producing a quotient that will not fit into the accumulator register (AL, AX, EAX, or RAX)</li>
<li value="7">By setting the carry and overflow flags</li>
<li value="8">They scramble the flag; that is, they leave it in an undefined state.</li>
<li value="9">The extended-precision <code>imul</code> instruction produces a 2 × <em>n</em>-bit result, uses implied operands (AL, AX, EAX, and RAX), and modifies the AH, DX, EDX, and RDX registers. Also, the extended-precision <code>imul</code> instruction does not allow constant operands, whereas the generic <code>imul</code> instruction does.</li>
<li value="10"><code>cbw</code>, <code>cwd</code>, <code>cdq</code>, and <code>cqo</code></li>
<li value="11">They scramble all the flags, leaving them in an undefined state.</li>
<li value="12">It sets the zero flag if the two operands are equal.</li>
<li value="13">It sets the carry flag if the first operand is less than the second operand.</li>
<li value="14">The sign and overflow flags are different if the first operand is less than the second operand; they are the same if the first operand is greater than or equal to the second operand.</li>
<li value="15">An 8-bit register or memory location</li>
<li value="16">They set the operand to 1 if the condition is true, or to false if the condition is not true.</li>
<li value="17">The <code>test</code> instruction is the same as the <code>and</code> instruction except it does not store the result to the destination (first) operand; it only sets the flags.</li>
<li value="18">They both set the condition code flags the same way.</li>
<li value="19">Supply the operand to be tested as the first (destination) operand and an immediate constant containing a single 1 bit in the bit position to test. After the test instruction, the zero flag will contain the state of the desired bit.</li>
<li value="20"><span epub:type="pagebreak" title="945" id="Page_945"/>The following are some possible, not the only, solutions:
<p class="ListBody"><code>x = x + y</code></p>
<pre><code>mov eax, x
add eax, y
mov x, eax</code></pre>
<p class="ListBody"><code>x = y – z</code></p>
<pre><code>mov eax, y
sub eax, z
mov x, eax</code></pre>
<p class="ListBody"><code>x = y * z</code></p>
<pre><code>mov  eax, y
imul eax, z
mov  x, eax</code></pre>
<p class="ListBody"><code>x = y + z * t</code></p>
<pre><code>mov  eax, z
imul eax, t
add  eax, y
mov  x, eax</code></pre>
<p class="ListBody"><code>x = (y + z) * t</code></p>
<pre><code>mov  eax, y
add  eax, z
imul eax, t
mov  x, eax</code></pre>
<p class="ListBody"><code>x = -((x*y)/z)</code></p>
<pre><code>mov  eax, x
imul y          ; Note: Sign-extends into EDX
idiv z
mov  x, eax</code></pre>
<p class="ListBody"><code>x = (y == z) &amp;&amp; (t != 0)</code></p>
<pre><code>mov   eax, y
cmp   eax, z
sete  bl
cmp   t, 0
setne bh
and   bl, bh
movzx eax, bl   ; Because x is a 32-bit integer
mov   x, eax</code></pre></li>
<li value="21"><span epub:type="pagebreak" title="946" id="Page_946"/>The following are some possible, not the only, solutions:
<p class="ListBody"><code>x = x * 2</code></p>
<pre><code>shl   x, 1</code></pre>
<p class="ListBody"><code>x = y * 5</code></p>
<pre><code>mov   eax, y
lea   eax, [eax][eax*4]
mov   x, eax</code></pre>
<p class="ListBody">Here is another solution:</p>
<pre><code>mov   eax, y
mov   ebx, eax
shl   eax, 2
add   eax, ebx
mov   x, eax</code></pre>
<p class="ListBody"><code>x = y * 8</code></p>
<pre><code>mov   eax, y
shl   eax, 3
mov   x, eax</code></pre></li>
<li value="22"><code>x = x /2</code>
<pre><code>shr   x, 1</code></pre>
<p class="ListBody"><code>x = y / 8</code></p>
<pre><code>mov   ax, y
shr   ax, 3
mov   x, ax</code></pre>
<p class="ListBody"><code>x = z / 10</code></p>
<pre><code>movzx eax, z
imul  eax, 6554  ; Or 6553
shr   eax, 16
mov   x, ax</code></pre></li>
<li value="23"><code>x = x + y</code>
<pre><code>fld   x
fld   y
faddp
fstp  x</code></pre>
<p class="ListBody"><code>x = y – z</code></p>
<pre><code>fld   y
fld   z
<span epub:type="pagebreak" title="947" id="Page_947"/>fsubp
fstp  x</code></pre>
<p class="ListBody"><code>x = y * z</code></p>
<pre><code>fld   y
fld   z
fmulp
fstp  x</code></pre>
<p class="ListBody"><code>x = y + z * t</code></p>
<pre><code>fld   y
fld   z
fld   t
fmulp
faddp
fstp  x</code></pre>
<p class="ListBody"><code>x = (y + z) * t</code></p>
<pre><code>fld   y
fld   z
faddp
fld   t
fmulp
fstp  x</code></pre>
<p class="ListBody"><code>x = -((x * y)/z)</code></p>
<pre><code>fld   x
fld   y
fmulp
fld   z
fdivp
fchs
fstp  x</code></pre></li>
<li value="24"><code>x = x + y</code>
<pre><code>movss xmm0, x
addss xmm0, y
movss x, xmm0</code></pre>
<p class="ListBody"><code>x = y – z</code></p>
<pre><code>movss xmm0, y
subss xmm0, z
movss x, xmm0</code></pre>
<p class="ListBody"><code>x = y * z</code></p>
<pre><code>movss xmm0, y
<span epub:type="pagebreak" title="948" id="Page_948"/>mulss xmm0, z
movss x, xmm0</code></pre>
<p class="ListBody"><code>x = y + z * t</code></p>
<pre><code>movss xmm0, z
mulss xmm0, t
addss xmm0, y
movss x, xmm0</code></pre></li>
<li value="25"><code>b = x &lt; y</code>
<pre><code>fld    y
fld    x
fcomip st(0), st(1)
setb   b
fstp   st(0)</code></pre>
<p class="ListBody"><code>b = x &gt;= y &amp;&amp; x &lt; z</code></p>
<pre><code>fld    y
fld    x
fcomip st(0), st(1)
setae  bl
fstp   st(0)
fld    z
fld    x
fcomip st(0), st(1)
setb   bh
fstp   st(0)
and    bl, bh
mov    b, bl</code></pre></li>
</ol>
<h2 id="h1-501089b05-0007">	E.7	Answers to Questions in Chapter 7</h2>
<ol class="decimal">
<li value="1">Use the <code>lea</code> instruction or the <code>offset</code> operator.</li>
<li value="2"><code>option noscoped</code></li>
<li value="3"><code>option scoped</code></li>
<li value="4"><code>jmp </code><var>reg</var><span class="SubscriptLiteral">64</span> and <code>jmp </code><var>mem</var><span class="SubscriptLiteral">64</span></li>
<li value="5">A piece of code that maintains history information in variables or via the program counter</li>
<li value="6">If the second letter of the jump mnemonic is <em>n</em>, remove the <em>n</em>; otherwise, insert an <em>n</em> as the second character.</li>
<li value="7"><code>jpo</code> and <code>jpe</code><aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Technically, the <code>jcxz</code>, <code>jecxz</code>, and <code>jrcxz</code> instructions are also exceptions.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside></li>
<li value="8">A short code sequence used to extend the range of a jump or call instruction beyond the ±2GB range</li>
<li value="9"><span epub:type="pagebreak" title="949" id="Page_949"/><code>cmov</code><var>cc</var><code> </code><var>reg</var><code>, </code><var>src</var>, where <var>cc</var> is one of the conditional suffixes (which follow a conditional jump), <var>reg</var> is a 16-, 32-, or 64-bit register, and <var>src</var> is a source register or memory location that is the same size as <var>reg</var>.</li>
<li value="10">You can conditionally execute a large set of different types of instructions by using a conditional jump without the time penalty of a control transfer.</li>
<li value="11">The destination has to be a register, and 8-bit registers are not allowed.</li>
<li value="12">Complete Boolean evaluation of an expression evaluates all components of the expression, even if it is not logically necessary to do so; short-circuit evaluation stops as soon as it determines that the expression must be true or false.</li>
<li value="13">
<pre><code>if(x == y || z &gt; t)
{
    <var>Do something</var> 
}
    mov  eax, x
    cmp  eax, y
    sete bl
    mov  eax, z
    cmp  eax, t
    seta bh
    or   bl, bh
    jz   skipIF
     <var>Code for statements that "do something"</var>
skipIF:

if(x != y &amp;&amp; z &lt; t)
{
     <var>THEN statements</var>
}
Else
{
     <var>ELSE statements</var>
}
    mov   eax, x
    cmp   eax, y
    setne bl
    mov   eax, z
    cmp   eax, t
    setb  bh
    and   bl, bh
    jz    doElse
    <var> Code for THEN statements</var>
    jmp   endOfIF

doElse:
    <var> Code for ELSE statements</var>
endOfIF:</code></pre></li>
<li value="14"><span epub:type="pagebreak" title="950" id="Page_950"/>
<pre><code>1st IF:
    mov  ax, x
    cmp  ax, y
    jeq  doBlock
    mov  eax, z
    cmp  eax, t
    jnl  skipIF
doBlock:     <var>Code for statements that "do something"</var>
skipIF:

2nd IF:
    mov   eax, x
    cmp   eax, y
    je    doElse
    mov   eax, z
    cmp   eax, t
    jnl   doElse
    <var> Code for THEN statements</var>
    jmp   endOfIF

doElse:
    <var> Code for ELSE statements</var>
endOfIF:</code></pre></li>
<li value="15">
<pre><code>switch(s)
{
   case 0:   <var>case 0 code</var>  break;
   case 1:   <var>case 1 code</var>  break;
   case 2:   <var>case 2 code</var>  break;
   case 3:   <var>case 3 code</var>  break;
}

    mov eax, s ; Zero-extends!
    cmp eax, 3
    ja  skipSwitch
    lea rbx, jmpTbl
    jmp [rbx][rax * 8]
jmpTbl qword case0, case1, case2, case3

case0: <var>case 0 code</var>
       jmp skipSwitch

case1: <var>case 1 code</var>
       jmp skipSwitch

case2: <var>case 2 code</var>
       jmp skipSwitch

case3: <var>case 3 code</var>
<span epub:type="pagebreak" title="951" id="Page_951"/>
skipSwitch:

switch(t)
{
   case 2:  <var>case 0 code</var> break;
   case 4:  <var>case 4 code</var> break;
   case 5:  <var>case 5 code</var> break;
   case 6:  <var>case 6 code</var> break;
   default: <var>default code</var>
}
    mov eax, t ; Zero-extends!
    cmp eax, 2
    jb  swDefault
    cmp eax, 6
    ja  swDefault
    lea rbx, jmpTbl
    jmp [rbx][rax * 8 – 2 * 8]
jmpTbl qword case2, swDefault, case4, case5, case6

swDefault: <var>default code</var>
       jmp endSwitch

case2: <var>case 2 code</var>
       jmp endSwitch

case4: <var>case 4 code</var>
       jmp endSwitch

case5: <var>case 5 code</var>
       jmp endSwitch

case6: <var>case 6 code</var>

endSwitch:

switch(u)
{
   case 10:  <var> case 10 code </var> break;
   case 11:  <var> case 11 code </var> break;
   case 12:  <var> case 12 code </var> break;
   case 25:  <var> case 25 code </var> break;
   case 26:  <var> case 26 code </var> break;
   case 27:  <var> case 27 code </var> break;
   default:  <var> default code</var>
} 
     lea rbx, jmpTbl1  ; Assume cases 10-12
     mov eax, u        ; Zero-extends!
     cmp eax, 10
     jb  swDefault
     cmp eax, 12
     jbe sw1
     cmp eax, 25
     jb  swDefault
     cmp eax, 27
<span epub:type="pagebreak" title="952" id="Page_952"/>     ja  swDefault
     lea rbx, jmpTbl2
     jmp [rbx][rax * 8 – 25 * 8]
sw1: jmp [rbx][rax*8-2*8]
jmpTbl1 qword case10, case11, case12
jmpTbl2 qword case25, case26, case27

swDefault: <var>default code</var>
       jmp endSwitch

case10: <var>case 10 code</var>
       jmp endSwitch

case11: <var>case 11 code</var>
       jmp endSwitch

case12: <var>case 12 code</var>
       jmp endSwitch

case25: <var>case 25 code</var>
       jmp endSwitch

case26: <var>case 26 code</var>
       jmp endSwitch

case27: <var>case 27 code</var>

endSwitch:</code></pre></li>
<li value="16">
<pre><code>while(i &lt; j)
{
     <var>Code for loop body</var>
}

whlLp:
     mov eax, i
     cmp eax, j
     jnl endWhl
      <var>Code for loop body</var>
     jmp whlLp
endWhl:

while(i &lt; j &amp;&amp; k != 0)
{
     <var>Code for loop body, part a</var>
    if(m == 5) continue;
     <var>Code for loop body, part b</var>
    if(n &lt; 6) break;
     <var>Code for loop body, part c</var>
}

; Assume short-circuit evaluation:
<span epub:type="pagebreak" title="953" id="Page_953"/>
whlLp:
     mov eax, i
     cmp eax, j
     jnl endWhl
     mov eax, k
     cmp eax, 0
     je  endWhl
     <var> Code for loop body, part a</var>
     cmp m, 5
     je  whlLp
     <var> Code for loop body, part b</var>
     cmp n, 6
     jl  endWhl
    <var>  Code for loop body, part c</var>
     jmp whlLp
endWhl:

do
{
   <var>Code for loop body</var>
} while(i != j);

doLp:
   <var>Code for loop body</var>
     mov eax, i
     cmp eax, j
     jne doLp

do
{
   <var>Code for loop body, part a</var>
    if(m != 5) continue;
   <var>Code for loop body, part b</var>
    if(n == 6) break;
   <var>Code for loop body, part c</var>
} while(i &lt; j &amp;&amp; k &gt; j);

doLp:
  <var> Code for loop body, part a</var>
     cmp m, 5
     jne doCont
  <var> Code for loop body, part b</var>
     cmp n, 6
     je  doExit
  <var> Code for loop body, part c</var>
doCont:     mov eax, i
     cmp eax, j
     jnl doExit
     mov eax, k
     cmp eax, j
     jg  doLp
doExit:

for(int i = 0; i &lt; 10; ++i)
<span epub:type="pagebreak" title="954" id="Page_954"/>{
   <var>Code for loop body</var>
}

       mov i, 0
forLp: cmp i, 10
       jnl forDone
       <var> Code for loop body</var>
       inc i
       jmp forLp
forDone:</code></pre></li>
</ol>
<h2 id="h1-501089b05-0008">	E.8	Answers to Questions in Chapter 8</h2>
<ol class="decimal">
<li value="1">You compute <em>x</em> = <em>y</em> + <em>z</em> as follows:
<ol class="lower-alpha">
<li value="1">
<pre><code>mov rax, qword ptr y
add rax, qword ptr z
mov qword ptr x, rax
mov rax, qword ptr y[8]
adc rax, qword ptr z[8]
mov qword ptr x[8], rax</code></pre></li>
<li value="2">
<pre><code>mov rax, qword ptr y
add rax, qword ptr z
mov qword ptr x, rax
mov eax, dword ptr z[8] 
adc eax, qword ptr y[8]
mov dword ptr x[8], eax</code></pre></li>
<li value="3">
<pre><code>mov eax, dword ptr y
add eax, dword ptr z
mov dword ptr x, eax
mov ax, word ptr z[4]
adc ax, word ptr y[4]
mov word ptr x[4], ax</code></pre>
</li>
</ol>
</li>
<li value="2">You compute <em>x</em> = <em>y</em> – <em>z </em>as follows:
<ol class="lower-alpha">
<li value="1">
<pre><code>mov rax, qword ptr y
sub rax, qword ptr z
mov qword ptr x, rax
mov rax, qword ptr y[8]
sbb rax, qword ptr z[8]
mov qword ptr x[8], rax
<span epub:type="pagebreak" title="955" id="Page_955"/>mov rax, qword ptr y[16]
sbb rax, qword ptr z[16]
mov qword ptr x[16], rax</code></pre></li>
<li value="2">
<pre><code>mov rax, qword ptr y
sub rax, qword ptr z
mov qword ptr x, rax
mov eax, dword ptr y[8]
sbb eax, dword ptr z[8]
mov dword ptr x[8], eax</code></pre>
</li>
</ol>
</li>
<li value="3">
<pre><code>mov rax, qword ptr y
mul qword ptr z
mov qword ptr x, rax
mov rbx, rdx

mov rax, qword ptr y
mul qword ptr z[8]
add rax, rbx
adc rdx, 0
mov qword ptr x[8], rax
mov rbx, rdx

mov rax, qword ptr y[8]
mul qword ptr z
add x[8], rax
adc rbx, rdx

mov rax, qword ptr y[8]
mul qword ptr z[8]
add rax, rbx
mov qword ptr x[16], rax
adc rdx, 0
mov qword ptr x[24], rdx</code></pre></li>
<li value="4">
<pre><code>mov  rax, qword ptr y[8]
cqo
idiv qword ptr z
mov  qword ptr x[8], rax
mov  rax, qword ptr y
idiv qword ptr z
mov  qword ptr x, rax</code></pre>
</li>
<li value="5"> The conversions are as follows:
<ol class="lower-alpha">
<li value="1">
<pre><code>; Note: order of comparison (HO vs. LO) is irrelevant
; for "==" comparison.

<span epub:type="pagebreak" title="956" id="Page_956"/>    mov rax, qword ptr x[8]
    cmp rax, qword ptr y[8]
    jne skipElse
    mov rax, qword ptr x
    cmp rax, qword ptr y
    jne skipElse
    <var>then code</var>
skipElse:</code></pre></li>
<li value="2">
<pre><code>    mov rax, qword ptr x[8]
    cmp rax, qword ptr y[8]
    jnb skipElse
    mov rax, qword ptr x
    cmp rax, qword ptr y
    jnb skipElse
   <var> then code</var>
skipElse:</code></pre></li>
<li value="3">
<pre><code>    mov rax, qword ptr x[8]
    cmp rax, qword ptr y[8]
    jna skipElse
    mov rax, qword ptr x
    cmp rax, qword ptr y
    jna skipElse
    <var>then code</var>
skipElse:</code></pre></li>
<li value="4">
<pre><code>; Note: order of comparison (HO vs. LO) is irrelevant
; for "!=" comparison.

    mov rax, qword ptr x[8]
    cmp rax, qword ptr y[8]
    jne doElse
    mov rax, qword ptr x
    cmp rax, qword ptr y
    je skipElse
doElse:
    <var>then code</var>
skipElse:</code></pre></li>
</ol>
</li>
<li value="6">The conversions are as follows:
<ol class="lower-alpha">
<li value="1">
<pre><code>; Note: order of comparison (HO vs. LO) is irrelevant
; for "==" comparison.

    mov eax, dword ptr x[8]
    cmp eax, dword ptr y[8]
<span epub:type="pagebreak" title="957" id="Page_957"/>    jne skipElse
    mov rax, qword ptr x
    cmp rax, qword ptr y
    jne skipElse
    <var>then code</var>
skipElse:</code></pre></li>
<li value="2">
<pre><code>    mov eax, dword ptr x[8]
    cmp eax, dword ptr y[8]
    jnb skipElse
    mov rax, qword ptr x
    cmp rax, qword ptr y
    jnb skipElse
    <var>then code</var>
skipElse:</code></pre></li>
<li value="3">
<pre><code>    mov eax, dword ptr x[8]
    cmp eax, dword ptr y[8]
    jna skipElse
    mov rax, qword ptr x
    cmp rax, qword ptr y
    jna skipElse
    <var>then code</var>
skipElse:</code></pre></li>
</ol>
</li>
<li value="7">The conversions are as follows:
<ol class="lower-alpha">
<li value="1">
<pre><code>neg qword ptr x[8]
neg qword ptr x
sbb qword ptr x[8], 0

xor rax, rax
xor rdx, rdx
sub rax, qword ptr x
sbb rdx, qword ptr x[8]
mov qword ptr x, rax
mov qword ptr x[8], rdx</code></pre>
</li>
<li value="2">
<pre><code>mov rax, qword ptr y
mov rdx, qword ptr y[8]
neg rdx
neg rax
sbb rdx, 0
mov qword ptr x, rax
mov qword ptr x[8], rdx

<span epub:type="pagebreak" title="958" id="Page_958"/>xor rdx, rdx
xor rax, rax
sub rax, qword ptr y
sbb rdx, qword ptr y[8]
mov qword ptr x, rax
mov qword ptr x[8], rdx</code></pre></li>
</ol>
</li>
<li value="8">The conversions are as follows:
<ol class="lower-alpha">
<li value="1">
<pre><code>mov rax, qword ptr y
and rax, qword ptr z
mov qword ptr x, rax
mov rax, qword ptr y[8]
and rax, qword ptr z[8]
mov qword ptr x[8], rax</code></pre></li>
<li value="2">
<pre><code>mov rax, qword ptr y
or  rax, qword ptr z
mov qword ptr x, rax
mov rax, qword ptr y[8]
or  rax, qword ptr z[8]
mov qword ptr x[8], rax</code></pre></li>
<li value="3">
<pre><code>mov rax, qword ptr y
xor rax, qword ptr z
mov qword ptr x, rax
mov rax, qword ptr y[8]
xor rax, qword ptr z[8]
mov qword ptr x[8], rax</code></pre></li>
<li value="4">
<pre><code>mov rax, qword ptr y
not rax
mov qword ptr x, rax
mov rax, qword ptr y[8]
not rax
mov qword ptr x[8], rax</code></pre></li>
<li value="5">
<pre><code>mov rax, qword ptr y
shl rax, 1
mov qword ptr x, rax
mov rax, qword ptr y[8]
rcl rax, 1
mov qword ptr x[8], rax</code></pre></li>
<li value="6"><pre><code><span epub:type="pagebreak" title="959" id="Page_959"/>mov rax, qword ptr y[8]
shr rax, 1
mov qword ptr x[8], rax
mov rax, qword ptr y
rcr rax, 1
mov qword ptr x rax</code></pre></li>
</ol>
</li>
<li value="9">
<pre><code>mov rax, qword ptr y[8]
sar rax, 1
mov qword ptr x[8], rax
mov rax, qword ptr y
rcr rax, 1
mov qword ptr x, rax</code></pre></li>
<li value="10">
<pre><code>rcl qword ptr x, 1
rcl qword ptr x[8], 1</code></pre></li>
<li value="11">
<pre><code>rcr qword ptr x[8], 1
rcr qword ptr x, 1</code></pre></li>
</ol>
<h2 id="h1-501089b05-0009">	E.9	Answers to Questions in Chapter 9</h2>
<ol class="decimal">
<li value="1">
<pre><code>btoh        proc

            mov     ah, al      ; Do HO nibble first
            shr     ah, 4       ; Move HO nibble to LO
            or      ah, '0'     ; Convert to char
            cmp     ah, '9' + 1 ; Is it "A" to "F"?
            jb      AHisGood
            
; Convert 3Ah to 3Fh to "A" to "F".

            add     ah, 7

; Process the LO nibble here.
            
AHisGood:   and     al, 0Fh     ; Strip away HO nibble
            or      al, '0'     ; Convert to char
            cmp     al, '9' + 1 ; Is it "A" to "F"?
            jb      ALisGood
            
; Convert 3Ah to 3Fh to "A" to "F".

<span epub:type="pagebreak" title="960" id="Page_960"/>            add     al, 7
ALisGood:   ret
btoh        endp</code></pre></li>
<li value="2">8</li>
<li value="3">Call <code>qToStr</code> twice: once with the HO 64 bits and once with the LO 64 bits. Then concatenate the two strings.</li>
<li value="4"><code>fbstp</code></li>
<li value="5">If the input value is negative, emit a hyphen (<code>-</code>) character and negate the value; then call the unsigned decimal conversion function. If the number is 0 or positive, just call the unsigned decimal conversion function.</li>
<li value="6">
<pre><code>; Inputs:
;    RAX -   Number to convert to string.
;    CL  -   minDigits (minimum print positions).
;    CH  -   Padding character.
;    RDI -   Buffer pointer for output string.</code></pre></li>
<li value="7">It will produce the full string required; the <code>minDigits</code> parameter specifies the minimum string size.</li>
<li value="8">
<pre><code>; On Entry:

   ; r10        - Real10 value to convert.
   ;              Passed in ST(0).

   ; fWidth     - Field width for the number (note that this
   ;              is an *exact* field width, not a minimum
   ;              field width).
   ;              Passed in EAX (RAX).

   ; decimalpts - # of digits to display after the decimal pt.
   ;              Passed in EDX (RDX). 

   ; fill       - Padding character if the number is smaller
   ;              than the specified field width.
   ;              Passed in CL (RCX).

   ; buffer     - r10ToStr stores the resulting characters
   ;              in this string.
   ;              Address passed in RDI.

   ; maxLength  - Maximum string length.
   ;              Passed in R8D (R8).</code></pre></li>
<li value="9"><span epub:type="pagebreak" title="961" id="Page_961"/>A string containing <code>fWidth</code> <code>#</code> characters.</li>
<li value="10">
<pre><code>; On Entry:

;    e10     - Real10 value to convert.
;              Passed in ST(0).

;    width   - Field width for the number (note that this
;              is an *exact* field width, not a minimum
;              field width).
;              Passed in RAX (LO 32 bits).

;    fill    - Padding character if the number is smaller
;              than the specified field width.
;              Passed in RCX.

;    buffer  - e10ToStr stores the resulting characters in
;              this buffer (passed in EDI).
;              Passed in RDI (LO 32 bits).

;    expDigs - Number of exponent digits (2 for real4,
;              3 for real8, and 4 for real10).
;              Passed in RDX (LO 8 bits).</code></pre></li>
<li value="11">A character that separates a sequence of characters from other such sequences, such as beginning or ending a numeric string</li>
<li value="12">Illegal character on input and numeric overflow during conversion</li>
</ol>
<h2 id="h1-501089b05-0010">	E.10	Answers to Questions in Chapter 10</h2>
<ol class="decimal">
<li value="1">The set of all possible input (parameter) values</li>
<li value="2">The set of all possible function output (return) values</li>
<li value="3">Computes AL = [RBX + AL × 1]</li>
<li value="4">Byte values: domain is the set of all integers in the range 0 to 255, and the range is also the set of all integers in the range 0 to 255.</li>
<li value="5">The code implementing the functions is as follows:
<ol class="lower-alpha">
<li value="1">
<pre><code>lea rbx, f
mov al, input
xlat</code></pre></li>
<li value="2">
<pre><code>lea rbx, f
movzx rax, input
mov ax, [rbx][rax * 2]</code></pre></li>
<li value="3"><pre><code><span epub:type="pagebreak" title="962" id="Page_962"/>lea rbx, f
movzx rax, input
mov al, [rbx][rax * 1]</code></pre></li>
<li value="4">
<pre><code>lea rbx, f
movzx rax, input
mov ax, [rbx][rax * 2]</code></pre>
</li>
</ol>
</li>
<li value="6">Modifying input values that are out of a specific range so that they lie within the input domain of the function</li>
<li value="7">Main memory is so slow that it might be faster to compute the value than to look it up via a table.</li>
</ol>
<h2 id="h1-501089b05-0011">	E.11	Answers to Questions in Chapter 11</h2>
<ol class="decimal">
<li value="1">Use the <code>cpuid</code> instruction.</li>
<li value="2">Because Intel and AMD have different feature sets</li>
<li value="3">EAX = 1</li>
<li value="4">ECX bit 20</li>
<li value="5">(a) <code>_TEXT</code>, (b) <code>_DATA</code>, (c) <code>_BSS</code>, (d) <code>CONST</code></li>
<li value="6"><code>PARA</code> or 16 bytes</li>
<li value="7">
<pre><code>data  segment align(64) 'DATA'
           .
           .
           .
data  ends</code></pre></li>
<li value="8">AVX/AVX2/AVX-256/AVX-512</li>
<li value="9">A data type within a SIMD register; typically, 1, 2, 4, or 8 bytes wide</li>
<li value="10">Scalar instructions operate on a single piece of data; vector instructions operate, simultaneously, on two or more pieces of data.</li>
<li value="11">16 bytes</li>
<li value="12">32 bytes</li>
<li value="13">64 bytes</li>
<li value="14"><code>movd</code></li>
<li value="15"><code>movq</code></li>
<li value="16"><code>movaps</code>, <code>movapd</code>, and <code>movdqa</code></li>
<li value="17"><code>movups</code>, <code>movupd</code>, and <code>movdqu</code><aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	<code>l</code><code>ddqu</code> also works.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside></li>
<li value="18"><span epub:type="pagebreak" title="963" id="Page_963"/><code>movhps</code> or <code>movhpd</code></li>
<li value="19"><code>movddup</code></li>
<li value="20"><code>pshufb</code></li>
<li value="21"><code>pshufd</code>, though <code>pshufb</code> could also work</li>
<li value="22"><code>(v)pextrb</code>, <code>(v)pextrw</code>, <code>(v)pextrd</code>, or <code>(v)pextrq</code></li>
<li value="23"><code>(v)pinsrb</code>, <code>(v)pinsrw</code>, <code>(v)pinsrd</code>, or <code>(v)pinsrq</code></li>
<li value="24">It takes the bits in the second operand, inverts them, and then logically ANDs these inverted bits with the first (destination) operand.</li>
<li value="25"><code>pslldq</code></li>
<li value="26"><code>pslrdq</code></li>
<li value="27"><code>psllq</code></li>
<li value="28"><code>pslrq</code></li>
<li value="29">The carry out of the HO bit is lost.</li>
<li value="30">In a vertical addition, the CPU sums values found in the same lane of two separate XMM registers; in a horizontal addition, the CPU sums values found in adjacent lanes of the same XMM register.</li>
<li value="31">In the destination XMM register, by storing 0FFh in the corresponding lane of the destination XMM register (0 for false)</li>
<li value="32">Swap the operands of the <code>pcmpgtq</code> instruction.</li>
<li value="33">It copies the HO bit of each byte in an XMM register into the corresponding bit position of a general-purpose 16-bit register; for example, bit 7 of lane 0 goes into bit 0.</li>
<li value="34">(a) 4 on SSE, 8 on AVX2, (b) 2 on SSE, 4 on AVX2</li>
<li value="35"><code>and rax, -16</code></li>
<li value="36"><code>pxor xmm0, xmm0</code></li>
<li value="37"><code>pcmpeqb xmm1, xmm1</code></li>
<li value="38"><code>include</code></li>
</ol>
<h2 id="h1-501089b05-0012">	E.12	Answers to Questions in Chapter 12</h2>
<ol class="decimal">
<li value="1"><code>and</code>/<code>andn</code></li>
<li value="2"><code>btr</code></li>
<li value="3"><code>or</code></li>
<li value="4"><code>bts</code></li>
<li value="5"><code>xor</code></li>
<li value="6"><code>btc</code></li>
<li value="7"><code>test</code>/<code>and</code></li>
<li value="8"><code>bt</code></li>
<li value="9"><code>pext</code></li>
<li value="10"><code>pdep</code></li>
<li value="11"><code>bextr</code></li>
<li value="12"><span epub:type="pagebreak" title="964" id="Page_964"/><code>bsf</code></li>
<li value="13"><code>bsr</code></li>
<li value="14">Invert the register and use <code>bsf</code>.</li>
<li value="15">Invert the register and use <code>bsr</code>.</li>
<li value="16"><code>popcnt</code></li>
</ol>
<h2 id="h1-501089b05-0013">	E.13	Answers to Questions in Chapter 13</h2>
<ol class="decimal">
<li value="1">Compile-time language</li>
<li value="2">During the assembly and compilation process</li>
<li value="3"><code>echo</code> (or <code>%out</code>)</li>
<li value="4"><code>.err</code></li>
<li value="5">The <code>=</code> directive</li>
<li value="6"><code>!</code></li>
<li value="7">It replaces an expression with text representing the value of that compile-time expression.</li>
<li value="8">It replaces a text symbol with the expansion of its text.</li>
<li value="9">It concatenates two or more textual strings at assembly time and stores the result into a text symbol.</li>
<li value="10">It searches for a substring within a larger string in a MASM text object and returns the index of the substring into that object; 0 if the substring does not appear in the larger string.</li>
<li value="11">It returns the length of a MASM text string.</li>
<li value="12">It returns a substring from a larger MASM text string.</li>
<li value="13"><code>if</code>, <code>elseif</code>, <code>else</code>, and <code>endif</code></li>
<li value="14"><code>while</code>, <code>for</code>, <code>forc</code>, and <code>endm</code></li>
<li value="15"><code>forc</code></li>
<li value="16"><code>macro</code>, <code>endm</code></li>
<li value="17">Specify the macro’s name where you want the text expansion to occur.</li>
<li value="18">As operands to the macro directive</li>
<li value="19">Specify <code>:req</code> after the parameter name in the macro operand field.</li>
<li value="20">Macro parameters are optional, by default, if they don’t have the <code>:req</code> suffix.</li>
<li value="21">Use the <code>:vararg</code> suffix after the last macro parameter declaration.</li>
<li value="22">Use conditional assembly directives such as <code>ifb</code> or <code>ifnb</code> to see if the actual macro argument is blank.</li>
<li value="23">Use the <code>local</code> directive.</li>
<li value="24"><code>exitm</code></li>
<li value="25">Use <code>exitm &lt;text&gt;</code>.</li>
<li value="26"><code>opattr</code></li>
</ol>
<h2 id="h1-501089b05-0014"><span epub:type="pagebreak" title="965" id="Page_965"/>	E.14	Answers to Questions in Chapter 14</h2>
<ol class="decimal">
<li value="1">Bytes, words, dwords, and qwords</li>
<li value="2"><code>movs</code>, <code>cmps</code>, <code>scas</code>, <code>stos</code>, and <code>lods</code></li>
<li value="3">Bytes and words</li>
<li value="4">RSI, RDI, and RCX</li>
<li value="5">RSI and RDI</li>
<li value="6">RCX, RSI, and AL</li>
<li value="7">RDI and EAX</li>
<li value="8">Dir = 0</li>
<li value="9">Dir = 1</li>
<li value="10">Clear the direction flag; alternatively, preserve its value.</li>
<li value="11">Clear</li>
<li value="12"><code>movs</code> and <code>stos</code></li>
<li value="13">When the source and destination blocks overlap and the source address starts at a lower memory address than the destination block</li>
<li value="14">This is the default condition; you would also clear the direction flag when the source and destination blocks overlap and the source address starts at a higher memory address than the destination block.</li>
<li value="15">Portions of the source block can be replicated in the destination block.</li>
<li value="16"><code>repe</code></li>
<li value="17">Direction flag should be clear.</li>
<li value="18">No, string instructions test RCX prior to the string operation when using a repeat prefix.</li>
<li value="19"><code>scasb</code></li>
<li value="20"><code>stos</code></li>
<li value="21"><code>lods</code> and <code>stos</code></li>
<li value="22"><code>lods</code></li>
<li value="23">Verify that the CPU supports SSE 4.2 instructions.</li>
<li value="24"><code>pcmpistri</code> and <code>pcmpistrm</code></li>
<li value="25"><code>pcmpestri</code> and <code>pcmpestrm</code></li>
<li value="26">RAX holds the <code>src1</code> length, and RDX holds the <code>src2</code> length.</li>
<li value="27">Equal any, or possibly, equal range</li>
<li value="28">Equal each</li>
<li value="29">Equal ordered</li>
<li value="30">The <code>pcmp</code><var>X</var><code>str</code><var>Y</var> instructions always read 16 bytes of memory, even if the string is shorter than this, and there is the possibility of an MMU page fault when it reads data beyond the end of the string.</li>
</ol>
<h2 id="h1-501089b05-0015"><span epub:type="pagebreak" title="966" id="Page_966"/>	E.15	Answers to Questions in Chapter 15</h2>
<ol class="decimal">
<li value="1"><code>ifndef</code> and <code>endif</code></li>
<li value="2">The assembly of a source file plus any files it includes or indirectly includes</li>
<li value="3"><code>public</code></li>
<li value="4"><code>extern</code> and <code>externdef</code></li>
<li value="5"><code>externdef</code></li>
<li value="6"><code>abs</code></li>
<li value="7"><code>proc</code></li>
<li value="8"><em>nmake.exe</em></li>
<li value="9">Multiple blocks of the following form:
<pre><code><var>target</var>: <var>dependencies</var>
    <var>commands</var></code></pre></li>
<li value="10">A dependent file is one that the current file depends on for its proper operation; the dependent file must be updated and built prior to the compilation and linking of the current file.</li>
<li value="11">Delete old object and executable files, and delete other cruft.</li>
<li value="12">A collection of object files</li>
</ol>
<h2 id="h1-501089b05-0016">	E.16	Answers to Questions in Chapter 16</h2>
<ol class="decimal">
<li value="1"><code>/subsystem:console</code></li>
<li value="2"><a href="https://www.masm32.com/" class="LinkURL">https://www.masm32.com/</a></li>
<li value="3">It slows the assembly process.</li>
<li value="4"><code>/entry:</code><var>procedure_name</var></li>
<li value="5"><code>MessageBox</code></li>
<li value="6">Code that surrounds a call to a function and that changes the way you call the function (for example, parameter order and location)</li>
<li value="7"><code>__imp_CreateFileA</code></li>
<li value="8"><code>__imp_GetLastError</code></li>
</ol>
</section>
</body></html>