- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating User Interfaces and Widgets
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sketch 42: A Button'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After text from the console or a file and basic mouse gestures, the simple
    button is the third most popular user input method. It is ubiquitous on web pages,
    game screens, and any system that requires on/off or yes/no choices from a user.
    It is, of course, based on the old-fashioned push button that has existed for
    a long time as an electrical device, and it works in a natural way: push the button
    and something happens.'
  prefs: []
  type: TYPE_NORMAL
- en: Graphically, a button is really just a rectangle. It is usually filled with
    a color and has a text label or image to indicate its function. When the user
    clicks the mouse button while the cursor is within the button, the task assigned
    to the button is executed, usually by calling some function. Properties that a
    button has include its *position* (the x- and y-coordinates of the upper left
    corner of the button), *size* (the width and height of the button), *label* (the
    string that is written in the button), and a *color* or *image* that will appear
    in the button.
  prefs: []
  type: TYPE_NORMAL
- en: A button is said to be armed when the mouse cursor lies within it. When armed,
    a mouse click will execute the function of the button. Sometimes the button is
    drawn with a different color or font when it is armed to indicate the activation
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The button implemented in this sketch causes the background color of the sketch
    window to change. It is armed when the mouse enters the rectangle 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: where (`bx`, `by`) is the position and (`bw`, `bh`) is the size of the button.
  prefs: []
  type: TYPE_NORMAL
- en: The `buttonArmed()` function returns true when this `if` condition is true.
    The `drawButton()` function draws and fills the rectangle and draws the text 1.
    When the button is armed, `drawButton()` also changes the fill color to green
    from red. And, of course, the `mousePressed()` function determines whether the
    button was armed when the mouse button was pressed and changes the background
    color if so 4.
  prefs: []
  type: TYPE_NORMAL
- en: Because this sketch only implements a single button, it doesn’t use much code.
    It is common for an application to have many buttons, as you’ll see in the next
    sketch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 43: The Class Object—Multiple Buttons'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This sketch will create and display three buttons, one for each color component:
    red, green, and blue. When a button is clicked, the corresponding components of
    the background color will change randomly.'
  prefs: []
  type: TYPE_NORMAL
- en: If an application needs many buttons, the scheme presented in Sketch 42 becomes
    awkward. What we want is a type, like `PImage` or `PFont`, that represents a button,
    so we can declare button variables or an array of buttons. The new `button` type
    should contain within it all of the properties of a button along with all of the
    code, written as functions, that performs the legal button operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making a custom type with associated functions is done using a feature called
    a class. A class is a way to enclose some variables and functions and give them
    a name. The `button` class would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the braces, we declare the variables used by the button: `x`, `y`, `width`,
    `height`, `label`, and so on. The functions `drawButton()` and `buttonArmed()`
    go inside the class too, along with something called a constructor: a function
    that is called automatically each time a new button (or, in general, a class object)
    is created. The `class` statement and what follows inside the braces declares
    the class as a custom type, and when you declare a variable of that class, you
    create an instance, one specific object that has the class variables and functions
    within it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A variable of class `button` is declared just like a `PImage` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step, as with a `PImage` or `PFont`, is to create an instance of the
    `button` class using `new` and assign it to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When you use `new`, Processing calls the constructor for the class. The constructor
    accepts parameters, such as position or size, and saves them for later use in
    drawing the button. The constructor function has the same name as does the class
    2 (in this case, `button`), and it has no function type—it is not preceded by
    `void` or a type name. The constructor itself has no return value, but the `new`
    operator will return a new instance of the class. If you define more than one
    constructor, Processing calls the one that matches the type and number of parameters
    given in the `new` statement. The constructor then returns a new instance of the
    class. You can create as many instances as your computer memory allows.
  prefs: []
  type: TYPE_NORMAL
- en: You access variables and functions in a class variable using dot notation. For
    the `button` class instance `bred` 1, the *x* position is `bred.bx`, and to draw
    it, you’d call `bred.draw()`. The main draw function must call `draw()` for each
    of the buttons, or they won’t be displayed, and the `mousePressed()` function
    in the main program must check each button to see if it was clicked (that is,
    if the mouse cursor is inside the button) using the `armed()` function in each
    button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 44: A Slider'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A slider is a user interface widget that allows the user to move a small object
    (a cursor) along a linear path, either horizontally or vertically. The relative
    position of the cursor along the path represents a number. The cursor in one extreme
    position corresponds to the minimum value, and the cursor in the other extreme
    position represents the maximum. If the cursor is halfway between the min and
    max positions, the value associated with the slider is halfway between the min
    and max values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This widget can be used to position a large image in a small window or a lot
    of text within a smaller area, and we call it a scroll bar in those cases. The
    purpose of a slider is, more generally, to allow the user to select a number geometrically
    by sliding a cursor between two limits, rather than typing it. It is a natural
    idea to choose a number as a fraction of a total, or as a part of a range of values.
    If we define `sliderPos` as the position of the cursor in pixels from the start
    of the slider, `sliderWidth` as the width of the slider in pixels, and `sliderMax`
    and `sliderMin` as the numerical values associated with the min and max cursor
    positions, this is the selected value 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This expression is based on the fact that the slider position is a fraction
    of the total possible set of positions, and this represents the same fraction
    of the range between the `sliderMin` and `sliderMax`values (see [Figure 44-1](#figure44-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f044001](Images/f044001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 44-1: A slider'
  prefs: []
  type: TYPE_NORMAL
- en: A slider can be represented graphically in many different ways. In this sketch,
    the widget is a horizontal rectangle with a circular cursor, and the current numerical
    value is drawn to the right. However, the cursor can be rectangular, elliptical,
    triangular, a pointer, or other shapes.
  prefs: []
  type: TYPE_NORMAL
- en: The `drawSlider()` function 1 draws the rectangle and positions the cursor using
    the `sliderPos` variable, which is set when the user selects the cursor with the
    mouse and then moves (slides) it between the ends of the rectangle. To build a
    slider class, you would make class variables for the position, size, current cursor
    position and value, and class functions to draw the slider and position the cursor
    (which you’d then call as, for example, `slider.drawSlider()` or `slider.draw()`).
  prefs: []
  type: TYPE_NORMAL
- en: A common use for sliders is as a way to display an image. Often an image will
    not fit into a particular window, or into any window; some images are very large.
    Rather than resize the image, it is common to have a slider at the bottom and
    the right side of the window, and to use the cursor to position the window over
    the image so that various parts can be seen. The values selected with the sliders
    represent the (*x*, *y*) location of the window over top of the larger image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 45: A Gauge Display'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The obvious way for a computer to display a numeric result is to simply display
    the number, but sometimes a more analog approach is easier for people to deal
    with. Some people like digital clocks, and some prefer the old kind with hands.
    The analog display can be faster for a human to process. A common kind of display
    is a gauge, where a pointer of some kind rotates and points to a number. Most
    older speedometers are displays of this type, for example. [Figure 45-1](#figure45-1)
    illustrates a gauge as a graphic and shows a simple abstraction of the situation.
  prefs: []
  type: TYPE_NORMAL
- en: '![f045001](Images/f045001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 45-1: A gauge showing a value near 0 (left), and the angles that are
    involved in the display (right)'
  prefs: []
  type: TYPE_NORMAL
- en: A gauge can display values between a minimum and a maximum numeric value. The
    minimum value corresponds to the minimum angle the pointer can have (labeled α
    in the figure), and the maximum value corresponds to the maximum angle the pointer
    can have (labeled β). In this sketch, angles map directly onto values so that
    a difference of one degree always represents the same amount of change. To display
    a value, we calculate the angle that corresponds to that value, named `theta`
    1 in the sketch, and draw the pointer at that angle.
  prefs: []
  type: TYPE_NORMAL
- en: One way to look at this is as a *slider* that is shaped like a curve. Although
    the *gauge* is only a display, the mathematics of where to place the pointer is
    the same as for a slider, except we use angles instead of straight-line distances,
    and it is reorganized to provide a value for the position. [Figure 45-2](#figure45-2)
    shows how the slider situation converts into what we need for a gauge, and shows
    the formula for finding where to draw the pointer. This formula is really the
    same as the one used for the slider.
  prefs: []
  type: TYPE_NORMAL
- en: '![f045002](Images/f045002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 45-2: The gauge is like a bent slider. The equation shown here determines
    a position value (angle) given a numerical value, but it is otherwise the same
    as the one we used for the slider.'
  prefs: []
  type: TYPE_NORMAL
- en: We do need to understand that 0 degrees is horizontal, and we convert the starting
    (α) and ending (β) angles so they are relative to 0\. Starting at α, we decrease
    the angle of the pointer as the value increases toward the maximum. If α is 140,
    then β should be −45 rather than the equivalent angle, 315, so that β < α.
  prefs: []
  type: TYPE_NORMAL
- en: The `gauge()` function draws the pointer at the angle specified by the equation
    in [Figure 45-2](#figure45-2) given a data value, `v`. Don’t forget that angles
    in Processing need to be given as radians, so `pos` has to be converted from degrees.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 46: A Likert Scale'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Likert scale is a rating scale for answering questions, commonly used in questionnaires.
    The person being asked the question selects one of the answers from a set of choices
    (often five) ranging from “Strongly Disagree” to “Strongly Agree.” The idea is
    to collect standard answers upon which statistics can be computed.
  prefs: []
  type: TYPE_NORMAL
- en: This sketch poses a question by drawing it near the top of the screen 2. The
    possible answers are numbered from 1 (Strongly Disagree) to 5 (Strongly Agree),
    and each answer corresponds to a circle. To select an answer, the user clicks
    on a circle, and the circle gets filled in 3. When the user has answered to their
    satisfaction, then they type any key and the sketch asks another question.
  prefs: []
  type: TYPE_NORMAL
- en: The questions reside in a text file named *questions.txt* that is opened within
    `setup()`. We assume that there are multiple questions, and each is one line of
    text in the file. The `loadStrings()` 1 function reads them all into an array
    named `question`, the length of which is the number of questions. Each question
    is asked (displayed) according to its index variable, `questionNo`, which iterates
    from 0 to the number of questions. The user selects an answer, one of five possible,
    by clicking the mouse within one of the five circles. That answer is chosen as
    the current selection (using a variable named `select`) in the `mouseReleased()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: When the user types a key, `keyPressed()` is called, and the selection will
    be written to a file named *save.txt* 4. Then the `questionNo` variable will be
    incremented, resulting in the next question being displayed. When all questions
    have been asked (that is, when `questionNo > question.length`), the file is closed
    and the program ends. The answers chosen by the user to all questions are now
    stored in the *save.txt* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 47: A Thermometer'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The original thermometer, made of glass with a colored fluid inside, had a design
    imposed by its function, but it was also an excellent way to display numeric data.
    It represents a number as the height of a colored line or rectangle. It is easy
    to see how tall a rectangle is and easy to compare it to others. This idea has
    been used in many places, most noticeably on sound equipment to show volume.
  prefs: []
  type: TYPE_NORMAL
- en: The representation on a computer is straightforward. A colored rectangle grows
    and shrinks as a function of how large a numeric variable is. Such a variable
    has a minimum and maximum value, and the rectangle has a minimum (usually 0) and
    maximum height. The mapping between the number and the height can be done as it
    was for the slider (Sketch 44) and the dial gauge (Sketch 45). In this sketch,
    it is implemented a bit differently, but it is computed in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sketch computes how much taller the rectangle gets for each increase in
    the variable 1. If the rectangle’s height can go from `ystart` to `yend`, and
    the range of data values is from `dataMin` to `dataMax`, then the change in rectangle
    height for each data increment is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then for any data value, `data`, the height of the rectangle relative to `ystart`
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This process only draws a rectangle, which is not very exciting, so we’ll add
    a background image (created specifically for this program) that contains an image
    of a glass thermometer and gradations that allow the user to interpret the height
    as a number. The coordinates of the rectangle have to be mapped specifically onto
    the image so that the rectangle aligns with the thermometer column, using a similar
    process as in Sketch 45.
  prefs: []
  type: TYPE_NORMAL
- en: This example generates a random numeric value for display. After starting arbitrarily
    at `data = 15`, the value changes by a small random amount each frame.
  prefs: []
  type: TYPE_NORMAL
