- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Basic Commands and Directory Hierarchy
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基本命令和目录层次结构
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: This chapter is a guide to the Unix commands and utilities you’ll encounter
    throughout this book. This is preliminary material, and you may already know a
    substantial amount of it. Even if you think you’re up to speed, take a few moments
    to flip through the chapter just to make sure, especially when it comes to the
    directory hierarchy material in Section 2.19.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一本指导你了解在本书中会遇到的Unix命令和工具的指南。这是初步材料，你可能已经掌握了其中的相当一部分。即使你认为自己已经掌握，也请花些时间浏览一下这一章，确保理解，尤其是关于目录层次结构的内容（见第2.19节）。
- en: Why Unix commands? Isn’t this a book about how Linux works? It is, of course,
    but Linux is a Unix flavor at heart. You’ll see the word *Unix* in this chapter
    more than *Linux* because you can take what you learn straight over to BSD and
    other Unix-flavored systems. I’ve attempted to avoid covering too many Linux-specific
    user interface extensions, not only to give you a better background for using
    the other operating systems, but also because these extensions tend to be unstable.
    You’ll be able to adapt to new Linux releases much more quickly if you know the
    core commands. In addition, knowing these commands can boost your understanding
    of the kernel, as many correspond directly to system calls.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要学习Unix命令？这不是一本关于Linux如何工作的书吗？当然是，但Linux本质上是一种Unix变种。在本章中，你会看到*Unix*这个词比*Linux*出现得更多，因为你学到的内容可以直接应用到BSD和其他Unix变种系统上。我试图避免讲解过多的Linux特有的用户界面扩展，不仅是为了帮助你更好地使用其他操作系统，也是因为这些扩展通常不稳定。如果你掌握了核心命令，你会在面对新的Linux版本时更加快速适应。此外，掌握这些命令可以增强你对内核的理解，因为许多命令直接对应于系统调用。
- en: '2.1 The Bourne Shell: /bin/sh'
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 Bourne Shell：/bin/sh
- en: The shell is one of the most important parts of a Unix system. A *shell* is
    a program that runs commands, like the ones that users enter into a terminal window.
    These commands can be other programs or built-in features of the shell. The shell
    also serves as a small programming environment. Unix programmers often break common
    tasks into smaller components and use the shell to manage tasks and piece things
    together.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Shell是Unix系统中最重要的部分之一。*Shell*是一个运行命令的程序，类似于用户在终端窗口中输入的命令。这些命令可以是其他程序，也可以是Shell的内置功能。Shell还作为一个小型的编程环境。Unix程序员通常将常见任务分解为更小的组件，并使用Shell来管理任务和将它们拼接起来。
- en: Many important parts of the system are actually *shell scripts*—text files that
    contain a sequence of shell commands. If you’ve worked with MS-DOS previously,
    you can think of shell scripts as very powerful *.BAT* files. Because they’re
    important, Chapter 11 is devoted entirely to shell scripts.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的许多重要部分实际上是*Shell脚本*——包含一系列Shell命令的文本文件。如果你以前使用过MS-DOS，可以把Shell脚本看作是非常强大的*.BAT*文件。因为它们很重要，第11章将完全讲解Shell脚本。
- en: As you progress through this book and gain practice, you’ll add to your knowledge
    of manipulating commands using the shell. One of the best things about the shell
    is that if you make a mistake, you can easily see what you typed to find out what
    went wrong, and then try again.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你在本书中的学习和实践，你会不断增加使用Shell操作命令的知识。Shell的一个最大优点就是，如果你犯了错误，你可以很容易地看到自己输入的内容，找出出错的原因，然后重新尝试。
- en: There are many different Unix shells, but all derive features from the Bourne
    shell (*/bin/sh*), a standard shell developed at Bell Labs for early versions
    of Unix. Every Unix system needs a version of the Bourne shell in order to function
    correctly, as you will see throughout this book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Unix有许多不同的Shell，但所有Shell都从Bourne Shell（*/bin/sh*）中继承了特性，Bourne Shell是由贝尔实验室为早期版本的Unix开发的标准Shell。每个Unix系统都需要一个Bourne
    Shell版本才能正常工作，正如你在本书中将看到的那样。
- en: Linux uses an enhanced version of the Bourne shell called `bash` or the “Bourne-again”
    shell. The `bash` shell is the default shell on most Linux distributions, and
    */bin/sh* is normally a link to `bash` on a Linux system. You should use the `bash`
    shell when running the examples in this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Linux使用的是增强版的Bourne Shell，称为`bash`，即“Bourne-again” Shell。`bash`是大多数Linux发行版的默认Shell，而在Linux系统中，*/bin/sh*通常是指向`bash`的链接。在本书中的示例中，你应使用`bash`
    Shell。
- en: 2.2 Using the Shell
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 使用Shell
- en: When you install Linux, you should create at least one regular user to be your
    personal account. For this chapter, you should log in as the regular user.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装Linux时，应该至少创建一个普通用户作为你的个人账户。在本章中，你应该以普通用户身份登录。
- en: 2.2.1 The Shell Window
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 Shell窗口
- en: After logging in, open a shell window (often referred to as a *terminal*). The
    easiest way to do so from a GUI like Gnome or KDE is to open a terminal application,
    which starts a shell inside a new window. Once you’ve opened a shell, it should
    display a prompt at the top that usually ends with a dollar sign (`$`). On Ubuntu,
    that prompt should look like `name@host:path``$`, and on Fedora, it’s `[``name@host
    path``]$`, where `name` is your username, `host` is the name of your machine,
    and `path` is your current working directory (see Section 2.4.1). If you’re familiar
    with Windows, the shell window will look something like a DOS command prompt;
    in macOS the Terminal application is essentially the same as a Linux shell window.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，打开一个 shell 窗口（通常称为*终端*）。从 Gnome 或 KDE 这样的图形界面打开的最简单方法是启动一个终端应用程序，它会在新窗口中启动一个
    shell。一旦打开了 shell，它应该在顶部显示一个提示符，通常以美元符号（`$`）结尾。在 Ubuntu 中，提示符应该像`name@host:path``$`，而在
    Fedora 中，则是`[name@host path]$`，其中`name`是你的用户名，`host`是你的计算机名称，`path`是你当前的工作目录（见
    2.4.1 节）。如果你熟悉 Windows，shell 窗口看起来有点像 DOS 命令提示符；在 macOS 中，终端应用程序本质上与 Linux shell
    窗口相同。
- en: 'This book contains many commands that you will type at a shell prompt. They
    all begin with a single `$` to denote the shell prompt. For example, type this
    command (just the part in bold, not the `$`) and press enter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书包含了许多你将在 shell 提示符下输入的命令。它们都以单个美元符号`$`开始，用来表示 shell 提示符。例如，输入以下命令（只输入粗体部分，不包括`$`）并按回车：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now enter this command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入这个命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command displays the contents of the */etc/passwd* system information file
    and then returns your shell prompt. Don’t worry about what *this* file does right
    now; you’ll learn all about it in Chapter 7.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令显示`/etc/passwd`系统信息文件的内容，然后返回你的 shell 提示符。现在不用担心*这个*文件的作用；你将在第七章中详细了解它。
- en: Commands usually begin with a program to run and may be followed by *arguments*
    that tell the program what to operate on and how to do so. Here, the program is
    `cat`, and there is one argument, `/etc/passwd`. Many arguments are options that
    modify the default behavior of a program and typically begin with a dash (`-`).
    You’ll see this shortly in the discussion of `ls`. There are some exceptions that
    don’t follow this normal command structure, however, such as shell built-ins and
    the temporary use of environment variables.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 命令通常以要运行的程序开始，后面可能跟着*参数*，这些参数告诉程序要操作的对象以及如何操作。在这里，程序是`cat`，并且有一个参数`/etc/passwd`。许多参数是选项，用来修改程序的默认行为，通常以破折号（`-`）开头。稍后在讨论`ls`时，你会看到这一点。然而，也有一些不遵循这种正常命令结构的例外情况，比如
    shell 内建命令和环境变量的临时使用。
- en: 2.2.2 cat
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 cat
- en: 'The `cat` program is one of the easiest in Unix to understand; it simply outputs
    the contents of one or more files or another source of input. The general syntax
    of a `cat` command is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`程序是 Unix 中最容易理解的程序之一；它只输出一个或多个文件的内容，或者来自其他输入源的数据。`cat`命令的基本语法如下：'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you run this command, `cat` prints the contents of `file1`, `file2`, and
    any other files that you specify as arguments (denoted by `...` in the preceding
    example), and then exits. The program is called `cat` because it performs concatenation
    when it prints the contents of more than one file. There are many ways to run
    `cat`; let’s use it to explore Unix I/O.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个命令时，`cat`会打印`file1`、`file2`以及你指定的任何其他文件的内容（在前面的例子中由`...`表示），然后退出。这个程序叫做`cat`，因为当它打印多个文件的内容时，它会执行连接操作。运行`cat`的方法有很多种；让我们用它来探索
    Unix 的输入输出（I/O）。
- en: 2.2.3 Standard Input and Standard Output
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.3 标准输入和标准输出
- en: Unix processes use I/O *streams* to read and write data. Processes read data
    from input streams and write data to output streams. Streams are very flexible.
    For example, the source of an input stream can be a file, a device, a terminal
    window, or even the output stream from another process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 进程使用 I/O *流*来读取和写入数据。进程从输入流中读取数据，并将数据写入输出流。流是非常灵活的。例如，输入流的来源可以是文件、设备、终端窗口，甚至是另一个进程的输出流。
- en: To see an input stream at work, enter `cat` (with no arguments) and press enter.
    This time, you won’t get any immediate output, and you won’t get your shell prompt
    back because `cat` is still running. Now type anything and press enter at the
    end of each line. When used like this, the `cat` command repeats any line that
    you type. Once you’re sufficiently bored, press ctrl-D on an empty line to terminate
    `cat` and return to the shell prompt.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看输入流的工作情况，输入`cat`（不带任何参数）并按回车。这时你不会立即看到输出，也不会看到shell提示符，因为`cat`仍在运行。现在输入任何内容，并在每行结束时按回车。以这种方式使用时，`cat`命令会重复你输入的每一行。当你感到足够无聊时，按ctrl-D结束空行以终止`cat`并返回到shell提示符。
- en: The reason `cat` adopts an interactive behavior here has to do with streams.
    When you don’t specify an input filename, `cat` reads from the *standard input*
    stream provided by the Linux kernel rather than a stream connected to a file.
    In this case, the standard input is connected to the terminal where you run `cat`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`在这里采用交互行为的原因与流有关。当你没有指定输入文件名时，`cat`从Linux内核提供的*标准输入*流中读取，而不是从连接到文件的流中读取。在这种情况下，标准输入连接到你运行`cat`的终端。'
- en: '*Standard output* is similar. The kernel gives each process a standard output
    stream where it can write its output. The `cat` command always writes its output
    to the standard output. When you ran `cat` in the terminal, the standard output
    was connected to that terminal, so that’s where you saw the output.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*标准输出*类似。内核为每个进程提供一个标准输出流，供其写入输出。`cat`命令始终将输出写入标准输出。当你在终端运行`cat`时，标准输出连接到该终端，因此你会在终端看到输出。'
- en: Standard input and output are often abbreviated as *stdin* and *stdout*. Many
    commands operate as `cat` does; if you don’t specify an input file, the command
    reads from stdin. Output is a little different. Some programs (like `cat`) send
    output only to stdout, but others have the option to send output directly to files.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 标准输入和输出通常缩写为*stdin*和*stdout*。许多命令的操作方式与`cat`相似；如果你没有指定输入文件，命令就会从stdin读取。输出稍有不同。一些程序（如`cat`）仅将输出发送到stdout，而其他程序则有将输出直接发送到文件的选项。
- en: There is a third standard I/O stream, called *standard error*. You’ll see it
    in Section 2.14.1.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个第三个标准I/O流，称为*标准错误*。你将在第2.14.1节中看到它。
- en: One of the best features of standard streams is that you can easily manipulate
    them to read and write to places other than the terminal, as you’ll learn in Section
    2.14. In particular, you’ll learn how to connect streams to files and other processes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 标准流的一个最佳特点是你可以轻松地操作它们，将数据读取和写入到终端以外的地方，正如你将在第2.14节中学到的那样。特别是，你将学会如何将流连接到文件和其他进程。
- en: 2.3 Basic Commands
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 基本命令
- en: Now let’s look at some more Unix commands. Most of the following programs take
    multiple arguments, and some have so many options and formats that an unabridged
    listing would be pointless. This is a simplified list of the basic commands; you
    don’t need all of the details just yet.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下更多的Unix命令。以下大多数程序都接受多个参数，有些有如此多的选项和格式，以至于列出所有的细节没有意义。这是一个简化的基础命令列表；你现在不需要所有的细节。
- en: 2.3.1 ls
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 ls
- en: 'The `ls` command lists the contents of a directory. The default is the current
    directory, but you can add any directory or file as an argument, and there are
    many useful options. For example, use `ls -l` for a detailed (long) listing and
    `ls -F` to display file type information. Here is a sample long listing; it includes
    the owner of the file (column 3), the group (column 4), the file size (column
    5), and the modification date/time (between column 5 and the filename):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls`命令列出目录的内容。默认情况下是当前目录，但你可以添加任何目录或文件作为参数，并且有许多有用的选项。例如，使用`ls -l`进行详细（长格式）列出，使用`ls
    -F`显示文件类型信息。以下是一个示例的长格式列出；它包括文件的所有者（第3列）、组（第4列）、文件大小（第5列）以及修改日期/时间（在第5列和文件名之间）：'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You’ll learn more about column 1 of this output in Section 2.17. You can ignore
    column 2 for now; it’s the number of hard links to the file and is explained in
    Section 4.6.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在第2.17节中进一步了解此输出的第一列。第二列现在可以忽略；它表示文件的硬链接数，详细信息将在第4.6节中解释。
- en: 2.3.2 cp
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 cp
- en: 'In its simplest form, `cp` copies files. For example, to copy `file1` to `file2`,
    enter this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`cp`命令最简单的形式是复制文件。例如，要将`file1`复制到`file2`，可以输入：'
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also copy a file to another directory, keeping the same file name in
    that directory:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将文件复制到另一个目录，并保持该目录中的相同文件名：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To copy more than one file to a directory (folder) named `dir`, try something
    like this example, which copies three files:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要将多个文件复制到名为`dir`的目录（文件夹）中，可以尝试如下示例，复制三个文件：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 2.3.3 mv
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 mv
- en: 'The `mv` (move) command works much like `cp`. In its simplest form, it renames
    a file. For example, to rename `file1` to `file2`, enter this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`mv`（移动）命令的工作方式与`cp`类似。以最简单的形式，它用于重命名文件。例如，要将`file1`重命名为`file2`，请输入：'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can also use `mv` to move files to other directories in the same way as
    `cp`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`mv`命令像`cp`一样将文件移动到其他目录。
- en: 2.3.4 touch
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 touch
- en: 'The `touch` command can create a file. If the target file already exists, `touch`
    doesn’t change the file, but it does update the file’s modification timestamp.
    For example, to create an empty file, enter this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`touch`命令可以创建一个文件。如果目标文件已经存在，`touch`不会改变文件，但它会更新文件的修改时间戳。例如，要创建一个空文件，请输入：'
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then run `ls -l` on that file. You should see output like the following, where
    the date and time indicate when you ran `touch`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后对那个文件运行`ls -l`命令。你应该看到类似以下的输出，其中的日期和时间表示你运行`touch`命令的时间：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To see a timestamp update, wait at least a minute and then run the same `touch`
    command again. The timestamp returned by `ls -l` will update.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看时间戳更新，至少等一分钟，然后再次运行相同的`touch`命令。`ls -l`返回的时间戳会更新。
- en: 2.3.5 rm
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.5 rm
- en: The `rm` command deletes (removes) a file. After you remove a file, it’s usually
    gone from your system and generally cannot be undeleted unless you restore it
    from a backup.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`rm`命令删除（移除）一个文件。删除文件后，它通常会从系统中消失，通常无法恢复，除非你从备份中恢复它。'
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 2.3.6 echo
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.6 echo
- en: 'The `echo` command prints its arguments to the standard output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo`命令将其参数打印到标准输出：'
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `echo` command is very useful for finding expansions of shell globs (“wildcards”
    such as `*`) and variables (such as `$HOME`), which you will encounter later in
    this chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo`命令对于查找shell通配符（如`*`）和变量（如`$HOME`）的扩展非常有用，你将在本章稍后遇到它们。'
- en: 2.4 Navigating Directories
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 导航目录
- en: The Unix directory hierarchy starts at */*, also called the *root directory*.
    The directory separator is the slash (*/*), *not* the backslash (\). There are
    several standard subdirectories in the root directory, such as */usr*, as you’ll
    learn in Section 2.19.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Unix目录层级从*/*开始，也称为*根目录*。目录分隔符是斜杠（*/*），*不是*反斜杠（\）。根目录下有几个标准的子目录，如*/usr*，你将在2.19节学习到。
- en: When you refer to a file or directory, you specify a *path* or *pathname*. When
    a path starts with */* (such as */usr/lib*), it’s a *full* or *absolute* path.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你引用一个文件或目录时，你需要指定一个*路径*或*路径名*。当路径以*/*（例如*/usr/lib*）开始时，它是一个*完整*或*绝对*路径。
- en: A path component identified by two dots (*..*) specifies the parent of a directory.
    For example, if you’re working in */usr/lib*, the path *..* would refer to */usr*.
    Similarly, *../bin* would refer to */usr/bin*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个由两个点（*..*）表示的路径组件指定了目录的父目录。例如，如果你在*/usr/lib*工作，路径*..*将指向*/usr*。类似地，*../bin*将指向*/usr/bin*。
- en: One dot (*.*) refers to the current directory; for example, if you’re in */usr/lib*,
    the path . is still */usr/lib*, and *./X11* is */usr/lib/X11*. You won’t have
    to use *.* very often because most commands default to the current directory if
    a path doesn’t start with */* (so you could just use *X11* instead of *./X11*
    in the preceding example).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个点（*.*）表示当前目录；例如，如果你在*/usr/lib*目录中，那么路径.仍然是*/usr/lib*，而*./X11*则是*/usr/lib/X11*。你不需要经常使用*.*，因为大多数命令会默认使用当前目录，如果路径没有以*/*开始（因此你可以在前面的例子中直接使用*X11*而不是*./X11*）。
- en: A path not beginning with */* is called a *relative path*. Most of the time,
    you’ll work with relative pathnames, because you’ll already be in or near the
    directory you need.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以*/*开头的路径称为*相对路径*。大多数时候，你会使用相对路径名，因为你通常已经在需要的目录中或靠近该目录。
- en: Now that you have a sense of the basic directory mechanics, here are some essential
    directory commands.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对基本的目录操作有了了解，下面是一些基本的目录命令。
- en: 2.4.1 cd
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 cd
- en: The *current working directory* is the directory that a process (such as the
    shell) is currently in. In addition to the default shell prompt in most Linux
    distributions, you can see your current directory with the `pwd` command, described
    in Section 2.5.3.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*当前工作目录*是一个进程（如shell）当前所在的目录。除了大多数Linux发行版中的默认shell提示符，你还可以使用`pwd`命令查看当前目录，详细信息见2.5.3节。'
- en: 'Each process can independently set its own current working directory. The `cd`
    command changes the shell’s current working directory:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都可以独立设置自己的当前工作目录。`cd`命令改变shell的当前工作目录：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you omit `dir`, the shell returns to your *home directory*, the directory
    where you started when you first logged in. Some programs abbreviate your home
    directory with the `~` symbol (a *tilde*).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略`dir`，Shell 会返回到你的*主目录*，即你第一次登录时所在的目录。一些程序用`~`符号（*波浪线*）来缩写你的主目录。
- en: 2.4.2 mkdir
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 mkdir
- en: 'The `mkdir` command creates a new directory `dir`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkdir`命令创建一个新的目录`dir`：'
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 2.4.3 rmdir
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.3 rmdir
- en: 'The `rmdir` command removes the directory `dir`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`rmdir`命令删除目录`dir`：'
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If `dir` isn’t empty, this command fails. However, if you’re impatient, you
    probably don’t want to laboriously delete all the files and subdirectories inside
    `dir` first. You can use `rm -r` `dir` to delete a directory and its contents,
    but be careful! This is one of the few commands that can do serious damage, especially
    if you run it as the superuser. The `-r` option specifies *recursive delete* to
    repeatedly delete everything inside `dir`. Don’t use the `-r` flag with globs
    such as a star (`*`). And above all, always double-check your command before you
    run it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`dir`目录不为空，这个命令会失败。然而，如果你急于操作，可能不想先繁琐地删除`dir`内部的所有文件和子目录。你可以使用`rm -r` `dir`来删除一个目录及其内容，但要小心！这是少数几个可能造成严重损害的命令之一，特别是当你以超级用户身份运行它时。`-r`选项指定*递归删除*，它会反复删除`dir`内部的所有内容。不要与像星号（`*`）这样的通配符一起使用`-r`标志。最重要的是，运行命令之前务必三思而后行。
- en: 2.4.4 Shell Globbing (“Wildcards”)
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.4 Shell 通配符匹配（“通配符”）
- en: 'The shell can match simple patterns to file and directory names, a process
    known as *globbing*. This is similar to the concept of wildcards in other systems.
    The simplest of these is the glob character `*`, which tells the shell to match
    any number of arbitrary characters. For example, the following command prints
    a list of files in the current directory:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 可以将简单模式匹配到文件和目录名称，这个过程叫做*通配符匹配*。这与其他系统中的通配符概念类似。最简单的通配符是`*`，它告诉 Shell
    匹配任意数量的任意字符。例如，下面的命令会打印当前目录中的文件列表：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The shell matches arguments containing globs to filenames, substitutes the
    filenames for those arguments, and then runs the revised command line. The substitution
    is called *expansion* because the shell substitutes all matching filenames for
    a simplified expression. Here are some ways to use `*` to expand filenames:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 会将包含通配符的参数匹配到文件名，并用这些文件名替换相应的参数，然后执行修改后的命令行。这个替换过程叫做*扩展*，因为 Shell 会用所有匹配的文件名替换简化的表达式。以下是一些使用`*`来扩展文件名的方法：
- en: '`at*` expands to all filenames that start with `at`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`at*` 会展开为所有以`at`开头的文件名。'
- en: '`*at` expands to all filenames that end with `at`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*at` 会展开为所有以`at`结尾的文件名。'
- en: '`*at*` expands to all filenames that contain `at`.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*at*` 会展开为所有包含`at`的文件名。'
- en: If no files match a glob, the `bash` shell performs no expansion, and the command
    runs with literal characters such as `*.` For example, try a command such as `echo
    *dfkdsafh`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有文件匹配通配符，`bash` Shell 不会进行扩展，命令将以字面字符（如`*.`）运行。例如，可以尝试命令`echo *dfkdsafh`。
- en: Another shell glob character, the question mark (`?`), instructs the shell to
    match exactly one arbitrary character. For example, `b?at` matches `boat` and
    `brat`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 Shell 通配符字符是问号（`?`），它告诉 Shell 匹配恰好一个任意字符。例如，`b?at`可以匹配`boat`和`brat`。
- en: If you don’t want the shell to expand a glob in a command, enclose the glob
    in single quotes (`''`). For example, the command `echo '*'` prints a star. You
    will find this handy for a few of the commands described in the next section,
    such as `grep` and `find`. (You’ll learn more much about quoting in Section 11.2.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不希望 Shell 扩展命令中的通配符，可以将通配符用单引号（`''`）括起来。例如，命令`echo '*'`会打印一个星号。你会发现这对于接下来章节中描述的某些命令（如`grep`和`find`）非常有用。（你将在第11.2节学到更多关于引用的内容。）
- en: There is more to the shell’s pattern-matching capabilities, but `*` and `?`
    are what you need to know now. Section 2.7 describes glob behavior with those
    funny files that start with a dot.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 的模式匹配能力还有更多内容，但`*`和`?`是现在需要了解的内容。第2.7节描述了包含点（`.`）的特殊文件的通配符行为。
- en: 2.5 Intermediate Commands
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 中级命令
- en: This section describes the most essential intermediate Unix commands.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了最基本的中级 Unix 命令。
- en: 2.5.1 grep
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 grep
- en: 'The `grep` command prints the lines from a file or input stream that match
    an expression. For example, to print the lines in the */etc/passwd* file that
    contain the text `root`, enter this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`命令会打印出文件或输入流中与某个表达式匹配的行。例如，要打印`/etc/passwd`文件中包含文本`root`的行，可以输入以下命令：'
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `grep` command is extraordinarily handy when operating on multiple files
    at once because it prints the filename in addition to the matching line. For example,
    if you want to check every file in */etc* that contains the word `root`, you could
    use this command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep` 命令在同时操作多个文件时非常方便，因为它会在匹配行之外打印文件名。例如，如果你想检查 `/etc` 中的每个文件是否包含 `root`
    这个词，可以使用以下命令：'
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Two of the most important `grep` options are `-i` (for case-insensitive matches)
    and `-v` (which inverts the search—that is, prints all lines that *don’t* match).
    There is also a more powerful variant called `egrep` (which is just a synonym
    for `grep -E`).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep` 的两个最重要的选项是 `-i`（用于不区分大小写的匹配）和 `-v`（反转搜索——即打印所有 *不* 匹配的行）。还有一个更强大的变体叫做
    `egrep`（它只是 `grep -E` 的别名）。'
- en: '`grep` understands *regular expressions*, patterns that are grounded in computer
    science theory and are very common in Unix utilities. Regular expressions are
    more powerful than wildcard-style patterns, and they have a different syntax.
    There are three important things to remember about regular expressions:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep` 理解 *正则表达式*，正则表达式是计算机科学理论中的模式，广泛应用于 Unix 工具中。正则表达式比通配符样式的模式更强大，并且具有不同的语法。关于正则表达式，有三件重要的事需要记住：'
- en: '`.*` matches any number of characters, including none (like the `*` in globs
    and wildcards).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.*` 匹配任意数量的字符，包括没有字符（就像通配符中的 `*`）。'
- en: '`.+` matches any one or more characters.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.+` 匹配一个或多个任意字符。'
- en: '`.` matches exactly one arbitrary character.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.` 匹配任意一个字符。'
- en: 2.5.2 less
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 less
- en: The `less` command comes in handy when a file is really big or when a command’s
    output is long and scrolls off the top of the screen.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`less` 命令在文件非常大或命令输出过长并滚动超出屏幕时非常有用。'
- en: To page through a big file like */usr/share/dict/words*, you can use the command
    `less` `/usr/share/dict/words`. When running `less`, you’ll see the contents of
    the file one screenful at a time. Press the spacebar to go forward in the file
    and press b (lowercase) to skip back one screenful. To quit, press q.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐页查看像 `/usr/share/dict/words` 这样的大文件，可以使用命令 `less` `/usr/share/dict/words`。运行
    `less` 后，你会一次看到文件的一个屏幕内容。按空格键向前翻页，按 b（小写）向后翻页。要退出，按 q。
- en: You can also search for text inside `less`. For example, to search forward for
    a word, you can type `/``word`, and to search backward, you can use `?``word`.
    When you find a match, press n to continue searching.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 `less` 中搜索文本。例如，向前搜索一个词，可以输入 `/` `word`，向后搜索可以用 `?` `word`。当找到匹配项时，按 n
    继续搜索。
- en: 'As you’ll learn in Section 2.14, you can send the standard output of nearly
    any program directly to another program’s standard input. This is exceptionally
    useful when you have a command with a lot of output to sift through and you’d
    like to use something like `less` to view the output. Here’s an example of sending
    the output of a `grep` command to `less`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在 2.14 节中学到的，你可以将几乎任何程序的标准输出直接传递到另一个程序的标准输入。这在你有大量输出需要筛选时特别有用，像 `less` 这样的工具可以帮助你查看输出。以下是将
    `grep` 命令的输出传递给 `less` 的示例：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Try this command out for yourself. You’ll probably find many similar uses for
    `less`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 自己试试这个命令。你可能会发现 `less` 有许多类似的用途。
- en: 2.5.3 pwd
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.3 pwd
- en: The `pwd` (print working directory) program simply outputs the name of the current
    working directory. You may be wondering why you need this when most Linux distributions
    set up user accounts with the current working directory in the prompt. There are
    two reasons.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`pwd`（打印工作目录）程序简单地输出当前工作目录的名称。你可能会想，既然大多数 Linux 发行版在提示符中已设置当前工作目录，为什么还需要这个命令呢？这里有两个原因。'
- en: First, not all prompts include the current working directory, especially because
    you may want to get rid of it in your own prompt because it takes up a lot of
    space. If you do so, you need `pwd`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，并非所有的提示符都包括当前工作目录，尤其是你可能想在自己的提示符中去掉它，因为它会占用大量空间。如果你这样做了，你需要使用 `pwd`。
- en: Second, the symbolic links that you’ll learn about in Section 2.17.2 can sometimes
    obscure the true full path of the current working directory. Use `pwd -P` to eliminate
    this confusion.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你将在 2.17.2 节中学到的符号链接有时会掩盖当前工作目录的真实完整路径。使用 `pwd -P` 可以消除这种混淆。
- en: 2.5.4 diff
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.4 diff
- en: 'To see the differences between two text files, use `diff`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看两个文本文件之间的差异，可以使用 `diff`：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Several options can control the format of the output, and the default output
    format is often the most comprehensible for human beings. However, most programmers
    prefer the output from `diff -u` when they need to send the output to someone
    else, because automated tools have an easier time with this format.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个选项可以控制输出格式，默认的输出格式通常是最容易理解的。然而，大多数程序员在需要将输出发送给别人时更喜欢使用`diff -u`的输出格式，因为自动化工具在这个格式下处理起来更容易。
- en: 2.5.5 file
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.5 file
- en: 'If you see a file and are unsure of its format, try using the `file` command
    to see if the system can guess it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到一个文件，并且不确定它的格式，可以尝试使用`file`命令查看系统是否能够猜测出它的格式：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You may be surprised by how much this innocent-looking command can do.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶于这个看似无害的命令能做这么多事情。
- en: 2.5.6 find and locate
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.6 find 和 locate
- en: 'It’s frustrating when you know that a certain file is in a directory tree somewhere
    but you just don’t know where. Run `find` to find `file` in `dir` as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道某个文件在某个目录树中但就是不知道在哪里时，使用`find`命令查找`file`在`dir`中的位置，如下所示：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Like most programs in this section, `find` is capable of some fancy stuff. However,
    don’t try options such as `-exec` before you know the form shown here by heart
    and understand why you need the `-name` and `-print` options. The `find` command
    accepts special pattern-matching characters such as `*`, but you must enclose
    them in single quotes (`'*'`) to protect the special characters from the shell’s
    own globbing feature. (Recall from Section 2.4.4 that the shell expands globs
    *before* running commands.)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 和本节中的大多数程序一样，`find`也能执行一些复杂的操作。然而，在你完全掌握并理解为什么需要`-name`和`-print`选项之前，不要尝试使用像`-exec`这样的选项。`find`命令接受特殊的模式匹配字符，例如`*`，但你必须将它们用单引号（`'*'`）括起来，以防止特殊字符被Shell的通配符特性所扩展。（回想一下第2.4.4节，Shell会在执行命令之前扩展通配符。）
- en: Most systems also have a `locate` command for finding files. Rather than searching
    for a file in real time, `locate` searches an index that the system builds periodically.
    Searching with `locate` is much faster than `find`, but if the file you’re looking
    for is newer than the index, `locate` won’t find it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数系统还具有`locate`命令用于查找文件。`locate`不会实时搜索文件，而是搜索系统定期建立的索引。使用`locate`进行搜索比使用`find`要快得多，但如果你要找的文件比索引更新，`locate`将找不到它。
- en: 2.5.7 head and tail
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.7 head 和 tail
- en: The `head` and `tail` commands allow you to quickly view a portion of a file
    or stream of data. For example, `head /etc/passwd` shows the first 10 lines of
    the password file, and `tail /etc/passwd` shows the last 10 lines.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`head`和`tail`命令允许你快速查看文件或数据流的一部分。例如，`head /etc/passwd`显示密码文件的前10行，`tail /etc/passwd`显示密码文件的最后10行。'
- en: To change the number of lines to display, use the `-n` option, where `n` is
    the number of lines you want to see (for example, `head -5 /etc/passwd`). To print
    lines starting at line `n`, use `tail +``n`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改显示的行数，请使用`-n`选项，其中`n`是您想要查看的行数（例如，`head -5 /etc/passwd`）。要从第`n`行开始打印行，请使用`tail
    +``n`。
- en: 2.5.8 sort
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.8 sort
- en: The `sort` command quickly puts the lines of a text file in alphanumeric order.
    If the file’s lines start with numbers and you want to sort in numerical order,
    use the `-n` option. The `-r` option reverses the order of the sort.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`命令可以快速将文本文件的行按字母数字顺序排列。如果文件的行以数字开头，并且你希望按数字顺序排序，请使用`-n`选项。`-r`选项会反转排序顺序。'
- en: 2.6 Changing Your Password and Shell
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 更改密码和 shell
- en: Use the `passwd` command to change your password. You’ll be asked for your old
    password and then prompted for your new password twice.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`passwd`命令更改密码。系统会要求你输入旧密码，然后提示你输入新密码两次。
- en: The best passwords tend to be long “nonsense” sentences that are easy to remember.
    The longer the password (in terms of character length), the better; try for 16
    characters or more. (In the very old days, the number of characters you could
    use was limited, so you were advised to add strange characters and such.)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳密码通常是长的“胡言乱语”句子，容易记住。密码越长（字符长度越多），就越好；尝试16个字符或更多。（在早期，您可以使用的字符数有限，因此建议添加一些奇怪的字符等。）
- en: You can change your shell with the `chsh` command (to an alternative such as
    `zsh`, `ksh` or `tcsh`), but keep in mind that this book assumes you’re running
    `bash`, so if you make a change, some of the examples may not work.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`chsh`命令更改你的Shell（例如更换为`zsh`、`ksh`或`tcsh`），但请记住，本书假设你正在使用`bash`，所以如果你进行了更改，某些示例可能无法正常工作。
- en: 2.7 Dot Files
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7 点文件
- en: Change to your home directory if you’re not already there, type `ls` to take
    a look around, and then run `ls -a`. Do you see the difference in the output?
    When you run `ls` without the `-a`, you won’t see the configuration files called
    *dot files*. These are files and directories whose names begin with a dot (`.`).
    Common dot files are *.bashrc* and *.login*, and there are dot directories, too,
    such as *.ssh*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不在家目录中，先切换到家目录，输入`ls`查看内容，然后运行`ls -a`。你看到输出的区别了吗？当你运行没有`-a`选项的`ls`时，你看不到以*点文件*（dot
    files）命名的配置文件。这些是以点（`.`）开头的文件和目录。常见的点文件有*.bashrc*和*.login*，也有点目录，例如*.ssh*。
- en: There’s nothing special about dot files or directories. Some programs don’t
    show them by default so that you won’t see a complete mess when listing the contents
    of your home directory. For example, `ls` doesn’t list dot files unless you use
    the `-a` option. In addition, shell globs don’t match dot files unless you explicitly
    use a pattern such as `.*`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 点文件和点目录没有什么特别之处。有些程序默认不显示它们，这样在列出家目录的内容时你就不会看到一团乱麻。例如，`ls`默认不列出点文件，除非你使用`-a`选项。此外，shell的通配符默认也不会匹配点文件，除非你显式地使用诸如`.*`这样的模式。
- en: 2.8 Environment and Shell Variables
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.8 环境变量与Shell变量
- en: The shell can store temporary variables, called *shell variables*, containing
    the values of text strings. Shell variables are very useful for keeping track
    of values in scripts, and some shell variables control the way the shell behaves.
    (For example, the `bash` shell reads the `PS1` variable before displaying the
    prompt.)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Shell可以存储临时变量，称为*shell变量*，它们包含文本字符串的值。Shell变量在脚本中非常有用，可以用来跟踪值，并且有些shell变量控制shell的行为。（例如，`bash`
    shell在显示提示符之前会读取`PS1`变量。）
- en: 'To assign a value to a shell variable, use the equal sign (`=`). Here’s a simple
    example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个shell变量赋值，可以使用等号（`=`）。这是一个简单的示例：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding example sets the value of the variable named `STUFF` to `blah`.
    To access this variable, use `$STUFF` (for example, try running `echo $STUFF`).
    You’ll learn about the many uses of shell variables in Chapter 11.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子将名为`STUFF`的变量的值设置为`blah`。要访问这个变量，可以使用`$STUFF`（例如，尝试运行`echo $STUFF`）。你将在第11章了解更多关于shell变量的用法。
- en: An *environment variable* is like a shell variable, but it’s not specific to
    the shell. All processes on Unix systems have environment variable storage. The
    main difference between environment and shell variables is that the operating
    system passes all of your shell’s environment variables to programs that the shell
    runs, whereas shell variables cannot be accessed in the commands that you run.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*环境变量*就像shell变量，但它不是特定于shell的。所有Unix系统上的进程都有环境变量存储。环境变量和shell变量的主要区别在于，操作系统会将你shell的所有环境变量传递给shell运行的程序，而shell变量则无法在你运行的命令中访问。'
- en: 'You assign an environment variable with the shell’s `export` command. For example,
    if you’d like to make the `$STUFF` shell variable into an environment variable,
    use the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用shell的`export`命令来赋值环境变量。例如，如果你想将`$STUFF`这个shell变量变成环境变量，可以使用以下命令：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Because child processes inherit environment variables from their parent, many
    programs read them for configuration and options. For example, you can put your
    favorite `less` command-line options in the `LESS` environment variable, and `less`
    will use those options when you run it. (Many manual pages contain a section labeled
    ENVIRONMENT that describes these variables.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因为子进程会继承父进程的环境变量，许多程序会读取这些变量来进行配置和选项设置。例如，你可以把自己喜欢的`less`命令行选项放在`LESS`环境变量中，当你运行`less`时，它会使用这些选项。（许多手册页中有一个名为ENVIRONMENT的部分，描述了这些变量。）
- en: 2.9 The Command Path
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.9 命令路径
- en: '`PATH` is a special environment variable that contains the *command path* (or
    *path* for short), a list of system directories that the shell searches when trying
    to locate a command. For example, when you run `ls`, the shell searches the directories
    listed in `PATH` for the `ls` program. If programs with the same name appear in
    several directories in the path, the shell runs the first matching program.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`PATH`是一个特殊的环境变量，包含*命令路径*（简称*路径*），它是一个系统目录的列表，当shell尝试定位命令时，它会搜索这些目录。例如，当你运行`ls`时，shell会在`PATH`中列出的目录中搜索`ls`程序。如果路径中的多个目录有相同名称的程序，shell会运行第一个匹配的程序。'
- en: 'If you run `echo $PATH`, you’ll see that the path components are separated
    by colons (`:`). For example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行`echo $PATH`，你会看到路径组件通过冒号（`:`）分隔。例如：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To tell the shell to look in more places for programs, change the `PATH` environment
    variable. For example, by using this command, you can add a directory `dir` to
    the beginning of the path so that the shell looks in `dir` before looking in any
    of the other `PATH` directories:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要让 shell 在更多位置查找程序，可以更改 `PATH` 环境变量。例如，通过使用此命令，可以将目录 `dir` 添加到路径的开头，以便 shell
    在查找其他 `PATH` 目录之前，首先查找 `dir`：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Or you can append a directory name to the end of the `PATH` variable, causing
    the shell to look in `dir` last:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以将目录名附加到 `PATH` 变量的末尾，使得 shell 最后查找 `dir`：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 2.10 Special Characters
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.10 特殊字符
- en: When discussing Linux with others, you should know a few names for some of the
    special characters that you’ll encounter. If you’re amused by this sort of thing,
    see the “Jargon File” (*http://www.catb.org/jargon/html/*) or its printed companion,
    *The New Hacker’s Dictionary*, 3rd edition, by Eric S. Raymond (MIT Press, 1996).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在与他人讨论 Linux 时，你应该了解一些你将遇到的特殊字符的名称。如果你对这些感兴趣，可以参阅“行话文件”(*http://www.catb.org/jargon/html/*)
    或其印刷版，《黑客新字典》第三版，由 Eric S. Raymond 编写（MIT出版社，1996年）。
- en: '[Table 2-1](#table2-1) describes a select set of the special characters, many
    of which you’ve already seen in this chapter. Some utilities, such as the Perl
    programming language, use almost all of these special characters! (Keep in mind
    that these are the American names for the characters.)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-1](#table2-1) 描述了一些常见的特殊字符，你在本章中已经看到了其中很多字符。一些工具，如 Perl 编程语言，几乎使用了所有这些特殊字符！(请记住，这些是字符的美国名称。)'
- en: 'Table 2-1: Special Characters'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1：特殊字符
- en: '| **Character** | **Name(s)** | **Uses** |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **字符** | **名称** | **用途** |'
- en: '| --- | --- | --- |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `*` | star, asterisk | Regular expression, glob character |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 星号，星形符号 | 正则表达式，通配符 |'
- en: '| `.` | dot | Current directory, file/hostname delimiter |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 点号 | 当前目录，文件/主机名分隔符 |'
- en: '| `!` | bang | Negation, command history |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `!` | bang | 否定，命令历史 |'
- en: '| `&#124;` | pipe | Command pipes |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 管道符号 | 命令管道 |'
- en: '| `/` | (forward) slash | Directory delimiter, search command |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 正斜杠 | 目录分隔符，搜索命令 |'
- en: '| `\` | backslash | Literals, macros (*never* directories) |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `\` | 反斜杠 | 字面值，宏（*绝不*是目录） |'
- en: '| `$` | dollar | Variables, end of line |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 美元符号 | 变量，行尾 |'
- en: '| `''` | tick, (single) quote | Literal strings |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `''` | 反引号，单引号 | 字面字符串 |'
- en: '| `` ` `` | backtick, backquote | Command substitution |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `` ` `` | 反引号 | 命令替换 |'
- en: '| `"` | double quote | Semi-literal strings |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `"` | 双引号 | 半字面字符串 |'
- en: '| `^` | caret | Negation, beginning of line |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 插入符号 | 否定，行首 |'
- en: '| `~` | tilde, squiggle | Negation, directory shortcut |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `~` | 波浪符，敲击符 | 否定，目录快捷方式 |'
- en: '| `#` | hash, sharp, pound | Comments, preprocessor, substitutions |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `#` | 井号，尖锐符号，磅符号 | 注释，预处理器，替换 |'
- en: '| `[ ]` | (square) brackets | Ranges |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `[ ]` | 方括号 | 范围 |'
- en: '| `{ }` | braces, (curly) brackets | Statement blocks, ranges |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `{ }` | 大括号，圆括号 | 语句块，范围 |'
- en: '| `_` | underscore, under | Cheap substitute for a space used when spaces aren’t
    wanted or allowed, or when autocomplete algorithms get confused |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `_` | 下划线，底线 | 当不想或不允许使用空格时，或当自动补全算法混淆时，常用作空格的廉价替代 |'
- en: 2.11 Command-Line Editing
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.11 命令行编辑
- en: As you play with the shell, notice that you can edit the command line using
    the left and right arrow keys, as well as page through previous commands using
    the up and down arrows. This is standard on most Linux systems.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在使用 shell 时，注意到你可以使用左右箭头键编辑命令行，同时也可以使用上下箭头键浏览之前的命令。这在大多数 Linux 系统中是标准配置。
- en: However, it’s a good idea to forget about the arrow keys and use control key
    combinations instead. If you learn the ones listed in [Table 2-2](#table2-2),
    you’ll find that you’re better able to enter text in the many Unix programs that
    use these standard keystrokes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最好忘记箭头键，而改用控制键组合。如果你学会了 [表 2-2](#table2-2) 中列出的快捷键，你会发现自己能更好地在许多使用这些标准快捷键的
    Unix 程序中输入文本。
- en: 'Table 2-2: Command-Line Keystrokes'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-2：命令行快捷键
- en: '| **Keystroke** | **Action** |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| **快捷键** | **动作** |'
- en: '| --- | --- |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ctrl-B | Move the cursor left |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| ctrl-B | 将光标向左移动 |'
- en: '| ctrl-F | Move the cursor right |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| ctrl-F | 将光标向右移动 |'
- en: '| ctrl-P | View the previous command (or move the cursor up) |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| ctrl-P | 查看上一条命令（或将光标向上移动） |'
- en: '| ctrl-N | View the next command (or move the cursor down) |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| ctrl-N | 查看下一条命令（或将光标向下移动） |'
- en: '| ctrl-A | Move the cursor to the beginning of the line |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| ctrl-A | 将光标移动到行首 |'
- en: '| ctrl-E | Move the cursor to the end of the line |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| ctrl-E | 将光标移动到行末 |'
- en: '| ctrl-W | Erase the preceding word |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| ctrl-W | 删除前一个单词 |'
- en: '| ctrl-U | Erase from cursor to beginning of line |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| ctrl-U | 从光标处删除到行首 |'
- en: '| ctrl-K | Erase from cursor to end of line |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| ctrl-K | 从光标处删除到行尾 |'
- en: '| ctrl-Y | Paste erased text (for example, from ctrl-U) |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| ctrl-Y | 粘贴已删除的文本（例如，从ctrl-U） |'
- en: 2.12 Text Editors
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.12 文本编辑器
- en: Speaking of editing, it’s time to learn an editor. To get serious with Unix,
    you must be able to edit text files without damaging them. Most parts of the system
    use plaintext configuration files (like the ones in */etc*). It’s not difficult
    to edit files, but you will do it so often that you need a powerful tool for the
    job.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 说到编辑，到了学习编辑器的时候了。要认真对待 Unix，你必须能够编辑文本文件而不损坏它们。系统的许多部分使用纯文本配置文件（如*/etc*中的文件）。编辑文件并不难，但你会做得如此频繁，以至于需要一个强大的工具来完成这项工作。
- en: 'You should try to learn one of the two de facto standard Unix text editors,
    vi and Emacs. Most Unix wizards are religious about their choice of editor, but
    don’t listen to them. Just choose for yourself. If you choose one that matches
    the way that you work, you’ll find it easier to learn. Basically, the choice comes
    down to this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该尝试学习两种事实上的标准 Unix 文本编辑器之一：vi 和 Emacs。大多数 Unix 大师对于他们选择的编辑器有着宗教般的偏执，但不要听他们的。自己选择一个适合你的工具。如果你选择一个与你的工作方式匹配的编辑器，你会发现学习起来更容易。基本上，选择可以归结为以下几点：
- en: If you want an editor that can do almost anything and has extensive online help,
    and you don’t mind doing some extra typing to get these features, try Emacs.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要一个几乎可以做任何事情并且拥有广泛在线帮助的编辑器，而且你不介意额外的打字工作来获得这些功能，可以试试 Emacs。
- en: If speed is everything, give vi a shot; it “plays” a bit like a video game.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果速度最重要，试试 vi；它有点像玩视频游戏。
- en: '*Learning the vi and Vim Editors: Unix Text Processing*, 7th edition, by Arnold
    Robbins, Elbert Hannah, and Linda Lamb (O’Reilly, 2008), can tell you everything
    you need to know about vi. For Emacs, use the online tutorial: start Emacs, press
    ctrl-H, and then type T. Or read *GNU Emacs Manual*, 18th edition, by Richard
    M. Stallman (Free Software Foundation, 2018).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*学习 vi 和 Vim 编辑器：Unix 文本处理*（第七版），作者：Arnold Robbins、Elbert Hannah 和 Linda Lamb（O’Reilly,
    2008），可以告诉你关于 vi 的一切。对于 Emacs，可以使用在线教程：启动 Emacs，按 ctrl-H，然后输入 T，或者阅读 *GNU Emacs
    手册*（第十八版），作者：Richard M. Stallman（自由软件基金会，2018）。'
- en: You might be tempted to experiment with a friendlier editor when you first start
    out, such as nano, Pico, or one of the myriad GUI editors out there, but if you
    tend to make a habit out of the first thing that you use, you don’t want to go
    this route.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 刚开始时，你可能会想尝试一个更友好的编辑器，比如nano、Pico或众多图形界面编辑器之一，但如果你倾向于养成使用第一个工具的习惯，你就不想走这条路。
- en: 2.13 Getting Online Help
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.13 获取在线帮助
- en: 'Linux systems come with a wealth of documentation. For basic commands, the
    manual pages (or *man pages*) will tell you what you need to know. For example,
    to see the manual page for the `ls` command, run `man` as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 系统自带大量文档。对于基础命令，手册页（或称*man 页）会告诉你所需的信息。例如，要查看`ls`命令的手册页，可以运行`man`命令，如下所示：
- en: '[PRE27]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Most manual pages concentrate primarily on reference information, perhaps with
    some examples and cross-references, but that’s about it. Don’t expect a tutorial,
    and don’t expect an engaging literary style.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数手册页主要集中在参考信息上，可能会包含一些示例和交叉引用，但就这些。不要指望它是教程，也不要指望它有吸引力的文学风格。
- en: When programs have many options, the manual page often lists the options in
    some systematic way (for example, in alphabetical order), but it won’t tell you
    what the important ones are. If you’re patient, you can usually find what you
    need to know in the man page. If you’re impatient, ask a friend—or pay someone
    to be your friend so that you can ask him or her.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序有很多选项时，手册页通常会以某种系统化的方式列出这些选项（例如，按字母顺序），但它不会告诉你哪些选项是重要的。如果你有耐心，通常可以在手册页中找到你需要了解的内容。如果你不耐烦，可以请朋友帮忙——或者付钱请个朋友，这样你就可以向他或她请教了。
- en: 'To search for a manual page by keyword, use the `-k` option:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要按关键词搜索手册页，可以使用 `-k` 选项：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is helpful if you don’t quite know the name of the command that you want.
    For example, if you’re looking for a command to sort something, run:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于你不太确定自己想要的命令名时很有帮助。例如，如果你在寻找一个排序命令，可以运行：
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The output includes the manual page name, the manual section (see below), and
    a quick description of what the manual page contains.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 输出内容包括手册页的名称、手册章节（见下文）以及对手册页内容的简要描述。
- en: Manual pages are referenced by numbered sections. When someone refers to a manual
    page, they often put the section number in parentheses next to the name, like
    ping(8). [Table 2-3](#table2-3) lists the sections and their numbers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 手册页通过编号的章节进行引用。当有人引用手册页时，他们通常会在名称旁边加上章节号，如 ping(8)。[表 2-3](#table2-3) 列出了章节及其编号。
- en: 'Table 2-3: Online Manual Sections'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-3：在线手册章节
- en: '| **Section** | **Description** |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| **章节** | **描述** |'
- en: '| --- | --- |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | User commands |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 用户命令 |'
- en: '| 2 | Kernel system calls |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 内核系统调用 |'
- en: '| 3 | Higher-level Unix programming library documentation |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 高级 Unix 编程库文档 |'
- en: '| 4 | Device interface and driver information |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 设备接口和驱动程序信息 |'
- en: '| 5 | File descriptions (system configuration files) |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 文件描述（系统配置文件） |'
- en: '| 6 | Games |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 游戏 |'
- en: '| 7 | File formats, conventions, and encodings (ASCII, suffixes, and so on)
    |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 文件格式、约定和编码（ASCII、后缀等） |'
- en: '| 8 | System commands and servers |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 系统命令和服务器 |'
- en: Sections 1, 5, 7, and 8 should be good supplements to this book. Section 4 may
    be of marginal use, and Section 6 would be great if only it were a little larger.
    You probably won’t be able to use Section 3 if you aren’t a programmer, but you
    may be able to understand some of the material in Section 2 once you’ve read more
    about system calls in this book.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 章节 1、5、7 和 8 应该是本书的良好补充。第 4 章可能用处不大，第 6 章如果再大一点会更好。如果你不是程序员，可能无法使用第 3 章，但一旦你阅读了更多关于系统调用的内容，第
    2 章的一些材料你可能能理解。
- en: 'Some common terms have many matching manual pages across several sections.
    By default, `man` displays the first page that it finds. You can select a manual
    page by section. For example, to read the */etc/passwd* file description (as opposed
    to the `passwd` command), you can insert the section number before the page name
    like so:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见术语在多个章节中有许多匹配的手册页。默认情况下，`man` 会显示它找到的第一个页面。你可以通过章节选择手册页。例如，要阅读 */etc/passwd*
    文件描述（而不是 `passwd` 命令），你可以在页面名称前加上章节号，如下所示：
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Manual pages cover the essentials, but there are many more ways to get online
    help (aside from searching the internet). If you’re just looking for a certain
    option for a command, try entering a command name followed by `--help` or `-h`
    (the option varies from command to command). You may get a deluge (as in the case
    of `ls --help`), or you may find just what you’re looking for.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 手册页涵盖了基本内容，但还有许多其他方式可以获取在线帮助（除了搜索互联网）。如果你只是想找某个命令的选项，可以尝试输入命令名称后加 `--help` 或
    `-h`（每个命令的选项不同）。你可能会得到大量的输出（如 `ls --help`），或者你可能找到你需要的信息。
- en: 'Some time ago, the GNU Project decided that it didn’t like manual pages very
    much and switched to another format called *info* (or *texinfo*). Often this documentation
    goes further than a typical manual page does, but it can be more complex. To access
    an info manual, use `info` with the command name:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 前些时候，GNU 项目决定不再太喜欢手册页，而转向了一种叫做 *info*（或 *texinfo*）的格式。通常这种文档比典型的手册页要深入，但它也可能更复杂。要访问
    info 手册，可以使用 `info` 命令加上命令名：
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you don’t like the `info` reader, you can send the output to `less` (just
    add `| less`).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢 `info` 阅读器，可以将输出发送到 `less`（只需添加 `| less`）。
- en: Some packages dump their available documentation into */usr/share/doc* with
    no regard for online manual systems such as `man` or `info`. See this directory
    on your system if you find yourself searching for documentation—and, of course,
    search the internet.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一些软件包将它们可用的文档直接转储到 */usr/share/doc* 目录，而不考虑像 `man` 或 `info` 这样的在线手册系统。如果你发现自己在寻找文档时，可以查看此目录——当然，也可以搜索互联网。
- en: 2.14 Shell Input and Output
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.14 Shell 输入与输出
- en: Now that you’re familiar with basic Unix commands, files, and directories, you’re
    ready to learn how to redirect standard input and output. Let’s start with standard
    output.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了基本的 Unix 命令、文件和目录，你准备好学习如何重定向标准输入和输出了。我们从标准输出开始。
- en: 'To send the output of `command` to a file instead of the terminal, use the
    `>` redirection character:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `command` 的输出发送到文件而不是终端，可以使用 `>` 重定向字符：
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The shell creates `file` if it does not already exist. If `file` exists, the
    shell erases (*clobbers*) the original file first. (Some shells have parameters
    that prevent clobbering. For example, you can enter `set -C` to avoid clobbering
    in `bash`.)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件 `file` 不存在，shell 会创建它。如果 `file` 已经存在，shell 会首先删除（*覆盖*）原始文件。（有些 shell 有防止覆盖的参数。例如，你可以在
    `bash` 中输入 `set -C` 来避免覆盖。）
- en: 'You can append the output to the file instead of overwriting it with the `>>`
    redirection syntax:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `>>` 重定向语法将输出附加到文件，而不是覆盖文件：
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is a handy way to collect output in one place when executing sequences
    of related commands.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种在执行相关命令序列时将输出收集到一个地方的便捷方式。
- en: 'To send the standard output of a command to the standard input of another command,
    use the pipe character (`|`). To see how this works, try these two commands:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个命令的标准输出发送到另一个命令的标准输入中，使用管道符号（`|`）。要查看这个是如何工作的，试试下面这两个命令：
- en: '[PRE34]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can send output through as many piped commands as you wish; just add another
    pipe before each additional command.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将输出通过任意多的管道命令传输；只需在每个附加命令前添加另一个管道符号。
- en: 2.14.1 Standard Error
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.14.1 标准错误
- en: 'Occasionally, you may redirect standard output but find that the program still
    prints something to the terminal. This is called *standard error* (stderr); it’s
    an additional output stream for diagnostics and debugging. For example, this command
    produces an error:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，你可能会重定向标准输出，但发现程序仍然会向终端输出内容。这被称为 *标准错误*（stderr）；它是用于诊断和调试的额外输出流。例如，这个命令会产生一个错误：
- en: '[PRE35]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After completion, *f* should be empty, but you still see the following error
    message on the terminal as standard error:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，*f* 应该为空，但你仍然会在终端看到以下作为标准错误的错误信息：
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can redirect the standard error if you like. For example, to send standard
    output to *f* and standard error to *e*, use the `2>` syntax, like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要重定向标准错误。例如，要将标准输出重定向到 *f* 并将标准错误重定向到 *e*，可以使用 `2>` 语法，如下所示：
- en: '[PRE37]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The number 2 specifies the *stream ID* that the shell modifies. Stream ID 1
    is standard output (the default), and 2 is standard error.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 数字 2 指定了 shell 修改的 *流 ID*。流 ID 1 是标准输出（默认），而 2 是标准错误。
- en: 'You can also send the standard error to the same place as stdout with the `>&`
    notation. For example, to send both standard output and standard error to the
    file named *f*, try this command:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `>&` 语法将标准错误发送到与标准输出相同的位置。例如，要将标准输出和标准错误都发送到名为 *f* 的文件中，可以使用以下命令：
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 2.14.2 Standard Input Redirection
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.14.2 标准输入重定向
- en: 'To channel a file to a program’s standard input, use the `<` operator:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文件通道到程序的标准输入中，使用 `<` 操作符：
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You will occasionally run into a program that requires this type of redirection,
    but because most Unix commands accept filenames as arguments, this isn’t very
    common. For example, the preceding command could have been written as `head /proc/cpuinfo`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你偶尔会遇到需要这种重定向的程序，但由于大多数 Unix 命令接受文件名作为参数，这种情况并不常见。例如，上面的命令可以写成 `head /proc/cpuinfo`。
- en: 2.15 Understanding Error Messages
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.15 理解错误信息
- en: When you encounter a problem on a Unix-like system such as Linux, you *must*
    read the error message. Unlike messages from other operating systems, Unix errors
    usually tell you exactly what went wrong.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在类似 Unix 的系统（如 Linux）上遇到问题时，*必须* 阅读错误信息。与其他操作系统的消息不同，Unix 错误通常会直接告诉你出了什么问题。
- en: 2.15.1 Anatomy of a Unix Error Message
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.15.1 Unix 错误信息的构成
- en: 'Most Unix programs generate and report the same basic error messages, but there
    can be subtle differences between the output of any two programs. Here’s an example
    that you’ll certainly encounter in some form or other:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Unix 程序生成并报告相同的基本错误信息，但不同程序的输出可能会有细微差别。下面是一个你一定会以某种形式遇到的例子：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'There are three components to this message:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个信息包含三个部分：
- en: The program name, `ls`. Some programs omit this identifying information, which
    can be annoying when you’re writing shell scripts, but it’s not really a big deal.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序名 `ls`。有些程序省略这个标识信息，当你写 shell 脚本时，这可能会很烦人，但其实不算大问题。
- en: The filename, `/dsafsda`, which is a more specific piece of information. There’s
    a problem with this path.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名 `/dsafsda`，这是更具体的信息。这个路径存在问题。
- en: The error `No such file or directory` indicates the problem with the filename.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误信息 `No such file or directory` 表示文件名存在问题。
- en: Putting it all together, you get something like “`ls` tried to open `/dsafsda`
    but couldn’t because it doesn’t exist.” This may seem obvious, but these messages
    can get a little confusing when you run a shell script that includes an erroneous
    command under a different name.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 综合来看，你会看到类似“`ls` 尝试打开 `/dsafsda`，但由于该文件不存在，无法打开。”这样的信息。这可能看起来显而易见，但当你运行包含错误命令的
    shell 脚本时，这些信息可能会有些混淆。
- en: 'When troubleshooting errors, always address the first error first. Some programs
    report that they can’t do anything before reporting a host of other problems.
    For example, say you run a fictitious program called `scumd` and you see this
    error message:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在排查错误时，始终先解决第一个错误。有些程序在报告其他问题之前，会先报告它们无法执行任何操作。例如，假设你运行了一个虚拟的程序 `scumd`，并且看到以下错误信息：
- en: '[PRE41]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Following this is a huge list of other error messages that looks like a complete
    catastrophe. Don’t let those other errors distract you. You probably just need
    to create */etc/scumd/config*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着是一长串看起来像灾难的其他错误信息。不要让那些错误分散你的注意力。你可能只需要创建 */etc/scumd/config*。
- en: 2.15.2 Common Errors
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.15.2 常见错误
- en: Many errors you’ll encounter in Unix programs result from things that can go
    wrong with files and processes. Quite a few of these errors stem directly from
    conditions that kernel system calls encounter, so you can learn something about
    how the kernel sends problems back to processes by looking at them.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 Unix 程序中遇到的许多错误都源于文件和进程可能出现的各种问题。其中许多错误直接源于内核系统调用遇到的情况，因此你可以通过查看这些错误，了解内核是如何将问题反馈给进程的。
- en: No such file or directory
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 没有这样的文件或目录
- en: This is the number one error. You tried to access a file that doesn’t exist.
    Because the Unix file I/O system doesn’t discriminate much between files and directories,
    this error message covers both cases. You get it when you try to read a file that
    doesn’t exist, when you try to change to a directory that isn’t there, when you
    try to write to a file in a directory that doesn’t exist, and so on. This error
    is also known as ENOENT, short for “Error NO ENTity.”
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最常见的错误。你试图访问一个不存在的文件。由于 Unix 文件 I/O 系统对文件和目录的区分不大，这条错误信息涵盖了这两种情况。当你试图读取一个不存在的文件时，当你试图切换到一个不存在的目录时，当你试图在一个不存在的目录下写入文件时，等等。这条错误也被称为
    ENOENT，表示“没有实体错误”。
- en: File exists
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文件已存在
- en: In this case, you probably tried to create a file that already exists. This
    is common when you try to create a directory with the same name as a file.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可能试图创建一个已存在的文件。这通常发生在你尝试创建一个与文件同名的目录时。
- en: Not a directory, Is a directory
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不是目录，是目录
- en: 'These messages pop up when you try to use a file as a directory, or a directory
    as a file. For example:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试将一个文件当作目录使用，或者将一个目录当作文件使用时，这些信息会弹出。例如：
- en: '[PRE42]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice that the error message applies only to the `a` part of `a/b`. When you
    encounter this problem, you may need to dig around a little to find the path component
    that is being treated like a directory.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，错误信息仅适用于 `a/b` 中的 `a` 部分。当你遇到这个问题时，你可能需要深入挖掘，找出哪个路径组件被当作目录处理。
- en: No space left on device
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设备上没有剩余空间
- en: You’re out of disk space.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你已用尽磁盘空间。
- en: Permission denied
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 权限被拒绝
- en: You get this error when you attempt to read or write to a file or directory
    that you’re not allowed to access (you have insufficient privileges). This error
    also shows when you try to execute a file that does not have the execute bit set
    (even if you can read the file). You’ll read more about permissions in Section
    2.17.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试读取或写入一个你没有权限访问的文件或目录时（你没有足够的权限），会出现此错误。如果你尝试执行一个没有设置执行权限的文件（即使你可以读取该文件），也会出现此错误。你将在
    2.17 节中了解更多关于权限的信息。
- en: Operation not permitted
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 操作不允许
- en: This usually happens when you try to kill a process that you don’t own.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 通常发生在你试图结束一个你不拥有的进程时。
- en: Segmentation fault, Bus error
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 段错误，公交错误
- en: A *segmentation fault* essentially means that the person who wrote the program
    that you just ran screwed up somewhere. The program tried to access a part of
    memory that it was not allowed to touch, and the operating system killed it. Similarly,
    a *bus error* means that the program tried to access some memory in a way it shouldn’t
    have. When you get one of these errors, you might be giving a program some input
    that it did not expect. In rare cases, it might be faulty memory hardware.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*段错误* 本质上意味着你刚刚运行的程序的作者在某个地方出错了。程序试图访问一个它不允许触及的内存区域，操作系统因此终止了它。类似地，*公交错误* 表示程序试图以不应有的方式访问某些内存。当你遇到这些错误时，可能是你向程序输入了它没有预料到的数据。少数情况下，这可能是硬件故障导致的内存问题。'
- en: 2.16 Listing and Manipulating Processes
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.16 列出和操作进程
- en: 'Recall from Chapter 1 that a process is a running program. Each process on
    the system has a numeric *process ID* *(PID)*. For a quick listing of running
    processes, just run `ps` on the command line. You should get a list like this
    one:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 回忆一下第 1 章中，进程是正在运行的程序。系统上的每个进程都有一个数字 *进程 ID* *(PID)*。要快速列出正在运行的进程，只需在命令行中运行
    `ps`。你应该会得到如下所示的列表：
- en: '[PRE43]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The fields are as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 各字段说明如下：
- en: '`PID` The process ID.'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PID` 进程 ID。'
- en: '`TTY` The terminal device where the process is running. More about this later.'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TTY` 进程正在运行的终端设备。稍后会详细讲解。'
- en: '`STAT` The process status—that is, what the process is doing and where its
    memory resides. For example, `S` means sleeping and `R` means running. (See the
    ps(1) manual page for a description of all the symbols.)'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`STAT` 进程状态——即进程正在做什么以及其内存的位置。例如，`S` 表示休眠，`R` 表示运行。（有关所有符号的描述，请参见 ps(1) 手册页面。）'
- en: '`TIME` The amount of CPU time in minutes and seconds that the process has used
    so far. In other words, the total amount of time that the process has spent running
    instructions on the processor. Remember that because processes don’t run constantly,
    this is different from the time since the process started (or “wall-clock time”).'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TIME` 进程已使用的 CPU 时间，以分钟和秒为单位。换句话说，这是进程在处理器上运行指令所消耗的总时间。记住，由于进程不会持续运行，这与进程启动以来的时间（或“挂钟时间”）是不同的。'
- en: '`COMMAND` This one might seem obvious as the command used to run the program,
    but be aware that a process can change this field from its original value. Furthermore,
    the shell can perform glob expansion, and this field will reflect the expanded
    command instead of what you enter at the prompt.'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`COMMAND` 这个看起来可能很明显，是用来运行程序的命令，但请注意，进程可以将此字段从原始值更改。此外，shell 可以执行通配符扩展，并且该字段将反映扩展后的命令，而不是你在提示符下输入的命令。'
- en: 2.16.1 ps Command Options
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.16.1 ps 命令选项
- en: 'The `ps` command has many options. To make things more confusing, you can specify
    options in three different styles—Unix, BSD, and GNU. Many people find the BSD
    style to be the most comfortable (perhaps because it involves less typing), so
    that’s what we’ll use in this book. Here are some of the most useful option combinations:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps` 命令有许多选项。为了避免混淆，你可以使用三种不同的样式来指定选项——Unix、BSD 和 GNU。许多人发现 BSD 样式最为舒适（也许是因为它需要输入更少的内容），所以本书中将使用这种样式。以下是一些最有用的选项组合：'
- en: '`ps x` Show all of your running processes.'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ps x` 显示所有正在运行的进程。'
- en: '`ps ax` Show all processes on the system, not just the ones you own.'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ps ax` 显示系统上的所有进程，而不仅仅是你拥有的进程。'
- en: '`ps u` Include more detailed information on processes.'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ps u` 显示关于进程的更详细信息。'
- en: '`ps w` Show full command names, not just what fits on one line.'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ps w` 显示完整的命令名称，而不仅仅是适合一行显示的部分。'
- en: As with other programs, you can combine options, as in `ps aux` and `ps auxw`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他程序一样，你可以组合选项，例如 `ps aux` 和 `ps auxw`。
- en: To check on a specific process, add its PID to the argument list of the `ps`
    command. For example, to inspect the current shell process, you can use `ps u
    $$` (`$$` is a shell variable that evaluates to the current shell’s PID). You’ll
    find information on the administration commands `top` and `lsof` in Chapter 8.
    These can be useful for locating processes, even when you’re doing something other
    than system maintenance.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查特定进程，可以将其 PID 添加到 `ps` 命令的参数列表中。例如，要检查当前的 shell 进程，可以使用 `ps u $$`（`$$` 是一个
    shell 变量，它会解析为当前 shell 的 PID）。你可以在第 8 章找到关于管理命令 `top` 和 `lsof` 的信息。这些命令即使在你进行系统维护之外也可以帮助你定位进程。
- en: 2.16.2 Process Termination
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.16.2 进程终止
- en: 'To terminate a process, you send it a *signal*—a message to a process from
    the kernel—with the `kill` command. In most cases, all you need to do is this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要终止一个进程，你需要通过 `kill` 命令向它发送一个 *信号*——来自内核的消息。在大多数情况下，你只需要执行以下操作：
- en: '[PRE44]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'There are many types of signals. The default (used above) is `TERM`, or terminate.
    You can send different signals by adding an extra option to `kill`. For example,
    to freeze a process instead of terminating it, use the `STOP` signal:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类型的信号。默认信号（如上所示）是 `TERM`，即终止信号。你可以通过向 `kill` 添加额外选项来发送不同的信号。例如，要冻结一个进程而不是终止它，可以使用
    `STOP` 信号：
- en: '[PRE45]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A stopped process is still in memory, ready to pick up where it left off. Use
    the `CONT` signal to continue running the process again:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一个停止的进程仍然在内存中，准备从停止的位置继续执行。使用 `CONT` 信号可以继续运行该进程：
- en: '[PRE46]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The kernel gives most processes a chance to clean up after themselves upon receiving
    signals (with the *signal handler* mechanism). However, some processes may choose
    a nonterminating action in response to a signal, get wedged in the act of trying
    to handle it, or simply ignore it, so you might find a process still running after
    you try to terminate it. If this happens and you really need to kill a process,
    the most brutal way to terminate it is with the `KILL` signal. Unlike other signals,
    `KILL` cannot be ignored; in fact, the operating system doesn’t even give the
    process a chance. The kernel just terminates the process and forcibly removes
    it from memory. Use this method only as a last resort.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 内核在收到信号后会给大多数进程一个机会让它们自行清理（通过 *信号处理程序* 机制）。然而，有些进程可能会选择在响应信号时采取非终止的行动，卡在处理信号的过程中，或者根本忽视信号，因此你可能会发现某个进程在你尝试终止它后仍然在运行。如果发生这种情况，如果你真的需要杀死一个进程，最直接的方法是使用
    `KILL` 信号。与其他信号不同，`KILL` 无法被忽略；实际上，操作系统甚至不给进程一个机会。内核会直接终止进程并强制将其从内存中移除。只有在最后手段下才使用这种方法。
- en: You should not kill processes indiscriminately, especially if you don’t know
    what they’re doing. You may be shooting yourself in the foot.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该随意杀死进程，尤其是当你不知道它们在做什么时。你可能会自作自受。
- en: You may see other users entering numbers instead of names with `kill`—for example,
    `kill -9` instead of `kill -KILL`. This is because the kernel uses numbers to
    denote the different signals; you can use `kill` this way if you know the number
    of the signal that you want to send. Run `kill -l` to get a mapping of signal
    numbers to names.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到其他用户在使用 `kill` 时输入数字而不是名称——例如，输入 `kill -9` 而不是 `kill -KILL`。这是因为内核使用数字来表示不同的信号；如果你知道想要发送的信号的数字，可以使用
    `kill` 命令。运行 `kill -l` 可以查看信号数字与名称的对应关系。
- en: 2.16.3 Job Control
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.16.3 作业控制
- en: 'Shells support *job control*, a way to send `TSTP` (similar to `STOP`) and
    `CONT` signals to programs by using various keystrokes and commands. This allows
    you to suspend and switch between programs you’re using. For example, you can
    send a `TSTP` signal with ctrl-Z and then start the process again by entering
    `fg` (bring to foreground) or `bg` (move to background; see the next section).
    But despite its utility and the habits of many experienced users, job control
    is not necessary and can be confusing for beginners: It’s common for users to
    press ctrl-Z instead of ctrl-C, forget about what they were running, and eventually
    end up with numerous suspended processes.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 支持 *作业控制*，这是一种通过使用各种按键和命令向程序发送 `TSTP`（类似于 `STOP`）和 `CONT` 信号的方式。这允许你暂停并在正在使用的程序之间切换。例如，你可以通过
    ctrl-Z 发送 `TSTP` 信号，然后通过输入 `fg`（将其带到前台）或 `bg`（将其移到后台；见下一节）重新启动进程。但尽管作业控制具有实用性，并且许多经验丰富的用户习惯使用它，它对初学者来说并不必要，甚至可能会令人困惑：用户常常会按错键，按下
    ctrl-Z 而不是 ctrl-C，忘记自己正在运行什么程序，最终导致有大量暂停的进程。
- en: If you want to run multiple programs, run each in a separate terminal window,
    put noninteractive processes in the background (as explained in the next section),
    and learn to use the `screen` and `tmux` utilities.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想运行多个程序，可以将每个程序运行在单独的终端窗口中，将非交互式进程放到后台（如下一节所述），并学习使用 `screen` 和 `tmux` 工具。
- en: 2.16.4 Background Processes
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.16.4 后台进程
- en: 'Normally, when you run a Unix command from the shell, you don’t get the shell
    prompt back until the program finishes executing. However, you can detach a process
    from the shell and put it in the “background” with the ampersand (`&`); this gives
    you the prompt back. For example, if you have a large file that you need to decompress
    with `gunzip` (you’ll see this in Section 2.18), and you want to do some other
    stuff while it’s running, run a command like this one:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你从 shell 执行 Unix 命令时，直到程序执行完成，你才会得到 shell 提示符。然而，你可以通过使用符号 ampersand (`&`)
    将进程从 shell 中分离并将其置于“后台”；这样可以立即返回提示符。例如，如果你有一个需要用 `gunzip` 解压的大文件（你将在 2.18 节看到这个），并且希望在运行过程中做其他事情，可以像这样运行命令：
- en: '[PRE47]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The shell should respond by printing the PID of the new background process,
    and the prompt should return immediately so that you can continue working. If
    the process takes a very long time, it can even continue to run after you log
    out, which comes in particularly handy if you have to run a program that does
    a lot of number crunching. If the process finishes before you log out or close
    the terminal window, the shell usually notifies you, depending on your setup.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: shell应该通过打印新后台进程的PID来响应，提示符应立即返回，以便你可以继续工作。如果进程需要很长时间，它甚至可以在你注销后继续运行，这在运行需要大量计算的程序时特别有用。如果进程在你注销或关闭终端窗口之前完成，shell通常会根据你的设置通知你。
- en: The dark side of running background processes is that they may expect to work
    with the standard input (or worse, read directly from the terminal). If a program
    tries to read something from the standard input when it’s in the background, it
    can freeze (try `fg` to bring it back) or terminate. Also, if the program writes
    to the standard output or standard error, the output can appear in the terminal
    window with no regard for anything else running there, meaning that you can get
    unexpected output when you’re working on something else.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后台进程的黑暗面在于，它们可能期望与标准输入进行交互（或者更糟糕的是，直接从终端读取）。如果一个程序在后台运行时试图从标准输入读取数据，它可能会冻结（可以尝试`fg`将其恢复）或终止。此外，如果程序向标准输出或标准错误输出写入数据，输出可能会直接出现在终端窗口中，而不会考虑任何其他正在运行的进程，这意味着当你在做其他事情时，可能会出现意外的输出。
- en: The best way to make sure that a background process doesn’t bother you is to
    redirect its output (and possibly input) as described in Section 2.14.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 确保后台进程不干扰你的最佳方法是重定向它的输出（以及可能的输入），如第2.14节所述。
- en: If spurious output from background processes gets in your way, learn how to
    redraw the content of your terminal window. The `bash` shell and most full-screen
    interactive programs support ctrl-L to redraw the entire screen. If a program
    is reading from the standard input, ctrl-R usually redraws the current line, but
    pressing the wrong sequence at the wrong time can leave you in an even worse situation
    than before. For example, entering ctrl-R at the `bash` prompt puts you in reverse
    isearch mode (press esc to exit).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果后台进程的多余输出妨碍了你的工作，学习如何重新绘制终端窗口的内容。`bash` shell和大多数全屏交互程序都支持ctrl-L来重新绘制整个屏幕。如果程序正在从标准输入读取数据，ctrl-R通常会重新绘制当前行，但在错误的时机按下错误的组合键可能会让你陷入比之前更糟的情况。例如，在`bash`提示符下输入ctrl-R会进入反向搜索模式（按esc退出）。
- en: 2.17 File Modes and Permissions
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.17 文件模式和权限
- en: 'Every Unix file has a set of *permissions* that determine whether you can read,
    write, or run the file. Running `ls -l` displays the permissions. Here’s an example
    of such a display:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Unix文件都有一组*权限*，决定你是否可以读取、写入或执行该文件。运行`ls -l`可以显示权限。以下是此类显示的示例：
- en: '[PRE48]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The file’s *mode* 1 represents the file’s permissions and some extra information.
    There are four parts to the mode, as illustrated in [Figure 2-1](#figure2-1).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的*模式*表示文件的权限和一些附加信息。模式有四个部分，如[图2-1](#figure2-1)所示。
- en: '![f02001](image_fi/500402c02/f02001.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![f02001](image_fi/500402c02/f02001.png)'
- en: 'Figure 2-1: The pieces of a file mode'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-1：文件模式的组成部分
- en: The first character of the mode is the *file type*. A dash (`-`) in this position,
    as in the example, denotes a *regular* file, meaning that there’s nothing special
    about the file; it’s just binary or text data. This is by far the most common
    kind of file. Directories are also common and are indicated by a `d` in the file
    type slot. (Section 3.1 lists the remaining file types.)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 模式的第一个字符是*文件类型*。如示例中所示，该位置的破折号（`-`）表示一个*常规*文件，这意味着文件没有特别之处，它仅包含二进制或文本数据。这是最常见的文件类型。目录也是常见的，它们通过文件类型位置的`d`来表示。（第3.1节列出了其他文件类型。）
- en: 'The rest of a file’s mode contains the permissions, which break down into three
    sets: *user*, *group*, and *other*, in that order. For example, the `rw-` characters
    in the example are the user permissions, the `r--` characters that follow are
    the group permissions, and the final `r--` characters are the other permissions.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 文件模式的其余部分包含权限，分为三组：*用户*、*组*和*其他*，按此顺序。例如，示例中的`rw-`字符是用户权限，接下来的`r--`字符是组权限，最后的`r--`字符是其他权限。
- en: 'Each permission set can contain four basic representations:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 每个权限集可以包含四种基本表示形式：
- en: '`r` means that the file is readable.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`表示该文件是可读的。'
- en: '`w` means that the file is writable.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`表示该文件是可写的。'
- en: '`x` means that the file is executable (you can run it as a program).'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`表示该文件是可执行的（您可以将其作为程序运行）。'
- en: '`-` means “nothing” (more specifically, the permission for that slot in the
    set has not been granted).'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`表示“无”（更具体地说，该位置的权限尚未授予）。'
- en: The user permissions (the first set) pertain to the user who owns the file.
    In the preceding example, that’s `juser`. The second set, group permissions, are
    for the file’s group (`somegroup` in the example). Any user in that group can
    take advantage of these permissions. (Use the `groups` command to see what group
    you’re in, and see Section 7.3.5 for more information.)
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 用户权限（第一组）与拥有文件的用户相关。在前面的示例中，用户是`juser`。第二组是组权限，适用于文件的组（示例中的`somegroup`）。该组中的任何用户都可以使用这些权限。（使用`groups`命令查看您所在的组，并参阅第7.3.5节了解更多信息。）
- en: Everyone else on the system has access according to the third set, the other
    permissions, which are sometimes called *world* permissions.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中的其他所有人根据第三组权限——其他权限，通常称为*全体*权限——进行访问。
- en: Some executable files have an `s` in the user permissions listing instead of
    an `x`. This indicates that the executable is *setuid*, meaning that when you
    execute the program, it runs as though the file owner is the user instead of you.
    Many programs use this setuid bit to run as root in order to get the privileges
    they need to change system files. One example is the `passwd` program, which needs
    to change the */etc/passwd* file.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可执行文件在用户权限列表中显示`s`而不是`x`。这表示该可执行文件是*setuid*，意味着当您执行程序时，它将以文件所有者的身份运行，而不是以您自己的身份。许多程序使用setuid位以root身份运行，以便获得更改系统文件所需的权限。一个例子是`passwd`程序，它需要更改*/etc/passwd*文件。
- en: 2.17.1 Modifying Permissions
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.17.1 修改权限
- en: 'To change permissions on a file or directory, use the `chmod` command. First,
    pick the set of permissions that you want to change, and then pick the bit to
    change. For example, to add group (`g`) and world (`o`, for “other”) read (`r`)
    permissions to `file`, you could run these two commands:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改文件或目录的权限，请使用`chmod`命令。首先，选择您要更改的权限集，然后选择要更改的位。例如，要为`file`添加组（`g`）和其他（`o`）用户的读（`r`）权限，您可以执行以下两个命令：
- en: '[PRE49]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Or you could do it all in one shot:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您也可以一次性完成所有操作：
- en: '[PRE50]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: To remove these permissions, use `go-r` instead of `go+r`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除这些权限，使用`go-r`代替`go+r`。
- en: 'You may sometimes see people changing permissions with numbers, for example:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您会看到人们使用数字来更改权限，例如：
- en: '[PRE51]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is called an *absolute* change because it sets *all* permission bits at
    once. To understand how this works, you need to know how to represent the permission
    bits in octal form (each numeral represents a number in base 8, 0 through 7, and
    corresponds to a permission set). See the chmod(1) manual page or info manual
    for more.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这称为*绝对*更改，因为它一次性设置*所有*的权限位。要理解这如何工作，您需要知道如何以八进制形式表示权限位（每个数字表示一个8进制数，范围从0到7，并对应一个权限集）。更多内容请参阅chmod(1)手册页或info手册。
- en: You don’t really need to know how to construct absolute modes if you prefer
    to use them; just memorize the modes that you use most often. [Table 2-4](#table2-4)
    lists the most common ones.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢使用绝对模式，实际上并不需要知道如何构建它们；只需记住您最常用的模式。[表2-4](#table2-4)列出了最常见的几种。
- en: 'Table 2-4: Absolute Permission Modes'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-4：绝对权限模式
- en: '| **Mode** | **Meaning** | **Used for** |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | **含义** | **用途** |'
- en: '| --- | --- | --- |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `644` | user: read/write; group, other: read | files |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `644` | 用户：读/写；组，其他：读 | 文件 |'
- en: '| `600` | user: read/write; group, other: none | files |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `600` | 用户：读/写；组，其他：无 | 文件 |'
- en: '| `755` | user: read/write/execute; group, other: read/execute | directories,
    programs |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `755` | 用户：读/写/执行；组，其他：读/执行 | 目录，程序 |'
- en: '| `700` | user: read/write/execute; group, other: none | directories, programs
    |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `700` | 用户：读/写/执行；组，其他：无 | 目录，程序 |'
- en: '| `711` | user: read/write/execute; group, other: execute | directories |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| `711` | 用户：读/写/执行；组，其他：执行 | 目录 |'
- en: Directories also have permissions. You can list the contents of a directory
    if it’s readable, but you can only access a file in a directory if the directory
    is executable. You need both in most cases; one common mistake people make when
    setting the permissions of directories is to accidentally remove the execute permission
    when using absolute modes.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 目录也有权限。如果目录可读，您可以列出其内容，但只有当目录是可执行的，您才能访问目录中的文件。在大多数情况下，您需要同时具备这两项；设置目录权限时，人们常犯的一个错误是使用绝对模式时不小心去掉了执行权限。
- en: Finally, you can specify a set of default permissions with the `umask` shell
    command, which applies a predefined set of permissions to any new file you create.
    In general, use `umask 022` if you want everyone to be able to see all of the
    files and directories that you create, and use `umask 077` if you don’t. If you
    want to make your desired permissions mask apply to new windows and later sessions,
    you need to put the `umask` command with the desired mode in one of your startup
    files, as discussed in Chapter 13.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用`umask` shell命令来指定一组默认权限，它会将一组预定义的权限应用于你创建的任何新文件。一般来说，如果你希望所有人都能查看你创建的所有文件和目录，请使用`umask
    022`，如果你不希望这样，则使用`umask 077`。如果你希望使你的所需权限掩码适用于新窗口和后续会话，你需要将`umask`命令与所需的模式放入启动文件中，正如第13章所讨论的那样。
- en: 2.17.2 Working with Symbolic Links
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.17.2 使用符号链接
- en: A *symbolic link* is a file that points to another file or a directory, effectively
    creating an alias (like a shortcut in Windows). Symbolic links offer quick access
    to obscure directory paths.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '*符号链接*是一个指向另一个文件或目录的文件，有效地创建了一个别名（类似于Windows中的快捷方式）。符号链接提供了对隐蔽目录路径的快速访问。'
- en: 'In a long directory listing, symbolic links look like this (notice the `l`
    as the file type in the file mode):'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在长目录列表中，符号链接的显示如下（请注意文件模式中的`l`，它表示文件类型）：
- en: '[PRE52]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If you try to access *somedir* in this directory, the system gives you */home/origdir*
    instead. Symbolic links are simply filenames that point to other names. Their
    names and the paths to which they point don’t have to mean anything. In the preceding
    example, */home/origdir* doesn’t need to exist.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试访问此目录中的*somedir*，系统会给你返回*/home/origdir*。符号链接只是指向其他名称的文件名。它们的名称和指向的路径不需要有任何实际意义。在前面的例子中，*/home/origdir*不需要存在。
- en: In fact, if */home/origdir* does not exist, any program that accesses *somedir*
    returns an error reporting that *somedir* doesn’t exist (except for `ls somedir`,
    a command that stupidly informs you that *somedir* is *somedir*). This can be
    baffling because you can see something named *somedir* right in front of your
    eyes.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果*/home/origdir*不存在，任何访问*somedir*的程序都会返回一个错误，报告*somedir*不存在（除了`ls somedir`，这个命令愚蠢地告诉你*somedir*就是*somedir*）。这可能会让人困惑，因为你眼前就能看到一个名为*somedir*的东西。
- en: This is not the only way that symbolic links can be confusing. Another problem
    is that you can’t identify the characteristics of a link target just by looking
    at the name of the link; you must follow the link to see if it goes to a file
    or directory. Your system may also have links that point to other links, which
    are called *chained symbolic links* and can be a nuisance when you’re trying to
    track them down.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是符号链接可能令人困惑的唯一方式。另一个问题是，你不能仅凭链接的名称就识别链接目标的特征；你必须跟踪该链接以查看它是指向文件还是目录。你的系统中可能还有指向其他链接的链接，这些被称为*链式符号链接*，在你试图追踪它们时可能会很麻烦。
- en: 'To create a symbolic link from *target* to *linkname*, use `ln -s` as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 要从*target*创建一个指向*linkname*的符号链接，请使用`ln -s`，如下所示：
- en: '[PRE53]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `linkname` argument is the name of the symbolic link, the `target` argument
    is the path of the file or directory that the link *points* to, and the `-s` flag
    specifies a symbolic link (see the warning that follows).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`linkname`参数是符号链接的名称，`target`参数是链接*指向*的文件或目录的路径，`-s`标志指定这是一个符号链接（请参阅后面的警告）。'
- en: When making a symbolic link, check the command twice before you run it, because
    several things can go wrong. For example, if you accidentally reverse the order
    of the arguments (`ln -s` `linkname target`), you’re in for some fun if *linkname*
    is a directory that already exists. If this is the case (and it quite often is),
    `ln` creates a link named *target* inside *linkname,* and the link will point
    to itself unless *linkname* is a full path. If something goes wrong when you create
    a symbolic link to a directory, check that directory for errant symbolic links
    and remove them.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 创建符号链接时，请在运行命令之前检查两遍，因为可能会出现几种错误情况。例如，如果你不小心反转了参数的顺序（`ln -s` `linkname target`），如果*linkname*是一个已经存在的目录，你将面临一些麻烦。如果是这种情况（而且这种情况非常常见），`ln`会在*linkname*目录中创建一个名为*target*的链接，而该链接将指向它自己，除非*linkname*是一个完整路径。如果创建符号链接到目录时出现问题，请检查该目录是否有错误的符号链接并将其删除。
- en: Symbolic links can also cause headaches when you don’t know that they exist.
    For example, you can easily edit what you think is a copy of a file but is actually
    a symbolic link to the original.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不知道符号链接存在时，它们也会引起头疼。例如，你可能会不小心编辑一个你认为是文件副本的文件，但它实际上是指向原始文件的符号链接。
- en: With all these warnings about symbolic links, you might be wondering why anyone
    would want to use them. As it turns out, their pitfalls are significantly outweighed
    by the power they provide for organizing files and their ability to easily patch
    up small problems. One common use case is when a program expects to find a particular
    file or directory that already exists somewhere else on your system. You don’t
    want to make a copy, and if you can’t change the program, you can just create
    a symbolic link from it to the actual file or directory location.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了关于符号链接的所有警告之后，你可能会好奇为什么有人会想使用它们。事实证明，它们的缺陷远远被它们在文件组织方面提供的强大功能以及轻松解决小问题的能力所弥补。一个常见的使用场景是，当程序期望在你的系统中某个地方找到特定的文件或目录时，你不想复制它，如果无法更改程序，你可以直接创建一个符号链接，将它指向实际的文件或目录位置。
- en: 2.18 Archiving and Compressing Files
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.18 文件归档与压缩
- en: Now that you’ve learned about files, permissions, and possible errors, you need
    to master `gzip` and `tar`, two common utilities for compressing and bundling
    files and directories.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了文件、权限和可能的错误，接下来需要掌握`gzip`和`tar`这两个常用工具，用于压缩和打包文件与目录。
- en: 2.18.1 gzip
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.18.1 gzip
- en: The program `gzip` (GNU Zip) is one of the current standard Unix compression
    programs. A file that ends with *.gz* is a GNU Zip archive. Use `gunzip` `file``.gz`
    to uncompress *<file>.gz* and remove the suffix; to compress the file again, use
    `gzip` `file`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 程序`gzip`（GNU Zip）是当前标准的Unix压缩程序之一。以*.gz*结尾的文件是GNU Zip归档文件。使用`gunzip` `file``.gz`来解压*<file>.gz*并移除后缀；要重新压缩文件，请使用`gzip`
    `file`。
- en: 2.18.2 tar
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.18.2 tar
- en: 'Unlike the ZIP programs for other operating systems, `gzip` does not create
    archives of files; that is, it doesn’t pack multiple files and directories into
    a single file. To create an archive, use `tar` instead:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他操作系统的ZIP程序不同，`gzip`并不会创建文件归档；也就是说，它不会将多个文件和目录打包成一个文件。要创建归档，请改用`tar`：
- en: '[PRE54]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Archives created by `tar` usually have a *.tar* suffix (this is by convention;
    it isn’t required). For example, in the previous command, `file1`, `file2`, and
    so on are the names of the files and directories that you wish to archive in *<archive>.tar*.
    The `c` flag activates *create mode*. The `v` and `f` flags have more specific
    roles.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`tar`创建的归档文件通常以*.tar*为后缀（这是惯例，并非强制要求）。例如，在之前的命令中，`file1`、`file2`等是你希望归档的文件和目录的名称，存储为*<archive>.tar*。`c`标志启用*创建模式*。`v`和`f`标志有更具体的作用。'
- en: The `v` flag activates verbose diagnostic output, causing `tar` to print the
    names of the files and directories in the archive when it encounters them. Adding
    another `v` causes `tar` to print details such as file size and permissions. If
    you don’t want `tar` to tell you what it’s doing, omit the `v` flag.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`v`标志启用详细诊断输出，当`tar`遇到文件和目录时，会打印它们的名称。再加一个`v`，`tar`会打印如文件大小和权限等详细信息。如果不想让`tar`告诉你它正在做什么，可以省略`v`标志。'
- en: The `f` flag denotes the file option. The next argument on the command line
    after the `f` flag must be the archive file for `tar` to create (in the preceding
    example, it is *<archive>.tar*). You *must* use this option followed by a filename
    at all times, except with tape drives. To use standard input or output, set the
    filename to a dash (`-`).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`f`标志表示文件选项。在`f`标志后面的命令行参数必须是`tar`将创建的归档文件（在之前的示例中，它是*<archive>.tar*）。你*必须*每次使用此选项并跟随一个文件名，除非使用磁带驱动器。要使用标准输入或输出，可以将文件名设置为破折号（`-`）。'
- en: Unpacking .tar Files
  id: totrans-385
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解包.tar文件
- en: 'To unpack a *.tar* file with `tar` use the `x` flag:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`tar`解包*.tar*文件，请使用`x`标志：
- en: '[PRE55]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this command, the `x` flag puts `tar` into *extract* (*unpack*) *mode*. You
    can extract individual parts of the archive by entering the names of the parts
    at the end of the command line, but you must know their exact names. (To find
    out for sure, see the table-of-contents mode described next.)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令中，`x`标志将`tar`设置为*提取*（*解包*）*模式*。你可以通过在命令行末尾输入归档部分的名称来提取单独的部分，但你必须知道它们的确切名称。（要确认名称，请参阅接下来介绍的目录列表模式。）
- en: Using Table-of-Contents Mode
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用目录列表模式
- en: Before unpacking, it’s usually a good idea to check the contents of a *.tar*
    file with the *table-of-contents mode* by using the `t` flag instead of the `x`
    flag. This mode verifies the archive’s basic integrity and prints the names of
    all files inside. If you don’t test an archive before unpacking it, you can end
    up dumping a huge mess of files into the current directory, which can be really
    difficult to clean up.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在解包之前，通常最好使用*目录内容模式*来检查*.tar*文件的内容，通过使用`t`标志而不是`x`标志。此模式验证归档的基本完整性，并列出归档中所有文件的名称。如果你在解包前没有测试归档，可能会把大量文件乱七八糟地解压到当前目录中，这样清理起来会非常困难。
- en: When you check an archive with the `t` mode, verify that everything is in a
    rational directory structure; that is, all file pathnames in the archive should
    start with the same directory. If you’re unsure, create a temporary directory,
    change to it, and then extract. (You can always use `mv * ..` if the archive didn’t
    create a mess.)
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`t`模式检查归档时，确保所有内容都位于合理的目录结构中；也就是说，归档中的所有文件路径名应该都以相同的目录开头。如果不确定，可以创建一个临时目录，切换到该目录，然后再进行解压。（如果归档没有搞乱文件结构，你可以随时使用`mv
    * ..`来移动文件。）
- en: When unpacking, consider using the `p` option to preserve permissions. Use this
    in extract mode to override your `umask` and get the exact permissions specified
    in the archive. The `p` option is the default when you’re working as the superuser.
    If you’re having trouble with permissions and ownership when unpacking an archive
    as the superuser, make sure that you’re waiting until the command terminates and
    you get the shell prompt back. Although you may only want to extract a small part
    of an archive, `tar` must run through the whole thing, and you must not interrupt
    the process because it sets the permissions only *after* checking the entire archive.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 解包时，可以考虑使用`p`选项来保留权限。在提取模式下使用此选项，以覆盖你的`umask`，并获得归档中指定的精确权限。对于超级用户来说，`p`选项是默认选项。如果你在以超级用户身份解包归档时遇到权限和所有权问题，确保等到命令执行完毕并返回到命令行提示符。尽管你可能只想提取归档的一小部分，但`tar`必须运行整个归档过程，你不能中断它，因为它只有在检查完整个归档后才会设置权限。
- en: Commit *all* of the `tar` options and modes in this section to memory. If you’re
    having trouble, make some flash cards. This may sound like grade school, but it’s
    very important to avoid careless mistakes with this command.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 将本节中*所有*的`tar`选项和模式都记住。如果你有困难，可以制作一些记忆卡片。听起来可能像是小学的做法，但这对避免在使用此命令时犯粗心错误非常重要。
- en: 2.18.3 Compressed Archives (.tar.gz)
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.18.3 压缩归档（.tar.gz）
- en: 'Many beginners find it confusing that archives are normally found compressed,
    with filenames ending in *.tar.gz*. To unpack a compressed archive, work from
    the right side to the left; get rid of the *.gz* first and then worry about the
    *.tar*. For example, these two commands decompress and unpack *<file>.tar.gz*:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 许多初学者发现压缩归档文件（以*.tar.gz*结尾）很容易混淆。要解压一个压缩归档，从右到左操作；先去掉*.gz*，然后再处理*.tar*。例如，这两个命令解压和解包*<file>.tar.gz*：
- en: '[PRE56]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'When starting out, it’s fine to do this one step at a time, first running `gunzip`
    to decompress and then `tar` to verify and unpack. To create a compressed archive,
    do the reverse: run `tar` first and `gzip` second. Do this frequently enough,
    and you’ll soon memorize how the archiving and compression process works. But
    even if you don’t do it all that often, you can see how tiresome all of the typing
    can become and you’ll start looking for shortcuts. Let’s take a look at those
    now.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，可以一步步地进行，先运行`gunzip`来解压，然后再运行`tar`来验证和解包。要创建压缩归档文件，只需反过来做：先运行`tar`，再运行`gzip`。经常这样做，你很快就会记住归档和压缩的过程是如何工作的。但即便你不常这样做，也能体会到所有输入的命令会变得多么繁琐，你会开始寻找快捷方式。让我们现在来看一下这些方法。
- en: 2.18.4 zcat
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.18.4 zcat
- en: 'The method just shown isn’t the fastest or most efficient way to invoke `tar`
    on a compressed archive, and it wastes disk space and kernel I/O time. A better
    way is to combine archival and compression functions with a pipeline. For example,
    this command pipeline unpacks *<file>.tar.gz*:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才展示的方法不是调用`tar`解压压缩归档的最快或最高效的方式，它浪费了磁盘空间和内核I/O时间。一种更好的方法是将归档和压缩功能结合在一个管道中。例如，这个命令管道解压*<file>.tar.gz*：
- en: '[PRE57]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `zcat` command is the same as `gunzip -dc`. The `-d` option decompresses
    and the `-c` option sends the result to standard output (in this case, to the
    `tar` command).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`zcat`命令与`gunzip -dc`相同。`-d`选项用于解压，`-c`选项将结果发送到标准输出（在此情况下为`tar`命令）。'
- en: 'Because it’s so common to use `zcat`, the version of `tar` that comes with
    Linux has a shortcut. You can use `z` as an option to automatically invoke `gzip`
    on the archive; this works both for extracting an archive (with the `x` or `t`
    modes in `tar`) and creating one (with `c`). For example, use the following to
    verify a compressed archive:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用`zcat`非常常见，Linux 中随附的`tar`版本提供了一个快捷方式。你可以使用`z`作为选项，自动在归档文件上调用`gzip`；这适用于提取归档（使用`x`或`t`模式的`tar`）和创建归档（使用`c`模式）。例如，使用以下命令来验证一个压缩的归档：
- en: '[PRE58]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: However, try to remember that you’re actually performing two steps when taking
    the shortcut.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，当你使用快捷方式时，实际上是在执行两个步骤。
- en: 2.18.5 Other Compression Utilities
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.18.5 其他压缩工具
- en: Two more compression programs are `xz` and `bzip2`, whose compressed files end
    with *.xz* and *.bz2*, respectively. While marginally slower than `gzip`, these
    often compact text files a little more. The decompressing programs to use are
    `unxz` and `bunzip2`, and the options of both are close enough to their `gzip`
    counterparts that you don’t need to learn anything new.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个压缩程序是`xz`和`bzip2`，它们的压缩文件分别以*.xz*和*.bz2*结尾。虽然它们比`gzip`稍慢，但通常能更紧凑地压缩文本文件。解压缩程序是`unxz`和`bunzip2`，它们的选项与`gzip`相似，所以你不需要学习新的命令。
- en: Most Linux distributions come with `zip` and `unzip` programs that are compatible
    with the ZIP archives on Windows systems. They work on the usual *.zip* files
    as well as self-extracting archives ending in *.exe*. But if you encounter a file
    that ends in *.Z*, you have found a relic created by the `compress` program, which
    was once the Unix standard. The `gunzip` program can unpack these files, but `gzip`
    won’t create them.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Linux 发行版都自带与 Windows 系统上的 ZIP 压缩文件兼容的`zip`和`unzip`程序。它们可以处理常见的*.zip*文件，以及以*.exe*结尾的自解压档案。但如果遇到以*.Z*结尾的文件，那是由曾经是
    Unix 标准的`compress`程序创建的遗物。`gunzip`程序可以解压这些文件，但`gzip`不会创建它们。
- en: 2.19 Linux Directory Hierarchy Essentials
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.19 Linux 目录层次结构要点
- en: Now that you know how to examine files, change directories, and read manual
    pages, you’re ready to start exploring your system files and directories. The
    details of the Linux directory structure are outlined in the Filesystem Hierarchy
    Standard, or FHS (*https://refspecs.linuxfoundation.org/fhs.shtml*), but a brief
    walkthrough should suffice for now.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何检查文件、切换目录和阅读手册页，你可以开始探索系统文件和目录了。Linux 目录结构的详细信息在文件系统层次标准（Filesystem
    Hierarchy Standard，简称 FHS）中有说明，网址为*https://refspecs.linuxfoundation.org/fhs.shtml*，但现在简要的介绍就足够了。
- en: '[Figure 2-2](#figure2-2) offers a simplified overview of the hierarchy, showing
    some of the directories under */*, */usr*, and */var*. Notice that the directory
    structure under */usr* contains some of the same directory names as */*.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-2](#figure2-2)提供了简化的层次结构概览，展示了*/*、*/usr*和*/var*下的一些目录。注意，*/usr*下的目录结构包含了一些与*/*相同的目录名。'
- en: '![f02002](image_fi/500402c02/f02002.png)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![f02002](image_fi/500402c02/f02002.png)'
- en: 'Figure 2-2: Linux directory hierarchy'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-2：Linux 目录层次结构
- en: 'Here are the most important subdirectories in root:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这是根目录下最重要的子目录：
- en: '***/bin*** Contains ready-to-run programs (also known as *executables*), including
    most of the basic Unix commands such as `ls` and `cp`. Most of the programs in
    */bin* are in binary format, having been created by a C compiler, but some are
    shell scripts in modern systems.'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***/bin*** 包含准备运行的程序（也称为*可执行文件*），包括大多数基本的 Unix 命令，如`ls`和`cp`。*/bin*中的大多数程序都是二进制格式的，由
    C 编译器创建，但在现代系统中，也有一些是 shell 脚本。'
- en: '***/dev*** Contains device files. You’ll learn more about these in Chapter
    3.'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***/dev*** 包含设备文件。你将在第 3 章学习更多关于这些文件的内容。'
- en: '***/etc*** This core system configuration directory (pronounced *EHT-see*)
    contains the user password, boot, device, networking, and other setup files.'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***/etc*** 该核心系统配置目录（发音为*EHT-see*）包含用户密码、启动、设备、网络和其他设置文件。'
- en: '***/home*** Holds home (personal) directories for regular users. Most Unix
    installations conform to this standard.'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***/home*** 包含普通用户的个人目录。大多数 Unix 安装都遵循这个标准。'
- en: '***/lib*** An abbreviation for *library*, this directory holds library files
    containing code that executables can use. There are two types of libraries: static
    and shared. The */lib* directory should contain only shared libraries, but other
    lib directories, such as */usr/lib,* contain both varieties as well as other auxiliary
    files. (We’ll discuss shared libraries in more detail in Chapter 15.)'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***/lib*** *library*的缩写，此目录存放包含可执行程序可使用代码的库文件。有两种类型的库：静态库和共享库。*/lib*目录应仅包含共享库，但其他lib目录（如*/usr/lib*）包含这两种库以及其他辅助文件。（我们将在第15章详细讨论共享库。）'
- en: '***/proc*** Provides system statistics through a browsable directory-and-file
    interface. Much of the */proc* subdirectory structure on Linux is unique, but
    many other Unix variants have similar features. The */proc* directory contains
    information about currently running processes as well as some kernel parameters.'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***/proc*** 通过可浏览的目录和文件接口提供系统统计信息。Linux上许多*/proc*子目录的结构是独特的，但许多其他Unix变种也具有类似的功能。*/proc*目录包含有关当前正在运行的进程以及一些内核参数的信息。'
- en: '***/run*** Contains runtime data specific to the system, including certain
    process IDs, socket files, status records, and, in many cases, system logging.
    This is a relatively recent addition to the root directory; in older systems,
    you can find it in */var/run*. On newer systems, */var/run* is a symbolic link
    to */run*.'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***/run*** 包含特定于系统的运行时数据，包括某些进程ID、套接字文件、状态记录，以及在许多情况下，系统日志。这是根目录的一个相对较新的添加项；在较老的系统中，你可以在*/var/run*找到它。在新系统中，*/var/run*是指向*/run*的符号链接。'
- en: '***/sys*** This directory is similar to */proc* in that it provides a device
    and system interface. You’ll read more about */sys* in Chapter 3.'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***/sys*** 此目录与*/proc*类似，提供设备和系统接口。你将在第3章中了解更多关于*/sys*的内容。'
- en: '***/sbin*** The place for system executables. Programs in /*sbin* directories
    relate to system management, so regular users usually do not have /*sbin* components
    in their command paths. Many of the utilities found here don’t work if not run
    as root.'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***/sbin*** 系统可执行文件所在的地方。/*sbin*目录中的程序与系统管理相关，因此普通用户通常不会在其命令路径中包含/*sbin*组件。这里找到的许多实用程序如果不是以root身份运行，则无法工作。'
- en: '***/tmp*** A storage area for smaller, temporary files that you don’t care
    much about. Any user may read to and write from */tmp*, but the user may not have
    permission to access another user’s files there. Many programs use this directory
    as a workspace. If something is extremely important, don’t put it in */tmp* because
    most distributions clear */tmp* when the machine boots and some even remove its
    old files periodically. Also, don’t let */tmp* fill up with garbage because its
    space is usually shared with something critical (the rest of */*, for example).'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***/tmp*** 一个用于存储较小临时文件的区域，这些文件你不太在意。任何用户都可以读写*/tmp*，但用户可能没有权限访问其他用户在那里存放的文件。许多程序将此目录用作工作空间。如果某些东西非常重要，不要将其放在*/tmp*中，因为大多数发行版会在机器启动时清空*/tmp*，有些甚至会定期删除其中的旧文件。此外，不要让*/tmp*堆满垃圾文件，因为它的空间通常与某些关键部分共享（例如根目录的其余部分）。'
- en: '***/usr*** Although pronounced “user,” this subdirectory has no user files.
    Instead, it contains a large directory hierarchy, including the bulk of the Linux
    system. Many of the directory names in */usr* are the same as those in the root
    directory (like */usr/bin* and */usr/lib*), and they hold the same type of files.
    (The reason that the root directory does not contain the complete system is primarily
    historic—in the past, it was to keep space requirements low for the root.)'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***/usr*** 尽管发音为“user”，但这个子目录并不包含用户文件。相反，它包含一个庞大的目录层次结构，包括Linux系统的大部分内容。*/usr*中的许多目录名称与根目录中的相同（如*/usr/bin*和*/usr/lib*），并且它们包含相同类型的文件。（根目录不包含完整系统的原因主要是历史上的考虑——过去这样做是为了降低根目录的空间需求。）'
- en: '***/var*** The variable subdirectory, where programs record information that
    can change over the course of time. System logging, user tracking, caches, and
    other files that system programs create and manage are here. (You’ll notice a
    */var/tmp* directory here, but the system doesn’t wipe it on boot.)'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***/var*** 变量子目录，用于记录可能随时间变化的程序信息。系统日志、用户跟踪、缓存以及其他系统程序创建和管理的文件都在这里。（你会注意到这里有一个*/var/tmp*目录，但系统在启动时不会清空它。）'
- en: 2.19.1 Other Root Subdirectories
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.19.1 其他根子目录
- en: 'There are a few other interesting subdirectories in the root directory:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 根目录下还有一些其他有趣的子目录：
- en: '***/boot*** Contains kernel boot loader files. These files pertain only to
    the very first stage of the Linux startup procedure, so you won’t find information
    about how Linux starts up its services in this directory. See Chapter 5 for more
    about this.'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***/boot*** 包含内核启动加载程序文件。这些文件仅与Linux启动过程的第一阶段有关，因此你不会在此目录中找到有关Linux如何启动其服务的信息。关于此内容，请参见第5章。'
- en: '***/media*** A base attachment point for removable media such as flash drives
    that is found in many distributions.'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***/media*** 一个用于可移动媒体（如闪存驱动器）的基础挂载点，许多发行版中都有此目录。'
- en: '***/opt*** This may contain additional third-party software. Many systems don’t
    use */opt*.'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***/opt*** 此目录可能包含额外的第三方软件。许多系统不使用*/opt*。'
- en: 2.19.2 The /usr Directory
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.19.2 /usr目录
- en: 'The */usr* directory may look relatively clean at first glance, but a quick
    look at */usr/bin* and */usr/lib* reveals that there’s a lot here; */usr* is where
    most of the user-space programs and data reside. In addition to */usr/bin*, */usr/sbin*,
    and */usr/lib*, */usr* contains the following:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '*/usr*目录乍一看可能比较干净，但快速查看*/usr/bin*和*/usr/lib*，就会发现这里有很多内容；*/usr*是大多数用户空间程序和数据所在的地方。除了*/usr/bin*、*/usr/sbin*和*/usr/lib*之外，*/usr*还包含以下内容：'
- en: '***/include*** Holds header files used by the C compiler.'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***/include*** 包含C编译器使用的头文件。'
- en: '***/local*** Is where administrators can install their own software. Its structure
    should look like that of */* and */usr*.'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***/local*** 管理员可以在此安装自己的软件。其结构应类似于*/*和*/usr*。'
- en: '***/man*** Contains manual pages.'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***/man*** 包含手册页。'
- en: '***/share*** Contains files that should work on other kinds of Unix machines
    with no loss of functionality. These are usually auxiliary data files that programs
    and libraries read as necessary. In the past, networks of machines would share
    this directory from a file server, but today a *share* directory used in this
    manner is rare because there are no realistic space restraints for these kinds
    of files on contemporary systems. Instead, on Linux distributions, you’ll find
    /*man*, /*info*, and many other subdirectories here because it is an easily understood
    convention.'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***/share*** 包含应在其他类型的Unix机器上无功能损失地运行的文件。这些通常是程序和库根据需要读取的辅助数据文件。过去，机器网络会从文件服务器共享这个目录，但如今在现代系统上，使用这种方式的*share*目录已经很少见，因为这些类型的文件在现代系统上没有实际的空间限制。相反，在Linux发行版中，你会在此目录下找到/*man*、/*info*和许多其他子目录，因为这是一个易于理解的约定。'
- en: 2.19.3 Kernel Location
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.19.3 内核位置
- en: On Linux systems, the kernel is normally a binary file */vmlinuz* or */boot/vmlinuz*.
    A *boot loader* loads this file into memory and sets it in motion when the system
    boots. (You’ll find details on the boot loader in Chapter 5.)
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux系统中，内核通常是一个二进制文件*/vmlinuz*或*/boot/vmlinuz*。一个*启动加载程序*在系统启动时将这个文件加载到内存并启动它。（你将在第5章中找到关于启动加载程序的详细信息。）
- en: Once the boot loader starts the kernel, the main kernel file is no longer used
    by the running system. However, you’ll find many modules that the kernel loads
    and unloads on demand during the course of normal system operation. Called *loadable
    kernel modules*, they are located under */lib/modules*.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动加载程序启动了内核，主内核文件将不再被正在运行的系统使用。然而，你会发现许多内核模块，它们在正常系统操作过程中按需加载和卸载。被称为*可加载内核模块*，它们位于*/lib/modules*下。
- en: 2.20 Running Commands as the Superuser
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.20 以超级用户身份运行命令
- en: 'Before going any further, you should learn how to run commands as the superuser.
    You may be tempted to start a root shell, but doing so has many disadvantages:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你应该学会如何以超级用户身份运行命令。你可能会想要启动一个root shell，但这样做有许多缺点：
- en: You have no record of system-altering commands.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你没有系统更改命令的记录。
- en: You have no record of the users who performed system-altering commands.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你没有记录执行系统更改命令的用户信息。
- en: You don’t have access to your normal shell environment.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你无法访问你的正常shell环境。
- en: You have to enter the root password (if you have one).
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要输入根密码（如果你有的话）。
- en: 2.20.1 sudo
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.20.1 sudo
- en: 'Most distributions use a package called `sudo` to allow administrators to run
    commands as root when they are logged in as themselves. For example, in Chapter
    7, you’ll learn about using `vipw` to edit the */etc/passwd* file. You could do
    it like this:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数发行版使用一个名为`sudo`的程序，允许管理员在以自己身份登录时以root身份执行命令。例如，在第7章中，你将学习如何使用`vipw`编辑*/etc/passwd*文件。你可以这样做：
- en: '[PRE59]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: When you run this command, `sudo` logs this action with the syslog service under
    the local2 facility. You’ll also learn more about system logs in Chapter 7.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此命令时，`sudo`会通过syslog服务在local2设施下记录此操作。你还将在第7章中了解更多关于系统日志的内容。
- en: 2.20.2 /etc/sudoers
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.20.2 /etc/sudoers
- en: 'Of course, the system doesn’t let just *any* user run commands as the superuser;
    you must configure the privileged users in your */etc/sudoers* file. The `sudo`
    package has many options (that you’ll probably never use), which makes the syntax
    in */etc/sudoers* somewhat complicated. For example, this file gives `user1` and
    `user2` the power to run any command as root without having to enter a password:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，系统不会让*任何*用户都可以以超级用户身份执行命令；你必须在你的*/etc/sudoers*文件中配置特权用户。`sudo`包有许多选项（你可能永远不会使用），这使得*/etc/sudoers*中的语法有些复杂。例如，这个文件授予`user1`和`user2`执行任何命令作为root的权限，而不需要输入密码：
- en: '[PRE60]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The first line defines an `ADMINS` user alias with the two users, and the second
    line grants the privileges. The `ALL = NOPASSWD: ALL` part means that the users
    in the `ADMINS` alias can use `sudo` to execute commands as root. The second `ALL`
    means “any command.” The first `ALL` means “any host.” (If you have more than
    one machine, you can set different kinds of access for each machine or group of
    machines, but we won’t cover that feature.)'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '第一行定义了一个包含两个用户的`ADMINS`用户别名，第二行授予了权限。`ALL = NOPASSWD: ALL`部分意味着`ADMINS`别名中的用户可以使用`sudo`以root身份执行命令。第二个`ALL`意味着“任何命令”。第一个`ALL`意味着“任何主机”。（如果你有多台机器，可以为每台机器或机器组设置不同的访问权限，但我们在这里不会讲解这个功能。）'
- en: 'The `root ALL=(ALL) ALL` simply means that the superuser may also use `sudo`
    to run any command on any host. The extra `(ALL)` means that the superuser may
    also run commands as any other user. You can extend this privilege to the `ADMINS`
    users by adding `(ALL)` to the second */etc/sudoers* line, as shown here:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`root ALL=(ALL) ALL`的意思是超级用户也可以使用`sudo`在任何主机上运行任何命令。额外的`(ALL)`意味着超级用户也可以作为其他用户执行命令。你可以通过将`(ALL)`添加到第二行的*/etc/sudoers*中来将这个权限扩展给`ADMINS`用户，如下所示：'
- en: '[PRE61]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 2.20.3 sudo Logs
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.20.3 sudo 日志
- en: 'Although we’ll go into logs in more detail later in the book, you can find
    the `sudo` logs on most systems with this command:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们会在本书后面更详细地讲解日志，但你可以通过以下命令在大多数系统上找到`sudo`日志：
- en: '[PRE62]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: On older systems, you’ll need to look for a logfile in */var/log*, such as */var/log/auth.log*.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧系统上，你需要在*/var/log*中查找日志文件，如*/var/log/auth.log*。
- en: That’s it for `sudo` for now. If you need to use its more advanced features,
    see the sudoers(5) and sudo(8) manual pages. (The actual mechanics of user switching
    are covered in Chapter 7.)
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是目前关于`sudo`的内容。如果你需要使用它的更高级功能，请参阅sudoers(5)和sudo(8)手册页。（用户切换的实际机制将在第七章中介绍。）
- en: 2.21 Looking Forward
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.21 展望未来
- en: 'You should now know how to do the following at the command line: run programs,
    redirect output, interact with files and directories, view process listings, view
    manual pages, and generally make your way around the user space of a Linux system.
    You should also be able to run commands as the superuser. You may not yet know
    much about the internal details of user-space components or what goes on in the
    kernel, but with the basics of files and processes under your belt, you’re on
    your way. In the next few chapters, you’ll be working with both kernel and user-space
    system components using the command-line tools that you just learned.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该已经知道如何在命令行中执行以下操作：运行程序、重定向输出、与文件和目录交互、查看进程列表、查看手册页，并且大致了解如何在Linux系统的用户空间中操作。你也应该能够以超级用户身份运行命令。你可能还不了解用户空间组件的内部细节或内核中的操作，但掌握了文件和进程的基础，你已经在正确的道路上了。在接下来的几章中，你将使用刚刚学到的命令行工具，处理内核和用户空间系统组件。
