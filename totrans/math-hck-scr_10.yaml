- en: '**A**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Programming Challenge Hints**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Studying math involves learning and understanding mathematical concepts in class,
    using textbooks and worksheets. It can be a passive process, where you just try
    to absorb information. On the other hand, *doing* math involves actively applying
    concepts to solve problems and create new mathematical models. This process requires
    creativity and problem-solving skills, as well as the ability to think critically
    and logically.
  prefs: []
  type: TYPE_NORMAL
- en: Programming is an important part of doing math, as it lets you automate complex
    calculations and constructions in order to explore mathematical ideas in ways
    that would be impossible on paper or in your head. This book has been all about
    using Scratch to do math—writing algorithms and performing numerical computations—with
    the programming challenges being an invitation for you to “get your hands dirty”
    on some real problems. This chapter provides some comments and code snippets to
    help you solve those challenges.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 1: What Computers Think About Numbers](ch01.xhtml)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Challenge 1.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As a first step, you could make a list of the digits in the base *b* number
    with a loop like the one in [Figure A-1](app01.xhtml#chAfig1). Then, you could
    put the digits together in a string to make the answer look like a base *b* number
    with code like that in [Figure A-2](app01.xhtml#chAfig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg196_Image_242.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-1: Converting to base* b'
  prefs: []
  type: TYPE_NORMAL
- en: For base 11 or 12, check if `convert mod b` is `10` or `11` and, if so, substitute
    `T` or `E` before adding the result to the `digits` list.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg196_Image_243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-2: Joining the digits into a string*'
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 1.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure A-3](app01.xhtml#chAfig3) shows some code that works for base 11 or
    base 12\. You can add cases to it to support base 16.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg196_Image_244.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-3: Substituting letters for numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: When you go from binary to hexadecimal, each group of four binary digits (counting
    from the least significant, or rightmost, digit) is equivalent to a single hexadecimal
    digit. For example, 1011 in binary becomes E in hexadecimal.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 1.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can grow a list by adding new items to it. Suppose you’ve asked the user
    to specify a starting value for the list, what the change should be (stored in
    the variable `change`), and how long the list should be (stored in the variable
    `length`). [Figure A-4](app01.xhtml#chAfig4) shows some code to calculate the
    remaining values in the list based on exponential and linear growth. Each type
    of growth gets its own list.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg197_Image_245.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-4: Comparing exponential and linear growth*'
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 1.4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With linear growth it would take a hopelessly long time to count to Scratch’s
    absolute maximum number, but with exponential growth (see [Challenge 1.3](app01.xhtml#app01lev4))
    you can get there very quickly. By doubling, for example, it takes just 1,024
    steps. The largest number Scratch can represent is about 1.08 ⋅ 10^(308); beyond
    that, the value reported is `Infinity`. [Figure A-5](app01.xhtml#chAfig5) shows
    how to get there.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 1.5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The best way to approach this challenge is to treat the 64 binary digits in
    the IEEE representation as a string. Luckily, there’s room on the Scratch stage
    to show the complete value of a variable holding 64 characters. [Figure A-6](app01.xhtml#chAfig6)
    numbers the characters (grouped by tens) to demonstrate how wide the screen is,
    though you’ll want use just the characters 0 and 1 for the actual binary representation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg197_Image_246.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-5: Doubling your way to infinity*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg197_Image_247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-6: There’s room on the stage for 64 bits.*'
  prefs: []
  type: TYPE_NORMAL
- en: Treating the binary representation as a string lets you pick out individual
    bits with the `letter of` block. You might want to store the bits in a list to
    make it easier to manipulate them.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 1.6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To calculate 3^(*n*), all you need to do is change the multiplier from `2` to
    `3` in the `replace item` block ❶ in [Figure 1-13](ch01.xhtml#ch1fig13). [Figure
    A-7](app01.xhtml#chAfig7) shows the updated block.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg198_Image_248.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-7: Calculating powers of 3 rather than powers of 2*'
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 1.7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Make sure that when you translate the answer back from a list of five-digit
    blocks to a string, smaller numbers are padded with an appropriate number of zeros.
    If the “digit” is 435, for example, it should become 00435 before being joined
    to the string. You can do this with a few `if` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 1.8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Start by prompting for a number. Treat it as a string and make a list of digits
    by taking the characters from the string one at a time, beginning with the rightmost
    character (the least significant digit). Make a similar list from the second number.
    Add the corresponding digits in the two lists and keep the carry separate, if
    one occurs, so you can add it to the next pair of digits. If the numbers have
    a different amount of digits, you can pad the smaller number with 0 entries in
    its list of digits to finish the addition.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2: Exploring Divisibility and Primes](ch02.xhtml)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Challenge 2.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure A-8](app01.xhtml#chAfig8) shows a custom block that can be used in
    an infinite loop both for Scratch Cat’s turn and for screening your answer to
    see if you have the pattern correct. It checks if a number is divisible by 5,
    7, or 35 (both 5 and 7) and “translates” the number to the appropriate phrase.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg198_Image_249.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-8: A block to play Fizz-Buzz*'
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 2.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To calculate the alternating digit sum, it helps to view the input number `n`
    as a string, like we do in the casting out nines program from [Figure 2-2](ch02.xhtml#ch2fig2).
    Then, the digits of `n` can be treated as characters and pulled out for individual
    treatment as `letter i of n`. To alternate between addition and subtraction, make
    a variable called `plus minus` and toggle it back and forth between `1` and `-1`
    by multiplying it by `-1` after each digit. [Figure A-9](app01.xhtml#chAfig9)
    has some code to get you started.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg199_Image_250.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-9: Testing for divisibility by 11 using an alternating digit sum*'
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 2.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code in [Figure A-10](app01.xhtml#chAfig10) counts how many random numbers
    are divisible by 9.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg199_Image_251.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-10: Testing random numbers for divisibility by 9*'
  prefs: []
  type: TYPE_NORMAL
- en: This is a bit of a trick problem, though. You would think that about 1/9 of
    the numbers would be divisible by 9, but in the particular range from 1 to 100
    there are 100 numbers and only 11 multiples of 9, so the actual probability is
    11/100, which is a little smaller than 1/9\. Still, with such a small sample size
    it would be hard to spot the difference.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 2.4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At the end of the casting out nines program, the variable `x` holds the “check
    digit.” It’s easy to add that digit to the original number if you treat the numbers
    as strings and use a `join` block, as in [Figure A-11](app01.xhtml#chAfig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg200_Image_252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-11: Adding a “check digit” to a number*'
  prefs: []
  type: TYPE_NORMAL
- en: Scratch Cat doesn’t have to say the answer with the check digit. You can just
    leave the variable `with check digit` visible on the stage.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 2.5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Casting out nines won’t help catch an error of transposition, since the sum
    of the digits is the same no matter what order the digits are in.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 2.6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Table A-1](app01.xhtml#chAtab1) shows how the ratio of primes evolves as the
    upper bound increases.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table A-1:** The Ratio of Primes'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Upper bound** | **Prime count** | **Ratio** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 4 | 0.4 |'
  prefs: []
  type: TYPE_TB
- en: '| 100 | 25 | 0.25 |'
  prefs: []
  type: TYPE_TB
- en: '| 1,000 | 168 | 0.168 |'
  prefs: []
  type: TYPE_TB
- en: '| 10,000 | 1,229 | 0.1229 |'
  prefs: []
  type: TYPE_TB
- en: '| 100,000 | 9,592 | 0.09592 |'
  prefs: []
  type: TYPE_TB
- en: The relative number of primes appears to decrease.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 2.7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’re looking for consecutive runs of `false` in the sieve output. There are
    77 in a row starting at 188,030.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 2.8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure A-12](app01.xhtml#chAfig12) shows a snippet of code to add to scan
    the `primes` list for twin primes.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg201_Image_253.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-12: Looking for twin primes*'
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 2.9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The easiest way to do this is probably to make a new list where each entry contains
    six consecutive numbers from the original `primes` list joined together in a string.
    When you view the resulting list on the Scratch stage, it will look like a table
    with six columns. You’ll have to be careful with the formatting, though, so that
    numbers of different lengths in each column line up nicely. (See [Project 21](ch05.xhtml#ch05lev13)
    in [Chapter 5](ch05.xhtml#ch05) for an example of how to achieve this sort of
    formatting.)
  prefs: []
  type: TYPE_NORMAL
- en: Column 2 consists of all numbers that are congruent to 2 mod 6, which are divisible
    by 2\. The elements in columns 4 and 6 are also all divisible by 2, and the elements
    in column 3 are divisible by 3\. This means the only places primes could be after
    the first row are in columns 1 and 5.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 2.10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As discussed in “Hacking the Code” on [page 39](ch02.xhtml#ch02lev16) ([Project
    9](ch02.xhtml#ch02lev14)), you can keep track of runtimes using the `timer` block
    in the Sensing section of Scratch’s block menu. Set a variable called `timer1`
    when you start a calculation and one called `timer2` when you’re done, and calculate
    the difference (`timer2 - timer1`) to see how much time has elapsed, in seconds.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re trying to time something that happens really quickly, it might be
    hard to tell how much time the computer is spending working on your problem and
    how much time it’s spending on its own background tasks. To get a better estimate,
    you could have the computer repeat your problem a bunch of times—say, 100—and
    then divide the total elapsed time by that number to find the average time per
    run.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 2.11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can add a step counter to the custom `gcd` block from [Figure 2-17](ch02.xhtml#ch2fig17)
    to see how many cycles the algorithm takes. [Figure A-13](app01.xhtml#chAfig13)
    shows the updated block definition.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg202_Image_254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-13: Counting the steps to complete Euclid’s algorithm*'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm takes longer when the quotients are smaller, so keep them at 1
    to make a pretty pattern of values for remainders. Work backward from 3 = 1 ⋅
    2 + 1 to 5 = 1 ⋅ 3 + 2, 8 = 1 ⋅ 5 + 3, and so on. You’ll see this pattern again
    in [Chapter 4](ch04.xhtml#ch04)!
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3: Splitting Numbers with Prime Factorization](ch03.xhtml)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Challenge 3.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To find a perfect number, simply check if the result of the sum of divisors
    code ([Project 12](ch03.xhtml#ch03lev7), [Figure 3-8](ch03.xhtml#ch3fig8)) is
    equal to the original input number. It turns out any even perfect number *n* satisfies
    the following equation, where 2^(*p*) – 1 is a prime number:'
  prefs: []
  type: TYPE_NORMAL
- en: '*n* = 2^(*p* – 1)(2^p – 1)'
  prefs: []
  type: TYPE_NORMAL
- en: When *p* = 2, the equation gives the perfect number 6\. When *p* = 3, it gives
    28\. When *p* = 5, it gives 496, and when *p* = 7, it gives 8,128.
  prefs: []
  type: TYPE_NORMAL
- en: Nobody knows if there are any odd perfect numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 3.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure A-14](app01.xhtml#chAfig14) shows some code to identify if a number
    is perfect, abundant, or deficient. Add it to the end of the sum of divisors program
    in [Figure 3-8](ch03.xhtml#ch3fig8). Notice that since the sum of divisors includes
    the original number, `answer`, we first subtract `answer` to keep track of the
    `sum of proper divisors` ❶.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg203_Image_256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-14: Determining if a number is perfect, abundant, or deficient*'
  prefs: []
  type: TYPE_NORMAL
- en: Now you need to write a counting routine that loops up to some upper bound,
    automatically inputting numbers into the sum of divisors program. Use three variables
    to keep track of the number of abundant, perfect, and deficient numbers, incrementing
    the appropriate variable whenever each type of number is found. There are no abundant
    numbers up to 10, but there are 22 of them up to 100 and 246 of them up to 1,000\.
    There are 9 deficient numbers up to 10 and 751 of them up to 1,000.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 3.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code gives the correct answer for a 0 exponent, even when the base is 0.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 3.4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure A-15](app01.xhtml#chAfig15) shows a modification of [Figure 3-7](ch03.xhtml#ch3fig7)
    that allows for positive or negative exponents.'
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 3.5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure A-16](app01.xhtml#chAfig16) shows how you might preserve the list of
    exponents when you want to calculate *τ*(*n*). This code replaces the original
    `repeat` loop from the [Project 11](ch03.xhtml#page_47) code (see [Figure 3-6](ch03.xhtml#ch3fig6)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg203_Image_257.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-15: Working with positive or negative exponents*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg204_Image_258.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-16: Preserving the* exponents *list*'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the same index variable, `i`, to step through both the prime factors
    and the exponents when calculating *σ*(*n*).
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 3.6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The custom block in [Figure A-17](app01.xhtml#chAfig17) uses a Boolean variable,
    `primeQ`, to keep track of its answer. We start by setting `primeQ` to `true`
    and loop to change its value to `false` if `p` can be divided evenly by any number.
    We have to look only for divisors up to the square root of `p`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg204_Image_259.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-17: Testing if a number is prime*'
  prefs: []
  type: TYPE_NORMAL
- en: You can make the code in [Figure A-17](app01.xhtml#chAfig17) run more quickly
    by exiting after the first `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 3.7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure A-18](app01.xhtml#chAfig18) shows a block that finds the next prime
    number after `n`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg205_Image_260.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-18: Finding the next prime number*'
  prefs: []
  type: TYPE_NORMAL
- en: The block steps forward from `n`, passing values into the prime checking block
    from Challenge 3.6, until it reaches a number where `primeQ` is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 3.8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Think about the track the inner wheel follows as a straight line instead of
    the inside of a ring. For each complete rotation, the ring adds 96 teeth to the
    straight line track. There are LCM(*b*, 96) teeth in the shortest track common
    to 96 teeth and *b* teeth—that’s when the wheel will end up back where it started
    and the drawing will be complete. A point is determined every *b* teeth, so there
    will be LCM(*b*, 96) / *b* points in all.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 3.9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can complete this challenge with the custom block from Challenge 3.6.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 3.10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To compare the factorization methods, you can use the timer hack from [Figure
    2-19](ch02.xhtml#ch2fig19). The trial division method is usually quicker for numbers
    below flintmax, but if the number *n* being factored is a biprime with both prime
    factors close to ![Image](../images/pg206_Image_261a.jpg), then Fermat factorization
    can be faster.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 3.11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here’s some general code that uses the Pen extension to paint the stage with
    pixels whose color values (0 for white and 1 for black) are derived from a binary
    message. We’ll start with the `initial setup` block in [Figure A-19](app01.xhtml#chAfig19).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg206_Image_261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-19: Getting ready to draw a message*'
  prefs: []
  type: TYPE_NORMAL
- en: This block first sets the starting coordinates to a position near the upper-left
    corner of the stage ❶. It then asks for a `width` and `height`, which are the
    numbers of columns and rows you want your message to contain. Next, it determines
    the size of each block in the message by dividing the stage’s overall width and
    height by the width and height of the message. The sprite that will draw the message
    by adding stamps in the appropriate pixel locations is a 9×9 black square, which
    is scaled to fit in the grid being drawn ➋.
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Figure A-20](app01.xhtml#chAfig20) does the work of drawing the
    message.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg207_Image_262.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-20: Drawing the message*'
  prefs: []
  type: TYPE_NORMAL
- en: We specify the size of the rectangle for the message in two loops, one for the
    `height` and one for the `width`. The `message` is a string of bits (0s and 1s).
    We use the variable `n` to look at the message bit by bit, drawing a stamp for
    each bit that’s a 1 ❶. At the end of each row, we move the cursor to the start
    of the next row ➋.
  prefs: []
  type: TYPE_NORMAL
- en: You can use this program to draw the contents of the Arecibo message by copying
    and pasting in its 1,679 bits, or entering them by hand if you want to. Or you
    can test the program on the smaller message included in the `sample message` variable
    used in the “3-PC11 Binary message to pixels” Scratch project created by rumpus88366
    (*[https://scratch.mit.edu/projects/771257850](https://scratch.mit.edu/projects/771257850)*),
    shown in [Figure A-21](app01.xhtml#chAfig21).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg207_Image_263.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-21: A test message*'
  prefs: []
  type: TYPE_NORMAL
- en: This message gives a much simpler output when drawn as a rectangle seven columns
    wide by five rows high (see [Figure A-22](app01.xhtml#chAfig22)). Let’s call it
    an *S* for *Scratch*!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg208_Image_264.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-22: Visualizing the test message*'
  prefs: []
  type: TYPE_NORMAL
- en: You could extend this program in various ways. For example, the program could
    just ask for the message and factor the message’s length to find appropriate dimensions
    for the rectangle, assuming the length is a biprime.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4: Finding Patterns in Sequences](ch04.xhtml)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Challenge 4.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Lucas sequence begins 2, 1, 3, 4, 7, 11, 18, 29, 47, . . . . There are
    lots of interesting relationships between Lucas numbers (represented with an *l*)
    and Fibonacci numbers (represented with an *f*). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '*f[n]* [– 2] + *f[n]* = *l[n]*'
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 4.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To extend the Fibonacci numbers backward from *f*[1], we need to make sense
    of *f*[0], *f*[–1], *f*[–2], and so on. We can start by saying *f*[0] should be
    whatever we need to add to *f*[1] = 1 to get *f*[2] = 1\. Therefore, *f*[0] =
    0\. To maintain the recurrence, we need *f*[–1] = 1, *f*[–2] = –1, *f*[–3] = 2,
    and so on. It’s the original Fibonacci sequence, but every other value is negative.
  prefs: []
  type: TYPE_NORMAL
- en: The program in [Figure A-23](app01.xhtml#chAfig23) uses a series of `if` statements
    to report the Fibonacci number with a given index, negative indices included.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg209_Image_266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-23: Calculating positive and negative Fibonacci terms*'
  prefs: []
  type: TYPE_NORMAL
- en: The first few `if` statements account for the initial values of the sequence,
    between indices –2 and +2\. For other indices, the custom `Fibonacci` block calculates
    the Fibonacci number as if the index were positive. For odd negative indices,
    the result is switched to a negative number.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 4.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The last value before flintmax is at row 78\. The last value before the result
    is reported as `Infinity` is at row 1,476.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 4.4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To generate the coefficients, you need to know the values of terms 0, 1, and
    2 in the sequence. Let’s call these values *r*, *s*, and *t*, respectively. (In
    [Chapter 4](ch04.xhtml#ch04), we mostly talked about sequences as starting with
    term 1, but they can also have a term 0.) We can think of these three values as
    the results of the quadratic polynomial function *f* (*x*) = *ax*² + *bx* + *c*
    when *x* equals 0, 1, and 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about what happens to the quadratic polynomial when *x* is 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg210_Image_267.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The coefficients *a* and *b* go away, leaving only *c*. So what we’re calling
    *r*, the value of term 0 in the sequence, must also be the value of *c*. What
    about the case where *x* = 1?
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg210_Image_268.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This tells us that term 1 in the sequence, what we’re calling *s*, is the sum
    of the three coefficients. And what about when *x* = 2?
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg210_Image_269.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is equivalent to term 2 in the sequence, what we’re calling *t*.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a little algebra, we can use these results to write individual formulas
    for *a*, *b*, and *c*. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg210_Image_270.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In your program, you’ll take terms 0, 1, and 2 from a sequence and plug them
    into these formulas as the variables `r`, `s`, and `t`. For the sequence of pentagonal
    numbers, you should get *a* = 3/2, *b* = –1/2, and *c* = 0.
  prefs: []
  type: TYPE_NORMAL
- en: This neat math hack for figuring out the coefficients from the first few values
    of the quadratic polynomial is called the *method of undetermined coefficients*.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 4.5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is a sneaky way of asking for the longest set of consecutive composite
    numbers you can find. You solved that problem in Challenge 2.7.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 4.6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure A-24](app01.xhtml#chAfig24) modifies the decimal-to-binary converter
    from [Project 1](ch01.xhtml#ch01lev3) to generate a list of binary numbers. The
    new `How many ones?` block counts the number of 1s in each binary number and stores
    the results in a separate list to create the desired sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg211_Image_271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-24: Counting the 1s in binary numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to think about the sequence is to see it as blocks of 1, 2, 4, 8, .
    . . , elements. (The length of each block is a power of 2.) To get the next block,
    first copy the previous block, then follow this with a second copy of the previous
    block but with 1 added to each element. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg18_Image_5.jpg)The first block is 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Image](../images/pg18_Image_5.jpg)The second block is 1, 1 + 1 (or 1, 2).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Image](../images/pg18_Image_5.jpg)The third block is 1, 2, 1 + 1, 2 + 1 (or
    1, 2, 2, 3).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Image](../images/pg18_Image_5.jpg)The fourth block is 1, 2, 2, 3, 1 + 1,
    2 + 1, 2 + 1, 3 + 1 (or 1, 2, 2, 3, 2, 3, 3, 4).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interesting feature of this sequence is the way it contains copies of itself.
    If you look at just the elements in positions 2, 4, 6, 8, 10, . . . , you’ll see
    that they’re exactly the same as the original sequence!
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 4.7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Fibonacci numbers show up again in the first, second, and higher differences.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 4.8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Similar to the Fibonacci numbers, the powers of 2 show up again in the first,
    second, and higher differences. It’s the underlying exponential growth of both
    sequences that makes their differences show the same pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 4.9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Third differences are constant, and fourth and higher differences are 0\. It’s
    significant that for the sequence of squares, the second differences are constant
    with a value of 2 ⋅ 1 = 2, whereas for cubes, the third differences are constant
    with a value of 3 ⋅ 2 ⋅ 1 = 6\. One more pattern to check out!
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5: From Sequences to Arrays](ch05.xhtml)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Challenge 5.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s a zero at the end of *n*! for every factor of 10\. A factor of 10 comes
    from a factor of 5 and a factor of 2\. There are lots of factors of 2, so it’s
    easier to count factors of 5\. Every fifth number is a multiple of 5 and contributes
    a factor of 5 to *n*! There are `floor of n/5` multiples of 5 up to `n`. In addition,
    there are extra factors of 5 that come from higher powers of 5\. For example,
    every 25th number is a multiple of 25, which contributes an extra factor of 5,
    and every 125th number is a multiple of 125, contributing yet another extra factor
    of 5\. The program in [Figure A-25](app01.xhtml#chAfig25) counts just the factors
    of 5 the first time through the `repeat until` loop, then uses additional cycles
    of the loop to count the extra factors that come from factors of higher powers
    of 5.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg212_Image_272.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-25: Calculating the number of zeros at the end of* n *factorial*'
  prefs: []
  type: TYPE_NORMAL
- en: The program reports that there are six zeros at the end of 25 factorial.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 5.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can adapt the row-generating program from [Project 19](ch05.xhtml#ch05lev7)
    ([Figure 5-7](ch05.xhtml#ch5fig7)) to grab row entries after the row is calculated.
    [Figure A-26](app01.xhtml#chAfig26) shows a custom block to calculate the row
    and extract the *k*th entry. You could also do the calculation as a quotient of
    factorials, as we did in [Project 18](ch05.xhtml#ch05lev4) ([Figure 5-1](ch05.xhtml#ch5fig1)),
    but this way gives answers that are accurate for more rows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg213_Image_273.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-26: Calculating a specific binomial coefficient*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll want to call this custom block repeatedly for successive values of `n`
    while holding `k` constant at `2`, adding each set of results to its own list.
    You should find that the numbers down the *C*(*n*, 2) diagonal are the triangular
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 5.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The trick is to take mod 2 of each value, so even numbers end up as 0s and odd
    numbers end up as 1s. [Figure A-27](app01.xhtml#chAfig27) shows an interpretation
    of the first 32 rows of Pascal’s triangle, mod 2\. Here, the 1s are visualized
    as black squares and the 0s as blank spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg214_Image_274.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-27: Pascal’s triangle mod 2*'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting pattern is known as the Sierpiński triangle. It’s a famous example
    of a *fractal*, a pattern that repeats itself at different scales.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 5.4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can use the custom `gcd` block from [Project 9](ch02.xhtml#ch02lev14) (see
    [Figure 2-17](ch02.xhtml#ch2fig17)) to filter the row and column indices, then
    include in the table only entries where the row and column indices are both relatively
    prime to the modulus. [Figure A-28](app01.xhtml#chAfig28) shows the updates to
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg214_Image_275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-28: Restricting the operations table to rows and columns that are
    relatively prime to the modulus*'
  prefs: []
  type: TYPE_NORMAL
- en: The stack on the left goes in the definition for the `Make index row` block
    (see [Figure 5-15](ch05.xhtml#ch5fig15)), taking the place of the `set row` block
    inside the `repeat modulus` loop. The stack on the right goes into the main program
    stack (see [Figure 5-17](ch05.xhtml#ch5fig17)), replacing the current `add row
    to table` block.
  prefs: []
  type: TYPE_NORMAL
- en: With these changes, the mod 12 multiplication table comes out looking like [Figure
    A-29](app01.xhtml#chAfig29).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg214_Image_276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-29: A reduced multiplication table mod 12*'
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 5.5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can modify the custom `power` block from [Project 12](ch03.xhtml#ch03lev7)
    (see [Figure 3-7](ch03.xhtml#ch3fig7)) to work with modular arithmetic so it takes
    in a base and a power and calculates the appropriate power of the base, mod `p`.
    Then, you can build a custom Boolean block to test if a particular number `n`
    is a primitive root of a particular prime `p`. [Figure A-30](app01.xhtml#chAfig30)
    shows these two blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg215_Image_277.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-30: Looking for a primitive root*'
  prefs: []
  type: TYPE_NORMAL
- en: The loop in the `primitive root?` block goes to `p - 2` because if you haven’t
    found a power of `n` that equals 1 by this time, the last power will be 1, and
    `n` will be a primitive root.
  prefs: []
  type: TYPE_NORMAL
- en: With those pieces, the main program is just a loop to ask for a prime and find
    the first number that works as a primitive root. Two math questions to consider
    as a follow-up are why primes must have primitive roots and whether primitive
    roots exist for any composite numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 5.6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can strip down the `Make index row` block from [Figure 5-15](ch05.xhtml#ch5fig15)
    to eliminate the work of formatting the table with an index row and padding appropriately
    with spaces. Then, modify the custom `pad` block in [Figure 5-16](ch05.xhtml#ch5fig16)
    to insert a comma before `x` instead of one or more spaces.
  prefs: []
  type: TYPE_NORMAL
- en: You might also want to strip off the initial comma at the start of each row
    before adding it to the table. You can do that with another custom block. Scratch
    doesn’t have a command to identify and modify characters in strings the way it
    lets us work with elements of lists, so you can just rewrite the string from the
    second character on, as shown in [Figure A-31](app01.xhtml#chAfig31).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg216_Image_278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-31: Removing the first character from a string*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6: Making Codes, and Cracking Them Too](ch06.xhtml)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Challenge 6.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Make a single ring of letters in your favorite drawing program, similar to [Figure
    A-32](app01.xhtml#chAfig32). Import it into Scratch as a sprite labeled `Outer
    Wheel`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg216_Image_279.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-32: A letter ring*'
  prefs: []
  type: TYPE_NORMAL
- en: Now shrink the `Outer Wheel` sprite to make a new sprite that’s small enough
    to fit inside it, and label this `Inner Wheel`. The only code you need is a bit
    of code to manipulate the smaller sprite, as shown in [Figure A-33](app01.xhtml#chAfig33).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg216_Image_280.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-33: Rotating* Inner Wheel *one letter at a time*'
  prefs: []
  type: TYPE_NORMAL
- en: This code rotates the inner wheel to the left or right. The angle of 13.846
    degrees is 360 / 26, so each key press shifts the inner wheel by one letter at
    a time relative to the outer wheel.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 6.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: H becomes I, A becomes B, and L becomes M (see [Figure A-34](app01.xhtml#chAfig34)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg217_Image_281.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-34: Shifting “HAL” by 1*'
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 6.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Yes* in French is *oui*. Your decoder ring can translate this word for you
    using a shift of 16: Y becomes O, E becomes U, and S becomes I (see [Figure A-35](app01.xhtml#chAfig35)).
    Sadly, its magical translation capabilities don’t extend much further!'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg217_Image_282.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-35: YES?*'
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 6.4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is a job for the program from [Project 23](ch06.xhtml#ch06lev5) (see [Figure
    6-9](ch06.xhtml#ch6fig9)). A shift of 16 reveals the message “THERE WILL BE A
    HOT TIME IN THE OLD TOWN TONIGHT!”
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 6.5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The trouble here is that, due to the order of operations, the multiplication
    happens before the shift when you run the linear transformation code. If you try
    to undo both at once, the multiplier acts on the shift as well, so the shift ends
    up being incorrect. This is why we originally performed the decryption in two
    steps, to force the shift to be reversed before the multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: If *s* is the original shift factor, the fix is to take –*s* and multiply it
    by the modular inverse (mod the alphabet size). Then, use the result as the new
    shift factor for the decryption, while using the modular inverse as the new multiplier.
    This way, when the multiplier is applied, the inverse cancels out and you get
    the shift you want.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 6.6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The program in [Figure A-36](app01.xhtml#chAfig36) achieves this. After prompting
    for a `modulus`, which is the alphabet size, and a `multiplier`, it calls our
    custom `gcd` block (from [Figure 2-17](ch02.xhtml#ch2fig17)) to make sure a modular
    inverse exists. The program exits if no inverse exists, and otherwise it calculates
    the inverse by trial and error ❶. Then, it prompts for the `shift` and calculates
    the inverse transformation’s shift ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg218_Image_283.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-36: Finding the numbers to undo a linear transformation cipher*'
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 6.7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the multiplier isn’t relatively prime to the alphabet size, the scrambled
    alphabet won’t be complete. Some letters will occur more than once, and others
    won’t appear at all. Also, there’s no modular inverse, so no decryption is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 6.8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can reuse some of the code we wrote earlier in the chapter for this challenge,
    including the `Alphabet` block from [Figure 6-2](ch06.xhtml#ch6fig2) to build
    the `alphabet` list and the `Scramble` block from [Figure 6-19](ch06.xhtml#ch6fig19)
    to mix up the alphabet. You’ll also need an `Initialize` block to set up the `alphabet`
    list and prompt for a message (you won’t need it to prompt for a shift and a multiplier,
    since you’re going to generate all possible shifts and multipliers yourself),
    as well as our old friend the `gcd` block from [Project 9](ch02.xhtml#ch02lev14)
    ([Figure 2-17](ch02.xhtml#ch2fig17)). [Figure A-37](app01.xhtml#chAfig37) shows
    the new code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg219_Image_284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-37: Generating every possible linear transformation decryption*'
  prefs: []
  type: TYPE_NORMAL
- en: The outer `repeat` loop moves through every possible multiplier ❶, while the
    inner `repeat` loop moves through every possible shift for that multiplier ➌.
    Together, these loops generate every possible linear transformation, using `Scramble`
    to mix up the alphabet based on the current `multiple` and `shift` parameters
    ➍. Each possible message is built up character by character in the `encrypted`
    variable, then added to the list of possible decodings ➎. Before exploring a given
    multiplier, the `gcd` test ➋ confirms that the multiplier and the alphabet size
    are relatively prime. This indicates that a modular inverse exists for the multiplier
    and therefore that the multiplier is valid.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 6.9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An easy way to mix up the alphabet is to swap each letter with a random letter.
    [Figure A-38](app01.xhtml#chAfig38) shows a program that does this using a custom
    `swap` block. Notice that you need an extra variable, `x`, to temporarily hold
    one of the swapped values.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg220_Image_285.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-38: Randomly scrambling the alphabet*'
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to see the entire scrambled alphabet on the stage, you can build
    a string from the `alphabet` list, adding one character at a time (see [Figure
    A-39](app01.xhtml#chAfig39)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg221_Image_286.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-39: Viewing the scrambled alphabet as a single string*'
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 6.10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Start with an extension of the `gcd` code, shown in [Figure A-40](app01.xhtml#chAfig40),
    that remembers the quotients and remainders as `qlist` and `rlist`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg221_Image_287.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-40: Listing quotients and remainders from Euclid’s algorithm*'
  prefs: []
  type: TYPE_NORMAL
- en: You can now make linear combinations of the remainders to represent the greatest
    common divisor. As you substitute up from the bottom, you end up with a linear
    combination of the original numbers `a` and `b` that gives the GCD. [Figure A-41](app01.xhtml#chAfig41)
    shows how this works.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg222_Image_288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-41: Finding* x *and* y'
  prefs: []
  type: TYPE_NORMAL
- en: As an example, if you ask the program to use *b* = 26 and *a* = 17, you’ll end
    up with `x = 2` and `y = -3`. That means (2 ⋅ 26) – (3 ⋅ 17) = 1, which tells
    you that –3 ⋅ 17 ≡ 1 mod 26\. So you can use –3, or 26 – 3 = 23, as the modular
    inverse for 17\. [Figure A-42](app01.xhtml#chAfig42) shows the output for this
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg223_Image_289.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-42: Identifying –3 (or +23) as the modular inverse of 17*'
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 6.11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The logic of this program is in its main part, shown in [Figure A-43](app01.xhtml#chAfig43).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg223_Image_290.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-43: Guessing a letter and seeing how it fits*'
  prefs: []
  type: TYPE_NORMAL
- en: The custom `Initialize` block asks for a cryptogram to solve and sets up the
    stage display, showing the puzzle and the shape of its solution. Then, the `forever`
    loop asks for a letter in the puzzle to guess and what it should be replaced with.
    It’s easier to process the guess if the solution is maintained as a list of individual
    characters rather than as a string, so there’s some background coding to convert
    back and forth between `Solution`, which is displayed, and `Solution list`, which
    remains hidden. The bookkeeping is done in the `update` block, shown in [Figure
    A-44](app01.xhtml#chAfig44).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg224_Image_291.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-44: Updating the solution*'
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 6.12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure A-45](app01.xhtml#chAfig45) shows a quick way to tell whether a character
    is a letter or not. The Boolean variable `letterQ` is set to `true` for upper-
    or lowercase letters, or `false` otherwise. (The `contains` block doesn’t care
    about capitalization.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg224_Image_292.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-45: Testing for letters of the alphabet*'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have this block, you can use it to test each character in a string,
    one at a time. Keep only those characters that result in a `letterQ` value of
    `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7: Experiments in Counting](ch07.xhtml)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Challenge 7.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The program in [Figure A-46](app01.xhtml#chAfig46) lists Catalan numbers using
    the alternative recurrence.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg225_Image_293.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-46: Another Catalan recurrence*'
  prefs: []
  type: TYPE_NORMAL
- en: The calculation is implemented inside the `repeat` loop ❶. Notice that the formula
    is a single-term recurrence, meaning we need only *C*(*n* – 1) to calculate *C*.
    This means we can just use the `C` variable over and over, without having to look
    up earlier values in the list. Also, term *C*(0) doesn’t have to be included in
    the list at all, so the list’s index numbers are correct from the start. This
    recurrence produces accurate values up to flintmax.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 7.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The input for this program will be a row of the `Catalan` list generated by
    the code for [Project 28](ch07.xhtml#ch07lev3) ([Figures 7-1](ch07.xhtml#ch7fig1)
    through [7-3](ch07.xhtml#ch7fig3)), consisting of forward slash (`/`) and backslash
    (`\`) characters. Say you’ve extracted one of the rows into the `input pattern`
    variable. You can then draw the pattern with the code in [Figure A-47](app01.xhtml#chAfig47).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg226_Image_294.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-47: Visualizing Catalan paths*'
  prefs: []
  type: TYPE_NORMAL
- en: The custom `draw` block sets `step size` to make the drawing fit nicely on the
    stage. Then, the `repeat` loop in the main stack uses the characters as a recipe
    for drawing the diagram, ignoring all characters in `input pattern` except for
    the slashes. It draws a diagonal line upward for each forward slash and a diagonal
    line downward for each backslash.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 7.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The pattern to notice is that the *n*th Catalan number is *C*(2*n*, *n*) / (*n*
    + 1).
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 7.4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All you have to do is change every `/` to a left parenthesis and every `\` to
    a right parenthesis. To label the parentheses with letters (placing the label
    after a left parenthesis and before a right parenthesis) so it looks like a multiplication
    problem, it might be easiest to do two passes through each string in the `Catalan`
    list. The first pass can change each slash to the appropriate parenthesis and
    add a placeholder symbol for a letter (the code in [Figure A-48](app01.xhtml#chAfig48)
    uses a `+` symbol). The second pass can then replace each placeholder with the
    next unused letter in the alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg227_Image_295.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-48: Representing Catalan numbers with parentheses*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure A-49](app01.xhtml#chAfig49) shows what the output would look like for
    a given input string.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg227_Image_296.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-49: The* pretty output *variable substitutes letters for plus signs.*'
  prefs: []
  type: TYPE_NORMAL
- en: Challenges 7.5 and 7.6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s assume that a partition is presented as a string of summands connected
    by + signs, as we saw in the list shown in [Figure 7-15](ch07.xhtml#ch7fig15).
    We’ll also assume the summands are in increasing order. Since you need to look
    at each summand, the first step could be to change the string into a list of individual
    summands called `parts`. Then, you can define custom blocks to report Boolean
    values if the list has no even elements (say, `oddpartsQ`) and if the list has
    no duplicated elements (say, `distinctpartsQ`). The output might look like [Figure
    A-50](app01.xhtml#chAfig50).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg228_Image_297.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-50: Testing for all odd and all distinct summands*'
  prefs: []
  type: TYPE_NORMAL
- en: An interesting observation made by mathematician Leonhard Euler, the namesake
    of Project Euler, is that the number of partitions of *n* with only odd summands
    is the same as the number of partitions of *n* with all distinct summands.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 7.7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Ramanujan made two other observations that are relevant here: the number of
    partitions of any number that is 5 more than a multiple of 7 is itself divisible
    by 7, and the number of partitions of any number that is 6 more than a multiple
    of 11 is itself divisible by 11\. For example, *P*(19) = *P*(2 ⋅ 7 + 5) = 490,
    a multiple of 7, and *P*(17) = *P*(1 ⋅ 11 + 6) = 297, a multiple of 11.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8: Three Helpings of Pi](ch08.xhtml)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Challenge 8.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The length of the perimeter of the inscribed triangle is equal to 3![Image](../images/pg228_Image_299.jpg),
    so we should take *b*, the lower bound, to be 3![Image](../images/pg228_Image_299.jpg)
    / 2\. The length of the perimeter of the circumscribed triangle is equal to 6![Image](../images/pg228_Image_299.jpg),
    so *a* should be half of that, or 3![Image](../images/pg228_Image_299.jpg). [Figure
    A-51](app01.xhtml#chAfig51) shows these new starting values.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg228_Image_298.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-51: Starting values for the inscribed and circumscribed triangles*'
  prefs: []
  type: TYPE_NORMAL
- en: As [Figure A-52](app01.xhtml#chAfig52) shows, running the program with these
    starting values does indeed produce the same results, from the second line on,
    as running it with starting values from hexagons.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg228_Image_300.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-52: The first few rows of output, starting from triangles*'
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 8.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All you need to do to choose random non-integer coordinates is change the two
    `set` blocks ➋ in [Figure 8-11](ch08.xhtml#ch8fig11). The updated blocks are shown
    in [Figure A-53](app01.xhtml#chAfig53).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg229_Image_301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-53: Randomly choosing non-integer coordinates*'
  prefs: []
  type: TYPE_NORMAL
- en: Not only does the code still work with non-integers, but it also gives much
    better approximations of *π*.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 8.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure A-54](app01.xhtml#chAfig54) shows a loop to calculate a partial sum
    for the series up to a given number of terms.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg229_Image_302.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-54: Calculating partial sums for π²/6*'
  prefs: []
  type: TYPE_NORMAL
- en: There are two hacks to notice here. First, we’re using a custom block to calculate
    the *n*th term of the series ❶. That makes it easy to adapt the code to study
    other series. In this case, the custom block calculates 1/*n*², as shown in [Figure
    A-55](app01.xhtml#chAfig55).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg230_Image_303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-55: Calculating one term of the sum*'
  prefs: []
  type: TYPE_NORMAL
- en: The second hack is that once we’ve generated a list of *n* terms in the series,
    we find their sum by adding backward from the last term to the first ➋. This is
    necessary because the series consists of decreasing terms, and some of the decimal
    places of the later terms might be wiped out if they were added to the sum of
    the prior (larger) terms.
  prefs: []
  type: TYPE_NORMAL
- en: If you run this program for increasingly more terms, you’ll approach the value
    of *π*²/6, which is approximately 1.644934.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 8.4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can reuse the code from Challenge 8.3 that sums the first *n* terms in a
    series to solve this problem. You just need to define a different custom block
    for calculating each term, as shown in [Figure A-56](app01.xhtml#chAfig56).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg230_Image_304.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-56: Calculating one term of the sum for π/4*'
  prefs: []
  type: TYPE_NORMAL
- en: This time, the terms being added are odd integers, not squares, and the signs
    alternate from one term to the next. So you need to introduce a new variable,
    `sign`, that switches back and forth between `1` and `-1` for each term.
  prefs: []
  type: TYPE_NORMAL
- en: The value to aim for is about 0.785398, but alternating series are notoriously
    slow to converge, so it might take a while to get there. Multiplying this value
    by 4 gives an approximation of *π*.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 8.5
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The series in Challenge 8.3 consistently reports the first three digits of *π*
    correctly after 202 terms. For the alternating series in Challenge 8.4, it takes
    626 terms before the first three digits are stable.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 8.6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unlike in the random sampling code for [Project 31](ch08.xhtml#ch08lev6), you
    don’t have the option of using non-integer coordinates (see [Challenge 8.2](app01.xhtml#app01lev73))
    here because you need integers to calculate a GCD. You can still use the `pick
    random` block to generate random lattice points, though. The code in [Figure A-57](app01.xhtml#chAfig57)
    has a loop using random choices of lattice point coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg231_Image_305.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-57: Randomly sampling lattice points*'
  prefs: []
  type: TYPE_NORMAL
- en: It gives approximations for *π* that are about as good as the exhaustive enumeration
    using the code in [Figure 8-13](ch08.xhtml#ch8fig13).
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9: What Next?](ch09.xhtml)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Challenge 9.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure A-58](app01.xhtml#chAfig58) shows a program that finds the sum of the
    multiples of any two numbers up to a limit.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg232_Image_306.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-58: Finding the sum of any two multiples*'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of hardcoding the values of `3` and `5` into the program, as we did
    in [Project 33](ch09.xhtml#ch09lev3), here we take in two values from the user
    and reference them as the `first` and `second` variables.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 9.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You might think you can just multiply the two numbers together to get the correction,
    but that won’t work if the numbers aren’t relatively prime. Instead, you need
    to find the least common multiple (LCM) of the two numbers (which for relative
    primes happens to be the equivalent of their product). Calculating the LCM is
    easy using our `gcd` code from [Project 9](ch02.xhtml#ch02lev14) ([Figure 2-17](ch02.xhtml#ch2fig17)),
    since the LCM of *b* and *a* is the product of *b* and *a* divided by their GCD,
    as we noted in [Chapter 3](ch03.xhtml#ch03).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure A-59](app01.xhtml#chAfig59) shows an updated program that sums the
    multiples of any two numbers using the triangular number trick and the LCM for
    inclusion–exclusion.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg233_Image_307.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-59: Summing the multiples of any two numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: We use a custom `lcm` block, which first calls our trusty `gcd` block and then
    calculates the LCM based on the result.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 9.3
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the multiples are *a*, *b*, and *c*, first add the multiples of *a*, *b*,
    and *c* separately, then subtract the multiples of *a* ⋅ *b*, *a* ⋅ *c*, and *b*
    ⋅ *c*. Finally, add the multiples of *a* ⋅ *b* ⋅ *c* back in.
  prefs: []
  type: TYPE_NORMAL
