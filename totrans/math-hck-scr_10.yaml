- en: '**A**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**A**'
- en: '**Programming Challenge Hints**'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**编程挑战提示**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: Studying math involves learning and understanding mathematical concepts in class,
    using textbooks and worksheets. It can be a passive process, where you just try
    to absorb information. On the other hand, *doing* math involves actively applying
    concepts to solve problems and create new mathematical models. This process requires
    creativity and problem-solving skills, as well as the ability to think critically
    and logically.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 学习数学涉及在课堂上学习和理解数学概念，使用教科书和工作表。这可能是一个被动的过程，你只是试图吸收信息。另一方面，*做*数学涉及积极地应用概念来解决问题并创建新的数学模型。这个过程需要创造力和解决问题的能力，以及批判性和逻辑性思维的能力。
- en: Programming is an important part of doing math, as it lets you automate complex
    calculations and constructions in order to explore mathematical ideas in ways
    that would be impossible on paper or in your head. This book has been all about
    using Scratch to do math—writing algorithms and performing numerical computations—with
    the programming challenges being an invitation for you to “get your hands dirty”
    on some real problems. This chapter provides some comments and code snippets to
    help you solve those challenges.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 编程是做数学的重要组成部分，它让你能够自动化复杂的计算和构建，从而以在纸上或脑中无法实现的方式探索数学思想。本书的全部内容都是关于使用 Scratch
    做数学——编写算法和进行数值计算——编程挑战是邀请你“动手”解决一些实际问题。本章提供了一些注释和代码片段，以帮助你解决这些挑战。
- en: '[Chapter 1: What Computers Think About Numbers](ch01.xhtml)'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[第 1 章：计算机如何理解数字](ch01.xhtml)'
- en: Challenge 1.1
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 1.1
- en: As a first step, you could make a list of the digits in the base *b* number
    with a loop like the one in [Figure A-1](app01.xhtml#chAfig1). Then, you could
    put the digits together in a string to make the answer look like a base *b* number
    with code like that in [Figure A-2](app01.xhtml#chAfig2).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，你可以使用像[图 A-1](app01.xhtml#chAfig1)中的循环来列出基数 *b* 数字的各个数字。然后，你可以将这些数字组合成一个字符串，使答案看起来像一个基数
    *b* 数字，使用像[图 A-2](app01.xhtml#chAfig2)中的代码。
- en: '![Image](../images/pg196_Image_242.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg196_Image_242.jpg)'
- en: '*Figure A-1: Converting to base* b'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-1：转换为基数* b'
- en: For base 11 or 12, check if `convert mod b` is `10` or `11` and, if so, substitute
    `T` or `E` before adding the result to the `digits` list.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基数 11 或 12，检查 `convert mod b` 是否为 `10` 或 `11`，如果是，则在将结果添加到 `digits` 列表之前，替换为
    `T` 或 `E`。
- en: '![Image](../images/pg196_Image_243.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg196_Image_243.jpg)'
- en: '*Figure A-2: Joining the digits into a string*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-2：将数字组合成一个字符串*'
- en: Challenge 1.2
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 1.2
- en: '[Figure A-3](app01.xhtml#chAfig3) shows some code that works for base 11 or
    base 12\. You can add cases to it to support base 16.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 A-3](app01.xhtml#chAfig3) 显示了一些适用于基数 11 或基数 12 的代码。你可以添加更多情况以支持基数 16。'
- en: '![Image](../images/pg196_Image_244.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg196_Image_244.jpg)'
- en: '*Figure A-3: Substituting letters for numbers*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-3：将字母替换为数字*'
- en: When you go from binary to hexadecimal, each group of four binary digits (counting
    from the least significant, or rightmost, digit) is equivalent to a single hexadecimal
    digit. For example, 1011 in binary becomes E in hexadecimal.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从二进制转换为十六进制时，每四个二进制数字（从最不重要的位开始，或者说最右边的位）相当于一个十六进制数字。例如，二进制的 1011 转换为十六进制的
    E。
- en: Challenge 1.3
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 1.3
- en: You can grow a list by adding new items to it. Suppose you’ve asked the user
    to specify a starting value for the list, what the change should be (stored in
    the variable `change`), and how long the list should be (stored in the variable
    `length`). [Figure A-4](app01.xhtml#chAfig4) shows some code to calculate the
    remaining values in the list based on exponential and linear growth. Each type
    of growth gets its own list.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向列表中添加新项来扩展它。假设你已经要求用户指定列表的起始值、变化值（存储在变量 `change` 中）以及列表的长度（存储在变量 `length`
    中）。[图 A-4](app01.xhtml#chAfig4) 显示了一些代码，用于根据指数增长和线性增长计算列表中的剩余值。每种类型的增长都有自己的列表。
- en: '![Image](../images/pg197_Image_245.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg197_Image_245.jpg)'
- en: '*Figure A-4: Comparing exponential and linear growth*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-4：比较指数增长和线性增长*'
- en: Challenge 1.4
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 1.4
- en: With linear growth it would take a hopelessly long time to count to Scratch’s
    absolute maximum number, but with exponential growth (see [Challenge 1.3](app01.xhtml#app01lev4))
    you can get there very quickly. By doubling, for example, it takes just 1,024
    steps. The largest number Scratch can represent is about 1.08 ⋅ 10^(308); beyond
    that, the value reported is `Infinity`. [Figure A-5](app01.xhtml#chAfig5) shows
    how to get there.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线性增长，计算到 Scratch 的绝对最大数值将需要漫长的时间，但使用指数增长（参见[挑战 1.3](app01.xhtml#app01lev4)），你可以非常迅速地达到目标。例如，通过倍增，只需要
    1,024 步。Scratch 能表示的最大数字约为 1.08 ⋅ 10^(308)；超出这个范围，报告的值为`Infinity`。[图 A-5](app01.xhtml#chAfig5)展示了如何达到这个数值。
- en: Challenge 1.5
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 1.5
- en: The best way to approach this challenge is to treat the 64 binary digits in
    the IEEE representation as a string. Luckily, there’s room on the Scratch stage
    to show the complete value of a variable holding 64 characters. [Figure A-6](app01.xhtml#chAfig6)
    numbers the characters (grouped by tens) to demonstrate how wide the screen is,
    though you’ll want use just the characters 0 and 1 for the actual binary representation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个挑战的最佳方法是将 IEEE 表示中的 64 位二进制数字当作字符串处理。幸运的是，Scratch 舞台上有足够的空间显示一个包含 64 个字符的变量的完整值。[图
    A-6](app01.xhtml#chAfig6)对字符进行了编号（按十个一组），以展示屏幕的宽度，尽管你实际二进制表示时只会使用字符 0 和 1。
- en: '![Image](../images/pg197_Image_246.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg197_Image_246.jpg)'
- en: '*Figure A-5: Doubling your way to infinity*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-5：通过倍增达到无限*'
- en: '![Image](../images/pg197_Image_247.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg197_Image_247.jpg)'
- en: '*Figure A-6: There’s room on the stage for 64 bits.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-6：舞台上有足够空间显示 64 位。*'
- en: Treating the binary representation as a string lets you pick out individual
    bits with the `letter of` block. You might want to store the bits in a list to
    make it easier to manipulate them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将二进制表示视为字符串，可以通过`letter of`块提取单个位。你可能希望将这些位存储在一个列表中，这样更容易操作它们。
- en: Challenge 1.6
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 1.6
- en: To calculate 3^(*n*), all you need to do is change the multiplier from `2` to
    `3` in the `replace item` block ❶ in [Figure 1-13](ch01.xhtml#ch1fig13). [Figure
    A-7](app01.xhtml#chAfig7) shows the updated block.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算 3^(*n*)，你需要做的就是将`replace item`块 ❶中的乘数从`2`改为`3`，见[图 1-13](ch01.xhtml#ch1fig13)。[图
    A-7](app01.xhtml#chAfig7)显示了更新后的块。
- en: '![Image](../images/pg198_Image_248.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg198_Image_248.jpg)'
- en: '*Figure A-7: Calculating powers of 3 rather than powers of 2*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-7：计算 3 的幂而不是 2 的幂*'
- en: Challenge 1.7
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 1.7
- en: Make sure that when you translate the answer back from a list of five-digit
    blocks to a string, smaller numbers are padded with an appropriate number of zeros.
    If the “digit” is 435, for example, it should become 00435 before being joined
    to the string. You can do this with a few `if` blocks.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在将答案从五位数字块的列表转换回字符串时，较小的数字被适当填充 0。例如，如果“数字”是 435，它应该变成 00435 然后再与字符串连接。你可以通过几个
    `if` 块来实现这一点。
- en: Challenge 1.8
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 1.8
- en: Start by prompting for a number. Treat it as a string and make a list of digits
    by taking the characters from the string one at a time, beginning with the rightmost
    character (the least significant digit). Make a similar list from the second number.
    Add the corresponding digits in the two lists and keep the carry separate, if
    one occurs, so you can add it to the next pair of digits. If the numbers have
    a different amount of digits, you can pad the smaller number with 0 entries in
    its list of digits to finish the addition.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从提示一个数字开始。将其视为字符串，并通过逐个取出字符串中的字符（从最右边的字符开始，即最低位数字）来创建一个数字列表。对第二个数字也做类似的处理。将两个列表中相应的数字相加，并且如果有进位，将其分开存储，以便加到下一对数字上。如果数字位数不同，可以通过在较小的数字的数字列表中填充
    0 来完成加法运算。
- en: '[Chapter 2: Exploring Divisibility and Primes](ch02.xhtml)'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[第 2 章：探索可除性和质数](ch02.xhtml)'
- en: Challenge 2.1
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 2.1
- en: '[Figure A-8](app01.xhtml#chAfig8) shows a custom block that can be used in
    an infinite loop both for Scratch Cat’s turn and for screening your answer to
    see if you have the pattern correct. It checks if a number is divisible by 5,
    7, or 35 (both 5 and 7) and “translates” the number to the appropriate phrase.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 A-8](app01.xhtml#chAfig8)显示了一个自定义块，可以在无限循环中使用，既用于 Scratch Cat 的回合，也用于筛选你的答案，以检查你是否正确找到模式。它检查一个数字是否能被
    5、7 或 35（即 5 和 7 同时）整除，并将该数字“转化”为适当的短语。'
- en: '![Image](../images/pg198_Image_249.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg198_Image_249.jpg)'
- en: '*Figure A-8: A block to play Fizz-Buzz*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-8：用于玩 Fizz-Buzz 的块*'
- en: Challenge 2.2
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 2.2
- en: To calculate the alternating digit sum, it helps to view the input number `n`
    as a string, like we do in the casting out nines program from [Figure 2-2](ch02.xhtml#ch2fig2).
    Then, the digits of `n` can be treated as characters and pulled out for individual
    treatment as `letter i of n`. To alternate between addition and subtraction, make
    a variable called `plus minus` and toggle it back and forth between `1` and `-1`
    by multiplying it by `-1` after each digit. [Figure A-9](app01.xhtml#chAfig9)
    has some code to get you started.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算交替数字和，最好将输入数字 `n` 视为字符串，就像我们在 [图 2-2](ch02.xhtml#ch2fig2) 的除九法程序中所做的那样。然后，`n`
    的每个数字可以当作字符逐个提取并单独处理，使用 `letter i of n`。为了在加法和减法之间交替，可以创建一个名为 `plus minus` 的变量，并在每个数字之后将其乘以
    `-1` 来切换其值，从而在 `1` 和 `-1` 之间切换。[图 A-9](app01.xhtml#chAfig9) 提供了一些起步的代码。
- en: '![Image](../images/pg199_Image_250.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg199_Image_250.jpg)'
- en: '*Figure A-9: Testing for divisibility by 11 using an alternating digit sum*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-9：使用交替数字和来测试是否能被 11 整除*'
- en: Challenge 2.3
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 2.3
- en: The code in [Figure A-10](app01.xhtml#chAfig10) counts how many random numbers
    are divisible by 9.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 A-10](app01.xhtml#chAfig10) 中的代码计算了多少随机数能被 9 整除。'
- en: '![Image](../images/pg199_Image_251.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg199_Image_251.jpg)'
- en: '*Figure A-10: Testing random numbers for divisibility by 9*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-10：测试随机数是否能被 9 整除*'
- en: This is a bit of a trick problem, though. You would think that about 1/9 of
    the numbers would be divisible by 9, but in the particular range from 1 to 100
    there are 100 numbers and only 11 multiples of 9, so the actual probability is
    11/100, which is a little smaller than 1/9\. Still, with such a small sample size
    it would be hard to spot the difference.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这是一个有点技巧性的问题。你可能认为约有 1/9 的数字能被 9 整除，但在从 1 到 100 这个特定范围内，虽然有 100 个数字，只有 11
    个是 9 的倍数，所以实际的概率是 11/100，比 1/9 稍小。尽管如此，由于样本量很小，很难察觉到这个差异。
- en: Challenge 2.4
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 2.4
- en: At the end of the casting out nines program, the variable `x` holds the “check
    digit.” It’s easy to add that digit to the original number if you treat the numbers
    as strings and use a `join` block, as in [Figure A-11](app01.xhtml#chAfig11).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在除九法程序的末尾，变量 `x` 保存着“校验位”。如果把数字当作字符串来处理，并使用 `join` 块，就可以轻松地将该校验位加到原始数字上，正如 [图
    A-11](app01.xhtml#chAfig11) 所示。
- en: '![Image](../images/pg200_Image_252.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg200_Image_252.jpg)'
- en: '*Figure A-11: Adding a “check digit” to a number*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-11：给数字添加“校验位”*'
- en: Scratch Cat doesn’t have to say the answer with the check digit. You can just
    leave the variable `with check digit` visible on the stage.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Scratch Cat 不需要通过校验位说出答案。你可以只让变量 `with check digit` 在舞台上可见。
- en: Challenge 2.5
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 2.5
- en: Casting out nines won’t help catch an error of transposition, since the sum
    of the digits is the same no matter what order the digits are in.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除九法无法帮助捕捉置换错误，因为无论数字顺序如何，数字之和始终相同。
- en: Challenge 2.6
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 2.6
- en: '[Table A-1](app01.xhtml#chAtab1) shows how the ratio of primes evolves as the
    upper bound increases.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 A-1](app01.xhtml#chAtab1) 显示了随着上界增加，素数比率如何变化。'
- en: '**Table A-1:** The Ratio of Primes'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 A-1：素数的比率**'
- en: '| **Upper bound** | **Prime count** | **Ratio** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **上界** | **素数数量** | **比率** |'
- en: '| --- | --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 10 | 4 | 0.4 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 4 | 0.4 |'
- en: '| 100 | 25 | 0.25 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 25 | 0.25 |'
- en: '| 1,000 | 168 | 0.168 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 1,000 | 168 | 0.168 |'
- en: '| 10,000 | 1,229 | 0.1229 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 10,000 | 1,229 | 0.1229 |'
- en: '| 100,000 | 9,592 | 0.09592 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 100,000 | 9,592 | 0.09592 |'
- en: The relative number of primes appears to decrease.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 素数的相对数量似乎在减少。
- en: Challenge 2.7
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 2.7
- en: You’re looking for consecutive runs of `false` in the sieve output. There are
    77 in a row starting at 188,030.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在筛选输出中寻找连续的 `false`。从 188,030 开始，有连续的 77 个 `false`。
- en: Challenge 2.8
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 2.8
- en: '[Figure A-12](app01.xhtml#chAfig12) shows a snippet of code to add to scan
    the `primes` list for twin primes.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 A-12](app01.xhtml#chAfig12) 显示了一段代码，用来扫描 `primes` 列表中的双胞胎素数。'
- en: '![Image](../images/pg201_Image_253.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg201_Image_253.jpg)'
- en: '*Figure A-12: Looking for twin primes*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-12：寻找双胞胎素数*'
- en: Challenge 2.9
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 2.9
- en: The easiest way to do this is probably to make a new list where each entry contains
    six consecutive numbers from the original `primes` list joined together in a string.
    When you view the resulting list on the Scratch stage, it will look like a table
    with six columns. You’ll have to be careful with the formatting, though, so that
    numbers of different lengths in each column line up nicely. (See [Project 21](ch05.xhtml#ch05lev13)
    in [Chapter 5](ch05.xhtml#ch05) for an example of how to achieve this sort of
    formatting.)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法可能是创建一个新列表，其中每个条目包含原始`primes`列表中的六个连续数字，并将它们作为字符串连接在一起。当你在Scratch舞台上查看生成的列表时，它将看起来像一个具有六列的表格。然而，你需要小心格式设置，以确保每一列中不同长度的数字对齐得很好。（请参阅[第21项目](ch05.xhtml#ch05lev13)和[第5章](ch05.xhtml#ch05)，了解如何实现这种格式设置的示例。）
- en: Column 2 consists of all numbers that are congruent to 2 mod 6, which are divisible
    by 2\. The elements in columns 4 and 6 are also all divisible by 2, and the elements
    in column 3 are divisible by 3\. This means the only places primes could be after
    the first row are in columns 1 and 5.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第2列包含所有对6取模为2的数字，它们能被2整除。第4列和第6列的元素也都能被2整除，而第3列的元素能被3整除。这意味着，素数只能出现在第一行之后的第1列和第5列。
- en: Challenge 2.10
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 2.10
- en: As discussed in “Hacking the Code” on [page 39](ch02.xhtml#ch02lev16) ([Project
    9](ch02.xhtml#ch02lev14)), you can keep track of runtimes using the `timer` block
    in the Sensing section of Scratch’s block menu. Set a variable called `timer1`
    when you start a calculation and one called `timer2` when you’re done, and calculate
    the difference (`timer2 - timer1`) to see how much time has elapsed, in seconds.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如在“破解代码”部分讨论的那样，你可以使用Scratch的感知模块中的`timer`块来跟踪运行时间（详见[第39页](ch02.xhtml#ch02lev16)和[第9项目](ch02.xhtml#ch02lev14)）。在开始计算时设置一个名为`timer1`的变量，完成后设置一个名为`timer2`的变量，然后计算差值（`timer2
    - timer1`），以查看已过去的时间，单位为秒。
- en: If you’re trying to time something that happens really quickly, it might be
    hard to tell how much time the computer is spending working on your problem and
    how much time it’s spending on its own background tasks. To get a better estimate,
    you could have the computer repeat your problem a bunch of times—say, 100—and
    then divide the total elapsed time by that number to find the average time per
    run.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在尝试计时某些非常快速的操作，可能很难分辨出计算机在处理你的问题时花费了多少时间，以及它花费在后台任务上的时间是多少。为了得到更准确的估算，你可以让计算机重复执行你的问题若干次——比如100次——然后将总的经过时间除以次数，得到每次运行的平均时间。
- en: Challenge 2.11
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 2.11
- en: You can add a step counter to the custom `gcd` block from [Figure 2-17](ch02.xhtml#ch2fig17)
    to see how many cycles the algorithm takes. [Figure A-13](app01.xhtml#chAfig13)
    shows the updated block definition.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为[图2-17](ch02.xhtml#ch2fig17)中的自定义`gcd`块添加一个步骤计数器，以查看算法执行了多少次循环。[图A-13](app01.xhtml#chAfig13)展示了更新后的块定义。
- en: '![Image](../images/pg202_Image_254.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg202_Image_254.jpg)'
- en: '*Figure A-13: Counting the steps to complete Euclid’s algorithm*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*图A-13：计算欧几里得算法完成所需的步骤数*'
- en: The algorithm takes longer when the quotients are smaller, so keep them at 1
    to make a pretty pattern of values for remainders. Work backward from 3 = 1 ⋅
    2 + 1 to 5 = 1 ⋅ 3 + 2, 8 = 1 ⋅ 5 + 3, and so on. You’ll see this pattern again
    in [Chapter 4](ch04.xhtml#ch04)!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当商较小时时，算法需要更长的时间，因此保持商为1可以形成一个漂亮的余数模式。从3 = 1 ⋅ 2 + 1开始，接着是5 = 1 ⋅ 3 + 2，8 =
    1 ⋅ 5 + 3，以此类推。你将在[第4章](ch04.xhtml#ch04)再次看到这个模式！
- en: '[Chapter 3: Splitting Numbers with Prime Factorization](ch03.xhtml)'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[第3章：通过素因数分解拆分数字](ch03.xhtml)'
- en: Challenge 3.1
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 3.1
- en: 'To find a perfect number, simply check if the result of the sum of divisors
    code ([Project 12](ch03.xhtml#ch03lev7), [Figure 3-8](ch03.xhtml#ch3fig8)) is
    equal to the original input number. It turns out any even perfect number *n* satisfies
    the following equation, where 2^(*p*) – 1 is a prime number:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到一个完美数，只需检查除数和代码的结果是否等于原始输入数字（[第12项目](ch03.xhtml#ch03lev7)，[图3-8](ch03.xhtml#ch3fig8)）。事实证明，任何偶数完美数
    *n* 都满足以下方程，其中2^(*p*) – 1是一个素数：
- en: '*n* = 2^(*p* – 1)(2^p – 1)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*n* = 2^(*p* – 1)(2^p – 1)'
- en: When *p* = 2, the equation gives the perfect number 6\. When *p* = 3, it gives
    28\. When *p* = 5, it gives 496, and when *p* = 7, it gives 8,128.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *p* = 2 时，方程给出完美数6。当 *p* = 3 时，方程给出28。当 *p* = 5 时，方程给出496，而当 *p* = 7 时，方程给出8,128。
- en: Nobody knows if there are any odd perfect numbers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人知道是否存在奇数完美数。
- en: Challenge 3.2
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 3.2
- en: '[Figure A-14](app01.xhtml#chAfig14) shows some code to identify if a number
    is perfect, abundant, or deficient. Add it to the end of the sum of divisors program
    in [Figure 3-8](ch03.xhtml#ch3fig8). Notice that since the sum of divisors includes
    the original number, `answer`, we first subtract `answer` to keep track of the
    `sum of proper divisors` ❶.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 A-14](app01.xhtml#chAfig14)展示了一些代码，用于识别一个数字是完美数、过剩数还是缺乏数。将其添加到[图 3-8](ch03.xhtml#ch3fig8)中除数和程序的末尾。注意，由于除数和包括原始数字`answer`，我们首先减去`answer`以跟踪`适当除数的总和`❶。'
- en: '![Image](../images/pg203_Image_256.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg203_Image_256.jpg)'
- en: '*Figure A-14: Determining if a number is perfect, abundant, or deficient*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-14：确定一个数字是完美数、过剩数还是缺乏数*'
- en: Now you need to write a counting routine that loops up to some upper bound,
    automatically inputting numbers into the sum of divisors program. Use three variables
    to keep track of the number of abundant, perfect, and deficient numbers, incrementing
    the appropriate variable whenever each type of number is found. There are no abundant
    numbers up to 10, but there are 22 of them up to 100 and 246 of them up to 1,000\.
    There are 9 deficient numbers up to 10 and 751 of them up to 1,000.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要编写一个计数例程，该例程循环直到某个上限，自动将数字输入到除数和程序中。使用三个变量来跟踪过剩数、完美数和缺乏数的数量，每当发现每种类型的数字时，增加相应的变量。10以内没有过剩数，但100以内有22个，1000以内有246个。10以内有9个缺乏数，1000以内有751个。
- en: Challenge 3.3
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 3.3
- en: The code gives the correct answer for a 0 exponent, even when the base is 0.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码为0指数给出了正确的答案，即使底数为0。
- en: Challenge 3.4
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 3.4
- en: '[Figure A-15](app01.xhtml#chAfig15) shows a modification of [Figure 3-7](ch03.xhtml#ch3fig7)
    that allows for positive or negative exponents.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 A-15](app01.xhtml#chAfig15)展示了[图 3-7](ch03.xhtml#ch3fig7)的修改，允许使用正指数或负指数。'
- en: Challenge 3.5
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 3.5
- en: '[Figure A-16](app01.xhtml#chAfig16) shows how you might preserve the list of
    exponents when you want to calculate *τ*(*n*). This code replaces the original
    `repeat` loop from the [Project 11](ch03.xhtml#page_47) code (see [Figure 3-6](ch03.xhtml#ch3fig6)).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 A-16](app01.xhtml#chAfig16)展示了如何在计算 *τ*(*n*) 时保存指数列表。该代码替换了[项目 11](ch03.xhtml#page_47)代码中的原始`repeat`循环（见[图
    3-6](ch03.xhtml#ch3fig6)）。'
- en: '![Image](../images/pg203_Image_257.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg203_Image_257.jpg)'
- en: '*Figure A-15: Working with positive or negative exponents*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-15：处理正指数或负指数*'
- en: '![Image](../images/pg204_Image_258.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg204_Image_258.jpg)'
- en: '*Figure A-16: Preserving the* exponents *list*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-16：保存* 指数 *列表*'
- en: You can use the same index variable, `i`, to step through both the prime factors
    and the exponents when calculating *σ*(*n*).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算 *σ*(*n*) 时，您可以使用相同的索引变量`i`，同时遍历素因子和指数。
- en: Challenge 3.6
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 3.6
- en: The custom block in [Figure A-17](app01.xhtml#chAfig17) uses a Boolean variable,
    `primeQ`, to keep track of its answer. We start by setting `primeQ` to `true`
    and loop to change its value to `false` if `p` can be divided evenly by any number.
    We have to look only for divisors up to the square root of `p`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 A-17](app01.xhtml#chAfig17)中的自定义块使用一个布尔变量`primeQ`来跟踪其答案。我们首先将`primeQ`设置为`true`，然后通过循环改变其值为`false`，如果`p`可以被任何数字整除。我们只需要查找不超过`p`的平方根的除数。'
- en: '![Image](../images/pg204_Image_259.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg204_Image_259.jpg)'
- en: '*Figure A-17: Testing if a number is prime*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-17：测试一个数字是否为素数*'
- en: You can make the code in [Figure A-17](app01.xhtml#chAfig17) run more quickly
    by exiting after the first `false`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在第一个`false`之后退出，来让[图 A-17](app01.xhtml#chAfig17)中的代码运行得更快。
- en: Challenge 3.7
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 3.7
- en: '[Figure A-18](app01.xhtml#chAfig18) shows a block that finds the next prime
    number after `n`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 A-18](app01.xhtml#chAfig18)展示了一个块，用于找到`n`之后的下一个素数。'
- en: '![Image](../images/pg205_Image_260.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg205_Image_260.jpg)'
- en: '*Figure A-18: Finding the next prime number*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-18：寻找下一个素数*'
- en: The block steps forward from `n`, passing values into the prime checking block
    from Challenge 3.6, until it reaches a number where `primeQ` is `true`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该块从`n`开始向前推进，将值传递到挑战 3.6 中的素数检查块，直到它达到一个使`primeQ`为`true`的数字。
- en: Challenge 3.8
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 3.8
- en: Think about the track the inner wheel follows as a straight line instead of
    the inside of a ring. For each complete rotation, the ring adds 96 teeth to the
    straight line track. There are LCM(*b*, 96) teeth in the shortest track common
    to 96 teeth and *b* teeth—that’s when the wheel will end up back where it started
    and the drawing will be complete. A point is determined every *b* teeth, so there
    will be LCM(*b*, 96) / *b* points in all.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 想象内轮所走的轨迹是直线而不是环的内部。每次完整旋转时，环会在直线轨迹上添加 96 个齿。96 个齿和 *b* 个齿的最短公共轨迹包含 LCM(*b*,
    96) 个齿——这时，轮子会回到起点，绘制完成。每 *b* 个齿就确定一个点，因此总共有 LCM(*b*, 96) / *b* 个点。
- en: Challenge 3.9
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 3.9
- en: You can complete this challenge with the custom block from Challenge 3.6.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过挑战 3.6 中的自定义积木来完成此挑战。
- en: Challenge 3.10
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 3.10
- en: To compare the factorization methods, you can use the timer hack from [Figure
    2-19](ch02.xhtml#ch2fig19). The trial division method is usually quicker for numbers
    below flintmax, but if the number *n* being factored is a biprime with both prime
    factors close to ![Image](../images/pg206_Image_261a.jpg), then Fermat factorization
    can be faster.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较分解方法，你可以使用[图 2-19](ch02.xhtml#ch2fig19)中的计时器黑客。对于小于 flintmax 的数字，试除法通常更快，但如果被分解的数字
    *n* 是一个双素数，且两个素因子都接近 ![Image](../images/pg206_Image_261a.jpg)，那么费马分解法可能会更快。
- en: Challenge 3.11
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 3.11
- en: Here’s some general code that uses the Pen extension to paint the stage with
    pixels whose color values (0 for white and 1 for black) are derived from a binary
    message. We’ll start with the `initial setup` block in [Figure A-19](app01.xhtml#chAfig19).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些通用代码，使用 Pen 扩展来用像素绘制舞台，这些像素的颜色值（0 为白色，1 为黑色）来自二进制消息。我们将从[图 A-19](app01.xhtml#chAfig19)中的`initial
    setup`积木开始。
- en: '![Image](../images/pg206_Image_261.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg206_Image_261.jpg)'
- en: '*Figure A-19: Getting ready to draw a message*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-19：准备绘制消息*'
- en: This block first sets the starting coordinates to a position near the upper-left
    corner of the stage ❶. It then asks for a `width` and `height`, which are the
    numbers of columns and rows you want your message to contain. Next, it determines
    the size of each block in the message by dividing the stage’s overall width and
    height by the width and height of the message. The sprite that will draw the message
    by adding stamps in the appropriate pixel locations is a 9×9 black square, which
    is scaled to fit in the grid being drawn ➋.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个积木首先将起始坐标设置为舞台的左上角附近的位置❶。然后，它会询问`width`和`height`，即你希望消息包含的列数和行数。接下来，它通过将舞台的总宽度和高度分别除以消息的宽度和高度来确定每个块的大小。将通过在适当的像素位置添加印章来绘制消息的精灵是一个
    9×9 的黑色方块，该方块会被缩放以适应正在绘制的网格➋。
- en: The code in [Figure A-20](app01.xhtml#chAfig20) does the work of drawing the
    message.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 A-20](app01.xhtml#chAfig20)中的代码完成了绘制消息的工作。'
- en: '![Image](../images/pg207_Image_262.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg207_Image_262.jpg)'
- en: '*Figure A-20: Drawing the message*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-20：绘制消息*'
- en: We specify the size of the rectangle for the message in two loops, one for the
    `height` and one for the `width`. The `message` is a string of bits (0s and 1s).
    We use the variable `n` to look at the message bit by bit, drawing a stamp for
    each bit that’s a 1 ❶. At the end of each row, we move the cursor to the start
    of the next row ➋.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过两个循环来指定消息的矩形大小，一个循环处理`height`，另一个循环处理`width`。`message`是一个比特串（0 和 1）。我们使用变量`n`逐位查看消息，为每个为
    1 的比特绘制印章❶。在每行的末尾，我们将光标移动到下一行的开始位置➋。
- en: You can use this program to draw the contents of the Arecibo message by copying
    and pasting in its 1,679 bits, or entering them by hand if you want to. Or you
    can test the program on the smaller message included in the `sample message` variable
    used in the “3-PC11 Binary message to pixels” Scratch project created by rumpus88366
    (*[https://scratch.mit.edu/projects/771257850](https://scratch.mit.edu/projects/771257850)*),
    shown in [Figure A-21](app01.xhtml#chAfig21).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个程序通过复制并粘贴 Arecibo 消息的 1,679 位来绘制其内容，或者如果你愿意，也可以手动输入它们。或者，你可以在“3-PC11
    二进制消息到像素” Scratch 项目中测试该程序，该项目由 rumpus88366 创建（* [https://scratch.mit.edu/projects/771257850](https://scratch.mit.edu/projects/771257850)
    *），如[图 A-21](app01.xhtml#chAfig21)所示。
- en: '![Image](../images/pg207_Image_263.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg207_Image_263.jpg)'
- en: '*Figure A-21: A test message*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-21：一个测试消息*'
- en: This message gives a much simpler output when drawn as a rectangle seven columns
    wide by five rows high (see [Figure A-22](app01.xhtml#chAfig22)). Let’s call it
    an *S* for *Scratch*!
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息作为一个七列五行的矩形绘制时，它会生成一个更简单的输出（见[图 A-22](app01.xhtml#chAfig22)）。我们称之为 *S*，代表
    *Scratch*！
- en: '![Image](../images/pg208_Image_264.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg208_Image_264.jpg)'
- en: '*Figure A-22: Visualizing the test message*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-22：可视化测试消息*'
- en: You could extend this program in various ways. For example, the program could
    just ask for the message and factor the message’s length to find appropriate dimensions
    for the rectangle, assuming the length is a biprime.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以各种方式扩展这个程序。例如，程序可以只要求输入消息，并对消息的长度进行因式分解，以找到矩形的适当尺寸，假设该长度是双素数。
- en: '[Chapter 4: Finding Patterns in Sequences](ch04.xhtml)'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[第 4 章：在序列中寻找模式](ch04.xhtml)'
- en: Challenge 4.1
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 4.1
- en: 'The Lucas sequence begins 2, 1, 3, 4, 7, 11, 18, 29, 47, . . . . There are
    lots of interesting relationships between Lucas numbers (represented with an *l*)
    and Fibonacci numbers (represented with an *f*). For example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Lucas 序列的开始是 2, 1, 3, 4, 7, 11, 18, 29, 47, …… Lucas 数字（用 *l* 表示）和斐波那契数字（用 *f*
    表示）之间有很多有趣的关系。例如：
- en: '*f[n]* [– 2] + *f[n]* = *l[n]*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*f[n]* [– 2] + *f[n]* = *l[n]*'
- en: Challenge 4.2
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 4.2
- en: To extend the Fibonacci numbers backward from *f*[1], we need to make sense
    of *f*[0], *f*[–1], *f*[–2], and so on. We can start by saying *f*[0] should be
    whatever we need to add to *f*[1] = 1 to get *f*[2] = 1\. Therefore, *f*[0] =
    0\. To maintain the recurrence, we need *f*[–1] = 1, *f*[–2] = –1, *f*[–3] = 2,
    and so on. It’s the original Fibonacci sequence, but every other value is negative.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 *f*[1] 向后扩展斐波那契数列，我们需要理解 *f*[0]、*f*[-1]、*f*[-2] 等等。我们可以从 *f*[0] 应该是我们需要加到
    *f*[1] = 1 才能得到 *f*[2] = 1 的数开始。因此，*f*[0] = 0。为了保持递推关系，我们需要 *f*[-1] = 1，*f*[-2]
    = -1，*f*[-3] = 2，依此类推。它是原始的斐波那契数列，但每隔一个值为负数。
- en: The program in [Figure A-23](app01.xhtml#chAfig23) uses a series of `if` statements
    to report the Fibonacci number with a given index, negative indices included.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 A-23](app01.xhtml#chAfig23) 中的程序使用了一系列 `if` 语句来报告给定索引的斐波那契数，包括负索引。'
- en: '![Image](../images/pg209_Image_266.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg209_Image_266.jpg)'
- en: '*Figure A-23: Calculating positive and negative Fibonacci terms*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-23：计算正负斐波那契项*'
- en: The first few `if` statements account for the initial values of the sequence,
    between indices –2 and +2\. For other indices, the custom `Fibonacci` block calculates
    the Fibonacci number as if the index were positive. For odd negative indices,
    the result is switched to a negative number.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的几个 `if` 语句处理了序列中索引从 -2 到 +2 的初始值。对于其他索引，自定义的 `Fibonacci` 块计算斐波那契数，假设索引是正数。对于奇数负索引，结果会被转换为负数。
- en: Challenge 4.3
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 4.3
- en: The last value before flintmax is at row 78\. The last value before the result
    is reported as `Infinity` is at row 1,476.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 flintmax 之前的最后一个值出现在第 78 行。结果报告为 `Infinity` 之前的最后一个值出现在第 1,476 行。
- en: Challenge 4.4
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 4.4
- en: To generate the coefficients, you need to know the values of terms 0, 1, and
    2 in the sequence. Let’s call these values *r*, *s*, and *t*, respectively. (In
    [Chapter 4](ch04.xhtml#ch04), we mostly talked about sequences as starting with
    term 1, but they can also have a term 0.) We can think of these three values as
    the results of the quadratic polynomial function *f* (*x*) = *ax*² + *bx* + *c*
    when *x* equals 0, 1, and 2.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成系数，你需要知道序列中第 0、1 和 2 项的值。我们分别称这三个值为 *r*、*s* 和 *t*。（在[第 4 章](ch04.xhtml#ch04)中，我们大多讨论的是以第
    1 项开始的序列，但它们也可以有第 0 项。）我们可以将这三个值看作是二次多项式函数 *f* (*x*) = *ax*² + *bx* + *c* 在 *x*
    等于 0、1 和 2 时的结果。
- en: 'Think about what happens to the quadratic polynomial when *x* is 0:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 想想当 *x* 等于 0 时，二次多项式会发生什么：
- en: '![Image](../images/pg210_Image_267.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg210_Image_267.jpg)'
- en: The coefficients *a* and *b* go away, leaving only *c*. So what we’re calling
    *r*, the value of term 0 in the sequence, must also be the value of *c*. What
    about the case where *x* = 1?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 系数 *a* 和 *b* 被消去，只剩下 *c*。因此我们称为 *r* 的序列第 0 项的值，也必须是 *c* 的值。那么 *x* = 1 的情况呢？
- en: '![Image](../images/pg210_Image_268.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg210_Image_268.jpg)'
- en: This tells us that term 1 in the sequence, what we’re calling *s*, is the sum
    of the three coefficients. And what about when *x* = 2?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，序列中的第 1 项，也就是我们称之为 *s* 的项，是三个系数的和。那么 *x* = 2 时呢？
- en: '![Image](../images/pg210_Image_269.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg210_Image_269.jpg)'
- en: This is equivalent to term 2 in the sequence, what we’re calling *t*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于序列中的第 2 项，也就是我们称之为 *t* 的项。
- en: 'With a little algebra, we can use these results to write individual formulas
    for *a*, *b*, and *c*. They are:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一点代数运算，我们可以利用这些结果写出 *a*、*b* 和 *c* 的单独公式。它们是：
- en: '![Image](../images/pg210_Image_270.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg210_Image_270.jpg)'
- en: In your program, you’ll take terms 0, 1, and 2 from a sequence and plug them
    into these formulas as the variables `r`, `s`, and `t`. For the sequence of pentagonal
    numbers, you should get *a* = 3/2, *b* = –1/2, and *c* = 0.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的程序中，你将从一个数列中取出第 0、1、2 项，并将它们代入这些公式作为变量 `r`、`s` 和 `t`。对于五边形数列，你应该得到 *a* =
    3/2，*b* = -1/2，*c* = 0。
- en: This neat math hack for figuring out the coefficients from the first few values
    of the quadratic polynomial is called the *method of undetermined coefficients*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这种巧妙的数学技巧，用来通过二次多项式的前几个值来确定系数，被称为 *未定系数法*。
- en: Challenge 4.5
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 4.5
- en: This is a sneaky way of asking for the longest set of consecutive composite
    numbers you can find. You solved that problem in Challenge 2.7.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个巧妙的方式，要求找出你能找到的最长的连续合成数集。你在挑战 2.7 中解决了这个问题。
- en: Challenge 4.6
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 4.6
- en: '[Figure A-24](app01.xhtml#chAfig24) modifies the decimal-to-binary converter
    from [Project 1](ch01.xhtml#ch01lev3) to generate a list of binary numbers. The
    new `How many ones?` block counts the number of 1s in each binary number and stores
    the results in a separate list to create the desired sequence.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 A-24](app01.xhtml#chAfig24) 修改了 [项目 1](ch01.xhtml#ch01lev3) 的十进制到二进制转换器，以生成一组二进制数。新的
    `有多少个 1？` 块计算每个二进制数中 1 的个数，并将结果存储在一个单独的列表中，从而创建出所需的序列。'
- en: '![Image](../images/pg211_Image_271.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg211_Image_271.jpg)'
- en: '*Figure A-24: Counting the 1s in binary numbers*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-24：计算二进制数中的 1 的个数*'
- en: 'One way to think about the sequence is to see it as blocks of 1, 2, 4, 8, .
    . . , elements. (The length of each block is a power of 2.) To get the next block,
    first copy the previous block, then follow this with a second copy of the previous
    block but with 1 added to each element. For example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 思考这个数列的一种方式是将其视为由 1、2、4、8、... 等元素构成的块。（每个块的长度是 2 的幂。）要获得下一个块，首先复制前一个块，然后在此基础上再复制一份前一个块，但每个元素加
    1。例如：
- en: '![Image](../images/pg18_Image_5.jpg)The first block is 1.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Image](../images/pg18_Image_5.jpg)第一块是 1。'
- en: '![Image](../images/pg18_Image_5.jpg)The second block is 1, 1 + 1 (or 1, 2).'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Image](../images/pg18_Image_5.jpg)第二块是 1、1 + 1（或者 1、2）。'
- en: '![Image](../images/pg18_Image_5.jpg)The third block is 1, 2, 1 + 1, 2 + 1 (or
    1, 2, 2, 3).'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Image](../images/pg18_Image_5.jpg)第三块是 1、2、1 + 1、2 + 1（或者 1、2、2、3）。'
- en: '![Image](../images/pg18_Image_5.jpg)The fourth block is 1, 2, 2, 3, 1 + 1,
    2 + 1, 2 + 1, 3 + 1 (or 1, 2, 2, 3, 2, 3, 3, 4).'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Image](../images/pg18_Image_5.jpg)第四块是 1、2、2、3、1 + 1、2 + 1、2 + 1、3 + 1（或者
    1、2、2、3、2、3、3、4）。'
- en: An interesting feature of this sequence is the way it contains copies of itself.
    If you look at just the elements in positions 2, 4, 6, 8, 10, . . . , you’ll see
    that they’re exactly the same as the original sequence!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数列的一个有趣特点是它包含了自身的副本。如果你只看位置 2、4、6、8、10、... 的元素，你会发现它们与原始数列完全相同！
- en: Challenge 4.7
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 4.7
- en: The Fibonacci numbers show up again in the first, second, and higher differences.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列再次出现在第一次、第二次及更高次差分中。
- en: Challenge 4.8
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 4.8
- en: Similar to the Fibonacci numbers, the powers of 2 show up again in the first,
    second, and higher differences. It’s the underlying exponential growth of both
    sequences that makes their differences show the same pattern.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于斐波那契数列，2 的幂次再次出现在第一次、第二次及更高次差分中。两者的底层指数增长使得它们的差分呈现出相同的模式。
- en: Challenge 4.9
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 4.9
- en: Third differences are constant, and fourth and higher differences are 0\. It’s
    significant that for the sequence of squares, the second differences are constant
    with a value of 2 ⋅ 1 = 2, whereas for cubes, the third differences are constant
    with a value of 3 ⋅ 2 ⋅ 1 = 6\. One more pattern to check out!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第三差分是常数，第四及更高次差分为 0。对于平方数列，第二差分是常数，值为 2 ⋅ 1 = 2，而对于立方数，第三差分是常数，值为 3 ⋅ 2 ⋅ 1
    = 6。这是另一个值得检查的模式！
- en: '[Chapter 5: From Sequences to Arrays](ch05.xhtml)'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[第 5 章：从数列到数组](ch05.xhtml)'
- en: Challenge 5.1
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 5.1
- en: There’s a zero at the end of *n*! for every factor of 10\. A factor of 10 comes
    from a factor of 5 and a factor of 2\. There are lots of factors of 2, so it’s
    easier to count factors of 5\. Every fifth number is a multiple of 5 and contributes
    a factor of 5 to *n*! There are `floor of n/5` multiples of 5 up to `n`. In addition,
    there are extra factors of 5 that come from higher powers of 5\. For example,
    every 25th number is a multiple of 25, which contributes an extra factor of 5,
    and every 125th number is a multiple of 125, contributing yet another extra factor
    of 5\. The program in [Figure A-25](app01.xhtml#chAfig25) counts just the factors
    of 5 the first time through the `repeat until` loop, then uses additional cycles
    of the loop to count the extra factors that come from factors of higher powers
    of 5.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 *n*! 的末尾有一个零时，就表示有一个因子是 10。因子 10 来自因子 5 和因子 2。由于因子 2 很多，因此更容易计算因子 5 的个数。每隔五个数就会有一个
    5 的倍数，它为 *n*! 贡献一个因子 5。直到 `n`，总共有 `floor of n/5` 个 5 的倍数。此外，还有来自更高次方的因子 5 的额外因子。例如，每隔
    25 个数就会有一个 25 的倍数，贡献一个额外的因子 5；每隔 125 个数就会有一个 125 的倍数，贡献又一个额外的因子 5。[图 A-25](app01.xhtml#chAfig25)中的程序第一次通过
    `repeat until` 循环时只计算因子 5，然后通过循环的额外周期来计算来自更高次方因子 5 的额外因子。
- en: '![Image](../images/pg212_Image_272.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg212_Image_272.jpg)'
- en: '*Figure A-25: Calculating the number of zeros at the end of* n *factorial*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-25：计算 n 阶乘末尾的零的个数*'
- en: The program reports that there are six zeros at the end of 25 factorial.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 程序报告显示 25 的阶乘末尾有六个零。
- en: Challenge 5.2
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 5.2
- en: You can adapt the row-generating program from [Project 19](ch05.xhtml#ch05lev7)
    ([Figure 5-7](ch05.xhtml#ch5fig7)) to grab row entries after the row is calculated.
    [Figure A-26](app01.xhtml#chAfig26) shows a custom block to calculate the row
    and extract the *k*th entry. You could also do the calculation as a quotient of
    factorials, as we did in [Project 18](ch05.xhtml#ch05lev4) ([Figure 5-1](ch05.xhtml#ch5fig1)),
    but this way gives answers that are accurate for more rows.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以改编来自[项目 19](ch05.xhtml#ch05lev7)的行生成程序（[图 5-7](ch05.xhtml#ch5fig7)），在计算出行之后提取行条目。[图
    A-26](app01.xhtml#chAfig26)展示了一个自定义块，用于计算该行并提取 *k* 位置的条目。你也可以像我们在[项目 18](ch05.xhtml#ch05lev4)中做的那样（[图
    5-1](ch05.xhtml#ch5fig1)）通过阶乘的商来进行计算，但这种方法在处理更多行时能提供更准确的结果。
- en: '![Image](../images/pg213_Image_273.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg213_Image_273.jpg)'
- en: '*Figure A-26: Calculating a specific binomial coefficient*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-26：计算特定的二项式系数*'
- en: You’ll want to call this custom block repeatedly for successive values of `n`
    while holding `k` constant at `2`, adding each set of results to its own list.
    You should find that the numbers down the *C*(*n*, 2) diagonal are the triangular
    numbers.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要重复调用这个自定义块，用连续的`n`值，每次保持`k`为`2`不变，将每组结果添加到它自己的列表中。你应该会发现，*C*(*n*, 2) 对角线上的数字就是三角形数字。
- en: Challenge 5.3
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 5.3
- en: The trick is to take mod 2 of each value, so even numbers end up as 0s and odd
    numbers end up as 1s. [Figure A-27](app01.xhtml#chAfig27) shows an interpretation
    of the first 32 rows of Pascal’s triangle, mod 2\. Here, the 1s are visualized
    as black squares and the 0s as blank spaces.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍是对每个值取模 2，这样偶数变成 0，奇数变成 1。[图 A-27](app01.xhtml#chAfig27)显示了前 32 行帕斯卡三角形模 2
    的一种解释。在这里，1 被可视化为黑色方块，0 则为空白空间。
- en: '![Image](../images/pg214_Image_274.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg214_Image_274.jpg)'
- en: '*Figure A-27: Pascal’s triangle mod 2*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-27：帕斯卡三角形模 2*'
- en: The resulting pattern is known as the Sierpiński triangle. It’s a famous example
    of a *fractal*, a pattern that repeats itself at different scales.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的模式被称为谢尔宾斯基三角形。这是一个著名的*分形*例子，一种在不同尺度上重复的模式。
- en: Challenge 5.4
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 5.4
- en: You can use the custom `gcd` block from [Project 9](ch02.xhtml#ch02lev14) (see
    [Figure 2-17](ch02.xhtml#ch2fig17)) to filter the row and column indices, then
    include in the table only entries where the row and column indices are both relatively
    prime to the modulus. [Figure A-28](app01.xhtml#chAfig28) shows the updates to
    the code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用来自[项目 9](ch02.xhtml#ch02lev14)的自定义`gcd`块（参见[图 2-17](ch02.xhtml#ch2fig17)）来筛选行和列索引，然后在表格中只包含那些行和列索引都与模数互质的条目。[图
    A-28](app01.xhtml#chAfig28)显示了代码的更新。
- en: '![Image](../images/pg214_Image_275.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg214_Image_275.jpg)'
- en: '*Figure A-28: Restricting the operations table to rows and columns that are
    relatively prime to the modulus*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-28：将运算表限制为与模数互质的行和列*'
- en: The stack on the left goes in the definition for the `Make index row` block
    (see [Figure 5-15](ch05.xhtml#ch5fig15)), taking the place of the `set row` block
    inside the `repeat modulus` loop. The stack on the right goes into the main program
    stack (see [Figure 5-17](ch05.xhtml#ch5fig17)), replacing the current `add row
    to table` block.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的堆栈用于`Make index row`块的定义（参见[图5-15](ch05.xhtml#ch5fig15)），取代`repeat modulus`循环中的`set
    row`块。右侧的堆栈则放入主程序堆栈（参见[图5-17](ch05.xhtml#ch5fig17)），替换当前的`add row to table`块。
- en: With these changes, the mod 12 multiplication table comes out looking like [Figure
    A-29](app01.xhtml#chAfig29).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，模12的乘法表的显示效果如[图A-29](app01.xhtml#chAfig29)所示。
- en: '![Image](../images/pg214_Image_276.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg214_Image_276.jpg)'
- en: '*Figure A-29: A reduced multiplication table mod 12*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*图A-29：模12的简化乘法表*'
- en: Challenge 5.5
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战5.5
- en: You can modify the custom `power` block from [Project 12](ch03.xhtml#ch03lev7)
    (see [Figure 3-7](ch03.xhtml#ch3fig7)) to work with modular arithmetic so it takes
    in a base and a power and calculates the appropriate power of the base, mod `p`.
    Then, you can build a custom Boolean block to test if a particular number `n`
    is a primitive root of a particular prime `p`. [Figure A-30](app01.xhtml#chAfig30)
    shows these two blocks.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以修改[项目12](ch03.xhtml#ch03lev7)中的自定义`power`块（参见[图3-7](ch03.xhtml#ch3fig7)），使其与模运算一起工作，从而接受一个基数和一个指数并计算该基数的适当幂，模`p`。然后，你可以构建一个自定义的布尔块，测试一个特定的数字`n`是否是一个特定素数`p`的原根。[图A-30](app01.xhtml#chAfig30)展示了这两个块。
- en: '![Image](../images/pg215_Image_277.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg215_Image_277.jpg)'
- en: '*Figure A-30: Looking for a primitive root*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图A-30：寻找原根*'
- en: The loop in the `primitive root?` block goes to `p - 2` because if you haven’t
    found a power of `n` that equals 1 by this time, the last power will be 1, and
    `n` will be a primitive root.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`primitive root?`块中的循环会到达`p - 2`，因为如果此时还没有找到一个`n`的幂等于1，那么最后一个幂将是1，`n`将是一个原根。'
- en: With those pieces, the main program is just a loop to ask for a prime and find
    the first number that works as a primitive root. Two math questions to consider
    as a follow-up are why primes must have primitive roots and whether primitive
    roots exist for any composite numbers.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些组件，主程序就是一个循环，用于询问一个素数并找到第一个可以作为原根的数字。作为后续，你可以考虑的两个数学问题是：为什么素数必须有原根，以及是否所有复合数都有原根。
- en: Challenge 5.6
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战5.6
- en: You can strip down the `Make index row` block from [Figure 5-15](ch05.xhtml#ch5fig15)
    to eliminate the work of formatting the table with an index row and padding appropriately
    with spaces. Then, modify the custom `pad` block in [Figure 5-16](ch05.xhtml#ch5fig16)
    to insert a comma before `x` instead of one or more spaces.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以精简[图5-15](ch05.xhtml#ch5fig15)中的`Make index row`块，去除格式化表格时的索引行和适当填充空格的工作。然后，修改[图5-16](ch05.xhtml#ch5fig16)中的自定义`pad`块，在`x`之前插入逗号，而不是一个或多个空格。
- en: You might also want to strip off the initial comma at the start of each row
    before adding it to the table. You can do that with another custom block. Scratch
    doesn’t have a command to identify and modify characters in strings the way it
    lets us work with elements of lists, so you can just rewrite the string from the
    second character on, as shown in [Figure A-31](app01.xhtml#chAfig31).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想在将每一行添加到表格之前，去除每一行开头的初始逗号。你可以通过另一个自定义块来完成这个操作。Scratch并没有像处理列表元素那样让我们处理字符串中的字符，所以你可以像[图A-31](app01.xhtml#chAfig31)所示，从第二个字符开始重写字符串。
- en: '![Image](../images/pg216_Image_278.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg216_Image_278.jpg)'
- en: '*Figure A-31: Removing the first character from a string*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*图A-31：从字符串中移除第一个字符*'
- en: '[Chapter 6: Making Codes, and Cracking Them Too](ch06.xhtml)'
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[第6章：制作代码，并破解它们](ch06.xhtml)'
- en: Challenge 6.1
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战6.1
- en: Make a single ring of letters in your favorite drawing program, similar to [Figure
    A-32](app01.xhtml#chAfig32). Import it into Scratch as a sprite labeled `Outer
    Wheel`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在你喜欢的绘图程序中绘制一个字母环，类似于[图A-32](app01.xhtml#chAfig32)。将其导入Scratch作为标记为`Outer Wheel`的精灵。
- en: '![Image](../images/pg216_Image_279.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg216_Image_279.jpg)'
- en: '*Figure A-32: A letter ring*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*图A-32：字母环*'
- en: Now shrink the `Outer Wheel` sprite to make a new sprite that’s small enough
    to fit inside it, and label this `Inner Wheel`. The only code you need is a bit
    of code to manipulate the smaller sprite, as shown in [Figure A-33](app01.xhtml#chAfig33).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，缩小`Outer Wheel`精灵，制作一个足够小以适应其中的精灵，并将其标记为`Inner Wheel`。你需要的唯一代码是一些操作小精灵的代码，如[图A-33](app01.xhtml#chAfig33)所示。
- en: '![Image](../images/pg216_Image_280.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg216_Image_280.jpg)'
- en: '*Figure A-33: Rotating* Inner Wheel *one letter at a time*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-33：每次旋转* 内轮 *一个字母*'
- en: This code rotates the inner wheel to the left or right. The angle of 13.846
    degrees is 360 / 26, so each key press shifts the inner wheel by one letter at
    a time relative to the outer wheel.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将内轮旋转到左侧或右侧。13.846度的角度是 360 / 26，因此每次按键都会使内轮相对于外轮移动一个字母。
- en: Challenge 6.2
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 6.2
- en: H becomes I, A becomes B, and L becomes M (see [Figure A-34](app01.xhtml#chAfig34)).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: H 变成 I，A 变成 B，L 变成 M（见[图 A-34](app01.xhtml#chAfig34)）。
- en: '![Image](../images/pg217_Image_281.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg217_Image_281.jpg)'
- en: '*Figure A-34: Shifting “HAL” by 1*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-34：将 “HAL” 移位 1*'
- en: Challenge 6.3
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 6.3
- en: '*Yes* in French is *oui*. Your decoder ring can translate this word for you
    using a shift of 16: Y becomes O, E becomes U, and S becomes I (see [Figure A-35](app01.xhtml#chAfig35)).
    Sadly, its magical translation capabilities don’t extend much further!'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*是的* 用法语是 *oui*。你的解码环可以通过移位 16 来翻译这个单词：Y 变成 O，E 变成 U，S 变成 I（见[图 A-35](app01.xhtml#chAfig35)）。遗憾的是，它的神奇翻译能力并不能延伸得太远！'
- en: '![Image](../images/pg217_Image_282.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg217_Image_282.jpg)'
- en: '*Figure A-35: YES?*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-35：YES？*'
- en: Challenge 6.4
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 6.4
- en: This is a job for the program from [Project 23](ch06.xhtml#ch06lev5) (see [Figure
    6-9](ch06.xhtml#ch6fig9)). A shift of 16 reveals the message “THERE WILL BE A
    HOT TIME IN THE OLD TOWN TONIGHT!”
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这是[项目 23](ch06.xhtml#ch06lev5)中的程序（见[图 6-9](ch06.xhtml#ch6fig9)）的工作。移位 16 后，解密得到消息：“THERE
    WILL BE A HOT TIME IN THE OLD TOWN TONIGHT！”
- en: Challenge 6.5
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 6.5
- en: The trouble here is that, due to the order of operations, the multiplication
    happens before the shift when you run the linear transformation code. If you try
    to undo both at once, the multiplier acts on the shift as well, so the shift ends
    up being incorrect. This is why we originally performed the decryption in two
    steps, to force the shift to be reversed before the multiplication.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，由于操作顺序的关系，乘法在执行线性变换代码时发生在移位之前。如果你尝试同时撤销两者，乘数也会作用于移位，导致移位结果错误。这就是我们最初将解密过程分为两步进行的原因，以强制在乘法之前先撤销移位。
- en: If *s* is the original shift factor, the fix is to take –*s* and multiply it
    by the modular inverse (mod the alphabet size). Then, use the result as the new
    shift factor for the decryption, while using the modular inverse as the new multiplier.
    This way, when the multiplier is applied, the inverse cancels out and you get
    the shift you want.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *s* 是原始的移位因子，那么解决方法是取 –*s* 并将其乘以模逆（对字母表大小取模）。然后，使用该结果作为解密的新移位因子，同时将模逆作为新的乘数。这样，当乘数应用时，逆元会相互抵消，从而得到你想要的移位。
- en: Challenge 6.6
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 6.6
- en: The program in [Figure A-36](app01.xhtml#chAfig36) achieves this. After prompting
    for a `modulus`, which is the alphabet size, and a `multiplier`, it calls our
    custom `gcd` block (from [Figure 2-17](ch02.xhtml#ch2fig17)) to make sure a modular
    inverse exists. The program exits if no inverse exists, and otherwise it calculates
    the inverse by trial and error ❶. Then, it prompts for the `shift` and calculates
    the inverse transformation’s shift ➋.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 A-36](app01.xhtml#chAfig36)中的程序实现了这一点。在提示输入 `modulus`（字母表的大小）和 `multiplier`（乘数）后，它调用我们自定义的
    `gcd` 模块（来自[图 2-17](ch02.xhtml#ch2fig17)）来确保存在模逆。如果不存在模逆，程序将退出，否则它将通过试错法计算出逆元❶。然后，程序会提示输入
    `shift` 并计算出逆变换的移位 ➋。'
- en: '![Image](../images/pg218_Image_283.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg218_Image_283.jpg)'
- en: '*Figure A-36: Finding the numbers to undo a linear transformation cipher*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 A-36：寻找数字以撤销线性变换密码*'
- en: Challenge 6.7
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 6.7
- en: If the multiplier isn’t relatively prime to the alphabet size, the scrambled
    alphabet won’t be complete. Some letters will occur more than once, and others
    won’t appear at all. Also, there’s no modular inverse, so no decryption is possible.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果乘数与字母表的大小不是互质的，那么打乱的字母表将不完整。一些字母会重复出现，其他字母则完全不会出现。另外，也没有模逆，因此无法进行解密。
- en: Challenge 6.8
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战 6.8
- en: You can reuse some of the code we wrote earlier in the chapter for this challenge,
    including the `Alphabet` block from [Figure 6-2](ch06.xhtml#ch6fig2) to build
    the `alphabet` list and the `Scramble` block from [Figure 6-19](ch06.xhtml#ch6fig19)
    to mix up the alphabet. You’ll also need an `Initialize` block to set up the `alphabet`
    list and prompt for a message (you won’t need it to prompt for a shift and a multiplier,
    since you’re going to generate all possible shifts and multipliers yourself),
    as well as our old friend the `gcd` block from [Project 9](ch02.xhtml#ch02lev14)
    ([Figure 2-17](ch02.xhtml#ch2fig17)). [Figure A-37](app01.xhtml#chAfig37) shows
    the new code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg219_Image_284.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-37: Generating every possible linear transformation decryption*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The outer `repeat` loop moves through every possible multiplier ❶, while the
    inner `repeat` loop moves through every possible shift for that multiplier ➌.
    Together, these loops generate every possible linear transformation, using `Scramble`
    to mix up the alphabet based on the current `multiple` and `shift` parameters
    ➍. Each possible message is built up character by character in the `encrypted`
    variable, then added to the list of possible decodings ➎. Before exploring a given
    multiplier, the `gcd` test ➋ confirms that the multiplier and the alphabet size
    are relatively prime. This indicates that a modular inverse exists for the multiplier
    and therefore that the multiplier is valid.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 6.9
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An easy way to mix up the alphabet is to swap each letter with a random letter.
    [Figure A-38](app01.xhtml#chAfig38) shows a program that does this using a custom
    `swap` block. Notice that you need an extra variable, `x`, to temporarily hold
    one of the swapped values.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg220_Image_285.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-38: Randomly scrambling the alphabet*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to see the entire scrambled alphabet on the stage, you can build
    a string from the `alphabet` list, adding one character at a time (see [Figure
    A-39](app01.xhtml#chAfig39)).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg221_Image_286.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-39: Viewing the scrambled alphabet as a single string*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 6.10
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Start with an extension of the `gcd` code, shown in [Figure A-40](app01.xhtml#chAfig40),
    that remembers the quotients and remainders as `qlist` and `rlist`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg221_Image_287.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-40: Listing quotients and remainders from Euclid’s algorithm*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: You can now make linear combinations of the remainders to represent the greatest
    common divisor. As you substitute up from the bottom, you end up with a linear
    combination of the original numbers `a` and `b` that gives the GCD. [Figure A-41](app01.xhtml#chAfig41)
    shows how this works.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg222_Image_288.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-41: Finding* x *and* y'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: As an example, if you ask the program to use *b* = 26 and *a* = 17, you’ll end
    up with `x = 2` and `y = -3`. That means (2 ⋅ 26) – (3 ⋅ 17) = 1, which tells
    you that –3 ⋅ 17 ≡ 1 mod 26\. So you can use –3, or 26 – 3 = 23, as the modular
    inverse for 17\. [Figure A-42](app01.xhtml#chAfig42) shows the output for this
    scenario.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg223_Image_289.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-42: Identifying –3 (or +23) as the modular inverse of 17*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 6.11
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The logic of this program is in its main part, shown in [Figure A-43](app01.xhtml#chAfig43).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg223_Image_290.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-43: Guessing a letter and seeing how it fits*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The custom `Initialize` block asks for a cryptogram to solve and sets up the
    stage display, showing the puzzle and the shape of its solution. Then, the `forever`
    loop asks for a letter in the puzzle to guess and what it should be replaced with.
    It’s easier to process the guess if the solution is maintained as a list of individual
    characters rather than as a string, so there’s some background coding to convert
    back and forth between `Solution`, which is displayed, and `Solution list`, which
    remains hidden. The bookkeeping is done in the `update` block, shown in [Figure
    A-44](app01.xhtml#chAfig44).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg224_Image_291.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-44: Updating the solution*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 6.12
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure A-45](app01.xhtml#chAfig45) shows a quick way to tell whether a character
    is a letter or not. The Boolean variable `letterQ` is set to `true` for upper-
    or lowercase letters, or `false` otherwise. (The `contains` block doesn’t care
    about capitalization.)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg224_Image_292.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-45: Testing for letters of the alphabet*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Once you have this block, you can use it to test each character in a string,
    one at a time. Keep only those characters that result in a `letterQ` value of
    `true`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7: Experiments in Counting](ch07.xhtml)'
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Challenge 7.1
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The program in [Figure A-46](app01.xhtml#chAfig46) lists Catalan numbers using
    the alternative recurrence.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg225_Image_293.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-46: Another Catalan recurrence*'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: The calculation is implemented inside the `repeat` loop ❶. Notice that the formula
    is a single-term recurrence, meaning we need only *C*(*n* – 1) to calculate *C*.
    This means we can just use the `C` variable over and over, without having to look
    up earlier values in the list. Also, term *C*(0) doesn’t have to be included in
    the list at all, so the list’s index numbers are correct from the start. This
    recurrence produces accurate values up to flintmax.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 7.2
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The input for this program will be a row of the `Catalan` list generated by
    the code for [Project 28](ch07.xhtml#ch07lev3) ([Figures 7-1](ch07.xhtml#ch7fig1)
    through [7-3](ch07.xhtml#ch7fig3)), consisting of forward slash (`/`) and backslash
    (`\`) characters. Say you’ve extracted one of the rows into the `input pattern`
    variable. You can then draw the pattern with the code in [Figure A-47](app01.xhtml#chAfig47).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg226_Image_294.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-47: Visualizing Catalan paths*'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: The custom `draw` block sets `step size` to make the drawing fit nicely on the
    stage. Then, the `repeat` loop in the main stack uses the characters as a recipe
    for drawing the diagram, ignoring all characters in `input pattern` except for
    the slashes. It draws a diagonal line upward for each forward slash and a diagonal
    line downward for each backslash.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 7.3
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The pattern to notice is that the *n*th Catalan number is *C*(2*n*, *n*) / (*n*
    + 1).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 7.4
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All you have to do is change every `/` to a left parenthesis and every `\` to
    a right parenthesis. To label the parentheses with letters (placing the label
    after a left parenthesis and before a right parenthesis) so it looks like a multiplication
    problem, it might be easiest to do two passes through each string in the `Catalan`
    list. The first pass can change each slash to the appropriate parenthesis and
    add a placeholder symbol for a letter (the code in [Figure A-48](app01.xhtml#chAfig48)
    uses a `+` symbol). The second pass can then replace each placeholder with the
    next unused letter in the alphabet.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg227_Image_295.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-48: Representing Catalan numbers with parentheses*'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure A-49](app01.xhtml#chAfig49) shows what the output would look like for
    a given input string.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg227_Image_296.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-49: The* pretty output *variable substitutes letters for plus signs.*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Challenges 7.5 and 7.6
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s assume that a partition is presented as a string of summands connected
    by + signs, as we saw in the list shown in [Figure 7-15](ch07.xhtml#ch7fig15).
    We’ll also assume the summands are in increasing order. Since you need to look
    at each summand, the first step could be to change the string into a list of individual
    summands called `parts`. Then, you can define custom blocks to report Boolean
    values if the list has no even elements (say, `oddpartsQ`) and if the list has
    no duplicated elements (say, `distinctpartsQ`). The output might look like [Figure
    A-50](app01.xhtml#chAfig50).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg228_Image_297.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-50: Testing for all odd and all distinct summands*'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: An interesting observation made by mathematician Leonhard Euler, the namesake
    of Project Euler, is that the number of partitions of *n* with only odd summands
    is the same as the number of partitions of *n* with all distinct summands.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 7.7
  id: totrans-307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Ramanujan made two other observations that are relevant here: the number of
    partitions of any number that is 5 more than a multiple of 7 is itself divisible
    by 7, and the number of partitions of any number that is 6 more than a multiple
    of 11 is itself divisible by 11\. For example, *P*(19) = *P*(2 ⋅ 7 + 5) = 490,
    a multiple of 7, and *P*(17) = *P*(1 ⋅ 11 + 6) = 297, a multiple of 11.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8: Three Helpings of Pi](ch08.xhtml)'
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Challenge 8.1
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The length of the perimeter of the inscribed triangle is equal to 3![Image](../images/pg228_Image_299.jpg),
    so we should take *b*, the lower bound, to be 3![Image](../images/pg228_Image_299.jpg)
    / 2\. The length of the perimeter of the circumscribed triangle is equal to 6![Image](../images/pg228_Image_299.jpg),
    so *a* should be half of that, or 3![Image](../images/pg228_Image_299.jpg). [Figure
    A-51](app01.xhtml#chAfig51) shows these new starting values.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg228_Image_298.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-51: Starting values for the inscribed and circumscribed triangles*'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: As [Figure A-52](app01.xhtml#chAfig52) shows, running the program with these
    starting values does indeed produce the same results, from the second line on,
    as running it with starting values from hexagons.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg228_Image_300.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-52: The first few rows of output, starting from triangles*'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 8.2
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All you need to do to choose random non-integer coordinates is change the two
    `set` blocks ➋ in [Figure 8-11](ch08.xhtml#ch8fig11). The updated blocks are shown
    in [Figure A-53](app01.xhtml#chAfig53).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg229_Image_301.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-53: Randomly choosing non-integer coordinates*'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Not only does the code still work with non-integers, but it also gives much
    better approximations of *π*.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 8.3
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure A-54](app01.xhtml#chAfig54) shows a loop to calculate a partial sum
    for the series up to a given number of terms.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg229_Image_302.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-54: Calculating partial sums for π²/6*'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: There are two hacks to notice here. First, we’re using a custom block to calculate
    the *n*th term of the series ❶. That makes it easy to adapt the code to study
    other series. In this case, the custom block calculates 1/*n*², as shown in [Figure
    A-55](app01.xhtml#chAfig55).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg230_Image_303.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-55: Calculating one term of the sum*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: The second hack is that once we’ve generated a list of *n* terms in the series,
    we find their sum by adding backward from the last term to the first ➋. This is
    necessary because the series consists of decreasing terms, and some of the decimal
    places of the later terms might be wiped out if they were added to the sum of
    the prior (larger) terms.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: If you run this program for increasingly more terms, you’ll approach the value
    of *π*²/6, which is approximately 1.644934.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 8.4
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can reuse the code from Challenge 8.3 that sums the first *n* terms in a
    series to solve this problem. You just need to define a different custom block
    for calculating each term, as shown in [Figure A-56](app01.xhtml#chAfig56).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg230_Image_304.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-56: Calculating one term of the sum for π/4*'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: This time, the terms being added are odd integers, not squares, and the signs
    alternate from one term to the next. So you need to introduce a new variable,
    `sign`, that switches back and forth between `1` and `-1` for each term.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: The value to aim for is about 0.785398, but alternating series are notoriously
    slow to converge, so it might take a while to get there. Multiplying this value
    by 4 gives an approximation of *π*.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 8.5
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The series in Challenge 8.3 consistently reports the first three digits of *π*
    correctly after 202 terms. For the alternating series in Challenge 8.4, it takes
    626 terms before the first three digits are stable.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 8.6
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unlike in the random sampling code for [Project 31](ch08.xhtml#ch08lev6), you
    don’t have the option of using non-integer coordinates (see [Challenge 8.2](app01.xhtml#app01lev73))
    here because you need integers to calculate a GCD. You can still use the `pick
    random` block to generate random lattice points, though. The code in [Figure A-57](app01.xhtml#chAfig57)
    has a loop using random choices of lattice point coordinates.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg231_Image_305.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-57: Randomly sampling lattice points*'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: It gives approximations for *π* that are about as good as the exhaustive enumeration
    using the code in [Figure 8-13](ch08.xhtml#ch8fig13).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9: What Next?](ch09.xhtml)'
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Challenge 9.1
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure A-58](app01.xhtml#chAfig58) shows a program that finds the sum of the
    multiples of any two numbers up to a limit.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg232_Image_306.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-58: Finding the sum of any two multiples*'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Instead of hardcoding the values of `3` and `5` into the program, as we did
    in [Project 33](ch09.xhtml#ch09lev3), here we take in two values from the user
    and reference them as the `first` and `second` variables.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 9.2
  id: totrans-350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You might think you can just multiply the two numbers together to get the correction,
    but that won’t work if the numbers aren’t relatively prime. Instead, you need
    to find the least common multiple (LCM) of the two numbers (which for relative
    primes happens to be the equivalent of their product). Calculating the LCM is
    easy using our `gcd` code from [Project 9](ch02.xhtml#ch02lev14) ([Figure 2-17](ch02.xhtml#ch2fig17)),
    since the LCM of *b* and *a* is the product of *b* and *a* divided by their GCD,
    as we noted in [Chapter 3](ch03.xhtml#ch03).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure A-59](app01.xhtml#chAfig59) shows an updated program that sums the
    multiples of any two numbers using the triangular number trick and the LCM for
    inclusion–exclusion.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg233_Image_307.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
- en: '*Figure A-59: Summing the multiples of any two numbers*'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: We use a custom `lcm` block, which first calls our trusty `gcd` block and then
    calculates the LCM based on the result.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Challenge 9.3
  id: totrans-356
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the multiples are *a*, *b*, and *c*, first add the multiples of *a*, *b*,
    and *c* separately, then subtract the multiples of *a* ⋅ *b*, *a* ⋅ *c*, and *b*
    ⋅ *c*. Finally, add the multiples of *a* ⋅ *b* ⋅ *c* back in.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
