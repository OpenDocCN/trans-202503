- en: '**19**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**RECEIVING FILE INPUT AND OUTPUT**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The programs you’ve written so far in this book took input from the keyboard
    and sent output to the screen. But what if you wanted to create a virtual phone
    book and use thousands of lines of data in the program? Working with that much
    data could make it difficult to write and maintain your program. You’d have to
    input every name and phone number each time you ran the program!
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, a program can also receive input from a file and send its output
    to a file, and both files can be saved on your computer. So all the phone book
    information could be neatly tucked away in a file, and you’d only have to input
    the data once. Today, many programs process data that is stored in files.
  prefs: []
  type: TYPE_NORMAL
- en: In most programming languages, working with files is an advanced topic, but
    Small Basic makes file handling super simple. In this chapter, you’ll learn about
    the `File` object and how it makes working with files a breeze!
  prefs: []
  type: TYPE_NORMAL
- en: '**The Case for Files**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In your programs, you’ve used variables and arrays to store data. But data
    stored in variables and arrays is temporary: all that data is lost when the program
    ends or when you turn off your computer. When you run your program again, it won’t
    remember the input you entered the last time it ran. If you want to permanently
    store the data created in a program, you need to save that data in a file. Data
    stored in files is called *persistent data* because it’s retained even after you
    turn off your computer. It’s as persistent as a squirrel caching acorns.'
  prefs: []
  type: TYPE_NORMAL
- en: Files provide a convenient way to handle large amounts of data. If your program
    requires lots of data (like the names of your friends), you can’t ask a user to
    input that data each time they run the program. Most likely, they will get annoyed
    and stop using the program. If a program can read its input data from a file,
    a user won’t need to enter data by hand and might want to run the program many
    times. When programs use files, a user could even customize the application by
    changing the data file. For example, if you write a spelling game that reads its
    input from a file, the user can set the game’s difficulty by changing the input
    file. For example, they could use short words for an easy game and long words
    for a more difficult game.
  prefs: []
  type: TYPE_NORMAL
- en: Getting data from a file is called *reading the file*, and the files a program
    reads are generally called *input files*. Similarly, sending data to a file is
    called *writing to the file*, and the files a program writes to (or creates) are
    called *output files*. Storing data to (and reading data from) files on disk is
    called *file access*. Working with files is called *file I/O*, which is short
    for input/output.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start working with files in programs, let’s look at filenames and
    how files are saved on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: '***Naming Files***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you create a new file, you give it a name. You can call it *Fred* or *DontOpenMe*
    if you want, but it’s usually best to name it more specifically, such as *myFriends*
    or *myLoveStory*.
  prefs: []
  type: TYPE_NORMAL
- en: The Windows operating system is case insensitive and doesn’t see any difference
    between uppercase and lowercase letters in filenames, so *myFile*, *Myfile*, and
    *MYFILE* would all refer to the same file. Windows also supports filenames with
    two parts that are separated by a period, such as *myFile.dat*. The part following
    the period (*dat* in this example) is called the *file extension*. The file extension
    usually indicates what kind of file it is (such as a photo or text file). [Table
    19-1](ch19.html#ch19table1) lists some of the most common file extensions and
    their meanings. File extensions are usually added automatically by the programs
    you use. For example, the Small Basic IDE adds an *.sb* extension to source code
    files.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 19-1:** Common File Extensions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Extension** | **File type** | **Used for** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *.dat* | General data file | Storing information about a specific application
    |'
  prefs: []
  type: TYPE_TB
- en: '| *.exe* | Executable file | Applications |'
  prefs: []
  type: TYPE_TB
- en: '| *.gif* | Graphic Interchange Format | Website images |'
  prefs: []
  type: TYPE_TB
- en: '| *.html* | Hypertext Markup Language website file | Web pages |'
  prefs: []
  type: TYPE_TB
- en: '| *.jpg* | An image encoded with the JPEG standard | Photos from a digital
    camera |'
  prefs: []
  type: TYPE_TB
- en: '| *.mp3* | Music encoded in MPEG layer 3 audio format | Audio files |'
  prefs: []
  type: TYPE_TB
- en: '| *.pdf* | Portable Document Format file for reading | Ebooks |'
  prefs: []
  type: TYPE_TB
- en: '| *.txt* | General text file | Notes you might write in Notepad |'
  prefs: []
  type: TYPE_TB
- en: You’ll be working with text (*.txt*) files in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '***File Organization***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine dozens of books organized in a cabinet with several shelves. Each shelf
    has a different label (such as Science, Math, Novels, Dr. Seuss, and so on) and
    is filled with books in that category. Each shelf serves as a container that groups
    related books together. Similarly, files on a computer are stored in containers
    called *directories* (or *folders*). A directory can contain files as well as
    other directories. A directory within a directory is called a *subdirectory*.
  prefs: []
  type: TYPE_NORMAL
- en: The *filesystem* is the part of the operating system that is responsible for
    organizing files and directories on a computer and providing ways to manage them.
    When you call a file-related method from your Small Basic program (to create,
    delete, read from, or write to a file), the operating system’s filesystem handles
    all the low-level details for you, so you don’t have to worry whether the actual
    files are stored on a hard drive, flash memory, a CD, a DVD, and so on. The Small
    Basic library talks to the operating system to access files stored on various
    media, as illustrated in [Figure 19-1](ch19.html#ch19fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f19-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-1: How the filesystem lets you access files on different media*'
  prefs: []
  type: TYPE_NORMAL
- en: The filesystem has a tree structure, like the one shown in [Figure 19-2](ch19.html#ch19fig2).
    The top of the tree is called the *root directory* (the drive letter *D:* in this
    figure). The root directory has a number of files and other directories under
    it. Each of these directories might contain other files and subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: You can locate any file by following a path from the root directory down the
    tree until you reach that file. The sequence of directories you follow makes up
    the *pathname* for the file. For example, to find the last file in [Figure 19-2](ch19.html#ch19fig2),
    you would look in the root directory *D:*, then in *Book*, and then in *Chapter03*
    to locate the file. If you write the path using a backslash (\) to separate each
    directory, the pathname is *D:\Book\Chapter03\Ch03.docx*. You can locate each
    file on the system using its pathname.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f19-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-2: The filesystem as a tree*'
  prefs: []
  type: TYPE_NORMAL
- en: To access a file from a Small Basic program, you need to specify the file’s
    pathname. To learn how, look at the executable file *Test.exe* in [Figure 19-2](ch19.html#ch19fig2).
    When you run this file, the running program knows its *current directory* (which
    is *D:\Book\Chapter01\Examples* in this case). If you want *Test.exe* to access
    a data file (such as *Test1.dat* or *Test2.dat*), you need to specify the pathname—the
    sequence of folders, starting from the root, that the program needs to navigate
    to reach the file. This is also called the *absolute path*. In [Figure 19-2](ch19.html#ch19fig2),
    the absolute path for *Test1.dat* is *D:\Book\Chapter01\Examples\Test1.dat*, and
    the absolute path for *Test2.dat* is *D:\Book\Chapter01\Examples\Data\Test2.dat*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you write a program that only you will use, you can save the data files
    needed by this program anywhere you like and access these files using absolute
    paths hardcoded in your program. For example, you can write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'But if you give this program to a friend to try, it will fail unless your friend
    has the same file tree as you. A better solution is to build the desired path(s)
    in your program at runtime, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now the program will add *Test1.dat* to the end of its current directory, which
    means it will look for *Test1.dat* in the same folder that the program is in.
    Then your friend only needs to place *Test.exe* and *Test1.dat* in the same folder;
    the absolute path will no longer matter. You can just zip your program’s folder
    (right-click the folder, click Send to, and click Compressed (zipped) folder)
    and send that ZIP file to your friend. Your friend can save the files contained
    in the ZIP file under *C:\*, *D:\*, *C:\Temp*, or any other folder of their choice,
    and your program will work as you designed it.
  prefs: []
  type: TYPE_NORMAL
- en: With an understanding of files and pathnames, you’re ready to learn about the
    `File` object and how to use its methods to read data from files, write data to
    files, and perform other file management operations. Let’s go single file!
  prefs: []
  type: TYPE_NORMAL
- en: '**The File Object**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Small Basic’s `File` object includes all the methods that handle reading and
    writing file data, deleting and copying files, and listing directory contents.
    Because this object supports many methods, this section is divided into two parts.
    First, we’ll explore the methods related to reading from and writing to files.
    Second, we’ll look at the methods related to file management.
  prefs: []
  type: TYPE_NORMAL
- en: '***File I/O Methods***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `File` object’s most frequently used methods are those used to write data
    to files and read data from files. Let’s explore these methods in detail.
  prefs: []
  type: TYPE_NORMAL
- en: To start, open Notepad and type some words in the editor so it looks like [Figure
    19-3](ch19.html#ch19fig3). Make sure that you don’t press ENTER after the last
    line.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f19-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-3: An example text file*'
  prefs: []
  type: TYPE_NORMAL
- en: Save the file as *Test1.txt* in *C:\Temp* so its absolute pathname is *C:\Temp\Test1.txt*.
    If you don’t want to create the file, you can find it in this chapter’s folder;
    just copy it to *C:\Temp*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reading from a File**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now let’s try reading the contents of *Test1.txt*. You can use the `File` object’s
    `ReadContents()` method to read the entire contents of a file at once. This method
    opens a file, reads it, and returns its entire contents as a string. Enter and
    run the program in [Listing 19-1](ch19.html#ch19ex1) to see how this method works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 19-1: Demonstrating the* `ReadContents()` *method*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output of this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Line 2 sets the file’s absolute path. Line 3 reads the entire contents of the
    file and saves the returned string in a variable named `str` using the `ReadContents()`
    method. `ReadContents()` takes one argument: the pathname of the file you want
    to read. Line 4 gets the length of the string and saves it in a variable named
    `len`. Lines 5–6 display the `str` and `len` variables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But why does `GetLength()` output 19 characters for the string’s length when
    the string `"This is a Test."` contains only 15? To understand what’s going on,
    you need to examine the actual characters that make up the `str` variable. Remember
    from [Chapter 18](ch18.html#ch18) that characters are encoded in a format (such
    as ASCII or Unicode). Add the following code to the end of [Listing 19-1](ch19.html#ch19ex1),
    and run the program again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code shows that the `str` variable has 19 characters. [Figure 19-4](ch19.html#ch19fig4)
    breaks down what the program is doing.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f19-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-4: The 19 characters of the* `str` *variable in [Listing 19-1](ch19.html#ch19ex1)*'
  prefs: []
  type: TYPE_NORMAL
- en: Notepad inserts two special characters (called *carriage return* and *line feed*,
    whose ASCII codes are 13 and 10) to mark the end of each line. Think of the *newline*
    (or end-of-line) marker as a pair of characters produced when you press ENTER
    on the keyboard. Without these characters, the lines in the file would run together
    in one long line. The newline characters are *control characters*; they only control
    the position of the cursor on the screen or the printer.
  prefs: []
  type: TYPE_NORMAL
- en: The `ReadContents()` method returns the entire contents of the file as a single
    string, including newline characters between lines in the file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing to a File**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `WriteContents()` method lets you save the contents of a string in a program
    to a file of your choice. If you want to create multiple lines of text, you need
    to insert the newline characters manually. For example, let’s write a program
    that reads text input from the keyboard and writes it back to a file. The program
    is shown in [Listing 19-2](ch19.html#ch19ex2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 19-2: Demonstrating the* `WriteContents()` *method*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample run of this program showing the user input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now open the output file *C:\Temp\Out.txt* in Notepad and check its contents.
    The file contains what the user entered in the text window. Pretty cool, huh?
    You wrote all of that text without using Notepad!
  prefs: []
  type: TYPE_NORMAL
- en: Here’s how the program works. We define the codes for the carriage return and
    the line feed characters in lines 2–3 and define the output file’s path in line
    4\. We then start a loop to get the user’s text (line 8–14). In each iteration
    of the loop, we prompt the user to enter any text they want (line 9) and read
    the input text into a variable named `strIn` (line 10). If the user enters any
    text other than `exit` (line 11), we append that text followed by a carriage return
    and line feed to the `strOut` string (line 12). When the user enters `exit`, the
    loop ends, and we call `WriteContents()` to write `strOut` to the output file
    (line 16). If the file doesn’t exist, `WriteContents()` automatically creates
    it. If the file does exist, `WriteContents()` overwrites its contents with whatever
    is in the `strOut` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRY IT OUT 19-1**'
  prefs: []
  type: TYPE_NORMAL
- en: Write a program that reads an input text file, converts the text to lowercase,
    and then saves the result to a new output file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Checking for Errors**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Similar to when you work with user input, you can’t control what the user saves
    in a file that your program reads. Sometimes the data in a file might be incorrect
    due to human error. Many things can go wrong (as you’ll see in a moment), and
    your programs need to be ready to handle these errors.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Small Basic is always prepared! A call to `WriteContents()` returns
    `"SUCCESS"` or `"FAILED"` automatically based on whether the operation was successful.
    A well-written program checks the returned string and takes action in case of
    failure. Let’s update [Listing 19-2](ch19.html#ch19ex2) to check the return value
    of `WriteContents()`. Replace the statement on line 16 with the code in [Listing
    19-3](ch19.html#ch19ex3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 19-3: Checking the return value of* `WriteContents()`'
  prefs: []
  type: TYPE_NORMAL
- en: First, we save the return of `WriteContents()` in a variable named `result`
    (line 1), and then we check the method’s return value. If the method succeeds
    (line 2), we inform the user that the output has been saved successfully (line
    3). If the operation fails (line 4), we tell the user that the program failed
    to write to the output file (line 5), and then we display the reason for the failure
    using the `File` object’s `LastError` property (line 6). This property is automatically
    updated by `WriteContents()` if writing to a file fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'After writing the code to handle the failure case, we need to test the code
    by making it fail on purpose. Here are some things that can cause `WriteContents()`
    to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: The path of the output file doesn’t exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The output file is already open in another program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is not enough space to save the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s experiment with the first possibility to see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: '**Path Doesn’t Exist**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Run the short program in [Listing 19-4](ch19.html#ch19ex4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 19-4: Writing to a file when the path doesn’t exist*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The program attempts to write the string `"Hello"` to an output file (lines
    2–3). The directory *Temp* exists, but the subdirectory *Folder1* doesn’t exist,
    so `WriteContents()` fails.
  prefs: []
  type: TYPE_NORMAL
- en: '**Appending to a File**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `AppendContents()` method opens the specified file and adds data to the
    end of the file without erasing its original contents. `AppendContents()` takes
    two arguments: the pathname of the output file and the string you want to append
    to the end of the file. If the operation is successful, the method returns `"SUCCESS"`;
    otherwise, it returns `"FAILED"`. If the file you pass to `AppendContents()` doesn’t
    exist, it’s created for you, and the string is written to it. If the file already
    exists, the string is appended to its end.'
  prefs: []
  type: TYPE_NORMAL
- en: To see the `AppendContents()` method in use, let’s say you need to maintain
    a log file that records actions, errors, and other events in your program. To
    keep the program simple, let’s just record the times when your program is executed.
    Every time your program runs, you add a record to a log file that includes the
    date and time. The complete program is shown in [Listing 19-5](ch19.html#ch19ex5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 19-5: Demonstrating the* `AppendContents()` *method*'
  prefs: []
  type: TYPE_NORMAL
- en: When you run this program, it creates a log string that contains the current
    day of the week, date, and time (line 4), and it appends this string to the end
    of a log file named *Log.txt* that is in the program’s directory (line 5). If
    writing to the file fails, the program displays an error message explaining the
    cause of the failure (lines 7–8). Then the program displays a message (line 11)
    and ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time you run this program, a new line is appended to the end of the *Log.txt*
    file. Here’s the output of *Log.txt* after running the program three times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**ReadLine(), WriteLine(), and InsertLine()**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `ReadContents()` and `WriteContents()` methods let you read and write the
    entire contents of a file at once. Sometimes this is just what you need. But in
    other situations, reading or writing one line at a time might be better.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `File` object provides the `ReadLine()` method for reading a single line
    of text from a file. A line of text consists of a string of characters that ends
    with a carriage return and line feed pair. `ReadLine()` reads all the text on
    that line up to (but not including) the carriage return character. This method
    takes two arguments: the path of the file and the line number of the text to be
    read. The first line of a file is line number 1, the second line is 2, and so
    on. If the file contains the specified line number, the method returns the text
    at that line. Otherwise, it returns an empty string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `File` object also provides the `WriteLine()` method for outputting a line
    of text to a file. This method takes three arguments: the path of the file, the
    line number to write text to, and the text to write. Keep the following information
    in mind when you’re using this method:'
  prefs: []
  type: TYPE_NORMAL
- en: If the file doesn’t exist, `WriteLine()` creates it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the file contains the specified line number, `WriteLine()` overwrites that
    line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the specified line number is larger than the number of lines in the file,
    the specified text is appended to the end of the file. For example, if the file
    contains three lines and you ask `WriteLine()` to write new text at line 100,
    the specified text is written at line 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`WriteLine()` automatically writes a carriage return and line feed at the end
    of the passed text. This means you don’t have to append these characters to your
    strings manually.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the operation is successful, `WriteLine()` returns `"SUCCESS"`; otherwise,
    it returns `"FAILED"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In addition to `ReadLine()` and `WriteLine()`, the `File` object provides the
    `InsertLine()` method for you to insert a line of text into a file, at a specified
    line number. As with the `WriteLine()` method, this method takes three arguments:
    the path of the file, the line number where you want the new text to be inserted,
    and the text you want to insert. `InsertLine()` won’t overwrite any existing content
    at the specified line. If the operation is successful, `InsertLine()` returns
    `"SUCCESS"`; otherwise, it returns `"FAILED"`.'
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s write a simple program that creates login names from the
    first and last names of users. The program will read an input file that contains
    the first and last names of users, and it will create an output file that contains
    the login names for these users. The login name for a user is composed of the
    first letter of the user’s first name and up to five characters from their last
    name. For example, if the user’s name is Jack Skellington, his login name is *jskell*.
    If the user’s name is Stan Lee (three-letter last name), his login name will be
    *slee*. The complete program is shown in [Listing 19-6](ch19.html#ch19ex6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 19-6: Creating login names from first and last names*'
  prefs: []
  type: TYPE_NORMAL
- en: We start by giving the paths for the input and output files (lines 2–3). We
    then start a loop to read the contents of the input file, one line at a time (lines
    6–19). After reading a line (line 7), we check whether that line is empty, and
    if it is (line 8), we set `N` equal to 0 to end the loop (line 9). Otherwise,
    we process the user’s name that is read from the input file to create the lowercase
    login name (lines 11–15). First, we find the space between the first name and
    the last name (line 11). Next, we get the first letter of the first name (line
    12) and the first five letters of the last name (line 13), combine them to create
    the login name (line 14), and convert the login name to lowercase (line 15). Then
    we write the login name to the output file (line 16) and increment `N` by 1 to
    read the next line in the input file (line 17).
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep the code simple, we didn’t add error-checking code. We also assumed
    that the input file was properly formatted: each line contained a user’s first
    and last names separated by a single space. [Table 19-2](ch19.html#ch19table2)
    shows an example input file for this program and the output file.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 19-2:** Creating Login Names'
  prefs: []
  type: TYPE_NORMAL
- en: '| **User’s name** | **Login name** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Tina Fey | *tfey* |'
  prefs: []
  type: TYPE_TB
- en: '| Jimmy Fallon | *jfallo* |'
  prefs: []
  type: TYPE_TB
- en: '| David Letterman | *dlette* |'
  prefs: []
  type: TYPE_TB
- en: '| Jay Leno | *jleno* |'
  prefs: []
  type: TYPE_TB
- en: '| Amy Poehler | *apoehl* |'
  prefs: []
  type: TYPE_TB
- en: '**TRY IT OUT 19-2**'
  prefs: []
  type: TYPE_NORMAL
- en: Write a program that reads an input file and counts the number of lines, characters,
    and spaces it contains.
  prefs: []
  type: TYPE_NORMAL
- en: '***File Management***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to the methods that let you perform file I/O, the `File` object
    also provides a couple of methods related to file and directory management. Using
    these methods, you can copy and delete files, create and delete directories, and
    list files and directories from your program.
  prefs: []
  type: TYPE_NORMAL
- en: '**Copying and Deleting Files**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can use the `CopyFile()` method to create a copy of an existing file. This
    method takes the pathnames of the source file and the destination file as arguments.
    The source file isn’t affected by this operation. If the operation is successful,
    the method returns `"SUCCESS"`. Otherwise, it returns `"FAILED"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the destination path points to a location that doesn’t exist, the method
    attempts to create it automatically. For example, look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If the subfolders *Temp*, *Temp1*, and *Temp2* don’t exist, `CopyFile()` attempts
    to create all the directories in the destination path, beginning with the root.
    When you run this code, you’ll have two copies of the *Test1.txt* file: the original
    source file and the duplicate file under *C:\Temp\Temp1\Temp2*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If the destination path points to an existing file, that file will be overwritten.
    So be careful when you use the* `CopyFile()` *method, because you might overwrite
    some of your files!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to delete a file, use the `DeleteFile()` method. This method takes
    one argument: the pathname of the file you want to delete. If the operation is
    successful, the method returns `"SUCCESS"`. Otherwise, it returns `"FAILED"`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The deleted file doesn’t go to the recycle bin; instead, it’s completely deleted
    from your system. So be extra careful when you use the* `DeleteFile()` *method!*'
  prefs: []
  type: TYPE_NORMAL
- en: Using `CopyFile()` and `DeleteFile()`, you can create your own subroutines for
    moving and renaming files. To move a file to a new location, copy the file to
    the new location and then delete the original file. To rename a file, make a copy
    of the file, give the copy a new name, and then delete the original file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating and Deleting Directories**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You can easily create or delete a directory. The `CreateDirectory()` method
    takes a single argument: the pathname of the directory you want to create. If
    the directories don’t exist, the method attempts to create all the directories
    in the path, beginning with the root. If the operation is successful, the method
    returns `"SUCCESS"`. Otherwise, it returns `"FAILED"`. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If the directories *C:\Temp*, *C:\Temp\Temp1*, and *C:\Temp\Temp1\Temp2* don’t
    exist, `CreateDirectory()` creates them. If the directory path already exists,
    the function does nothing and returns `"SUCCESS"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DeleteDirectory()` method also takes a single argument: the pathname of
    the directory you want to delete. All files and folders under the path are deleted.
    If the operation is successful, the method returns `"SUCCESS"`. Otherwise, it
    returns `"FAILED"`. [Figure 19-5](ch19.html#ch19fig5) shows an example of `DeleteDirectory()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f19-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-5: Demonstrating the* `DeleteDirectory()` *method*'
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When you call* `DeleteDirectory()`, *all the files and folders under the pathname
    are deleted. So make sure you don’t have any files tucked away that you don’t
    want to delete!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**List Files and Directories**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `File` object includes the `GetFiles()` method, which lets you list all
    the files in a directory. This method takes the path of the target directory as
    its argument. The example in [Listing 19-7](ch19.html#ch19ex7) shows you how to
    use this method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 19-7: Demonstrating the* `GetFiles()` *method*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output after running this program (change the `path` variable in
    line 2 to a directory on your computer):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We start by specifying the path of the directory we want to list (line 2). Next,
    we call `GetFiles()` with the desired path (line 3). This method creates an array
    that contains the pathnames of all the files in the directory; we save the identifier
    of the returned array in `fileArray`. Then we call `GetItemCount()` to find out
    the number of elements in the returned array (line 4) and use a `For` loop to
    display its elements (lines 6–8).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If* `GetFiles()` *fails, then* `fileArray` *stores the string* `"FAILED"`*.
    In this case, the call to* `Array.GetItemCount(fileArray)` *returns* `0`*. So
    you might not need to perform an extra check on the return of* `GetFiles()`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `GetDirectories()` method lets you list all the subdirectories in a given
    directory. [Listing 19-8](ch19.html#ch19ex8) shows an example of this method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 19-8: Demonstrating the* `GetDirectories()` *method*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output after running this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: But your output will probably look different, depending on what your *Temp*
    directory looks like. This program is similar to [Listing 19-7](ch19.html#ch19ex7).
    We start by storing the path we’re interested in (line 2). Next, we call `GetDirectories()`
    with the path (line 3). This method creates an array that contains the pathnames
    of all the directories in the specified path; we save the identifier of the returned
    array in `dirArray`. Then we call `GetItemCount()` to find out the number of elements
    in the returned array (line 4) and use a `For` loop to display its elements (lines
    6–8). Try changing line 2 to access a different directory.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’ve covered everything you need to know about the `File` object.
    Let’s put some of this newfound knowledge to work to create some cool applications!
  prefs: []
  type: TYPE_NORMAL
- en: '**Practical Programs**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll present two programs intended to highlight different aspects of file I/O
    and give you some ideas and new techniques that you can use in your own creations.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Poet***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this example, we’ll modify the Poet program we created in [Chapter 16](ch16.html#ch16)
    so it reads its input from files instead of hardcoding the word lists into the
    program. By doing so, your program will be more awesome and concise, and it will
    be easy to add words to!
  prefs: []
  type: TYPE_NORMAL
- en: 'The program uses five input files: *article.txt*, *adjective.txt*, *noun.txt*,
    *verb.txt*, and *preposition.txt*. The *article.txt* file contains a list of articles
    and qualifiers; the *adjective.txt* file contains a list of adjectives, and so
    on. To take advantage of the way Small Basic handles arrays, each of the five
    files is formatted to make it easy to be read into an array in your program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We automatically load the contents of the *article.txt* file into an array named
    `art` that contains the five elements shown in [Figure 19-6](ch19.html#ch19fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f19-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-6: Reading the contents of* article.txt *into an array named* `art`'
  prefs: []
  type: TYPE_NORMAL
- en: Open the file *Poet_Incomplete.sb* from this chapter’s folder, which also contains
    the background image and the five input files we’ll need. The file has an empty
    placeholder for the `CreateLists()` subroutine, which you’ll add now. This subroutine
    is shown in [Listing 19-9](ch19.html#ch19ex9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 19-9: The* `CreateLists()` *subroutine*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run this program. It should work the same way as before but with an advantage:
    the user can now change the input files to create their own custom poems.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Math Wizard***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this example, we’ll create a program featuring a wizard who seems to know
    a lot about math. The wizard isn’t Merlin, Gandalf, or Harry Potter: welcome to
    the world of the Math Wizard! The wizard starts by asking the user to think of
    a *secret* number. He then requests that the user perform some mathematical operations
    on that number (such as doubling the number, subtracting 2, dividing the answer
    by 10, and so on). At the end, the wizard uses his magical powers to tell the
    user the resulting number after performing these operations (although he doesn’t
    know the user’s secret number)!'
  prefs: []
  type: TYPE_NORMAL
- en: The idea of the program is very simple. We’ll save each math puzzle in a text
    file that has the format shown in [Figure 19-7](ch19.html#ch19fig7). The first
    line contains the puzzle’s answer, and the remaining lines contain the instructions
    that the wizard asks the user to perform. This program includes 11 puzzles saved
    in *Puzzle01.txt*, *Puzzle02.txt*, *..., Puzzle11.txt*. You can add more puzzles
    by creating additional puzzle files (follow the format shown in [Figure 19-7](ch19.html#ch19fig7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f19-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-7: The format of a puzzle file*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The strategy for developing this program is outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When the program starts, we’ll list the files in the program’s directory to
    get the pathnames of the puzzle files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each round of the program, we’ll select one of the available puzzles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We read the first line of the selected puzzle’s file and interpret it as the
    puzzle’s answer. The remaining lines represent the instructions the wizard displays.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The wizard displays the puzzle’s instructions one by one until the program reaches
    an empty line. The wizard asks the user to press ENTER after each instruction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The wizard displays the puzzle’s answer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the *Wizard_Incomplete.sb* file from this chapter’s folder. This file contains
    the program’s main code, shown in [Listing 19-10](ch19.html#ch19ex10), and empty
    placeholders for the `DoPuzzle()` subroutine that you’ll add. The folder also
    contains the text files for the 11 premade puzzles.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 19-10: The main code of the Math Wizard program*'
  prefs: []
  type: TYPE_NORMAL
- en: After displaying the program’s title and its instructions (lines 2–6), we call
    `GetFiles()` to get a list of all the files in the program’s directory, and we
    save the identifier of the returned array in the `puzzle` variable (line 8). We
    then start a loop to process the files we found (lines 10–15). In each iteration,
    we get one pathname from the `puzzle` array (line 11) and check whether it has
    a *.txt* extension (line 12). If the file has a *.txt* extension (which means
    it contains a puzzle), we call `DoPuzzle()` to show that puzzle to the user (line
    13). The program ends with a message from the Math Wizard (lines 16–17).
  prefs: []
  type: TYPE_NORMAL
- en: Add the `DoPuzzle()` subroutine shown in [Listing 19-11](ch19.html#ch19ex11)
    to the bottom of the *Wizard_Incomplete.sb* program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 19-11: The* `DoPuzzle()` *subroutine*'
  prefs: []
  type: TYPE_NORMAL
- en: We read the first line from the file and save it in `puzzleAns` (line 2). Next,
    we set `N` to 2 to read the second line of the file and set the `line` string
    to `"?"` to enter the `While` loop (lines 3–4). In each iteration of the loop,
    we read one line from the puzzle’s file (line 6) and check whether the program
    reached the last instruction. If `line` is not empty (line 7), we display the
    instruction the program just read (line 8) and wait for the user to press any
    key (line 9). When the player presses any key, we increment `N` to read the next
    instruction in the file (line 11). When the program reads an empty line, the `While`
    loop ends, and the program moves to line 14, where we display the puzzle’s answer
    followed by an empty line (lines 14–15).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 19-8](ch19.html#ch19fig8) shows a sample run of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f19-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-8: Sample output of the Math Wizard program*'
  prefs: []
  type: TYPE_NORMAL
- en: '**TRY IT OUT 19-3**'
  prefs: []
  type: TYPE_NORMAL
- en: Think of ways to improve the Math Wizard program, and try to implement them.
    For example, add some colors to make the output look fancier or draw something
    after each puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming Challenges**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you get stuck, check out *[http://nostarch.com/smallbasic/](http://nostarch.com/smallbasic/)*
    for the solutions and for more resources and review questions for teachers and
    students.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a spelling quiz game using homonyms. Homonyms are words that sound
    the same but have different meanings. Use Notepad to create the following text
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each line in this file contains three fields separated by semicolons. The first
    field is the hint you’ll show the player, such as `In your math class`. The second
    field is the two possible answers that your player will choose from, such as `ad/add`.
    The third field is the correct answer, such as `add`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In each round, have the program display the hint and the two possible answers
    to the player, and then wait for them to enter their answer. Have the program
    compare the user’s answer with the correct answer, and then let them know whether
    their answer is correct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write a science quiz that tests the student’s knowledge of the animal kingdom.
    First, use Notepad to create the following text file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first line contains the possible classifications. Each of the remaining
    lines contains an animal’s name and its correct classification. Display an animal’s
    name to the player, and then ask them to classify that animal by entering the
    number of the correct class. Then process the player’s answer and let them know
    whether their answer is correct; if their answer is incorrect, display the correct
    classification.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
