- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Injection
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: This chapter guides you through the detection and exploitation of several prominent
    injection vulnerabilities. API requests that are vulnerable to injection allow
    you to send input that is then directly executed by the API’s supporting technologies
    (such as the web application, database, or operating system running on the server),
    bypassing input validation measures.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: You’ll typically find injection attacks named after the technology they are
    targeting. Database injection techniques such as SQL injection take advantage
    of SQL databases, whereas NoSQL injection takes advantage of NoSQL databases.
    Cross-site scripting (XSS) attacks insert scripts into web pages that run on a
    user’s browser. Cross-API scripting (XAS) is similar to XSS but leverages third-party
    applications ingested by the API you’re attacking. Command injection is an attack
    against the web server operating system that allows you to send it operating system
    commands.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The techniques demonstrated throughout this chapter can be applied to other
    injection attacks as well. As one of the most severe findings you might come across,
    API injection can lead to a total compromise of a target’s most sensitive data
    or even grant you access to the supporting infrastructure.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Discovering Injection Vulnerabilities
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you can inject a payload using an API, you must discover places where
    the API accepts user input. One way to discover these injection points is by fuzzing
    and then analyzing the responses you receive. You should attempt injection attacks
    against all potential inputs and especially within the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: API keys
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tokens
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Headers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query strings in the URL
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters in POST/PUT requests
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your approach to fuzzing will depend on how much information you know about
    your target. If you’re not worried about making noise, you could send a variety
    of fuzzing inputs likely to cause an issue in many possible supporting technologies.
    Yet the more you know about the API, the better your attacks will be. If you know
    what database the application uses, what operating system is running on the web
    server, or the programming language in which the app was written, you’ll be able
    to submit targeted payloads aimed at detecting vulnerabilities in those particular
    technologies.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: After sending your fuzzing requests, hunt for responses that contain a verbose
    error message or some other failure to properly handle the request. In particular,
    look for any indication that your payload bypassed security controls and was interpreted
    as a command, either at the operating system, programming, or database level.
    This response could be as obvious as a message such as “SQL Syntax Error” or something
    as subtle as taking a little more time to process a request. You could even get
    lucky and receive an entire verbose error dump that can provide you with plenty
    of details about the host.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: When you do come across a vulnerability, make sure to test every similar endpoint
    for that vulnerability. Chances are, if you find a weakness in the */file/upload*
    endpoint, all endpoints with an upload feature, such as */image/upload* and */account/upload*,
    have the same problem.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, it is important to note that several of these injection attacks have
    been around for decades. The only thing unique about API injection is that the
    API provides a newer delivery method for the attack. Since injection vulnerabilities
    are well known and often have a detrimental impact on application security, they
    are often well-protected against.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Scripting (XSS)
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: XSS is a classic web application vulnerability that has been around for decades.
    If you’re already familiar with the attack, you might be wondering, is XSS a relevant
    threat to API security? Of course it is, especially if the data submitted over
    the API interacts with the web application in the browser.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: In an XSS attack, the attacker inserts a malicious script into a website by
    submitting user input that gets interpreted as JavaScript or HTML by a user’s
    browser. Often, XSS attacks inject a pop-up message into a web page that instructs
    a user to click a link that redirects them to the attacker’s malicious content.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: In a web application, executing an XSS attack normally consists of injecting
    XSS payloads into different input fields on the site. When it comes to testing
    APIs for XSS, your goal is to find an endpoint that allows you to submit requests
    that interact with the frontend web application. If the application doesn’t sanitize
    the request’s input, the XSS payload might execute the next time a user visits
    the application’s page.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: That said, for this attack to succeed, the stars have to align. Because XSS
    has been around for quite some time, API defenders are quick to eliminate opportunities
    to easily take advantage of this weakness. In addition, XSS takes advantage of
    web browsers loading client-side scripts, so if an API does not interact with
    a web browser, the chances of exploiting this vulnerability are slim to none.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples of XSS payloads:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '`<script>alert("xss")</script>`'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<script>alert(1);</script>`'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<%00script>alert(1)</%00script>`'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SCRIPT>alert("XSS");///SCRIPT>`'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each of these scripts attempts to launch an alert in a browser. The variations
    between the payloads are attempts to bypass user input validation. Typically,
    a web application will try to prevent XSS attacks by filtering out different characters
    or preventing characters from being sent in the first place. Sometimes, doing
    something simple such as adding a null byte (`%00`) or capitalizing different
    letters will bypass web app protections. We will go into more depth about evading
    security controls in Chapter 13.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'For API-specific XSS payloads, I highly recommend the following resources:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '**Payload Box XSS payload list** This list contains over 2,700 XSS scripts
    that could trigger a successful XSS attack ([https://github.com/payloadbox/xss-payload-list](https://github.com/payloadbox/xss-payload-list)).'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Wfuzz wordlist** A shorter wordlist included with one of our primary tools.
    Useful for a quick check for XSS ([https://github.com/xmendez/wfuzz/tree/master/wordlist](https://github.com/xmendez/wfuzz/tree/master/wordlist)).'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**NetSec.expert XSS payloads** Contains explanations of different XSS payloads
    and their use cases. Useful to better understand each payload and conduct more
    precise attacks ([https://netsec.expert/posts/xss-in-2020](https://netsec.expert/posts/xss-in-2020)).'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the API implements some form of security, many of your XSS attempts should
    produce similar results, like 405 Bad Input or 400 Bad Request. However, watch
    closely for the outliers. If you find requests that result in some form of successful
    response, try refreshing the relevant web page in your browser to see whether
    the XSS attempt affected it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'When reviewing the web apps for potential API XSS injection points, look for
    requests that include client input and are used to display information within
    the web app. A request used for any of the following is a prime candidate:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Updating user profile information
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating social media “like” information
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating ecommerce store products
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Posting to forums or comment sections
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search the web application for requests and then fuzz them with an XSS payload.
    Review the results for anomalous or successful status codes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Cross-API Scripting (XAS)
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: XAS is cross-site scripting performed across APIs. For example, imagine that
    the hAPI Hacking blog has a sidebar powered by a LinkedIn newsfeed. The blog has
    an API connection to LinkedIn such that when a new post is added to the LinkedIn
    newsfeed, it appears in the blog sidebar as well. If the data received from LinkedIn
    isn’t sanitized, there is a chance that an XAS payload added to a LinkedIn newsfeed
    could be injected into the blog. To test this, you could post a LinkedIn newsfeed
    update containing an XAS script and check whether it successfully executes on
    the blog.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: XAS does have more complexities than XSS, because the web application must meet
    certain conditions in order for XAS to succeed. The web app must poorly sanitize
    the data submitted through its own API or a third-party one. The API input must
    also be injected into the web application in a way that would launch the script.
    Moreover, if you’re attempting to attack your target through a third-party API,
    you may be limited in the number of requests you can make through its platform.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides these general challenges, you’ll encounter the same challenge inherent
    to XSS attacks: input validation. The API provider might attempt to prevent certain
    characters from being submitted through the API. Since XAS is just another form
    of XSS, you can borrow from the XSS payloads described in the preceding section.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to testing third-party APIs for XAS, you might look for the vulnerability
    in cases when a provider’s API adds content or makes changes to its web application.
    For example, let’s say the hAPI Hacking blog allows users to update their user
    profiles through either a browser or a POST request to the API endpoint */api/profile/update*.
    The hAPI Hacking blog security team may have spent all their time protecting the
    blog from input provided using the web application, completely overlooking the
    API as a threat vector. In this situation, you might try sending a typical profile
    update request containing your payload in one field of POST request:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If the request succeeds, load the web page in a browser to see whether the script
    executes. If the API implements input validation, the server might issue an HTTP
    400 Bad Request response, preventing you from sending scripts as payloads. In
    that case, try using Burp Suite or Wfuzz to send a large list of XAS/XSS scripts
    in an attempt to locate some that don’t result in a 400 response.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful XAS tip is to try altering the `Content-Type` header to induce
    the API into accepting an HTML payload to spawn the script:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: XAS requires a specific situation to be in place in order to be exploitable.
    That said, API defenders often do a better job at preventing attacks that have
    been around for over two decades, such as XSS and SQL injection, than newer and
    more complex attacks like XAS.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: SQL Injection
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most well-known web application vulnerabilities, SQL injection, allows
    a remote attacker to interact with the application’s backend SQL database. With
    this access, an attacker could obtain or delete sensitive data such as credit
    card numbers, usernames, passwords, and other gems. In addition, an attacker could
    leverage SQL database functionality to bypass authentication and even gain system
    access.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: This vulnerability has been around for decades, and it seemed to be diminishing
    before APIs presented a new way to perform injection attacks. Still, API defenders
    have been keen to detect and prevent SQL injections over APIs. Therefore, these
    attacks are not likely to succeed. In fact, sending requests that include SQL
    payloads could arouse the attention of your target’s security team or cause your
    authorization token to be banned.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, you can often detect the presence of a SQL database in less obvious
    ways. When sending a request, try requesting the unexpected. For example, take
    a look at the Swagger documentation shown in [Figure 12-1](#figure12-1) for a
    Pixi endpoint.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![screenshot of swagger documentation that contains the following values in
    the body: id, user, pass, name, is_admin , and account_balance](image_fi/502444c12/F12001.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-1: Pixi API Swagger documentation'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Pixi is expecting the consumer to provide certain values in
    the body of a request. The `"id"` value should be a number, `"name"` expects a
    string, and `"is_admin"` expects a Boolean value such as true or false. Try providing
    a string where a number is expected, a number where a string is expected, and
    a number or string where a Boolean value is expected. If an API is expecting a
    small number, send a large number, and if it expects a small string, send a large
    one. By requesting the unexpected, you’re likely to discover a situation the developers
    didn’t predict, and the database might return an error in the response. These
    errors are often verbose, revealing sensitive information about the database.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，Pixi 期望消费者在请求的主体中提供某些值。`"id"` 值应该是一个数字，`"name"` 期望一个字符串，`"is_admin"` 期望一个布尔值，比如
    true 或 false。尝试在预期数字的地方提供字符串，在预期字符串的地方提供数字，并在预期布尔值的地方提供数字或字符串。如果 API 预期一个小数字，请发送一个大数字，如果它预期一个小字符串，请发送一个大字符串。通过请求意外情况，你很可能会发现开发人员没有预测到的情况，数据库可能会在响应中返回错误。这些错误通常是冗长的，会泄露有关数据库的敏感信息。
- en: When looking for requests to target for database injections, seek out those
    that allow client input and can be expected to interact with a database. In [Figure
    12-1](#figure12-1), there is a good chance that the collected user information
    will be stored in a database and that the PUT request allows us to update it.
    Since there is a probable database interaction, the request is a good candidate
    to target in a database injection attack. In addition to making obvious requests
    like this, you should fuzz everything, everywhere, because you might find indications
    of a database injection weakness in less obvious requests.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找用于数据库注入的目标请求时，要寻找那些允许客户端输入并且预计会与数据库交互的请求。在 [图 12-1](#figure12-1) 中，收集的用户信息很可能会存储在数据库中，并且
    PUT 请求允许我们对其进行更新。由于可能存在数据库交互，因此该请求是目标进行数据库注入攻击的一个很好的候选项。除了进行明显的请求外，还应该对所有地方进行模糊测试，因为你可能会在不太明显的请求中找到数据库注入弱点的迹象。
- en: 'This section will cover two easy ways to test whether an application is vulnerable
    to SQL injection: manually submitting metacharacters as input to the API and using
    an automated solution called SQLmap.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍两种简单的方法来测试应用程序是否容易受到 SQL 注入攻击：手动将元字符提交为 API 的输入，以及使用一个名为 SQLmap 的自动化解决方案。
- en: Manually Submitting Metacharacters
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动提交元字符
- en: '*Metacharacters* are characters that SQL treats as functions rather than as
    data. For example, `--` is a metacharacter that tells the SQL interpreter to ignore
    the following input because it is a comment. If an API endpoint does not filter
    SQL syntax from API requests, any SQL queries passed to the database from the
    API will execute.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*元字符* 是 SQL 中被视为函数而不是数据的字符。例如，`--` 是一个元字符，告诉 SQL 解释器忽略接下来的输入，因为它是一个注释。如果 API
    端点没有过滤 API 请求中的 SQL 语法，那么通过 API 传递到数据库的任何 SQL 查询都将被执行。'
- en: 'Here are some SQL metacharacters that can cause some issues:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可以引起问题的 SQL 元字符：
- en: '`''`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`''`'
- en: '`''''`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`''''`'
- en: '`;%00`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`;%00`'
- en: '`--`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`--`'
- en: '`-- -`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`-- -`'
- en: '`""`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`""`'
- en: '`;`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`;`'
- en: '`'' OR ''1`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`'' OR ''1`'
- en: '`'' OR 1 -- -`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`'' OR 1 -- -`'
- en: '`" OR "" = "`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`" OR "" = "`'
- en: '`" OR 1 = 1 -- -`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`" OR 1 = 1 -- -`'
- en: '`'' OR '''' = ''`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`'' OR '''' = ''`'
- en: '`OR 1=1`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`OR 1=1`'
- en: 'All of these symbols and queries are meant to cause problems for SQL queries.
    A null byte like `;%00` could cause a verbose SQL-related error to be sent as
    a response. The `OR 1=1` is a conditional statement that literally means “or the
    following statement is true,” and it results in a true condition for the given
    SQL query. Single and double quotes are used in SQL to indicate the beginning
    and ending of a string, so quotes could cause an error or a unique state. Imagine
    that the backend is programmed to handle the API authentication process with a
    SQL query like the following, which is a SQL authentication query that checks
    for username and password:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些符号和查询都旨在引起 SQL 查询的问题。像 `;%00` 这样的空字节可能会导致一个冗长的与 SQL 相关的错误作为响应发送。`OR 1=1`
    是一个条件语句，字面上意味着“或者以下语句为真”，这将导致给定 SQL 查询的条件为真。单引号和双引号在 SQL 中用于指示字符串的开始和结束，因此引号可能会导致错误或独特的状态。想象一下，后端程序编程时，处理
    API 身份验证过程的 SQL 查询可能会像下面这样，这是一个检查用户名和密码的 SQL 身份验证查询：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The query retrieves the values `hAPI_hacker` and `Password1!` from the user
    input. If, instead of a password, we supplied the API with the value `'' OR 1=1--
    -`, the SQL query might instead look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 查询从用户输入中检索值 `hAPI_hacker` 和 `Password1!`。如果我们向 API 提供的不是密码，而是值 `' OR 1=1-- -`，那么
    SQL 查询可能会变成这样：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This would be interpreted as selecting the user with a true statement and skipping
    the password requirement, as it has been commented out. The query no longer checks
    for a password at all, and the user is granted access. The attack can be performed
    to both the username and password fields. In a SQL query, the dashes (`--`) represent
    the beginning of a single-line comment. This turns everything within the following
    query line into a comment that will not be processed. Single and double quotes
    can be used to escape the current query to cause an error or to append your own
    SQL query.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被解释为选择一个为真语句的用户，并跳过密码要求，因为密码部分已被注释掉。查询不再检查密码，用户被授予访问权限。该攻击可以对用户名和密码字段同时执行。在
    SQL 查询中，破折号（`--`）代表单行注释的开始。这将使后续查询行中的所有内容变成注释，不会被处理。单引号和双引号可以用来逃避当前查询，导致错误，或追加你自己的
    SQL 查询。
- en: The preceding list has been around in many forms for years, and the API defenders
    are also aware of its existence. Therefore, make sure you attempt various forms
    of requesting the unexpected.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表已经以多种形式存在多年，API 防御者也意识到它的存在。因此，确保你尝试各种方式请求意外的结果。
- en: SQLmap
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLmap
- en: One of my favorite ways to automatically test an API for SQL injection is to
    save a potentially vulnerable request in Burp Suite and then use SQLmap against
    it. You can discover potential SQL weaknesses by fuzzing all potential inputs
    in a request and then reviewing the responses for anomalies. In the case of a
    SQL vulnerability, this anomaly is normally a verbose SQL response like “The SQL
    database is unable to handle your request . . .”
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的一种自动测试 API 是否存在 SQL 注入的方法是，将一个可能存在漏洞的请求保存在 Burp Suite 中，然后使用 SQLmap 对其进行攻击。你可以通过对请求中的所有潜在输入进行模糊测试，然后检查响应中的异常来发现潜在的
    SQL 弱点。在 SQL 漏洞的情况下，这种异常通常是类似于“SQL 数据库无法处理你的请求……”的详细 SQL 响应。
- en: 'Once you’ve saved the request, launch SQLmap, one of the standard Kali packages
    that can be run over the command line. Your SQLmap command might look like the
    following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 保存请求后，启动 SQLmap，这是 Kali 的标准包之一，可以通过命令行运行。你的 SQLmap 命令可能如下所示：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `-r` option lets you specify the path to the saved request. The `-p` option
    lets you specify the exact parameters you’d like to test for SQL injection. If
    you do not specify a parameter to attack, SQLmap will attack every parameter,
    one after another. This is great for performing a thorough attack of a simple
    request, but a request with many parameters can be fairly time-consuming. SQLmap
    tests one parameter at a time and tells you when a parameter is unlikely to be
    vulnerable. To skip a parameter, use the ctrl-C keyboard shortcut to pull up SQLmap’s
    scan options and use the `n` command to move to the next parameter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`-r` 选项让你指定已保存请求的路径。`-p` 选项让你指定希望测试 SQL 注入的具体参数。如果没有指定要攻击的参数，SQLmap 会依次攻击每一个参数。这对于对一个简单请求进行彻底攻击非常有效，但对于一个包含多个参数的请求，可能会相当耗时。SQLmap
    会一次测试一个参数，并告诉你哪个参数不太可能存在漏洞。要跳过某个参数，可以使用 ctrl-C 键组合打开 SQLmap 的扫描选项，并使用 `n` 命令跳到下一个参数。'
- en: 'When SQLmap indicates that a certain parameter may be injectable, attempt to
    exploit it. There are two major next steps, and you can choose which to pursue
    first: dumping every database entry or attempting to gain access to the system.
    To dump all database entries, use the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当 SQLmap 表明某个参数可能存在注入漏洞时，尝试利用它。有两个主要的后续步骤，你可以选择先进行哪一个：导出所有数据库条目或尝试获取系统访问权限。要导出所有数据库条目，可以使用以下命令：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you’re not interested in dumping the entire database, you could use the
    `--dump` command to specify the exact table and columns you would like:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想导出整个数据库，你可以使用 `--dump` 命令来指定你希望获取的具体表格和列：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This example attempts to dump the `password` column of the `users` table within
    the `helpdesk` database. When this command executes successfully, SQLmap will
    display database information on the command line and export the information to
    a CSV file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例尝试从 `helpdesk` 数据库中的 `users` 表导出 `password` 列。当命令成功执行时，SQLmap 会在命令行上显示数据库信息，并将信息导出到
    CSV 文件。
- en: 'Sometimes SQL injection vulnerabilities will allow you to upload a web shell
    to the server that can then be executed to obtain system access. You could use
    one of SQLmap’s commands to automatically attempt to upload a web shell and execute
    the shell to grant you with system access:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有时 SQL 注入漏洞会允许你向服务器上传一个 Web Shell，然后执行该 Shell 以获取系统访问权限。你可以使用 SQLmap 的命令之一来自动尝试上传
    Web Shell 并执行它，从而为你提供系统访问权限：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This command will attempt to leverage the SQL command access within the vulnerable
    parameter to upload and launch a shell. If successful, this will give you access
    to an interactive shell with the operating system.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you could use the `os-pwn` option to attempt to gain a shell
    using Meterpreter or VNC:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Successful API SQL injections may be few and far between, but if you do find
    a weakness, the impact can lead to a severe compromise of the database and affected
    servers. For additional information on SQLmap, check out its documentation at
    [https://github.com/sqlmapproject/sqlmap#readme](https://github.com/sqlmapproject/sqlmap#readme).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL Injection
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: APIs commonly use NoSQL databases due to how well they scale with the architecture
    designs common among APIs, as discussed in Chapter 1. It may even be more common
    for you to discover NoSQL databases than SQL databases. Also, NoSQL injection
    techniques aren’t as well known as their structured counterparts. Due to this
    one small fact, you might be more likely to find NoSQL injections.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: As you hunt, remember that NoSQL databases do not share as many commonalities
    as the different SQL databases do. *NoSQL* is an umbrella term that means the
    database does not use SQL. Therefore, these databases have unique structures,
    modes of querying, vulnerabilities, and exploits. Practically speaking, you’ll
    conduct many similar attacks and target similar requests, but your actual payloads
    will vary.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are common NoSQL metacharacters you could send in an API call
    to manipulate the database:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '`$gt`'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`{"$gt":""}`'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`{"$gt":-1}`'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ne`'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`{"$ne":""}`'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`{"$ne":-1}`'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$nin`'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`{"$nin":1}`'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`{"$nin":[1]}`'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`|| ''1''==''1`'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`//`'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`||''a''\\''a`'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''||''1''==''1'';//`'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''/{}:`'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''"\;{}`'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`''"\/$[].>`'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`{"$where": "sleep(1000)"}`'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A note on a few of these NoSQL metacharacters: as we touched on in Chapter
    1, `$gt` is a MongoDB NoSQL query operator that selects documents that are greater
    than the provided value. The `$ne` query operator selects documents where the
    value is not equal to the provided value. The `$nin` operator is the “not in”
    operator, used to select documents where the field value is not within the specified
    array. Many of the others in the list contain symbols that are meant to cause
    verbose errors or other interesting behavior, such as bypassing authentication
    or waiting 10 seconds.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Anything out of the ordinary should encourage you to thoroughly test the database.
    When you send an API authentication request, one possible response for an incorrect
    password is something like the following, which comes from the Pixi API collection:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that a failed response includes a status code of 202 Accepted and includes
    a failed login message. Fuzzing the */api/login* endpoint with certain symbols
    results in verbose error messaging. For example, the payload `'"\;{}` sent as
    the password parameter might cause the following 400 Bad Request message.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Unfortunately, the error messaging does not indicate anything about the database
    in use. However, this unique response does indicate that this request has an issue
    with handling certain types of user input, which could be an indication that it
    is potentially vulnerable to an injection attack. This is exactly the sort of
    response that should incite you to focus your testing. Since we have our list
    of NoSQL payloads, we can set the attack position to the password with our NoSQL
    strings:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，错误信息并未指示所使用的数据库类型。然而，这个独特的响应确实表明，该请求在处理某些类型的用户输入时存在问题，这可能表明它可能容易受到注入攻击。这正是应该引起你注意并集中测试的响应。既然我们已经有了
    NoSQL 负载列表，我们可以将攻击位置设置为密码，并使用我们的 NoSQL 字符串：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since we already have this request saved in our Pixi collection, let’s attempt
    our injection attack with Postman. Sending various requests with the NoSQL fuzzing
    payloads results in 202 Accepted responses, as seen with other bad password attempts
    in [Figure 12-2](#figure12-2).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在 Pixi 集合中保存了这个请求，让我们尝试使用 Postman 进行注入攻击。发送带有 NoSQL 模糊负载的各种请求会得到 202 Accepted
    响应，正如在[图 12-2](#figure12-2)中看到的其他错误密码尝试。
- en: As you can see, the payloads with nested NoSQL commands `{"$gt":""}` and `{"$ne":""}`
    result in successful injection and authentication bypass.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，嵌套的 NoSQL 命令负载 `{"$gt":""}` 和 `{"$ne":""}` 导致了成功的注入和认证绕过。
- en: '![screenshot of postman that shows successful attempts when using nested nosql
    commands](image_fi/502444c12/F12002.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 截图，显示使用嵌套 NoSQL 命令时成功的尝试](image_fi/502444c12/F12002.png)'
- en: 'Figure 12-2: Successful NoSQL injection attack using Postman'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-2：使用 Postman 成功进行 NoSQL 注入攻击
- en: Operating System Command Injection
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统命令注入
- en: Operating system command injection is similar to the other injection attacks
    we’ve covered in this chapter, but instead of, say, database queries, you’ll inject
    a command separator and operating system commands. When you’re performing operating
    system injection, it helps a great deal to know which operating system is running
    on the target server. Make sure you get the most out of your Nmap scans during
    reconnaissance in an attempt to glean this information.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统命令注入类似于本章中我们讨论的其他注入攻击，但不同之处在于，你注入的不是数据库查询，而是命令分隔符和操作系统命令。在进行操作系统注入时，了解目标服务器上运行的操作系统非常有帮助。确保在侦察期间充分利用你的
    Nmap 扫描，以尝试获取这些信息。
- en: As with all other injection attacks, you’ll begin by finding a potential injection
    point. Operating system command injection typically requires being able to leverage
    system commands that the application has access to or escaping the application
    altogether. Some key places to target include URL query strings, request parameters,
    and headers, as well as any request that has thrown unique or verbose errors (especially
    those containing any operating system information) during fuzzing attempts.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他注入攻击一样，你的第一步是找到潜在的注入点。操作系统命令注入通常需要能够利用应用程序访问的系统命令，或完全逃逸出应用程序。一些关键的攻击目标包括
    URL 查询字符串、请求参数和头部，以及在模糊测试中抛出过独特或冗长错误（特别是那些包含操作系统信息的错误）的请求。
- en: 'Characters such as the following all act as *command separators*, which enable
    a program to pair multiple commands together on a single line. If a web application
    is vulnerable, it would allow an attacker to add command separators to an existing
    command and then follow it with additional operating system commands:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下字符都充当 *命令分隔符*，它们允许程序在一行中将多个命令配对。如果 Web 应用程序存在漏洞，它将允许攻击者将命令分隔符添加到现有命令中，并在其后跟随其他操作系统命令：
- en: '`|`'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`|`'
- en: '`||`'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`||`'
- en: '`&`'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`&`'
- en: '`&&`'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`&&`'
- en: '`''`'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''`'
- en: '`"`'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`"`'
- en: '`;`'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`;`'
- en: '`''"`'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''"`'
- en: 'If you don’t know a target’s underlying operating system, put your API fuzzing
    skills to work by using two payload positions: one for the command separator followed
    by a second for the operating system command. [Table 12-1](#table12-1) is a small
    list of potential operating system commands to use.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道目标的底层操作系统，可以通过使用两个负载位置来发挥你的 API 模糊技能：一个用于命令分隔符，另一个用于操作系统命令。[表 12-1](#table12-1)是一些潜在的操作系统命令。
- en: 'Table 12-1: Common Operating System Commands to Use in Injection Attacks'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-1：注入攻击中常用的操作系统命令
- en: '| **Operating system** | **Command** | **Description** |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| **操作系统** | **命令** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Windows | `ipconfig` | Shows the network configuration |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| Windows | `ipconfig` | 显示网络配置 |'
- en: '|  | `dir` | Prints the contents of a directory |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|  | `dir` | 打印目录内容 |'
- en: '|  | `ver` | Prints the operating system and version |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '|  | `echo``%CD%` | Prints the current working directory |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '|  | `whoami` | Prints the current user |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| *nix (Linux and Unix) | `ifconfig` | Shows the network configuration |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '|  | `ls` | Prints the contents of a directory |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '|  | `uname``-a` | Prints the operating system and version |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '|  | `pwd` | Prints the current working directory |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '|  | `whoami` | Prints the current user |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: 'To perform this attack with Wfuzz, you can either manually provide a list of
    commands or supply them as a wordlist. In the following example, I have saved
    all my command separators in the file *commandsep.txt* and operating system commands
    as *os-cmds.txt*:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To perform this same attack in Burp Suite, you could leverage an Intruder cluster
    bomb attack.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: We set the request to be a login POST request and target the `user` parameter.
    Two payload positions have been set to each of our files. Review the results for
    anomalies, such as responses in the 200s and response lengths that stick out.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'What you decide to do with your operating system command injection is up to
    you. You could retrieve SSH keys, the */etc/shadow* password file on Linux, and
    so on. Alternatively, you could escalate or command-inject to a full-blown remote
    shell. Either way, that is where your API hacking transitions into regular old
    hacking, and there are plenty of other books on that topic. For additional information,
    check out the following resources:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '*RTFM:* *Red Team Field Manual* (2013) by Ben Clark'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Penetration Testing: A Hands-On Introduction to Hacking* (No Starch Press,
    2014) by Georgia Weidman'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ethical Hacking: A Hands-On Introduction to Breaking In* (No Starch Press,
    2021) by Daniel Graham'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Advanced Penetration Testing: Hacking the World’s Most Secure Networks* (Wiley,
    2017) by Wil Allsop'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hands-On Hacking* (Wiley, 2020) by Jennifer Arcuri and Matthew Hickey'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Hacker Playbook 3: Practical Guide to Penetration Testing* (Secure Planet,
    2018) by Peter Kim'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Shellcoder’s Handbook: Discovering and Exploiting Security Holes* (Wiley,
    2007) by Chris Anley, Felix Lindner, John Heasman, and Gerardo Richarte'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we used fuzzing to detect several types of API injection vulnerabilities.
    Then we reviewed the myriad ways these vulnerabilities can be exploited. In the
    next chapter, you’ll learn how to evade common API security controls.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Lab #9: Faking Coupons Using NoSQL Injection'
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s time to approach the crAPI with our new injection powers. But where to
    start? Well, one feature we haven’t tested yet that accepts client input is the
    coupon code feature. Now don’t roll your eyes—coupon scamming can be lucrative!
    Search for Robin Ramirez, Amiko Fountain, and Marilyn Johnson and you’ll learn
    how they made $25 million. The crAPI might just be the next victim of a massive
    coupon heist.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Using the web application as an authenticated user, let’s use the **Add Coupon**
    button found within the Shop tab. Enter some test data in the coupon code field
    and then intercept the corresponding request with Burp Suite (see [Figure 12-3](#figure12-3)).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![screenshot of crapi’s enter coupon code pop-up window, in which “test!” has
    been typed into the coupon code box and has given the error message “invalid coupon
    code”](image_fi/502444c12/F12003.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-3: The crAPI coupon code validation feature'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'In the web application, using this coupon code validation feature with an incorrect
    coupon code results in an “invalid coupon code” response. The intercepted request
    should look like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice the `"coupon_code"` value in the POST request body. This seems like a
    good field to test if we’re hoping to forge coupons. Let’s send the request over
    to Intruder and add our payload positions around `TEST!` so we can fuzz this coupon
    value. Once we’ve set our payload positions, we can add our injection fuzzing
    payloads. Try including all the SQL and NoSQL payloads covered in this chapter.
    Next, begin the Intruder fuzzing attack.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The results of this initial scan all show the same status code (500) and response
    length (385), as you can see in [Figure 12-4](#figure12-4).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![fuzzing results show various requests, all with a length of 385 and a status
    code of 500](image_fi/502444c12/F12004.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-4: Intruder fuzzing results'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Nothing appears anomalous here. Still, we should investigate what the requests
    and responses look like. See Listings 12-1 and 12-2.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 12-1: The coupon validation request'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 12-2: The coupon validation response'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: While reviewing the results, you may notice something interesting. Select one
    of the results and look at the Request tab. Notice that the payload we sent has
    been encoded. This could be interfering with our injection attack because the
    encoded data might not be interpreted correctly by the application. In other situations,
    the payload might need to be encoded to help bypass security controls, but for
    now, let’s find the source of this problem. At the bottom of the Burp Suite Intruder
    Payloads tab is an option to URL-encode certain characters. Uncheck this box,
    as shown in [Figure 12-5](#figure12-5), so that the characters will be sent, and
    then send another attack.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![screenshot of burp suite’s intruder payloads tab that shows the “url-encode
    these characters” option as unchecked](image_fi/502444c12/F12005.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-5: Burp Suite Intruder’s payload-encoding options'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'The request should now look like [Listing 12-3](#listing12-3), and the response
    should now look like [Listing 12-4](#listing12-4):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 12-3: The request with URL encoding disabled'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 12-4: The corresponding response'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: This round of attacks did result in some slightly more interesting responses.
    Notice the 422 Unprocessable Entity status code, along with the verbose error
    message. This status code normally means that there is an issue in the syntax
    of the request.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking a closer look at our request, you might notice a possible issue: we
    placed our payload position within the original key/value quotes generated in
    the web application’s request. We should experiment with the payload position
    to include the quotes so as to not interfere with nested object injection attempts.
    Now the Intruder payload positions should look like the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Once again, initiate the updated Intruder attack. This time, we receive even
    more interesting results, including two 200 status codes (see [Figure 12-6](#figure12-6)).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![screenshot of burp suite’s intruder results that shows various requests of
    varying lengths; all but two requests are of status code 422, and the two are
    of status code 200.](image_fi/502444c12/F12006.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-6: Burp Suite Intruder results'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, two injection payloads, `{"$gt":""}` and `{"$nin":[1]}`, resulted
    in successful responses. By investigating the response to the `$nin` (not in)
    NoSQL operator, we see that the API request has returned a valid coupon code.
    Congratulations on performing a successful API NoSQL injection attack!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the injection vulnerability is present, but you need to troubleshoot
    your attack attempts to find the injection point. Therefore, make sure you analyze
    your requests and responses and follow the clues left within verbose error messages.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
