<html><head></head><body>
<h2 class="h2" id="ch17"><span epub:type="pagebreak" id="page_451"/><span class="big">17</span><br/>USING THE AUTOTOOLS WITH WINDOWS</h2>&#13;
<p class="quote"><em>“Well, Steve, I think there’s more than one way of looking at it. I think it’s more like we both had this rich neighbor named Xerox and I broke into his house to steal the TV set and found out that you had already stolen it.”<br/>—Bill Gates, quoted in</em> Steve Jobs <em>by Walter Isaacson</em></p>&#13;
<p class="image1"><img src="../images/common.jpg" alt="Image"/></p>&#13;
<p class="noindent">Autoconf generates configure scripts containing hundreds of lines of Bourne shell code. If that statement doesn’t make you wonder how we could ever use the Autotools with Windows, you should probably re-read it until it does. In fact, the only way Autoconf <em>can</em> be used is with an actual Bourne shell and a subset of Unix tools like <span class="literal">grep</span>, <span class="literal">awk</span>, and <span class="literal">sed</span>. So before we can even get started, we need to ensure that we have a proper execution environment.</p>&#13;
<p class="indent">When I started working on the first edition of this book, there were few options that provided the required environment for building Windows software with the Autotools. During the last 10 years, that story has changed. Today, an entire gamut of options is available to developers, depending on whether your goal is to build Windows applications on Linux or Windows.</p>&#13;
<p class="indent">In the last decade, Windows has been viewed by the GNU community as a more important target than it has in the past. Significant efforts have been made recently to ensure that GNU source code at least considers <span epub:type="pagebreak" id="page_452"/>Windows as a target environment. This attitude shift has provided important source-level support for making Cygwin and its sibling environments manage clean ports of GNU packages to Windows.</p>&#13;
<h3 class="h3" id="ch17sec1">Environment Options</h3>&#13;
<p class="noindent">Since our goal is to build native Windows software using GNU tools, including specifically the Autotools, we’re naturally going to have to consider systems that provide various levels of POSIX environment functionality.</p>&#13;
<p class="indent">At one end of the spectrum, we have actual Linux installations, which may take any one of several forms, including bare-metal dedicated machine installations and virtual machines running on KVM, Xen, or VMware ESX servers or on a Windows machine running Microsoft HyperV, VMware Workstation, or Oracle’s VirtualBox. There are also Mac options for running virtual machines, and macOS itself provides a reasonably POSIX-compliant environment. We could also use Windows Subsystem for Linux (WSL).</p>&#13;
<p class="indent">A full Linux installation obviously provides the most POSIX-compliant environment for building software using GNU tools. To actually generate Windows software on a Linux system, we have to configure a cross-compile. That is, we have to build software that’s not designed to run on the build system.</p>&#13;
<p class="indent">At the other end of that spectrum, we have various POSIX environment emulators running within Windows applications. The “application” in these cases is almost always a Bash shell running in some sort of shell host process or terminal, but these environments are more or less compatible with a true Linux build environment. The flavors we have to pick from today include Cygwin, MinGW, and MSys2.</p>&#13;
<p class="indent">A final option—and one we won’t spend much time on—is that of cross-compiling Windows software on other types of systems, including mainframes and supercomputers. If you want to see a Windows program compile fast, you should watch it happen on a Cray XC50 with an SSD or RAM disk. Since GNU software can run on pretty much any Unix system that has a Bourne shell, we can cross-compile software on it for any platform, including Windows. After you’ve cross-compiled on Linux, moving the process to a different POSIX-compliant platform is relatively simple.</p>&#13;
<h3 class="h3" id="ch17sec2">Tool Chain Options</h3>&#13;
<p class="noindent">Once we’ve chosen an environment, we’ll then need to select a tool chain in which to build our native software for Windows. Generally speaking, the environment you choose limits your tool chain options. For example, if you select a full Linux installation, your only tool chain option is to install a cross-compiler for Windows—probably <em>mingw-w64</em>. Don’t knock it until you’ve tried it—this is a really good option because it does a pretty reasonable job of building Windows software.</p>&#13;
<p class="indent">The biggest problem you’ll find here is the inconvenience of having to copy your software over to a Windows system in order to test it. In fact, <span epub:type="pagebreak" id="page_453"/>running tests as part of your build is pretty much a nonstarter, as you can’t execute your products on your build machine.<sup><a id="ch17fn_1" href="footnote.xhtml#ch17fn1">1</a></sup> I’ve seen such cross-compilation testing done by having a remote copy and execution stage as part of the build system’s test phase, but doing this tends to make your build brittle because it requires additional environment configuration that’s not part of a normal package build process.</p>&#13;
<h3 class="h3" id="ch17sec3">Getting Started</h3>&#13;
<p class="noindent">I’ll present a full cross-section of options for building Windows software using GNU tools. We’ll start by using a Windows cross-compiler tool chain on native Linux and then check out Windows Subsystem for Linux, and finally move on to the remaining Windows-based options, presented in the order they were created. We’ll first check out Cygwin on a Windows 10 system. Next, we’ll try MinGW and finally finish up with MSys2. By the time you reach the end of this chapter, you should be very comfortable with these processes.</p>&#13;
<p class="indent">For Windows-based systems, I’ll presume you’re running a reasonably recent copy of Windows 10. I installed <em>Windows 10 Build 1803</em> (released April 30, 2018) in a virtual machine under Oracle’s VirtualBox on my Linux Mint system. You can take this path, or you can use a “bare metal” (nonvirtual) installation of Windows 10. The manner in which you choose to run Windows and, to a lesser extent, the exact version you choose to run are really not significant issues here.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The majority of this book centers on the use of free and open source software (FOSS). Microsoft Windows is, of course, not free software. You should pay for any copy of Windows—or any other non-free software—you choose to use.<sup><a id="ch17fn_2" href="footnote.xhtml#ch17fn2">2</a></sup></em></p>&#13;
</div>&#13;
<p class="indent">I’ve also installed Git for Windows<sup><a id="ch17fn_3" href="footnote.xhtml#ch17fn3">3</a></sup> on my Windows system and cloned the b64 project from <a href="ch13.xhtml">Chapter 13</a> and Gnulib from the Savannah Git server. We won’t be making any significant changes to the b64 project source code, except to make it work in a given environment where necessary.</p>&#13;
<p class="indent">When you install Git for Windows, you’ll have the option of downloading a 32- or 64-bit version in one of two varieties—as an installer or as a portable package. The installer style installs Git on your Windows system in the usual fashion and may be uninstalled from the Windows installed-programs panel. <span epub:type="pagebreak" id="page_454"/>The portable style requires no installation and can be executed directly from its expanded archive. Select an installer or a portable package option for your Windows system.</p>&#13;
<p class="indent">If you chose to use an installer, during the installation process you’ll be asked how you want Git to treat your source file line endings. I generally avoid the first option, which is to “check out” using Windows-style line endings but “commit” using Unix-style line endings. You might want to use this option if you’re planning to use Notepad as your editor (not advisable). I generally select the option to check out and commit as is. Git has no business modifying your source files as they pass through it. Just configure your editor to recognize and manage line endings the way you like.</p>&#13;
<h3 class="h3" id="ch17sec4">Cross-Compiling for Windows on Linux</h3>&#13;
<p class="noindent">Since we’re already running Linux, let’s start our investigation of the options right here at home.</p>&#13;
<h4 class="h4" id="ch17sec4-1"><em>Installing a Windows Cross Tool Chain</em></h4>&#13;
<p class="noindent">The first thing we’ll need to do is install a Windows cross-compiler tool chain (often referred to simply as a “cross tool chain” or as “cross tools”) on our Linux system. The most widely available one is mingw-w64 for Linux, which can build native Windows programs and libraries that look very much like they were generated by Microsoft tools.</p>&#13;
<p class="indent">On my Linux Mint system, I searched the internet for <em>Linux Mint mingw-w64</em>; the top result was my goal. You can generally use your system’s package manager to find and install this package because mingw-w64 is pretty popular. On CentOS and other Red Hat–based systems, try <span class="literal">yum search mingw-w64</span>. For Debian-based systems like Ubuntu and Mint, try <span class="literal">apt-cache search mingw-w64</span>.</p>&#13;
<p class="indent">Be aware when you run these package searches that you may get back a long result list composed of a few dozen real packages and one or two meta packages. It’s better to select one of the meta packages so you get all of the required real packages in one shot. I highly recommend you search the internet for your distro name and <em>mingw-w64</em> in order to get some background on which package you should install using your package manager. A little research up front can save you a lot of headache later.</p>&#13;
<p class="indent">For example, on my Debian-based system, I got these results from an <span class="literal">apt-cache</span> search:</p>&#13;
<pre>$ <span class="codestrong1">apt-cache search mingw-w64</span>&#13;
<span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">g++-mingw-w64 - GNU C++ compiler for MinGW-w64</span>&#13;
<span class="ash">g++-mingw-w64-i686 - GNU C++ compiler for MinGW-w64 targeting Win32</span>&#13;
<span class="ash">g++-mingw-w64-x86-64 - GNU C++ compiler for MinGW-w64 targeting Win64</span>&#13;
<span class="ash">gcc-mingw-w64 - GNU C compiler for MinGW-w64</span>&#13;
<span class="ash">gcc-mingw-w64-base - GNU Compiler Collection for MinGW-w64 (base package)</span>&#13;
<span class="ash">gcc-mingw-w64-i686 - GNU C compiler for MinGW-w64 targeting Win32</span>&#13;
<span class="ash">gcc-mingw-w64-x86-64 - GNU C compiler for MinGW-w64 targeting Win64</span>&#13;
<span epub:type="pagebreak" id="page_455"/><span class="codeitalic1a">--snip--</span>&#13;
mingw-w64 - Development environment targeting 32- and 64-bit Windows&#13;
<span class="ash">mingw-w64-common - Common files for Mingw-w64</span>&#13;
<span class="ash">mingw-w64-i686-dev - Development files for MinGW-w64 targeting Win32</span>&#13;
<span class="ash">mingw-w64-tools - Development tools for 32- and 64-bit Windows</span>&#13;
<span class="ash">mingw-w64-x86-64-dev - Development files for MinGW-w64 targeting Win64</span>&#13;
<span class="codeitalic1a">--snip</span><span class="codeitalic1a">--</span>&#13;
$</pre>&#13;
<p class="indent">The actual results list contained dozens of entries, but according to a quick internet search, I found the only package I really needed to install was <em>mingw-w64</em> (highlighted); a meta-package referencing actual packages that install the GCC C and C++ compilers for generating 32- and 64-bit Windows software; and a <em>binutils</em> package containing the librarian, linker, and other common development tools. Some package management systems divide this set of packages differently, allowing you the option of installing <span class="literal">gcc</span> and <span class="literal">g++</span> separately or of installing 32-bit and 64-bit code generators separately. Installing this package on my system displays the following output:</p>&#13;
<pre>$ <span class="codestrong1">sudo apt-get install mingw-w64</span>&#13;
[sudo] password for jcalcote:&#13;
Reading package lists... Done&#13;
Building dependency tree&#13;
Reading state information... Done&#13;
The following additional packages will be installed:&#13;
  binutils-mingw-w64-i686 binutils-mingw-w64-x86-64 g++-mingw-w64 g++-&#13;
mingw-w64-i686 g++-mingw-w64-x86-64 gcc-mingw-w64 gcc-mingw-w64-base&#13;
gcc-mingw-w64-i686 gcc-mingw-w64-x86-64&#13;
  mingw-w64-common mingw-w64-i686-dev mingw-w64-x86-64-dev&#13;
Suggested packages:&#13;
  gcc-7-locales wine wine64&#13;
The following NEW packages will be installed:&#13;
  binutils-mingw-w64-i686 binutils-mingw-w64-x86-64 g++-mingw-w64 g++-&#13;
mingw-w64-i686 g++-mingw-w64-x86-64 gcc-mingw-w64 gcc-mingw-w64-base&#13;
gcc-mingw-w64-i686 gcc-mingw-w64-x86-64&#13;
  mingw-w64 mingw-w64-common mingw-w64-i686-dev mingw-w64-x86-64-dev&#13;
0 upgraded, 13 newly installed, 0 to remove and 31 not upgraded.&#13;
Need to get 127 MB of archives.&#13;
After this operation, 744 MB of additional disk space will be used.&#13;
Do you want to continue? [Y/n] <span class="codestrong1">Y</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$</pre>&#13;
<h4 class="h4" id="ch17sec4-2"><em>Testing the Build</em></h4>&#13;
<p class="noindent">Once you’ve found and installed the proper cross tool chain, you’re ready to start building Windows software. I’ve chosen something simple, but not trivial—the b64 project from <a href="ch13.xhtml">Chapter 13</a>. It uses Gnulib, so it has a convenience library. Gnulib aims for portability, so we can assess how good it is with Windows portability, at least for the few modules b64 uses.</p>&#13;
<p class="indent">To build for another platform, you need to configure the project for cross-compilation. For a full explanation of cross-compiling using the <span epub:type="pagebreak" id="page_456"/>Autotools, see Item 6 in <a href="ch18.xhtml">Chapter 18</a>. For now, just be aware that the configuration options you’ll need are <span class="literal">--build</span> and <span class="literal">--host</span>. The first option describes the system on which you’ll be building the software, and the second option describes the system on which the generated software will be executed. In order to discover our build platform, we can run the <span class="literal">config.guess</span> script installed into the root of our project by <span class="literal">automake</span> (via <span class="literal">autoreconf</span>). To do this, we’ll need to bootstrap the project for a regular build so that <span class="literal">config.guess</span> gets installed.<sup><a id="ch17fn_4" href="footnote.xhtml#ch17fn4">4</a></sup> Let’s do that within the <em>b64</em> directory itself:</p>&#13;
<pre>$ <span class="codestrong1">cd b64</span>&#13;
$ <span class="codestrong1">./bootstrap.sh</span>&#13;
<span class="ash">Module list with included dependencies (indented):</span>&#13;
    <span class="ash">absolute-header</span>&#13;
  <span class="ash">base64</span>&#13;
    <span class="ash">extensions</span>&#13;
    <span class="ash">extern-inline</span>&#13;
<span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">configure.ac:12: installing './compile'</span>&#13;
configure.ac:20: installing './config.guess'&#13;
configure.ac:20: installing './config.sub'&#13;
<span class="ash">configure.ac:6: installing './install-sh'</span>&#13;
<span class="ash">configure.ac:6: installing './missing'</span>&#13;
<span class="ash">Makefile.am: installing './depcomp'</span>&#13;
$&#13;
$ <span class="codestrong1">./config.guess</span>&#13;
x86_64-pc-linux-gnu&#13;
$</pre>&#13;
<p class="indent">Running <span class="literal">config.guess</span> is how <span class="literal">configure</span> determines the default value to use for the <span class="literal">--build</span> option, so it will always be correct. Determining the value we should use for the <span class="literal">--host</span> option is just a bit more difficult. We need to find the prefix on our cross tool chain, because the <span class="literal">--host</span> option value is what <span class="literal">configure</span> uses to find the correct tool chain and to set up our <span class="literal">CC</span> and <span class="literal">LD</span> variables.</p>&#13;
<p class="indent">This can be done in a few different ways. You can use your system’s package manager to determine what files were installed when you installed the mingw-w64 meta package, or you can look in your <em>/usr/bin</em> directory to see what the compiler is named—this usually works, and actually <em>does</em> work for this tool chain, but sometimes cross tool chains are installed into a completely different directory, so I’ll use my package manager. Your package manager has similar options, but you can follow along directly with my usage if you happen to be on a Debian-based system:</p>&#13;
<pre>$ <span class="codestrong1">dpkg -l | grep mingw</span>&#13;
<span class="ash">ii  binutils-mingw-w64-i686 ...</span>&#13;
<span class="ash">ii  binutils-mingw-w64-x86-64 ...</span>&#13;
<span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">ii  gcc-mingw-w64-i686 ...</span>&#13;
<span class="ash">ii</span>  <span class="codestrong1">gcc-mingw-w64-x86-64</span> <span class="ash">... GNU C compiler for MinGW-w64 targeting Win64</span>&#13;
<span epub:type="pagebreak" id="page_457"/><span class="ash">ii  mingw-w64 ... Development environment targeting 32- and 64-bit Windows</span>&#13;
<span class="codeitalic1a">--snip</span><span class="codeitalic1a">--</span>&#13;
$ <span class="codestrong1">dpkg -L gcc-mingw-w64-x86-64</span>&#13;
<span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">/usr/lib/gcc/</span>x86_64-w64-mingw32&#13;
<span class="ash">/usr/lib/gcc/</span>x86_64-w64-mingw32<span class="ash">/5.3-win32</span>&#13;
<span class="ash">/usr/lib/gcc/</span>x86_64-w64-mingw32<span class="ash">/5.3-win32/libgcc_s_seh-1.dll</span>&#13;
<span class="ash">/usr/lib/gcc/</span>x86_64-w64-mingw32<span class="ash">/5.3-win32/libgcov.a</span>&#13;
<span class="codeitalic1a">--snip--</span>&#13;
$</pre>&#13;
<p class="indent">The first command lists all of the installed packages on my system and filters the list through <span class="literal">grep</span>, searching for anything associated with <em>mingw</em>. The equivalent <span class="literal">rpm</span> command on Red Hat–based systems would be <span class="literal">rpm -qa | grep mingw</span>. The package I’m looking for will be related to the GCC C compiler and <span class="literal">x86_64</span> development. It will likely look very similar, if not exactly the same, on your system.</p>&#13;
<p class="indent">The second command lists the files installed by that package. Here, I’m looking for the compiler, standard C library, headers, and other target-specific files. The equivalent <span class="literal">rpm</span> command would be <span class="literal">rpm -ql mingw64-gcc</span>.<sup><a id="ch17fn_5" href="footnote.xhtml#ch17fn5">5</a></sup> The tag I’m searching for is <span class="literal">x86_64-w64-mingw32</span>. It should look similar in structure (but not content) to the value printed previously by our execution of <span class="literal">./config.guess</span>. This is the value that should be used with the <span class="literal">--host</span> option on the <span class="literal">configure</span> command line. It’s used by <span class="literal">configure</span> as a prefix for <span class="literal">gcc</span>, and a careful examination of your package manager output will show that there was indeed a program called <span class="literal">x86_64-w64-mingw32-gcc</span> installed into your <em>/</em><em>usr/bin</em> directory.</p>&#13;
<p class="indent">Now let’s use the information we’ve gathered to build b64 for Windows. From within the <em>b64</em> directory, create a subdirectory called <em>w64</em> (or whatever you like) and change into it; this will be the build directory we’ll use to build a 64-bit Windows version of b64. Run <span class="literal">../configure</span> with options to target Windows, as follows (assuming we’re still in the <em>b64</em> directory):<sup><a id="ch17fn_6" href="footnote.xhtml#ch17fn6">6</a></sup></p>&#13;
<pre>$ <span class="codestrong1">mkdir w64</span>&#13;
$ <span class="codestrong1">cd w64</span>&#13;
$ <span class="codestrong1">../configure --build=x86_64-pc-linux-gnu --host=x86_64-w64-mingw32</span>&#13;
<span class="ash">checking for a BSD-compatible install... /usr/bin/install -c</span>&#13;
<span class="ash">checking whether build environment is sane... yes</span>&#13;
checking for x86_64-w64-mingw32-strip... x86_64-w64-mingw32-strip&#13;
<span class="ash">checking for a thread-safe mkdir -p... /bin/mkdir -p</span>&#13;
<span class="ash">checking for gawk... gawk</span>&#13;
<span class="ash">checking whether make sets $(MAKE)... yes</span>&#13;
<span epub:type="pagebreak" id="page_458"/><span class="ash">checking whether make supports nested variables... yes</span>&#13;
checking for x86_64-w64-mingw32-gcc... x86_64-w64-mingw32-gcc&#13;
<span class="ash">checking whether the C compiler works... yes</span>&#13;
checking for C compiler default output file name... a.exe&#13;
checking for suffix of executables... .exe&#13;
checking whether we are cross compiling... yes&#13;
checking for suffix of object files... o&#13;
<span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">configure: creating ./config.status</span>&#13;
<span class="ash">config.status: creating Makefile</span>&#13;
<span class="ash">config.status: creating lib/Makefile</span>&#13;
<span class="ash">config.status: creating config.h</span>&#13;
<span class="ash">config.status: executing depfiles commands</span>&#13;
$</pre>&#13;
<p class="indent">I’ve highlighted some of the important output lines from <span class="literal">configure</span> when cross-compiling. If you make a mistake entering the <span class="literal">--host</span> value on the command line, you’ll see output similar to the following:</p>&#13;
<pre>$ <span class="codestrong1">../configure --build=x86_64-pc-linux-gnu --host=x86_64-w64-oops</span>&#13;
<span class="ash">checking for a BSD-compatible install... /usr/bin/install -c</span>&#13;
<span class="ash">checking whether build environment is sane... yes</span>&#13;
<span class="ash">checking for</span> x86_64-w64-oops-strip... no&#13;
<span class="ash">checking for strip... strip</span>&#13;
configure: WARNING: using cross tools not prefixed with host triplet&#13;
<span class="codeitalic1a">--snip--</span>&#13;
$</pre>&#13;
<p class="indent">The warning is telling you that it could not find a <span class="literal">strip</span> program called <span class="literal">x86_64-w64-oops-strip</span> (not surprising). Most cross tool chains come with a properly prefixed version of <span class="literal">strip</span> because this is one of the tools in the <em>binutils</em> package, so this is a reasonable test. If <span class="literal">configure</span> can’t find a prefixed version of the tools, it falls back to using the base names of the tools, which may be perfectly fine if your cross tools are named by their base names but simply stored in a different directory (which you’ve presumably added to your <span class="literal">PATH</span>).</p>&#13;
<p class="indent">Now that we’ve configured the build for cross-compilation, everything else works exactly the same as a regular Linux build. Try running <span class="literal">make</span>:</p>&#13;
<pre>$ <span class="codestrong1">make</span>&#13;
<span class="ash">make  all-recursive</span>&#13;
<span class="ash">make[1]: Entering directory '/.../b64/w64'</span>&#13;
<span class="ash">Making all in lib</span>&#13;
<span class="ash">make[2]: Entering directory '/.../b64/w64/lib'</span>&#13;
<span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">make  all-recursive</span>&#13;
<span class="ash">make[3]: Entering directory '/.../b64/w64/lib'</span>&#13;
<span class="ash">make[4]: Entering directory '/.../b64/w64/lib'</span>&#13;
<span class="ash">depbase=`echo base64.o | sed 's|[^/]*$|.deps/&amp;|;s|\.o$||'`;\</span>&#13;
x86_64-w64-mingw32-gcc -DHAVE_CONFIG_H -I. -I../../lib -I..     -g -O2 -MT&#13;
base64.o -MD -MP -MF $depbase.Tpo -c -o base64.o ../../lib/base64.c <span class="ash">&amp;&amp;\</span>&#13;
<span class="ash">mv -f $depbase.Tpo $depbase.Po</span>&#13;
<span epub:type="pagebreak" id="page_459"/><span class="ash">rm -f libgnu.a</span>&#13;
x86_64-w64-mingw32-ar cr libgnu.a base64.o&#13;
x86_64-w64-mingw32-ranlib libgnu.a&#13;
<span class="ash">make[4]: Leaving directory '/.../b64/w64/lib'</span>&#13;
<span class="ash">make[3]: Leaving directory '/.../b64/w64/lib'</span>&#13;
<span class="ash">make[2]: Leaving directory '/.../b64/w64/lib'</span>&#13;
<span class="ash">make[2]: Entering directory '/.../b64/w64'</span>&#13;
x86_64-w64-mingw32-gcc -DHAVE_CONFIG_H -I. -I..  -I./lib -I../lib   -g -O2 -MT&#13;
src/src_b64-b64.o -MD -MP -MF src/.deps/src_b64-b64.Tpo -c -o src/src_b64-&#13;
b64.o `test -f 'src/b64.c' || echo '../'`src/b64.c&#13;
<span class="ash">mv -f src/.deps/src_b64-b64.Tpo src/.deps/src_b64-b64.Po</span>&#13;
x86_64-w64-mingw32-gcc  -g -O2   -o src/b64.exe src/src_b64-b64.o lib/libgnu.a&#13;
<span class="ash">make[2]: Leaving directory '/.../b64/w64'</span>&#13;
<span class="ash">make[1]: Leaving directory '/.../b64/w64'</span>&#13;
$&#13;
$ <span class="codestrong1">ls -1p src</span>&#13;
b64.exe&#13;
<span class="ash">src_b64-b64.o</span>&#13;
$</pre>&#13;
<p class="indent">I’ve highlighted the lines that indicate we’re using the <em>mingw-w64</em> cross tool chain to build b64. A listing of the <em>src</em> directory shows our Windows executable, <span class="literal">b64.exe</span>.</p>&#13;
<p class="indent">To be complete, let’s copy this program over to a Windows system and give it a try. As mentioned previously, I have Windows 10 installed in a virtual machine on my Linux system so I can simply run it in place from a Windows-mapped drive (<span class="literal">Z:</span>, in my case):</p>&#13;
<pre>Z:\...\b64\w64\src&gt;<span class="codestrong1">dir /B</span>&#13;
src_b64-b64.o&#13;
b64.exe&#13;
Z:\...\b64\w64\src&gt;<span class="codestrong1">type ..\..\bootstrap.sh | b64.exe</span>&#13;
IyEvYmluL3NoCmdudWxpYi10b29sIC0tdXBkYXRlCmF1dG9yZWNvbmYgLWkK&#13;
Z:\...\b64\w64\src&gt;<span class="codestrong1">set /p="IyEvYmluL3NoCmdudWxpYi10b29sIC0tdXBkYXRlCmF1dG9yZWN</span>&#13;
<span class="codestrong1">vbmYgLWkK" &lt;nul | b64.exe -d</span>&#13;
#!/bin/sh&#13;
gnulib-tool --update&#13;
autoreconf -i&#13;
&#13;
Z:\...\b64\w64\src&gt;</pre>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Don’t be concerned about the <em><span class="literal">set /p</span></em> command—it’s just a tricky way of echoing text to the Windows console without a trailing newline, since <em><span class="literal">cmd.exe</span></em>’s <em><span class="literal">echo</span></em> statement has no option to suppress the trailing newline.</em></p>&#13;
</div>&#13;
<p class="indent">I’m not going to try to tell you that you’ll never experience problems building Windows software this way. You will, but they’ll be porting issues related primarily to a few POSIX system calls made directly by your project’s source code. I will, however, say that whatever problems you do run into will be a proper subset of those you’d experience if you tried to use Microsoft tools to build this package. In addition to any source-code-porting issues <span epub:type="pagebreak" id="page_460"/>you might find (they’ll still be there, even with Microsoft tools), you’d also have to work the kinks out of hand-configured Visual Studio solution and project files or Microsoft <span class="literal">nmake</span> files. For some projects, it’s worth the extra effort to be able to access the additional fine-grained tuning available when using Microsoft tools. For others, such tuning is not that important; building these projects for Windows on a Linux system works very well.</p>&#13;
<h3 class="h3" id="ch17sec5">Windows Subsystem for Linux</h3>&#13;
<p class="noindent">Before we leave the Linux world behind, let’s examine the Windows Subsystem for Linux (WSL) as an option for building Windows software using GNU tools.</p>&#13;
<p class="indent">You can obtain a flavor of Linux for WSL by downloading the version you want to use from the Windows Store. Before doing this, however, you must enable the optional Windows Subsystem for Linux feature. You can do this either from the <strong>Windows Features</strong> panel (type <strong>windows features</strong> into the Cortana search bar and select the top result) or from a PowerShell command prompt opened as <em>Administrator</em>.</p>&#13;
<p class="indent">From the <strong>Windows Features</strong> panel, scroll down until you find the entry for <strong>Windows Subsystem for Linux</strong>, check the associated checkbox, and click <strong>OK</strong>. Alternatively, from a PowerShell prompt (as <em>Administrator</em>), enter the following command and follow the prompts:</p>&#13;
<pre>PS C:\Windows\system32&gt; <span class="codestrong1">Enable-WindowsOptionalFeature -Online -FeatureName</span>&#13;
 <span class="codestrong1">Microsoft-Windows-Subsystem-Linux</span></pre>&#13;
<p class="indent">Installing the Windows Subsystem for Linux will require a system restart.</p>&#13;
<p class="indent">Now open the Windows Store and search for “Windows Subsystem for Linux,” select the “Run Linux on Windows” search result, and select the Linux flavor you want to install. On my system, installing the Ubuntu 18.04 flavor downloaded about 215MB and installed an “Ubuntu 18.04” icon in my Start menu.</p>&#13;
<p class="indent">Upon first execution, the terminal window displayed text indicating that the system was being installed:</p>&#13;
<pre>Installing, this may take a few minutes...&#13;
Please create a default UNIX user account. The username does not need to match&#13;
your Windows username.&#13;
For more information visit: https://aka.ms/wslusers&#13;
Enter new UNIX username: jcalcote&#13;
Enter new UNIX password:&#13;
Retype new UNIX password:&#13;
passwd: password updated successfully&#13;
Installation successful!&#13;
To run a command as administrator (user "root"), use "sudo &lt;command&gt;".&#13;
See "man sudo_root" for details.&#13;
&#13;
$</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_461"/>Use the <span class="literal">mount</span> command to see how Microsoft integrates the Windows and Linux filesystems:</p>&#13;
<pre>$ <span class="codestrong1">mount</span>&#13;
<span class="ash">rootfs on / type lxfs (rw,noatime)</span>&#13;
<span class="ash">sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,noatime)</span>&#13;
<span class="ash">proc on /proc type proc (rw,nosuid,nodev,noexec,noatime)</span>&#13;
<span class="ash">none on /dev type tmpfs (rw,noatime,mode=755)</span>&#13;
<span class="ash">devpts on /dev/pts type devpts (rw,nosuid,noexec,noatime,gid=5,mode=620)</span>&#13;
<span class="ash">none on /run type tmpfs (rw,nosuid,noexec,noatime,mode=755)</span>&#13;
<span class="ash">none on /run/lock type tmpfs (rw,nosuid,nodev,noexec,noatime)</span>&#13;
<span class="ash">none on /run/shm type tmpfs (rw,nosuid,nodev,noatime)</span>&#13;
<span class="ash">none on /run/user type tmpfs (rw,nosuid,nodev,noexec,noatime,mode=755)</span>&#13;
<span class="ash">binfmt_misc on /proc/sys/fs/binfmt_misc type binfmt_misc (rw,noatime)</span>&#13;
C: on /mnt/c type drvfs (rw,noatime,uid=1000,gid=1000)&#13;
$</pre>&#13;
<p class="indent">The key item of interest (highlighted) here is the fact that your Windows <em>C:</em> drive is mounted under <em>/mnt/c</em> on this Linux installation.</p>&#13;
<p class="indent">On the other side of the coin, the Linux root filesystem is installed into your Windows filesystem in the hidden user-specific <em>AppData</em> directory. For example, I found my Ubuntu 18.04 installation’s root filesystem at <em>C:\Users\</em>your-username<em>\AppData\Local\Packages\CanonicalGroupLimited .UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs</em>.<sup><a id="ch17fn_7" href="footnote.xhtml#ch17fn7">7</a></sup></p>&#13;
<p class="indent">If you selected a Debian-based distribution, start by updating your system software repository cache with <span class="literal">sudo apt-get update</span>. Then you can install development tools like GCC and the Autotools in the usual manner for the distro you selected:</p>&#13;
<pre>$ <span class="codestrong1">sudo apt-get install gcc make autoconf automake libtool libtool-bin</span></pre>&#13;
<p class="indent">If you’re at all familiar with Ubuntu and <span class="literal">apt</span>, you’ll see there’s no significant difference between the output of the preceding command on WSL Ubuntu 18.04 and a native installation of Ubuntu 18.04. That’s because you’re really running Ubuntu 18.04 on Windows here.</p>&#13;
<p class="indent">As with a regular installation of Ubuntu 18.04, if you create a <em>bin</em> directory in your home directory and then open a new Ubuntu 18.04 terminal window, you’ll find your personal <em>bin</em> directory at the beginning of your <span class="literal">PATH</span>. Do this now so you can create a symlink, <em>~/bin/gnulib-tools</em>, that refers to the <span class="literal">gnulib-tool</span> in your Windows clone of Gnulib, as we did when we built b64 on Linux:</p>&#13;
<pre>$ <span class="codestrong1">ln -s /mnt/c/Users/.../gnulib/gnulib-tool ~/bin/gnulib-tool</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_462"/>Change into the <em>/mnt/c/Users/.../b64</em> directory and run <span class="literal">./bootstrap.sh</span>, followed by ./<span class="literal">configure &amp;&amp; make</span> to build b64:</p>&#13;
<pre>$ <span class="codestrong1">cd /mnt/c/Users/.../b64</span>&#13;
$ <span class="codestrong1">./bootstrap.sh</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">./configure &amp;&amp; make</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">cd src</span>&#13;
$ <span class="codestrong1">./b64 &lt;../../../b64/bootstrap.sh</span>&#13;
IyEvYmluL3NoCmdudWxpYi10b29sIC0tdXBkYXRlCmF1dG9yZWNvbmYgLWkK$&#13;
$ <span class="codestrong1">printf "IyEvYmluL3NoCmdudWxpYi10b29sIC0tdXBkYXRlCmF1dG9yZWNvbmYgLWkK" | ./</span>&#13;
<span class="codestrong1">b64 -d</span>&#13;
#!/bin/sh&#13;
gnulib-tool --update&#13;
autoreconf -i&#13;
$</pre>&#13;
<p class="indent">Wonderful! Except that this is a Linux program, not a Windows program:</p>&#13;
<pre>$ <span class="codestrong1">objdump -i b64</span>&#13;
BFD header file version (GNU Binutils for Ubuntu) 2.30&#13;
elf64-x86-64&#13;
 (header little endian, data little endian)&#13;
  i386&#13;
elf32-i386&#13;
 (header little endian, data little endian)&#13;
  i386&#13;
<span class="codeitalic1">--snip--</span>&#13;
$</pre>&#13;
<p class="indent">Attempting to run this program from a Windows command prompt will result in the Windows equivalent of a blank stare. You see, what you really have here with WSL is an inexpensive form of virtual machine guest with some built-in filesystem integration. That’s not to say it’s not useful. It’s very handy to have Linux closely integrated with Windows for many purposes.</p>&#13;
<p class="indent">So what can we do? Our only option is to do the same thing we did on our native Linux installation earlier—install mingw-w64 and cross-compile. The process is identical, so I won’t reiterate the details. Refer to that discussion in “Cross-Compiling for Windows on Linux” on <a href="ch17.xhtml#page_454">page 454</a> for instructions.</p>&#13;
<h3 class="h3" id="ch17sec6">Cygwin</h3>&#13;
<p class="noindent">The Cygwin project was established in 1995 by Cygnus Solutions as an effort to create tool chains using GNU software for the various embedded environments for which the company was hired to provide development tools.</p>&#13;
<p class="indent">Cygwin’s general philosophy is that GNU packages should be able to be compiled for Windows without any modifications to the source code at <span epub:type="pagebreak" id="page_463"/>all. Time is money to a support company, and any time not spent modifying source code is money in the bank. They wanted their engineers to <em>use</em> GNU tools in these environments, not spend their time porting them.</p>&#13;
<p class="indent">So how do they do this? Well, most GNU packages are written in C and use the C standard library for accessing most of the system functionality they require. The C standard library—being standardized—is portable by definition. Additionally, GNU projects strive for portability—at least among Unix flavors. Nevertheless, there is a subset of POSIX system functionality of which many GNU packages avail themselves, including POSIX threads (pthreads) and system calls like <span class="literal">fork</span>, <span class="literal">exec</span>, and <span class="literal">mmap</span>. While recent C and C++ standards now include a threading API, those other system calls are very specific to Unix and Linux. In fact, they have no direct counterparts on Windows that align well enough to use without some adapter code between the caller and the Windows API.</p>&#13;
<p class="indent">For a simple example, when you get right down to the bare metal, the two kernels work fundamentally differently with respect to how processes are created. Windows uses the Win32 <span class="literal">CreateProcess</span> function to create a new process and load a program into it in a single step. Unix, on the other hand, uses the <span class="literal">fork</span> and <span class="literal">exec</span> system calls to respectively clone an existing process and replace the contents of the clone with another program.</p>&#13;
<p class="indent">It’s actually fairly easy to replace the <span class="literal">fork</span>-<span class="literal">exec</span> pair with a call to <span class="literal">CreateProcess</span>. The true difficulties arise when <span class="literal">fork</span> is used independently of <span class="literal">exec</span>, and this does happen occasionally.<sup><a id="ch17fn_8" href="footnote.xhtml#ch17fn8">8</a></sup> There is simply no way to make <span class="literal">CreateProcess</span> do only half its job.<sup><a id="ch17fn_9" href="footnote.xhtml#ch17fn9">9</a></sup> Many GNU programs don’t use <span class="literal">fork</span> without <span class="literal">exec</span>, but some important ones do. Mapping these calls to the Windows API is difficult at best, and it’s often impossible without significant structural changes to the source code.</p>&#13;
<p class="indent">Cygnus therefore elected to create a shim library of POSIX system call functionality. This library is called <em>cygwin1.dll</em>, and programs built using Cygwin are linked to this library and therefore depend on it at runtime. More to the point, every standard library call and most system calls pass though <em>cygwin1.dll</em> so that porting to a new platform without existing tools is an easy process.</p>&#13;
<p class="indent">You can detect if a Windows program was built for the Cygwin platform by simply looking for <em>cygwin1.dll</em> in its dependency list.<sup><a id="ch17fn_10" href="footnote.xhtml#ch17fn10">10</a></sup> But the Cygwin platform is not the only target that Cygwin supports. The mingw-w64 tool <span epub:type="pagebreak" id="page_464"/>chains have been ported to Cygwin and may be used as cross-compilers in Cygwin to build native Windows software, just as we did on Linux.</p>&#13;
<p class="indent">In 1999, Red Hat purchased Cygnus Solutions, and Cygwin has been maintained by various Red Hat employees and outside volunteers since then. Because of this maturity, Cygwin’s package repository is very large, and its Windows POSIX environment is one of the most complete implementations available. Cygwin is one of the most-used systems for porting GNU and other software to Windows.</p>&#13;
<h4 class="h4" id="ch17sec6-1"><em>Installing Cygwin</em></h4>&#13;
<p class="noindent">To install Cygwin, download the installer from Cygwin’s website at <em><a href="https://www.cygwin.com">https://www.cygwin.com</a></em>. The installer is called <span class="literal">setup-x86_64.exe</span>. Cygwin’s installer does not use the Windows installation database; you can remove Cygwin merely by deleting its installation directory.</p>&#13;
<p class="indent">A unique and useful aspect of the Cygwin installer is that it caches its downloaded packages at a location of your choice on your filesystem. This cache can then be used as a standalone installation source for later installations.</p>&#13;
<p class="indent">Running the installer presents a setup wizard, the opening page of which is shown in <a href="ch17.xhtml#ch17fig1">Figure 17-1</a>.</p>&#13;
<p class="image"><img src="../images/17fig01.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig1"><em>Figure 17-1: The initial copyright screen of the Cygwin64 setup program</em></p>&#13;
<p class="indent">Click <strong>Next</strong> to move to the second page of the setup wizard, shown in <a href="ch17.xhtml#ch17fig2">Figure 17-2</a>.</p>&#13;
<p class="indent">You’re asked here to select how you want to obtain packages. Your options include the internet or a local installation directory. You may also elect to download files from the internet but not install them, which is useful for building a local installation source for installing multiple systems from the same cache of downloaded files. Select <strong>Install from Internet</strong> and click <strong>Next</strong> to continue to the next page, shown in <a href="ch17.xhtml#ch17fig3">Figure 17-3</a>.</p>&#13;
<p class="image"><span epub:type="pagebreak" id="page_465"/><img src="../images/17fig02.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig2"><em>Figure 17-2: The installation type screen of the Cygwin64 setup program</em></p>&#13;
<p class="image"><img src="../images/17fig03.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig3"><em>Figure 17-3: The installation location screen of the Cygwin64 setup program</em></p>&#13;
<p class="indent">Here, you’re asked where you want to install Cygwin. The default location is <em>C:\cygwin64</em>, and it’s recommended that you just stick with this default location, though Cygwin does a better job than some of the other installers of managing the required system changes if you do choose to install in a nondefault location.</p>&#13;
<p class="indent">If you’re a Windows power user, you’re very likely feeling that gut-wrenching desire right now to change the default location to something more reasonable on Windows. I admonish you not to do this. The problem is that you’re trying to view Cygwin as an application and, while it technically is one, it can also be viewed as being somewhat akin to a full Linux <span epub:type="pagebreak" id="page_466"/>virtual machine installation. It provides a foreign (to Windows) development environment, which puts it squarely in the camp of a sibling operating system to Windows. From this perspective, it’s perhaps a bit easier to understand why the <em>Cygwin64</em> directory deserves a special place next to the <em>Windows</em> directory on your hard drive.</p>&#13;
<p class="indent">Click <strong>Next</strong> to move to the next page, shown in <a href="ch17.xhtml#ch17fig4">Figure 17-4</a>.</p>&#13;
<p class="image"><img src="../images/17fig04.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig4"><em>Figure 17-4: The local package directory screen of the Cygwin64 setup program</em></p>&#13;
<p class="indent">You’re now asked to select a local package directory. This is the directory where downloaded package files are stored. Choose a reasonable location on your Windows system—such as your <em>Downloads</em> directory. A <em>cygwin</em> directory will be created at this location and will contain a subdirectory for each internet source from which you download packages. Click <strong>Next</strong> to move to the next screen, shown in <a href="ch17.xhtml#ch17fig5">Figure 17-5</a>.</p>&#13;
<p class="image"><img src="../images/17fig05.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig5"><em>Figure 17-5: The proxy settings screen of the Cygwin64 setup program</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_467"/>You may now select or modify your proxy settings. Usually, you can just use the default system proxy settings. Those who use a proxy in their work or home environments will be used to configuring this for internet applications and will know what to do with the options here. Click <strong>Next</strong> to move to the next screen, shown in <a href="ch17.xhtml#ch17fig6">Figure 17-6</a>.</p>&#13;
<p class="image"><img src="../images/17fig06.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig6"><em>Figure 17-6: The package download source screen of the Cygwin64 setup program</em></p>&#13;
<p class="indent">Select a package download source. As with a Linux distribution, there are multiple sites you can use as a package source for Cygwin. Select one that’s geographically close to you for the fastest installation and then click <strong>Next</strong> to begin downloading the package catalog, shown in <a href="ch17.xhtml#ch17fig7">Figure 17-7</a>.</p>&#13;
<p class="image"><img src="../images/17fig07.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig7"><em>Figure 17-7: The package catalog download screen of the Cygwin64 setup program</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_468"/>Downloading and parsing the package catalog from the selected source site takes only a few seconds, and then the package manager main screen is displayed, as shown in <a href="ch17.xhtml#ch17fig8">Figure 17-8</a>.</p>&#13;
<p class="image"><img src="../images/17fig08.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig8"><em>Figure 17-8: The package manager screen of the Cygwin64 setup program</em></p>&#13;
<p class="indent">I’ve expanded the All root element and the Devel category to show you the first few packages in this category, sorted alphabetically. Select the following additional packages in the Devel category by clicking the down arrow on the right end of the New column and choosing the highest version number available in the list for each package (with a few exceptions):</p>&#13;
<ul>&#13;
<li class="noindent">autoconf2.5 (2.69-3)</li>&#13;
<li class="noindent">automake (10-1)</li>&#13;
<li class="noindent">automake1.15 (1.15.1-1)</li>&#13;
<li class="noindent">binutils (2.29-1)</li>&#13;
<li class="noindent">gcc-core (7.4.0-1)</li>&#13;
<li class="noindent">gcc-g++ (7.4.0-1 - optional)</li>&#13;
<li class="noindent">libtool (2.4.6-6)</li>&#13;
<li class="noindent">make (4.2.1-2)</li>&#13;
</ul>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>As you scroll though the list of packages, you’ll note that some have been preselected for you. Do not deselect any of the default packages.</em></p>&#13;
</div>&#13;
<p class="indent">Each entry in this list has a base package name followed by a package version in parentheses. The versioning system is similar to that of a standard Linux distribution. The upstream source package version is suffixed with a dash, followed by a packager’s version. For example, the <em>autoconf2.5</em> package has a source package version of 2.69 and a packager’s version of 3. The packager’s version is specific to the distribution—in this case, Cygwin.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_469"/>Cygwin uses a rolling release mechanism, meaning that Cygwin packages are updated somewhat independently as newer source package versions become available and as the Cygwin maintainers consume them. The versions I’ve listed here were current at the time of this writing. Your most recent version numbers may be newer. Select the most recent rather than the ones I’ve listed. Feel free to use the search box at the top of the dialog to quickly find the packages in the list. Once you’ve selected these additional packages, click <strong>Next</strong> to continue to the next page, shown in <a href="ch17.xhtml#ch17fig9">Figure 17-9</a>.</p>&#13;
<p class="image"><img src="../images/17fig09.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig9"><em>Figure 17-9: The download confirmation screen of the Cygwin64 setup program</em></p>&#13;
<p class="indent">After reviewing the list here to ensure you’ve selected the desired set, click <strong>Next</strong> to start the download process, shown in <a href="ch17.xhtml#ch17fig10">Figure 17-10</a>.</p>&#13;
<p class="image"><img src="../images/17fig10.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig10"><em>Figure 17-10: The package download progress screen of the Cygwin64 setup program</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_470"/>Since you elected to install only a few packages, this should not take long. Once the process completes, click <strong>Next</strong> to continue to the next screen, shown in <a href="ch17.xhtml#ch17fig11">Figure 17-11</a>.</p>&#13;
<p class="image"><img src="../images/17fig11.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig11"><em>Figure 17-11: The icon selection screen of the Cygwin64 setup program</em></p>&#13;
<p class="indent">Select where you’d like icons to be created on your Windows system. You have two checkbox options here: Desktop and Start Menu. If you elect not to add any icons, you can still run the Cygwin terminal program by executing <em>C:\cygwin64\cygwin.bat</em> from an Explorer window or from a command or PowerShell prompt.</p>&#13;
<p class="indent">Click <strong>Finish</strong> to close the package manager. When you want to modify your Cygwin environment by adding or removing packages, or updating your existing packages to newer versions, just run <span class="literal">setup-x86_64.exe</span> again.<sup><a id="ch17fn_11" href="footnote.xhtml#ch17fn11">11</a></sup> You’ll need to go through all the same initial screens, but the package manager will remember your previous options and all the packages you currently have installed, allowing you to modify the existing configuration as you desire.</p>&#13;
<h4 class="h4" id="ch17sec6-2"><em>Opening the Cygwin Terminal</em></h4>&#13;
<p class="noindent">The first execution of the Cygwin terminal indicates that skeleton <em>.bashrc</em>, <em>.bash_profile</em>, <em>.inputrc</em>, and <em>.profile</em> files are copied into your <em>/home/</em>username directory within the Cygwin filesystem.</p>&#13;
<p class="indent">The best way to understand the Cygwin filesystem is to execute the <span class="literal">mount</span> command within the terminal to display how Cygwin maps your Windows filesystem resources into its own filesystem:</p>&#13;
<pre>$ <span class="codestrong1">mount</span>&#13;
C:/cygwin64/bin on /usr/bin type ntfs (binary,auto)&#13;
<span epub:type="pagebreak" id="page_471"/>C:/cygwin64/lib on /usr/lib type ntfs (binary,auto)&#13;
C:/cygwin64 on / type ntfs (binary,auto)&#13;
C: on /cygdrive/c type ntfs (binary,posix=0,user,noumount,auto)&#13;
Z: on /cygdrive/z type vboxsharedfolderfs (binary,posix=0,user,noumount,auto)&#13;
$</pre>&#13;
<p class="indent">Cygwin auto-mounts <em>C:\cygwin64</em>, <em>C:\cygwin64\bin</em>, and <em>C:\cygwin64\lib</em> to <em>/</em>, <em>/usr/bin</em>, and <em>/usr/lib</em>, respectively. It also auto-mounts all of your Windows drive roots to directories named by the drive letter under the <em>/cygdrive</em> directory. I have my Windows operating system installed on the <em>C:\</em> drive, and I have the <em>Z:\</em> drive mapped to my Linux host though VirtualBox’s shared folder system. Therefore, I have full access to both my Windows filesystem and my Linux host filesystem from within Cygwin’s POSIX environment.<sup><a id="ch17fn_12" href="footnote.xhtml#ch17fn12">12</a></sup> I also have access to Cygwin’s entire filesystem from Windows, via the <em>C:\Cygwin64</em> directory.</p>&#13;
<h4 class="h4" id="ch17sec6-3"><em>Testing the Build</em></h4>&#13;
<p class="noindent">Because Cygwin provides access to your Windows environment within its own POSIX environment, you can simply run a previously installed standalone copy of Git for Windows directly from the Cygwin shell prompt. An even better option, but one that only works inside of the Cygwin terminal, is to install Cygwin’s version of git from its package manager. Why is this option better? Because Cygwin’s git package understands Cygwin’s filesystem conventions better than the Windows version does. For instance, the Windows version will sometimes create files with the wrong permissions when viewed from a POSIX environment.</p>&#13;
<p class="indent">Unlike MinGW and Msys2, Cygwin can manage symlinks correctly within the Cygwin filesystem. Recall from <a href="ch13.xhtml">Chapter 13</a>, and earlier in this chapter, that we need to create a symlink to the <span class="literal">gnulib-tool</span> utility somewhere in our <span class="literal">PATH</span> so that b64’s <span class="literal">bootstrap.sh</span> script is able to find Gnulib. Let’s do that now in the Cygwin terminal. Fill in the elided section of the following command with the proper path to your clone of Gnulib:</p>&#13;
<pre>$ <span class="codestrong1">ln -s /cygdrive/c/.../gnulib/gnulib-tool /usr/bin/gnulib-tool</span></pre>&#13;
<p class="indent">This command creates a symbolic link in Cygwin’s <em>/usr/bin</em> directory, referring to the <span class="literal">gnulib-tool</span> program in the root of the Gnulib work area you cloned.</p>&#13;
<p class="indent">By default, Cygwin creates symlinks as text files flagged with the Windows <em>System</em> (S) attribute, making them invisible to normal Windows directory listing commands and within Windows File Explorer. If you examine the contents of a Cygwin symlink file, you’ll find it contains a magic <span epub:type="pagebreak" id="page_472"/>cookie, <span class="literal">!&lt;symlink&gt;</span>, followed by the path to the target filesystem entry in UTF-16 format (beginning with the little-endian byte order mark, 0xFFFE).</p>&#13;
<p class="indent">You can configure Cygwin to create true Windows symbolic links by exporting a <span class="literal">CYGWIN</span> environment variable containing the text <span class="literal">winsymlinks:nativestrict</span>. However, if you do this, you must then run your Cygwin terminal as Administrator, because creating Windows native symbolic links requires administrative rights by default. Recent versions of Windows 10 allow native symlinks to be created without elevated privileges if you’re willing to switch your system into so-called “developer mode.”</p>&#13;
<p class="indent">All that said, Cygwin’s own system of managing symlinks works really well, as long as the tools interpreting the links are built for the Cygwin platform. In fact, to see the contents of a Cygwin symlink file, you have to use a non-Cygwin tool because Cygwin tools will simply follow the symlink file, rather than open the file, even from a Windows command prompt!</p>&#13;
<p class="indent">Now, let’s build b64 for Windows. We’ll start by changing directories within the Cygwin terminal to the b64 work area you cloned on your Windows system and running the <span class="literal">bootstrap.sh</span> script to pull in our Gnulib dependencies and to run <span class="literal">autoreconf -i</span>:</p>&#13;
<pre>$ <span class="codestrong1">cd /cygdrive/c/.../b64</span>&#13;
$ <span class="codestrong1">./bootstrap.sh</span>&#13;
Module list with included dependencies (indented):&#13;
    absolute-header&#13;
  base64&#13;
<span class="codeitalic1">--snip--</span>&#13;
configure.ac:12: installing './compile'&#13;
configure.ac:20: installing './config.guess'&#13;
configure.ac:20: installing './config.sub'&#13;
configure.ac:6: installing './install-sh'&#13;
configure.ac:6: installing './missing'&#13;
Makefile.am: installing './depcomp'&#13;
$</pre>&#13;
<p class="indent">And now we can simply run <span class="literal">configure</span> and <span class="literal">make</span>. We’ll do this from within a subdirectory structure so we can reuse this work area for other build types later. Note there’s no need to specify <span class="literal">--build</span> or <span class="literal">--host</span> options here to set up a cross-compile. We’re running “native” Cygwin tools, which automatically build Cygwin programs designed to run on the host platform:</p>&#13;
<pre>$ <span class="codestrong1">mkdir -p cw-builds/cygwin</span>&#13;
$ <span class="codestrong1">cd cw-builds/cygwin</span>&#13;
$ <span class="codestrong1">../../configure</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
checking for C compiler default output file name... a.exe&#13;
checking for suffix of executables... .exe&#13;
<span class="codeitalic1">--snip--</span>&#13;
checking build system type... x86_64-unknown-cygwin&#13;
<span epub:type="pagebreak" id="page_473"/>checking host system type... x86_64-unknown-cygwin&#13;
<span class="codeitalic1">--snip</span><span class="codeitalic1">--</span>&#13;
configure: creating ./config.status&#13;
config.status: creating Makefile&#13;
config.status: creating lib/Makefile&#13;
config.status: creating config.h&#13;
config.status: executing depfiles commands&#13;
$&#13;
$ <span class="codestrong1">make</span>&#13;
make  all-recursive&#13;
make[1]: Entering directory '/cygdrive/c/.../cw-builds/cygwin'&#13;
<span class="codeitalic1">--snip--</span>&#13;
make[2]: Entering directory '/cygdrive/c/.../cw-builds/cygwin'&#13;
gcc -DHAVE_CONFIG_H -I. -I../../b64  -I./lib -I../../b64/lib   -g -O2 -MT src/&#13;
src_b64-b64.o -MD -MP -MF src/.deps/src_b64-b64.Tpo -c -o src/src_b64-b64.o&#13;
`test -f 'src/b64.c' || echo '../../b64/'`src/b64.c&#13;
mv -f src/.deps/src_b64-b64.Tpo src/.deps/src_b64-b64.Po&#13;
gcc  -g -O2   -o src/b64.exe src/src_b64-b64.o lib/libgnu.a&#13;
make[2]: Leaving directory '/cygdrive/c/.../cw-builds/cygwin'&#13;
make[1]: Leaving directory '/cygdrive/c/.../cw-builds/cygwin'&#13;
$</pre>&#13;
<p class="indent">Finally, we’ll test our new <span class="literal">b64.exe</span> program to see if it works on Windows. While the Cygwin terminal may look like Linux, it’s really just a Linux-like way of accessing Windows, so you can execute Windows programs from the Cygwin terminal. This is nice because it allows us to use the Bash version of <span class="literal">echo</span> with its <span class="literal">-n</span> option to suppress the default linefeed during our testing:</p>&#13;
<pre>$ <span class="codestrong1">cd src</span>&#13;
$ <span class="codestrong1">./b64.exe &lt;../../bootstrap.sh</span>&#13;
IyEvYmluL3NoCmdudWxpYi10b29sIC0tdXBkYXRlCmF1dG9yZWNvbmYgLWkK&#13;
$&#13;
$ <span class="codestrong1">echo -n "IyEvYmluL3NoCmdudWxpYi10b29sIC0tdXBkYXRlCmF1dG9yZWNvbmYgLWkK" |\</span>&#13;
  <span class="codestrong1">./b64 -d</span>&#13;
#!/bin/sh&#13;
gnulib-tool --update&#13;
autoreconf -i&#13;
$</pre>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>I did not use the</em> .exe <em>extension on the command to reverse the base64 encoding operation in this console listing. I wanted to show that, like Windows, Cygwin does not require the use of the extension on executable files.</em></p>&#13;
</div>&#13;
<p class="indent">If you run a dependency checker like Visual Studio’s <span class="literal">dumpbin.exe</span> or Cygwin’s <span class="literal">cygcheck</span> utility, you’ll find that this version of <span class="literal">b64.exe</span> depends heavily on <em>cygwin1.dll</em>, which must be shipped with your program. By default, Cygwin builds “Cygwin” software—software designed to run on the Cygwin platform, and an important part of the Cygwin platform is <em>cygwin1.dll</em> on Windows.</p>&#13;
<h4 class="h4" id="ch17sec6-4"><span epub:type="pagebreak" id="page_474"/><em>Building True Native Windows Software</em></h4>&#13;
<p class="noindent">You may also install the mingw-w64 tool chain and compile using the same techniques we used in “Cross-Compiling for Windows on Linux” on <a href="ch17.xhtml#page_454">page 454</a>. The mingw-w64 tool chain is available in the Cygwin package manager and is a Cygwin port of the same tool chain we installed earlier on Linux.</p>&#13;
<p class="indent">Let’s do that now. Run the <span class="literal">setup-x86_64.exe</span> program again and skip through all the leading dialogs until you come to the package manager window. After initial installation, the default view shown by the package manager window is a list of pending updates of packages you’ve already installed. Depending on how long it has been since your initial installation, this list may even be empty. Select the <strong>Full</strong> option from the <strong>View</strong> drop-down box to return to the complete list of packages. Locate and select (under the <strong>Devel</strong> category) the following packages for installation. You may see newer version options than I’ve listed here; select the latest available to you. You can enter a prefix (<strong>mingw64-</strong>) in the <strong>Search</strong> box to narrow down the result list to a subset of packages containing those you want.</p>&#13;
<ul>&#13;
<li class="noindent">mingw64-i686-gcc-core (7.4.0-1)</li>&#13;
<li class="noindent">mingw64-i686-gcc-g++ (7.4.0-1)</li>&#13;
<li class="noindent">mingw64-x86_64-gcc-core (7.4.0-1)</li>&#13;
<li class="noindent">mingw64-x86_64-gcc-g++ (7.4.0-1)</li>&#13;
</ul>&#13;
<p class="indent">The first two of these packages are for generating 32-bit Windows software, and the last two are for generating 64-bit Windows software. Click <strong>Next</strong> to continue and install these additional packages.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You may notice on the summary screen that other packages you did not explicitly select are also getting installed. That’s because these four are meta-packages, as described previously. If it has been a while since you initially installed Cygwin, you may also see updates for packages you previously installed.</em></p>&#13;
</div>&#13;
<p class="indent">Create other subdirectories under <em>b64/cw-builds</em> for 32- and 64-bit mingw-w64 builds:</p>&#13;
<pre>$ <span class="codestrong1">pwd</span>&#13;
/cygdrive/c/.../cw-builds&#13;
$ <span class="codestrong1">mkdir mingw32 mingw64</span>&#13;
$ <span class="codestrong1">cd mingw32</span>&#13;
$</pre>&#13;
<p class="indent">Let’s start by building the 32-bit Windows program in the <em>mingw32</em> directory using the i686 variation of the mingw-w64 cross tool set:</p>&#13;
<pre>$ <span class="codestrong1">cd mingw32</span>&#13;
$ <span class="codestrong1">../../configure --build=x86_64-unknown-cygwin --host=i686-w64-mingw32</span>&#13;
<span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">checking for C compiler default output file name... a.exe</span>&#13;
<span class="ash">checking for suffix of executables... .exe</span>&#13;
<span epub:type="pagebreak" id="page_475"/><span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">checking build system type... x86_64-unknown-cygwin</span>&#13;
<span class="ash">checking host system type...</span> i686-w64-mingw32&#13;
<span class="codeitalic1a">--snip--</span>&#13;
$&#13;
$ <span class="codestrong1">make</span>&#13;
<span class="ash">make  all-recursive</span>&#13;
<span class="codeitalic1a">--snip--</span>&#13;
i686-w64-mingw32-gcc <span class="ash">-DHAVE_CONFIG_H -I. -I../../b64  -I./lib -I../../lib  -g</span>&#13;
<span class="ash">-O2 -MT src/src_b64-b64.o -MD -MP -MF src/.deps/src_b64-b64.Tpo -c -o src/</span>&#13;
<span class="ash">src_b64-b64.o `test -f 'src/b64.c' || echo '../../'`src/b64.c</span>&#13;
<span class="ash">mv -f src/.deps/src_b64-b64.Tpo src/.deps/src_b64-b64.Po</span>&#13;
i686-w64-mingw32-gcc  <span class="ash">-g -O2</span>   -o src/b64.exe <span class="ash">src/src_b64-b64.o lib/libgnu.a</span>&#13;
<span class="ash">make[2]: Leaving directory '/cygdrive/c/.../cw-builds/mingw32'</span>&#13;
<span class="ash">make[1]: Leaving directory '/cygdrive/c/.../cw-builds/mingw32'</span>&#13;
$</pre>&#13;
<p class="indent">Though it may seem odd, you must use the <span class="literal">--build</span> and <span class="literal">--host</span> options on the <span class="literal">configure</span> command line here to cross-compile for Windows. The reason is the mingw-w64 tool chain is not the default tool chain on Cygwin. All you’re really doing is telling <span class="literal">configure</span> where to find the nondefault tools you want to use. From a certain point of view, it actually is a cross-compile because you’re building non-Cygwin software on the Cygwin platform.</p>&#13;
<p class="indent">Do the same for the 64-bit build:</p>&#13;
<pre>$ <span class="codestrong1">cd ../mingw64</span>&#13;
$ <span class="codestrong1">../../configure --build=x86_64-unknown-cygwin --host=x86_64-w64-mingw32</span>&#13;
<span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">checking for C compiler default output file name... a.exe</span>&#13;
<span class="ash">checking for suffix of executables... .exe</span>&#13;
<span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">checking build system type... x86_64-unknown-cygwin</span>&#13;
<span class="ash">checking host system type...</span> x86_64-w64-mingw32&#13;
<span class="codeitalic1a">--snip--</span>&#13;
$&#13;
$ <span class="codestrong1">make</span>&#13;
<span class="ash">make  all-recursive</span>&#13;
<span class="codeitalic1a">--</span><span class="codeitalic1a">snip--</span>&#13;
x86_64-w64-mingw32-gcc <span class="ash">-DHAVE_CONFIG_H -I. -I../..  -I./lib -I../../lib   -g</span>&#13;
<span class="ash">-O2 -MT src/src_b64-b64.o -MD -MP -MF src/.deps/src_b64-b64.Tpo -c -o src/</span>&#13;
<span class="ash">src_b64-b64.o `test -f 'src/b64.c' || echo '../../'`src/b64.c</span>&#13;
<span class="ash">mv -f src/.deps/src_b64-b64.Tpo src/.deps/src_b64-b64.Po</span>&#13;
x86_64-w64-mingw32-gcc  <span class="ash">-g -O2</span>   -o src/b64.exe <span class="ash">src/src_b64-b64.o lib/libgnu.</span>&#13;
<span class="ash">amake[2]: Leaving directory '/cygdrive/c/.../cw-builds/mingw64'</span>&#13;
<span class="ash">make[1]: Leaving directory '/cygdrive/c/.../cw-builds/mingw64'</span>&#13;
$</pre>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>It may seem strange that the 64-bit version of the gcc is called <em><span class="literal">x86_64-w64-mingw32-gcc</span></em>. What’s with that <em><span class="literal">32</span></em> on the end of the cross-tool prefix? The reason is that mingw was originally a 32-bit Windows compiler, named specifically mingw32. The mingw32 project was eventually renamed to MinGW, but tools and package names are harder to change once they’re in widespread use.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch17sec6-5"><span epub:type="pagebreak" id="page_476"/><em>Analyzing the Software</em></h4>&#13;
<p class="noindent">To really understand the differences between these builds, you’ll need to obtain a tool for looking inside the <span class="literal">b64.exe</span> files we generated using each of these three tool sets. You can run the <span class="literal">dumpbin.exe</span> utility that comes with Visual Studio or Cygwin’s <span class="literal">cygcheck</span> tool, if you like. I found a very nice tool called <em>Dependencies</em> on GitHub by user lucasg.<sup><a id="ch17fn_13" href="footnote.xhtml#ch17fn13">13</a></sup></p>&#13;
<p class="indent">First, let’s look at the <span class="literal">cygcheck</span> output for all three versions of the program. We’ll start in the <em>cw-builds</em> directory to give us easy access to all of them:</p>&#13;
<pre>   $ <span class="codestrong1">pwd</span>&#13;
   /cygdrive/c/Users/.../cw-builds&#13;
   $&#13;
<span class="ent">➊</span> $ <span class="codestrong1">cygcheck cygwin/src/b64.exe</span>&#13;
   C:\Users\...\cw-builds\cygwin\src\b64.exe&#13;
     C:\cygwin64\bin\cygwin1.dll&#13;
       C:\Windows\system32\KERNEL32.dll&#13;
         C:\Windows\system32\ntdll.dll&#13;
         C:\Windows\system32\KERNELBASE.dll&#13;
   $&#13;
<span class="ent">➋</span> $ <span class="codestrong1">cygcheck mingw32/src/b64.exe</span>&#13;
   C:\Users\...\cw-builds\mingw32\src\b64.exe&#13;
   $&#13;
<span class="ent">➌</span> $ <span class="codestrong1">cygcheck mingw64/src/b64.exe</span>&#13;
   C:\Users\...\cw-builds\mingw64\src\b64.exe&#13;
     C:\Windows\system32\KERNEL32.dll&#13;
       C:\Windows\system32\ntdll.dll&#13;
       C:\Windows\system32\KERNELBASE.dll&#13;
     C:\Windows\system32\msvcrt.dll&#13;
   $</pre>&#13;
<p class="indent">The concept being conveyed by the hierarchies here is that a library is a direct dependency of the library or program directly above it and an indirect dependency of ancestors farther up the chain. The Cygwin version at <span class="ent">➊</span> shows a dependency hierarchy with <em>cygwin1.dll</em> near the top, just under <span class="literal">b64.exe</span>, and with all other libraries as direct or indirect dependencies of that library. This implies that every system or library call made by <span class="literal">b64.exe</span> is being made directly to <em>cygwin1.dll</em>, which then calls the other libraries on its behalf.</p>&#13;
<p class="indent">The 64-bit mingw64 version at <span class="ent">➌</span> displays a similar hierarchy, except that the <span class="literal">b64.exe</span> program depends directly on <em>kernel32.dll</em> and <em>msvcrt.dll</em>. This is a native Windows program, by all accounts.</p>&#13;
<p class="indent">My version of the <span class="literal">cygcheck</span> utility has some problems with 32-bit native Windows software. You can see this at <span class="ent">➋</span>, where the tool shows us only the <span epub:type="pagebreak" id="page_477"/>program, <span class="literal">b64.exe</span>, with no library dependencies. To see the true details of this version, let’s switch to the Dependencies program I mentioned earlier. I’ve loaded all three versions of the program into one instance of Dependencies in <a href="ch17.xhtml#ch17fig12">Figure 17-12</a>.</p>&#13;
<p class="image"><img src="../images/17fig12.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig12"><em>Figure 17-12: Modules and exports for <span class="literal">b64.exe</span> built as a 32-bit mingw-w64 program</em></p>&#13;
<p class="indent">Here, you can see that the 32-bit mingw-w64 version really does have library dependencies similar to those of the 64-bit mingw-w64 version. The 32-bit version uses <em>C:\Windows\SysWOW64\msvcrt.dll</em>, and the 64-bit version uses <em>C:\Windows\system32\msvcrt.dll</em>. The same is true of <em>kernel32.dll</em>.</p>&#13;
<p class="indent">There are additional subtle differences between the Cygwin version and the mingw-w64 versions. For a simple example, the Cygwin version imports <span class="literal">getopt</span> from <em>cygwin1.dll</em>. You’ll perhaps recall that we used the POSIX <span class="literal">getopt</span> function to parse command line options in b64. You won’t find <span class="literal">getopt</span> in <em>msvcrt.dll</em>, however, so where does it come from? The mingw-w64 tool chain provides a static archive of such POSIX functionality that ends up becoming a part of <span class="literal">b64.exe</span>.</p>&#13;
<h3 class="h3" id="ch17sec7">MinGW: Minimalist GNU for Windows</h3>&#13;
<p class="noindent">In 1998, Colin Peters authored the initial release of what was then called <em>mingw32</em>. Later the numbers were dropped in order to avoid the implication that MinGW could only generate 32-bit software.<sup><a id="ch17fn_14" href="footnote.xhtml#ch17fn14">14</a></sup></p>&#13;
<p class="indent">MinGW initially offered only a Cygwin port of GCC. Sometime later, Jan-Jaap Van der Heijden created a native Windows port of GCC and added <span epub:type="pagebreak" id="page_478"/>a <em>binutils</em> package and GNU <span class="literal">make</span>. MinGW has been a very popular alternative to Cygwin ever since, mainly because of its primary goal of creating software that closely resembles software generated by Microsoft tools. For reasonably portable C code, no libraries other than Windows system and Visual Studio runtime libraries (<em>msvcrt.dll</em>) are required. Remember that mingw-w64 was not available until 2013, so MinGW was the only available open source option for generating native Windows code for more than 10 years.</p>&#13;
<p class="indent">This concept is central to the philosophy espoused by the MinGW project. The goal of MinGW is to use only the standard C library as an abstraction layer and to modify source code where necessary to make other key packages available under MinGW.</p>&#13;
<p class="indent">There is a significant portion of GNU software, however, that makes use of the <em>pthreads</em> library. To accommodate this major set of GNU packages, MinGW gave in to pragmatism by providing a library called <em>pthreads-win32.dll</em>. This library shows up so often in the dependency list for software today that many people don’t associate it with MinGW at all. Indeed, some portable software compiled using Microsoft’s tools has even used <em>pthreads-win32.dll</em> independently, as a portable threading library, relying on POSIX threads in both POSIX and Windows environments.<sup><a id="ch17fn_15" href="footnote.xhtml#ch17fn15">15</a></sup></p>&#13;
<p class="indent">There is one major drawback to using MinGW, which is lately becoming more of an issue: MinGW still only generates 32-bit native Windows applications. Microsoft and Intel have recently announced jointly that some near-future version of Windows would only support 64-bit hardware. While 32-bit software will generally run on 64-bit systems, this may change with time. MinGW’s package repository does not provide a port of its GCC compiler that generates 64-bit Windows object code, but there are third parties that make mingw-w64 available on the MinGW platform if you’re willing to move away from MinGW’s package manager. However, this sort of activity is discouraged because adding third-party packages to the environment can cause dependency problems the package manager can’t resolve.</p>&#13;
<p class="indent">The MinGW community has survived on its name for many years, and the project has only recently started taking monetary donations to help with maintenance. Perhaps the additional financial support will spur the community into moving forward with these important upgrades.</p>&#13;
<h4 class="h4" id="ch17sec7-1"><em>Installing MinGW</em></h4>&#13;
<p class="noindent">In spite of MinGW generating only 32-bit Windows programs and libraries, it’s worth looking at here because using it is so simple and effective for software that’s already portable. Once you’ve begun to understand how MinGW and Msys work, moving to the other Windows-based POSIX platforms is a trivial task because all of them are based on some form of an Msys-like environment.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_479"/>We’ll start by installing MinGW, which could not be simpler. Navigate in your favorite browser to <em><a href="http://www.mingw.org">http://www.mingw.org</a></em>. Click the <strong>Downloads</strong> tab in the top menu bar. This link takes you to the <em>osdn.net</em><sup><a id="ch17fn_16" href="footnote.xhtml#ch17fn16">16</a></sup> download page for the MinGW project. Scroll down a bit (being careful to avoid the ridiculous large green-button advertisement links intended to look like legitimate download buttons). Under the gray bar labeled “Operating System: Windows,” click the small blue button with the embedded Windows 10–like logo. Save the <span class="literal">mingw-get-setup.exe</span> program to a location on your hard drive.</p>&#13;
<p class="indent">Running this program presents you with a very simple dialog-based installer for the MinGW Installation Manager Setup Tool, as shown in <a href="ch17.xhtml#ch17fig13">Figure 17-13</a>.</p>&#13;
<p class="image"><img src="../images/17fig13.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig13"><em>Figure 17-13: The initial dialog presented by the MinGW Installation Manager Setup Tool</em></p>&#13;
<p class="indent">This program actually installs the MinGW Installation Manager, a tool that, much like the Cygwin package manager, allows fine-grained control over the MinGW components that get installed or updated. Before the installation manager, the only option for updating MinGW was either to uninstall an existing full installation and then reinstall a new version from scratch, or try to upgrade, which was a hit-and-miss proposition at best.</p>&#13;
<p class="indent">In spite of the apparent out-of-date copyright range, the setup program and the installation manager itself were last refreshed (as of this writing) in September of 2017. The installation manager keeps a package catalog up-to-date, so you always have access to the very latest MinGW packages. For instance, a package containing GCC 8.2.0 was uploaded in August of 2018. By the time you read this, it will likely have been updated with an even newer version.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_480"/>Go ahead and click <strong>Install</strong>. You’re presented with an options page, shown in <a href="ch17.xhtml#ch17fig14">Figure 17-14</a>.</p>&#13;
<p class="image"><img src="../images/17fig14.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig14"><em>Figure 17-14: The options page presented by the MinGW Installation Manager Setup Tool</em></p>&#13;
<p class="indent">As with Cygwin, MinGW wants to be installed in a path off the root of the system drive, and also as with Cygwin, you need to consider MinGW a virtualized operating system. As such, it has need of a special place on your Windows filesystem.</p>&#13;
<p class="indent">Additionally, like Cygwin, you’ll find MinGW is not installed using the Windows installation database and, hence, does not show up in the Windows installed programs panel. You can, in fact, completely remove MinGW from your Windows system by merely deleting the <em>C:\MinGW</em> directory.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you do decide to install into a different location, you’ll need to carefully read the initial installation instructions on the MinGW website, because you’ll need to make additional changes to files in the</em> C:\MinGW\msys\1.0\etc <em>directory after installation.</em></p>&#13;
</div>&#13;
<p class="indent">Leave all options as they are and click <strong>Continue</strong>. The next screen you’ll see is the download progress page, showing you that the latest installation manager program is being downloaded into the <em>C:\MinGW\libexec\mingw-get</em> directory. <a href="ch17.xhtml#ch17fig15">Figure 17-15</a> shows the state of this dialog once the catalog has been updated from the download source and the latest version of the installation manager has been downloaded and installed.</p>&#13;
<span epub:type="pagebreak" id="page_481"/>&#13;
<p class="image"><img src="../images/17fig15.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig15"><em>Figure 17-15: The download progress page for the MinGW Installation Manager Setup Tool</em></p>&#13;
<p class="indent">Click <strong>Continue</strong> to open the installation manager, shown in <a href="ch17.xhtml#ch17fig16">Figure 17-16</a>.</p>&#13;
<p class="image"><img src="../images/17fig16.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig16"><em>Figure 17-16: The installation manager main screen with package context menu</em></p>&#13;
<p class="indent">The packages you see in the Basic Setup panel (shown by default) are actually meta-packages, or packages referring to large groups of actual packages. To see real packages, you can select the <strong>All Packages</strong> option on the left and then scroll through the list displayed on the right. When you’re ready to continue, return to the Basic Setup panel.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_482"/>Selecting the <em>mingw-developer-toolkit-bin</em> meta-package will also automatically select the <em>msys-base-bin</em> meta-package. These two, plus the <em>mingw32-base-bin</em> meta-package, are all you need to compile C programs into 32-bit native Windows programs. Select these three packages, as shown in <a href="ch17.xhtml#ch17fig16">Figure 17-16</a>, and then click the <strong>Apply Changes</strong> option from the <strong>Installation</strong> menu, as shown in <a href="ch17.xhtml#ch17fig17">Figure 17-17</a>.</p>&#13;
<p class="image"><img src="../images/17fig17.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig17"><em>Figure 17-17: Applying selected changes in the installation manager</em></p>&#13;
<p class="indent">You’re presented with a confirmation dialog titled “Schedule of Pending Actions,” which allows you to apply the scheduled changes, defer these changes in order to return to the main window and modify the current list, or simply discard all changes. Select <strong>Apply</strong>, as shown in <a href="ch17.xhtml#ch17fig18">Figure 17-18</a>.</p>&#13;
<p class="image"><img src="../images/17fig18.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig18"><em>Figure 17-18: The installation manager’s schedule of pending actions dialog</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_483"/>Finally, you’re presented with the Download Package dialog, shown in <a href="ch17.xhtml#ch17fig19">Figure 17-19</a>, in which each of the 112 packages you selected for download is displayed with a progress bar.</p>&#13;
<p class="image"><img src="../images/17fig19.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig19"><em>Figure 17-19: <em>The installation manager’s Download Package dialog</em></em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Since the MinGW download site will have undoubtedly been updated after this writing, you may see a different number of packages to be installed in the bottom pane of the dialog shown in <a href="ch17.xhtml#ch17fig18">Figure 17-18</a>.</em></p>&#13;
</div>&#13;
<p class="indent">This may take a while, depending on your internet connection, so go grab a snack.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you get any package download errors, just click <strong>OK</strong> to dismiss the error dialog, wait for the successful download and installation of the remaining packages to complete, and then click <strong>Apply Changes</strong> from the <strong>Installation</strong> menu again to retry downloading and installing the failed packages. Only the failed packages will be redownloaded.</em></p>&#13;
</div>&#13;
<p class="indent">Once all packages have been downloaded, they’ll be installed into a standard Unix-like directory structure within the <em>C:\MinGW\msys\1.0</em> directory. <a href="ch17.xhtml#ch17fig20">Figure 17-20</a> shows the installation manager’s Applying Scheduled Changes dialog, after it has installed each of the previously downloaded packages.</p>&#13;
<p class="image"><img src="../images/17fig20.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig20"><em>Figure 17-20: The installation manager’s Applying Scheduled Changes dialog</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_484"/>You may now close the installation manager program. There is one final step in preparing your installation of MinGW—creating a convenient desktop icon for the MinGW terminal, which is a somewhat outdated version of the Bash shell ported to Windows and running in a Windows Console Host (<span class="literal">conhost.exe</span>) process. MinGW installs a Windows batch file at <em>C:\MinGW\msys\1.0\msys.bat</em>. Execute this batch file to start the MinGW terminal that provides your POSIX build environment. I like to create a shortcut to this file on my desktop and change the icon for it to point to the <em>msys.ico</em> file found in the same directory.</p>&#13;
<p class="indent">Double-click the <span class="literal">msys.bat</span> file and start up the MinGW terminal. You’ll find <span class="literal">pwd</span> shows that you’re left in the <em>/home/</em><em><span class="literal">username</span></em> directory, where <em><span class="literal">username</span></em> is your Windows system user name.</p>&#13;
<p class="indent">As with Cygwin, the best way to understand the filesystem is to use <span class="literal">mount</span> to view the mount points in the MinGW filesystem:</p>&#13;
<pre>$ <span class="codestrong1">mount</span>&#13;
C:\Users\...\AppData\Local\Temp on /tmp type user (binmode,noumount)&#13;
C:\MinGW\msys\1.0 on /usr type user (binmode,noumount)&#13;
C:\MinGW\msys\1.0 on / type user (binmode,noumount)&#13;
C:\MinGW on /mingw type user (binmode)&#13;
c: on /c type user (binmode,noumount)&#13;
d: on /d type user (binmode,noumount)&#13;
z: on /z type user (binmode,noumount)&#13;
$</pre>&#13;
<p class="indent">This output looks similar to its Cygwin counterpart, but there are a few differences. First, MinGW mounts your Windows user temporary directory as <em>/tmp</em>. Second, both <em>/usr</em> and <em>/</em> represent the same Windows directory, <em>C:\MinGW\msys\1.0</em>. Finally, <em>C:\MinGW</em> itself is mounted under <em>/mingw</em>.</p>&#13;
<p class="indent">Windows drives are managed a bit differently also. Windows drive letters show up in the MinGW filesystem as they do in Cygwin, but they’re listed directly under the root, rather than as a separate top-level directory. Another subtle difference here is that my <em>D:</em> drive is listed. It’s a virtual optical drive, with no media mounted. MinGW chooses to show it even without media, while Cygwin only shows it with media.</p>&#13;
<p class="indent">If you <span class="literal">cat</span> the contents of the <em>/etc/fstab</em> file, you can see that most of the preceding is hardcoded. The only mount point that’s actually soft-configured is the <em>/mingw</em> path:<sup><a id="ch17fn_17" href="footnote.xhtml#ch17fn17">17</a></sup></p>&#13;
<pre>$ <span class="codestrong1">cat /etc/fstab</span>&#13;
# /etc/fstab -- mount table configuration for MSYS.&#13;
# Please refer to /etc/fstab.sample for explanatory annotation.&#13;
&#13;
# MSYS-Portable needs this "magic" comment:&#13;
# MSYSROOT=C:/MinGW/msys/1.0&#13;
<span epub:type="pagebreak" id="page_485"/># Win32_Path                              Mount_Point&#13;
#-------------------------------------    -----------&#13;
C:/MinGW                                  /mingw&#13;
$</pre>&#13;
<h4 class="h4" id="ch17sec7-2"><em>Testing the Build</em></h4>&#13;
<p class="noindent">We’re now ready to try building the b64 project. First, we should clean up the <em>b64</em> directory in order to demonstrate <span class="literal">bootstrap.sh</span> in this environment, so change into the <em>b64</em> directory from your MinGW terminal and use <span class="literal">git</span> to remove all artifacts. Then make a build directory structure for testing MinGW:</p>&#13;
<pre>$ <span class="codestrong1">cd /c/Users/.../Documents/dev/b64</span>&#13;
$ <span class="codestrong1">git clean -xfd</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
$ <span class="codestrong1">mkdir -p mgw-builds/mingw</span>&#13;
$</pre>&#13;
<p class="indent">At this point, rather than lead you down a sure path to failure, I’ll state up front that you’ll immediately run into problems with symbolic links. While Cygwin has no trouble properly creating and using symlinks in its environment, the same is not true of MinGW. If you attempt to create a symlink from <span class="literal">/usr/bin/gnulib-tool</span> to the <span class="literal">.../gnulib/gnulib-tool</span> program, you’ll find the <span class="literal">ln -s</span> command seems to work, but when you try to run <span class="literal">bootstrap.sh</span>, it fails to find Gnulib. A closer examination shows that the symlink you thought you created was actually just a copy. Well, a copy won’t work, because <span class="literal">gnulib-tool</span> uses its real location in the filesystem as the base of the Gnulib repository and a copy of <span class="literal">gnulib-tool</span> in another location cannot do this.</p>&#13;
<p class="indent">To fix this problem, we’ll have to adjust b64’s <span class="literal">bootstrap.sh</span> program to use a relative path to the actual <span class="literal">gnulib-tool</span>. I cloned gnulib right next to b64, so I merely have to change <span class="literal">bootstrap.sh</span> so that it refers to <span class="literal">../gnulib/gnulib-tool</span>, rather than relying on its being accessible from the system <span class="literal">PATH</span>. Use any editor to make changes similar to those highlighted in <a href="ch17.xhtml#ch17ex1">Listing 17-1</a> on your system.</p>&#13;
<pre><span class="ash">#!/bin/sh</span>&#13;
../gnulib/<span class="ash">gnulib-tool --update</span>&#13;
<span class="ash">autoreconf -i</span></pre>&#13;
<p class="caption" id="ch17ex1"><em>Listing 17-1:</em> b64/bootstrap.sh: <em>Changes required to allow MinGW to find Gnulib</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>After making these changes to <em><span class="literal">bootstrap.sh</span></em>, you should expect to see different output when you run <em><span class="literal">b64.exe</span></em> against it.</em></p>&#13;
</div>&#13;
<p class="indent">That will fix our Gnulib issues, but there’s another problem lurking here. While MinGW may have the very latest GCC tool chain, it doesn’t stay as current with the Autotools. We’ve been working with Autoconf 2.69 and Automake 1.15.1, but as of this writing, MinGW only provides Autoconf 2.68 <span epub:type="pagebreak" id="page_486"/>and Automake 1.11.1. Perhaps by the time you read this, these tools will have been updated, and you will not have to make the changes to <em>configure.ac</em> shown in <a href="ch17.xhtml#ch17ex2">Listing 17-2</a>. Check your Autoconf and Automake versions before making these changes.</p>&#13;
<pre><span class="ash">#                                               -*- Autoconf -*-</span>&#13;
<span class="ash"># Process this file with autoconf to produce a configure script.</span>&#13;
&#13;
AC_PREREQ([2.68])&#13;
<span class="ash">AC_INIT([b64], [1.0], [b64-bugs@example.com])</span>&#13;
<span class="ash">AM_INIT_AUTOMAKE([subdir-objects])</span>&#13;
<span class="ash">AC_CONFIG_SRCDIR([src/b64.c])</span>&#13;
<span class="ash">AC_CONFIG_HEADERS([config.h])</span>&#13;
AC_CONFIG_MACRO_DIR([m4])&#13;
&#13;
<span class="ash"># Checks for programs.</span>&#13;
<span class="ash">AC_PROG_CC</span>&#13;
AM_PROG_CC_C_O&#13;
<span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">AC_OUTPUT</span></pre>&#13;
<p class="caption" id="ch17ex2"><em>Listing 17-2:</em> b64/configure.ac: <em>Changes required to work with Autoconf 2.68</em></p>&#13;
<p class="indent">The highlighted lines show the changes that need to be made. First, we need to reduce the lowest supported version in <span class="literal">AC_PREREQ</span> to allow Autoconf 2.68 to process this <em>configure.ac</em> file. Then we need to change the Automake macro, <span class="literal">AC_CONFIG_MACRO_DIRS</span> (plural), to its Autoconf counterpart, <span class="literal">AC_CONFIG_MACRO_DIR</span>. It works the same, except that the one that comes with Automake 1.15.1 makes it possible for us to forego the use of <span class="literal">AC_LOCAL_AMFLAGS = -I m4</span> in our <em>Makefile.am</em> file. Luckily, I had already added that line into <em>Makefile.am</em> and just left it there, so this change is easy. Finally, Automake 1.15.1 consolidated the functionality of <span class="literal">AM_PROG_CC_C_O</span> into the <span class="literal">AM_INIT_AUTOMAKE</span> macro when the <span class="literal">subdir-objects</span> option is given. Moving back to Automake 1.11.1 requires us to change to the old format where we have to explicitly mention <span class="literal">AM_PROG_CC_C_O</span> and it must come after <span class="literal">AC_PROG_CC</span>.</p>&#13;
<p class="indent">After these changes, we can finally run <span class="literal">bootstrap.sh</span> to generate our <span class="literal">configure</span> script:</p>&#13;
<pre>$ <span class="codestrong1">./bootstrap.sh</span>&#13;
Module list with included dependencies (indented):&#13;
    absolute-header&#13;
  base64&#13;
<span class="codeitalic1">--snip--</span>&#13;
configure.ac:13: installing `./compile'&#13;
configure.ac:21: installing `./config.guess'&#13;
configure.ac:21: installing `./config.sub'&#13;
configure.ac:6: installing `./install-sh'&#13;
configure.ac:6: installing `./missing'&#13;
lib/Makefile.am: installing `./depcomp'&#13;
$</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_487"/>Now change into the <em>mgw-builds/mingw</em> directory created earlier and run <span class="literal">configure</span> with a relative path back to <em>b64</em>:</p>&#13;
<pre>$ <span class="codestrong1">cd mgw-builds/mingw</span>&#13;
$ <span class="codestrong1">../../configure</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
checking for C compiler default output file name... a.exe&#13;
checking for suffix of executables... .exe&#13;
checking whether we are cross compiling... no&#13;
<span class="codeitalic1">--</span><span class="codeitalic1">snip--</span>&#13;
checking build system type... i686-pc-mingw32&#13;
checking host system type... i686-pc-mingw32&#13;
<span class="codeitalic1">--snip--</span>&#13;
configure: creating ./config.status&#13;
config.status: creating Makefile&#13;
config.status: creating lib/Makefile&#13;
config.status: creating config.h&#13;
config.status: executing depfiles commands&#13;
&#13;
$ <span class="codestrong1">make</span>&#13;
<span class="codeitalic1">--snip--</span>&#13;
make[2]: Entering directory `/c/Users/.../mgw-builds/mingw'&#13;
gcc -DHAVE_CONFIG_H -I. -I../..  -I./lib -I../../lib   -g -O2 -MT src/src_b64-&#13;
b64.o -MD -MP -MF src/.deps/src_b64-b64.Tpo -c -o src/src_b64-b64.o `test -f&#13;
'src/b64.c' || echo '../../'`src/b64.c&#13;
mv -f src/.deps/src_b64-b64.Tpo src/.deps/src_b64-b64.Po&#13;
gcc  -g -O2   -o src/b64.exe src/src_b64-b64.o lib/libgnu.a&#13;
make[2]: Leaving directory `/c/Users/.../mgw-builds/mingw'&#13;
make[1]: Leaving directory `/c/Users/.../mgw-builds/mingw'&#13;
$</pre>&#13;
<p class="indent">Opening <span class="literal">b64.exe</span> in <span class="literal">DependenciesGUI.exe</span> shows us it’s a 32-bit Windows program that depends only on <span class="literal">SysWOW64\kernel32.dll</span> and <span class="literal">SysWOW64\MSVCRT.dll</span>.</p>&#13;
<h3 class="h3" id="ch17sec8">Msys2</h3>&#13;
<p class="noindent">Msys2 was developed by a company called OneVision Software in 2013 using “clean room” techniques in order to loosen up the open source licensing requirements imposed by Cygwin and to provide a more modern alternative to the old out-of-date Msys environments used by Cygwin and MinGW.</p>&#13;
<p class="indent">MSys2 uses a OneVision 64-bit port of the MinGW tool chain called <em>mingw-w64</em>. However, like Cygwin, Msys2 provides its own library of POSIX system-level functionality called <em>msys-2.0.dll</em>. Msys2 provides a C standard library implemented in terms of this library. You can detect if a Windows program was built for the Msys2 platform in the same manner as previously described for the Cygwin platform.</p>&#13;
<p class="indent">Because Msys2 is more or less a feature-for-feature replacement of Cygwin, and since so many people are already used to the way Cygwin works, Msys2 has had a difficult time gaining traction, though it is used by some key players, including Git for Windows. Msys2 is advertised as an <span epub:type="pagebreak" id="page_488"/>upgrade to Cygwin, but Msys2 merely provides different implementations of the same portability mechanisms used by Cygwin.</p>&#13;
<p class="indent">The one distinguishing characteristic that sets Msys2 apart from Cygwin is the fact that Msys2’s open source license is much more lenient than that of Cygwin. While Cygwin uses GPL-based licensing, Msys2 uses only a standard 3-clause BSD license, making it a viable option for building proprietary Windows software using Linux tools.</p>&#13;
<p class="indent">The most significant offering in OneVision’s system is the 64-bit port of the MinGW compiler—not that it runs on 64-bit platforms (which it does), but that it generates 64-bit Windows code. It’s safe to say that the world of cross-compiled Windows code was expanded dramatically when this compiler was released. It has since been ported to many different platforms.</p>&#13;
<p class="indent">Msys2 does tie into the Windows installation database, so you may uninstall Msys2 from the Windows installed-programs panel.</p>&#13;
<h4 class="h4" id="ch17sec8-1"><em>What’s Msys?</em></h4>&#13;
<p class="noindent">The term “Msys” has been misused for many purposes over the years. Some think it means “Unix on Windows” or, at the very least, the sense of such. All it really provides is potential. Msys, at its most basic, provides a Unix-compatible terminal program, a Bourne-like shell (usually Bash), and a base set of utilities. Some implementations have more and some have fewer utilities. Whatever implementation you’re using, be it Cygwin, MinGW, or Msys2, the Msys component of these packages is there for you to build upon by installing additional packages to build up the environment the way you like.</p>&#13;
<p class="indent">When OneVision created Msys2, the company’s vision was to start out small, allowing the user to build up the environment exactly the way they wanted. Msys2’s version of Msys has very few packages preinstalled, while Cygwin has many. Msys2 and Cygwin base their terminal window on <span class="literal">mintty.exe</span>,<sup><a id="ch17fn_18" href="footnote.xhtml#ch17fn18">18</a></sup> while MinGW bases its terminal on <span class="literal">conhost.exe</span> (Windows console host process), and you can tell this is so because the look and feel of the Cygwin and Msys2 terminals are very similar to each other, but significantly different from that of MinGW.</p>&#13;
<h4 class="h4" id="ch17sec8-2"><em>Installing Msys2</em></h4>&#13;
<p class="noindent">The installation procedure for Msys2 is pretty simple. Navigate in your web browser to the Msys2 home page at <em><a href="http://www.msys2.org">http://www.msys2.org</a></em> and click the button at the top of the page for either the 32-bit (<span class="literal">msys2-i686-</span><em><span class="literal">yyyymmdd</span></em><span class="literal">.exe</span>) or the 64-bit (<span class="literal">msys2-x86_64-</span><em><span class="literal">yyyymmdd</span></em><span class="literal">.exe</span>) version of the Msys2 installer.<sup><a id="ch17fn_19" href="footnote.xhtml#ch17fn19">19</a></sup> When the download completes, run the installer and you’re presented with a dialog-based installation wizard. The welcome page is shown in <a href="ch17.xhtml#ch17fig21">Figure 17-21</a>.</p>&#13;
<p class="image"><span epub:type="pagebreak" id="page_489"/><img src="../images/17fig21.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig21"><em>Figure 17-21: The welcome page of the Msys2 install utility</em></p>&#13;
<p class="indent">Click <strong>Next</strong> to move to the next page, shown in <a href="ch17.xhtml#ch17fig22">Figure 17-22</a>.</p>&#13;
<p class="image"><img src="../images/17fig22.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig22"><em>Figure 17-22: The installation folder page of the Msys2 install utility</em></p>&#13;
<p class="indent">Select an installation location. Like Cygwin and MinGW, Msys2 wants to be installed at the root of the system drive. I recommend sticking with the default location for the same reasons I gave for the other two systems. Click <strong>Next</strong> to move to the next page, shown in <a href="ch17.xhtml#ch17fig23">Figure 17-23</a>.</p>&#13;
<p class="image"><span epub:type="pagebreak" id="page_490"/><img src="../images/17fig23.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig23"><em>Figure 17-23: The shortcuts page of the Msys2 install utility</em></p>&#13;
<p class="indent">You can select the Windows Start Menu folder in which you’d like the installer to create its shortcuts. The default is sufficient. Click <strong>Next</strong> to move to the next page and begin installation, shown in <a href="ch17.xhtml#ch17fig24">Figure 17-24</a>.</p>&#13;
<p class="image"><img src="../images/17fig24.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig24"><em>Figure 17-24: The installation progress page (showing details) of the Msys2 install utility</em></p>&#13;
<p class="indent">When installation has completed, click <strong>Next</strong> to move to the final page, shown in <a href="ch17.xhtml#ch17fig25">Figure 17-25</a>.</p>&#13;
<p class="image"><span epub:type="pagebreak" id="page_491"/><img src="../images/17fig25.jpg" alt="Image"/></p>&#13;
<p class="caption" id="ch17fig25"><em>Figure 17-25: The final page of the Msys2 install utility</em></p>&#13;
<p class="indent">You’re given the option here of starting Msys2 upon completion. Click <strong>Finish</strong> to exit the installer. Allow the installer to execute Msys2 as it exits or go to the Windows 10 Start Menu, locate the <strong>MSYS2 64bit</strong> folder, and click the <strong>MSYS2 MSYS</strong> entry. Both options start the Msys2 terminal window in the same manner by executing the <span class="literal">C:\msys64\msys2_shell.cmd</span> script with a command line option of <span class="literal">-msys</span>.</p>&#13;
<p class="indent">Unlike the other systems’ installers, the Msys2 installer doesn’t download packages from the internet. Rather, much like a Linux distribution release, Msys2 installs a small base set of packages that get further out-of-date as time goes by until, eventually, a new installer is made available by the Msys2 maintainers. Therefore, the first thing you need to do is update these installed base packages.</p>&#13;
<p class="indent">Msys2 uses a Windows port of the Arch Linux package manager, Pacman, to provide access to repositories of packages ported to Msys2. The basic installation provides relatively few packages, and it needs to be updated with Pacman before additional packages can be installed.</p>&#13;
<p class="indent">With the terminal window open, we’ll update the Msys2 system using the command <span class="literal">pacman -Syu</span>. Pacman commands are uppercase, and options to those commands are lowercase. The <span class="literal">-S</span> command is the remote repository “sync” command. The <span class="literal">-u</span> option of this command updates existing packages from the remote repository. The <span class="literal">-y</span> option updates the catalog from the repository before checking for updates. To get help on the commands, run <span class="literal">pacman -h</span>. To get help on the available options for a command, add <span class="literal">-h</span> to the command line along with the command. For example, to get help on available options for the <span class="literal">-S</span> command, run <span class="literal">pacman -Sh</span>.</p>&#13;
<p class="indent">Go ahead and update the system now, downloading the latest catalog first:</p>&#13;
<pre>$ <span class="codestrong1">pacman -Syu</span>&#13;
:: Synchronizing package databases...&#13;
 mingw32                                           530.8 KiB     495K/s 00:01&#13;
 mingw32.sig                                       119.0   B     116K/s 00:00&#13;
<span epub:type="pagebreak" id="page_492"/>&#13;
 mingw64                                           532.0 KiB     489K/s 00:01&#13;
 mingw64.sig                                       119.0   B     116K/s 00:00&#13;
 msys                                              178.2 KiB     655K/s 00:00&#13;
 msys.sig                                          119.0   B    0.00B/s 00:00&#13;
:: Starting core system upgrade...&#13;
warning: terminate other MSYS2 programs before proceeding&#13;
resolving dependencies...&#13;
looking for conflicting packages...&#13;
&#13;
Packages (6) bash-4.4.023-1  filesystem-2018.12-1  mintty-1~2.9.5-1&#13;
             msys2-runtime-2.11.2-1  pacman-5.1.2-1  pacman-mirrors-20180604-2&#13;
&#13;
Total Download Size:   19.04 MiB&#13;
Total Installed Size:  68.24 MiB&#13;
Net Upgrade Size:      11.96 MiB&#13;
&#13;
:: Proceed with installation? [Y/n] <span class="codestrong1">Y</span></pre>&#13;
<p class="indent">Press y (or just enter to accept the default) at the prompt to continue updating the Msys2 system. You’ll note the small number of packages being updated. The base Msys2 system provides almost nothing. The core system comes with Bash, a Unix-like filesystem emulator that sits on top of the Windows filesystem, mintty, the Msys2 Msys runtime, and the Pacman package manager, so it’s not really a problem that the Msys2 installer installs out-of-date packages that need to be updated upon first use.</p>&#13;
<p class="indent">Pacman will download and install several packages, including Pacman:</p>&#13;
<pre>:: Retrieving packages...&#13;
 msys2-runtime-2.11.2-1-x86_64                        2.5 MiB  1012K/s 00:03&#13;
 bash-4.4.023-1-x86_64                             1931.4 KiB  1003K/s 00:02&#13;
 filesystem-2018.12-1-x86_64                         46.3 KiB   242K/s 00:00&#13;
 mintty-1~2.9.5-1-x86_64                            296.7 KiB  1648K/s 00:00&#13;
 pacman-mirrors-20180604-2-any                       17.1 KiB  2.09M/s 00:00&#13;
 pacman-5.1.2-1-x86_64                               14.3 MiB  1010K/s 00:14&#13;
(6/6) checking keys in keyring&#13;
(6/6) checking package integrity&#13;
(6/6) loading package files&#13;
(6/6) checking for file conflicts&#13;
(6/6) checking available disk space&#13;
warning: could not get file information for opt/&#13;
:: Processing package changes...&#13;
(1/6) upgrading msys2-runtime&#13;
(2/6) upgrading bash&#13;
(3/6) upgrading filesystem&#13;
(4/6) upgrading mintty&#13;
(5/6) upgrading pacman-mirrors&#13;
(6/6) upgrading pacman&#13;
warning: terminate MSYS2 without returning to shell and check for updates again&#13;
warning: for example close your terminal window instead of calling exit</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_493"/>When you reach this point, Pacman itself needs to be updated, but it cannot update itself while it’s running—an artifact of the way Windows manages running executable images. It displays a message indicating that you should close the terminal window by clicking the X in the upper-right corner and then restart Msys2 from the Windows Start Menu and continue the installation process.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you get a pop-up box warning you of running processes, just click <em><strong>OK</strong></em> to close the window anyway.</em></p>&#13;
</div>&#13;
<p class="indent">Run <span class="literal">pacman -Su</span> again (no need to update the catalog again) to continue the update process and press enter when prompted again. This time, many more packages are updated. Press y (or just enter) to continue and then wait for the update process to complete.</p>&#13;
<p class="indent">Before we continue installing additional packages, let’s take a look at the filesystem by running the <span class="literal">mount</span> command:</p>&#13;
<pre>$ <span class="codestrong1">mount</span>&#13;
C:/msys64 on / type ntfs (binary,noacl,auto)&#13;
C:/msys64/usr/bin on /bin type ntfs (binary,noacl,auto)&#13;
C: on /c type ntfs (binary,noacl,posix=0,user,noumount,auto)&#13;
Z: on /z type vboxsharedfolderfs (binary,noacl,posix=0,user,noumount,auto)&#13;
$</pre>&#13;
<p class="indent">You’ll notice that the Msys2 base installation directory, <em>C:\msys64</em>, is mounted at <em>/</em> and that <em>C:\msys64\usr\bin</em> is mounted at <em>/bin</em>. As with the other systems, Windows drives are mounted as their drive letter. Msys2 mounts them off the root like MinGW. (Cygwin can be configured to do the same.) Like Cygwin, Msys2 doesn’t mount optical drives without media, so you don’t see my <em>D:</em> drive mounted here as <em>/d</em>, but if I inserted a virtual disc and then executed <span class="literal">mount</span>, it would show up in the list.</p>&#13;
<h4 class="h4" id="ch17sec8-3"><em>Installing Tools</em></h4>&#13;
<p class="noindent">At this point, Msys2 is completely up-to-date and ready for you to add tools. But what tools should we add? I’d venture to guess this is the point where most uncommitted Msys2 explorers bail out. There is fairly complete documentation on the Msys2 wiki site, but you really need to read at least the introductory material in order to understand Msys2 the way you should.</p>&#13;
<p class="indent">While Cygwin and MinGW make it pretty obvious which path you should take at each turn, Msys2 simply offers options. You can build POSIX-only software for the Msys2 environment, or you can build native 32- or 64-bit Windows applications. Msys2 doesn’t attempt to persuade you to go one way or the other by preinstalling software for a particular goal.</p>&#13;
<p class="indent">Msys2 provides three different terminal window shortcuts, each configured (using different command line options) to build software for one of the three targets Msys2 supports: Msys2 native applications, 32-bit Windows <span epub:type="pagebreak" id="page_494"/>applications, or 64-bit Windows applications. This is not really any different from cross-compiling; it just targets a specific tool chain with a custom environment instead of using options on the <span class="literal">configure</span> command line.</p>&#13;
<p class="indentb">Obviously, our goal here is not to build Msys2 software. Rather, we want to build Windows software, and Msys2 fully supports this goal. To find out what needs to be installed to meet our goals, read the Msys2 wiki page titled “Creating Packages.”<sup><a id="ch17fn_20" href="footnote.xhtml#ch17fn20">20</a></sup> According to this page, the following are the important Pacman groups:</p>&#13;
<p class="noindent3"><strong>base-devel</strong>   Required by all targets</p>&#13;
<p class="noindent3"><strong>msys2-devel</strong>   For building Msys2 native POSIX packages</p>&#13;
<p class="noindent3"><strong>mingw-w64-i686-toolchain</strong>   For building native 32-bit Windows software</p>&#13;
<p class="noindent3"><strong>mingw-w64-x86_64-toolchain</strong>   For building native 64-bit Windows software</p>&#13;
<p class="indentt">For our purposes, the first and last of these packages will suffice. It’s not necessarily obvious, but you don’t get <span class="literal">gcc</span> and the <em>binutils</em> package unless you install the <em>msys2-devel</em> meta package. Like Cygwin, Msys2 sees its own platform, which generates applications that fully depend on <em>msys2.0.dll</em>, as owning the native Msys2 tool chain.</p>&#13;
<p class="indent">There is no GUI package installer in Msys2, so let’s begin by exploring a few Pacman commands. Like most package management systems, the packages available to Pacman are grouped into logical sets. The <span class="literal">-Sg</span> option shows you a list of package groups:</p>&#13;
<pre>$ <span class="codestrong1">pacman -Sg</span>&#13;
kf5&#13;
mingw-w64-i686-toolchain&#13;
mingw-w64-i686&#13;
mingw-w64-i686-gimp-plugins&#13;
kde-applications&#13;
kdebase&#13;
mingw-w64-i686-qt4&#13;
mingw-w64-i686-qt&#13;
mingw-w64-i686-qt5&#13;
<span class="codeitalic1">--snip--</span>&#13;
$</pre>&#13;
<p class="indent">To find out what packages are in a group, just add the group name to the end of the previous command line:</p>&#13;
<pre>$ <span class="codestrong1">pacman -Sg mingw-w64-i686-toolchain</span>&#13;
mingw-w64-i686-toolchain mingw-w64-i686-binutils&#13;
mingw-w64-i686-toolchain mingw-w64-i686-crt-git&#13;
mingw-w64-i686-toolchain mingw-w64-i686-gcc&#13;
mingw-w64-i686-toolchain mingw-w64-i686-gcc-ada&#13;
<span epub:type="pagebreak" id="page_495"/>mingw-w64-i686-toolchain mingw-w64-i686-gcc-fortran&#13;
mingw-w64-i686-toolchain mingw-w64-i686-gcc-libgfortran&#13;
mingw-w64-i686-toolchain mingw-w64-i686-gcc-libs&#13;
mingw-w64-i686-toolchain mingw-w64-i686-gcc-objc&#13;
mingw-w64-i686-toolchain mingw-w64-i686-gdb&#13;
<span class="codeitalic1">--</span><span class="codeitalic1">snip--</span>&#13;
$</pre>&#13;
<p class="indent">When you use <span class="literal">pacman -S</span> to install a package and give it a group name, it shows you a list of group members and asks which of these members to install. If you simply press enter, it installs all of them. The <span class="literal">--needed</span> option ensures that only packages that are not already installed are downloaded. Without it, you’ll download and install packages in your target groups that are already installed:</p>&#13;
<pre>$ <span class="codestrong1">pacman -S --needed base-devel mingw-w64-i686-toolchain \</span>&#13;
    <span class="codestrong1">mingw-w64-x86_64-toolchain</span>&#13;
:: There are 56 members in group base-devel:&#13;
:: Repository msys&#13;
   1) asciidoc  2) autoconf  3) autoconf2.13  4) autogen  ...&#13;
<span class="codeitalic1">--snip--</span>&#13;
Enter a selection (default=all):&#13;
warning: file-5.35-1 is up to date -- skipping&#13;
warning: flex-2.6.4-1 is up to date -- skipping&#13;
<span class="codeitalic1">--snip--</span>&#13;
:: There are 17 members in group mingw-w64-x86_64-toolchain:&#13;
:: Repository mingw64&#13;
   1) mingw-w64-x86_64-binutils  2) mingw-w64-x86_64-crt-git  ...&#13;
<span class="codeitalic1">--snip--</span>&#13;
Enter a selection (default=all):&#13;
<span class="codeitalic1">--</span><span class="codeitalic1">snip--</span>&#13;
Total Download Size:    185.24 MiB&#13;
Total Installed Size:  1071.62 MiB&#13;
&#13;
:: Proceed with installation? [Y/n] <span class="codestrong1">Y</span></pre>&#13;
<p class="indent">Press y to download and then install the packages you requested. This could take a while, so I guess it’s time for another snack.</p>&#13;
<h4 class="h4" id="ch17sec8-4"><em>Testing the Build</em></h4>&#13;
<p class="noindent">Once these packages have been installed, your Msys2 environment is ready to use. Let’s change into the <em>b64</em> directory again, clean up, and create another build directory for Msys2 build testing.</p>&#13;
<p class="indent">If you’ve been working through this chapter and just came out of testing MinGW, your <span class="literal">bootstrap.sh</span> and <em>configure.ac</em> files have probably been modified. These changes will work fine in this environment. However, if you do decide to revert, only revert the <em>configure.ac</em> changes. The <span class="literal">bootstrap.sh</span> file should remain as is with the relative-path reference to <span class="literal">gnulib-tool</span>. If you skipped the section on MinGW, you’ll need to modify <span class="literal">bootstrap.sh</span> by adding a relative path to the Gnulib repository work area to the execution <span epub:type="pagebreak" id="page_496"/>of <span class="literal">gnulib-tool</span>. Msys2 has the same problem as MinGW in that it creates copies of the target, rather than working symlinks, so creating a symlink in <em>/usr/bin</em> for <span class="literal">gnulib-tool</span> will not work here:<sup><a id="ch17fn_21" href="footnote.xhtml#ch17fn21">21</a></sup></p>&#13;
<pre>$ <span class="codestrong1">cd /c/Users/.../Documents/dev/b64</span>&#13;
$ <span class="codestrong1">git clean -xfd</span>&#13;
$ <span class="codestrong1">mkdir -p ms2-builds/mw32 ms2-builds/mw64</span>&#13;
$ <span class="codestrong1">./bootstrap.sh</span>&#13;
Module list with included dependencies (indented):&#13;
    absolute-header&#13;
  base64&#13;
<span class="codeitalic1">--snip--</span>&#13;
configure.ac:12: installing './compile'&#13;
configure.ac:21: installing './config.guess'&#13;
configure.ac:21: installing './config.sub'&#13;
configure.ac:6: installing './install-sh'&#13;
configure.ac:6: installing './missing'&#13;
Makefile.am: installing './depcomp'&#13;
$</pre>&#13;
<p class="indent">Before we can build b64, we need to change terminals. You may have noticed that Msys2 configured three shortcuts in the <strong>MSYS2 64bit</strong> folder it created in the Windows Start Menu. Up to this point, we’ve been using the <strong>MSYS2 MSYS</strong> shortcut to start an Msys2 terminal. This was fine as long as we were just installing packages or if we were going to target the Msys2 platform.</p>&#13;
<p class="indent">We’re building 64-bit native Windows software, so open a MinGW 64-bit terminal now. Then, from within that terminal window, change into the <em>b64/ms2-builds/mw64</em> directory and build b64:</p>&#13;
<pre>$ <span class="codestrong1">cd /c/Users/.../Documents/dev/b64/ms2-builds/mw64</span>&#13;
$ <span class="codestrong1">../../configure</span>&#13;
configure: loading site script /mingw64/etc/config.site&#13;
<span class="codeitalic1">--snip--</span>&#13;
checking for C compiler default output file name... a.exe&#13;
checking for suffix of executables... .exe&#13;
checking whether we are cross compiling... no&#13;
<span class="codeitalic1">--snip--</span>&#13;
checking build system type... x86_64-w64-mingw32&#13;
checking host system type... x86_64-w64-mingw32&#13;
<span class="codeitalic1a">--snip--</span>&#13;
<span class="ash">configure: creating ./config.status</span>&#13;
<span class="ash">config.status: creating Makefile</span>&#13;
<span class="ash">config.status: creating lib/Makefile</span>&#13;
<span class="ash">config.status: creating config.h</span>&#13;
<span epub:type="pagebreak" id="page_497"/><span class="ash">config.status: executing depfiles commands</span>&#13;
$&#13;
$ <span class="codestrong1">make</span>&#13;
make  all-recursive&#13;
make[1]: Entering directory '/c/Users/.../ms2-builds/mw64'&#13;
<span class="codeitalic1">--snip--</span>&#13;
make[2]: Entering directory '/c/Users/.../ms2-builds/mw64'&#13;
gcc -DHAVE_CONFIG_H -I. -I../../b64  -I./lib -I../../lib   -g -O2 -MT src/&#13;
b64-b64.o -MD -MP -MF src/.deps/b64-b64.Tpo -c -o src/b64-b64.o `test -f 'src/&#13;
b64.c' || echo '../../'`src/b64.c&#13;
mv -f src/.deps/b64-b64.Tpo src/.deps/b64-b64.Po&#13;
gcc  -g -O2   -o src/b64.exe src/b64-b64.o lib/libgnu.a&#13;
make[2]: Leaving directory '/c/Users/.../ms2-builds/mw64'&#13;
make[1]: Leaving directory '/c/Users/.../ms2-builds/mw64'&#13;
$</pre>&#13;
<p class="indent">The difference between these terminal windows is defined by the values of various environment variables starting with <span class="literal">MSYS</span>. These variables are used to configure the site configuration file referenced in the first line of <span class="literal">configure</span>’s output. See the Msys2 wiki for lots of details on how to configure environments this way.</p>&#13;
<p class="indent">Running the <span class="literal">b64.exe</span> program through <span class="literal">DependenciesGUI.exe</span>, we can see that it’s a true native 64-bit Windows program, dependent only on Windows system and Visual Studio runtime libraries.</p>&#13;
<h3 class="h3" id="ch17sec9">Summary</h3>&#13;
<p class="noindent">After the whirlwind tour we just took, you should now have no trouble building Windows software using GNU tools. Personally, I find the Cygwin and Msys2 environments to be the most useful for many purposes.</p>&#13;
<p class="indent">Msys2 is a bit more modern and fresh, but they both serve as good general-purpose platforms for the GNU tools. Msys2 also has the distinct advantage of building pure Windows software wherever possible, while Cygwin (unless using the mingw-w64 cross tools) builds apps that, although they do run on Windows, rely heavily on the Cygwin system library. That’s not necessarily a showstopper for me. If there are other factors and Cygwin comes out on top, then I don’t mind the extra library, but the purist in me leans toward a desire for no unnecessary third-party libraries.</p>&#13;
<p class="indent">Cygwin has the advantage of maturity. It’s not so far behind Msys2 that it’s unusable, but it’s been around long enough that it has some nice features, like integrating a working symbolic link mechanism into all of its utilities so it can properly emulate POSIX symlinks. It also has many more packages available for installation within the environment.</p>&#13;
<p class="indent">MinGW is a bit out-of-date, and it really needs to support 64-bit Windows builds, but it’s clean and small. With its new package manager, it stacks up pretty well against the other two. All it really needs to move into the big leagues is to embrace the newer 64-bit code generator in the <em>mingw-w64</em> package. It might also be nice to upgrade to mintty from the conhost-based console it uses.<span epub:type="pagebreak" id="page_498"/></p>&#13;
</body></html>