- en: '13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '13'
- en: TLS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: TLS
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: The *Transport Layer Security* (*TLS*) *protocol*, also known as *Secure Socket
    Layer* (*SSL*), which is the name of its predecessor, is the workhorse of internet
    security. TLS protects connections between servers and clients, whether that connection
    is between a website and its visitors, email servers, a mobile application and
    its servers, or video game servers and players. Without TLS, there would be no
    secure online commerce, secure online banking, or for that matter secure online
    anything.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*传输层安全性*（*TLS*）*协议*，也叫做*安全套接字层*（*SSL*），这是其前身的名称，是互联网安全的支柱。TLS保护服务器和客户端之间的连接，无论是网站与访客之间的连接、电子邮件服务器、移动应用与其服务器之间的连接，还是视频游戏服务器与玩家之间的连接。如果没有TLS，就不会有安全的在线商务、安全的在线银行，或者说安全的任何在线事务。'
- en: TLS is application agnostic; it doesn’t care about the type of content encrypted.
    This means that you can use it for web-based applications that rely on the HTTP
    protocol, as well as for any system where a client computer or device needs to
    initiate a connection with a remote server. For example, TLS is widely used for
    machine-to-machine communications in so-called internet of things (IoT) applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: TLS是与应用无关的；它不关心加密内容的类型。这意味着你可以将其用于依赖HTTP协议的基于Web的应用程序，也可以用于任何需要客户端计算机或设备与远程服务器建立连接的系统。例如，TLS广泛用于所谓的物联网（IoT）应用中的机器间通信。
- en: This chapter provides you with an abbreviated view of TLS. As you’ll see, TLS
    has become increasingly complex over the years. Unfortunately, complexity and
    bloat brought multiple vulnerabilities, and bugs found in its cluttered implementations
    have made headlines—think Heartbleed, BEAST, CRIME, and POODLE, all vulnerabilities
    that impacted millions of web servers.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为你提供了TLS的简要概览。如你所见，随着时间的推移，TLS变得越来越复杂。不幸的是，复杂性和臃肿带来了多个漏洞，且其杂乱的实现中发现的错误屡次登上头条——比如Heartbleed、BEAST、CRIME和POODLE，所有这些漏洞影响了数百万台Web服务器。
- en: In 2013, engineers tired of fixing new cryptographic vulnerabilities in TLS
    overhauled it and started working on TLS 1.3\. As you’ll learn in this chapter,
    TLS 1.3 ditched unnecessary features and insecure ones, and replaced old algorithms
    with state-of-the-art ciphers. The result is a simpler, faster, and more secure
    protocol.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年，工程师们厌倦了修复TLS中新出现的加密漏洞，于是对其进行了全面改革，并开始着手开发TLS 1.3。如你将在本章中了解到的那样，TLS 1.3摒弃了不必要和不安全的特性，并用先进的密码算法替代了旧的算法。结果是一个更简洁、更快速且更安全的协议。
- en: But before we explore how TLS 1.3 works, let’s review the problem that TLS aims
    to solve in the first place, and the reason for its very existence.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们探讨TLS 1.3如何工作之前，先让我们回顾一下TLS最初旨在解决的问题，以及它存在的理由。
- en: Target Applications and Requirements
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标应用和需求
- en: TLS is best known for being the *S* in HTTPS websites, and the padlock in a
    browser’s address bar indicating that a page is secure. The primary driver for
    creating TLS was to enable secure browsing in applications such as e-commerce
    or e-banking by encrypting website connections to protect credit card numbers,
    user credentials, and other sensitive information.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: TLS最著名的是作为HTTPS网站中的*S*，以及浏览器地址栏中显示的锁形图标，表示该页面是安全的。创建TLS的主要驱动力是通过加密网站连接来保护信用卡号码、用户凭证和其他敏感信息，从而在电子商务或电子银行等应用程序中实现安全浏览。
- en: TLS also helps to protect internet-based communication in general by establishing
    a *secure channel* between a client and a server that ensures the data transferred
    is confidential, authenticated, and unmodified.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: TLS还通过在客户端和服务器之间建立*安全通道*来帮助保护基于互联网的通信，确保传输的数据是机密的、经过身份验证的且未被篡改。
- en: One of TLS’s security goals is to prevent man-in-the-middle attacks, wherein
    an attacker intercepts encrypted traffic from the transmitting party, decrypts
    the traffic to capture the clear content, and re-encrypts it to send to the receiving
    party. TLS defeats man-in-the-middle attacks by authenticating servers (and optionally
    clients) using certificates and trusted certificate authorities, as we’ll discuss
    in more detail in the section [“Certificates and Certificate Authorities”](ch13.xhtml#lev2sec159)
    on page 238.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: TLS的一个安全目标是防止中间人攻击，其中攻击者拦截传输方的加密流量，解密流量以捕获明文内容，然后重新加密并发送给接收方。TLS通过使用证书和受信任的证书颁发机构来验证服务器（并可选择验证客户端），从而防止中间人攻击，我们将在第238页的[“证书和证书颁发机构”](ch13.xhtml#lev2sec159)部分中详细讨论。
- en: 'To ensure wide adoption, TLS needed to satisfy four more requirements: it needed
    to be efficient, interoperable, extensible, and versatile.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保广泛采用，TLS 需要满足另外四个要求：它需要高效、互操作、可扩展且多功能。
- en: For TLS, efficiency means minimizing the performance penalty compared with unencrypted
    connections. This is good for both the server (to reduce the cost of hardware
    for the service providers) and for clients (to avoid perceptible delays or the
    reduction of mobile devices’ battery life). The protocol needed to be interoperable
    so that it would work on any hardware and any operating system. It was to be extensible
    so that it could support additional features or algorithms. And it had to be versatile—that
    is, not bound to a specific application (this parallels something like Transport
    Control Protocol, which doesn’t care about the application protocol used on top
    of it).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 TLS，效率意味着尽量减少与未加密连接相比的性能损失。这对服务器（减少服务提供商硬件成本）和客户端（避免明显的延迟或移动设备电池寿命的减少）都有好处。该协议需要具有互操作性，以便能够在任何硬件和操作系统上工作。它还需要具有可扩展性，以支持额外的功能或算法。而且它必须是多功能的——也就是说，不绑定于特定的应用程序（这与传输控制协议类似，后者不关心其上方使用的应用协议）。
- en: The TLS Protocol Suite
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TLS 协议套件
- en: To protect client–server communications, TLS is made up of multiple versions
    of several protocols that together form the TLS protocol *suite*. And although
    *TLS* stands for *Transport Layer* *Security*, it’s actually not a transport protocol.
    TLS usually sits between the transport protocol TCP and an application layer protocol
    such as HTTP or SMTP, in order to secure data transmitted over a TCP connection.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护客户端与服务器之间的通信，TLS 由多个版本的多个协议组成，这些协议共同构成了 TLS 协议 *套件*。尽管 *TLS* 代表 *传输层安全性*，它实际上并不是一种传输协议。TLS
    通常位于传输协议 TCP 和应用层协议（如 HTTP 或 SMTP）之间，用于保护通过 TCP 连接传输的数据。
- en: TLS can also work over the *User Datagram Protocol (UDP)* transport protocol,
    which is used for “connectionless” transmissions such as voice or video traffic.
    However, unlike TCP, UDP doesn’t guarantee delivery or correct packet ordering.
    The UDP version of TLS is therefore slightly different and is called *DTLS* *(Datagram
    Transport Layer Security)*. For more on TCP and UDP, see Charles Kozierok’s *The
    TCP/IP Guide* (No Starch Press, 2005.)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 还可以通过 *用户数据报协议（UDP）* 传输协议工作，UDP 被用于“无连接”的传输，如语音或视频流量。然而，与 TCP 不同，UDP 不保证数据的传输或正确的包排序。因此，UDP
    版本的 TLS 略有不同，称为 *DTLS*（*数据报传输层安全协议*）。关于 TCP 和 UDP 的更多内容，请参阅 Charles Kozierok 的
    *The TCP/IP Guide*（No Starch Press，2005 年）。
- en: '*The TLS and SSL Family of Protocols: A Brief History*'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*TLS 和 SSL 协议族：简史*'
- en: TLS began life in 1995 when Netscape, developer of the Netscape browser, developed
    TLS’s ancestor, the Secure Socket Layer (SSL) protocol. SSL was far from perfect,
    and both SSL 2.0 and SSL 3.0 had security flaws. The upshot is that you should
    never use SSL, you should always use TLS—what adds to the confusion is that TLS
    is often referred to as “SSL,” even by security experts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 的诞生可追溯到 1995 年，当时 Netscape 浏览器的开发商 Netscape 开发了 TLS 的前身——安全套接字层（SSL）协议。SSL
    远非完美，SSL 2.0 和 SSL 3.0 都存在安全漏洞。最终的结论是，你绝对不应该使用 SSL，应该始终使用 TLS——但令人困惑的是，TLS 经常被称为“SSL”，即使是安全专家也是如此。
- en: Moreover, not all versions of TLS are secure. TLS 1.0 (1999) is the least secure
    TLS version, though it’s still more secure than SSL 3.0\. TLS 1.1 (2006) is better
    but includes a number of algorithms known today to be weak. TLS 1.2 (2008) is
    better yet, but it’s complex and only gets you high security if configured correctly
    (which is no simple matter). Also, its complexity increases the risk of bugs in
    implementations and the risk of incorrect configurations. For example, TLS 1.2
    supports AES in CBC mode, which is often vulnerable to padding oracle attacks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，并非所有版本的 TLS 都是安全的。TLS 1.0（1999 年）是最不安全的版本，尽管它仍然比 SSL 3.0 更安全。TLS 1.1（2006
    年）稍好一些，但包含一些如今已知较弱的算法。TLS 1.2（2008 年）则更好，但它比较复杂，只有在正确配置的情况下才能实现高安全性（这并非易事）。此外，它的复杂性增加了实现中的错误风险和配置错误的风险。例如，TLS
    1.2 支持 AES CBC 模式，这通常容易受到填充 Oracle 攻击的威胁。
- en: TLS 1.2 inherited dozens of features and design choices from earlier versions
    of TLS that make it suboptimal, both in terms of security and performance. To
    clean up this mess, cryptography engineers reinvented TLS—keeping only the good
    parts and adding security features. The result is TLS 1.3, an overhaul that has
    simplified a bloated design and made it more secure, more efficient, and simpler.
    Essentially, TLS 1.3 is mature TLS.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.2 从早期版本的 TLS 继承了数十项特性和设计选择，这使得它在安全性和性能方面都存在一些不足。为了解决这一问题，密码学工程师重新设计了 TLS——保留了好的部分，并添加了安全功能。最终的结果是
    TLS 1.3，这是一项彻底的改革，简化了臃肿的设计，并使其更加安全、高效和简洁。本质上，TLS 1.3 是成熟版的 TLS。
- en: '*TLS in a Nutshell*'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*TLS 简要概述*'
- en: 'TLS has two main protocols: one determines how to transmit data, and the other
    what data to transmit. The *record protocol* defines a packet format to encapsulate
    data from higher-level protocols and sends this data to another party. It’s a
    simple protocol that people often forget is part of TLS.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 有两种主要协议：一种确定如何传输数据，另一种确定传输哪些数据。*记录协议*定义了一个数据包格式，用于封装来自更高层协议的数据并将其发送给另一方。这是一个简单的协议，人们常常忘记它是
    TLS 的一部分。
- en: The *handshake protocol*—or just *handshake*—is TLS’s key agreement protocol.
    It’s often mistaken for “the” TLS protocol but the record protocol and the handshake
    can’t be separated.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*握手协议*——或者简称 *握手*——是 TLS 的密钥协商协议。它常常被误认为是“整个”TLS 协议，但记录协议和握手协议是无法分开的。'
- en: The handshake is started by a client to initiate a secure connection with a
    server. The client sends an initial message called ClientHello with parameters
    that include the cipher it wants to use. The server checks this message and its
    parameters and then responds with a message called ServerHello. Once both the
    client and the server have processed each other’s messages, they’re ready to exchange
    encrypted data using session keys established through the handshake protocol,
    as you’ll see in the section [“The TLS Handshake Protocol”](ch13.xhtml#lev2sec161)
    on page 241.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 握手由客户端发起，用以与服务器建立安全连接。客户端发送一条初始消息，称为 ClientHello，其中包含它希望使用的加密算法参数。服务器检查此消息及其参数后，回应一条消息，称为
    ServerHello。一旦客户端和服务器处理完对方的消息，它们就准备好通过握手协议建立的会话密钥来交换加密数据，如你将在[“TLS 握手协议”](ch13.xhtml#lev2sec161)第
    241 页中看到的那样。
- en: '*Certificates and Certificate Authorities*'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*证书与证书颁发机构*'
- en: The most critical step in the TLS handshake, and the crux of TLS’s security,
    is the *certificate validation step*, wherein a server uses a *certificate* to
    authenticate itself to a client.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 握手中最关键的步骤，也是 TLS 安全性的核心，是*证书验证步骤*，其中服务器使用*证书*来向客户端验证其身份。
- en: A certificate is essentially a public key accompanied by a signature of that
    key and associated information (including the domain name). For example, when
    connecting to *[https://www.google.com/](https://www.google.com/)*, your browser
    will receive a certificate from some network host and will then verify the certificate’s
    signature, which reads something like “I am *[google.com](http://google.com)*
    and my public key is [*key*].” If the signature is verified, the certificate (and
    its public key) are said to be *trusted*, and the browser can proceed with establishing
    the connection. (See [Chapters 10](ch10.xhtml#ch10) and [12](ch12.xhtml#ch12)
    for details about signatures.)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 证书本质上是一个公钥，并附带该公钥的签名和相关信息（包括域名）。例如，当连接到 *[https://www.google.com/](https://www.google.com/)*
    时，浏览器会从某个网络主机接收到证书，并随后验证该证书的签名，签名内容可能类似于“我就是 *[google.com](http://google.com)*，我的公钥是[*key*]”。如果签名被验证通过，则该证书（及其公钥）被认为是*可信任的*，浏览器可以继续建立连接。（关于签名的详细信息，请参见[第
    10 章](ch10.xhtml#ch10)和[第 12 章](ch12.xhtml#ch12)）
- en: How does the browser know the public key needed to verify the signature? That’s
    where the concept of *certificate authority* (*CA*) comes in. A CA is essentially
    a public key hard coded in your browser or operating system. The public key’s
    private key (that is, its signing capability) belongs to a trusted organization
    that ensures the public keys in certificates that it issues belong to the website
    or entity that claims them. That is, a CA acts as a *trusted third party*. Without
    CAs, there would be no way to verify that the public key served by *[google.com](http://google.com)*
    belongs to Google and not to an eavesdropper performing a man-in-the-middle attack.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器如何知道验证签名所需的公钥？这就是*证书颁发机构*（*CA*）概念的作用。CA 本质上是硬编码在你的浏览器或操作系统中的公钥。该公钥的私钥（即其签名能力）属于一个受信任的组织，该组织确保其颁发的证书中的公钥属于声明拥有该公钥的网站或实体。也就是说，CA
    充当*受信任的第三方*。没有 CA，就无法验证由 *[google.com](http://google.com)* 提供的公钥是否属于 Google，而不是属于正在进行中间人攻击的窃听者。
- en: 'For example, the command shown in [Listing 13-1](ch13.xhtml#ch13list1) shows
    what happens when we use the OpenSSL command-line tool to initiate a TLS connection
    to *[www.google.com](http://www.google.com)* on port 443, the network port used
    for TLS-based HTTP connections (that is, HTTPS.):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[清单 13-1](ch13.xhtml#ch13list1)中显示的命令展示了当我们使用 OpenSSL 命令行工具在端口 443（TLS 基于
    HTTP 连接的网络端口，即 HTTPS）上启动与*[www.google.com](http://www.google.com)*的 TLS 连接时发生的情况：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 13-1: Establishing a TLS connection with* [www.google.com](http://www.google.com)
    *and receiving certificates to authenticate the connection*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-1：与* [www.google.com](http://www.google.com) *建立 TLS 连接并接收证书以验证连接*'
- en: I’ve trimmed the output to show only the interesting part, which is the certificate.
    Notice that before the first certificate (which starts with the `BEGIN CERTIFICATE`
    tag) is a description of the *certificate chain*, where the line starting with
    `s:` describes the subject name and the line starting with `i:` describes the
    issuer of the signature. Here, certificate `0` is the one received by *[google.com](http://google.com)*
    ❶, certificate `1` ❷ belongs to the entity that signed certificate `0`, and certificate
    `2` ❸ belongs to the entity that signed certificate `1`. The organization that
    issued certificate `2` (GeoTrust) granted permission to Google Internet Authority
    to issue a certificate (certificate `1`) for the domain name *[www.google.com](http://www.google.com)*,
    thereby transferring trust to Google Internet Authority.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我已将输出结果裁剪，只显示有趣的部分，即证书。请注意，在第一个证书（以 `BEGIN CERTIFICATE` 标签开头）之前，是*证书链*的描述，其中以
    `s:` 开头的行描述了主题名称，以 `i:` 开头的行描述了签名的颁发者。在这里，证书 `0` 是从*[google.com](http://google.com)*接收到的
    ❶，证书 `1` ❷属于签署证书 `0` 的实体，证书 `2` ❸属于签署证书 `1` 的实体。颁发证书 `2`（GeoTrust）的组织授权 Google
    Internet Authority 为域名 *[www.google.com](http://www.google.com)* 颁发证书（证书 `1`），从而将信任转移给了
    Google Internet Authority。
- en: Obviously, these CA organizations must be trustworthy and only issue certificates
    to trustworthy entities, and they must protect their private keys in order to
    prevent an attacker from issuing certificates on their behalf (for example, in
    order to impersonate a legitimate *[google.com](http://google.com)* server).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些 CA 组织必须是可信的，并且只能向可信的实体颁发证书，它们还必须保护其私钥，以防止攻击者代表它们颁发证书（例如，冒充合法的 *[google.com](http://google.com)*
    服务器）。
- en: To see what’s in a certificate, we enter the command shown in [Listing 13-2](ch13.xhtml#ch13list2)
    into a Linux terminal and then paste the first certificate shown in [Listing 13-1](ch13.xhtml#ch13list1).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看证书的内容，我们在 Linux 终端中输入[清单 13-2](ch13.xhtml#ch13list2)中显示的命令，然后粘贴在[清单 13-1](ch13.xhtml#ch13list1)中显示的第一个证书。
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 13-2: Decoding a certificate received from* [www.google.com](http://www.google.com)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-2：解码从* [www.google.com](http://www.google.com) *接收到的证书*'
- en: What you see in [Listing 13-2](ch13.xhtml#ch13list2) is the command `openssl
    x509` decoding a certificate, originally provided as a block of base64-encoded
    data. Because OpenSSL knows how this block of data is structured, it can tell
    us what’s inside the certificate, including a serial number and version information,
    identifying information, validity dates (the `Not Before` and `Not After` lines),
    a public key (here as an RSA modulus and its public exponent), and a signature
    of the preceding information.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 [Listing 13-2](ch13.xhtml#ch13list2) 中看到的是命令 `openssl x509` 解码一个证书，该证书最初是作为一块
    base64 编码的数据提供的。由于 OpenSSL 知道这块数据的结构，它可以告诉我们证书内部的内容，包括序列号和版本信息、标识信息、有效期（`Not Before`
    和 `Not After` 行）、公钥（这里是一个 RSA 模数及其公钥指数）以及前述信息的签名。
- en: Although security experts and cryptographers often claim the whole certificate
    system is broken by design, it’s one of the best solutions we have, along with
    the trust-on-first-use (TOFU) policy adopted by SSH, for example.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管安全专家和密码学家常常声称整个证书系统在设计上存在漏洞，但它仍然是我们拥有的最佳解决方案之一，例如，SSH 采用的首次使用信任（TOFU）策略就是一个例子。
- en: '*The Record Protocol*'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*记录协议（Record Protocol）*'
- en: All data exchanged through TLS 1.3 communications is transmitted as sequences
    of *TLS records*, the data packets used by TLS. The TLS record protocol (the *record
    layer*) is essentially a transport protocol, agnostic of the transported data’s
    meaning; this is what makes TLS suitable for any application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有通过 TLS 1.3 通信交换的数据都是作为 *TLS 记录* 传输的，TLS 使用的数据包。TLS 记录协议（*记录层*）本质上是一种传输协议，与传输数据的含义无关；这使得
    TLS 适用于任何应用。
- en: The TLS record protocol is first used to carry the data exchanged during the
    handshake. Once the handshake is complete and both parties share a secret key,
    application data is fragmented into chunks that are transmitted as part of the
    TLS records.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 记录协议首先用于承载握手过程中交换的数据。一旦握手完成，双方共享一个秘密密钥，应用数据会被分割成多个块，作为 TLS 记录的一部分进行传输。
- en: Structure of a TLS Record
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: TLS 记录的结构
- en: 'A TLS record is a chunk of data of at most 16 kilobytes, structured as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 TLS 记录是最多 16 千字节的数据块，其结构如下：
- en: The first byte represents the type of data transmitted and is set to the value
    22 for handshake data, 23 for encrypted data, and 21 for alerts. In the TLS 1.3
    specifications, this value is called ContentType.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个字节表示传输数据的类型，设置为 22 表示握手数据，23 表示加密数据，21 表示警报。在 TLS 1.3 规范中，这个值被称为 ContentType。
- en: The second and third byte are set to 3 and 1, respectively. These bytes are
    fixed for historical reasons and are not unique to TLS version 1.3\. In the specifications,
    this 2-byte value is called ProtocolVersion.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个和第三个字节分别被设置为 3 和 1。这些字节由于历史原因是固定的，并且不特定于 TLS 1.3 版本。在规范中，这个 2 字节的值被称为 ProtocolVersion。
- en: The fourth and fifth bytes encode the length of the data to transmit as a 16-bit
    integer, which can be no larger than 2^(14) bytes (16KB).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个和第五个字节编码了传输数据的长度，表示为一个 16 位整数，最大为 2^(14) 字节（16KB）。
- en: The rest of the bytes are the data to transmit (also called the *payload*),
    of a length equal to the value encoded by the record’s fourth and fifth bytes.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩下的字节是要传输的数据（也称为 *负载*），其长度等于记录的第四和第五个字节编码的值。
- en: '**NOTE**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*A TLS record has a relatively simple structure. As we’ve seen, a TLS record’s
    header includes only three fields. For comparison, an IPv4 packet includes 14
    fields before its payload and a TCP segment includes 13 fields.*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*TLS 记录有一个相对简单的结构。正如我们所见，TLS 记录的头部仅包含三个字段。作为对比，IPv4 包在其负载之前包含 14 个字段，TCP 段则包含
    13 个字段。*'
- en: 'When the first byte of a TLS 1.3 record (ContentType) is set to 23, its payload
    is encrypted and authenticated using an authenticated cipher. The payload consists
    of a ciphertext followed by an authentication tag, which the receiving end will
    decrypt. But then how does the recipient know which cipher and key to decrypt
    with? That’s the magic of TLS: if you receive an encrypted TLS record, you already
    know the cipher and key, because they are established when the TLS handshake protocol
    is executed.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当 TLS 1.3 记录的第一个字节（ContentType）被设置为 23 时，它的负载会使用经过认证的密码算法进行加密和认证。负载由密文和一个认证标签组成，接收方会解密该负载。那么，接收方如何知道使用哪个密码和密钥来解密呢？这就是
    TLS 的魔力：如果你收到一个加密的 TLS 记录，你已经知道使用哪个密码和密钥，因为它们在 TLS 握手协议执行时已经建立。
- en: Nonces
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 随机数（Nonces）
- en: Unlike many other protocols such as IPsec’s Encapsulating Security Payload (ESP),
    TLS records don’t specify the nonce to be used by the authenticated cipher.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他协议（例如 IPsec 的封装安全有效载荷（ESP））不同，TLS 记录并没有指定经过身份验证的密码算法所使用的随机数。
- en: The nonces used to encrypt and decrypt TLS records are derived from 64-bit sequence
    numbers, maintained locally by each party, and incremented for each new record.
    When the client encrypts data, it derives a nonce by XORing the sequence number
    with a value called `client_write_iv`, itself derived from the shared secret.
    The server uses a similar method but with a different value, called `server_write_iv`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 用于加密和解密 TLS 记录的随机数是从 64 位序列号派生的，这些序列号由每一方本地维护，并且在每个新记录中递增。当客户端加密数据时，它通过将序列号与一个名为`client_write_iv`的值进行异或运算来派生随机数，这个值本身是从共享密钥中派生的。服务器使用类似的方法，但使用不同的值，称为`server_write_iv`。
- en: For example, if you transmit three TLS records, you’ll derive a nonce from 0
    for the first record, from 1 for the second, and from 2 for the third; if you
    then receive three records, you’ll also use nonces 0, 1, and 2, in this order.
    Reuse of the same sequence numbers values for encrypting trans­mitted data and
    decrypting receiving data isn’t a weakness because they are XORed with different
    constants (`client_write_iv` and `server_write_iv`) and because you use different
    secret keys for each direction.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你传输三个 TLS 记录，你将从第一个记录派生一个从 0 开始的随机数，从第二个记录派生一个从 1 开始的随机数，从第三个记录派生一个从 2
    开始的随机数；如果你接收三个记录，你也将按此顺序使用随机数 0、1 和 2。对于加密传输数据和解密接收数据使用相同序列号值并不构成弱点，因为它们与不同的常量（`client_write_iv`
    和 `server_write_iv`）进行异或运算，并且每个方向使用不同的密钥。
- en: Zero Padding
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 零填充
- en: TLS 1.3 records support a nice feature known as *zero padding* that mitigates
    traffic analysis attacks. *Traffic analysis* is a method that attackers use to
    extract information from traffic patterns using timing, volume of data transferred,
    and so on. For example, because ciphertexts are approximately the same size as
    plaintexts, even when strong encryption is used, attackers can determine the approximate
    size of your messages simply by looking at the length of their ciphertext.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.3 记录支持一个很好的功能，叫做*零填充*，它能够缓解流量分析攻击。*流量分析*是一种攻击者通过分析流量模式（例如时序、传输的数据量等）来提取信息的方法。例如，因为密文的大小大致与明文相同，即使使用强加密，攻击者也能仅通过查看密文的长度来大致判断消息的大小。
- en: Zero padding adds zeros to the plaintext in order to inflate the ciphertext’s
    size, and thus to fool observers into thinking that an encrypted message is longer
    than it really is.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 零填充会向明文添加零，以增加密文的大小，从而欺骗观察者认为加密后的消息比实际的要长。
- en: '*The TLS Handshake Protocol*'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*TLS 握手协议*'
- en: The *handshake* is the key TLS agreement protocol—the process by which a client
    and server establish shared secret keys in order to initiate secure communications.
    During the course of a TLS handshake, the client and server play different roles.
    The client proposes some configurations (the TLS version and a suite of ciphers,
    in order of preference) and the server chooses the configuration to be used. The
    server should follow the client’s preferences, but it may do otherwise. In order
    to ensure interoperability between implementations and to guarantee that any server
    implementing TLS 1.3 will be able to read TLS 1.3 data sent by any client implementing
    TLS 1.3 (even if it’s using a different library or programming language), the
    TLS 1.3 specifications also describe the format in which data should be sent.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*握手*是 TLS 协议的关键协商协议——客户端和服务器通过该过程建立共享的密钥，以便启动安全通信。在 TLS 握手过程中，客户端和服务器扮演不同的角色。客户端提出一些配置（TLS
    版本和密码套件，按优先顺序排列），服务器选择要使用的配置。服务器应该遵循客户端的偏好，但也可以选择不同的配置。为了确保不同实现之间的互操作性，并保证任何实现
    TLS 1.3 的服务器都能读取任何实现 TLS 1.3 的客户端发送的数据（即使它使用的是不同的库或编程语言），TLS 1.3 规范还描述了数据应如何发送的格式。'
- en: '[Figure 13-1](ch13.xhtml#ch13fig1) shows how data is exchanged in the handshake
    process, as described in the TLS 1.3 specifications. As you can see, in the TLS
    1.3 handshake, the client sends a message to the server saying, “I want to establish
    a TLS connection with you. Here are the ciphers that I support to encrypt TLS
    records, and here is a Diffie–Hellman public key.” The public key must be generated
    specifically for this TLS session, and the client keeps the associated private
    key. The message sent by the client also includes a 32-byte random value and optional
    information (additional parameters and such). This first message is called *ClientHello*,
    and it must follow a specific format when transmitted as a series of bytes, as
    defined in the TLS 1.3 specification.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13-1](ch13.xhtml#ch13fig1)展示了在 TLS 1.3 规范中描述的握手过程中文件交换的方式。如你所见，在 TLS 1.3
    握手中，客户端向服务器发送一条消息，内容为：“我想与你建立一个 TLS 连接。这里是我支持的加密 TLS 记录的密码套件，还有一个 Diffie–Hellman
    公钥。”该公钥必须专门为此次 TLS 会话生成，且客户端保留相关的私钥。客户端发送的消息还包括一个32字节的随机值和可选信息（如附加参数等）。这条消息称为*ClientHello*，并且在以字节序列传输时必须遵循
    TLS 1.3 规范中定义的特定格式。'
- en: '![image](../images/f13-01.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f13-01.jpg)'
- en: '*Figure 13-1: The TLS 1.3 handshake process when connecting to HTTPS websites*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-1：连接到 HTTPS 网站时的 TLS 1.3 握手过程*'
- en: But note that the specifications also describe in what format data should be
    sent, in order to ensure interoperability between implementations by guaranteeing
    that any server implementing TLS 1.3 will be able to read TLS 1.3 data sent by
    any client implementing TLS 1.3, possibly using a different library or programming
    language.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，规范还描述了数据应以何种格式发送，以确保各个实现之间的互操作性，从而保证任何实现 TLS 1.3 的服务器都能够读取任何实现 TLS 1.3
    的客户端发送的 TLS 1.3 数据，即使客户端可能使用不同的库或编程语言。
- en: 'The server receives the ClientHello message, verifies that it’s correctly formatted,
    and responds with a message called *ServerHello*. The ServerHello message is loaded
    with information: it contains the cipher to be used to encrypt TLS records, a
    Diffie–Hellman public key, a 32-byte random value (discussed in [“Downgrade Protection”](ch13.xhtml#lev2sec163)
    on page 244), a certificate, a signature of all the previous information in ClientHello
    and ServerHello messages (computed using the private key associated with the certificate’s
    public key), a MAC of that same information plus the signature. The MAC is computed
    using a symmetric key derived from the Diffie–Hellman shared secret, which the
    server computes from its Diffie–Hellman private key and the client’s public key.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器接收到 ClientHello 消息后，验证消息格式是否正确，并以一条名为 *ServerHello* 的消息作出响应。ServerHello 消息包含大量信息：它包含将用于加密
    TLS 记录的密码套件，一个 Diffie–Hellman 公钥，一个32字节的随机值（详见[“降级保护”](ch13.xhtml#lev2sec163)第244页），一个证书，一个对
    ClientHello 和 ServerHello 消息中所有先前信息的签名（使用与证书公钥相关联的私钥计算），以及该信息和签名的 MAC。MAC 是使用从
    Diffie–Hellman 共享密钥派生的对称密钥计算的，该密钥由服务器从其 Diffie–Hellman 私钥和客户端的公钥计算得出。
- en: When the client receives the ServerHello message, it verifies the certificate’s
    validity, verifies the signature, computes the shared Diffie–Hellman secret and
    derives symmetric keys from it, and verifies the MAC sent by the server. Once
    everything has been verified, the client is ready to send encrypted messages to
    the server.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端接收到 ServerHello 消息时，它会验证证书的有效性，验证签名，计算共享的 Diffie–Hellman 密钥并从中派生出对称密钥，同时验证服务器发送的
    MAC。一旦所有内容都被验证，客户端就准备好向服务器发送加密消息。
- en: Note, however, that TLS 1.3 supports many options and extensions, so it may
    behave differently than what has been described here (and shown in [Figure 13-1](ch13.xhtml#ch13fig1)).
    You can, for example, configure the TLS 1.3 handshake to require a client certificate
    so that the server verifies the identity of the client. TLS 1.3 also supports
    a handshake with pre-shared keys.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，TLS 1.3 支持许多选项和扩展，因此它的行为可能与这里描述的不同（并且与[图13-1](ch13.xhtml#ch13fig1)所示的不同）。例如，你可以配置
    TLS 1.3 握手以要求客户端证书，从而使服务器验证客户端的身份。TLS 1.3 还支持使用预共享密钥的握手。
- en: '**NOTE**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*TLS 1.3 supports many options and extensions, so it may behave differently
    than what has been described here (and shown in [Figure 13-1](ch13.xhtml#ch13fig1)).
    You can, for example, configure the TLS 1.3 handshake to require a client certificate
    so that the server verifies the identity of the client. TLS 1.3 also supports
    a handshake with pre-shared keys.*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*TLS 1.3 支持许多选项和扩展，因此它的行为可能与这里描述的有所不同（并且在 [图 13-1](ch13.xhtml#ch13fig1) 中有所展示）。例如，你可以配置
    TLS 1.3 握手要求客户端证书，以便服务器验证客户端的身份。TLS 1.3 还支持使用预共享密钥的握手。*'
- en: Let’s look at this in practice. Say you’ve deployed TLS 1.3 to provide secure
    access to the website *[https://www.nostarch.com/](https://www.nostarch.com/)*.
    When you point your browser (the client) to this site, your browser sends a ClientHello
    message to the site’s server that includes the ciphers that it supports. The website
    responds with a ServerHello message and a certificate that includes a public key
    associated with the domain *[www.nostarch.com](http://www.nostarch.com)*. The
    client verifies the certificate’s validity using one of the certificate authorities
    embedded in the browser (the received certificate should be signed by a trusted
    certificate authority, whose certificate should be included in the browser’s certificate
    store in order to be validated). Once all checks are passed, the browser requests
    the site’s initial page from the *[www.nostarch.com](http://www.nostarch.com)*
    server.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下实际应用。假设你已经部署了 TLS 1.3 来提供对网站 *[https://www.nostarch.com/](https://www.nostarch.com/)*
    的安全访问。当你将浏览器（客户端）指向这个网站时，浏览器向网站的服务器发送一个包含支持的密码套件的 ClientHello 消息。网站则用一个 ServerHello
    消息和一个包含与域名 *[www.nostarch.com](http://www.nostarch.com)* 相关的公钥的证书作出回应。客户端使用浏览器中嵌入的证书颁发机构之一验证该证书的有效性（收到的证书应该由一个受信任的证书颁发机构签名，该机构的证书应该包含在浏览器的证书库中，以便进行验证）。一旦所有检查通过，浏览器就会从
    *[www.nostarch.com](http://www.nostarch.com)* 服务器请求该网站的初始页面。
- en: Upon a successful TLS 1.3 handshake, all communications between the client and
    the server are encrypted and authenticated. An eavesdropper can learn that a client
    at a given IP address is talking to a server at another given IP address, and
    can observe the encrypted content exchanged, but won’t be able to learn the underlying
    plaintext or modify the encrypted messages (if they do, the receiving party will
    notice that the communication has been tampered with, because messages are not
    only encrypted but also authenticated). That’s enough security for many applications.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功完成 TLS 1.3 握手后，客户端和服务器之间的所有通信都将被加密和认证。窃听者可以知道某个 IP 地址的客户端正在与另一个 IP 地址的服务器进行通信，并且可以观察交换的加密内容，但无法得知底层的明文或修改加密消息（如果他们这样做，接收方会注意到通信已被篡改，因为消息不仅被加密，还经过认证）。对于许多应用来说，这样的安全性就足够了。
- en: '*TLS 1.3 Cryptographic Algorithms*'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*TLS 1.3 加密算法*'
- en: We know that TLS 1.3 uses authenticated encryption algorithms, a key derivation
    function (a hash function that derives secret keys from a shared secret), as well
    as a Diffie–Hellman operation. But how exactly do these work, what algorithms
    are used, and how secure are they?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 TLS 1.3 使用了认证加密算法、密钥衍生函数（一个从共享秘密中衍生出秘密密钥的哈希函数），以及 Diffie-Hellman 操作。那么这些是如何工作的，使用了哪些算法，安全性如何呢？
- en: 'With regard to the choice of authenticated ciphers, TLS 1.3 supports only three
    algorithms: AES-GCM, AES-CCM (a slightly less efficient mode than GCM), and the
    ChaCha20 stream cipher combined with the Poly1305 MAC (as defined in RFC 7539).
    Because TLS 1.3 prevents you from using an unsafe key length such as 64 or 80
    bits (which are both too short), the secret key can be either 128 bits (AES-GCM
    or AES-CCM) or 256 bits (AES-GCM or ChaCha20-Poly1305).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 关于认证密码的选择，TLS 1.3 只支持三种算法：AES-GCM、AES-CCM（比 GCM 略低效的模式）和与 Poly1305 MAC 结合使用的
    ChaCha20 流密码（如 RFC 7539 所定义）。因为 TLS 1.3 阻止使用不安全的密钥长度，如 64 位或 80 位（这两者都太短），所以秘密密钥可以是
    128 位（AES-GCM 或 AES-CCM）或 256 位（AES-GCM 或 ChaCha20-Poly1305）。
- en: The key derivation operation (KDF) in [Figure 13-1](ch13.xhtml#ch13fig1) is
    based on HKDF, a construction based on HMAC (discussed in [Chapter 7](ch07.xhtml#ch7))
    and defined in RFC 5869 that uses either the SHA-256 or the SHA-384 hash function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-1](ch13.xhtml#ch13fig1) 中的密钥衍生操作（KDF）基于 HKDF，这是一种基于 HMAC 的构造（在 [第 7 章](ch07.xhtml#ch7)
    中有讨论），并在 RFC 5869 中定义，使用 SHA-256 或 SHA-384 哈希函数。'
- en: 'Your options for performing the Diffie–Hellman operation (the core of the TLS
    1.3 handshake) are limited to elliptic curve cryptography and a multiplicative
    group of integers modulo a prime number (as in traditional Diffie–Hellman). But
    you can’t use just any elliptic curve or group: the supported curves include three
    NIST curves as well as Curve25519 (discussed in [Chapter 12](ch12.xhtml#ch12))
    and Curve448, both defined in RFC 7748\. TLS 1.3 also supports DH over groups
    of integers, as opposed to elliptic curves. The groups supported are the five
    groups defined in RFC 7919: groups of 2048, 3072, 4096, 6144, and 8192 bits.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The 2048-bit group may be TLS 1.3’s weakest link. Whereas the other options
    provide at least 128-bit security, 2048-bit Diffie–Hellman is believed to provide
    less than 100-bit security. Supporting a 2048-bit group can therefore be seen
    as inconsistent with other TLS 1.3 design choices.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: TLS 1.3 Improvements over TLS 1.2
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TLS 1.3 is very different from its predecessor. For one thing, it gets rid of
    weak algorithms like MD5, SHA-1, RC4, and AES in CBC mode. Also, whereas TLS 1.2
    often protected records using a combination of a cipher and a MAC (such as HMAC-SHA-1)
    within a MAC-then-encrypt construction, TLS 1.3 only supports the more efficient
    and more secure authenticated ciphers. TLS 1.3 also ditches elliptic curve point
    encoding negotiation, and defines a single point format for each curve.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: One of the main development goals of TLS 1.3 was to remove features in 1.2 that
    weakened the protocol and to reduce the protocol’s overall complexity and thereby
    its attack surface. For example, TLS 1.3 ditches optional data compression, a
    feature that enabled the CRIME attack on TLS 1.2\. This attack exploited the fact
    that the length of the compressed version of a message leaks information on the
    content of the message.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'But TLS 1.3 also brings new features that make connections either more secure
    or more efficient. I’ll discuss three of these features briefly: downgrade protection,
    the single round-trip handshake, and session resumption.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '*Downgrade Protection*'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TLS 1.3’s *downgrade protection* feature is designed as a defense against *downgrade
    attacks*, wherein an attacker forces the client and server to use a weaker version
    of TLS than 1.3\. To carry out a downgrade attack, an attacker forces the server
    to use a weaker version of TLS by intercepting and modifying the ClientHello message
    to tell the server that the client doesn’t support TLS 1.3\. Now the attacker
    can exploit vulnerabilities in earlier versions of TLS.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: In an effort to defeat downgrade attacks, the TLS 1.3 server uses three types
    of patterns in the 32-byte random value sent within the ServerHello message to
    identify the type of connection requested. The pattern should match the client’s
    request for a specific type of TLS connection. If the client receives the wrong
    pattern, it knows that something is up.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, if the client asks for a TLS 1.2 connection, the first eight of
    the 32 bytes are set to 44 4F 57 4E 47 52 44 01, and if it asks for a TLS 1.1
    connection, they’re set to 44 4F 57 4E 47 52 44 00\. However, if the client requests
    a TLS 1.3 connection, these first eight bits should be random. For example, if
    a client sends a ClientHello asking for a TLS 1.3 connection, but an attacker
    on the network modifies it to ask for a TLS 1.1 connection, when the client receives
    the ServerHello with the wrong pattern, it will know that its ClientHello message
    was modified. (The attacker can’t arbitrarily modify the server’s 32-byte random
    value because this value is cryptographically signed.)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '*Single Round-Trip Handshake*'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a typical TLS 1.2 handshake, the client sends some data to the server, waits
    for a response, and then sends more data and waits for the server’s response before
    sending encrypted messages. The delay is that of two round-trip times (RTT). In
    contrast, TLS 1.3’s handshake takes a single round-trip time, as shown in [Figure
    13-1](ch13.xhtml#ch13fig1). The time saved can be in the hundreds of milliseconds.
    That may sound small, but its actually significant when you consider that servers
    of popular services handle thousands of connections per second.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '*Session Resumption*'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'TLS 1.3 is faster than 1.2, but it can be made even faster (on the order of
    hundreds of milliseconds) by completely eliminating the round trips that precede
    an encrypted session. The trick is to use *session resumption*, a method that
    leverages the pre-shared key exchanged between the client and server in a previous
    session to bootstrap a new session. Session resumption brings two major benefits:
    the client can start encrypting immediately, and there is no need to use certificates
    in these subsequent sessions.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 13-2](ch13.xhtml#ch13fig2) shows how session resumption works. First,
    the client sends a ClientHello message that includes the identifier of the key
    already shared (denoted *PSK* for *pre-shared key*) with the server, along with
    a fresh DH public key. The client can also include encrypted data in this first
    message (such data is known as *0-RTT data*). When the server responds to a ClientHello
    message, it provides a MAC over the data exchange. The client verifies the MAC
    and knows that it’s talking to the same server as it did previously, thus rendering
    certificate validation somewhat superfluous. The client and the server perform
    a Diffie–Hellman key agreement as in the normal handshake, and subsequent messages
    are encrypted using keys that depend on both the PSK and the newly computed Diffie–Hellman
    shared secret.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f13-02.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: The TLS 1.3 session resumption handshake. The 0-RTT data is the
    session resumption data sent along with the ClientHello.*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The Strengths of TLS Security
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll evaluate the strengths of TLS 1.3 with respect to two main security notions
    discussed in [Chapter 11](ch11.xhtml#ch11): authentication and forward secrecy.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将评估 TLS 1.3 在 [第 11 章](ch11.xhtml#ch11) 中讨论的两个主要安全概念的强度：身份验证和前向保密性。
- en: '*Authentication*'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*身份验证*'
- en: During the TLS 1.3 handshake, the server authenticates to the client using the
    certificate mechanism. However, the client is not authenticated, and clients may
    authenticate with a server-based application (such as Gmail) by providing a username
    and password in a TLS record after performing the handshake. If the client has
    already established a session with the remote service, it may authenticate by
    sending a *secure cookie*, one that can only be sent through a TLS connection.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TLS 1.3 握手过程中，服务器通过证书机制对客户端进行身份验证。然而，客户端并没有得到认证，客户端可以通过在 TLS 记录中提供用户名和密码，在完成握手后与基于服务器的应用程序（例如
    Gmail）进行身份验证。如果客户端已经与远程服务建立了会话，它可以通过发送*安全 Cookie*进行身份验证，该 Cookie 只能通过 TLS 连接发送。
- en: 'In certain cases, clients can authenticate to a server using a certificate-based
    mechanism similar to what the server uses in order to authenticate to the client:
    the client sends a *client certificate* to the server, which in turn verifies
    this certificate before authorizing the client. However, client certificates are
    rarely used because they complicate things for both clients and the server (that
    is, the certificate issuer): clients need to perform complex operations in order
    to integrate the certificate into their system and to protect its private key,
    while the issuer needs to make sure that only authorized clients received a certificate,
    among other requirements.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，客户端可以使用类似于服务器身份验证机制的基于证书的机制来对服务器进行身份验证：客户端将 *客户端证书* 发送给服务器，服务器验证该证书后再授权客户端。然而，由于客户端证书会增加客户端和服务器（即证书颁发者）的复杂性，因此很少使用客户端证书：客户端需要执行复杂的操作，将证书集成到系统中并保护其私钥，而颁发者需要确保只有授权的客户端收到证书，以及满足其他要求。
- en: '*Forward Secrecy*'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*前向保密性*'
- en: Recall from [“Key Agreement Protocols”](ch11.xhtml#lev1sec76) on page 205 that
    a key agreement is said to provide forward secrecy if previous sessions aren’t
    compromised when the present session is compromised. In the data leak model, only
    temporary secrets are compromised, whereas in the breach model, long-term secrets
    are exposed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请回忆起在 [“密钥协商协议”](ch11.xhtml#lev1sec76) 第 205 页中的内容，当当前会话被破解时，如果以前的会话没有受到影响，密钥协商被称为提供前向保密性。在数据泄露模型中，仅临时密钥受到影响，而在安全漏洞模型中，长期密钥被暴露。
- en: Thankfully, TLS 1.3 forward secrecy holds up in the face of both a data leak
    and a breach. In the case of the data leak model, the attacker recovers temporary
    secrets such as the session keys or Diffie–Hellman private keys of a specific
    session (the values *c*, *s*, *secret*, and *keys* in [Figure 13-1](ch13.xhtml#ch13fig1)
    on page 242). However, they can only use these values to decrypt communications
    from the present session, but not from previous sessions, because different values
    of *c* and *s* were used (thus yielding different keys).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，TLS 1.3 的前向保密性在数据泄露和安全漏洞面前仍然有效。在数据泄漏模型中，攻击者恢复了某个会话的临时密钥，例如会话密钥或 Diffie–Hellman
    私钥（在 [图 13-1](ch13.xhtml#ch13fig1) 第 242 页中的 *c*、*s*、*secret* 和 *keys* 值）。然而，攻击者只能使用这些值解密当前会话的通信，而无法解密之前的会话，因为使用了不同的
    *c* 和 *s* 值（从而生成了不同的密钥）。
- en: In the breach model, the attacker also recovers long-term secrets (namely, the
    private key that corresponds to the public key in the certificate). However, this
    is no more useful when decrypting previous sessions than temporary secrets, because
    this private key only serves to authenticate the server, and forward secrecy holds
    up again.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全漏洞模型中，攻击者还恢复了长期密钥（即与证书中的公钥对应的私钥）。然而，这对于解密之前的会话并不比临时密钥更有用，因为该私钥仅用于验证服务器，前向保密性再次得以维持。
- en: But what happens in practice? Say an attacker compromises a client’s machine
    and gains access to all of its memory. Now the attacker may recover the client’s
    TLS session keys and secrets for the current session from memory. But more importantly,
    if previous keys are still in memory, the attacker may be able to find them too
    and use them to decrypt previous sessions, thereby bypassing the theoretical forward
    secrecy. Therefore, in order for a TLS implementation to ensure forward secrecy,
    it must properly erase keys from memory once they are no longer used, typically
    by zeroing out the memory.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在实际操作中会发生什么呢？假设攻击者入侵了客户端的计算机，并获得了其所有内存的访问权限。现在，攻击者可能从内存中恢复当前会话的TLS会话密钥和密钥。但是更重要的是，如果之前的密钥仍然保存在内存中，攻击者可能也能够找到它们，并用它们解密之前的会话，从而绕过理论上的前向保密性。因此，为了确保前向保密性，TLS实现必须在不再使用密钥时，正确地从内存中清除这些密钥，通常是通过将内存置零来实现。
- en: How Things Can Go Wrong
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题可能出在哪里
- en: TLS 1.3 fits the bill as a general-purpose secure communications protocol, but
    it’s not bulletproof. Like any security system, it can fail under certain circumstances
    (for example, when the assumptions made by its designers about real attacks turn
    out to be wrong). Unfortunately, even the latest version of TLS 1.3, configured
    with the most secure ciphers, can still be compromised. For example, TLS 1.3 security
    relies on the assumption that all three parties (the client, the server, and the
    certificate authority) will behave honestly, but what if one party is compromised
    or the TLS implementation itself is poorly implemented?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: TLS 1.3作为通用安全通信协议符合要求，但并非万无一失。像任何安全系统一样，它在某些情况下也会失败（例如，当设计者对实际攻击的假设被证明是错误的时）。不幸的是，即使是配置了最安全密码的最新版本TLS
    1.3也可能会被攻破。例如，TLS 1.3的安全性依赖于假设所有三方（客户端、服务器和证书颁发机构）都会诚实地行事，但如果其中一方遭到攻击或TLS实现本身存在问题怎么办？
- en: '*Compromised Certificate Authority*'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*受损的证书颁发机构*'
- en: Root certificate authorities (root CAs) are organizations that are trusted by
    browsers to validate certificates served by remote hosts. For example, if your
    browser accepts the certificate provided by *[www.google.com](http://www.google.com)*,
    the assumption is that a trusted CA has verified the legitimacy of the certificate
    owner. The browser verifies the certificate by checking its CA-issued signature.
    Since only the CA knows the private key required to create this signature, we
    assume that others can’t create valid certificates on behalf of the CA. Very often
    a website’s certificate won’t be signed by a root CA but by an inter­mediate CA,
    which is connected to the root CA through a certificate chain.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 根证书颁发机构（Root CAs）是浏览器信任的组织，用于验证远程主机提供的证书。例如，如果你的浏览器接受了*[www.google.com](http://www.google.com)*提供的证书，假设一个受信任的CA已经验证了证书所有者的合法性。浏览器通过检查CA签发的签名来验证证书。由于只有CA知道创建此签名所需的私钥，因此我们假设其他人无法代表CA创建有效的证书。通常，一个网站的证书不会由根CA签发，而是由中间CA签发，中间CA通过证书链与根CA连接。
- en: But let’s say that a CA’s private key is compromised. Now the attacker will
    be able to use the CA’s private key to create a certificate for any URLs in, say,
    the *[google.com](http://google.com)* domain without Google’s approval. What happens
    then? The attacker can use those certificates to pretend to host a legitimate
    server or subdomain like *[mail.google.com](http://mail.google.com)* and intercept
    a user’s credentials and communications. That’s exactly what happened in 2011
    when an attacker hacked into the network of the Dutch certificate authority DigiNotar
    and was able to create certificates that appeared to have been legitimate DigiNotar
    certificates. The attacker then used these fake certificates for several Google
    services.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 假设CA的私钥被泄露。那么攻击者将能够使用CA的私钥为任何URL（比如，* [google.com](http://google.com) * 域名下的URL）创建证书，而无需Google的批准。那么会发生什么呢？攻击者可以利用这些证书冒充合法服务器或子域名，比如*
    [mail.google.com](http://mail.google.com) *，并拦截用户的凭据和通信。这正是2011年发生的事情，当时攻击者入侵了荷兰证书机构DigiNotar的网络，并成功创建了看似合法的DigiNotar证书。攻击者随后利用这些伪造证书访问了多个Google服务。
- en: '*Compromised Server*'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*受损的服务器*'
- en: 'If a server is compromised and fully controlled by an attacker, all is lost:
    the attacker will be able to see all transmitted data before it’s encrypted, and
    all received data once it has been decrypted. They will also be able to get their
    hands on the server’s private key, which could allow them to impersonate the legitimate
    server using their own malicious server. Obviously, TLS won’t save you in this
    case.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, such security disasters are rarely seen in high-profile applications
    such as Gmail and iCloud, which are well protected and sometimes have their private
    keys stored in a separate security module. Attacks on web applications via vulnerabilities
    such as database query injections and cross-site scripting are more common, because
    they are mostly independent of TLS’s security and are carried out by attackers
    over a legitimate TLS connection. Such attacks may compromise usernames, passwords,
    and so on.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '*Compromised Client*'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TLS security is also compromised when a client, such as a browser, is compromised
    by a remote attacker. Having compromised the client, the attacker will be able
    to capture session keys, read any decrypted data, and so on. They could even install
    a rogue CA certificate in the client’s browser to have it silently accept otherwise
    invalid certificates, thereby letting attackers intercept TLS connections.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The big difference between the compromised CA or server scenarios and the compromised
    client scenario is that in the case of the compromised client, only the targeted
    client will be affected, instead of potentially *all* the clients.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '*Bugs in Implementations*'
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As with any cryptographic system, TLS can fail when there are bugs in its implementation.
    The poster child for TLS bugs is Heartbleed (see [Figure 13-3](ch13.xhtml#ch13fig3)),
    a buffer overflow in the OpenSSL implementation of a minor TLS feature known as
    heartbeat. Heartbleed was discovered in 2014, independently by a Google researcher
    and by the Codenomicon company, and affected millions of TLS servers and clients.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 13-3](ch13.xhtml#ch13fig3), a client first sends a
    buffer along with a buffer length to the server to check whether the server is
    online. In this example, the buffer is the string *BANANAS*, and the client explicitly
    says that this word is seven letters long. The server reads the seven-letter word
    and returns it to the client.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f13-03.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-3: The Heartbleed bug in OpenSSL implementations of TLS*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that the server doesn’t confirm that the length is correct, and
    will attempt to read as many characters as the client tells it to. Consequently,
    if the client provides a length that is longer than the string’s actual length,
    the server reads too much data from memory and will return it to the client, together
    with any extra data that may contain sensitive information, such as private keys
    or session cookies.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: It won’t surprise you to hear that the Heartbleed bug came as a shock. To avoid
    similar future bugs, OpenSSL and other major TLS implementations now perform rigorous
    code reviews and use automated tools such as fuzzers in order to identify potential
    issues.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你听到Heartbleed漏洞的消息时，应该不会感到惊讶。为了避免未来类似的漏洞，OpenSSL和其他主要的TLS实现现在进行严格的代码审查，并使用自动化工具，如模糊测试工具（fuzzers），来识别潜在问题。
- en: Further Reading
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'As I stated at the outset, this chapter is not a comprehensive guide to TLS,
    and you may want to dig deeper into TLS 1.3\. For starters, the complete TLS 1.3
    specifications include everything about the protocol (though not necessarily about
    its underlying rationale). You can find that on the home page of the TLS Working
    Group (TLSWG) here: *[https://tlswg.github.io/](https://tlswg.github.io/)*.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在开头所提到的，本章并不是关于TLS的全面指南，你可能想要更深入地了解TLS 1.3。首先，完整的TLS 1.3规范涵盖了协议的所有内容（尽管不一定包括其背后的理论依据）。你可以在TLS工作组（TLSWG）的主页上找到该规范，网址是：*[https://tlswg.github.io/](https://tlswg.github.io/)*。
- en: 'In addition, let me cite two important TLS initiatives:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我提到两个重要的TLS倡议：
- en: SSL Labs TLS test (*[https://www.ssllabs.com/ssltest/](https://www.ssllabs.com/ssltest/)*)
    is a free service by Qualys that lets you test a browser’s or a server’s TLS configuration,
    providing a security rating as well as improvement suggestions. If you set up
    your own TLS server, use this test to make sure that everything is safe and that
    you get an “A” rating.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSL Labs TLS测试（*[https://www.ssllabs.com/ssltest/](https://www.ssllabs.com/ssltest/)）*是Qualys提供的一个免费服务，允许你测试浏览器或服务器的TLS配置，提供安全评分和改进建议。如果你设置了自己的TLS服务器，可以使用这个测试来确保一切安全，并获得“A”评级。
- en: Let’s Encrypt (*[https://letsencrypt.org/](https://letsencrypt.org/)*) is a
    nonprofit that offers a service to “automagically” deploy TLS on your HTTP servers.
    It includes features to automatically generate a certificate and configure the
    TLS server, and it supports all the common web servers and operating systems.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Let’s Encrypt（*[https://letsencrypt.org/](https://letsencrypt.org/)）*是一个非盈利组织，提供“自动化”在你的HTTP服务器上部署TLS的服务。它包括自动生成证书和配置TLS服务器的功能，并且支持所有常见的Web服务器和操作系统。
