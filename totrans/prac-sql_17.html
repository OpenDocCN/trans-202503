<html><head></head><body><div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" title="337" id="Page_337"/>17</span><br/>&#13;
<span class="ChapterTitle">Saving Time with Views, Functions, and Triggers</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img src="Images/chapterart.png" alt="" width="200" height="200"/>&#13;
</figure>&#13;
<p class="ChapterIntro">One advantage of using a programming language is that we can automate repetitive, boring tasks. That’s what this chapter is about: taking the queries or steps you might do over and over and turning them into reusable database objects that you code once and can call later to let the database do the work. Programmers call this the DRY principle: Don’t Repeat Yourself.</p>&#13;
<p>You’ll start by learning to store queries as reusable database <em>views</em>. Next, you’ll explore how to create database functions you can use to operate on your data, the same way you’ve used built-in functions like <code>round()</code> and <code>upper()</code>. Then you’ll set up <em>triggers</em> to run your functions automatically when certain events occur on a table. All these techniques are useful not only for reducing repetitive work but for ensuring data integrity too.</p>&#13;
<p>We’ll practice these techniques on tables created from examples in earlier chapters. All the code for this chapter is available for download along with the book’s resources at <a href="https://nostarch.com/practical-sql-2nd-edition/" class="LinkURL">https://nostarch.com/practical-sql-2nd-edition/</a>.</p>&#13;
<h2 id="h1-501065c17-0001"><span epub:type="pagebreak" title="338" id="Page_338"/>Using Views to Simplify Queries</h2>&#13;
<p class="BodyFirst">A <em>view</em> is essentially a stored query with a name that you can work with as if it were a table. For example, a view might store a query that calculates total population by state. As with a table, you could query that view, join the view to tables (or to other views), and use the view to update or insert data into a table it’s based on, albeit with some caveats. The stored query in a view can be simple, referencing just one table, or complex, with multiple table joins.</p>&#13;
<p>Views are especially useful in the following scenarios:</p>&#13;
<ul>&#13;
<li><b>Avoiding duplicate effort:</b> They let you write a complex query once and access the results when needed.</li>&#13;
<li><b>Reducing clutter:</b> They can trim the amount of information you need to wade through by showing only columns relevant to your needs.</li>&#13;
<li><b>Providing security:</b> Views can limit access to only certain columns in a table.</li>&#13;
</ul>&#13;
<p>In this section, we’ll look at two kinds of views. The first—a standard view—contains PostgreSQL syntax that’s largely in line with the ANSI SQL standard for views. Every time you access a standard view, the stored query runs and generates a temporary set of results. The second is a <em>materialized view</em>, which is specific to PostgreSQL, Oracle, and a limited number of other database systems. When you create a materialized view, the data returned by its query is stored permanently in the database like a table; you can refresh the view to update the stored data if needed.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	To ensure data security and prevent users from seeing sensitive information, you must restrict access by setting account permissions in PostgreSQL and also define the view using a <code>security_barrier</code> attribute. Typically, a database administrator handles these tasks, but if you want to explore this issue further, read the PostgreSQL documentation on user roles at <a href="https://www.postgresql.org/docs/current/sql-createrole.html" class="LinkURL">https://www.postgresql.org/docs/current/sql-createrole.html</a>, on the <code>GRANT</code> command at <a href="https://www.postgresql.org/docs/current/sql-grant.html" class="LinkURL">https://www.postgresql.org/docs/current/sql-grant.html</a>, and on <code>security_barrier</code> at <a href="https://www.postgresql.org/docs/current/rules-privileges.html" class="LinkURL">https://www.postgresql.org/docs/current/rules-privileges.html</a>.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>Views are easy to create and maintain. Let’s work through several examples to see how they work.</p>&#13;
<h3 id="h2-501065c17-0001">Creating and Querying Views</h3>&#13;
<p class="BodyFirst">In this section, we’ll return to the census estimates table <code>us_counties_pop_est_2019</code> you imported in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>. <a href="#listing17-1" id="listinganchor17-1">Listing 17-1</a> creates a standard view that returns just the population of Nevada counties. The original table has sixteen columns; the view will return just four of them. This would be useful for making a subset of Nevada census data quickly accessible when we’re referring to it often or using the data in an application.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> CREATE OR REPLACE VIEW nevada_counties_pop_2019 AS&#13;
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> SELECT county_name,&#13;
<span epub:type="pagebreak" title="339" id="Page_339"/>           state_fips,&#13;
           county_fips,&#13;
           pop_est_2019&#13;
    FROM us_counties_pop_est_2019&#13;
    WHERE state_name = 'Nevada';</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-1">Listing 17-1</a>: Creating a view that displays Nevada 2019 counties</p>&#13;
<p>We define the view using the keywords <code>CREATE OR REPLACE VIEW</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> followed by the view’s name, <code>nevada_counties_pop_2019</code>, and then <code>AS</code>. (We can name the view any way we’d like; I prefer a name that’s descriptive of the view’s results.) Next, we use a standard SQL <code>SELECT</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> to fetch the 2019 population estimate (the <code>pop_est_2019</code> column) for each Nevada county from the <code>us_counties_pop_est_2019</code> table.</p>&#13;
<p>Notice the <code>OR REPLACE</code> keywords after <code>CREATE</code>. These are optional and tell the database that if a view with this name already exists, then replace it with the new definition. It’s helpful to include these keywords if you’re iterating on creating a view and want to refine the query. There is one caveat: if you’re replacing an existing view, the new query <span class="CodeAnnotation" aria-label="annotation2">2</span> must generate the same column names with the same data types and in the same order as the one it’s replacing. You can add columns, but they must be placed at the end of the column list. If you try to do otherwise, the database will respond with an error message.</p>&#13;
<p>Run the code in <a href="#listing17-1">Listing 17-1</a> using pgAdmin. The database should respond with the message <code>CREATE VIEW</code>. To find the new view, in pgAdmin’s object browser, right-click the <code>analysis</code> database and click <b>Refresh</b>. Choose <b>Schemas</b><span class="MenuArrow">▶</span><b>public</b><span class="MenuArrow">▶</span><b>Views</b> to see all views. When you right-click your new view and click <b>Properties</b>, you should see a more verbose version of the query (with the table name prepended to each column name) on the Code tab in the dialog that opens. That’s a handy way to inspect views you might find in a database.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	As with other database objects, you can delete a view using the <code>DROP</code> command. In this example, the syntax would be <code>DROP VIEW nevada_counties_pop_2019;</code>.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>This type of view—one that isn’t materialized—holds no data at this point; instead, the stored <code>SELECT</code> query it contains will run when you access the view from another query. For example, the code in <a href="#listing17-2" id="listinganchor17-2">Listing 17-2</a> returns all columns in the view. As with a typical <code>SELECT</code> query, we can use <code>ORDER BY</code> to sort results, this time using the county’s Federal Information Processing Standards (FIPS) code—the standard designator the US Census Bureau and other federal agencies use to specify each county and state. We also add a <code>LIMIT</code> clause to display just five rows.</p>&#13;
<pre><code>SELECT *&#13;
FROM nevada_counties_pop_2019&#13;
ORDER BY county_fips&#13;
LIMIT 5;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-2">Listing 17-2</a>: Querying the <code>nevada_counties_pop_2010</code> view</p>&#13;
<p><span epub:type="pagebreak" title="340" id="Page_340"/>Aside from the five-row limit, the result should be the same as if you had run the <code>SELECT</code> query used to create the view in <a href="#listing17-1">Listing 17-1</a>:</p>&#13;
<pre><code>     geo_name     | state_fips | county_fips | pop_2010&#13;
------------------+------------+-------------+----------&#13;
 Churchill County | 32         | 001         |   24909&#13;
 Clark County     | 32         | 003         | 2266715&#13;
 Douglas County   | 32         | 005         |   48905&#13;
 Elko County      | 32         | 007         |   52778&#13;
 Esmeralda County | 32         | 009         |     873</code></pre>&#13;
<p>This simple example isn’t useful unless quickly listing Nevada county population is a task you’ll perform frequently. So, let’s imagine a question data-minded analysts in a political research organization might ask often: what was the percent change in population for each county in Nevada (or any other state) from 2010 to 2019?</p>&#13;
<p>We wrote a query to answer this question in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>, and though it wasn’t onerous to create, it did require joining tables on two columns and using a percent change formula that involved rounding and type casting. To avoid repeating that work, we can create a view that stores a query similar to the one in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span> as a view, as shown in <a href="#listing17-3" id="listinganchor17-3">Listing 17-3</a>.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> CREATE OR REPLACE VIEW county_pop_change_2019_2010 AS&#13;
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> SELECT c2019.county_name,&#13;
           c2019.state_name,&#13;
           c2019.state_fips,&#13;
           c2019.county_fips,&#13;
           c2019.pop_est_2019 AS pop_2019,&#13;
           c2010.estimates_base_2010 AS pop_2010,&#13;
         <span class="CodeAnnotationCode" aria-label="annotation3">3</span> round( (c2019.pop_est_2019::numeric - c2010.estimates_base_2010)&#13;
               / c2010.estimates_base_2010 * 100, 1 ) AS pct_change_2019_2010&#13;
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> FROM us_counties_pop_est_2019 AS c2019&#13;
        JOIN us_counties_pop_est_2010 AS c2010&#13;
    ON c2019.state_fips = c2010.state_fips&#13;
       AND c2019.county_fips = c2010.county_fips;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-3">Listing 17-3</a>: Creating a view showing population change for US counties</p>&#13;
<p>We start the view definition with <code>CREATE OR REPLACE VIEW</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, followed by the name of the view and <code>AS</code>. The <code>SELECT</code> query <span class="CodeAnnotation" aria-label="annotation2">2</span> names columns from the census tables and includes a column definition with a percent change calculation <span class="CodeAnnotation" aria-label="annotation3">3</span> that you learned about in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>. Then we join the 2019 and 2010 census tables <span class="CodeAnnotation" aria-label="annotation4">4</span> using the state and county FIPS codes. Run the code, and the database should again respond with <code>CREATE VIEW</code>.</p>&#13;
<p>Now that we’ve created the view, we can use the code in <a href="#listing17-4" id="listinganchor17-4">Listing 17-4</a> to run a simple query using the new view that retrieves data for Nevada counties.</p>&#13;
<pre><code>SELECT county_name,&#13;
       state_name,&#13;
       pop_2019,&#13;
     <span class="CodeAnnotationCode" aria-label="annotation1">1</span> pct_change_2019_2010&#13;
FROM county_pop_change_2019_2010&#13;
<span epub:type="pagebreak" title="341" id="Page_341"/><span class="CodeAnnotationHang" aria-label="annotation2">2</span> WHERE state_name = 'Nevada'&#13;
ORDER BY county_fips&#13;
LIMIT 5;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-4">Listing 17-4</a>: Selecting columns from the <code>county_pop_change_2019_2010</code> view</p>&#13;
<p>In <a href="#listing17-2">Listing 17-2</a>, in the query that referenced our <code>nevada_counties_pop_2019</code> view, we retrieved every column in the view by using the asterisk wildcard after <code>SELECT</code>. <a href="#listing17-4">Listing 17-4</a> shows that, as with a query on a table, we can name specific columns when querying a view. Here, we specify four of the <code>county_pop_change_2019_2010</code> view’s seven columns. One is <code>pct_change_2019_2010</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, which returns the result of the percent change calculation we’re looking for. As you can see, it’s much simpler to write the column name like this than the whole formula. We’re also filtering the results using a <code>WHERE</code> clause <span class="CodeAnnotation" aria-label="annotation2">2</span>, similar to how we’d filter any query.</p>&#13;
<p>After querying the four columns from the view, the results should look like this:</p>&#13;
<pre><code>  county_name     state_name  pop_2019  pct_change_2019_2010&#13;
----------------  ----------  --------  --------------------&#13;
Churchill County  Nevada         24909                   0.1&#13;
Clark County      Nevada       2266715                  16.2&#13;
Douglas County    Nevada         48905                   4.1&#13;
Elko County       Nevada         52778                   7.8&#13;
Esmeralda County  Nevada           873                  11.4</code></pre>&#13;
<p>Now we can revisit this view as often as we like to pull data for presentations or to answer questions about the percent change in population for any county in America from 2010 to 2019.</p>&#13;
<p>Looking at just these five rows, you can see a couple of interesting stories emerge: the continued rapid growth of Clark County, which includes the city of Las Vegas, as well as a strong percent increase in Esmeralda County, one of the smallest counties in the United States and home to several ghost towns.</p>&#13;
<h3 id="h2-501065c17-0002">Creating and Refreshing a Materialized View</h3>&#13;
<p class="BodyFirst">A materialized view differs from a standard view in that upon its creation, the materialized view’s stored query is executed, and the results it generates are saved in the database. In effect, this creates a new table. The view retains its stored query, so you can update the saved data by issuing a command to refresh the view. A good use for materialized views is to preprocess complex queries that take a while to run and make those results available for faster querying.</p>&#13;
<p>Let’s drop the <code>nevada_counties_pop_2019</code> view and re-create it as a materialized view using the code in <a href="#listing17-5" id="listinganchor17-5">Listing 17-5</a>.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> DROP VIEW nevada_counties_pop_2019;&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> CREATE MATERIALIZED VIEW nevada_counties_pop_2019 AS&#13;
    SELECT county_name,&#13;
<span epub:type="pagebreak" title="342" id="Page_342"/>           state_fips,&#13;
           county_fips,&#13;
           pop_est_2019&#13;
    FROM us_counties_pop_est_2019&#13;
    WHERE state_name = 'Nevada';</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-5">Listing 17-5</a>: Creating a materialized view</p>&#13;
<p>First, we use a <code>DROP VIEW</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> statement to remove the <code>nevada_counties_pop_2019</code> view from the database. Then, we run <code>CREATE MATERIALIZED VIEW</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> to make the view. Notice that the syntax is the same as the one for making a standard view, except for the added <code>MATERIALIZED</code> keyword and the omission of <code>OR REPLACE</code>, which is not available in the materialized view syntax. After running the statement, the database should respond with the message <code>SELECT 17</code>, telling you that the view’s query produced 17 rows to be stored in the view. We can now query this data as with a standard view.</p>&#13;
<p>Let’s say that the population estimates stored in <code>us_counties_pop_est_2019</code> are revised. To update the data stored in the materialized view, we can use the <code>REFRESH</code> keyword, as in <a href="#listing17-6" id="listinganchor17-6">Listing 17-6</a>.</p>&#13;
<pre><code>REFRESH MATERIALIZED VIEW nevada_counties_pop_2019;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-6">Listing 17-6</a>: Refreshing a materialized view</p>&#13;
<p>Executing this statement reruns the query stored in the <code>nevada_counties_pop_2019</code> view; the server will respond with the message <code>REFRESH MATERIALIZED VIEW</code>. The view will now reflect any updates to the data referenced by the view’s query. When you have a query that takes some time to run, you can save time by storing its results in a materialized view that’s refreshed periodically, letting users quickly access the stored data rather than run a lengthy query.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	Using <code>REFRESH MATERIALIZED VIEW</code><code> CONCURRENTLY</code> will prevent locking out <code>SELECT</code> statements that are executed against the view during the refresh. See <a href="https://www.postgresql.org/docs/current/sql-refreshmaterializedview.html" class="LinkURL">https://www.postgresql.org/docs/current/sql-refreshmaterializedview.html</a> for details.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>To delete a materialized view, we use a <code>DROP MATERIALIZED VIEW</code> statement. Also, note that materialized views appear in a different part of pgAdmin’s object browser, under <b>Schemas</b><span class="MenuArrow">▶</span><b>public</b><span class="MenuArrow">▶</span><b>Materialized Views</b>.</p>&#13;
<h3 id="h2-501065c17-0003">Inserting, Updating, and Deleting Data Using a View</h3>&#13;
<p class="BodyFirst">With nonmaterialized views, you can update or insert data in the underlying table being queried as long as the view meets certain conditions. One requirement is that the view must reference a single table or updatable view. If the view’s query joins tables, as with the population change view we just built in the previous section, you can’t perform inserts or updates to the original table directly. Also, the view’s query can’t contain <code>DISTINCT</code>, <code>WITH</code>, <code>GROUP BY</code>, or other clauses. (See a complete list of restrictions at <a href="https://www.postgresql.org/docs/current/sql-createview.html" class="LinkURL">https://www.postgresql.org/docs/current/sql-createview.html</a>.)</p>&#13;
<p><span epub:type="pagebreak" title="343" id="Page_343"/>You already know how to directly insert and update data on a table, so why do it through a view? One reason is that a view is one way you can exercise control over which data a user can update. Let’s work through an example to see how this works.</p>&#13;
<h4 id="h3-501065c17-0001">Creating a View of Employees</h4>&#13;
<p class="BodyFirst">In the <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span> lesson on joins, we created and filled the <code>departments</code> and <code>employees</code> tables with four rows about people and where they work (if you skipped that section, you can revisit <a href="c07.xhtml#listing7-1" id="listinganchor7-1">Listing 7-1</a>). Running a quick <code>SELECT * FROM employees ORDER BY emp_id;</code> query shows the table’s contents, as you can see here:</p>&#13;
<pre><code>emp_id first_name last_name  salary   dept_id&#13;
------ ---------- --------- --------- -------&#13;
     1 Julia      Reyes     115300.00       1&#13;
     2 Janet      King       98000.00       1&#13;
     3 Arthur     Pappas     72700.00       2&#13;
     4 Michael    Taylor     89500.00       2</code></pre>&#13;
<p>Let’s say we want to use a view to give users in the Tax Department (its <code>dept_id</code> is <code>1</code>) the ability to add, remove, or update their employees’ names without letting them change salary information or the data of employees in another department. To do this, we can set up a view using <a href="#listing17-7" id="listinganchor17-7">Listing 17-7</a>.</p>&#13;
<pre><code>CREATE OR REPLACE VIEW employees_tax_dept WITH (security_barrier)<span class="CodeAnnotationCode" aria-label="annotation1">1</span> AS&#13;
     SELECT emp_id,&#13;
            first_name,&#13;
            last_name,&#13;
            dept_id&#13;
     FROM employees&#13;
   <span class="CodeAnnotationCode" aria-label="annotation2">2</span> WHERE dept_id = 1&#13;
   <span class="CodeAnnotationCode" aria-label="annotation3">3</span> WITH LOCAL CHECK OPTION;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-7">Listing 17-7</a>: Creating a view on the <code>employees</code> table</p>&#13;
<p>This view is similar to others we’ve created so far, but with a few additions. First, in the <code>CREATE OR REPLACE VIEW</code> statement, we add the keywords <code>WITH (security_barrier)</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. This enables a level of database security to prevent a malicious user from getting around restrictions that the view places on rows and columns. (See <a href="https://www.postgresql.org/docs/current/rules-privileges.html" class="LinkURL">https://www.postgresql.org/docs/current/rules-privileges.html</a> for how someone might subvert a view if you omit this type of security.)</p>&#13;
<p>In the view’s <code>SELECT</code> query, we pick the columns we want to show from the <code>employees</code> table and use <code>WHERE</code> to filter the results on <code>dept_id = 1</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> to list only Tax Department staff. The view itself will restrict updates or deletes to rows matching the condition in the <code>WHERE</code> clause. Adding the keywords <code>WITH LOCAL CHECK OPTION</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> restricts inserts as well, allowing users to add new Tax Department employees only (if the view definition omitted those keywords, you could use it to insert a row with a <code>dept_id</code> of <code>3</code>, for example). The <code>LOCAL CHECK OPTION</code> also prevents a user from changing an employee’s <code>dept_id</code> to a value other than <code>1</code>.</p>&#13;
<p><span epub:type="pagebreak" title="344" id="Page_344"/>Create the <code>employees_tax_dept</code> view by running the code in <a href="#listing17-7">Listing 17-7</a>. Then run <code>SELECT * FROM employees_tax_dept ORDER BY emp_id;</code>, which should provide these two rows:</p>&#13;
<pre><code>emp_id first_name last_name dept_id&#13;
------ ---------- --------- -------&#13;
     1 Julia      Reyes           1&#13;
     2 Janet      King            1</code></pre>&#13;
<p>The result shows the employees who work in the Tax Department; they’re two of the four rows in the entire <code>employees</code> table.</p>&#13;
<p>Now, let’s look at how inserts and updates work via this view.</p>&#13;
<h4 id="h3-501065c17-0002">Inserting Rows Using the employees_tax_dept View</h4>&#13;
<p class="BodyFirst">We can use a view to insert or update data, but instead of using the table name in the <code>INSERT</code> or <code>UPDATE</code> statement, we substitute the view name. After we add or change data using a view, the change is applied to the underlying table, which in this case is <code>employees</code>. The view then reflects the change via the query it runs.</p>&#13;
<p><a href="#listing17-8" id="listinganchor17-8">Listing 17-8</a> shows two examples that attempt to add new employee records via the <code>employees_tax_dept</code> view. The first succeeds, but the second fails.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> INSERT INTO employees_tax_dept (emp_id, first_name, last_name, dept_id)&#13;
VALUES (5, 'Suzanne', 'Legere', 1);&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> INSERT INTO employees_tax_dept (emp_id, first_name, last_name, dept_id)&#13;
VALUES (6, 'Jamil', 'White', 2);&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> SELECT * FROM employees_tax_dept ORDER BY emp_id;&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> SELECT * FROM employees ORDER BY emp_id;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-8">Listing 17-8</a>: Successful and rejected inserts via the <code>employees_tax_dept</code> view</p>&#13;
<p>In the first <code>INSERT</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, which uses the insert syntax you learned in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, we supply the first and last names of Suzanne Legere plus her <code>emp_id</code> and <code>dept_id</code>. Because the new row will satisfy the <code>LOCAL CHECK</code> in the view—it contains the same columns and <code>dept_id</code> is <code>1</code>—the insert succeeds when it executes.</p>&#13;
<p>But when we run the second <code>INSERT</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> to add an employee named Jamil White using a <code>dept_id</code> of <code>2</code>, the operation fails with the error message <code>new row violates check option for view "employees_tax_dept"</code>. The reason is that when we created the view, we used a <code>WHERE</code> clause to return only rows with <code>dept_id = 1</code>. The <code>dept_id</code> of <code>2</code> doesn’t pass the <code>LOCAL CHECK</code>, so it’s prevented from being inserted.</p>&#13;
<p><span epub:type="pagebreak" title="345" id="Page_345"/>Run the <code>SELECT</code> statement <span class="CodeAnnotation" aria-label="annotation3">3</span> on the view to check that Suzanne Legere was successfully added:</p>&#13;
<pre><code>emp_id first_name last_name dept_id&#13;
------ ---------- --------- -------&#13;
     1 Julia      Reyes           1&#13;
     2 Janet      King            1&#13;
     5 Suzanne    Legere          1</code></pre>&#13;
<p>We also query the <code>employees</code> table <span class="CodeAnnotation" aria-label="annotation4">4</span> to see that, in fact, Suzanne Legere was added to the full table. The view queries the <code>employees</code> table each time we access it.</p>&#13;
<pre><code>emp_id first_name last_name  salary   dept_id&#13;
------ ---------- --------- --------- -------&#13;
     1 Julia      Reyes     115300.00       1&#13;
     2 Janet      King       98000.00       1&#13;
     3 Arthur     Pappas     72700.00       2&#13;
     4 Michael    Taylor     89500.00       2&#13;
     5 Suzanne    Legere                    1</code></pre>&#13;
<p>As you can see from the addition of Suzanne Legere, the data we add using a view is also added to the underlying table. However, because the view doesn’t include the <code>salary</code> column, the value in her row is <code>NULL</code>. If you attempt to insert a salary value using this view, you would receive the error message <code>column "salary" of relation "employees_tax_dept" does not exist</code>. The reason is that even though the <code>salary</code> column exists in the underlying <code>employees</code> table, it’s not referenced in the view. Again, this is one way to limit access to sensitive data. Check the links I provided in the note in the section “Using Views to Simplify Queries” to learn more about granting permissions to users and adding <code>WITH (security_barrier)</code> if you plan to take on database administrator responsibilities.</p>&#13;
<h4 id="h3-501065c17-0003">Updating Rows Using the employees_tax_dept View</h4>&#13;
<p class="BodyFirst">The same restrictions on accessing data in an underlying table apply when we update data using the <code>employees_tax_dept</code> view. <a href="#listing17-9" id="listinganchor17-9">Listing 17-9</a> shows a standard query to change the spelling of Suzanne’s last name using <code>UPDATE</code> (as a person with more than one uppercase letter in their last name, I can confirm such corrections aren’t unusual).</p>&#13;
<pre><code>UPDATE employees_tax_dept&#13;
SET last_name = 'Le Gere'&#13;
WHERE emp_id = 5;&#13;
&#13;
SELECT * FROM employees_tax_dept ORDER BY emp_id;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-9">Listing 17-9</a>: Updating a row via the <code>employees_tax_dept</code> view</p>&#13;
<p><span epub:type="pagebreak" title="346" id="Page_346"/>Run the code, and the result from the <code>SELECT</code> query should show the updated last name, which occurs in the underlying <code>employees</code> table:</p>&#13;
<pre><code>emp_id first_name last_name dept_id&#13;
------ ---------- --------- -------&#13;
     1 Julia      Reyes           1&#13;
     2 Janet      King            1&#13;
     5 Suzanne    Le Gere         1</code></pre>&#13;
<p>Suzanne’s last name is now correctly spelled as Le Gere, not Legere.</p>&#13;
<p>However, if we try to update the name of an employee who’s not in the Tax Department, the query fails just as it did when we tried to insert Jamil White in <a href="#listing17-8">Listing 17-8</a>. Trying to use this view to update the salary of an employee—even one in the Tax Department—will also fail. If the view doesn’t reference a column in the underlying table, you can’t access that column through the view. Again, the fact that updates on views are restricted in this way offers ways to secure and hide certain pieces of data.</p>&#13;
<h4 id="h3-501065c17-0004">Deleting Rows Using the employees_tax_dept View</h4>&#13;
<p class="BodyFirst">Now, let’s explore how to delete rows using a view. The restrictions on which data you can affect apply here as well. For example, if Suzanne Le Gere gets a better offer from another firm and decides to leave, you could remove her from <code>employees</code> through the <code>employees_tax_dept</code> view. <a href="#listing17-10" id="listinganchor17-10">Listing 17-10</a> shows the query in the standard <code>DELETE</code> syntax.</p>&#13;
<pre><code>DELETE FROM employees_tax_dept&#13;
WHERE emp_id = 5;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-10">Listing 17-10</a>: Deleting a row via the <code>employees_tax_dept</code> view</p>&#13;
<p>Run the query, and PostgreSQL should respond with <code>DELETE 1</code>. However, when you try to delete a row for an employee in a department other than the Tax Department, PostgreSQL won’t allow it and will report <code>DELETE 0</code>.</p>&#13;
<p>In summary, views not only give you control over access to data, but also give you shortcuts for working with data. Next, let’s explore how to use functions to save keystrokes and time.</p>&#13;
<h2 id="h1-501065c17-0002">Creating Your Own Functions and Procedures</h2>&#13;
<p class="BodyFirst">You’ve used functions throughout the book, such as to capitalize letters with <code>upper()</code> or add numbers with <code>sum()</code>. Behind these functions is a significant amount of (sometimes complex) programming that executes a series of actions and may, depending on the job of the function, return a response. We’ll avoid complicated code here, but we’ll build some basic functions that you can use as a launchpad for your own ideas. Even simple functions can help you avoid repeating code.</p>&#13;
<p>Much of the syntax in this section is specific to PostgreSQL, which supports both user-defined functions and <em>procedures</em> (the difference between the two is subtle, and I’ll give examples of both). You can define functions and <span epub:type="pagebreak" title="347" id="Page_347"/>procedures using plain SQL, but you also can choose from other options. One is a PostgreSQL-specific <em>procedural language</em> called PL/pgSQL that adds features not found in standard SQL, such as logical control structures (<code>IF ... THEN ... ELSE</code>). Other options include PL/Python and PL/R for the Python and R programming languages.</p>&#13;
<p>Note that major database systems including Microsoft SQL Server, Oracle, and MySQL implement their own variations of functions and procedures. If you’re using another database management system, this section will be useful for understanding concepts related to functions, but you’ll need to check your database’s documentation for specifics on its implementation of functions.</p>&#13;
<h3 id="h2-501065c17-0004">Creating the percent_change() Function</h3>&#13;
<p class="BodyFirst">A function processes data and returns a value. As an example, let’s write a function to simplify a staple of data analysis: calculating the percent change between two values. In <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>, you learned that we express the percent change formula this way:</p>&#13;
<pre><code>percent change = (New Number – Old Number) / Old Number</code></pre>&#13;
<p>Rather than writing that formula each time we need it, we can create a function called <code>percent_change()</code> that takes the new and old numbers as inputs and returns the result rounded to a user-specified number of decimal places. Let’s walk through the code in <a href="#listing17-11" id="listinganchor17-11">Listing 17-11</a> to see how to declare a simple function that uses SQL.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> CREATE OR REPLACE FUNCTION&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> percent_change(new_value numeric,&#13;
               old_value numeric,&#13;
               decimal_places integer <span class="CodeAnnotationCode" aria-label="annotation3">3</span>DEFAULT 1)&#13;
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> RETURNS numeric AS&#13;
<span class="CodeAnnotationHang" aria-label="annotation5">5</span> 'SELECT round(&#13;
       ((new_value - old_value) / old_value) * 100, decimal_places&#13;
);'&#13;
<span class="CodeAnnotationHang" aria-label="annotation6">6</span> LANGUAGE SQL&#13;
<span class="CodeAnnotationHang" aria-label="annotation7">7</span> IMMUTABLE&#13;
<span class="CodeAnnotationHang" aria-label="annotation8">8</span> RETURNS NULL ON NULL INPUT;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-11">Listing 17-11</a>: Creating a <code>percent_change()</code> function</p>&#13;
<p>A lot is happening in this code, but it’s not as complicated as it looks. We start with the command <code>CREATE OR REPLACE FUNCTION</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. As with the syntax to create a view, the <code>OR REPLACE</code> keywords are optional. We then give the name of the function <span class="CodeAnnotation" aria-label="annotation2">2</span> and, in parentheses, a list of <em>arguments</em> that determine the function’s inputs. Each argument will serve as an input to the function and gets a name and data type. For example, <code>new_value</code> and <code>old_value</code> are <code>numeric</code> and require that the user of the function supply input values matching that type, whereas <code>decimal_places</code> (which specifies the number of places to round results) is <code>integer</code>. For <code>decimal_places</code>, we specify <code>1</code> as the <code>DEFAULT</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> value—this <span epub:type="pagebreak" title="348" id="Page_348"/>makes the argument optional and, if it’s omitted by the user, will set the argument to <code>1</code> by default.</p>&#13;
<p>We then use the keywords <code>RETURNS numeric AS</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> to tell the function to return its calculation as type <code>numeric</code>. If this were a function to concatenate strings, we might return <code>text</code>.</p>&#13;
<p>Next, we write the meat of the function that performs the calculation. Inside single quotes, we place a <code>SELECT</code> query <span class="CodeAnnotation" aria-label="annotation5">5</span> that includes the percent change calculation nested inside a <code>round()</code> function. In the formula, we use the function’s argument names instead of numbers.</p>&#13;
<p>We then supply a series of keywords that define the function’s attributes and behavior. The <code>LANGUAGE</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> keyword specifies that we’ve written this function using plain SQL as opposed to one of other languages PostgreSQL supports for creating functions. Next, the <code>IMMUTABLE</code> keyword <span class="CodeAnnotation" aria-label="annotation7">7</span> indicates that the function cannot modify the database and will always return the same result for a given set of arguments. The line <code>RETURNS NULL ON NULL INPUT</code> <span class="CodeAnnotation" aria-label="annotation8">8</span> guarantees that the function will supply a <code>NULL</code> response if any input that is not supplied by default is a <code>NULL</code>.</p>&#13;
<p>Run the code using pgAdmin to create the <code>percent_change()</code> function. The server should respond with the message <code>CREATE FUNCTION</code>.</p>&#13;
<h3 id="h2-501065c17-0005">Using the percent_change() Function</h3>&#13;
<p class="BodyFirst">To test the new <code>percent_change()</code> function, run it by itself using <code>SELECT</code>, as shown in <a href="#listing17-12" id="listinganchor17-12">Listing 17-12</a>.</p>&#13;
<pre><code>SELECT percent_change(110, 108, 2);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-12">Listing 17-12</a>: Testing the <code>percent_change()</code> function</p>&#13;
<p>This example uses a value of <code>110</code> for the new number, <code>108</code> for the old number, and <code>2</code> as the desired number of decimal places to round the result.</p>&#13;
<p>Run the code; the result should look like this:</p>&#13;
<pre><code> percent_change&#13;
----------------&#13;
           1.85</code></pre>&#13;
<p>The result tells us there’s a 1.85 percent increase between 108 and 110. Experiment with other numbers to see how the results change. Also, try changing the <code>decimal_places</code> argument to values including <code>0</code>, or omit it, to see how that affects the output. You should see results that have more or fewer numbers after the decimal point, based on your input.</p>&#13;
<p>We created this function to avoid writing the full percent change formula in queries. Let’s use it to calculate percent change using a version of the census estimates population change query we wrote in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>, as shown in <a href="#listing17-13" id="listinganchor17-13">Listing 17-13</a>.</p>&#13;
<pre><code>SELECT c2019.county_name,&#13;
       c2019.state_name,&#13;
       c2019.pop_est_2019 AS pop_2019,&#13;
<span epub:type="pagebreak" title="349" id="Page_349"/>     <span class="CodeAnnotationCode" aria-label="annotation1">1</span> percent_change(c2019.pop_est_2019,&#13;
                      c2010.estimates_base_2010) AS pct_chg_func,&#13;
     <span class="CodeAnnotationCode" aria-label="annotation2">2</span> round( (c2019.pop_est_2019::numeric - c2010.estimates_base_2010)&#13;
           / c2010.estimates_base_2010 * 100, 1 ) AS pct_change_formula&#13;
FROM us_counties_pop_est_2019 AS c2019&#13;
    JOIN us_counties_pop_est_2010 AS c2010&#13;
ON c2019.state_fips = c2010.state_fips&#13;
   AND c2019.county_fips = c2010.county_fips&#13;
ORDER BY pct_chg_func DESC&#13;
LIMIT 5;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-13">Listing 17-13</a>: Testing <code>percent_change()</code> on census data</p>&#13;
<p><a href="#listing17-13">Listing 17-13</a> modifies the original query from <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span> to add the <code>percent_change()</code> function <span class="CodeAnnotation" aria-label="annotation1">1</span> as a column in <code>SELECT</code>. We also include the explicit percent change formula <span class="CodeAnnotation" aria-label="annotation2">2</span> so we can compare results. As inputs, we use the 2019 population estimate column (<code>c2019.pop_est_2019</code>) as the new number and the 2010 estimates base as the old (<code>c2010.estimates_base_2010</code>).</p>&#13;
<p>The query results should display the five counties with the greatest percent change in population, and the results from the function should match the results from the formula entered directly into the query. Note that each value in the <code>pct_chg_func</code> column has one decimal place, the function’s default value, because we didn’t provide the optional third argument. Here’s the result with both the function and the formula:</p>&#13;
<pre><code>  county_name    state_name  pop_2019 pct_chg_func pct_chg_formula&#13;
--------------- ------------ -------- ------------ ---------------&#13;
McKenzie County North Dakota    15024        136.3           136.3&#13;
Loving County   Texas             169        106.1           106.1&#13;
Williams County North Dakota    37589         67.8            67.8&#13;
Hays County     Texas          230191         46.5            46.5&#13;
Wasatch County  Utah            34091         44.9            44.9</code></pre>&#13;
<p>Now that we know the function works as intended, we can use <code>percent_change()</code> any time we need to solve that calculation—and that’s much faster than writing out the formula!</p>&#13;
<h3 id="h2-501065c17-0006">Updating Data with a Procedure</h3>&#13;
<p class="BodyFirst">As implemented in PostgreSQL, a <em>procedure</em> is a close relative of a function, albeit with some significant differences. Both procedures and functions can perform data operations that don’t return a value, such as an update. Procedures, on the other hand, don’t have a clause to return a value, while functions do. Also, procedures can incorporate the transaction commands we covered in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span> such as <code>COMMIT</code> and <code>ROLLBACK</code>, and functions cannot. Many database managers implement procedures, which are sometimes referred to as <em>stored procedures</em>. PostgreSQL added procedures as of version 11 and are part of the SQL standard, though PostgreSQL syntax is not fully compatible.</p>&#13;
<p>We can simplify routine updates to data using procedures. In this section, we’ll write a procedure that updates a record of the correct number of <span epub:type="pagebreak" title="350" id="Page_350"/>personal days off a teacher gets (in addition to vacation days) based on the time elapsed since their hire date.</p>&#13;
<p>For this exercise, we’ll return to the <code>teachers</code> table from the first lesson in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>. If you skipped “Creating a Table” in that chapter, create the <code>teachers</code> table and insert the data now using the example code in Listings 2-2 and 2-3.</p>&#13;
<p>Let’s add a column to <code>teachers</code> to hold the teachers’ personal days using the code in <a href="#listing17-14" id="listinganchor17-14">Listing 17-14</a>. The new column will be empty until we fill it later using a procedure.</p>&#13;
<pre><code>ALTER TABLE teachers ADD COLUMN personal_days integer;&#13;
&#13;
SELECT first_name,&#13;
       last_name,&#13;
       hire_date,&#13;
       personal_days&#13;
FROM teachers;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-14">Listing 17-14</a>: Adding a column to the <code>teachers</code> table and seeing the data</p>&#13;
<p><a href="#listing17-14">Listing 17-14</a> updates the teachers table using <code>ALTER</code> and adds the <code>personal_days</code> column using the keywords <code>ADD COLUMN</code>. We then run the <code>SELECT</code> statement to view the data, in which we also include the names and hire dates of each teacher. When both queries finish, you should see the following six rows:</p>&#13;
<pre><code>first_name last_name hire_date  personal_days&#13;
---------- --------- ---------- -------------&#13;
Janet      Smith     2011-10-30&#13;
Lee        Reynolds  1993-05-22&#13;
Samuel     Cole      2005-08-01&#13;
Samantha   Bush      2011-10-30&#13;
Betty      Diaz      2005-08-30&#13;
Kathleen   Roush     2010-10-22</code></pre>&#13;
<p>The <code>personal_days</code> column contains only <code>NULL</code> values because we haven’t inserted anything yet.</p>&#13;
<p>Now, let’s create a procedure called <code>update_personal_days()</code> that populates the <code>personal_days</code> column with their earned personal days (in addition to vacation days). We’ll use the following criteria:</p>&#13;
<ul>&#13;
<li>Less than 10 years since hire: 3 personal days</li>&#13;
<li>10 to less than 15 years since hire: 4 personal days</li>&#13;
<li>15 to less than 20 years since hire: 5 personal days</li>&#13;
<li>20 years to less than 25 years since hire: 6 personal days</li>&#13;
<li>25 years or more since hire: 7 personal days</li>&#13;
</ul>&#13;
<p>The code in <a href="#listing17-15" id="listinganchor17-15">Listing 17-15</a> creates a procedure. This time, instead of using plain SQL, we’ll incorporate elements of the PL/pgSQL procedural language, which is an additional language PostgreSQL supports for writing functions. Let’s walk through some differences.</p>&#13;
<pre><code><span epub:type="pagebreak" title="351" id="Page_351"/>CREATE OR REPLACE PROCEDURE update_personal_days()&#13;
AS <span class="CodeAnnotation" aria-label="annotation1">1</span>$$&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> BEGIN&#13;
    UPDATE teachers&#13;
    SET personal_days =&#13;
      <span class="CodeAnnotationCode" aria-label="annotation3">3</span> CASE WHEN (now() - hire_date) &gt;= '10 years'::interval&#13;
                  AND (now() - hire_date) &lt; '15 years'::interval THEN 4&#13;
             WHEN (now() - hire_date) &gt;= '15 years'::interval&#13;
                  AND (now() - hire_date) &lt; '20 years'::interval THEN 5&#13;
             WHEN (now() - hire_date) &gt;= '20 years'::interval&#13;
                  AND (now() - hire_date) &lt; '25 years'::interval THEN 6&#13;
             WHEN (now() - hire_date) &gt;= '25 years'::interval THEN 7&#13;
             ELSE 3&#13;
        END;&#13;
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> RAISE NOTICE 'personal_days updated!';&#13;
END;&#13;
<span class="CodeAnnotationHang" aria-label="annotation5">5</span> $$&#13;
<span class="CodeAnnotationHang" aria-label="annotation6">6</span> LANGUAGE plpgsql;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-15">Listing 17-15</a>: Creating an <code>update_personal_days()</code> function</p>&#13;
<p>We begin with <code>CREATE OR REPLACE PROCEDURE</code> and give the procedure a name. This time, we provide no arguments because no user input is required—the procedure operates on predetermined columns with set values for calculating intervals.</p>&#13;
<p>Often, when writing PL/pgSQL-based functions, the PostgreSQL convention is to use the non-ANSI SQL standard dollar-quote (<code>$$</code>) to mark the start <span class="CodeAnnotation" aria-label="annotation1">1</span> and end <span class="CodeAnnotation" aria-label="annotation5">5</span> of the string that contains all the function’s commands. (As with the <code>percent_change()</code> SQL function earlier, you could use single quote marks to enclose the string, but then any single quotes in the string would need to be doubled, and that not only looks messy but can be confusing.) So, everything between the pair of <code>$$</code> is the code that does the work. You can also add some text between the dollar signs, like <code>$namestring$</code>, to create a unique pair of beginning and ending quotes. This is useful, for example, if you need to quote a query inside the function.</p>&#13;
<p>Right after the first <code>$$</code> we start a <code>BEGIN ... END;</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> block. This is a PL/pgSQL convention that delineates the start and end of a section of code within a function or procedure; as with dollar quotes, it is possible to nest one <code>BEGIN ... END;</code> inside another to facilitate logical groupings of code. Inside that block, we place an <code>UPDATE</code> statement that uses a <code>CASE</code> statement <span class="CodeAnnotation" aria-label="annotation3">3</span> to determine the number of days each teacher gets. We subtract the <code>hire_date</code> from the current date, which is retrieved from the server by the <code>now()</code> function. Depending on which range <code>now() - hire_date</code> falls into, the <code>CASE</code> statement returns the number of personal days corresponding to the range. We use the PL/pgSQL keywords <code>RAISE NOTICE</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> to display a message that the procedure is done. Finally, we use the <code>LANGUAGE</code> keyword <span class="CodeAnnotation" aria-label="annotation6">6</span> so the database knows to interpret what we’ve written according to the syntax specific to PL/pgSQL.</p>&#13;
<p><span epub:type="pagebreak" title="352" id="Page_352"/>Run the code in <a href="#listing17-15">Listing 17-15</a> to create the <code>update_personal_days()</code> procedure. To invoke the procedure, we use the <code>CALL</code> command, which is part of the ANSI SQL standard:</p>&#13;
<pre><code>CALL update_personal_days();</code></pre>&#13;
<p>When the procedure runs, the server responds with the notice it raises, which is <code>personal_days updated!</code>.</p>&#13;
<p>When you rerun the <code>SELECT</code> statement in <a href="#listing17-14">Listing 17-14</a>, you should see that each row of the <code>personal_days</code> column is filled with the appropriate values. Note that results will vary depending on when you run this function, because calculations using <code>now()</code> change as time passes.</p>&#13;
<pre><code>first_name last_name hire_date  personal_days&#13;
---------- --------- ---------- -------------&#13;
Janet      Smith     2011-10-30             3&#13;
Lee        Reynolds  1993-05-22             7&#13;
Samuel     Cole      2005-08-01             5&#13;
Samantha   Bush      2011-10-30             3&#13;
Betty      Diaz      2005-08-30             5&#13;
Kathleen   Roush     2010-10-22             4</code></pre>&#13;
<p>You could use the <code>update_personal_days()</code> function to regularly update data manually after performing certain tasks, or you could use a task scheduler such as pgAgent (a separate open source tool) to run it automatically. You can learn about pgAgent and other tools in “PostgreSQL Utilities, Tools, and Extensions” in the appendix.</p>&#13;
<h3 id="h2-501065c17-0007">Using the Python Language in a Function</h3>&#13;
<p class="BodyFirst">Previously, I mentioned that PL/pgSQL is the default procedural language within PostgreSQL, but the database also supports creating functions using open source languages, such as Python and R. This support allows you to take advantage of features and modules from those languages within functions you create. For example, with Python, you can use the <code>pandas</code> library for analysis. The documentation at <a href="https://www.postgresql.org/docs/current/server-programming.html" class="LinkURL">https://www.postgresql.org/docs/current/server-programming.html</a> provides a comprehensive review of the languages included with PostgreSQL, but here I’ll show you a simple function using Python.</p>&#13;
<p>To enable PL/Python, you must create the extension using the code in <a href="#listing17-16" id="listinganchor17-16">Listing 17-16</a>. </p>&#13;
<pre><code>CREATE EXTENSION plpython3u;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-16">Listing 17-16</a>: Enabling the PL/Python procedural language</p>&#13;
<p>If you get an error, such as <code>image not found</code>, that means the PL/Python extension is not installed on your system. Depending on the operating system, installation of PL/Python typically requires installation of Python and <span epub:type="pagebreak" title="353" id="Page_353"/>additional configuration beyond the basic PostgreSQL install. For this, refer to the installation instructions for your operating system in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>.</p>&#13;
<p>After enabling the extension, we can create a function using syntax similar to the examples you’ve tried so far, but using Python for the body of the function. <a href="#listing17-17" id="listinganchor17-17">Listing 17-17</a> shows how to use PL/Python to create a function called <code>trim_county()</code> that removes the word <em>County</em> from the end of a string. We’ll use this function to clean up names of counties in the census data.</p>&#13;
<pre><code>CREATE OR REPLACE FUNCTION trim_county(input_string text)&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> RETURNS text AS $$&#13;
    import re<span class="CodeAnnotation" aria-label="annotation2">2</span>&#13;
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> cleaned = re.sub(r' County', '', input_string)&#13;
    return cleaned&#13;
$$&#13;
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> LANGUAGE plpython3u;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-17">Listing 17-17</a>: Using PL/Python to create the <code>trim_county()</code> function</p>&#13;
<p>The structure should look familiar. After naming the function and its text input, we use the <code>RETURNS</code> keyword <span class="CodeAnnotation" aria-label="annotation1">1</span> to specify that the function will send text back. After the opening <code>$$</code> quotes, we get straight to the Python code, starting with a statement to import the Python regular expressions module, <code>re</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>. Even if you don’t know much about Python, you can probably deduce that the next two lines of code <span class="CodeAnnotation" aria-label="annotation3">3</span> set a variable called <code>cleaned</code> to the results of a Python regular expression function called <code>sub()</code>. That function looks for a space followed by the word <em>County</em> in the <code>input_string</code> passed into the function and substitutes an empty string, which is denoted by two apostrophes. Then the function returns the content of the variable <code>cleaned</code>. To end, we specify <code>LANGUAGE plpython3u</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> to note we’re writing the function with PL/Python.</p>&#13;
<p>Run the code to create the function, and then execute the <code>SELECT</code> statement in <a href="#listing17-18" id="listinganchor17-18">Listing 17-18</a> to see it in action.</p>&#13;
<pre><code>SELECT county_name,&#13;
       trim_county(county_name)&#13;
FROM us_counties_pop_est_2019&#13;
ORDER BY state_fips, county_fips&#13;
LIMIT 5;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-18">Listing 17-18</a>: Testing the <code>trim_county()</code> function</p>&#13;
<p>We use the <code>county_name</code> column in the <code>us_counties_pop_est_2019</code> table as input to <code>trim_county()</code>. That should return these results:</p>&#13;
<pre><code>  county_name     trim_county&#13;
----------------  -------------&#13;
 Autauga County   Autauga&#13;
 Baldwin County   Baldwin&#13;
 Barbour County   Barbour&#13;
 Bibb County      Bibb&#13;
 Blount County    Blount</code></pre>&#13;
<p>As you can see, the <code>trim_county()</code> function evaluated each value in the <code>county_name</code> column and removed a space and the word <em>County</em> when present. <span epub:type="pagebreak" title="354" id="Page_354"/>Although this is a trivial example, it shows how easy it is to use Python—or one of the other supported procedural languages—inside a function.</p>&#13;
<p>Next, you’ll learn how to use triggers to automate your database.</p>&#13;
<h2 id="h1-501065c17-0003">Automating Database Actions with Triggers</h2>&#13;
<p class="BodyFirst">A database <em>trigger </em>executes a function whenever a specified event, such as an <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>, occurs on a table or a view. You can set a trigger to fire before, after, or instead of the event, and you can also set it to fire once for each row affected by the event or just once per operation. For example, let’s say you delete 20 rows from a table. You could set the trigger to fire once for each of the 20 rows deleted or just one time.</p>&#13;
<p>We’ll work through two examples. The first example keeps a log of changes made to grades at a school. The second automatically classifies temperatures each time we collect a reading.</p>&#13;
<h3 id="h2-501065c17-0008">Logging Grade Updates to a Table</h3>&#13;
<p class="BodyFirst">Let’s say we want to automatically track changes made to a student <code>grades</code> table in our school’s database. Every time a row is updated, we want to record the old and new grade plus the time the change occurred (search online for <em>David Lightman and grades</em> and you’ll see why this might be worth tracking). To handle this task automatically, we’ll need three items:</p>&#13;
<ul>&#13;
<li>A <code>grades_history</code> table to record the changes to grades in a <code>grades</code> table</li>&#13;
<li>A trigger to run a function every time a change occurs in the <code>grades</code> table, which we’ll name <code>grades_update</code></li>&#13;
<li>The function the trigger will execute, which we’ll call <code>record_if_grade_changed()</code></li>&#13;
</ul>&#13;
<h4 id="h3-501065c17-0005">Creating Tables to Track Grades and Updates</h4>&#13;
<p class="BodyFirst">Let’s start by making the tables we need. <a href="#listing17-19" id="listinganchor17-19">Listing 17-19</a> includes the code to first create and fill <code>grades</code> and then create <code>grades_history</code>.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> CREATE TABLE grades (&#13;
    student_id bigint,&#13;
    course_id bigint,&#13;
    course text NOT NULL,&#13;
    grade text NOT NULL,&#13;
PRIMARY KEY (student_id, course_id)&#13;
);&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> INSERT INTO grades&#13;
VALUES&#13;
    (1, 1, 'Biology 2', 'F'),&#13;
    (1, 2, 'English 11B', 'D'),&#13;
    (1, 3, 'World History 11B', 'C'),&#13;
    (1, 4, 'Trig 2', 'B');&#13;
&#13;
<span epub:type="pagebreak" title="355" id="Page_355"/><span class="CodeAnnotationHang" aria-label="annotation3">3</span> CREATE TABLE grades_history (&#13;
    student_id bigint NOT NULL,&#13;
    course_id bigint NOT NULL,&#13;
    change_time timestamp with time zone NOT NULL,&#13;
    course text NOT NULL,&#13;
    old_grade text NOT NULL,&#13;
    new_grade text NOT NULL,&#13;
PRIMARY KEY (student_id, course_id, change_time)&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-19">Listing 17-19</a>: Creating the <code>grades</code> and <code>grades_history</code> tables</p>&#13;
<p>These commands are straightforward. We use <code>CREATE</code> to make a <code>grades</code> table <span class="CodeAnnotation" aria-label="annotation1">1</span> and add four rows using <code>INSERT</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, where each row represents a student’s grade in a class. Then we use <code>CREATE TABLE</code> to make the <code>grades_history</code> table <span class="CodeAnnotation" aria-label="annotation3">3</span> to hold the data we log each time an existing grade is altered. The <code>grades_history</code> table has columns for the new grade, old grade, and the time of the change. Run the code to create the tables and fill the <code>grades</code> table. We insert no data into <code>grades_history</code> here because the trigger process will handle that task.</p>&#13;
<h4 id="h3-501065c17-0006">Creating the Function and Trigger</h4>&#13;
<p class="BodyFirst">Next, let’s write the <code>record_if_grade_changed()</code> function that the trigger will execute (note that the PostgreSQL documentation refers to such functions as <em>trigger procedures</em>). We must write the function before naming it in the trigger. Let’s go through the code in <a href="#listing17-20" id="listinganchor17-20">Listing 17-20</a>.</p>&#13;
<pre><code>CREATE OR REPLACE FUNCTION record_if_grade_changed()&#13;
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> RETURNS trigger AS&#13;
$$&#13;
BEGIN&#13;
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> IF NEW.grade &lt;&gt; OLD.grade THEN&#13;
    INSERT INTO grades_history (&#13;
        student_id,&#13;
        course_id,&#13;
        change_time,&#13;
        course,&#13;
        old_grade,&#13;
        new_grade)&#13;
    VALUES&#13;
        (OLD.student_id,&#13;
         OLD.course_id,&#13;
         now(),&#13;
         OLD.course,&#13;
       <span class="CodeAnnotationCode" aria-label="annotation3">3</span> OLD.grade,&#13;
       <span class="CodeAnnotationCode" aria-label="annotation4">4</span> NEW.grade);&#13;
    END IF;&#13;
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> RETURN NULL;&#13;
END;&#13;
$$ LANGUAGE plpgsql;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-20">Listing 17-20</a>: Creating the <code>record_if_grade_changed()</code> function</p>&#13;
<p><span epub:type="pagebreak" title="356" id="Page_356"/>The <code>record_if_grade_changed()</code> function follows the pattern of earlier examples but with differences specific to working with triggers. First, we specify <code>RETURNS trigger</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> instead of a data type. We use dollar-quotes to delineate the code portion of the function, and because <code>record_if_grade_changed()</code> is a PL/pgSQL function, we also place the code to execute inside a <code>BEGIN ... END;</code> block. Next, we start the procedure using an <code>IF ... THEN</code> statement <span class="CodeAnnotation" aria-label="annotation2">2</span>, which is one of the control structures PL/pgSQL provides. We use it here to run the <code>INSERT</code> statement only if the updated grade is different from the old grade, which we check using the <code>&lt;&gt;</code> operator.</p>&#13;
<p>When a change occurs to the <code>grades</code> table, the trigger (which we’ll create next) will execute. For each row that’s changed, the trigger will pass two collections of data into <code>record_if_grade_changed()</code>. The first is the row values <em>before</em> they were changed, noted with the prefix <code>OLD</code>. The second is the row values <em>after</em> they were changed, noted with the prefix <code>NEW</code>. The function can access the original row values and the updated row values, which it will use for a comparison. If the <code>IF ... THEN</code> statement evaluates as <code>true</code>, indicating that the old and new <code>grade</code> values are different, we use <code>INSERT</code> to add a row to <code>grades_history</code> that contains both <code>OLD.grade</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> and <code>NEW.grade</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>. Finally, we include a <code>RETURN</code> statement <span class="CodeAnnotation" aria-label="annotation5">5</span> with a value of <code>NULL</code>; the trigger procedure performs a database <code>INSERT</code>, so we do not need a value returned.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	Sometimes a <code>RETURN</code> value is ignored; the PostgreSQL documentation at <a href="https://www.postgresql.org/docs/current/plpgsql-trigger.html" class="LinkURL">https://www.postgresql.org/docs/current/plpgsql-trigger.html</a> details the scenarios in which this occurs.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>Run the code in <a href="#listing17-20">Listing 17-20</a> to create the function. Then, add the <code>grades_update</code> trigger to the <code>grades</code> table using <a href="#listing17-21" id="listinganchor17-21">Listing 17-21</a>.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> CREATE TRIGGER grades_update&#13;
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> AFTER UPDATE&#13;
  ON grades&#13;
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> FOR EACH ROW&#13;
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> EXECUTE PROCEDURE record_if_grade_changed();</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-21">Listing 17-21</a>: Creating the <code>grades_update</code> trigger</p>&#13;
<p>In PostgreSQL, the syntax for creating a trigger follows the ANSI SQL standard (although not all aspects of the standard are supported, per the documentation at <a href="https://www.postgresql.org/docs/current/sql-createtrigger.html" class="LinkURL">https://www.postgresql.org/docs/current/sql-createtrigger.html</a>). The code begins with a <code>CREATE TRIGGER</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> statement, followed by clauses that control when the trigger runs and how it behaves. We use <code>AFTER UPDATE</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> to specify that we want the trigger to fire after the update occurs on the <code>grades</code> row. We could also use the <code>BEFORE</code> or <code>INSTEAD OF</code> keywords depending on the need.</p>&#13;
<p>We write <code>FOR EACH ROW</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> to tell the trigger to execute the procedure once for each row updated in the table. For example, if someone runs an update that affects three rows, the procedure will run three times. The alternate (and default) is <code>FOR EACH STATEMENT</code>, which runs the procedure once. If we didn’t care about capturing changes to each row and simply wanted <span epub:type="pagebreak" title="357" id="Page_357"/>to record that grades were changed at a certain time, we could use that option. Finally, we use <code>EXECUTE PROCEDURE</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> to name <code>record_if_grade_changed()</code> as the function the trigger should run.</p>&#13;
<p>Create the trigger by running the code in <a href="#listing17-21">Listing 17-21</a> in pgAdmin. The database should respond with the message <code>CREATE TRIGGER</code>.</p>&#13;
<h4 id="h3-501065c17-0007">Testing the Trigger</h4>&#13;
<p class="BodyFirst">Now that we’ve created the trigger and the function, it should run when data in the <code>grades</code> table changes; let’s see what the process does. First, let’s check the current status of our data. When you run <code>SELECT * FROM grades_history;</code>, you’ll see that the table is empty because we haven’t made any changes to the <code>grades</code> table yet and there’s nothing to track. Next, when you run <code>SELECT * FROM grades ORDER BY student_id, course_id;</code>, you should see the grade data that you inserted in <a href="#listing17-19">Listing 17-19</a>, as shown here:</p>&#13;
<pre><code>student_id course_id      course       grade&#13;
---------- --------- ----------------- -----&#13;
         1         1 Biology 2         F&#13;
         1         2 English 11B       D&#13;
         1         3 World History 11B C&#13;
         1         4 Trig 2            B</code></pre>&#13;
<p>That Biology 2 grade doesn’t look very good. Let’s update it using the code in <a href="#listing17-22" id="listinganchor17-22">Listing 17-22</a>.</p>&#13;
<pre><code>UPDATE grades&#13;
SET grade = 'C'&#13;
WHERE student_id = 1 AND course_id = 1;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-22">Listing 17-22</a>: Testing the <code>grades_update</code> trigger</p>&#13;
<p>When you run the <code>UPDATE</code>, pgAdmin doesn’t display anything to let you know that the trigger executed in the background. It just reports <code>UPDATE 1</code>, meaning a row was updated. But our trigger did run, which we can confirm by examining columns in <code>grades_history</code> using this <code>SELECT</code> query:</p>&#13;
<pre><code>SELECT student_id,&#13;
       change_time,&#13;
       course,&#13;
       old_grade,&#13;
       new_grade&#13;
FROM grades_history;</code></pre>&#13;
<p>When you run this query, you should see that the <code>grades_history</code> table, which contains all changes to grades, now has one row:</p>&#13;
<pre><code>student_id          change_time           course      old_grade new_grade&#13;
---------- ----------------------------- ---------    --------- ---------&#13;
         1 2023-09-01 15:50:43.291164-04 Biology 2    F         C</code></pre>&#13;
<p><span epub:type="pagebreak" title="358" id="Page_358"/>This row displays the old Biology 2 grade of <code>F</code>, the new value <code>C</code>, and <code>change_time</code>, showing the time of update (your result should reflect your date and time). Note that the addition of this row to <code>grades_history</code> happened in the background without the knowledge of the person making the update. But the <code>UPDATE</code> event on the table caused the trigger to fire, which executed the <code>record_if_grade_changed()</code> function.</p>&#13;
<p>If you’ve ever used a content management system, such as WordPress or Drupal, this sort of revision tracking might be familiar. It provides a helpful record of changes made to content for reference, auditing, and, unfortunately, occasional finger-pointing. Regardless, the ability to trigger actions on a database automatically gives you more control over your data.</p>&#13;
<h3 id="h2-501065c17-0009">Automatically Classifying Temperatures</h3>&#13;
<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span>, we used the SQL <code>CASE</code> statement to reclassify temperature readings into descriptive categories. The <code>CASE</code> statement is also part of the PL/pgSQL procedural language, and we can use its capability to assign values to variables to automatically store those category names in a table each time we add a temperature reading. If we’re routinely collecting temperature readings, using this technique to automate the classification spares us from having to handle the task manually.</p>&#13;
<p>We’ll follow the same steps we used for logging the grade changes: we first create a function to classify the temperatures and then create a trigger to run the function each time the table is updated. Use <a href="#listing17-23" id="listinganchor17-23">Listing 17-23</a> to create a <code>temperature_test</code> table for the exercise.</p>&#13;
<pre><code>CREATE TABLE temperature_test (&#13;
    station_name text,&#13;
    observation_date date,&#13;
    max_temp integer,&#13;
    min_temp integer,&#13;
    max_temp_group text,&#13;
PRIMARY KEY (station_name, observation_date)&#13;
);</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-23">Listing 17-23</a>: Creating a <code>temperature_test</code> table</p>&#13;
<p>The <code>temperature_test</code> table contains columns to hold the name of the station and date of the temperature observation. Let’s imagine that we have some process to insert a row once a day that provides the maximum and minimum temperature for that location, and we need to fill the <code>max_temp_group</code> column with a descriptive classification of the day’s high reading to provide text to a weather forecast we’re distributing.</p>&#13;
<p>To do this, we first make a function called <code>classify_max_temp()</code>, as shown in <a href="#listing17-24" id="listinganchor17-24">Listing 17-24</a>.</p>&#13;
<pre><code>CREATE OR REPLACE FUNCTION classify_max_temp()&#13;
    RETURNS trigger AS&#13;
$$&#13;
<span epub:type="pagebreak" title="359" id="Page_359"/>BEGIN&#13;
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> CASE&#13;
       WHEN NEW.max_temp &gt;= 90 THEN&#13;
           NEW.max_temp_group := 'Hot';&#13;
       WHEN NEW.max_temp &gt;= 70 AND NEW.max_temp &lt; 90 THEN&#13;
           NEW.max_temp_group := 'Warm';&#13;
       WHEN NEW.max_temp &gt;= 50 AND NEW.max_temp &lt; 70 THEN&#13;
           NEW.max_temp_group := 'Pleasant';&#13;
       WHEN NEW.max_temp &gt;= 33 AND NEW.max_temp &lt; 50 THEN&#13;
           NEW.max_temp_group := 'Cold';&#13;
       WHEN NEW.max_temp &gt;= 20 AND NEW.max_temp &lt; 33 THEN&#13;
           NEW.max_temp_group := 'Frigid';&#13;
       WHEN NEW.max_temp &lt; 20 THEN&#13;
           NEW.max_temp_group := 'Inhumane';&#13;
       ELSE NEW.max_temp_group := 'No reading';&#13;
    END CASE;&#13;
    RETURN NEW;&#13;
END;&#13;
$$ LANGUAGE plpgsql;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-24">Listing 17-24</a>: Creating the <code>classify_max_temp()</code> function</p>&#13;
<p>By now, these functions should look familiar. What’s new here is the PL/pgSQL version of the <code>CASE</code> syntax <span class="CodeAnnotation" aria-label="annotation1">1</span>, which differs slightly from the SQL syntax. The PL/pgSQL syntax includes a semicolon after each <code>WHEN ... THEN</code> clause. Also new is the <em>assignment operator </em><code>:=</code>, which we use to assign the descriptive name to the <code>NEW.max_temp_group</code> column based on the outcome of the <code>CASE</code> function. For example, the statement <code>NEW.max_temp_group := 'Cold'</code> assigns the string <code>'Cold'</code> to <code>NEW.max_temp_group</code> when the temperature value is greater than or equal to 33 degrees but less than 50 degrees Fahrenheit. When the function returns the <code>NEW</code> row to be inserted in the table, it will include the string value <code>Cold</code>. Run the code to create the function.</p>&#13;
<p>Next, using the code in <a href="#listing17-25" id="listinganchor17-25">Listing 17-25</a>, create a trigger to execute the function each time a row is added to <code>temperature_test</code>.</p>&#13;
<pre><code>CREATE TRIGGER temperature_insert&#13;
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> BEFORE INSERT&#13;
    ON temperature_test&#13;
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> FOR EACH ROW&#13;
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> EXECUTE PROCEDURE classify_max_temp();</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-25">Listing 17-25</a>: Creating the <code>temperature_insert</code> trigger</p>&#13;
<p>In this example, we classify <code>max_temp</code> and create a value for <code>max_temp_group</code> prior to inserting the row into the table. Doing so is more efficient than performing a separate update after the row is inserted. To specify that behavior, we set the <code>temperature_insert</code> trigger to fire <code>BEFORE INSERT</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. </p>&#13;
<p>We also want the trigger to fire <code>FOR EACH ROW</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> because we want each <code>max_temp</code> recorded in the table to get a descriptive classification. The final <code>EXECUTE PROCEDURE</code> statement names the <code>classify_max_temp()</code> function <span class="CodeAnnotation" aria-label="annotation3">3</span> we just created. Run the <code>CREATE TRIGGER</code> statement in pgAdmin, and then test the setup using <a href="#listing17-26" id="listinganchor17-26">Listing 17-26</a>.</p>&#13;
<pre><code><span epub:type="pagebreak" title="360" id="Page_360"/>INSERT INTO temperature_test&#13;
VALUES&#13;
    ('North Station', '1/19/2023', 10, -3),&#13;
    ('North Station', '3/20/2023', 28, 19),&#13;
    ('North Station', '5/2/2023', 65, 42),&#13;
    ('North Station', '8/9/2023', 93, 74),&#13;
    ('North Station', '12/14/2023', NULL, NULL);&#13;
&#13;
SELECT * FROM temperature_test ORDER BY observation_date;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing17-26">Listing 17-26</a>: Inserting rows to test the <code>temperature_insert</code> trigger</p>&#13;
<p>Here we insert five rows into <code>temperature_test</code>, and we expect the <code>temperature_insert</code> trigger to fire for each row—and it does! The <code>SELECT</code> statement in the listing should display these results:</p>&#13;
<pre><code>station_name  observation_date max_temp min_temp max_temp_group&#13;
------------- ---------------- -------- -------- --------------&#13;
North Station 2023-01-19             10       -3 Inhumane&#13;
North Station 2023-03-20             28       19 Frigid&#13;
North Station 2023-05-02             65       42 Pleasant&#13;
North Station 2023-08-09             93       74 Hot&#13;
North Station 2023-12-14                         No reading</code></pre>&#13;
<p>Thanks to the trigger and function, each <code>max_temp</code> inserted automatically receives the appropriate classification in the <code>max_temp_group</code> column—including the instance where we had no reading for that value. Note that the trigger’s update of the column will override any user-supplied values during insert.</p>&#13;
<p>This temperature example and the earlier grade-change auditing example are rudimentary, but they give you a glimpse of how useful triggers and functions can be in simplifying data maintenance.</p>&#13;
<h2 id="h1-501065c17-0004">Wrapping Up</h2>&#13;
<p class="BodyFirst">Although the techniques you learned in this chapter begin to merge with those of a database administrator, you can apply the concepts to reduce the amount of time you spend repeating certain tasks. I hope these approaches will help you free up more time to find interesting stories in your data.</p>&#13;
<p>This chapter concludes our discussion of analysis techniques and the SQL language. The next two chapters offer workflow tips to help you increase your command of PostgreSQL. They include how to connect to a database and run queries from your computer’s command line and how to maintain your database.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" title="361" id="Page_361"/>Try It Yourself</h2>&#13;
<p class="BoxBodyFirst">Review the concepts in the chapter with these exercises:</p>&#13;
<ol>&#13;
<li value="1">Create a materialized view that displays the number of New York City taxi trips per hour. Use the taxi data from <span class="xref" itemid="xref_target_Chapter 12">Chapter 12</span> and the query in <a href="c12.xhtml#listing12-8" id="listinganchor12-8">Listing 12-8</a>. How do you refresh the view if you need to?</li>&#13;
<li value="2">In <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span>, you learned how to calculate a rate per thousand. Turn that formula into a <code>rate_per_thousand()</code> function that takes three arguments to calculate the result: <code>observed_number</code>, <code>base_number</code>, and <code>decimal_places</code>.</li>&#13;
<li value="3">In <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>, you worked with the <code>meat_poultry_egg_establishments</code> table that listed food processing facilities. Write a trigger that automatically adds an inspection deadline timestamp six months in the future whenever you insert a new facility into the table. Use the <code>inspection_deadline</code> column added in <a href="c10.xhtml#listing10-19" id="listinganchor10-19">Listing 10-19</a>. You should be able to describe the steps needed to implement a trigger and how the steps relate to each other.</li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div></body></html>