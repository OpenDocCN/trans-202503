["```\ninclude `filename`\n```", "```\ninclude  print.inc\ninclude  getTitle.inc\n```", "```\n ifndef  myinclude_inc   ; Filename: myinclude.inc\nmyinclude_inc =       0\n\n`Put all the source code lines for the include file here`\n\n; The following statement should be the last non-blank line\n; in the source file:\n\n              endif  ; myinclude_inc\n```", "```\n; Here is the \"asmMain\" function.\n\n        public  asmMain\nasmMain proc\n         .\n         .\n         .\nasmMain endp\n```", "```\n// extern \"C\" namespace prevents\n// \"name mangling\" by the C++\n// compiler.\n\nextern \"C\"\n{\n // asmMain is the assembly language\n    // code's \"main program\":\n\n    void asmMain(void);\n\n    // getTitle returns a pointer to a\n    // string of characters from the\n    // assembly code that specifies the\n    // title of that program (which makes\n    // this program generic and usable\n    // with a large number of sample\n    // programs in \"The Art of 64-Bit\n    // Assembly\").\n\n    char *getTitle(void);\n\n    // C++ function that the assembly\n    // language program can call:\n\n    int readLine(char *dest, int maxLen);\n\n};\n```", "```\nextern    `symbol`:`type`  {`optional_list_of_symbol:type_pairs`}\nexterndef `symbol`:`type`  {`optional_list_of_symbol:type_pairs`}\n```", "```\n public someLen\nsomeStr   byte   \"abcdefg\"\nsomeLen   =      $-someStr\n```", "```\nextern p:proc, b:byte, d:dword, a:abs\n```", "```\n; header.inc\n           ifndef   header_inc\nheader_inc =        0\n\n           extern  func1:proc\n           extern  func2:proc\n\n           endif   ; header_inc\n```", "```\n; func1.asm\n\n           include header.inc\n\n           .code\n\nfunc1      proc\n             .\n             .\n             .\n           call func2\n             .\n             .\n             .\nfunc1      endp\n           end\n```", "```\n; header.inc\n           ifndef     header_inc\nheader_inc =          0\n\n externdef  func1:proc\n           externdef  func2:proc\n\n           endif      ; header_inc\n```", "```\n; aoalib.inc - Header file containing external function\n;              definitions, constants, and other items used\n;              by code in \"The Art of 64-Bit Assembly.\"\n\n            ifndef      aoalib_inc\naoalib_inc  equ         0\n\n; Constant definitions:\n\n; nl (newline constant):\n\nnl          =           10\n\n; SSE4.2 feature flags (in ECX):\n\nSSE42       =       00180000h       ; Bits 19 and 20\nAVXSupport  =       10000000h       ; Bit 28\n\n; CPUID bits (EAX = 7, EBX register):\n\nAVX2Support  =      20h             ; Bit 5 = AVX\n\n**********************************************************\n\n; External data declarations:\n\n            externdef   ttlStr:byte\n\n**********************************************************\n\n; External function declarations:\n\n            externdef   print:qword\n            externdef   getTitle:proc\n\n; Definition of C/C++ printf function that\n; the print function will call (and some\n; AoA sample programs call this directly,\n; as well).\n\n            externdef   printf:proc\n\n            endif       ; aoalib_inc\n```", "```\n; print.asm - Assembly unit containing the SSE/AVX dynamically\n;             selectable print procedures.\n\n            include aoalib.inc\n\n            .data\n            align   qword\nprint       qword   choosePrint     ; Pointer to print function\n\n            .code\n\n; print - \"Quick\" form of printf that allows the format string to\n;         follow the call in the code stream. Supports up to five\n;         additional parameters in RDX, R8, R9, R10, and R11.\n\n; This function saves all the Microsoft ABIâ€“volatile,\n; parameter, and return result registers so that code\n; can call it without worrying about any registers being\n; modified (this code assumes that Windows ABI treats\n; YMM6 to YMM15 as nonvolatile).\n\n; Of course, this code assumes that AVX instructions are\n; available on the CPU.\n\n; Allows up to 5 arguments in:\n\n;  RDX - Arg #1\n;  R8  - Arg #2\n;  R9  - Arg #3\n;  R10 - Arg #4\n;  R11 - Arg #5\n\n; Note that you must pass floating-point values in\n; these registers as well. The printf function\n; expects real values in the integer registers. \n\n; There are two versions of this program, one that\n; will run on CPUs without AVX capabilities (no YMM\n; registers) and one that will run on CPUs that\n; have AVX capabilities (YMM registers). The difference\n; between the two is which registers they preserve\n; (print_SSE preserves only XMM registers and will\n; run properly on CPUs that don't have YMM register\n; support; print_AVX will preserve the volatile YMM\n; registers on CPUs with AVX support).\n\n; On first call, determine if we support AVX instructions\n; and set the \"print\" pointer to point at print_AVX or\n; print_SSE:\n\nchoosePrint proc\n            push    rax             ; Preserve registers that get\n            push    rbx             ; tweaked by CPUID\n            push    rcx\n            push    rdx\n\n            mov     eax, 1\n            cpuid\n            test    ecx, AVXSupport ; Test bit 28 for AVX\n            jnz     doAVXPrint\n\n            lea     rax, print_SSE  ; From now on, call\n            mov     print, rax      ; print_SSE directly\n\n; Return address must point at the format string\n; following the call to this function! So we have\n; to clean up the stack and JMP to print_SSE.\n\n            pop     rdx\n            pop     rcx\n            pop     rbx\n            pop     rax\n            jmp     print_SSE\n\ndoAVXPrint: lea     rax, print_AVX  ; From now on, call\n            mov     print, rax      ; print_AVX directly\n\n; Return address must point at the format string\n; following the call to this function! So we have\n; to clean up the stack and JMP to print_AUX.\n\n            pop     rdx\n            pop     rcx\n            pop     rbx\n            pop     rax\n            jmp     print_AVX\n\nchoosePrint endp\n\n; Version of print that will preserve volatile\n; AVX registers (YMM0 to YMM3):\n\nthestr      byte \"YMM4:%I64x\", nl, 0\nprint_AVX   proc\n\n; Preserve all the volatile registers\n; (be nice to the assembly code that\n; calls this procedure):\n\n            push    rax\n            push    rbx\n            push    rcx\n            push    rdx\n            push    r8\n            push    r9\n            push    r10\n            push    r11\n\n; YMM0 to YMM7 are considered volatile, so preserve them:\n\n            sub     rsp, 256\n            vmovdqu ymmword ptr [rsp + 000], ymm0\n            vmovdqu ymmword ptr [rsp + 032], ymm1\n            vmovdqu ymmword ptr [rsp + 064], ymm2\n            vmovdqu ymmword ptr [rsp + 096], ymm3\n            vmovdqu ymmword ptr [rsp + 128], ymm4\n            vmovdqu ymmword ptr [rsp + 160], ymm5\n            vmovdqu ymmword ptr [rsp + 192], ymm6\n            vmovdqu ymmword ptr [rsp + 224], ymm7\n\n            push    rbp\n\nreturnAdrs  textequ <[rbp + 328]>\n\n            mov     rbp, rsp\n            sub     rsp, 256\n            and     rsp, -16\n\n; Format string (passed in RCX) is sitting at\n; the location pointed at by the return address;\n; load that into RCX:\n\n            mov     rcx, returnAdrs\n\n; To handle more than three arguments (four counting\n; RCX), you must pass data on stack. However, to the\n; print caller, the stack is unavailable, so use\n; R10 and R11 as extra parameters (could be just\n; junk in these registers, but pass them just\n; in case).\n\n mov     [rsp + 32], r10\n            mov     [rsp + 40], r11\n            call    printf\n\n; Need to modify the return address so\n; that it points beyond the zero-terminating byte.\n; Could use a fast strlen function for this, but\n; printf is so slow it won't really save us anything.\n\n            mov     rcx, returnAdrs\n            dec     rcx\nskipTo0:    inc     rcx\n            cmp     byte ptr [rcx], 0\n            jne     skipTo0\n            inc     rcx\n            mov     returnAdrs, rcx\n\n            leave\n            vmovdqu ymm0, ymmword ptr [rsp + 000]\n            vmovdqu ymm1, ymmword ptr [rsp + 032]\n            vmovdqu ymm2, ymmword ptr [rsp + 064]\n            vmovdqu ymm3, ymmword ptr [rsp + 096]\n            vmovdqu ymm4, ymmword ptr [rsp + 128]\n            vmovdqu ymm5, ymmword ptr [rsp + 160]\n            vmovdqu ymm6, ymmword ptr [rsp + 192]\n            vmovdqu ymm7, ymmword ptr [rsp + 224]\n            add     rsp, 256\n            pop     r11\n            pop     r10\n            pop     r9\n            pop     r8\n            pop     rdx\n            pop     rcx\n            pop     rbx\n            pop     rax\n            ret\nprint_AVX   endp\n\n; Version that will run on CPUs without\n; AVX support and will preserve the\n; volatile SSE registers (XMM0 to XMM3):\n\nprint_SSE   proc\n\n; Preserve all the volatile registers\n; (be nice to the assembly code that\n; calls this procedure):\n\n            push    rax\n            push    rbx\n            push    rcx\n            push    rdx\n            push    r8\n            push    r9\n push    r10\n            push    r11\n\n; XMM0 to XMM3 are considered volatile, so preserve them:\n\n            sub     rsp, 128\n            movdqu  xmmword ptr [rsp + 00],  xmm0\n            movdqu  xmmword ptr [rsp + 16],  xmm1\n            movdqu  xmmword ptr [rsp + 32],  xmm2\n            movdqu  xmmword ptr [rsp + 48],  xmm3\n            movdqu  xmmword ptr [rsp + 64],  xmm4\n            movdqu  xmmword ptr [rsp + 80],  xmm5\n            movdqu  xmmword ptr [rsp + 96],  xmm6\n            movdqu  xmmword ptr [rsp + 112], xmm7\n\n            push    rbp\n\nreturnAdrs  textequ <[rbp + 200]>\n\n            mov     rbp, rsp\n            sub     rsp, 128\n            and     rsp, -16\n\n; Format string (passed in RCX) is sitting at\n; the location pointed at by the return address;\n; load that into RCX:\n\n            mov     rcx, returnAdrs\n\n; To handle more than three arguments (four counting\n; RCX), you must pass data on stack. However, to the\n; print caller, the stack is unavailable, so use\n; R10 and R11 as extra parameters (could be just\n; junk in these registers, but pass them just\n; in case):\n\n            mov     [rsp + 32], r10\n            mov     [rsp + 40], r11\n            call    printf\n\n; Need to modify the return address so\n; that it points beyond the zero-terminating byte.\n; Could use a fast strlen function for this, but\n; printf is so slow it won't really save us anything.\n\n            mov     rcx, returnAdrs\n            dec     rcx\nskipTo0:    inc     rcx\n            cmp     byte ptr [rcx], 0\n            jne     skipTo0\n            inc     rcx\n            mov     returnAdrs, rcx\n\n            leave\n movdqu  xmm0, xmmword ptr [rsp + 00] \n            movdqu  xmm1, xmmword ptr [rsp + 16] \n            movdqu  xmm2, xmmword ptr [rsp + 32] \n            movdqu  xmm3, xmmword ptr [rsp + 48] \n            movdqu  xmm4, xmmword ptr [rsp + 64] \n            movdqu  xmm5, xmmword ptr [rsp + 80] \n            movdqu  xmm6, xmmword ptr [rsp + 96] \n            movdqu  xmm7, xmmword ptr [rsp + 112] \n            add     rsp, 128\n            pop     r11\n            pop     r10\n            pop     r9\n            pop     r8\n            pop     rdx\n            pop     rcx\n            pop     rbx\n            pop     rax\n            ret\nprint_SSE   endp            \n            end\n```", "```\n; getTitle.asm - The getTitle function converted to\n;                an assembly unit.\n\n; Return program title to C++ program:\n\n            include aoalib.inc\n\n            .code\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n            end\n```", "```\n; Listing 15-4\n\n; Demonstration of linking.\n\n            include aoalib.inc\n\n            .data\nttlStr      byte    \"Listing 15-4\", 0\n\n***************************************************************\n\n; Here is the \"asmMain\" function.\n\n            .code\n            public  asmMain\nasmMain     proc\n            push    rbx\n            push    rsi\n            push    rdi\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 56         ; Shadow storage\n\n            call    print\n            byte    \"Assembly units linked\", nl, 0\n\n            leave\n            pop     rdi\n            pop     rsi\n            pop     rbx\n            ret     ; Returns to caller\nasmMain     endp\n            end\n```", "```\nml64 /c print.asm getTitle.asm listing15-4.asm\ncl /EHa c.cpp print.obj getTitle.obj listing15-4.obj\n```", "```\nml64 /c print.asm\nml64 /c getTitle.asm\nml64 /c listing15-4.asm\ncl /EHa c.cpp print.obj getTitle.obj listing15-4.obj\n```", "```\nml64 /c listing15-4.asm\ncl /EHa c.cpp print.obj getTitle.obj listing15-4.obj\n```", "```\nnmake `optional_arguments`\n```", "```\nnmake /f mymake.mak\n```", "```\n`target`: `dependencies`\n    `commands`\n```", "```\nc.exe:\n  ml64 /c print.asm\n  ml64 /c getTitle.asm\n  ml64 /c listing15-4.asm\n  cl /EHa c.cpp print.obj getTitle.obj listing15-4.obj\n```", "```\nexecutable:\n  ml64 /c listing15-4.asm\n  cl /EHa c.cpp print.obj getTitle.obj listing15-4.obj\n\nlibrary:\n  ml64 /c print.asm\n  ml64 /c getTitle.asm\n```", "```\nnmake library\n```", "```\n`target`: `dependency1` `dependency2` `dependency3` ...\n```", "```\nexecutable:\n  ml64 /c listing15-4.asm\n  cl /EHa c.cpp print.obj getTitle.obj listing15-4.obj\n\nlibrary:\n  ml64 /c print.asm\n  ml64 /c getTitle.asm\n\nall: library executable\n```", "```\nexecutable:\n  ml64 /c listing15-4.asm\n  cl /EHa c.cpp print.obj getTitle.obj listing15-4.obj\n\nlibrary: print.obj getTitle.obj\n\nprint.obj:\n  ml64 /c print.asm\n\ngetTitle.obj:\n  ml64 /c getTitle.asm\n\nall: library executable\n```", "```\nc.exe: print.obj getTitle.obj listing15-4.obj\n  cl /EHa c.cpp print.obj getTitle.obj listing15-4.obj\n\nlisting15-4.obj: listing15-4.asm\n  ml64 /c listing15-4.asm\n\nprint.obj: print.asm\n  ml64 /c print.asm\n\ngetTitle.obj: getTitle.asm\n  ml64 /c getTitle.asm\n```", "```\n# listing15-5.mak\n\n# makefile for Listing 15-4.\n\nlisting15-4.exe:print.obj getTitle.obj listing15-4.obj\n    cl /nologo /O2 /Zi /utf-8 /EHa /Felisting15-4.exe c.cpp \\\n            print.obj getTitle.obj listing15-4.obj\n\nlisting15-4.obj: listing15-4.asm aoalib.inc\n  ml64 /nologo /c listing15-4.asm\n\nprint.obj: print.asm aoalib.inc\n  ml64 /nologo /c print.asm\n\ngetTitle.obj: getTitle.asm aoalib.inc\n  ml64 /nologo /c getTitle.asm\n```", "```\nC:\\>**nmake /f listing15-5.mak**\n\nMicrosoft (R) Program Maintenance Utility Version 14.15.26730.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\n ml64 /nologo /c print.asm\n Assembling: print.asm\n        ml64 /nologo /c getTitle.asm\n Assembling: getTitle.asm\n        ml64 /nologo /c listing15-4.asm\n Assembling: listing15-4.asm\n        cl /nologo /O2 /Zi /utf-8 /EHa /Felisting15-4.exe c.cpp  print.obj getTitle.obj listing15-4.obj\nc.cpp\n\nC:\\>**listing15-4**\nCalling Listing 15-4:\nAssembly units linked\nListing 15-4 terminated\n```", "```\n# listing15-6.mak\n\n# makefile for Listing 15-4.\n\nlisting15-4.exe:print.obj getTitle.obj listing15-4.obj\n    cl /nologo /O2 /Zi /utf-8 /EHa /Felisting15-4.exe c.cpp \\\n            print.obj getTitle.obj listing15-4.obj\n\nlisting15-4.obj: listing15-4.asm aoalib.inc\n    ml64 /nologo /c listing15-4.asm\n\nprint.obj: print.asm aoalib.inc\n    ml64 /nologo /c print.asm\n\ngetTitle.obj: getTitle.asm aoalib.inc\n    ml64 /nologo /c getTitle.asm\n\nclean:\n    del getTitle.obj\n    del print.obj\n    del listing15-4.obj\n    del c.obj\n    del listing15-4.ilk\n    del listing15-4.pdb\n    del vc140.pdb\n    del listing15-4.exe\n\n# Alternative clean (if you like living dangerously):\n\n# clean:\n#   del *.obj\n#   del *.ilk\n#   del *.pdb\n#   del *.exe\n```", "```\nC:\\>**nmake /f listing15-6.mak clean**\n\nMicrosoft (R) Program Maintenance Utility Version 14.15.26730.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\n        del getTitle.obj\n        del print.obj\n        del listing15-4.obj\n        del c.obj\n        del listing15-4.ilk\n        del listing15-4.pdb\n        del listing15-4.exe\n\nC:\\>**nmake /f listing15-6.mak**\n\nMicrosoft (R) Program Maintenance Utility Version 14.15.26730.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\n        ml64 /nologo /c print.asm\n Assembling: print.asm\n        ml64 /nologo /c getTitle.asm\n Assembling: getTitle.asm\n        ml64 /nologo /c listing15-4.asm\n Assembling: listing15-4.asm\n        cl /nologo /O2 /Zi /utf-8 /EHa /Felisting15-4.exe c.cpp\n           print.obj getTitle.obj listing15-4.obj\nc.cpp\n```", "```\ntouch listing15-4.asm\n```", "```\nlib /out:`libname.lib` `list_of_.obj_files`\n```", "```\nlib /out:aoalib.lib getTitle.obj print.obj\n```", "```\ncl /EHa /Felisting15-4.exe c.cpp listing15-4.obj aoalib.lib\n```", "```\nlib /?\n```", "```\nlib /list `lib_filename.lib`\n```", "```\nC:\\>**lib /list aoalib.lib**\nMicrosoft (R) Library Manager Version 14.15.26730.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\ngetTitle.obj\nprint.obj\n```", "```\nincludelib `lib_filename.lib`\n```"]