["```\nstruct EntityIdentifier {\n    namespace: String,\n    name: String,\n}\n```", "```\nstruct EntityIdentifier<'a> {\n    namespace: Cow<'a, str>,\n    name: Cow<'a str>,\n}\n```", "```` `Instant::elapsed` returns the `Duration` since an `Instant` was created. This is much more concise than the common approach of creating a new `Instant` and subtracting the earlier instance.    `Option::as_deref` takes an `Option<P>` where `P: Deref` and returns `Option<&P::Target>` (there’s also an `as_deref_mut` method). This simple operation can make functional transformation chains that operate on `Option` much cleaner by avoiding the inscrutable `.as_ref().map(|r| &**r)`.    `Ord::clamp` lets you take any type that implements `Ord` and clamp it between two other values of a given range. That is, given a lower limit `min` and an upper limit `max`, `x.clamp(min, max)` returns `min` if `x` is less than `min`, `max` if `x` is greater than `max`, and `x` otherwise.    `Result::transpose` and its counterpart `Option::transpose` invert types that nest `Result` and `Option`. That is, transposing a `Result<Option<T>, E>` gives an `Option<Result<T, E>>`, and vice versa. When combined with `?`, this operation can make for cleaner code when working with `Iterator::next` and similar methods in fallible contexts.    `Vec::swap_remove` is `Vec::remove`’s faster twin. `Vec::remove` preserves the order of the vector, which means that to remove an element in the middle, it must shift all the later elements in the vector down by one. This can be very slow for large vectors. `Vec::swap_remove`, on the other hand, swaps the to-be-removed element with the last element and then truncates the vector’s length by one, which is a constant-time operation. Be aware, though, that it will shuffle your vector around and thus invalidate old indexes!    ## Patterns in the Wild    As you start exploring codebases that aren’t your own, you’ll likely come across a couple of common Rust patterns that we haven’t discussed in the book so far. Knowing about them will make it easier to recognize them, and thus understand their purpose, when you do encounter them. You may even find use for them in your own codebase one day!    ### Index Pointers    Index pointers allow you to store multiple references to data within a data structure without running afoul of the borrow checker. For example, if you want to store a collection of data so that it can be efficiently accessed in more than one way, such as by keeping one `HashMap` keyed by one field and one keyed by a different field, you don’t want to store the underlying data multiple times too. You could use `Arc` or `Rc`, but they use dynamic reference counting that introduces unnecessary overhead, and the extra bookkeeping requires you to store additional bytes per entry. You could use references, but the lifetimes become difficult if not impossible to manage because the data and the references live in the same data structure (it’s a self-referential data structure, as we discussed in Chapter 8). You could use raw pointers combined with `Pin` to ensure the pointers remain valid, but that introduces a lot of complexity as well as unsafety you then need to carefully consider.    Most crates use index pointers—or, as I like to call them, *indeferences*—instead. The idea is simple: store each data entry in some indexable data structure like a `Vec`, and then store just the index in a derived data structure. To then perform an operation, first use the derived data structure to efficiently find the data index, and then use the index to retrieve the referenced data. No lifetimes needed—and you can even have cycles in the derived data representation if you wish!    The `indexmap` crate, which provides a `HashMap` implementation where the iteration order matches the map insertion order, provides a good example of this pattern. The implementation has to store the keys in two places, both in the map of keys to values and in the list of all the keys, but it obviously doesn’t want to keep two copies in case the key type itself is large. So, it uses index pointers. Specifically, it keeps all the key/value pairs in a single `Vec` and then keeps a mapping from key hashes to `Vec` indexes. To iterate over all the elements of the map, it just walks the `Vec`. To look up a given key, it hashes that key, looks that hash up in the mapping, which yields the key’s index in the `Vec` (the index pointer), and then uses that to get the key’s value from the `Vec`.    The `petgraph` crate, which implements graph data structures and algorithms, also uses this pattern. The crate stores one `Vec` of all node values and another of all edge values and then only ever uses the indexes into those `Vec`s to refer to a node or edge. So, for example, the two nodes associated with an edge are stored in that edge simply as two `u32`s, rather than as references or reference-counted values.    The trick lies in how you support deletions. To delete a data entry, you first need to search for its index in all of the derived data structures and remove the corresponding entries, and then you need to remove the data from the root data store. If the root data store is a `Vec`, removing the entry will also change the index of one other data entry (when using `swap_remove`), so you then need to go update all the derived data structures to reflect the new index for the entry that moved.    ### Drop Guards    Drop guards provide a simple but reliable way to ensure that a bit of code runs even in the presence of panics, which is often essential in unsafe code. An example is a function that takes a closure `f: FnOnce` and executes it under mutual exclusion using atomics. Say the function uses `compare_exchange` (discussed in Chapter 10) to set a Boolean from `false` to `true`, calls `f`, and then sets the Boolean back to `false` to end the mutual exclusion. But consider what happens if `f` panics—the function will never get to run its cleanup, and no other call will be able to enter the mutual exclusion section ever again.    It’s possible to work around this using `catch_unwind`, but drop guards provide an alternative that is often more ergonomic. [Listing 13-3](#listing13-3) shows how, in our current example, we can use a drop guard to ensure the Boolean always gets reset.    ``` fn mutex(lock: &AtomicBool, f: impl FnOnce()) {     // .. while lock.compare_exchange(false, true).is_err() ..     struct DropGuard<'a>(&'a AtomicBool);     impl Drop for DropGuard<'_> {         fn drop(&mut self) {             self.0.store(true, Ordering::Release);         }     }     let _guard = DropGuard(lock);     f(); } ```    Listing 13-3: Using a drop guard to ensure code gets run after an unwinding panic    We introduce the local type `DropGuard` that implements `Drop` and place the cleanup code in its implementation of `Drop::drop`. Any necessary state can be passed in through the fields of `DropGuard`. Then, we construct an instance of the guard type just before we call the function that might panic, which is `f` here. When `f` returns, whether due to a panic or because it returns normally, the guard is dropped, its destructor runs, the lock is released, and all is well.    It’s important that the guard is assigned to a variable that is dropped at the end of the scope, after the user-provided code has been executed. This means that even though we never refer to the guard’s variable again, it needs to be given a name, as `let _ = DropGuard(lock)` would drop the guard immediately—before the user-provided code even runs!    This pattern is frequently used in conjunction with thread locals, when library code may wish to set the thread local state so that it’s valid only for the duration of the execution of the closure, and thus needs to be cleared afterwards. For example, at the time of writing, Tokio uses this pattern to provide information about the executor calling `Future::poll` to leaf resources like `TcpStream` without having to propagate that information through function signatures that are visible to users. It’d be no good if the thread local state continued to indicate that a particular executor thread was active even after `Future::poll` returned due to a panic, so Tokio uses a drop guard to ensure that the thread local state is reset.    ### Extension Traits    Extension traits allow crates to provide additional functionality to types that implement a trait from a different crate. For example, the `itertools` crate provides an extension trait for `Iterator`, which adds a number of convenient shortcuts for common (and not so common) iterator operations. As another example, `tower` provides `ServiceExt`, which adds several more ergonomic operations to wrap the low-level interface in the `Service` trait from `tower-service`.    Extension traits tend to be useful either when you do not control the base trait, as with `Iterator`, or when the base trait lives in a crate of its own so that it rarely sees breaking releases and thus doesn’t cause unnecessary ecosystem splits, as with `Service`.    An extension trait extends the base trait it is an extension of (`trait ServiceExt: Service`) and consists solely of provided methods. It also comes with a blanket implementation for any `T` that implements the base trait (`impl<T> ServiceExt for T where T: Service {}`). Together, these conditions ensure that the extension trait’s methods are available on anything that implements the base trait.    ### Crate Preludes    In Chapter 12, we talked about the standard library prelude that makes a number of types and traits automatically available without you having to write any `use` statements. Along similar lines, crates that export multiple types, traits, or functions that you’ll often use together sometimes define their own prelude in the form of a module called `prelude`, which re-exports some particularly common subset of those types, traits, and functions. There’s nothing magical about that module name, and it doesn’t get used automatically, but it serves as a signal to users that they likely want to add `use` `somecrate``::prelude::*` to files that want to use the crate in question. The `*` is a *glob import* and tells Rust to use all publicly available items from the indicated module. This can save quite a bit of typing when the crate has a lot of items you’ll usually need to name.    Preludes are also great for crates that expose a lot of extension traits, since trait methods can be called only if the trait that defines them is in scope. For example, the `diesel` crate, which provides ergonomic access to relational databases, makes extensive use of extension traits so you can write code like:    ``` posts.filter(published.eq(true)).limit(5).load::<Post>(&connection) ```    This line will work only if all the right traits are in scope, which the prelude takes care of.    In general, you should be careful when adding glob imports to your code, as they can potentially turn additions to the indicated module into backward-incompatible changes. For example, if someone adds a new trait to a module you glob-import from, and that new trait makes a method `foo` available on a type that already had some other `foo` method, code that calls `foo` on that type will no longer compile as the call to `foo` is now ambiguous. Interestingly enough, while the existence of glob imports makes any module addition a technically breaking change, the Rust RFC on API evolution (RFC 1105; see [https://rust-lang.github.io/rfcs/1105-api-evolution.html](https://rust-lang.github.io/rfcs/1105-api-evolution.html)) does *not* require a library to issue a new major version for such a change. The RFC goes into great detail about why, and I recommend you read it, but the gist is that minor releases are allowed to require minimally invasive changes to dependents, like having to add type annotations in edge cases, because otherwise a large fraction of changes would require new major versions despite being very unlikely to actually break any consumers.    Specifically in the case of preludes, using glob imports is usually fine when recommended by the vending crate, since its maintainers know that their users will use glob imports for the prelude module and thus will take that into account when deciding whether a change requires a major version bump.    ## Staying Up to Date    Rust, being such a young language, is evolving rapidly. The language itself, the standard library, the tooling, and the broader ecosystem are all still in their infancy, and new developments happen every day. While staying on top of all the changes would be infeasible, it’s worth your time to keep up with significant developments so that you can take advantage of the latest and greatest features in your projects.    For monitoring improvements to Rust itself, including new language features, standard library additions, and core tooling upgrades, the official Rust blog at [https://blog.rust-lang.org/](https://blog.rust-lang.org/)is a good, low-volume place to start. It mainly features announcements for each new Rust release. I recommend you make a habit of reading these, as they tend to include interesting tidbits that will slowly but surely deepen your knowledge of the language. To dig a little deeper, I highly recommend reading the detailed changelogs for Rust and Cargo as well (links can usually be found near the bottom of each release announcement). The changelogs surface changes that weren’t large enough to warrant a paragraph in the release notes but that may be just what you need two weeks from now. For a less frequently updated news source, check in on *The Edition Guide* at [https://doc.rust-lang.org/edition-guide/](https://doc.rust-lang.org/edition-guide/), which outlines what’s new in each Rust edition. Rust editions tend to be released every three years.    If you’re curious about how Rust itself is developed, you may also want to subscribe to the *Inside Rust* blog at[https://blog.rust-lang.org/inside-rust/](https://blog.rust-lang.org/inside-rust/). It includes updates from the various Rust teams, as well as incident reports, larger change proposals, edition planning information, and the like. To get involved in Rust development yourself—which I highly encourage, as it’s a lot of fun and a great learning experience—you can check out the various Rust working groups at [https://www.rust-lang.org/governance/](https://www.rust-lang.org/governance/), which each focus on improving a specific aspect of Rust. Find one that appeals to you, check in with the group wherever it meets and ask how you may be able to help. You can also join the community discussion about Rust internals over at [https://internals.rust-lang.org/](https://internals.rust-lang.org/); this is another great way to get insight into the thought that goes into every part of Rust’s design and development.    As is the case for most programming languages, much of Rust’s value is derived from its community. Not only do the members of the Rust community constantly develop new work-saving crates and discover new Rust-specific techniques and design patterns, but they also collectively and continuously help one another understand, document, and explain how to take best advantage of the Rust language. Everything I have covered in this book, and much more, has already been discussed by the community in thousands of comment threads, blog posts, and Twitter and Discord conversations. Dipping into these discussions even just once in a while is almost guaranteed to show you new things about a language feature, a technique, or a crate that you didn’t already know.    The Rust community lives in a lot of places, but some good places to start are the Users forum ([https://users.rust-lang.org/](https://users.rust-lang.org/)), the Rust subreddit ([https://www.reddit.com/r/rust/](https://www.reddit.com/r/rust/)), the Rust Community Discord ([https://discord.gg/rust-lang-community](https://discord.gg/rust-lang-community)), and the Rust Twitter account ([https://twitter.com/rustlang](https://twitter.com/rustlang)). You don’t have to engage with all of these, or all of the time—pick one you like the vibe of, and check in occasionally!    A great single location for staying up to date with ongoing developments is the *This Week in Rust* blog ([https://this-week-in-rust.org/](https://this-week-in-rust.org/)), a “weekly summary of [Rust’s] progress and community.” It links to official announcements and changelogs as well as popular community discussions and resources, interesting new crates, opportunities for contributions, upcoming Rust events, and Rust job opportunities. It even lists interesting language RFCs and compiler PRs, so this site truly has it all! Discerning what information is valuable to you and what isn’t may be a little daunting, but even just scrolling through and clicking occasional links that appear interesting is a good way to keep a steady stream of new Rust knowledge trickling into your brain.    ## What Next?    So, you’ve read this book front to back, absorbed all the knowledge it imparts, and are still hungry for more? Great! There are a number of other excellent resources out there for broadening and deepening your knowledge and understanding of Rust, and in this very final section I’ll give you a survey of some of my favorites so that you can keep learning. I’ve divided them into subsections based on how different people prefer to learn so that you can find resources that’ll work for you.    ### Learn by Watching    Watching experienced developers code is essentially a life hack to remedy the slow starting phase of solo learning. It allows you to observe the process of designing and building while utilizing someone else’s experience. Listening to experienced developers articulate their thinking and explain tricky concepts or techniques as they come up can be an excellent alternative to struggling through problems on your own. You’ll also pick up a variety of auxiliary knowledge like debugging techniques, design patterns, and best practices. Eventually you will have to sit down and do things yourself—it’s the only way to check that you actually understand what you’ve observed—but piggybacking on the experience of others will almost certainly make the early stages more pleasant. And if the experience is interactive, that’s even better!    So, with that said, here are some Rust video channels that I recommend:    1.  Perhaps unsurprisingly, my own channel:[https://www.youtube.com/c/JonGjengset/](https://www.youtube.com/c/JonGjengset/). I have a mix of long-form coding videos and short(er) code-based theory/concept explanation videos, as well as occasional videos that dive into interesting Rust coding stories. 2.  The *Awesome Rust Streaming* listing: [https://github.com/jamesmunns/awesome-rust-streaming/](https://github.com/jamesmunns/awesome-rust-streaming/). This resource lists a wide variety of developers who stream Rust coding or other Rust content. 3.  The channel of Tim McNamara, the author of *Rust in Action*: [https://www.youtube.com/c/timClicks/](https://www.youtube.com/c/timClicks/). Tim’s channel, like mine, splits its time between implementation and theory, though Tim has a particular knack for creative visual projects, which makes for fun viewing. 4.  Jonathan Turner’s *Systems with JT* channel: [https://www.youtube.com/c/SystemswithJT/](https://www.youtube.com/c/SystemswithJT/). Jonathan’s videos document their work on Nushell, their take on a “new type of shell,” providing a great sense of what it’s like to work on a nontrivial existing codebase. 5.  Ryan Levick’s channel: [https://www.youtube.com/c/RyanLevicksVideos/](https://www.youtube.com/c/RyanLevicksVideos/). Ryan mainly posts videos that tackle particular Rust concepts and walks through them using concrete code examples, but he also occasionally does implementation videos (like FFI for Microsoft Flight Simulator!) and deep dives into how well-known crates work under the hood.    Given that I make Rust videos, it should come as no surprise that I am a fan of this approach to teaching. But this kind of receptive or interactive learning doesn’t have to come in the form of videos. Another great avenue for learning from experienced developers is pair programming. If you have a colleague or friend with expertise in a particular aspect of Rust you’d like to learn, ask if you can do a pair-programming session with them to solve a problem together!    ### Learn by Doing    Since your ultimate goal is to get better at writing Rust, there’s no substitute for programming experience. No matter what or how many resources you learn from, you need to put that learning into practice. However, finding a good place to start can be tricky, so here I’ll give some suggestions.    Before I dive into the list, I want to provide some general guidance on how to pick projects. First, choose a project that *you* care about, without worrying too much whether others care about it. While there are plenty of popular and established Rust projects out there that would love to have you as a contributor, and it’s fun to be able to say “I contributed to the well-known library X,” your first priority must be your own interest. Without concrete motivation, you’ll quickly lose steam and find contributing to be a chore. The very best targets are projects that you use yourself and have experienced problems with—go fix them! Nothing is more satisfying than getting rid of a long-standing personal nuisance while also contributing back to the community.    Okay, so back to project suggestions. First and foremost, consider contributing to the Rust compiler and its associated tools. It’s a high-quality codebase with good documentation and an endless supply of issues (you probably know of some yourself), and there are several great mentors who can provide outlines for how to approach solving issues. If you look through the issue tracker for issues marked E-easy or E-mentor, you’ll likely find a good candidate quickly. As you gain more experience, you can keep leveling up to contribute to trickier parts.    If that’s not your cup of tea, I recommend finding something you use frequently that’s written in another language and porting it to Rust—not necessarily with the intention of replacing the original library or tool, but just because the experience will allow you to focus on writing Rust without having to spend too much time coming up with all the functionality yourself. If it turns out well, the fact that it already exists suggests that someone else also needed it, so there may be a wider audience for your port too! Data structures and command-line tools often make for great porting subjects, but find a niche that appeals to you.    Should you be more of a “build it from scratch” kind of person, I recommend looking back at your own development experience so far and thinking about similar code you’ve ended up writing in multiple projects (whether in Rust or in other languages). Such repetition tends to be a good signal that something is reusable and could be turned into a library. If nothing comes to mind, David Tolnay maintains a list of smaller utility crates that other Rust developers have requested at [https://github.com/dtolnay/request-for-implementation/](https://github.com/dtolnay/request-for-implementation/) that may provide a source of inspiration. If you’re looking for something more substantial and ambitious, there’s also the Not Yet Awesome list at [https://github.com/not-yet-awesome-rust/not-yet-awesome-rust/](https://github.com/not-yet-awesome-rust/not-yet-awesome-rust/) that lists things that should exist in Rust but don’t (yet).    ### Learn by Reading    Although the state of affairs is constantly improving, finding good Rust reading material beyond the beginner level can still be tricky. Here’s a collection of pointers to some of my favorite resources that continue to teach me new things or serve as good references when I have particularly niche or nuanced questions.    First, I recommend looking through the official virtual Rust books linked from [https://www.rust-lang.org/learn/](https://www.rust-lang.org/learn/). Some, like the Cargo book, are more reference-like while others, like the Embedded book, are more guide-like, but they’re all deep sources of solid technical information about their respective topics. *The Rustonomicon* ([https://doc.rust-lang.org/nomicon/](https://doc.rust-lang.org/nomicon/)), in particular, is a lifesaver when you’re writing unsafe code.    Two more books that are worth checking out are the *Guide to rustc Development* ([https://rustc-dev-guide.rust-lang.org/](https://rustc-dev-guide.rust-lang.org/)) and the *Standard Library Developers Guide* ([https://std-dev-guide.rust-lang.org/](https://std-dev-guide.rust-lang.org/)). These are fantastic resources if you’re curious about how the Rust compiler does what it does or how the standard library is designed, or if you want some pointers before you try your hand at contributing to Rust itself. The official Rust guidelines are also a treasure trove of information; I’ve already mentioned the *Rust API Guidelines* ([https://rust-lang.github.io/api-guidelines/](https://rust-lang.github.io/api-guidelines/)) in the book, but a *Rust Unsafe Code Guidelines Reference* is also available ([https://rust-lang.github.io/unsafe-code-guidelines/](https://rust-lang.github.io/unsafe-code-guidelines/)), and by the time you read this book there may be more.    There are also a number of unofficial virtual Rust books that are enormously valuable collections of experience and knowledge. *The Little Book of Rust Macros* ([https://veykril.github.io/tlborm/](https://veykril.github.io/tlborm/)), for example, is indispensable if you want to write nontrivial declarative macros, and *The Rust Performance Book* ([https://nnethercote.github.io/perf-book/](https://nnethercote.github.io/perf-book/)) is filled with tips and tricks for improving the performance of Rust code both at the micro and the macro level. Other great resources include the *Rust Fuzz Book* ([https://rust-fuzz.github.io/book/](https://rust-fuzz.github.io/book/)), which explores fuzz testing in more detail, and the *Rust Cookbook* ([https://rust-lang-nursery.github.io/rust-cookbook/](https://rust-lang-nursery.github.io/rust-cookbook/)), which suggests idiomatic solutions to common programming tasks. There’s even a resource for finding more books, *The Little Book of Rust Books* ([https://lborb.github.io/book/unofficial.html](https://lborb.github.io/book/unofficial.html))!    If you prefer more hands-on reading, the Tokio project has published *mini-redis* ([https://github.com/tokio-rs/mini-redis/](https://github.com/tokio-rs/mini-redis/)), an incomplete but idiomatic implementation of a Redis client and server that’s extremely well documented and specifically written to serve as a guide to writing asynchronous code. If you’re more of a data structures person, *Learn Rust with Entirely Too Many Linked Lists* ([https://rust-unofficial.github.io/too-many-lists/](https://rust-unofficial.github.io/too-many-lists/)) is an enlightening and fun read that gets into lots of gnarly details about ownership and references. If you’re looking for something closer to the hardware, Philipp Oppermann’s *Writing an OS in Rust* ([https://os.phil-opp.com/](https://os.phil-opp.com/)) goes through the whole operating system stack in great detail while teaching you good Rust patterns in the process. I also highly recommend Amos’s collection of articles ([https://fasterthanli.me/tags/rust/](https://fasterthanli.me/tags/rust/)) if you want a wide sampling of interesting deep dives written in a conversational style.    When you feel more confident in your Rust abilities and need more of a quick reference than a long tutorial, I’ve found the *Rust Language Cheat Sheet* ([https://cheats.rs/](https://cheats.rs/)) great for looking things up quickly. It also provides very nice visual explanations for most topics, so even if you’re looking up something you’re not intimately familiar with already, the explanations are pretty approachable.    And finally, if you want to put all of your Rust understanding to the test, go give David Tolnay’s *Rust Quiz* ([https://dtolnay.github.io/rust-quiz/](https://dtolnay.github.io/rust-quiz/)) a try. There are some real mind-benders in there, but each question comes with a thorough explanation of what’s going on, so even if you get one wrong, you’ll have learned from the experience!    ### Learn by Teaching    My experience has been that the best way to learn something well and thoroughly, by far, is to try to teach it to others. I have learned an enormous amount from writing this book, and I learn new things every time I make a new Rust video or podcast episode. So, I wholeheartedly recommend that you try your hand at teaching others about some of the things you’ve learned from reading this book or that you learn from here on out. It can take whatever form you prefer: in person, writing a blog post, tweeting, making a video or podcast, or giving a talk. The important thing is that you try to convey your newfound knowledge in your own words to someone who doesn’t already understand the topic—in doing so, you also give back to the community so that the next you that comes along has a slightly easier time getting up to speed. Teaching is a humbling and deeply educational experience, and I cannot recommend it highly enough.    ## Summary    In this chapter, we’ve covered Rust beyond what exists in your local workspace. We surveyed useful tools, libraries, and Rust features; looked at how to stay up to date as the ecosystem continues to evolve; and then discussed how you can get your hands dirty and contribute back to the ecosystem yourself. Finally, we discussed where you can go next to continue your Rust journey now that this book has reached its end. And with that, there’s little more to do than to declare:    ``` } ``` ````"]