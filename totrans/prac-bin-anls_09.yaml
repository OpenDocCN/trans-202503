- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: SIMPLE CODE INJECTION TECHNIQUES FOR ELF
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ELF的简单代码注入技术
- en: In this chapter, you’ll learn several techniques for injecting code into an
    existing ELF binary, allowing you to modify or augment the binary’s behavior.
    Although the techniques discussed in this chapter are convenient for making small
    modifications, they’re not very flexible. This chapter will demonstrate their
    limitations so you can understand the need for more comprehensive code modification
    techniques, which you’ll learn in [Chapter 9](ch09.xhtml#ch09).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习几种将代码注入现有ELF二进制文件的技术，这些技术可以让你修改或增强二进制文件的行为。尽管本章讨论的技术对于进行小规模修改非常方便，但它们的灵活性较差。本章将展示这些技术的局限性，以便你理解更全面的代码修改技术的必要性，这些技术你将在[第9章](ch09.xhtml#ch09)中学习到。
- en: 7.1 Bare-Metal Binary Modification Using Hex Editing
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1 使用十六进制编辑进行裸金属二进制修改
- en: The most straightforward way to modify an existing binary is by directly editing
    it using a *hex editor*, which is a program that represents the bytes of a binary
    file in hexadecimal format and allows you to edit these bytes. Usually, you’ll
    first use a disassembler to identify the code or data bytes you want to change
    and then use a hex editor to make the changes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 修改现有二进制文件最直接的方法是使用*十六进制编辑器*，这是一种以十六进制格式表示二进制文件字节并允许你编辑这些字节的程序。通常，你会先使用反汇编工具识别你想要更改的代码或数据字节，然后再使用十六进制编辑器进行更改。
- en: 'The advantage of this approach is that it’s simple and requires only basic
    tools. The disadvantage is that it only allows in-place editing: you can change
    code or data bytes but not add anything new. Inserting a new byte causes all the
    bytes after it to shift to another address, which breaks references to the shifted
    bytes. It’s difficult (or even impossible) to correctly identify and fix all the
    broken references, because the relocation information needed for this is usually
    discarded after the linking phase. If the binary contains any padding bytes, dead
    code (such as unused functions), or unused data, you can overwrite those parts
    of the binary with something new. However, this approach is limited since most
    binaries don’t contain a lot of dead bytes that you can safely overwrite.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点在于它简单，只需要基本的工具。缺点是它仅支持就地编辑：你可以更改代码或数据字节，但不能添加任何新的内容。插入新的字节会导致后面的所有字节移到另一个地址，从而破坏对这些字节的引用。由于在链接阶段之后通常会丢弃所需的重定位信息，因此很难（甚至不可能）正确识别和修复所有损坏的引用。如果二进制文件中包含任何填充字节、死代码（如未使用的函数）或未使用的数据，你可以用新内容覆盖这些部分。然而，由于大多数二进制文件中没有很多可以安全覆盖的死字节，这种方法是有限制的。
- en: Still, in some cases hex editing may be all you need. For instance, malware
    uses anti-debugging techniques to check the environment it’s running in for signs
    of analysis software. If the malware suspects it’s being analyzed, it will refuse
    to run or attack the analysis environment. When you’re analyzing a malware sample
    and you suspect that it contains anti-debugging checks, you can disable them using
    hex editing to overwrite the checks with `nop` (do-nothing) instructions. Sometimes,
    you can even fix simple bugs in a program using a hex editor. To show you an example
    of this, I’ll use a hex editor called `hexedit`, an open source editor for Linux
    that comes preinstalled on the virtual machine, to fix an off-by-one bug in a
    simple program.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，十六进制编辑可能是你所需要的一切。例如，恶意软件使用反调试技术来检查它运行的环境是否存在分析软件的痕迹。如果恶意软件怀疑自己正在被分析，它会拒绝运行或攻击分析环境。当你分析一个恶意软件样本并怀疑它包含反调试检查时，你可以使用十六进制编辑禁用这些检查，将检查部分覆盖为`nop`（无操作）指令。有时，你甚至可以通过十六进制编辑器修复程序中的简单错误。为了向你展示一个例子，我将使用名为`hexedit`的十六进制编辑器，它是一个开源编辑器，已在虚拟机上预安装，用于修复一个简单程序中的越界错误。
- en: Finding the Right Opcode
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找正确的操作码
- en: When you’re editing code in a binary, you need to know which values to insert,
    and for that, you need to know the format and hexadecimal encodings of the machine
    instructions. There are handy overviews online of the opcodes and operand formats
    for x86 instructions, such as *[http://ref.x86asm.net](http://ref.x86asm.net)*.
    For more detailed information about how a given x86 instruction works, consult
    the official Intel manual.*^a*
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在二进制文件中编辑代码时，你需要知道要插入哪些值，为此，你需要了解机器指令的格式和十六进制编码。网上有很多关于x86指令的操作码和操作数格式的有用概览，例如*[http://ref.x86asm.net](http://ref.x86asm.net)*。如果你需要更详细的信息来了解某个x86指令如何工作，可以查阅官方的英特尔手册。*^a*
- en: '*a*. *[https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf](https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf)*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*. *[https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf](https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf)*'
- en: '*7.1.1 Observing an Off-by-One Bug in Action*'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*7.1.1 观察越界错误的实际表现*'
- en: '*Off-by-one bugs* typically occur in loops when the programmer uses an erroneous
    loop condition that causes the loop to read or write one too few or one too many
    bytes. The example program in [Listing 7-1](ch07.xhtml#ch07list1) encrypts a file
    but accidentally leaves the last byte unencrypted because of an off-by-one bug.
    To fix this bug, I’ll first use `objdump` to disassemble the binary and locate
    the offending code. Then I’ll use `hexedit` to edit that code and remove the offby-one
    bug.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*越界错误* 通常发生在循环中，当程序员使用了错误的循环条件，导致循环读取或写入少了一个字节或多了一个字节。[列表 7-1](ch07.xhtml#ch07list1)
    中的示例程序加密一个文件，但由于越界错误，不小心将最后一个字节未加密。为了解决这个问题，我将首先使用 `objdump` 反汇编二进制文件并定位到出错的代码。然后我会使用
    `hexedit` 编辑该代码并去除越界错误。'
- en: '*Listing 7-1:* xor_encrypt.c'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-1：* xor_encrypt.c'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After parsing its command line arguments, the program opens the input file to
    encrypt ➊, determines the file size and stores it in a variable called `n` ➋,
    allocates a buffer ➌ to store the file in, reads the entire file into the buffer
    ➍, and then closes the file ➎. If anything goes wrong along the way, the program
    calls the `die` function to print an appropriate error message and exit.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析命令行参数后，程序打开要加密的输入文件 ➊，确定文件大小并将其存储在名为 `n` 的变量中 ➋，分配一个缓冲区 ➌ 用来存储文件，读取整个文件到缓冲区
    ➍，然后关闭文件 ➎。如果在过程中出现任何问题，程序会调用 `die` 函数打印适当的错误信息并退出。
- en: 'The bug is in the next part of the program, which encrypts the file bytes using
    a simple `xor`-based algorithm. The program enters a `for` loop to loop over the
    buffer containing all the file bytes and encrypts each byte by computing its `xor`
    with the provided key ➏. Note the loop condition of the `for` loop: the loop starts
    at `i = 0` but only loops while `i < n-1`. That means the last encrypted byte
    is at index `n-2` in the buffer, so the final byte (at index `n-1`) is left unencrypted!
    This is the off-by-one bug, which we’ll fix using a hex editor to edit the binary.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 错误发生在程序的下一个部分，该部分使用简单的 `xor` 算法加密文件字节。程序进入一个 `for` 循环，遍历包含所有文件字节的缓冲区，并通过与提供的密钥
    ➏ 做 `xor` 运算来加密每个字节。注意 `for` 循环的循环条件：循环从 `i = 0` 开始，但仅当 `i < n-1` 时才会继续。这意味着最后一个加密的字节位于缓冲区的索引
    `n-2` 处，因此最后一个字节（索引为 `n-1`）未被加密！这就是越界错误，我们将使用十六进制编辑器来修复它。
- en: After encrypting the file buffer, the program opens an output file ➐, writes
    the encrypted bytes to it ➑, and finally closes the output file ➒. [Listing 7-2](ch07.xhtml#ch07list2)
    shows an example run of the program (compiled using the Makefile provided on the
    virtual machine) where you can observe the off-by-one bug in action.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密文件缓冲区后，程序打开一个输出文件 ➐，将加密后的字节写入文件 ➑，最后关闭输出文件 ➒。[列表 7-2](ch07.xhtml#ch07list2)
    显示了程序的示例运行（使用虚拟机中提供的 Makefile 编译），可以看到程序中存在越界错误的实际情况。
- en: '*Listing 7-2: Observing the off-by-one bug in the* xor_encrypt *program*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-2：观察 *xor_encrypt* 程序中的越界错误*'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, I’ve used the `xor_encrypt` program to encrypt its own source
    file using the key `foobar`, writing the output to a file called *encrypted* ➊.
    Using `xxd` to view the contents of the original source file ➋, you can see that
    it ends with the byte `0x0a` ➌. In the encrypted file, all bytes are garbled ➍except
    the last one, which is the same as in the original file ➎. This is because the
    off-by-one bug causes the last byte to be left unencrypted.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我使用 `xor_encrypt` 程序用密钥 `foobar` 加密了它自己的源文件，并将输出写入名为 *encrypted* 的文件
    ➊。使用 `xxd` 查看原始源文件的内容 ➋，你会看到它以字节 `0x0a` 结尾 ➌。在加密后的文件中，所有字节都被破坏了 ➍，除了最后一个字节，它与原文件中的字节相同
    ➎。这是因为越界错误导致最后一个字节没有被加密。
- en: '*7.1.2 Fixing the Off-by-One Bug*'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*7.1.2 修复越界错误*'
- en: Now let’s take a look at how to fix the off-by-one bug in the binary. In all
    examples in this chapter, you can pretend you don’t have the source code of the
    binaries you’re editing, even though you really do. This is to simulate real-life
    cases where you’re forced to use binary modification techniques, such as when
    you’re working on a proprietary or malicious program or a program whose source
    code is lost.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Bytes That Cause the Bug
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To fix the off-by-one bug, you need to change the loop condition so that it
    loops one more time to encrypt the last byte. Therefore, you first need to disassemble
    the binary and find the instructions responsible for enforcing the loop condition.
    [Listing 7-3](ch07.xhtml#ch07list3) contains the relevant instructions as shown
    by `objdump`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-3: Disassembled code showing the off-by-one bug*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The loop starts at address `0x4007d8` ➊, and the loop counter (`i`) is contained
    in the `rbx` register. You can see the loop counter being incremented in each
    loop iteration ➋. You can also see a `cmp` instruction ➌ that checks whether another
    loop iteration is needed. The `cmp` compares `i` (stored in `rbx`) to the value
    `n-1` (stored in `r12`). If another loop iteration is needed, the `jne` instruction
    ➍ jumps back to the start of the loop. If not, it falls through to the next instruction,
    ending the loop.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'The `jne` instruction stands for “jump if not equal”^([1](footnote.xhtml#ch07fn_1)):
    it jumps back to the start of the loop if `i` is not equal to `n-1` (as determined
    by the `cmp`). In other words, since `i` is incremented in each loop iteration,
    the loop will run while `i < n-1`. But to fix the off-by-one bug, you want the
    loop to run while `i <= n-1` so that it runs one more time.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the Offending Bytes
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To implement this fix, you can use a hex editor to replace the opcode for the
    `jne` instruction, turning it into a different kind of jump. The `cmp` has `r12`
    (containing `n-1`) as its first operand, followed by `rbx` (containing `i`). Thus,
    you should use a `jae` (“jump if above or equal”) instruction so that the loop
    runs while `n-1 >= i`, which is just another way of saying `i <= n-1`. Now you
    can implement this fix using `hexedit`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: To follow along, go to the code folder for this chapter, run the Makefile, and
    then type `hexedit xor_encrypt` on the command line and press ENTER to open the
    `xor_encrypt` binary in the hex editor (it’s an interactive program). To find
    the specific bytes to modify, you can search for a byte pattern taken from a disassembler
    like `objdump`. In the case of [Listing 7-3](ch07.xhtml#ch07list3), you can see
    that the `jne` instruction you need to modify is encoded with the hexadecimal
    byte string `75d9`, so you’ll search for that pattern. In larger binaries, you’ll
    want to use longer patterns, possibly including bytes from other instructions,
    to ensure uniqueness. To search for a pattern in `hexedit`, press the / key. This
    should open up a prompt like the one shown in [Figure 7-1](ch07.xhtml#ch07fig1),
    where you can enter the search pattern `75d9` and then press ENTER to start the
    search.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟着操作，请转到本章的代码文件夹，运行 Makefile，然后在命令行中输入 `hexedit xor_encrypt` 并按 ENTER 以在十六进制编辑器中打开
    `xor_encrypt` 二进制文件（这是一个交互式程序）。要查找需要修改的特定字节，你可以搜索来自反汇编器（如 `objdump`）的字节模式。在 [Listing
    7-3](ch07.xhtml#ch07list3) 中，你可以看到需要修改的 `jne` 指令被编码为十六进制字节串 `75d9`，所以你将搜索这个模式。在更大的二进制文件中，你可能需要使用更长的模式，可能包括其他指令的字节，以确保唯一性。要在
    `hexedit` 中搜索模式，按 / 键。这将打开一个提示框，如 [Figure 7-1](ch07.xhtml#ch07fig1) 所示，你可以在其中输入搜索模式
    `75d9`，然后按 ENTER 开始搜索。
- en: '![image](Images/f161-01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f161-01.jpg)'
- en: '*Figure 7-1: Searching for a byte string with* `hexedit`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 7-1：使用* `hexedit` *搜索字节串*'
- en: The search finds the pattern and moves the cursor to the first byte of the pattern.
    Referring to an x86 opcode reference or the Intel x86 manual, you can see that
    the `jne` instruction is encoded as an opcode byte (`0x75`) followed by a byte
    that encodes an offset to the jump location (`0xd9`). For these purposes, you
    just want to replace the `jne` opcode, `0x75`, with the opcode for a `jae` instruction,
    which is `0x73`, leaving the jump offset unchanged. Since the cursor is already
    on the byte you want to modify, all it takes to make the edit is to type the new
    byte value, `73`. As you type, `hexedit` highlights the modified byte value in
    boldface. Now, all that’s left is to save the modified binary by pressing CTRL-X
    to exit and then pressing Y to confirm the change. You’ve now fixed the off-by-one
    bug in the binary! Let’s confirm the change by using `objdump` again, as shown
    in [Listing 7-4](ch07.xhtml#ch07list4).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索会找到模式并将光标移到模式的第一个字节。参考 x86 操作码参考或英特尔 x86 手册，你可以看到 `jne` 指令被编码为一个操作码字节（`0x75`），后跟一个编码跳转位置偏移量的字节（`0xd9`）。为了这些目的，你只需要将
    `jne` 操作码 `0x75` 替换为 `jae` 指令的操作码 `0x73`，而跳转偏移量保持不变。由于光标已经位于你想修改的字节上，编辑所需的只是输入新的字节值
    `73`。在你输入时，`hexedit` 会用粗体突出显示修改过的字节值。现在，剩下的就是按 CTRL-X 退出并按 Y 确认更改来保存修改过的二进制文件。你现在已经修复了二进制文件中的越界错误！让我们通过再次使用
    `objdump` 来确认这个更改，如 [Listing 7-4](ch07.xhtml#ch07list4) 所示。
- en: '*Listing 7-4: Disassembly showing the patch for the off-by-one bug*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 7-4：显示修复越界错误补丁的反汇编*'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the original `jne` instruction is now replaced by `jae` ➊. To
    check that the fix works, let’s run the program again to see whether it encrypts
    the last byte. [Listing 7-5](ch07.xhtml#ch07list5) shows the results.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，原来的 `jne` 指令现在已被 `jae` ➊ 替换。为了检查修复是否有效，让我们再次运行程序，看它是否加密了最后一个字节。[Listing
    7-5](ch07.xhtml#ch07list5) 显示了结果。
- en: '*Listing 7-5: Output of the fixed* xor_encrypt *program*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 7-5：修复后的* xor_encrypt *程序输出*'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As before, you run the `xor_encrypt` program to encrypt its own source code
    ➊. Recall that in the original source file, the last byte’s value was `0x0a` (see
    [Listing 7-2](ch07.xhtml#ch07list2)). Using `xxd` to inspect the encrypted file
    ➋, you can see that even the last byte is now properly encrypted ➌: it’s now `0x65`
    instead of `0x0a`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，你运行 `xor_encrypt` 程序来加密它自己的源代码 ➊。回想一下，在原始源文件中，最后一个字节的值是 `0x0a`（见 [Listing
    7-2](ch07.xhtml#ch07list2)）。使用 `xxd` 检查加密文件 ➋，你可以看到即使是最后一个字节现在也已正确加密 ➌：它现在是 `0x65`
    而不是 `0x0a`。
- en: You now know how to edit a binary using a hex editor! Although this example
    was simple, the procedure is the same for more complex binaries and edits.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何使用十六进制编辑器编辑二进制文件了！虽然这个例子很简单，但程序对于更复杂的二进制文件和编辑是相同的。
- en: 7.2 Modifying Shared Library Behavior Using LD_PRELOAD
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2 使用 LD_PRELOAD 修改共享库行为
- en: Hex editing is a nice way of making modifications to your binaries because it
    requires only basic tools, and since the modifications are small, edited binaries
    usually have virtually no performance or code/data size overhead compared to the
    original. However, as you’ve seen in the example in the previous section, hex
    editing is also tedious, error-prone, and restrictive because you cannot add new
    code or data. If your goal is to modify the behavior of shared library functions,
    you can achieve this more easily using `LD_PRELOAD`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制编辑是一种修改二进制文件的好方法，因为它只需要基础工具，而且由于修改较小，编辑后的二进制文件通常与原始文件相比几乎没有性能或代码/数据大小的开销。然而，正如你在前一节的示例中看到的，十六进制编辑也很繁琐、容易出错并且有局限性，因为你不能添加新的代码或数据。如果你的目标是修改共享库函数的行为，使用
    `LD_PRELOAD` 可以更轻松地实现。
- en: '`LD_PRELOAD` is the name of an environment variable that influences the behavior
    of the dynamic linker. It allows you to specify one or more libraries for the
    linker to load before any other library, including standard system libraries such
    as *libc.so*. If a preloaded library contains a function with the same name as
    a function in a library loaded later, the first function is the one that will
    be used at runtime. This allows you to *override* library functions (even standard
    library functions like `malloc` or `printf`) with your own versions of those functions.
    This is useful not only for binary modification but also for programs for which
    source code is available, because the ability to modify the behavior of a library
    function can save you the trouble of having to painstakingly modify all points
    in the source where that library function is used. Let’s look at an example of
    how `LD_PRELOAD` can be useful to modify a binary’s behavior.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`LD_PRELOAD` 是一个环境变量的名称，它会影响动态链接器的行为。它允许你指定一个或多个库，在任何其他库加载之前，包括像 *libc.so*
    这样的标准系统库。如果一个预加载的库中包含与稍后加载的库中的某个函数同名的函数，那么运行时将使用第一个函数。这使得你可以用自己实现的版本 *覆盖* 库函数（即使是像
    `malloc` 或 `printf` 这样的标准库函数）。这不仅对二进制修改有用，对于那些源代码可用的程序也很有帮助，因为修改库函数的行为可以避免你费力修改源代码中所有调用该库函数的地方。我们来看一个例子，说明
    `LD_PRELOAD` 如何有助于修改二进制程序的行为。'
- en: '*7.2.1 A Heap Overflow Vulnerability*'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*7.2.1 堆溢出漏洞*'
- en: The program I’ll be modifying in this example is `heapoverflow`, which contains
    a heap overflow vulnerability that you can fix using `LD_PRELOAD`. [Listing 7-6](ch07.xhtml#ch07list6)
    shows the source for the program.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这个示例中修改的程序是 `heapoverflow`，它包含一个堆溢出漏洞，可以通过 `LD_PRELOAD` 来修复。[示例 7-6](ch07.xhtml#ch07list6)
    显示了程序的源代码。
- en: '*Listing 7-6:* heapoverflow.c'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-6:* heapoverflow.c'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `heapoverflow` program takes two command line arguments: a number and a
    string. It takes the given number, interpreting it as a buffer length ➊, and then
    allocates a buffer of that size using `malloc` ➋. Next, it uses `strcpy` ➌ to
    copy the given string into the buffer and then prints the buffer contents to the
    screen. Finally, it deallocates the buffer again using `free` ➍.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`heapoverflow` 程序接受两个命令行参数：一个数字和一个字符串。它将给定的数字作为缓冲区的大小 ➊，然后使用 `malloc` ➋ 分配该大小的缓冲区。接下来，它使用
    `strcpy` ➌ 将给定的字符串复制到缓冲区中，并将缓冲区的内容打印到屏幕上。最后，它使用 `free` ➍ 释放该缓冲区。'
- en: 'The overflow vulnerability is in the `strcpy` operation: since the length of
    the string is never checked, it may be too large to fit into the buffer. If that’s
    the case, the copy will result in a heap overflow, potentially corrupting other
    data on the heap and resulting in a crash or even exploitation of the program.
    But if the given string fits into the buffer, everything works fine, as you can
    see in [Listing 7-7](ch07.xhtml#ch07list7).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 溢出漏洞出现在 `strcpy` 操作中：因为字符串的长度从未检查，所以它可能太大，无法放入缓冲区。如果是这种情况，复制操作将导致堆溢出，可能会破坏堆上的其他数据，并导致崩溃甚至利用程序漏洞。但如果给定的字符串可以适应缓冲区，一切都能正常工作，就像你在
    [示例 7-7](ch07.xhtml#ch07list7) 中看到的那样。
- en: '*Listing 7-7: Behavior of the* heapoverflow *program when given a benign input*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-7：* heapoverflow *程序在输入正常时的行为*'
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, I’ve told `heapoverflow` to allocate a 13-byte buffer and then copy the
    message “Hello world!” into it ➊. The program allocates the requested buffer,
    copies the message into it, and prints it back to screen as expected, since the
    buffer is exactly large enough to hold the string, including its terminating `NULL`
    character. Let’s examine [Listing 7-8](ch07.xhtml#ch07list8) to see what happens
    if you give a message that doesn’t fit into the buffer.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-8: Crash of the* heapoverflow *program when the input is too long*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Again, I’ve told the program to allocate 13 bytes, but now the message is far
    too large to fit into the buffer: it’s a string consisting of 100 *A*s in a row
    ➊. The program allocates the 13-byte buffer as earlier ➋ and then copies the message
    into it and prints it to screen ➌. However, things go wrong when `free` is called
    ➍ to deallocate the buffer: the overflowing message has overwritten metadata on
    the heap that’s used by `malloc` and `free` to keep track of heap buffers. The
    corrupted heap metadata ultimately causes the program to crash ➎. In the worst
    case, overflows like this can allow an attacker to take over the vulnerable program
    using a carefully crafted string for the overflow. Now let’s see how you can detect
    and prevent the overflow using `LD_PRELOAD`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '*7.2.2 Detecting the Heap Overflow*'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The key idea is to implement a shared library that overrides the `malloc` and
    `free` functions so that they internally keep track of the size of all allocated
    buffers and also overrides `strcpy` so that it automatically checks whether the
    buffer is large enough for the string before copying anything. Note that for the
    sake of the example, this idea is oversimplified and should not be used in production
    settings. For example, it doesn’t take into account that buffer sizes can be changed
    using `realloc`, and it uses simple bookkeeping that can track only the last 1,024
    allocated buffers. However, it should be enough to show how you can use `LD_PRELOAD`
    to solve real-world problems. [Listing 7-9](ch07.xhtml#ch07list9) shows the code
    for the library (*heapcheck.c*) containing the alternative `malloc`/`free`/`strcpy`
    implementations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-9:* heapcheck.c'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, note the *dlfcn.h* header ➊, which you’ll often include when writing
    libraries for use with `LD_PRELOAD` because it provides the `dlsym` function.
    You can use `dlsym` to get pointers to shared library functions. In this case,
    I’ll use it to get access to the original `malloc`, `free`, and `strcpy` functions
    to avoid having to reimplement them completely. There’s a set of global function
    pointers that keep track of these original functions as found by `dlsym` ➋.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: To keep track of the sizes of allocated buffers, I’ve defined a `struct` type
    called `alloc_t`, which can store the address and size of a buffer ➌. I use a
    global circular array of these structures, called `allocs`, to keep track of the
    1,024 most recent allocations ➍.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take a look at the modified `malloc` function ➎. The first thing
    it does is check whether the pointer to the original (`libc`) version of `malloc`
    (which I call `orig_malloc`) is initialized yet. If not, it calls `dlsym` to look
    up this pointer ➏.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看修改后的`malloc`函数 ➎。它做的第一件事是检查指向原始（`libc`）版本的`malloc`的指针（我称之为`orig_malloc`）是否已经初始化。如果没有，它会调用`dlsym`来查找这个指针
    ➏。
- en: Note that I use the `RTLD_NEXT` flag for `dlsym`, which causes `dlsym` to return
    a pointer to the next version of `malloc` in the chain of shared libraries. When
    you preload a library, it will be at the start of the chain. Thus, the *next*
    version of `malloc`, to which `dlsym` returns a pointer, will be the original
    `libc` version since `libc` is loaded later than your preloaded library.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在`dlsym`中使用了`RTLD_NEXT`标志，这会导致`dlsym`返回链中下一个版本的`malloc`的指针。当你预加载一个库时，它将位于链的开始。因此，`dlsym`返回指针的*下一个*版本的`malloc`将是原始的`libc`版本，因为`libc`会比你的预加载库晚加载。
- en: Next, the modified `malloc` calls `orig_malloc` to do the actual allocation
    ➐ and then stores the address and size of the allocated buffer in the global `allocs`
    array. Now that this information is stored, `strcpy` can later check whether it’s
    safe to copy a string into a given buffer.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改后的`malloc`调用`orig_malloc`来执行实际的分配 ➐，然后将分配的缓冲区的地址和大小存储在全局`allocs`数组中。现在这些信息已经存储，`strcpy`以后可以检查是否可以安全地将字符串复制到给定的缓冲区中。
- en: The new version of `free` is similar to the new `malloc`. It simply resolves
    and calls the original `free` (`orig_free`) and then invalidates the metadata
    for the freed buffer in the `allocs` array ➑.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本的`free`与新的`malloc`类似。它简单地解析并调用原始的`free`（`orig_free`），然后在`allocs`数组中使已释放缓冲区的元数据无效
    ➑。
- en: Finally, let’s look at the new `strcpy` ➒. Again, it starts by resolving the
    original `strcpy` (`orig_strcpy`). However, *before* calling it, it checks whether
    the copy would be safe by searching the global `allocs` array for an entry that
    tells you the size of the destination buffer. If the metadata is found, `strcpy`
    checks whether the buffer would be large enough to accomodate the string ➓. If
    so, it allows the copy. If not, it prints an error message and aborts the program
    to prevent an attacker from exploiting the vulnerability. Note that if no metadata
    is found because the destination buffer wasn’t one of the 1,024 most recent allocations,
    `strcpy` allows the copy. Practically, you would probably want to avoid this situation
    by using a more complex data structure for tracking the metadata, one that isn’t
    limited to 1,024 (or any hard limit) of allocations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下新的`strcpy` ➒。它首先解析原始的`strcpy`（`orig_strcpy`）。然而，*在*调用之前，它会检查通过在全局`allocs`数组中搜索一个条目来确认复制是否安全，该条目会告诉你目标缓冲区的大小。如果找到元数据，`strcpy`会检查缓冲区是否足够大以容纳字符串
    ➓。如果是，它就允许复制。如果不是，它会打印错误消息并终止程序，以防止攻击者利用这个漏洞。请注意，如果没有找到元数据，因为目标缓冲区不是最近1,024次分配之一，`strcpy`会允许复制。实际上，你可能希望通过使用更复杂的数据结构来跟踪元数据，避免这种情况，这种结构不限于1,024个（或任何硬限制的）分配。
- en: '[Listing 7-10](ch07.xhtml#ch07list10) shows how to use the *heapcheck.so* library
    in practice.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-10](ch07.xhtml#ch07list10)展示了如何在实践中使用*heapcheck.so*库。'
- en: '*Listing 7-10: Using the* heapcheck.so *library to prevent heap overflows*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-10：使用* heapcheck.so *库来防止堆溢出*'
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, the important thing to note is the definition of the `LD_PRELOAD` environment
    variable ➊ when starting the `heapoverflow` program. This causes the linker to
    preload the specified library, *heapcheck.so*, which contains the modified `malloc`,
    `free`, and `strcpy` functions. Note that the paths given in `LD_PRELOAD` need
    to be absolute. If you use a relative path, the dynamic linker will fail to find
    the library, and the preload won’t happen.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的关键点是在启动`heapoverflow`程序时定义`LD_PRELOAD`环境变量 ➊。这会导致链接器预加载指定的库，*heapcheck.so*，该库包含修改过的`malloc`、`free`和`strcpy`函数。请注意，`LD_PRELOAD`中给出的路径需要是绝对路径。如果使用相对路径，动态链接器将无法找到该库，预加载也将无法进行。
- en: 'The parameters to the `heapoverflow` program are the same as those in [Listing
    7-8](ch07.xhtml#ch07list8): a 13-byte buffer and a 100-byte string. As you can
    see, now the heap overflow does not cause a crash. The modified `strcpy` successfully
    detects the unsafe copy, prints an error, and safely aborts the program ➋, making
    the vulnerability impossible for an attacker to exploit.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: If you look carefully at the Makefile for the `heapoverflow` program, you’ll
    note that I used `gcc`’s `-fno-builtin` flag to build the program. For essential
    functions like `malloc`, `gcc` sometimes uses built-in versions, which it statically
    links into the compiled program. In this case, I used `-fno-builtin` to make sure
    that doesn’t happen because statically linked functions cannot be overridden using
    `LD_PRELOAD`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 7.3 Injecting a Code Section
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The binary modification techniques you learned so far are pretty limited in
    their applicability. Hex editing is useful for small modifications, but you can’t
    add much (if any) new code or data. `LD_PRELOAD` allows you to easily add new
    code, but you can use it only to modify library calls. Before exploring more flexible
    binary modification techniques in [Chapter 9](ch09.xhtml#ch09), let’s explore
    how to inject a completely new code section into an ELF binary; this relatively
    simple trick is more flexible than those just discussed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: On the virtual machine, there’s a complete tool called `elfinject` that implements
    this code injection technique. Because the `elfinject` source code is pretty lengthy,
    I won’t go through it here, but I include an explanation of how `elfinject` is
    implemented in [Appendix B](appb.xhtml) if you’re interested. The appendix also
    doubles as an introduction to `libelf`, a popular open source library for parsing
    ELF binaries. While you won’t need to know `libelf` to understand the rest of
    this book, it can be useful when implementing your own binary analysis tools,
    so I encourage you to read [Appendix B](appb.xhtml).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll give you a high-level overview that explains the main
    steps involved in the code section injection technique. I’ll then show you how
    to use the `elfinject` tool provided on the virtual machine to inject a code section
    into an ELF binary.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '*7.3.1 Injecting an ELF Section: A High-Level Overview*'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 7-2](ch07.xhtml#ch07fig2) shows the main steps needed to inject a new
    code section into an ELF. The left side of the figure shows an original (unmodified)
    ELF, while the right side shows the altered file with the new section added, called
    `.injected`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: To add a new section to an ELF binary, you first inject the bytes that the section
    will contain (step ➊ in [Figure 7-2](ch07.xhtml#ch07fig2)) by appending them to
    the end of the binary. Next, you create a section header ➋ and a program header
    ➌ for the injected section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall from [Chapter 2](ch02.xhtml#ch02), the program header table
    is usually located right after the executable header ➍. Because of this, adding
    an extra program header would shift all of the sections and headers that come
    after it. To avoid the need for complex shifting, you can simply overwrite an
    existing one instead of adding a new program header, as shown in [Figure 7-2](ch07.xhtml#ch07fig2).
    This is what `elfinject` implements, and you can apply the same header-overwriting
    trick to avoid adding a new section header to the binary.^([2](footnote.xhtml#ch07fn_2))
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f170-01.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Replacing* `.note.ABI-tag` *with an injected code section*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Overwriting the PT_NOTE Segment
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you just saw, it’s easier to overwrite an existing section header and program
    header than to add completely new ones. But how do you know which headers you
    can safely overwrite without breaking the binary? One program header that you
    can always safely overwrite is the `PT_NOTE` header, which describes the `PT_NOTE`
    segment.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: The `PT_NOTE` segment encompasses sections that contain auxiliary information
    about the binary. For example, it may tell you that it’s a GNU/Linux binary, what
    kernel version the binary expects, and so on. In the `/bin/ls` executable on the
    virtual machine in particular, the `PT_NOTE` segment contains this information
    in two sections called `.note.ABI-tag` and `.note.gnu.build-id`. If this information
    is missing, the loader simply assumes it’s a native binary, so it’s safe to overwrite
    the `PT_NOTE` header without fear of breaking the binary. This trick is commonly
    used by malicious parasites to infect binaries, but it also works for benign modifications.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s consider the changes needed for step ➋ in [Figure 7-2](ch07.xhtml#ch07fig2),
    where you overwrite one of the `.note.*` section headers to turn it into a header
    for your new code section (`.injected`). I’ll (arbitrarily) choose to overwrite
    the header for the `.note.ABI-tag` section. As you can see in [Figure 7-2](ch07.xhtml#ch07fig2),
    I change the `sh_type` from `SHT_NOTE` to `SHT_PROGBITS` to denote that the header
    now describes a code section. Moreover, I change the `sh_addr`, `sh_offset`, and
    `sh_size` fields to describe the location and size of the new `.injected` section
    instead of the now obsolete `.note.ABI-tag` section. Finally, I change the section
    alignment (`sh_addralign`) to 16 bytes to ensure that the code will be properly
    aligned when loaded into memory, and I add the `SHF_EXECINSTR` flag to the `sh_flags`
    field to mark the section as executable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'The changes for step ➌ are similar, except that here I change the `PT_NOTE`
    program header instead of a section header. Again, I change the header type by
    setting `p_type` to `PT_LOAD` to indicate that the header now describes a loadable
    segment instead of a `PT_NOTE` segment. This causes the loader to load the segment
    (which encompasses the new `.injected` section) into memory when the program starts.
    I also change the required address, offset, and size fields: `p_offset`, `p_vaddr`
    (and `p_paddr`, not shown), `p_filesz`, and `p_memsz`. I set `p_flags` to mark
    the segment as readable and executable, instead of just readable, and I fix the
    alignment (`p_align`).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Although it’s not shown in [Figure 7-2](ch07.xhtml#ch07fig2), it’s nice to also
    update the string table to change the name of the old `.note.ABI-tag` section
    to something like `.injected` to reflect the fact that a new code section was
    added. I discuss this step in detail in [Appendix B](appb.xhtml).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting the ELF Entry Point
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Step ➍ in [Figure 7-2](ch07.xhtml#ch07fig2) is optional. In this step, I change
    the `e_entry` field in the ELF executable header to point to an address in the
    new `.injected` section, instead of the original entry point, which is usually
    somewhere in `.text`. You need to do this only if you want some code in the `.injected`
    section to run right at the start of the program. Otherwise, you can just leave
    the entry point as is, though in that case, the new injected code will never run
    unless you redirect some calls in the original `.text` section to injected code,
    use some of the injected code as constructors, or apply another method to reach
    the injected code. I’ll discuss more ways to call into the injected code in [Section
    7.4](ch07.xhtml#ch07_4).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '*7.3.2 Using elfinject to Inject an ELF Section*'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To make the `PT_NOTE` injection technique more concrete, let’s look at how to
    use the `elfinject` tool provided on the virtual machine. [Listing 7-11](ch07.xhtml#ch07list11)
    shows how to use `elfinject` to inject a code section into a binary.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-11:* elfinject *usage*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the code folder for this chapter on the virtual machine, you’ll see a file
    called *hello.bin* ➊, which contains the new code you’ll inject in raw binary
    form (without any ELF headers). As you’ll see shortly, the code prints a `hello
    world!` message and then transfers control to the original entry point of the
    host binary, resuming normal execution of the binary. If you’re interested, you
    can find the assembly instructions for the injected code in the file called *hello.s*
    or in [Section 7.4](ch07.xhtml#ch07_4).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now take a look at the `elfinject` usage ➋. As you can see, `elfinject`
    expects five arguments: a path to a host binary, a path to an inject file, a name
    and an address for the injected section, and an offset to the entry point of the
    injected code (or −1 if it has no entry point). The inject file *hello.bin* is
    injected into the host binary, with the given name, address, and entry point.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: I use a copy of `/bin/ls` as a host binary in this example ➌. As you can see,
    `ls` behaves normally before the inject, printing a listing of the current directory
    ➍. You can see with `readelf` that the binary contains a `.note.ABI-tag` section
    ➎ and a `PT_NOTE` segment ➏, which the inject will overwrite.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s time to inject some code. In the example, I use `elfinject` to inject
    the *hello.bin* file into the `ls` binary, using the name `.injected` and load
    address `0x800000` for the injected section (which `elfinject` appends to the
    end of the binary) ➐. I use `0` as the entry point because the entry point of
    *hello.bin* is right at its start.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: After `elfinject` completes successfully, `readelf` shows that the `ls` binary
    now contains a code section called `.injected` ➑ and a new executable segment
    of type `PT_LOAD` ➒ that contains this section. Also, the `.note.ABI-tag` section
    and `PT_NOTE` segment are gone because they have been overwritten. Looks like
    the inject succeeded!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s check whether the injected code behaves as expected. Executing the
    modified `ls` binary ➓, you can see that the binary now runs the injected code
    at startup, printing the `hello world!` message. The injected code then passes
    execution to the binary’s original entry point so that it resumes its normal behavior
    of printing a directory listing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 Calling Injected Code
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, you learned how to use `elfinject` to inject a new
    code section into an existing binary. To get the new code to execute, you modified
    the ELF entry point, causing the new code to run as soon as the loader transfers
    control to the binary. But you may not always want to use the injected code immediately
    when the binary starts. Sometimes, you’ll want to use the injected code for different
    reasons, such as substituting a replacement for an existing function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll discuss alternative techniques for transferring control
    to the injected code, other than modifying the ELF entry point. I’ll also recap
    the ELF entry point modification technique, this time using only a hex editor
    to change the entry point. This will let you redirect the entry point not only
    to code injected with `elfinject` but also to code that’s been inserted in other
    ways, for instance, by overwriting dead code like padding instructions. Note that
    all of the techniques discussed in this section are suitable for use with any
    code injection method, not just `PT_NOTE` overwriting.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '*7.4.1 Entry Point Modification*'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, let’s briefly recap the ELF entry point modification technique. In the
    following example, I’ll transfer control to a code section injected using `elfinject`,
    but instead of using `elfinject` to update the entry point itself, I’ll use a
    hex editor. This will show you how to generalize the technique to code injected
    in various ways.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-12](ch07.xhtml#ch07list12) shows the assembly instructions for the
    code I’ll inject. It’s the “hello world” example used in the previous section.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-12:* hello.s'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code is in Intel syntax, intended to be assembled with the `nasm` assembler
    in 64-bit mode ➊. The first few assembly instructions save the `rax`, `rcx`, `rdx`,
    `rsi`, and `rdi` registers by pushing them onto the stack ➋. These registers may
    be clobbered by the kernel, and you’ll want to restore them to their original
    values after the injected code completes to avoid interfering with other code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'The next instructions set up the arguments for a `sys_write` system call ➌,
    which will print `hello world!` to the screen. (You’ll find more information on
    all standard Linux system call numbers and arguments in the `syscall man` page.)
    For `sys_write`, the syscall number (which is placed in `rax`) is 1, and there
    are three arguments: the file descriptor to write to (1 for `stdout`), a pointer
    to the string to print, and the length of the string. Now that all the arguments
    are prepared, the `syscall` instruction ➍ invokes the actual system call, printing
    the string.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: After invoking the `sys_write` system call, the code restores the registers
    to their previously saved state ➎. It then pushes the address `0x4049a0` of the
    original entry point (which I found using `readelf`, as you’ll see shortly) and
    returns to that address, starting execution of the original program ➏.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The “hello world” string ➐ is declared after the assembly instructions, along
    with an integer containing the length of the string ➑, both of which are used
    for the `sys_write` system call.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: To make the code suitable for injection, you need to assemble it into a raw
    binary file that contains nothing more than the binary encodings of the assembly
    instructions and data. This because you don’t want to create a full-fledged ELF
    binary that contains headers and other overhead not needed for the inject. To
    assemble *hello.s* into a raw binary file, you can use the `nasm` assembler’s
    `-f bin` option, as shown in [Listing 7-13](ch07.xhtml#ch07list13). The *Makefile*
    for this chapter comes with a *hello.bin* target that automatically runs this
    command.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-13: Assembling* hello.s *into* hello.bin *using* nasm'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This creates the file *hello.bin*, which contains the raw binary instructions
    and data suitable for injection. Now let’s use `elfinject` to inject this file
    and redirect the ELF entry point using a hex editor so that the injected code
    runs on startup of the binary. [Listing 7-14](ch07.xhtml#ch07list14) shows how
    to do this.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-14: Calling injected code by overwriting the ELF entry point*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'First, copy the `/bin/ls` binary into `ls.entry` ➊. This will serve as a host
    binary for the inject. Then you can use `elfinject` to inject the just-prepared
    code into the binary with load address `0x800000` ➋, exactly as discussed in [Section
    7.3.2](ch07.xhtml#ch07_3_2), with one crucial difference: set the last `elfinject`
    argument to −1 so that `elfinject` leaves the entry point unmodified (because
    you’ll overwrite it manually).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'With `readelf`, you can see the original entry point of the binary: `0x4049a0`
    ➌. Note that this is the address that the injected code jumps to when it’s done
    printing the `hello world` message, as shown in [Listing 7-12](ch07.xhtml#ch07list12).
    You can also see with `readelf` that the injected section actually starts at the
    address `0x800e78` ➍ instead of the address `0x800000`. This is because `elfinject`
    slightly changed the address to meet the alignment requirements of the ELF format,
    as I discuss in more detail in [Appendix B](appb.xhtml). What’s important here
    is that `0x800e78` is the new address you’ll want to use to overwrite the entry
    point address with.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the entry point is still unmodified, if you run `ls.entry` now, it
    simply behaves like the normal `ls` command without the added “hello world” message
    at the start ➎. To modify the entry point, you open up the `ls.entry` binary in
    `hexedit` ➏ and search for the original entry point address. Recall that you can
    open the search dialog in `hexedit` using the / key and then enter the address
    to search for. The address is stored in little-endian format, so you’ll need to
    search for the bytes `a04940` instead of `4049a0`. After you’ve found the entry
    point, overwrite it with the new one, again with the byte order reversed: `780e80`.
    Now, press CTRL-X to exit and press Y to save your changes.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: You can now see with `readelf` that the entry point is updated to `0x800e78`
    ➐, pointing to the start of the injected code. Now when you run `ls.entry`, it
    prints `hello world` before showing the directory listing ➑. You’ve successfully
    overwritten the entry point!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '*7.4.2 Hijacking Constructors and Destructors*'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s take a look at another way to ensure your injected code gets called
    once during the lifetime of the binary, either at the start or end of execution.
    Recall from [Chapter 2](ch02.xhtml#ch02) that x86 ELF binaries compiled with `gcc`
    contain sections called `.init_array` and `.fini_array`, which contain pointers
    to a series of constructors and destructors, respectively. By overwriting one
    of these pointers, you can cause the injected code to be invoked before or after
    the binary’s `main` function, depending on whether you overwrite a constructor
    or a destructor pointer.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Of course, after the injected code completes, you’ll want to transfer control
    back to the constructor or destructor that you hijacked. This requires some small
    changes to the injected code, as shown in [Listing 7-15](ch07.xhtml#ch07list15).
    In this listing, I assume you’ll pass control back to a specific constructor whose
    address you’ll find using `objdump`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-15:* hello-ctor.s'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code shown in [Listing 7-15](ch07.xhtml#ch07list15) is the same as the code
    in [Listing 7-12](ch07.xhtml#ch07list12), except that I’ve inserted the address
    of the hijacked constructor to return to ➊ instead of the entry point address.
    The command to assemble the code into a raw binary file is the same as discussed
    in the previous section. [Listing 7-16](ch07.xhtml#ch07list16) shows how to inject
    the code into a binary and hijack a constructor.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-16: Calling injected code by hijacking a constructor*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As before, you begin by copying `/bin/ls` ➊ and injecting the new code into
    the copy ➋, without changing the entry point. Using `readelf`, you can see that
    the `.init_array` section exists ➌.^([3](footnote.xhtml#ch07fn_3)) The `.fini_array`
    section is also there, but in this case I’m hijacking a constructor, not a destructor.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: You can view the contents of `.init_array` using `objdump`, which reveals a
    single constructor function pointer with the value `0x404a70` (stored in little-endian
    format) ➍. Now, you can use `hexedit` to search for this address and change it
    ➎ to the entry address `0x800e78` of your injected code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: After you do this, the single pointer in `.init_array` points to the injected
    code instead of the original constructor ➏. Keep in mind that when this is done,
    the injected code transfers control back to the original constructor. After overwriting
    the constructor pointer, the updated `ls` binary starts by showing the “hello
    world” message and then prints a directory listing as normal ➐. Using this technique,
    you can get code to run once at the start or termination of a binary without having
    to modify its entry point.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '*7.4.3 Hijacking GOT Entries*'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Both of the techniques discussed so far—entry point modification and constructor/destructor
    hijacking—allow the injected code to run only once at startup or at termination
    of the binary. What if you want to invoke the injected function repeatedly, for
    instance, to replace an existing library function? I’ll now show you how to hijack
    a GOT entry to replace a library call with an injected function. Recall from [Chapter
    2](ch02.xhtml#ch02) that the Global Offset Table (GOT) is a table containing pointers
    to shared library functions, used for dynamic linking. Overwriting one or more
    of these entries essentially gives you the same level of control as the `LD_PRELOAD`
    technique but without the need for an external library containing the new function,
    allowing you to keep the binary self-contained. Moreover, GOT hijacking is a suitable
    technique not only for persistent binary modification but also for exploiting
    a binary at runtime.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The GOT hijacking technique requires a slight modification to the injected code,
    as shown in [Listing 7-17](ch07.xhtml#ch07list17).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-17:* hello-got.s'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With GOT hijacking, you’re completely replacing a library function, so there’s
    no need to transfer control back to the original implementation when the injected
    code completes. Thus, [Listing 7-17](ch07.xhtml#ch07list17) doesn’t contain any
    hard-coded address to which it transfers control at the end. Instead, it simply
    ends with a normal return ➊.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at how to implement the GOT hijacking technique in practice.
    [Listing 7-18](ch07.xhtml#ch07list18) shows an example that replaces the GOT entry
    for the `fwrite_unlocked` library function in the `ls` binary with a pointer to
    the “hello world” function, as shown in [Listing 7-17](ch07.xhtml#ch07list17).
    The `fwrite_unlocked` function is the function that `ls` uses to print all of
    its messages to screen.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-18: Calling injected code by hijacking a GOT entry*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After creating a fresh copy of `ls` ➊ and injecting your code into it ➋, you
    can use `objdump` to view the binary’s PLT entries (where the GOT entries are
    used) and find the one for `fwrite_unlocked` ➌. It starts at address `0x402800`,
    and the GOT entry it uses is located at address `0x61e2a0` ➍, which is in the
    `.got.plt` section.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `objdump` to view the `.got.plt` section, you can see the original address
    stored in the GOT entry ➎: `402806` (encoded in little-endian format).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: As explained in [Chapter 2](ch02.xhtml#ch02), this is the address of the next
    instruction in `fwrite_unlocked`’s PLT entry, which you want to overwrite with
    the address of your injected code. Thus, the next step is to start `hexedit`,
    search for the string `062840`, and replace it with the address `0x800e78` of
    your injected code ➏, as usual. You confirm the changes by using `objdump` again
    to view the modified GOT entry ➐.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: After changing the GOT entry to point to your “hello world” function, the `ls`
    program now prints `hello world` every time it invokes `fwrite_unlocked` ➑, replacing
    all of the usual `ls` output with copies of the `"hello world"` string. Of course,
    in real life, you’d want to replace `fwrite_unlocked` with a more useful function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: A benefit of GOT hijacking is that it’s not only straightforward but can also
    be easily done at runtime. This is because, unlike code sections, `.got.plt` is
    writable at runtime. As a result, GOT hijacking is a popular technique not only
    for static binary modifications, as I’ve demonstrated here, but also for exploits
    that aim to change the behavior of a running process.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '*7.4.4 Hijacking PLT Entries*'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next technique for calling injected code, PLT hijacking, is similar to GOT
    hijacking. Like GOT hijacking, PLT hijacking allows you to insert a replacement
    for an existing library function. The only difference is that instead of changing
    the function address stored in a GOT entry used by a PLT stub, you change the
    PLT stub itself. Because this technique involves changing the PLT, which is a
    code section, it’s not suitable for modifying a binary’s behavior at runtime.
    [Listing 7-19](ch07.xhtml#ch07list19) shows how to use the PLT hijacking technique.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 7-19: Calling injected code by hijacking a PLT entry*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As before, start by creating a copy of the `ls` binary ➊ and injecting the new
    code into it ➋. Note that this example uses the same code payload as for the GOT
    hijacking technique. As in the GOT hijacking example, you’ll replace the `fwrite_unlocked`
    library call with the “hello world” function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Using `objdump`, take a look at the PLT entry for `fwrite_unlocked` ➌. But this
    time, you’re not interested in the address of the GOT entry used by the PLT stub.
    Instead, look at the binary encoding of the first instruction of the PLT stub.
    As `objdump` shows, the encoding is `ff259aba2100` ➍, corresponding to an indirect
    `jmp` instruction with an offset relative to the `rip` register. You can hijack
    the PLT entry by overwriting this instruction with another that jumps directly
    to the injected code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Next, using `hexedit`, search for the byte sequence `ff259aba2100` corresponding
    to the first instruction of the PLT stub ➎. Once you’ve found it, replace it with
    `e973e63f00`, which is the encoding for a direct `jmp` to address `0x800e78`,
    where the injected code resides. The first byte, `e9`, of the replacement string
    is the opcode for a direct `jmp`, and the next 4 bytes are an offset to the injected
    code, relative to the `jmp` instruction itself.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'After completing the modifications, disassemble the PLT again, using `objdump`
    to verify the changes ➏. As you can see, the first disassembled instruction of
    the `fwrite_unlocked` PLT entry now reads `jmp 800e78`: a direct jump to the injected
    code. After that, the disassembler shows a few bogus instructions resulting from
    the leftover bytes from the original PLT entry that you didn’t overwrite. The
    bogus instructions are no problem since the first instruction is the only one
    that will ever be executed anyway.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see whether the modifications worked. When you run the modified `ls`
    binary, you can see that the “hello world” message is printed for every invocation
    of the `fwrite_unlocked` function ➐ as expected, creating the same result as the
    GOT hijacking technique.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '*7.4.5 Redirecting Direct and Indirect Calls*'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far, you’ve learned how to run injected code at the start or end of a binary
    or when a library function is invoked. But when you want to use an injected function
    to replace a nonlibrary function, hijacking a GOT or PLT entry doesn’t work. In
    that case, you can use a disassembler to locate the calls you want to modify and
    then overwrite them, using a hex editor to replace them with calls to the injected
    function instead of the original. The hex editing process is the same as for modifying
    a PLT entry, so I won’t repeat the steps here.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: When redirecting an indirect call (as opposed to a direct one), the easiest
    way is to replace the indirect call with a direct one. However, this isn’t always
    possible since the encoding of the direct call may be longer than the encoding
    of the indirect call. In that case, you’ll first need to find the address of the
    indirectly called function that you want to replace, for instance, by using `gdb`
    to set a breakpoint on the indirect call instruction and inspecting the target
    address.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Once you know the address of the function to replace, you can use `objdump`
    or a hex editor to search for the address in the binary’s `.rodata` section. If
    you’re lucky, this may reveal a function pointer containing the target address.
    You can then use a hex editor to overwrite this function pointer, setting it to
    the address of the injected code. If you’re unlucky, the function pointer may
    be computed in some way at runtime, requiring more complex hex editing to replace
    the computed target with the address of the injected function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 7.5 Summary
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to modify ELF binaries using several simple
    techniques: hex editing, `LD_PRELOAD`, and ELF section injection. Because these
    techniques aren’t very flexible, they’re suitable only for making small changes
    to binaries. This chapter should have made clear to you that there’s a real need
    for more general and powerful binary modification techniques. Fortunately, these
    techniques do exist, and I’ll discuss them in [Chapter 9](ch09.xhtml#ch09)!'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Changing the Date Format
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Create a copy of the */bin/date* program and use `hexedit` to change the default
    date format string. You may want to use `strings` to look for the default format
    string.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Limiting the Scope of ls
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Use the `LD_PRELOAD` technique to modify a copy of */bin/ls* such that it will
    show directory listings only for paths within your home directory.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 3\. An ELF Parasite
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Write your own ELF parasite and use `elfinject` to inject it into a program
    of your choice. See whether you can make the parasite fork off a child process
    that opens a backdoor. Bonus points if you can create a modified copy of `ps`
    that doesn’t show the parasite process in the process listing.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
