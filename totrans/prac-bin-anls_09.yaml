- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: SIMPLE CODE INJECTION TECHNIQUES FOR ELF
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ELF的简单代码注入技术
- en: In this chapter, you’ll learn several techniques for injecting code into an
    existing ELF binary, allowing you to modify or augment the binary’s behavior.
    Although the techniques discussed in this chapter are convenient for making small
    modifications, they’re not very flexible. This chapter will demonstrate their
    limitations so you can understand the need for more comprehensive code modification
    techniques, which you’ll learn in [Chapter 9](ch09.xhtml#ch09).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习几种将代码注入现有ELF二进制文件的技术，这些技术可以让你修改或增强二进制文件的行为。尽管本章讨论的技术对于进行小规模修改非常方便，但它们的灵活性较差。本章将展示这些技术的局限性，以便你理解更全面的代码修改技术的必要性，这些技术你将在[第9章](ch09.xhtml#ch09)中学习到。
- en: 7.1 Bare-Metal Binary Modification Using Hex Editing
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1 使用十六进制编辑进行裸金属二进制修改
- en: The most straightforward way to modify an existing binary is by directly editing
    it using a *hex editor*, which is a program that represents the bytes of a binary
    file in hexadecimal format and allows you to edit these bytes. Usually, you’ll
    first use a disassembler to identify the code or data bytes you want to change
    and then use a hex editor to make the changes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 修改现有二进制文件最直接的方法是使用*十六进制编辑器*，这是一种以十六进制格式表示二进制文件字节并允许你编辑这些字节的程序。通常，你会先使用反汇编工具识别你想要更改的代码或数据字节，然后再使用十六进制编辑器进行更改。
- en: 'The advantage of this approach is that it’s simple and requires only basic
    tools. The disadvantage is that it only allows in-place editing: you can change
    code or data bytes but not add anything new. Inserting a new byte causes all the
    bytes after it to shift to another address, which breaks references to the shifted
    bytes. It’s difficult (or even impossible) to correctly identify and fix all the
    broken references, because the relocation information needed for this is usually
    discarded after the linking phase. If the binary contains any padding bytes, dead
    code (such as unused functions), or unused data, you can overwrite those parts
    of the binary with something new. However, this approach is limited since most
    binaries don’t contain a lot of dead bytes that you can safely overwrite.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点在于它简单，只需要基本的工具。缺点是它仅支持就地编辑：你可以更改代码或数据字节，但不能添加任何新的内容。插入新的字节会导致后面的所有字节移到另一个地址，从而破坏对这些字节的引用。由于在链接阶段之后通常会丢弃所需的重定位信息，因此很难（甚至不可能）正确识别和修复所有损坏的引用。如果二进制文件中包含任何填充字节、死代码（如未使用的函数）或未使用的数据，你可以用新内容覆盖这些部分。然而，由于大多数二进制文件中没有很多可以安全覆盖的死字节，这种方法是有限制的。
- en: Still, in some cases hex editing may be all you need. For instance, malware
    uses anti-debugging techniques to check the environment it’s running in for signs
    of analysis software. If the malware suspects it’s being analyzed, it will refuse
    to run or attack the analysis environment. When you’re analyzing a malware sample
    and you suspect that it contains anti-debugging checks, you can disable them using
    hex editing to overwrite the checks with `nop` (do-nothing) instructions. Sometimes,
    you can even fix simple bugs in a program using a hex editor. To show you an example
    of this, I’ll use a hex editor called `hexedit`, an open source editor for Linux
    that comes preinstalled on the virtual machine, to fix an off-by-one bug in a
    simple program.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，十六进制编辑可能是你所需要的一切。例如，恶意软件使用反调试技术来检查它运行的环境是否存在分析软件的痕迹。如果恶意软件怀疑自己正在被分析，它会拒绝运行或攻击分析环境。当你分析一个恶意软件样本并怀疑它包含反调试检查时，你可以使用十六进制编辑禁用这些检查，将检查部分覆盖为`nop`（无操作）指令。有时，你甚至可以通过十六进制编辑器修复程序中的简单错误。为了向你展示一个例子，我将使用名为`hexedit`的十六进制编辑器，它是一个开源编辑器，已在虚拟机上预安装，用于修复一个简单程序中的越界错误。
- en: Finding the Right Opcode
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找正确的操作码
- en: When you’re editing code in a binary, you need to know which values to insert,
    and for that, you need to know the format and hexadecimal encodings of the machine
    instructions. There are handy overviews online of the opcodes and operand formats
    for x86 instructions, such as *[http://ref.x86asm.net](http://ref.x86asm.net)*.
    For more detailed information about how a given x86 instruction works, consult
    the official Intel manual.*^a*
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在二进制文件中编辑代码时，你需要知道要插入哪些值，为此，你需要了解机器指令的格式和十六进制编码。网上有很多关于x86指令的操作码和操作数格式的有用概览，例如*[http://ref.x86asm.net](http://ref.x86asm.net)*。如果你需要更详细的信息来了解某个x86指令如何工作，可以查阅官方的英特尔手册。*^a*
- en: '*a*. *[https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf](https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf)*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*. *[https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf](https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf)*'
- en: '*7.1.1 Observing an Off-by-One Bug in Action*'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*7.1.1 观察越界错误的实际表现*'
- en: '*Off-by-one bugs* typically occur in loops when the programmer uses an erroneous
    loop condition that causes the loop to read or write one too few or one too many
    bytes. The example program in [Listing 7-1](ch07.xhtml#ch07list1) encrypts a file
    but accidentally leaves the last byte unencrypted because of an off-by-one bug.
    To fix this bug, I’ll first use `objdump` to disassemble the binary and locate
    the offending code. Then I’ll use `hexedit` to edit that code and remove the offby-one
    bug.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*越界错误* 通常发生在循环中，当程序员使用了错误的循环条件，导致循环读取或写入少了一个字节或多了一个字节。[列表 7-1](ch07.xhtml#ch07list1)
    中的示例程序加密一个文件，但由于越界错误，不小心将最后一个字节未加密。为了解决这个问题，我将首先使用 `objdump` 反汇编二进制文件并定位到出错的代码。然后我会使用
    `hexedit` 编辑该代码并去除越界错误。'
- en: '*Listing 7-1:* xor_encrypt.c'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-1：* xor_encrypt.c'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After parsing its command line arguments, the program opens the input file to
    encrypt ➊, determines the file size and stores it in a variable called `n` ➋,
    allocates a buffer ➌ to store the file in, reads the entire file into the buffer
    ➍, and then closes the file ➎. If anything goes wrong along the way, the program
    calls the `die` function to print an appropriate error message and exit.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析命令行参数后，程序打开要加密的输入文件 ➊，确定文件大小并将其存储在名为 `n` 的变量中 ➋，分配一个缓冲区 ➌ 用来存储文件，读取整个文件到缓冲区
    ➍，然后关闭文件 ➎。如果在过程中出现任何问题，程序会调用 `die` 函数打印适当的错误信息并退出。
- en: 'The bug is in the next part of the program, which encrypts the file bytes using
    a simple `xor`-based algorithm. The program enters a `for` loop to loop over the
    buffer containing all the file bytes and encrypts each byte by computing its `xor`
    with the provided key ➏. Note the loop condition of the `for` loop: the loop starts
    at `i = 0` but only loops while `i < n-1`. That means the last encrypted byte
    is at index `n-2` in the buffer, so the final byte (at index `n-1`) is left unencrypted!
    This is the off-by-one bug, which we’ll fix using a hex editor to edit the binary.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 错误发生在程序的下一个部分，该部分使用简单的 `xor` 算法加密文件字节。程序进入一个 `for` 循环，遍历包含所有文件字节的缓冲区，并通过与提供的密钥
    ➏ 做 `xor` 运算来加密每个字节。注意 `for` 循环的循环条件：循环从 `i = 0` 开始，但仅当 `i < n-1` 时才会继续。这意味着最后一个加密的字节位于缓冲区的索引
    `n-2` 处，因此最后一个字节（索引为 `n-1`）未被加密！这就是越界错误，我们将使用十六进制编辑器来修复它。
- en: After encrypting the file buffer, the program opens an output file ➐, writes
    the encrypted bytes to it ➑, and finally closes the output file ➒. [Listing 7-2](ch07.xhtml#ch07list2)
    shows an example run of the program (compiled using the Makefile provided on the
    virtual machine) where you can observe the off-by-one bug in action.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密文件缓冲区后，程序打开一个输出文件 ➐，将加密后的字节写入文件 ➑，最后关闭输出文件 ➒。[列表 7-2](ch07.xhtml#ch07list2)
    显示了程序的示例运行（使用虚拟机中提供的 Makefile 编译），可以看到程序中存在越界错误的实际情况。
- en: '*Listing 7-2: Observing the off-by-one bug in the* xor_encrypt *program*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-2：观察 *xor_encrypt* 程序中的越界错误*'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, I’ve used the `xor_encrypt` program to encrypt its own source
    file using the key `foobar`, writing the output to a file called *encrypted* ➊.
    Using `xxd` to view the contents of the original source file ➋, you can see that
    it ends with the byte `0x0a` ➌. In the encrypted file, all bytes are garbled ➍except
    the last one, which is the same as in the original file ➎. This is because the
    off-by-one bug causes the last byte to be left unencrypted.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我使用 `xor_encrypt` 程序用密钥 `foobar` 加密了它自己的源文件，并将输出写入名为 *encrypted* 的文件
    ➊。使用 `xxd` 查看原始源文件的内容 ➋，你会看到它以字节 `0x0a` 结尾 ➌。在加密后的文件中，所有字节都被破坏了 ➍，除了最后一个字节，它与原文件中的字节相同
    ➎。这是因为越界错误导致最后一个字节没有被加密。
- en: '*7.1.2 Fixing the Off-by-One Bug*'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*7.1.2 修复越界错误*'
- en: Now let’s take a look at how to fix the off-by-one bug in the binary. In all
    examples in this chapter, you can pretend you don’t have the source code of the
    binaries you’re editing, even though you really do. This is to simulate real-life
    cases where you’re forced to use binary modification techniques, such as when
    you’re working on a proprietary or malicious program or a program whose source
    code is lost.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何修复二进制文件中的越界错误。在本章的所有示例中，你可以假装没有二进制文件的源代码，尽管实际上你是有的。这是为了模拟现实中你被迫使用二进制修改技术的情况，比如你正在处理专有或恶意程序，或者源代码丢失的程序。
- en: Finding the Bytes That Cause the Bug
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找导致错误的字节
- en: To fix the off-by-one bug, you need to change the loop condition so that it
    loops one more time to encrypt the last byte. Therefore, you first need to disassemble
    the binary and find the instructions responsible for enforcing the loop condition.
    [Listing 7-3](ch07.xhtml#ch07list3) contains the relevant instructions as shown
    by `objdump`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复越界错误，你需要更改循环条件，使其多循环一次以加密最后一个字节。因此，你首先需要反汇编二进制文件，找到负责强制执行循环条件的指令。[清单 7-3](ch07.xhtml#ch07list3)
    包含了相关的指令，正如 `objdump` 所显示的那样。
- en: '*Listing 7-3: Disassembled code showing the off-by-one bug*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-3：显示越界错误的反汇编代码*'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The loop starts at address `0x4007d8` ➊, and the loop counter (`i`) is contained
    in the `rbx` register. You can see the loop counter being incremented in each
    loop iteration ➋. You can also see a `cmp` instruction ➌ that checks whether another
    loop iteration is needed. The `cmp` compares `i` (stored in `rbx`) to the value
    `n-1` (stored in `r12`). If another loop iteration is needed, the `jne` instruction
    ➍ jumps back to the start of the loop. If not, it falls through to the next instruction,
    ending the loop.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 循环从地址 `0x4007d8` ➊ 开始，循环计数器（`i`）存储在 `rbx` 寄存器中。你可以看到循环计数器在每次循环迭代时都会递增 ➋。你还可以看到一个
    `cmp` 指令 ➌，它检查是否需要进行另一轮循环。`cmp` 将 `i`（存储在 `rbx`）与值 `n-1`（存储在 `r12`）进行比较。如果需要进行另一轮循环，`jne`
    指令 ➍ 会跳转回循环开始处。如果不需要，它会跳过，执行下一条指令，结束循环。
- en: 'The `jne` instruction stands for “jump if not equal”^([1](footnote.xhtml#ch07fn_1)):
    it jumps back to the start of the loop if `i` is not equal to `n-1` (as determined
    by the `cmp`). In other words, since `i` is incremented in each loop iteration,
    the loop will run while `i < n-1`. But to fix the off-by-one bug, you want the
    loop to run while `i <= n-1` so that it runs one more time.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`jne` 指令表示“如果不相等则跳转”^([1](footnote.xhtml#ch07fn_1))：当 `i` 不等于 `n-1`（由 `cmp`
    指令确定）时，它会跳转回循环的开始处。换句话说，由于 `i` 在每次循环迭代时都会递增，循环将会在 `i < n-1` 时运行。但为了修复越界错误，你希望循环在
    `i <= n-1` 时运行，这样就能多循环一次。'
- en: Replacing the Offending Bytes
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换有问题的字节
- en: To implement this fix, you can use a hex editor to replace the opcode for the
    `jne` instruction, turning it into a different kind of jump. The `cmp` has `r12`
    (containing `n-1`) as its first operand, followed by `rbx` (containing `i`). Thus,
    you should use a `jae` (“jump if above or equal”) instruction so that the loop
    runs while `n-1 >= i`, which is just another way of saying `i <= n-1`. Now you
    can implement this fix using `hexedit`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个修复，你可以使用十六进制编辑器替换 `jne` 指令的操作码，将其改为另一种跳转指令。`cmp` 的第一个操作数是 `r12`（包含 `n-1`），后面是
    `rbx`（包含 `i`）。因此，你应该使用 `jae`（“如果大于或等于则跳转”）指令，使得循环在 `n-1 >= i` 时继续运行，也就是相当于说 `i
    <= n-1`。现在你可以使用 `hexedit` 实现这个修复。
- en: To follow along, go to the code folder for this chapter, run the Makefile, and
    then type `hexedit xor_encrypt` on the command line and press ENTER to open the
    `xor_encrypt` binary in the hex editor (it’s an interactive program). To find
    the specific bytes to modify, you can search for a byte pattern taken from a disassembler
    like `objdump`. In the case of [Listing 7-3](ch07.xhtml#ch07list3), you can see
    that the `jne` instruction you need to modify is encoded with the hexadecimal
    byte string `75d9`, so you’ll search for that pattern. In larger binaries, you’ll
    want to use longer patterns, possibly including bytes from other instructions,
    to ensure uniqueness. To search for a pattern in `hexedit`, press the / key. This
    should open up a prompt like the one shown in [Figure 7-1](ch07.xhtml#ch07fig1),
    where you can enter the search pattern `75d9` and then press ENTER to start the
    search.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟着操作，请转到本章的代码文件夹，运行 Makefile，然后在命令行中输入 `hexedit xor_encrypt` 并按 ENTER 以在十六进制编辑器中打开
    `xor_encrypt` 二进制文件（这是一个交互式程序）。要查找需要修改的特定字节，你可以搜索来自反汇编器（如 `objdump`）的字节模式。在 [Listing
    7-3](ch07.xhtml#ch07list3) 中，你可以看到需要修改的 `jne` 指令被编码为十六进制字节串 `75d9`，所以你将搜索这个模式。在更大的二进制文件中，你可能需要使用更长的模式，可能包括其他指令的字节，以确保唯一性。要在
    `hexedit` 中搜索模式，按 / 键。这将打开一个提示框，如 [Figure 7-1](ch07.xhtml#ch07fig1) 所示，你可以在其中输入搜索模式
    `75d9`，然后按 ENTER 开始搜索。
- en: '![image](Images/f161-01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f161-01.jpg)'
- en: '*Figure 7-1: Searching for a byte string with* `hexedit`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 7-1：使用* `hexedit` *搜索字节串*'
- en: The search finds the pattern and moves the cursor to the first byte of the pattern.
    Referring to an x86 opcode reference or the Intel x86 manual, you can see that
    the `jne` instruction is encoded as an opcode byte (`0x75`) followed by a byte
    that encodes an offset to the jump location (`0xd9`). For these purposes, you
    just want to replace the `jne` opcode, `0x75`, with the opcode for a `jae` instruction,
    which is `0x73`, leaving the jump offset unchanged. Since the cursor is already
    on the byte you want to modify, all it takes to make the edit is to type the new
    byte value, `73`. As you type, `hexedit` highlights the modified byte value in
    boldface. Now, all that’s left is to save the modified binary by pressing CTRL-X
    to exit and then pressing Y to confirm the change. You’ve now fixed the off-by-one
    bug in the binary! Let’s confirm the change by using `objdump` again, as shown
    in [Listing 7-4](ch07.xhtml#ch07list4).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索会找到模式并将光标移到模式的第一个字节。参考 x86 操作码参考或英特尔 x86 手册，你可以看到 `jne` 指令被编码为一个操作码字节（`0x75`），后跟一个编码跳转位置偏移量的字节（`0xd9`）。为了这些目的，你只需要将
    `jne` 操作码 `0x75` 替换为 `jae` 指令的操作码 `0x73`，而跳转偏移量保持不变。由于光标已经位于你想修改的字节上，编辑所需的只是输入新的字节值
    `73`。在你输入时，`hexedit` 会用粗体突出显示修改过的字节值。现在，剩下的就是按 CTRL-X 退出并按 Y 确认更改来保存修改过的二进制文件。你现在已经修复了二进制文件中的越界错误！让我们通过再次使用
    `objdump` 来确认这个更改，如 [Listing 7-4](ch07.xhtml#ch07list4) 所示。
- en: '*Listing 7-4: Disassembly showing the patch for the off-by-one bug*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 7-4：显示修复越界错误补丁的反汇编*'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the original `jne` instruction is now replaced by `jae` ➊. To
    check that the fix works, let’s run the program again to see whether it encrypts
    the last byte. [Listing 7-5](ch07.xhtml#ch07list5) shows the results.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，原来的 `jne` 指令现在已被 `jae` ➊ 替换。为了检查修复是否有效，让我们再次运行程序，看它是否加密了最后一个字节。[Listing
    7-5](ch07.xhtml#ch07list5) 显示了结果。
- en: '*Listing 7-5: Output of the fixed* xor_encrypt *program*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 7-5：修复后的* xor_encrypt *程序输出*'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As before, you run the `xor_encrypt` program to encrypt its own source code
    ➊. Recall that in the original source file, the last byte’s value was `0x0a` (see
    [Listing 7-2](ch07.xhtml#ch07list2)). Using `xxd` to inspect the encrypted file
    ➋, you can see that even the last byte is now properly encrypted ➌: it’s now `0x65`
    instead of `0x0a`.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，你运行 `xor_encrypt` 程序来加密它自己的源代码 ➊。回想一下，在原始源文件中，最后一个字节的值是 `0x0a`（见 [Listing
    7-2](ch07.xhtml#ch07list2)）。使用 `xxd` 检查加密文件 ➋，你可以看到即使是最后一个字节现在也已正确加密 ➌：它现在是 `0x65`
    而不是 `0x0a`。
- en: You now know how to edit a binary using a hex editor! Although this example
    was simple, the procedure is the same for more complex binaries and edits.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何使用十六进制编辑器编辑二进制文件了！虽然这个例子很简单，但程序对于更复杂的二进制文件和编辑是相同的。
- en: 7.2 Modifying Shared Library Behavior Using LD_PRELOAD
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2 使用 LD_PRELOAD 修改共享库行为
- en: Hex editing is a nice way of making modifications to your binaries because it
    requires only basic tools, and since the modifications are small, edited binaries
    usually have virtually no performance or code/data size overhead compared to the
    original. However, as you’ve seen in the example in the previous section, hex
    editing is also tedious, error-prone, and restrictive because you cannot add new
    code or data. If your goal is to modify the behavior of shared library functions,
    you can achieve this more easily using `LD_PRELOAD`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制编辑是一种修改二进制文件的好方法，因为它只需要基础工具，而且由于修改较小，编辑后的二进制文件通常与原始文件相比几乎没有性能或代码/数据大小的开销。然而，正如你在前一节的示例中看到的，十六进制编辑也很繁琐、容易出错并且有局限性，因为你不能添加新的代码或数据。如果你的目标是修改共享库函数的行为，使用
    `LD_PRELOAD` 可以更轻松地实现。
- en: '`LD_PRELOAD` is the name of an environment variable that influences the behavior
    of the dynamic linker. It allows you to specify one or more libraries for the
    linker to load before any other library, including standard system libraries such
    as *libc.so*. If a preloaded library contains a function with the same name as
    a function in a library loaded later, the first function is the one that will
    be used at runtime. This allows you to *override* library functions (even standard
    library functions like `malloc` or `printf`) with your own versions of those functions.
    This is useful not only for binary modification but also for programs for which
    source code is available, because the ability to modify the behavior of a library
    function can save you the trouble of having to painstakingly modify all points
    in the source where that library function is used. Let’s look at an example of
    how `LD_PRELOAD` can be useful to modify a binary’s behavior.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`LD_PRELOAD` 是一个环境变量的名称，它会影响动态链接器的行为。它允许你指定一个或多个库，在任何其他库加载之前，包括像 *libc.so*
    这样的标准系统库。如果一个预加载的库中包含与稍后加载的库中的某个函数同名的函数，那么运行时将使用第一个函数。这使得你可以用自己实现的版本 *覆盖* 库函数（即使是像
    `malloc` 或 `printf` 这样的标准库函数）。这不仅对二进制修改有用，对于那些源代码可用的程序也很有帮助，因为修改库函数的行为可以避免你费力修改源代码中所有调用该库函数的地方。我们来看一个例子，说明
    `LD_PRELOAD` 如何有助于修改二进制程序的行为。'
- en: '*7.2.1 A Heap Overflow Vulnerability*'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*7.2.1 堆溢出漏洞*'
- en: The program I’ll be modifying in this example is `heapoverflow`, which contains
    a heap overflow vulnerability that you can fix using `LD_PRELOAD`. [Listing 7-6](ch07.xhtml#ch07list6)
    shows the source for the program.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这个示例中修改的程序是 `heapoverflow`，它包含一个堆溢出漏洞，可以通过 `LD_PRELOAD` 来修复。[示例 7-6](ch07.xhtml#ch07list6)
    显示了程序的源代码。
- en: '*Listing 7-6:* heapoverflow.c'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-6:* heapoverflow.c'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `heapoverflow` program takes two command line arguments: a number and a
    string. It takes the given number, interpreting it as a buffer length ➊, and then
    allocates a buffer of that size using `malloc` ➋. Next, it uses `strcpy` ➌ to
    copy the given string into the buffer and then prints the buffer contents to the
    screen. Finally, it deallocates the buffer again using `free` ➍.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`heapoverflow` 程序接受两个命令行参数：一个数字和一个字符串。它将给定的数字作为缓冲区的大小 ➊，然后使用 `malloc` ➋ 分配该大小的缓冲区。接下来，它使用
    `strcpy` ➌ 将给定的字符串复制到缓冲区中，并将缓冲区的内容打印到屏幕上。最后，它使用 `free` ➍ 释放该缓冲区。'
- en: 'The overflow vulnerability is in the `strcpy` operation: since the length of
    the string is never checked, it may be too large to fit into the buffer. If that’s
    the case, the copy will result in a heap overflow, potentially corrupting other
    data on the heap and resulting in a crash or even exploitation of the program.
    But if the given string fits into the buffer, everything works fine, as you can
    see in [Listing 7-7](ch07.xhtml#ch07list7).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 溢出漏洞出现在 `strcpy` 操作中：因为字符串的长度从未检查，所以它可能太大，无法放入缓冲区。如果是这种情况，复制操作将导致堆溢出，可能会破坏堆上的其他数据，并导致崩溃甚至利用程序漏洞。但如果给定的字符串可以适应缓冲区，一切都能正常工作，就像你在
    [示例 7-7](ch07.xhtml#ch07list7) 中看到的那样。
- en: '*Listing 7-7: Behavior of the* heapoverflow *program when given a benign input*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7-7：* heapoverflow *程序在输入正常时的行为*'
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, I’ve told `heapoverflow` to allocate a 13-byte buffer and then copy the
    message “Hello world!” into it ➊. The program allocates the requested buffer,
    copies the message into it, and prints it back to screen as expected, since the
    buffer is exactly large enough to hold the string, including its terminating `NULL`
    character. Let’s examine [Listing 7-8](ch07.xhtml#ch07list8) to see what happens
    if you give a message that doesn’t fit into the buffer.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我告诉 `heapoverflow` 分配一个13字节的缓冲区，然后将消息“Hello world!”复制进去 ➊。程序分配了请求的缓冲区，将消息复制进去，并按预期将其打印到屏幕上，因为该缓冲区刚好足够大，能够容纳字符串，包括其终止的
    `NULL` 字符。让我们检查 [Listing 7-8](ch07.xhtml#ch07list8)，看看如果提供一个无法适应缓冲区的消息会发生什么。
- en: '*Listing 7-8: Crash of the* heapoverflow *program when the input is too long*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 7-8: 输入过长时* heapoverflow *程序崩溃*'
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Again, I’ve told the program to allocate 13 bytes, but now the message is far
    too large to fit into the buffer: it’s a string consisting of 100 *A*s in a row
    ➊. The program allocates the 13-byte buffer as earlier ➋ and then copies the message
    into it and prints it to screen ➌. However, things go wrong when `free` is called
    ➍ to deallocate the buffer: the overflowing message has overwritten metadata on
    the heap that’s used by `malloc` and `free` to keep track of heap buffers. The
    corrupted heap metadata ultimately causes the program to crash ➎. In the worst
    case, overflows like this can allow an attacker to take over the vulnerable program
    using a carefully crafted string for the overflow. Now let’s see how you can detect
    and prevent the overflow using `LD_PRELOAD`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我告诉程序分配13字节，但现在消息太大，无法适应缓冲区：它是一个包含100个 *A* 字符的字符串 ➊。程序如前所述分配了13字节的缓冲区 ➋，然后将消息复制进去并将其打印到屏幕上
    ➌。然而，当调用 `free` 来释放缓冲区时出现问题 ➍：溢出的消息覆盖了堆上的元数据，这些元数据被 `malloc` 和 `free` 用来跟踪堆缓冲区。损坏的堆元数据最终导致程序崩溃
    ➎。最坏的情况是，这种溢出可能使攻击者通过精心构造的溢出字符串接管易受攻击的程序。现在，让我们看看如何使用 `LD_PRELOAD` 来检测和防止溢出。
- en: '*7.2.2 Detecting the Heap Overflow*'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*7.2.2 检测堆溢出*'
- en: The key idea is to implement a shared library that overrides the `malloc` and
    `free` functions so that they internally keep track of the size of all allocated
    buffers and also overrides `strcpy` so that it automatically checks whether the
    buffer is large enough for the string before copying anything. Note that for the
    sake of the example, this idea is oversimplified and should not be used in production
    settings. For example, it doesn’t take into account that buffer sizes can be changed
    using `realloc`, and it uses simple bookkeeping that can track only the last 1,024
    allocated buffers. However, it should be enough to show how you can use `LD_PRELOAD`
    to solve real-world problems. [Listing 7-9](ch07.xhtml#ch07list9) shows the code
    for the library (*heapcheck.c*) containing the alternative `malloc`/`free`/`strcpy`
    implementations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 关键思路是实现一个共享库，重写 `malloc` 和 `free` 函数，使其在内部跟踪所有分配的缓冲区的大小，并且重写 `strcpy`，使其在复制任何内容之前自动检查缓冲区是否足够大以容纳字符串。请注意，为了示例的简单性，这个思路过于简化，不应在生产环境中使用。例如，它没有考虑到缓冲区大小可能通过
    `realloc` 改变，并且使用了简单的记账方法，最多只能追踪最近1,024个分配的缓冲区。然而，它应该足以展示如何使用 `LD_PRELOAD` 来解决现实世界中的问题。[Listing
    7-9](ch07.xhtml#ch07list9) 显示了包含替代 `malloc`/`free`/`strcpy` 实现的库代码 (*heapcheck.c*)。
- en: '*Listing 7-9:* heapcheck.c'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 7-9:* heapcheck.c'
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, note the *dlfcn.h* header ➊, which you’ll often include when writing
    libraries for use with `LD_PRELOAD` because it provides the `dlsym` function.
    You can use `dlsym` to get pointers to shared library functions. In this case,
    I’ll use it to get access to the original `malloc`, `free`, and `strcpy` functions
    to avoid having to reimplement them completely. There’s a set of global function
    pointers that keep track of these original functions as found by `dlsym` ➋.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意到 *dlfcn.h* 头文件 ➊，当你编写供 `LD_PRELOAD` 使用的库时，通常会包含这个头文件，因为它提供了 `dlsym` 函数。你可以使用
    `dlsym` 来获取共享库函数的指针。在这种情况下，我将使用它来访问原始的 `malloc`、`free` 和 `strcpy` 函数，以避免完全重新实现它们。有一组全局函数指针，用来跟踪通过
    `dlsym` 找到的这些原始函数 ➋。
- en: To keep track of the sizes of allocated buffers, I’ve defined a `struct` type
    called `alloc_t`, which can store the address and size of a buffer ➌. I use a
    global circular array of these structures, called `allocs`, to keep track of the
    1,024 most recent allocations ➍.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪分配的缓冲区大小，我定义了一个名为 `alloc_t` 的 `struct` 类型，它可以存储缓冲区的地址和大小 ➌。我使用一个全局的圆形数组来存储这些结构，称为
    `allocs`，用于跟踪最近的1,024次分配 ➍。
- en: Now, let’s take a look at the modified `malloc` function ➎. The first thing
    it does is check whether the pointer to the original (`libc`) version of `malloc`
    (which I call `orig_malloc`) is initialized yet. If not, it calls `dlsym` to look
    up this pointer ➏.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看修改后的`malloc`函数 ➎。它做的第一件事是检查指向原始（`libc`）版本的`malloc`的指针（我称之为`orig_malloc`）是否已经初始化。如果没有，它会调用`dlsym`来查找这个指针
    ➏。
- en: Note that I use the `RTLD_NEXT` flag for `dlsym`, which causes `dlsym` to return
    a pointer to the next version of `malloc` in the chain of shared libraries. When
    you preload a library, it will be at the start of the chain. Thus, the *next*
    version of `malloc`, to which `dlsym` returns a pointer, will be the original
    `libc` version since `libc` is loaded later than your preloaded library.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在`dlsym`中使用了`RTLD_NEXT`标志，这会导致`dlsym`返回链中下一个版本的`malloc`的指针。当你预加载一个库时，它将位于链的开始。因此，`dlsym`返回指针的*下一个*版本的`malloc`将是原始的`libc`版本，因为`libc`会比你的预加载库晚加载。
- en: Next, the modified `malloc` calls `orig_malloc` to do the actual allocation
    ➐ and then stores the address and size of the allocated buffer in the global `allocs`
    array. Now that this information is stored, `strcpy` can later check whether it’s
    safe to copy a string into a given buffer.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改后的`malloc`调用`orig_malloc`来执行实际的分配 ➐，然后将分配的缓冲区的地址和大小存储在全局`allocs`数组中。现在这些信息已经存储，`strcpy`以后可以检查是否可以安全地将字符串复制到给定的缓冲区中。
- en: The new version of `free` is similar to the new `malloc`. It simply resolves
    and calls the original `free` (`orig_free`) and then invalidates the metadata
    for the freed buffer in the `allocs` array ➑.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本的`free`与新的`malloc`类似。它简单地解析并调用原始的`free`（`orig_free`），然后在`allocs`数组中使已释放缓冲区的元数据无效
    ➑。
- en: Finally, let’s look at the new `strcpy` ➒. Again, it starts by resolving the
    original `strcpy` (`orig_strcpy`). However, *before* calling it, it checks whether
    the copy would be safe by searching the global `allocs` array for an entry that
    tells you the size of the destination buffer. If the metadata is found, `strcpy`
    checks whether the buffer would be large enough to accomodate the string ➓. If
    so, it allows the copy. If not, it prints an error message and aborts the program
    to prevent an attacker from exploiting the vulnerability. Note that if no metadata
    is found because the destination buffer wasn’t one of the 1,024 most recent allocations,
    `strcpy` allows the copy. Practically, you would probably want to avoid this situation
    by using a more complex data structure for tracking the metadata, one that isn’t
    limited to 1,024 (or any hard limit) of allocations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下新的`strcpy` ➒。它首先解析原始的`strcpy`（`orig_strcpy`）。然而，*在*调用之前，它会检查通过在全局`allocs`数组中搜索一个条目来确认复制是否安全，该条目会告诉你目标缓冲区的大小。如果找到元数据，`strcpy`会检查缓冲区是否足够大以容纳字符串
    ➓。如果是，它就允许复制。如果不是，它会打印错误消息并终止程序，以防止攻击者利用这个漏洞。请注意，如果没有找到元数据，因为目标缓冲区不是最近1,024次分配之一，`strcpy`会允许复制。实际上，你可能希望通过使用更复杂的数据结构来跟踪元数据，避免这种情况，这种结构不限于1,024个（或任何硬限制的）分配。
- en: '[Listing 7-10](ch07.xhtml#ch07list10) shows how to use the *heapcheck.so* library
    in practice.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-10](ch07.xhtml#ch07list10)展示了如何在实践中使用*heapcheck.so*库。'
- en: '*Listing 7-10: Using the* heapcheck.so *library to prevent heap overflows*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-10：使用* heapcheck.so *库来防止堆溢出*'
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, the important thing to note is the definition of the `LD_PRELOAD` environment
    variable ➊ when starting the `heapoverflow` program. This causes the linker to
    preload the specified library, *heapcheck.so*, which contains the modified `malloc`,
    `free`, and `strcpy` functions. Note that the paths given in `LD_PRELOAD` need
    to be absolute. If you use a relative path, the dynamic linker will fail to find
    the library, and the preload won’t happen.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的关键点是在启动`heapoverflow`程序时定义`LD_PRELOAD`环境变量 ➊。这会导致链接器预加载指定的库，*heapcheck.so*，该库包含修改过的`malloc`、`free`和`strcpy`函数。请注意，`LD_PRELOAD`中给出的路径需要是绝对路径。如果使用相对路径，动态链接器将无法找到该库，预加载也将无法进行。
- en: 'The parameters to the `heapoverflow` program are the same as those in [Listing
    7-8](ch07.xhtml#ch07list8): a 13-byte buffer and a 100-byte string. As you can
    see, now the heap overflow does not cause a crash. The modified `strcpy` successfully
    detects the unsafe copy, prints an error, and safely aborts the program ➋, making
    the vulnerability impossible for an attacker to exploit.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`heapoverflow`程序的参数与[清单7-8](ch07.xhtml#ch07list8)中的相同：一个13字节的缓冲区和一个100字节的字符串。如你所见，现在堆溢出不再导致崩溃。修改后的`strcpy`成功检测到了不安全的拷贝，打印了错误信息，并安全地中止了程序
    ➋，使得攻击者无法利用这个漏洞。'
- en: If you look carefully at the Makefile for the `heapoverflow` program, you’ll
    note that I used `gcc`’s `-fno-builtin` flag to build the program. For essential
    functions like `malloc`, `gcc` sometimes uses built-in versions, which it statically
    links into the compiled program. In this case, I used `-fno-builtin` to make sure
    that doesn’t happen because statically linked functions cannot be overridden using
    `LD_PRELOAD`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仔细查看`heapoverflow`程序的Makefile，你会注意到我使用了`gcc`的`-fno-builtin`标志来构建程序。对于像`malloc`这样的基本函数，`gcc`有时会使用内建版本，将其静态链接到编译后的程序中。在这种情况下，我使用`-fno-builtin`确保不会发生这种情况，因为静态链接的函数不能通过`LD_PRELOAD`进行覆盖。
- en: 7.3 Injecting a Code Section
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3 注入代码段
- en: The binary modification techniques you learned so far are pretty limited in
    their applicability. Hex editing is useful for small modifications, but you can’t
    add much (if any) new code or data. `LD_PRELOAD` allows you to easily add new
    code, but you can use it only to modify library calls. Before exploring more flexible
    binary modification techniques in [Chapter 9](ch09.xhtml#ch09), let’s explore
    how to inject a completely new code section into an ELF binary; this relatively
    simple trick is more flexible than those just discussed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你学到的二进制修改技术在适用性上相对有限。十六进制编辑对于小范围的修改很有用，但你无法添加太多（如果有的话）新代码或数据。`LD_PRELOAD`允许你轻松添加新代码，但它只能用于修改库函数调用。在深入探讨[第9章](ch09.xhtml#ch09)中更灵活的二进制修改技术之前，让我们先来了解如何将一个全新的代码段注入到ELF二进制文件中；这个相对简单的技巧比前面讨论的那些方法更灵活。
- en: On the virtual machine, there’s a complete tool called `elfinject` that implements
    this code injection technique. Because the `elfinject` source code is pretty lengthy,
    I won’t go through it here, but I include an explanation of how `elfinject` is
    implemented in [Appendix B](appb.xhtml) if you’re interested. The appendix also
    doubles as an introduction to `libelf`, a popular open source library for parsing
    ELF binaries. While you won’t need to know `libelf` to understand the rest of
    this book, it can be useful when implementing your own binary analysis tools,
    so I encourage you to read [Appendix B](appb.xhtml).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟机上，有一个完整的工具叫做`elfinject`，它实现了这种代码注入技术。由于`elfinject`的源代码比较长，我在这里不打算详细讲解，但如果你感兴趣，可以在[附录B](appb.xhtml)中找到关于`elfinject`实现的说明。附录还介绍了`libelf`，这是一个流行的开源库，用于解析ELF二进制文件。虽然理解本书剩余部分时不需要了解`libelf`，但在实现你自己的二进制分析工具时，它会非常有用，所以我鼓励你阅读[附录B](appb.xhtml)。
- en: In this section, I’ll give you a high-level overview that explains the main
    steps involved in the code section injection technique. I’ll then show you how
    to use the `elfinject` tool provided on the virtual machine to inject a code section
    into an ELF binary.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将为你提供一个高层次的概述，解释代码段注入技术的主要步骤。接下来，我将向你展示如何使用虚拟机上提供的`elfinject`工具，将代码段注入到ELF二进制文件中。
- en: '*7.3.1 Injecting an ELF Section: A High-Level Overview*'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*7.3.1 注入ELF段：高层次概述*'
- en: '[Figure 7-2](ch07.xhtml#ch07fig2) shows the main steps needed to inject a new
    code section into an ELF. The left side of the figure shows an original (unmodified)
    ELF, while the right side shows the altered file with the new section added, called
    `.injected`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-2](ch07.xhtml#ch07fig2)展示了将新代码段注入ELF所需的主要步骤。图的左侧展示了原始（未修改）ELF文件，而右侧则展示了添加了新段后的修改文件，新的代码段被称为`.injected`。'
- en: To add a new section to an ELF binary, you first inject the bytes that the section
    will contain (step ➊ in [Figure 7-2](ch07.xhtml#ch07fig2)) by appending them to
    the end of the binary. Next, you create a section header ➋ and a program header
    ➌ for the injected section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要向ELF二进制文件添加新段，首先需要注入该段所包含的字节（在[图7-2](ch07.xhtml#ch07fig2)中的步骤➊），将其附加到二进制文件的末尾。接着，你需要为注入的段创建一个段头
    ➋ 和一个程序头 ➌。
- en: As you may recall from [Chapter 2](ch02.xhtml#ch02), the program header table
    is usually located right after the executable header ➍. Because of this, adding
    an extra program header would shift all of the sections and headers that come
    after it. To avoid the need for complex shifting, you can simply overwrite an
    existing one instead of adding a new program header, as shown in [Figure 7-2](ch07.xhtml#ch07fig2).
    This is what `elfinject` implements, and you can apply the same header-overwriting
    trick to avoid adding a new section header to the binary.^([2](footnote.xhtml#ch07fn_2))
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能记得的[第2章](ch02.xhtml#ch02)，程序头表通常位于可执行文件头之后➍。因此，添加一个额外的程序头会使后面的所有段和头部发生偏移。为了避免复杂的偏移操作，你可以简单地覆盖一个现有的程序头，而不是添加一个新的程序头，如[图7-2](ch07.xhtml#ch07fig2)所示。这正是`elfinject`所实现的，你也可以应用相同的头部覆盖技巧，以避免向二进制文件中添加新的段头。^([2](footnote.xhtml#ch07fn_2))
- en: '![image](Images/f170-01.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f170-01.jpg)'
- en: '*Figure 7-2: Replacing* `.note.ABI-tag` *with an injected code section*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-2：将* `.note.ABI-tag` *替换为注入的代码段*'
- en: Overwriting the PT_NOTE Segment
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖PT_NOTE段
- en: As you just saw, it’s easier to overwrite an existing section header and program
    header than to add completely new ones. But how do you know which headers you
    can safely overwrite without breaking the binary? One program header that you
    can always safely overwrite is the `PT_NOTE` header, which describes the `PT_NOTE`
    segment.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你刚才所见，覆盖现有的段头和程序头比添加全新的更为容易。但你如何知道哪些头部可以安全地覆盖，而不会破坏二进制文件呢？一个你可以始终安全覆盖的程序头是`PT_NOTE`头，它描述了`PT_NOTE`段。
- en: The `PT_NOTE` segment encompasses sections that contain auxiliary information
    about the binary. For example, it may tell you that it’s a GNU/Linux binary, what
    kernel version the binary expects, and so on. In the `/bin/ls` executable on the
    virtual machine in particular, the `PT_NOTE` segment contains this information
    in two sections called `.note.ABI-tag` and `.note.gnu.build-id`. If this information
    is missing, the loader simply assumes it’s a native binary, so it’s safe to overwrite
    the `PT_NOTE` header without fear of breaking the binary. This trick is commonly
    used by malicious parasites to infect binaries, but it also works for benign modifications.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`PT_NOTE`段包含有关二进制文件的辅助信息。例如，它可能会告诉你这是一个GNU/Linux二进制文件、该二进制文件期望的内核版本等等。特别是在虚拟机中的`/bin/ls`可执行文件中，`PT_NOTE`段包含了两个部分的信息，分别是`.note.ABI-tag`和`.note.gnu.build-id`。如果这些信息缺失，加载器会默认认为这是一个本地二进制文件，因此可以安全地覆盖`PT_NOTE`头，而不必担心破坏二进制文件。这个技巧通常被恶意软件用来感染二进制文件，但它也可以用于无害的修改。'
- en: Now, let’s consider the changes needed for step ➋ in [Figure 7-2](ch07.xhtml#ch07fig2),
    where you overwrite one of the `.note.*` section headers to turn it into a header
    for your new code section (`.injected`). I’ll (arbitrarily) choose to overwrite
    the header for the `.note.ABI-tag` section. As you can see in [Figure 7-2](ch07.xhtml#ch07fig2),
    I change the `sh_type` from `SHT_NOTE` to `SHT_PROGBITS` to denote that the header
    now describes a code section. Moreover, I change the `sh_addr`, `sh_offset`, and
    `sh_size` fields to describe the location and size of the new `.injected` section
    instead of the now obsolete `.note.ABI-tag` section. Finally, I change the section
    alignment (`sh_addralign`) to 16 bytes to ensure that the code will be properly
    aligned when loaded into memory, and I add the `SHF_EXECINSTR` flag to the `sh_flags`
    field to mark the section as executable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑[图7-2](ch07.xhtml#ch07fig2)中步骤➋所需的更改，你需要覆盖其中一个`.note.*`段头，将其转变为新代码段（`.injected`）的头。我将（任意地）选择覆盖`.note.ABI-tag`段的头部。正如你在[图7-2](ch07.xhtml#ch07fig2)中看到的，我将`sh_type`从`SHT_NOTE`更改为`SHT_PROGBITS`，以表示该头部现在描述的是代码段。此外，我将`sh_addr`、`sh_offset`和`sh_size`字段更改为描述新`.injected`段的位置和大小，而不是已经过时的`.note.ABI-tag`段。最后，我将段对齐（`sh_addralign`）更改为16字节，以确保代码在加载到内存时能够正确对齐，并且我将`SHF_EXECINSTR`标志添加到`sh_flags`字段中，将该段标记为可执行的。
- en: 'The changes for step ➌ are similar, except that here I change the `PT_NOTE`
    program header instead of a section header. Again, I change the header type by
    setting `p_type` to `PT_LOAD` to indicate that the header now describes a loadable
    segment instead of a `PT_NOTE` segment. This causes the loader to load the segment
    (which encompasses the new `.injected` section) into memory when the program starts.
    I also change the required address, offset, and size fields: `p_offset`, `p_vaddr`
    (and `p_paddr`, not shown), `p_filesz`, and `p_memsz`. I set `p_flags` to mark
    the segment as readable and executable, instead of just readable, and I fix the
    alignment (`p_align`).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤➌的更改类似，不过在这里，我更改的是`PT_NOTE`程序头，而不是段头。同样，我通过将`p_type`设置为`PT_LOAD`来更改头类型，以指示该头现在描述的是一个可加载的段，而不是`PT_NOTE`段。这使得加载器在程序启动时将该段（包括新的`.injected`段）加载到内存中。我还更改了所需的地址、偏移量和大小字段：`p_offset`、`p_vaddr`（以及`p_paddr`，未显示）、`p_filesz`和`p_memsz`。我将`p_flags`设置为标记该段为可读且可执行，而不仅仅是可读，并且修正了对齐（`p_align`）。
- en: Although it’s not shown in [Figure 7-2](ch07.xhtml#ch07fig2), it’s nice to also
    update the string table to change the name of the old `.note.ABI-tag` section
    to something like `.injected` to reflect the fact that a new code section was
    added. I discuss this step in detail in [Appendix B](appb.xhtml).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然[图7-2](ch07.xhtml#ch07fig2)中没有显示，但最好也更新字符串表，将旧的`.note.ABI-tag`段的名称更改为像`.injected`这样的名称，以反映新代码段的添加。我在[附录B](appb.xhtml)中详细讨论了这个步骤。
- en: Redirecting the ELF Entry Point
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重定向ELF入口点
- en: Step ➍ in [Figure 7-2](ch07.xhtml#ch07fig2) is optional. In this step, I change
    the `e_entry` field in the ELF executable header to point to an address in the
    new `.injected` section, instead of the original entry point, which is usually
    somewhere in `.text`. You need to do this only if you want some code in the `.injected`
    section to run right at the start of the program. Otherwise, you can just leave
    the entry point as is, though in that case, the new injected code will never run
    unless you redirect some calls in the original `.text` section to injected code,
    use some of the injected code as constructors, or apply another method to reach
    the injected code. I’ll discuss more ways to call into the injected code in [Section
    7.4](ch07.xhtml#ch07_4).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-2](ch07.xhtml#ch07fig2)中的步骤➍是可选的。在这个步骤中，我更改了ELF可执行文件头中的`e_entry`字段，使其指向新的`.injected`段中的一个地址，而不是指向通常位于`.text`中的原始入口点。只有当你希望`.injected`段中的某些代码在程序开始时运行时，你才需要这样做。否则，你可以保持入口点不变，不过在这种情况下，新的注入代码永远不会执行，除非你通过重定向原始`.text`段中的某些调用到注入代码、将一些注入代码用作构造函数，或者使用其他方法来调用注入的代码。我将在[第7.4节](ch07.xhtml#ch07_4)中讨论更多调用注入代码的方法。'
- en: '*7.3.2 Using elfinject to Inject an ELF Section*'
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*7.3.2 使用elfinject注入ELF段*'
- en: To make the `PT_NOTE` injection technique more concrete, let’s look at how to
    use the `elfinject` tool provided on the virtual machine. [Listing 7-11](ch07.xhtml#ch07list11)
    shows how to use `elfinject` to inject a code section into a binary.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更具体地了解`PT_NOTE`注入技术，让我们看看如何使用虚拟机中提供的`elfinject`工具。[清单7-11](ch07.xhtml#ch07list11)展示了如何使用`elfinject`将代码段注入到二进制文件中。
- en: '*Listing 7-11:* elfinject *usage*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单7-11：* elfinject *使用方法*'
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the code folder for this chapter on the virtual machine, you’ll see a file
    called *hello.bin* ➊, which contains the new code you’ll inject in raw binary
    form (without any ELF headers). As you’ll see shortly, the code prints a `hello
    world!` message and then transfers control to the original entry point of the
    host binary, resuming normal execution of the binary. If you’re interested, you
    can find the assembly instructions for the injected code in the file called *hello.s*
    or in [Section 7.4](ch07.xhtml#ch07_4).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章关于虚拟机的代码文件夹中，你会看到一个名为*hello.bin* ➊的文件，其中包含了你将以原始二进制形式注入的新代码（没有任何ELF头）。正如你稍后将看到的，这段代码会打印一个`hello
    world!`消息，然后将控制权转交给主机二进制文件的原始入口点，继续正常执行二进制文件。如果你有兴趣，你可以在名为*hello.s*的文件中找到注入代码的汇编指令，或者在[第7.4节](ch07.xhtml#ch07_4)中找到。
- en: 'Let’s now take a look at the `elfinject` usage ➋. As you can see, `elfinject`
    expects five arguments: a path to a host binary, a path to an inject file, a name
    and an address for the injected section, and an offset to the entry point of the
    injected code (or −1 if it has no entry point). The inject file *hello.bin* is
    injected into the host binary, with the given name, address, and entry point.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`elfinject`的用法➋。如你所见，`elfinject`需要五个参数：一个主机二进制文件的路径，一个注入文件的路径，注入部分的名称和地址，以及注入代码的入口点偏移（如果没有入口点，则为−1）。注入文件*hello.bin*被注入到主机二进制文件中，使用给定的名称、地址和入口点。
- en: I use a copy of `/bin/ls` as a host binary in this example ➌. As you can see,
    `ls` behaves normally before the inject, printing a listing of the current directory
    ➍. You can see with `readelf` that the binary contains a `.note.ABI-tag` section
    ➎ and a `PT_NOTE` segment ➏, which the inject will overwrite.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这个示例中使用了`/bin/ls`的副本作为主机二进制文件➌。如你所见，`ls`在注入前正常工作，打印当前目录的文件列表➍。你可以使用`readelf`看到该二进制文件包含一个`.note.ABI-tag`部分➎和一个`PT_NOTE`段➏，这些将在注入时被覆盖。
- en: Now, it’s time to inject some code. In the example, I use `elfinject` to inject
    the *hello.bin* file into the `ls` binary, using the name `.injected` and load
    address `0x800000` for the injected section (which `elfinject` appends to the
    end of the binary) ➐. I use `0` as the entry point because the entry point of
    *hello.bin* is right at its start.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候注入一些代码了。在这个示例中，我使用`elfinject`将*hello.bin*文件注入到`ls`二进制文件中，使用`.injected`作为注入部分的名称，`0x800000`作为加载地址（`elfinject`会将其附加到二进制文件的末尾）➐。我使用`0`作为入口点，因为*hello.bin*的入口点就在其开头。
- en: After `elfinject` completes successfully, `readelf` shows that the `ls` binary
    now contains a code section called `.injected` ➑ and a new executable segment
    of type `PT_LOAD` ➒ that contains this section. Also, the `.note.ABI-tag` section
    and `PT_NOTE` segment are gone because they have been overwritten. Looks like
    the inject succeeded!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在`elfinject`成功完成后，`readelf`显示`ls`二进制文件现在包含一个名为`.injected`的代码部分➑，以及一个类型为`PT_LOAD`的新的可执行段➒，该段包含了这个代码部分。此外，`.note.ABI-tag`部分和`PT_NOTE`段已经消失，因为它们被覆盖了。看起来注入成功了！
- en: Now, let’s check whether the injected code behaves as expected. Executing the
    modified `ls` binary ➓, you can see that the binary now runs the injected code
    at startup, printing the `hello world!` message. The injected code then passes
    execution to the binary’s original entry point so that it resumes its normal behavior
    of printing a directory listing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查一下注入的代码是否按预期运行。执行修改后的`ls`二进制文件➓，你可以看到该二进制文件现在在启动时运行注入的代码，打印出`hello world!`消息。然后，注入的代码将执行权交给二进制文件的原始入口点，以便恢复正常的行为，即打印目录列表。
- en: 7.4 Calling Injected Code
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4 调用注入的代码
- en: In the previous section, you learned how to use `elfinject` to inject a new
    code section into an existing binary. To get the new code to execute, you modified
    the ELF entry point, causing the new code to run as soon as the loader transfers
    control to the binary. But you may not always want to use the injected code immediately
    when the binary starts. Sometimes, you’ll want to use the injected code for different
    reasons, such as substituting a replacement for an existing function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了如何使用`elfinject`将一个新的代码部分注入到现有的二进制文件中。为了让新的代码执行，你修改了ELF入口点，使得加载器将控制权交给二进制文件时，新的代码能够立即运行。但有时，你可能并不希望在二进制文件启动时立即使用注入的代码。有时，你希望出于不同的原因使用注入的代码，比如替换现有函数。
- en: In this section, I’ll discuss alternative techniques for transferring control
    to the injected code, other than modifying the ELF entry point. I’ll also recap
    the ELF entry point modification technique, this time using only a hex editor
    to change the entry point. This will let you redirect the entry point not only
    to code injected with `elfinject` but also to code that’s been inserted in other
    ways, for instance, by overwriting dead code like padding instructions. Note that
    all of the techniques discussed in this section are suitable for use with any
    code injection method, not just `PT_NOTE` overwriting.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将讨论一些将控制权转交给注入代码的替代技术，而不仅仅是修改ELF入口点。我还将回顾一下ELF入口点修改技术，这次仅使用十六进制编辑器来更改入口点。这将使你能够将入口点重定向到不仅是通过`elfinject`注入的代码，还包括通过其他方式插入的代码，例如通过覆盖死代码（如填充指令）。请注意，本节讨论的所有技术都适用于任何代码注入方法，而不仅仅是`PT_NOTE`覆盖。
- en: '*7.4.1 Entry Point Modification*'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*7.4.1 入口点修改*'
- en: First, let’s briefly recap the ELF entry point modification technique. In the
    following example, I’ll transfer control to a code section injected using `elfinject`,
    but instead of using `elfinject` to update the entry point itself, I’ll use a
    hex editor. This will show you how to generalize the technique to code injected
    in various ways.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们简要回顾一下ELF入口点修改技术。在下面的示例中，我将通过`elfinject`转移控制权到注入的代码部分，但我不会使用`elfinject`更新入口点本身，而是使用十六进制编辑器。这将向你展示如何将此技术泛化到各种方式注入的代码。
- en: '[Listing 7-12](ch07.xhtml#ch07list12) shows the assembly instructions for the
    code I’ll inject. It’s the “hello world” example used in the previous section.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-12](ch07.xhtml#ch07list12)展示了我将注入的代码的汇编指令。它是上一节中使用的“hello world”示例。'
- en: '*Listing 7-12:* hello.s'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-12:* hello.s'
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code is in Intel syntax, intended to be assembled with the `nasm` assembler
    in 64-bit mode ➊. The first few assembly instructions save the `rax`, `rcx`, `rdx`,
    `rsi`, and `rdi` registers by pushing them onto the stack ➋. These registers may
    be clobbered by the kernel, and you’ll want to restore them to their original
    values after the injected code completes to avoid interfering with other code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码采用Intel语法，旨在使用`nasm`汇编器在64位模式下进行汇编 ➊。前几条汇编指令通过将`rax`、`rcx`、`rdx`、`rsi`和`rdi`寄存器推入栈中来保存它们
    ➋。这些寄存器可能会被内核覆盖，你会希望在注入代码完成后恢复它们的原始值，以免干扰其他代码。
- en: 'The next instructions set up the arguments for a `sys_write` system call ➌,
    which will print `hello world!` to the screen. (You’ll find more information on
    all standard Linux system call numbers and arguments in the `syscall man` page.)
    For `sys_write`, the syscall number (which is placed in `rax`) is 1, and there
    are three arguments: the file descriptor to write to (1 for `stdout`), a pointer
    to the string to print, and the length of the string. Now that all the arguments
    are prepared, the `syscall` instruction ➍ invokes the actual system call, printing
    the string.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的指令为`sys_write`系统调用设置参数 ➌，该调用将把`hello world!`打印到屏幕上。（你可以在`syscall man`页面找到所有标准Linux系统调用号和参数的更多信息。）对于`sys_write`，系统调用号（放在`rax`中）是1，且有三个参数：要写入的文件描述符（`stdout`为1）、指向要打印的字符串的指针和字符串的长度。现在，所有参数都已准备好，`syscall`指令
    ➍执行实际的系统调用，打印字符串。
- en: After invoking the `sys_write` system call, the code restores the registers
    to their previously saved state ➎. It then pushes the address `0x4049a0` of the
    original entry point (which I found using `readelf`, as you’ll see shortly) and
    returns to that address, starting execution of the original program ➏.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`sys_write`系统调用后，代码恢复寄存器到先前保存的状态 ➎。然后，它将原始入口点的地址`0x4049a0`（我通过`readelf`找到的，如你将看到的那样）推送到栈上，并返回到该地址，开始执行原始程序
    ➏。
- en: The “hello world” string ➐ is declared after the assembly instructions, along
    with an integer containing the length of the string ➑, both of which are used
    for the `sys_write` system call.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: “hello world”字符串 ➐ 在汇编指令后声明，并附带一个包含字符串长度的整数 ➑，它们都用于`sys_write`系统调用。
- en: To make the code suitable for injection, you need to assemble it into a raw
    binary file that contains nothing more than the binary encodings of the assembly
    instructions and data. This because you don’t want to create a full-fledged ELF
    binary that contains headers and other overhead not needed for the inject. To
    assemble *hello.s* into a raw binary file, you can use the `nasm` assembler’s
    `-f bin` option, as shown in [Listing 7-13](ch07.xhtml#ch07list13). The *Makefile*
    for this chapter comes with a *hello.bin* target that automatically runs this
    command.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码适合注入，你需要将它汇编成一个原始二进制文件，该文件只包含汇编指令和数据的二进制编码。这是因为你不想创建一个包含头部和其他不需要的开销的完整ELF二进制文件。要将*hello.s*汇编成原始二进制文件，可以使用`nasm`汇编器的`-f
    bin`选项，如[清单 7-13](ch07.xhtml#ch07list13)所示。本章的*Makefile*包含一个*hello.bin*目标，自动运行此命令。
- en: '*Listing 7-13: Assembling* hello.s *into* hello.bin *using* nasm'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-13：使用nasm将*hello.s*汇编成*hello.bin*'
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This creates the file *hello.bin*, which contains the raw binary instructions
    and data suitable for injection. Now let’s use `elfinject` to inject this file
    and redirect the ELF entry point using a hex editor so that the injected code
    runs on startup of the binary. [Listing 7-14](ch07.xhtml#ch07list14) shows how
    to do this.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建文件*hello.bin*，其中包含适合注入的原始二进制指令和数据。现在，让我们使用`elfinject`注入此文件，并使用十六进制编辑器重定向ELF入口点，使得注入的代码在二进制启动时运行。[清单
    7-14](ch07.xhtml#ch07list14)展示了如何操作。
- en: '*Listing 7-14: Calling injected code by overwriting the ELF entry point*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单7-14：通过覆盖ELF入口点调用注入的代码*'
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'First, copy the `/bin/ls` binary into `ls.entry` ➊. This will serve as a host
    binary for the inject. Then you can use `elfinject` to inject the just-prepared
    code into the binary with load address `0x800000` ➋, exactly as discussed in [Section
    7.3.2](ch07.xhtml#ch07_3_2), with one crucial difference: set the last `elfinject`
    argument to −1 so that `elfinject` leaves the entry point unmodified (because
    you’ll overwrite it manually).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将`/bin/ls`二进制文件复制到`ls.entry`中 ➊。这将作为注入程序的宿主二进制文件。然后，你可以使用`elfinject`将刚刚准备好的代码注入二进制文件，加载地址为`0x800000`
    ➋，正如在[第7.3.2节](ch07.xhtml#ch07_3_2)中讨论的那样，唯一的关键区别是：将最后一个`elfinject`参数设置为-1，这样`elfinject`就不会修改入口点（因为你将手动覆盖它）。
- en: 'With `readelf`, you can see the original entry point of the binary: `0x4049a0`
    ➌. Note that this is the address that the injected code jumps to when it’s done
    printing the `hello world` message, as shown in [Listing 7-12](ch07.xhtml#ch07list12).
    You can also see with `readelf` that the injected section actually starts at the
    address `0x800e78` ➍ instead of the address `0x800000`. This is because `elfinject`
    slightly changed the address to meet the alignment requirements of the ELF format,
    as I discuss in more detail in [Appendix B](appb.xhtml). What’s important here
    is that `0x800e78` is the new address you’ll want to use to overwrite the entry
    point address with.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`readelf`，你可以看到二进制文件的原始入口点：`0x4049a0` ➌。注意，这是注入的代码在打印`hello world`信息后跳转到的地址，如[清单7-12](ch07.xhtml#ch07list12)所示。你还可以使用`readelf`看到注入的部分实际上是从地址`0x800e78`
    ➍开始的，而不是地址`0x800000`。这是因为`elfinject`略微更改了地址，以满足ELF格式的对齐要求，正如我在[附录B](appb.xhtml)中更详细地讨论的那样。这里需要注意的是，`0x800e78`是你要用来覆盖入口点地址的新地址。
- en: 'Because the entry point is still unmodified, if you run `ls.entry` now, it
    simply behaves like the normal `ls` command without the added “hello world” message
    at the start ➎. To modify the entry point, you open up the `ls.entry` binary in
    `hexedit` ➏ and search for the original entry point address. Recall that you can
    open the search dialog in `hexedit` using the / key and then enter the address
    to search for. The address is stored in little-endian format, so you’ll need to
    search for the bytes `a04940` instead of `4049a0`. After you’ve found the entry
    point, overwrite it with the new one, again with the byte order reversed: `780e80`.
    Now, press CTRL-X to exit and press Y to save your changes.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因为入口点仍然未被修改，如果现在运行`ls.entry`，它的行为就像正常的`ls`命令，只是没有添加开头的“hello world”信息 ➎。要修改入口点，打开`ls.entry`二进制文件，使用`hexedit`
    ➏并搜索原始入口点地址。记住，你可以在`hexedit`中使用/键打开搜索对话框，然后输入要搜索的地址。地址是以小端格式存储的，因此你需要搜索字节`a04940`而不是`4049a0`。找到入口点后，用新的入口点地址覆盖它，同样需要反转字节顺序：`780e80`。然后，按CTRL-X退出，并按Y保存更改。
- en: You can now see with `readelf` that the entry point is updated to `0x800e78`
    ➐, pointing to the start of the injected code. Now when you run `ls.entry`, it
    prints `hello world` before showing the directory listing ➑. You’ve successfully
    overwritten the entry point!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`readelf`看到入口点已更新为`0x800e78` ➐，指向注入代码的起始位置。现在，当你运行`ls.entry`时，它会在显示目录列表之前先打印`hello
    world` ➑。你已经成功地覆盖了入口点！
- en: '*7.4.2 Hijacking Constructors and Destructors*'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*7.4.2 劫持构造函数和析构函数*'
- en: Now let’s take a look at another way to ensure your injected code gets called
    once during the lifetime of the binary, either at the start or end of execution.
    Recall from [Chapter 2](ch02.xhtml#ch02) that x86 ELF binaries compiled with `gcc`
    contain sections called `.init_array` and `.fini_array`, which contain pointers
    to a series of constructors and destructors, respectively. By overwriting one
    of these pointers, you can cause the injected code to be invoked before or after
    the binary’s `main` function, depending on whether you overwrite a constructor
    or a destructor pointer.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下另一种确保注入的代码在二进制程序生命周期内运行一次的方法，无论是在执行开始时还是结束时。回顾[第2章](ch02.xhtml#ch02)，使用`gcc`编译的x86
    ELF二进制文件包含名为`.init_array`和`.fini_array`的部分，它们分别包含构造函数和析构函数的指针。通过覆盖其中一个指针，你可以使注入的代码在二进制文件的`main`函数之前或之后被调用，具体取决于你是覆盖构造函数指针还是析构函数指针。
- en: Of course, after the injected code completes, you’ll want to transfer control
    back to the constructor or destructor that you hijacked. This requires some small
    changes to the injected code, as shown in [Listing 7-15](ch07.xhtml#ch07list15).
    In this listing, I assume you’ll pass control back to a specific constructor whose
    address you’ll find using `objdump`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在注入的代码完成后，你需要将控制权转回你劫持的构造函数或析构函数。这需要对注入的代码进行一些小的修改，如[清单7-15](ch07.xhtml#ch07list15)所示。在这个清单中，我假设你将控制权传回一个特定的构造函数，其地址可以通过`objdump`查找。
- en: '*Listing 7-15:* hello-ctor.s'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单7-15:* hello-ctor.s'
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code shown in [Listing 7-15](ch07.xhtml#ch07list15) is the same as the code
    in [Listing 7-12](ch07.xhtml#ch07list12), except that I’ve inserted the address
    of the hijacked constructor to return to ➊ instead of the entry point address.
    The command to assemble the code into a raw binary file is the same as discussed
    in the previous section. [Listing 7-16](ch07.xhtml#ch07list16) shows how to inject
    the code into a binary and hijack a constructor.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单7-15](ch07.xhtml#ch07list15)中显示的代码与[清单7-12](ch07.xhtml#ch07list12)中的代码相同，唯一不同的是我插入了劫持的构造函数的地址，以便返回到➊，而不是入口点地址。将代码组装成原始二进制文件的命令与上一节中讨论的相同。[清单7-16](ch07.xhtml#ch07list16)展示了如何将代码注入到二进制文件并劫持构造函数。'
- en: '*Listing 7-16: Calling injected code by hijacking a constructor*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单7-16: 通过劫持构造函数调用注入的代码*'
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As before, you begin by copying `/bin/ls` ➊ and injecting the new code into
    the copy ➋, without changing the entry point. Using `readelf`, you can see that
    the `.init_array` section exists ➌.^([3](footnote.xhtml#ch07fn_3)) The `.fini_array`
    section is also there, but in this case I’m hijacking a constructor, not a destructor.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如之前一样，你首先复制`/bin/ls` ➊，并将新代码注入到副本中 ➋，而不更改入口点。使用`readelf`可以看到`.init_array`段的存在
    ➌。^([3](footnote.xhtml#ch07fn_3)) `.fini_array`段也存在，但在这个例子中，我劫持的是构造函数，而不是析构函数。
- en: You can view the contents of `.init_array` using `objdump`, which reveals a
    single constructor function pointer with the value `0x404a70` (stored in little-endian
    format) ➍. Now, you can use `hexedit` to search for this address and change it
    ➎ to the entry address `0x800e78` of your injected code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`objdump`查看`.init_array`的内容，里面显示了一个构造函数指针，值为`0x404a70`（以小端格式存储）➍。现在，你可以使用`hexedit`查找这个地址并将其更改为注入代码的入口地址`0x800e78`➎。
- en: After you do this, the single pointer in `.init_array` points to the injected
    code instead of the original constructor ➏. Keep in mind that when this is done,
    the injected code transfers control back to the original constructor. After overwriting
    the constructor pointer, the updated `ls` binary starts by showing the “hello
    world” message and then prints a directory listing as normal ➐. Using this technique,
    you can get code to run once at the start or termination of a binary without having
    to modify its entry point.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，`.init_array`中的唯一指针将指向注入的代码，而不是原始构造函数 ➏。请记住，完成此操作后，注入的代码会将控制权返回到原始构造函数。覆盖构造函数指针后，更新后的`ls`二进制文件首先会显示“hello
    world”消息，然后像正常一样打印目录列表 ➐。通过这种技术，你可以在不修改入口点的情况下，让代码在二进制文件的启动或终止时运行一次。
- en: '*7.4.3 Hijacking GOT Entries*'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*7.4.3 劫持GOT条目*'
- en: Both of the techniques discussed so far—entry point modification and constructor/destructor
    hijacking—allow the injected code to run only once at startup or at termination
    of the binary. What if you want to invoke the injected function repeatedly, for
    instance, to replace an existing library function? I’ll now show you how to hijack
    a GOT entry to replace a library call with an injected function. Recall from [Chapter
    2](ch02.xhtml#ch02) that the Global Offset Table (GOT) is a table containing pointers
    to shared library functions, used for dynamic linking. Overwriting one or more
    of these entries essentially gives you the same level of control as the `LD_PRELOAD`
    technique but without the need for an external library containing the new function,
    allowing you to keep the binary self-contained. Moreover, GOT hijacking is a suitable
    technique not only for persistent binary modification but also for exploiting
    a binary at runtime.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止讨论的两种技术——入口点修改和构造函数/析构函数劫持——都仅允许注入的代码在二进制文件启动时或终止时运行一次。那么，如果你想多次调用注入的函数，比如替换现有的库函数，该怎么办呢？接下来，我将展示如何劫持一个GOT条目，将库调用替换为注入的函数。回顾[第2章](ch02.xhtml#ch02)，全局偏移表（GOT）是一个包含指向共享库函数的指针的表，用于动态链接。覆盖这些条目中的一个或多个，基本上可以让你获得与`LD_PRELOAD`技术相同的控制级别，但不需要包含新函数的外部库，从而使得二进制文件保持自包含。此外，GOT劫持不仅适用于持久的二进制修改，而且在运行时利用二进制文件也非常合适。
- en: The GOT hijacking technique requires a slight modification to the injected code,
    as shown in [Listing 7-17](ch07.xhtml#ch07list17).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: GOT劫持技术需要对注入代码进行轻微修改，如[列表 7-17](ch07.xhtml#ch07list17)所示。
- en: '*Listing 7-17:* hello-got.s'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-17:* hello-got.s'
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With GOT hijacking, you’re completely replacing a library function, so there’s
    no need to transfer control back to the original implementation when the injected
    code completes. Thus, [Listing 7-17](ch07.xhtml#ch07list17) doesn’t contain any
    hard-coded address to which it transfers control at the end. Instead, it simply
    ends with a normal return ➊.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过GOT劫持，你完全替换了一个库函数，因此注入代码完成后无需将控制权转回原始实现。因此，[列表 7-17](ch07.xhtml#ch07list17)中没有包含任何硬编码的地址来转移控制。相反，它只是以正常的返回结束
    ➊。
- en: Let’s take a look at how to implement the GOT hijacking technique in practice.
    [Listing 7-18](ch07.xhtml#ch07list18) shows an example that replaces the GOT entry
    for the `fwrite_unlocked` library function in the `ls` binary with a pointer to
    the “hello world” function, as shown in [Listing 7-17](ch07.xhtml#ch07list17).
    The `fwrite_unlocked` function is the function that `ls` uses to print all of
    its messages to screen.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何在实践中实现GOT劫持技术。[列表 7-18](ch07.xhtml#ch07list18)展示了一个示例，该示例将`ls`二进制文件中`fwrite_unlocked`库函数的GOT条目替换为指向“hello
    world”函数的指针，如[列表 7-17](ch07.xhtml#ch07list17)所示。`fwrite_unlocked`是`ls`用来将所有消息打印到屏幕上的函数。
- en: '*Listing 7-18: Calling injected code by hijacking a GOT entry*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-18: 通过劫持GOT条目调用注入代码*'
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After creating a fresh copy of `ls` ➊ and injecting your code into it ➋, you
    can use `objdump` to view the binary’s PLT entries (where the GOT entries are
    used) and find the one for `fwrite_unlocked` ➌. It starts at address `0x402800`,
    and the GOT entry it uses is located at address `0x61e2a0` ➍, which is in the
    `.got.plt` section.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`ls`的全新副本 ➊ 并将代码注入其中 ➋ 后，你可以使用`objdump`查看二进制文件的PLT条目（GOT条目在此处使用），并找到`fwrite_unlocked`的条目
    ➌。它从地址`0x402800`开始，使用的GOT条目位于地址`0x61e2a0` ➍，该地址在`.got.plt`段中。
- en: 'Using `objdump` to view the `.got.plt` section, you can see the original address
    stored in the GOT entry ➎: `402806` (encoded in little-endian format).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`objdump`查看`.got.plt`段，你可以看到存储在GOT条目中的原始地址 ➎：`402806`（以小端格式编码）。
- en: As explained in [Chapter 2](ch02.xhtml#ch02), this is the address of the next
    instruction in `fwrite_unlocked`’s PLT entry, which you want to overwrite with
    the address of your injected code. Thus, the next step is to start `hexedit`,
    search for the string `062840`, and replace it with the address `0x800e78` of
    your injected code ➏, as usual. You confirm the changes by using `objdump` again
    to view the modified GOT entry ➐.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第2章](ch02.xhtml#ch02)所述，这是`fwrite_unlocked`在PLT条目中下一条指令的地址，你想用注入代码的地址来覆盖它。因此，下一步是启动`hexedit`，搜索字符串`062840`，并将其替换为注入代码地址`0x800e78`
    ➏，像往常一样确认更改。你可以通过再次使用`objdump`查看修改后的GOT条目 ➐。
- en: After changing the GOT entry to point to your “hello world” function, the `ls`
    program now prints `hello world` every time it invokes `fwrite_unlocked` ➑, replacing
    all of the usual `ls` output with copies of the `"hello world"` string. Of course,
    in real life, you’d want to replace `fwrite_unlocked` with a more useful function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在将GOT条目修改为指向你的“hello world”函数后，每次`ls`程序调用`fwrite_unlocked`时，都会打印`hello world`➑，并将所有常规的`ls`输出替换为“hello
    world”字符串的副本。当然，实际情况下，你可能希望将`fwrite_unlocked`替换为一个更有用的函数。
- en: A benefit of GOT hijacking is that it’s not only straightforward but can also
    be easily done at runtime. This is because, unlike code sections, `.got.plt` is
    writable at runtime. As a result, GOT hijacking is a popular technique not only
    for static binary modifications, as I’ve demonstrated here, but also for exploits
    that aim to change the behavior of a running process.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: GOT劫持的一个好处是，它不仅简单直观，而且可以在运行时轻松完成。这是因为与代码段不同，`.got.plt`在运行时是可写的。因此，GOT劫持不仅是静态二进制修改中的一种流行技术，如我在这里演示的，还广泛应用于旨在改变正在运行的进程行为的漏洞利用中。
- en: '*7.4.4 Hijacking PLT Entries*'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*7.4.4 劫持PLT条目*'
- en: The next technique for calling injected code, PLT hijacking, is similar to GOT
    hijacking. Like GOT hijacking, PLT hijacking allows you to insert a replacement
    for an existing library function. The only difference is that instead of changing
    the function address stored in a GOT entry used by a PLT stub, you change the
    PLT stub itself. Because this technique involves changing the PLT, which is a
    code section, it’s not suitable for modifying a binary’s behavior at runtime.
    [Listing 7-19](ch07.xhtml#ch07list19) shows how to use the PLT hijacking technique.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 下一种调用注入代码的技术是PLT劫持，它与GOT劫持类似。与GOT劫持一样，PLT劫持允许你插入一个替代已有库函数的代码。唯一的区别在于，你不是修改PLT存根使用的GOT条目中的函数地址，而是直接修改PLT存根本身。由于该技术涉及修改PLT（它是一个代码段），因此不适用于在运行时修改二进制的行为。[Listing
    7-19](ch07.xhtml#ch07list19)展示了如何使用PLT劫持技术。
- en: '*Listing 7-19: Calling injected code by hijacking a PLT entry*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 7-19：通过劫持PLT条目调用注入代码*'
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As before, start by creating a copy of the `ls` binary ➊ and injecting the new
    code into it ➋. Note that this example uses the same code payload as for the GOT
    hijacking technique. As in the GOT hijacking example, you’ll replace the `fwrite_unlocked`
    library call with the “hello world” function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如之前所述，首先创建`ls`二进制文件的副本➊，并将新代码注入其中➋。请注意，此示例使用与GOT劫持技术相同的代码载荷。如同GOT劫持示例一样，你将用“hello
    world”函数替换`fwrite_unlocked`库调用。
- en: Using `objdump`, take a look at the PLT entry for `fwrite_unlocked` ➌. But this
    time, you’re not interested in the address of the GOT entry used by the PLT stub.
    Instead, look at the binary encoding of the first instruction of the PLT stub.
    As `objdump` shows, the encoding is `ff259aba2100` ➍, corresponding to an indirect
    `jmp` instruction with an offset relative to the `rip` register. You can hijack
    the PLT entry by overwriting this instruction with another that jumps directly
    to the injected code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`objdump`查看`fwrite_unlocked`的PLT条目➌。但这次，你不是关注PLT存根使用的GOT条目的地址，而是查看PLT存根第一条指令的二进制编码。如`objdump`所示，编码为`ff259aba2100`
    ➍，对应一个相对于`rip`寄存器的间接`jmp`指令。你可以通过用另一个指令覆盖此指令，从而直接跳转到注入的代码，来劫持PLT条目。
- en: Next, using `hexedit`, search for the byte sequence `ff259aba2100` corresponding
    to the first instruction of the PLT stub ➎. Once you’ve found it, replace it with
    `e973e63f00`, which is the encoding for a direct `jmp` to address `0x800e78`,
    where the injected code resides. The first byte, `e9`, of the replacement string
    is the opcode for a direct `jmp`, and the next 4 bytes are an offset to the injected
    code, relative to the `jmp` instruction itself.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`hexedit`，搜索与PLT存根第一条指令`ff259aba2100`对应的字节序列➎。一旦找到它，将其替换为`e973e63f00`，该编码表示一个直接跳转（`jmp`）到地址`0x800e78`，即注入代码所在的位置。替换字符串的第一个字节`e9`是直接`jmp`的操作码，接下来的4个字节是相对于`jmp`指令本身的偏移量，指向注入的代码。
- en: 'After completing the modifications, disassemble the PLT again, using `objdump`
    to verify the changes ➏. As you can see, the first disassembled instruction of
    the `fwrite_unlocked` PLT entry now reads `jmp 800e78`: a direct jump to the injected
    code. After that, the disassembler shows a few bogus instructions resulting from
    the leftover bytes from the original PLT entry that you didn’t overwrite. The
    bogus instructions are no problem since the first instruction is the only one
    that will ever be executed anyway.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 完成修改后，再次使用`objdump`反汇编PLT，验证修改结果➏。正如你所看到的，`fwrite_unlocked`的PLT条目的第一条反汇编指令现在是`jmp
    800e78`：直接跳转到注入的代码。之后，反汇编器显示一些伪指令，它们是原始PLT条目中没有被覆盖的剩余字节产生的伪指令。由于第一条指令是唯一会被执行的指令，因此这些伪指令并不成问题。
- en: Now, let’s see whether the modifications worked. When you run the modified `ls`
    binary, you can see that the “hello world” message is printed for every invocation
    of the `fwrite_unlocked` function ➐ as expected, creating the same result as the
    GOT hijacking technique.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下修改是否生效。当你运行修改后的`ls`二进制文件时，你会看到每次调用`fwrite_unlocked`函数时都会打印“hello world”消息➐，正如预期的那样，产生与GOT劫持技术相同的结果。
- en: '*7.4.5 Redirecting Direct and Indirect Calls*'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*7.4.5 重定向直接和间接调用*'
- en: So far, you’ve learned how to run injected code at the start or end of a binary
    or when a library function is invoked. But when you want to use an injected function
    to replace a nonlibrary function, hijacking a GOT or PLT entry doesn’t work. In
    that case, you can use a disassembler to locate the calls you want to modify and
    then overwrite them, using a hex editor to replace them with calls to the injected
    function instead of the original. The hex editing process is the same as for modifying
    a PLT entry, so I won’t repeat the steps here.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了如何在二进制文件的开始或结束时，或者在调用库函数时运行注入的代码。但当你想使用注入的函数替换非库函数时，劫持GOT或PLT条目就不起作用。在这种情况下，你可以使用反汇编工具定位你想修改的调用，然后覆盖它们，使用十六进制编辑器将其替换为调用注入函数，而不是原始函数。十六进制编辑过程与修改PLT条目相同，因此我不会在这里重复步骤。
- en: When redirecting an indirect call (as opposed to a direct one), the easiest
    way is to replace the indirect call with a direct one. However, this isn’t always
    possible since the encoding of the direct call may be longer than the encoding
    of the indirect call. In that case, you’ll first need to find the address of the
    indirectly called function that you want to replace, for instance, by using `gdb`
    to set a breakpoint on the indirect call instruction and inspecting the target
    address.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当重定向间接调用（与直接调用相对）时，最简单的方法是将间接调用替换为直接调用。然而，这并不总是可行的，因为直接调用的编码可能比间接调用的编码长。在这种情况下，你首先需要找到你想替换的间接调用函数的地址，例如，通过使用`gdb`在间接调用指令上设置断点并检查目标地址。
- en: Once you know the address of the function to replace, you can use `objdump`
    or a hex editor to search for the address in the binary’s `.rodata` section. If
    you’re lucky, this may reveal a function pointer containing the target address.
    You can then use a hex editor to overwrite this function pointer, setting it to
    the address of the injected code. If you’re unlucky, the function pointer may
    be computed in some way at runtime, requiring more complex hex editing to replace
    the computed target with the address of the injected function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道了要替换的函数的地址，你可以使用`objdump`或十六进制编辑器在二进制文件的`.rodata`段中搜索该地址。如果运气好的话，这可能会显示包含目标地址的函数指针。然后你可以使用十六进制编辑器覆盖这个函数指针，将其设置为注入代码的地址。如果运气不好，函数指针可能会在运行时以某种方式计算出来，这需要更复杂的十六进制编辑来将计算出的目标替换为注入函数的地址。
- en: 7.5 Summary
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5 小结
- en: 'In this chapter, you learned how to modify ELF binaries using several simple
    techniques: hex editing, `LD_PRELOAD`, and ELF section injection. Because these
    techniques aren’t very flexible, they’re suitable only for making small changes
    to binaries. This chapter should have made clear to you that there’s a real need
    for more general and powerful binary modification techniques. Fortunately, these
    techniques do exist, and I’ll discuss them in [Chapter 9](ch09.xhtml#ch09)!'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用几种简单的技术修改ELF二进制文件：十六进制编辑、`LD_PRELOAD`和ELF段注入。由于这些技术的灵活性较差，它们仅适用于对二进制文件进行小规模修改。本章应该让你意识到，实际上有需求需要更通用、更强大的二进制修改技术。幸运的是，这些技术确实存在，我将在[第9章](ch09.xhtml#ch09)中讨论它们！
- en: Exercises
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: 1\. Changing the Date Format
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 更改日期格式
- en: Create a copy of the */bin/date* program and use `hexedit` to change the default
    date format string. You may want to use `strings` to look for the default format
    string.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一份 */bin/date* 程序的副本，并使用 `hexedit` 更改默认日期格式字符串。你可能需要使用 `strings` 查找默认的格式字符串。
- en: 2\. Limiting the Scope of ls
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 限制 ls 的作用范围
- en: Use the `LD_PRELOAD` technique to modify a copy of */bin/ls* such that it will
    show directory listings only for paths within your home directory.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `LD_PRELOAD` 技术修改一份 */bin/ls* 的副本，使其仅显示你主目录路径下的目录列表。
- en: 3\. An ELF Parasite
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 一个 ELF 寄生虫
- en: Write your own ELF parasite and use `elfinject` to inject it into a program
    of your choice. See whether you can make the parasite fork off a child process
    that opens a backdoor. Bonus points if you can create a modified copy of `ps`
    that doesn’t show the parasite process in the process listing.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 编写你自己的 ELF 寄生虫，并使用 `elfinject` 将其注入到你选择的程序中。看看你能否让寄生虫分叉出一个子进程并打开后门。如果你能创建一个修改版的
    `ps`，使其不在进程列表中显示寄生虫进程，则可以获得额外积分。
