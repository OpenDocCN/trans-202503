<html><head></head><body>
<h2 class="h2" id="ch9"><span epub:type="pagebreak" id="page_197"/><span class="big"><strong>9</strong></span></h2>&#13;
<h2 class="h2a">PAINT COLORFUL BUBBLES WITH YOUR MOUSE!</h2>&#13;
<div class="image21"><img src="../images/circle.jpg" alt="Image"/></div>&#13;
<p class="noindent">In the next three chapters, we’ll build BubbleDraw, an interactive, animated drawing app that lets the user draw floating, bouncy, colorful bubbles with their mouse in the desktop version and with their fingers in the mobile version!</p>&#13;
<p class="indent">The first version of the BubbleDraw app will look like <a href="ch9.xhtml#ch9fig1">Figure 9-1</a>, with each bubble in a different random color. It will let the user draw bubbles of random colors whenever they click and drag the mouse on the app window. The user will also be able to change the size of the bubbles by scrolling the mouse wheel up and down or by using a scroll gesture on a trackpad or touchscreen.</p>&#13;
<div class="imagef"><span epub:type="pagebreak" id="page_198"/><img src="../images/f0198-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch9fig1"/>Figure 9-1: The BubbleDraw app lets the user draw randomly colored bubbles using the mouse.</em></p>&#13;
<p class="indent">We’re going to use an object-oriented programming approach to build the BubbleDraw app. The variables, functions, loops, and conditional statements you’ve learned so far are known as <em>procedural programming</em>. Procedural programming involves writing programs step-by-step in a linear fashion, sort of like following a recipe. Object-oriented programming uses all of these concepts, but it allows us to program much larger and more complicated applications by breaking a big software project into smaller pieces called <em>objects</em>.</p>&#13;
<p class="indent">As an example, a bubble is an important entity in the BubbleDraw app, so bubbles might become objects as we begin to code this app. First, we’ll tackle the problem of defining what a bubble is. Second, we’ll figure out a way to store information on lots of bubbles and how to draw the bubbles on the screen. Finally, we’ll add the ability to click and drag the mouse to create bubbles. Instead of writing separate pieces of code to control each bubble individually, we’ll write one piece of code that applies to all bubble objects.</p>&#13;
<p class="indent">We’ll begin with two source code files: one for the app window called <em>BubbleDraw</em> and one for the drawing canvas called <em>BubblePanel</em>. The app window will extend a familiar class, <code>JFrame</code>, and the drawing canvas inside the window frame will use a new kind of GUI container called a <code>JPanel</code>. By building two separate files, we’ll be able to reuse the drawing canvas in a GUI app in <a href="ch10.xhtml#ch10">Chapter 10</a>. Let’s start coding!</p>&#13;
<h3 class="h3"><a id="toc_lev150"/>Creating the BubbleDraw Project Files</h3>&#13;
<p class="noindent">In Eclipse, go to <strong>File</strong> <span class="ent">▸</span> <strong>New</strong> <span class="ent">▸</span> <strong>Java Project</strong> and create a new project folder for the BubbleDraw app. Name the project <span class="codestrong"><code>BubbleDraw</code></span> and click <strong>Finish</strong>.</p>&#13;
<p class="indent">Expand the <em>BubbleDraw</em> project folder in the Project Explorer pane, right-click the <em>src</em> folder, and select <strong>New</strong> <span class="ent">▸</span> <strong>Class</strong>. Create a class called <span epub:type="pagebreak" id="page_199"/><code>BubbleDraw</code> for the app window, with <code>javax.swing.JFrame</code> as the superclass, and under <strong>Which method stubs . . .</strong> select the <strong>public static void main(String[] args)</strong> checkbox. Then click <strong>Finish</strong>.</p>&#13;
<p class="indent">Next, we’ll create the BubblePanel drawing canvas. Right-click the <em>src</em> folder and select <strong>New</strong> <span class="ent">▸</span> <strong>Class</strong>. Name this class <span class="codestrong"><code>BubblePanel</code></span>, with a superclass of <code>javax.swing.JPanel</code>. Click <strong>Finish</strong>.</p>&#13;
<p class="indent">Using these classes, we’ll create a reusable <code>BubblePanel</code> canvas that we can expand and put into other apps. The <code>BubbleDraw</code> frame will be a container that displays the <code>BubblePanel</code>.</p>&#13;
<h3 class="h3"><a id="toc_lev151"/>Building the BubbleDraw Frame</h3>&#13;
<p class="noindent">Let’s begin by setting up the main app window in the <em>BubbleDraw.java</em> source code file. Click the <em>BubbleDraw.java</em> tab at the top of the content pane in Eclipse, and you’ll see the following code has already been filled in:</p>&#13;
<p class="pre">import javax.swing.JFrame;<br/>&#13;
public class BubbleDraw extends JFrame {<br/>&#13;
    public static void main(String[] args) {<br/>&#13;
    }<br/>&#13;
}</p>&#13;
<p class="indent">The app window runs in a <code>JFrame</code>, like our previous GUI apps did. In this app, we need the window to display the drawing canvas, our <code>BubblePanel</code>. We won’t add any other GUI components to this first version of the app.</p>&#13;
<p class="indent">We want to create a <code>JFrame</code> window and add setup code for the frame as we have in previous chapters, but we’ll also add a <code>BubblePanel</code> to the frame for our drawing canvas. The complete <code>BubbleDraw</code> class will look like <a href="ch9.xhtml#ch9list1">Listing 9-1</a>:</p>&#13;
<p class="pre">import javax.swing.JFrame;<br/>&#13;
public class BubbleDraw extends JFrame {<br/>&#13;
    public static void main(String[] args) {<br/>&#13;
      <span class="ent">➊</span> JFrame frame = new JFrame("<em>Your Name</em>'s BubbleDraw App");<br/>&#13;
      <span class="ent">➋</span> frame.setDefaultCloseOperation(JFrame.<em>EXIT_ON_CLOSE</em>);<br/>&#13;
      <span class="ent">➌</span> frame.getContentPane().add(new BubblePanel());<br/>&#13;
      <span class="ent">➍</span> frame.setSize(new java.awt.Dimension(600,400));<br/>&#13;
      <span class="ent">➎</span> frame.setVisible(true);<br/>&#13;
    }<br/>&#13;
}</p>&#13;
<p class="code-title"><em><a id="ch9list1"/>Listing 9-1: The BubbleDraw</em>  <em>class</em></p>&#13;
<p class="indent">Start by creating a new <code>JFrame</code> with a title bar at the top <span class="ent">➊</span>. Put your own name in the title string. Next, set the default close operation so that the app exits when the user closes the window <span class="ent">➋</span>. Then add the code to open a new <code>BubblePanel</code> drawing canvas as the content inside this frame <span class="ent">➌</span>. The last two lines set the size of the window <span class="ent">➍</span> and make it visible <span class="ent">➎</span>.</p>&#13;
<p class="indent">Save the <em>BubbleDraw.java</em> file and run it once. You’ll see a gray Java frame with <code>"</code><em>Your Name</em><code>'s BubbleDraw App"</code> in the title bar. We’ll build the logic for the <code>BubblePanel</code> drawing canvas next.</p>&#13;
<h3 class="h3"><span epub:type="pagebreak" id="page_200"/><a id="toc_lev152"/>Creating a Class for Bubbles</h3>&#13;
<p class="noindent">Switch to the tab for the <em>BubblePanel.java</em> file. This file will contain all the logic for drawing bubbles on the screen. Our first task will be creating a <code>Bubble</code> class to store each bubble’s color, size, and location on the screen.</p>&#13;
<h4 class="h4"><em><a id="toc_lev153"/>Defining a Bubble</em></h4>&#13;
<p class="noindent">The reason for building a class is quite practical: in the older, procedural approach to programming, we would need a separate variable for each bubble’s x- and y-coordinates, size, and so on. For example, we’d need a <code>bubble1x</code> variable for the first bubble’s x-location, as well as <code>bubble1y</code>, <code>bubble1size</code>, and <code>bubble1color</code> variables for that bubble. That wouldn’t be so bad, but what if we drag the mouse for a few seconds and wind up with a thousand bubbles? We would need 4,000 variables just to keep track! Instead, we can use properties inside a class to store those values for each bubble.</p>&#13;
<p class="indent">Before we start writing code, let’s define what a bubble is. As shown earlier in <a href="ch9.xhtml#ch9fig1">Figure 9-1</a>, a bubble is a colorful, filled circle, and bubbles can be different sizes and in different locations.</p>&#13;
<p class="indent">All of those features are attributes of bubbles in this app. In object-oriented programming, we use the nouns and adjectives that describe an object to build a list of attributes when we create a new class. Attributes are stored as class variables.</p>&#13;
<p class="indent">Besides attributes, a class can also contain methods. A method is a type of function associated with a specific class. Methods enable a class to do something. Think about what we want the bubbles in the drawing app to do. We need to create a bubble whenever the user clicks or drags the mouse. We’ll also draw a bubble every time the screen refreshes. The verbs—like <em>create</em> and <em>draw</em>—will help us identify the methods we need in our bubble class.</p>&#13;
<p class="indent">When we capture all of those attributes and methods into a single class, we can describe any bubble we might want to show on the screen. This is how a coder solves problems with object-oriented programming: by breaking big applications into smaller pieces, creating classes by asking questions about what the program contains, and then identifying methods and attributes by asking what each object of a new class should do and what kind of information it needs.</p>&#13;
<p class="indent">Let’s begin writing the <code>Bubble</code> class. We’ll do this inside the <code>BubblePanel</code> class, as <code>BubblePanel</code> is the only place we need to draw bubbles. Start coding your <code>Bubble</code> class before the closing brace at the end of <code>BubblePanel</code>, as follows:</p>&#13;
<p class="pre"><span class="gray">import javax.swing.JPanel;</span><br/>&#13;
<span class="gray">public class BubblePanel extends JPanel {</span><br/>&#13;
    private class Bubble {<br/>&#13;
    }<br/>&#13;
<span class="gray">}</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_201"/>We usually make internal and helper classes private to keep other programs from accessing them directly. So, to make <code>Bubble</code> an internal class accessible only from a <code>BubblePanel</code>, we declare it as <code>private</code>. This technique, called <em>encapsulation</em>, means that the <code>BubblePanel</code> class hides its inner workings from other classes. Encapsulation is one of the core principles of object-oriented programming, and it’s a best practice worth following because it means we can change the way the <code>Bubble</code> class works internally and know for certain that we won’t break other parts of the code. Since <code>Bubble</code> is declared as <code>private</code>, we know that there isn’t any code outside of the <code>BubblePanel</code> class that depends on it. This is especially important for bigger applications that contain a large number of classes and are worked on by many programmers.</p>&#13;
<p class="indent"><code>BubblePanel</code> will rely on the <code>Bubble</code> class to store information on individual bubbles as the user draws on the screen. A bubble has an (x, y) location on the screen, a size, and a color, so we can make these attributes as variables inside <code>Bubble</code>. The x- and y-coordinates of the bubble’s location and the size of the bubble can all be stored as integer values:</p>&#13;
<p class="pre"><span class="gray">import javax.swing.JPanel;<br/>&#13;
public class BubblePanel extends JPanel {<br/>&#13;
    private class Bubble {</span><br/>&#13;
        private int x;<br/>&#13;
        private int y;<br/>&#13;
        private int size;<br/>&#13;
    <span class="gray">}</span><br/>&#13;
<span class="gray">}</span></p>&#13;
<p class="indent">Here we make two separate variables called <code>x</code> and <code>y</code> to store the bubble’s coordinates, as well as a <code>size</code> variable. These attributes are <code>private</code>, so only the <code>Bubble</code> class itself can change those values directly. We encapsulate all the data a bubble should have inside the <code>Bubble</code> class, and we interact with bubbles using the methods in that class only.</p>&#13;
<p class="indent">As mentioned earlier, each bubble in our app can have its own color. The <code>java.awt</code> library has a <code>Color</code> class that handles <em>RGB</em> (<em>red-green-blue</em>) color values to reproduce any color that we can display on our monitor. We’ll talk a bit more about RGB when we actually write the code to control bubble colors later in the chapter, so for now just import the <code>java.awt.Color</code> class at the top of the file and add an attribute called <code>color</code> to the <code>Bubble</code> class, like so:</p>&#13;
<p class="pre">import java.awt.Color;<br/>&#13;
<span class="gray">import javax.swing.JPanel;<br/>&#13;
public class BubblePanel extends JPanel {<br/>&#13;
    private class Bubble {</span><br/>&#13;
        <span class="gray">private int x;</span><br/>&#13;
        <span class="gray">private int y;</span><br/>&#13;
        <span class="gray">private int size;</span><br/>&#13;
        private Color color;<br/>&#13;
    <span class="gray">}<br/>&#13;
}</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_202"/>Now that we’ve added the four attributes we want each bubble to have (<code>x</code>, <code>y</code>, <code>size</code>, and <code>color</code>), we can start building the behaviors, or functions, of a bubble to give values to these attributes. We’ll do that by adding methods inside the <code>Bubble</code> class.</p>&#13;
<h4 class="h4"><em><a id="toc_lev154"/>Designing a Bubble’s Methods</em></h4>&#13;
<p class="noindent">The <code>Bubble</code> class will have two actions, which we’ll turn into methods: creating a bubble and drawing a bubble on the desktop screen.</p>&#13;
<p class="indent">Methods that create objects have a special name: <em>constructors</em>. A constructor sets up an object by assigning values to the object’s attributes. When we assign values to the attributes inside a constructor, we’re <em>initializing</em> them. For the <code>Bubble</code> class, we want to initialize the <code>x</code>, <code>y</code>, <code>size</code>, and <code>color</code> attributes of an individual bubble.</p>&#13;
<h5 class="h5">Building the Constructor</h5>&#13;
<p class="noindent">A constructor method begins with the keyword <code>public</code>, followed by the name of the class and a pair of parentheses. If there are any parameters you want to pass in as you set up an object, you place those inside the parentheses. We want to assign each bubble its <code>x</code>, <code>y</code>, and <code>size</code> values when it is created, so the constructor for the <code>Bubble</code> class looks like <a href="ch9.xhtml#ch9list2">Listing 9-2</a>.</p>&#13;
<p class="pre">    <span class="gray">private class Bubble {</span><br/>&#13;
        <span class="gray">private int x;</span><br/>&#13;
        <span class="gray">private int y;</span><br/>&#13;
        <span class="gray">private int size;</span><br/>&#13;
        <span class="gray">private Color color;</span><br/>&#13;
      <span class="ent">➊</span> public Bubble(int newX, int newY, int newSize) {<br/>&#13;
         <span class="ent">➋</span> x = newX;<br/>&#13;
         <span class="ent">➌</span> y = newY;<br/>&#13;
         <span class="ent">➍</span> size = newSize;<br/>&#13;
        }<br/>&#13;
    <span class="gray">}</span></p>&#13;
<p class="code-title"><em><a id="ch9list2"/>Listing 9-2: The Bubble class constructor</em></p>&#13;
<p class="indent">Each bubble’s coordinates and size will be determined by the user, so we want to pass the x- and y-coordinates and a size as integer values to the <code>Bubble()</code> constructor as each new bubble is created. These values are the three parameters we pass to the <code>Bubble()</code> method and are called <code>newX</code>, <code>newY</code>, and <code>newSize</code> <span class="ent">➊</span>. Later in the code, when we handle the user creating bubbles, we’ll be outside the private <code>Bubble</code> class. That means we won’t have direct access to the bubble’s attributes, so we can’t just assign values to the <code>x</code>, <code>y</code>, and <code>size</code> attributes of each bubble. In order to get around that, we assign the attributes values through the <code>Bubble()</code> constructor, which takes the input from the user; assigns the input values to <code>newX</code>, <code>newY</code>, and <code>newSize</code>; and then assigns the user input values to the bubble’s attributes at <span class="ent">➋</span>, <span class="ent">➌</span>, and <span class="ent">➍</span>.</p>&#13;
<p class="indent">We also want each bubble to have a random color. Because the color will be random, we don’t need to pass it to the constructor using a parameter. Instead, we can create the color inside the constructor.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_203"/>We’ll need to generate random RGB color values to create a color for each bubble. RGB works by combining different amounts of red, green, and blue light on your computer monitor to produce different colors. In programming, each of these three colors is represented by an integer between 0 (none of the color) and 255 (the maximum amount of the color possible). To make a color, we need to get three integers between 0 and 255, separate them with commas, and group them together between parentheses. For example, pure red has an RGB value of (255, 0, 0), meaning full red, no green, and no blue. Yellow is (255, 255, 0) in RGB, meaning full amounts of red and green, but no blue. In total, there are over 16 million RGB color values that can be created this way.</p>&#13;
<p class="indent">We’ve generated random numbers with the <code>Math</code> class’s <code>Math.random()</code> method before when we needed a single number, but in the BubbleDraw app, we’ll need three random numbers (one for each part of RGB), so let’s look at a new way to generate random values.</p>&#13;
<p class="indent">The <code>java.util.Random</code> class contains several useful methods, including <code>nextInt()</code>, which will let us instantly generate a random integer up to a certain size without having to do additional math or rounding. To use the <code>Random</code> class, we’ll have to import it first, at the top of the <em>BubblePanel.java</em> file:</p>&#13;
<p class="pre">import java.util.Random;<br/>&#13;
<span class="gray">import java.awt.Color;<br/>&#13;
import javax.swing.JPanel;</span></p>&#13;
<p class="indent">Because <code>Random</code> is a class, we need to create a new object or variable of the <code>Random</code> type to access its functions. Add the following line inside the top of the <code>BubblePanel</code> class:</p>&#13;
<p class="pre"><span class="gray">import java.util.Random;<br/>&#13;
import java.awt.Color;<br/>&#13;
import javax.swing.JPanel;<br/>&#13;
public class BubblePanel extends JPanel {</span><br/>&#13;
    Random rand = new Random();<br/>&#13;
    <span class="gray">private class Bubble {</span></p>&#13;
<p class="indent">This line creates a random number generator called <code>rand</code> that will allow us to generate random integer or floating-point values quickly. We’re encapsulating <code>rand</code> by putting it at the top of the <code>BubblePanel</code> class so that we can generate random numbers both in the drawing window and in the inner <code>Bubble</code> class, but not outside a <code>BubblePanel</code>.</p>&#13;
<p class="indent">To create a random color in Java, we can use the constructor for the <code>java.awt.Color</code> class that we imported earlier. The constructor will accept three integer arguments between <code>0</code> and <code>255</code> for the red, green, and blue values to create a color.</p>&#13;
<p class="indent">Add the following code to the <code>Bubble()</code> constructor method:</p>&#13;
<p class="pre">      <span class="gray">public Bubble(int newX, int newY, int newSize) {</span><br/>&#13;
          <span class="gray">x = newX;</span><br/>&#13;
          <span class="gray">y = newY;</span><br/>&#13;
          <span class="gray">size = newSize;</span><br/>&#13;
          color = new Color( rand.nextInt(256),<br/>&#13;
                  rand.nextInt(256),<br/>&#13;
                  rand.nextInt(256) );<br/>&#13;
      <span class="gray">}</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_204"/>We use the <code>new</code> keyword with the constructor for the <code>Color</code> class to create a new color, and each of the RGB color values will be a randomly generated integer between <code>0</code> and <code>255</code>. Every time you call the <code>nextInt()</code> method, it generates a new random integer between 0 and the maximum integer you pass it. Here, we want random color values from <code>0</code> to <code>255</code>, so we pass it <code>256</code> because <code>nextInt()</code> generates an integer up to, but not including, the upper bound passed to it.</p>&#13;
<h5 class="h5">Coding the Method to Draw a Bubble</h5>&#13;
<p class="noindent">Now that each bubble has an (x, y) location, a size, and a random color, let’s add the ability to draw bubbles on the screen. To draw colorful graphics on the screen, we’ll import the <code>java.awt.Graphics</code> class. This <code>Graphics</code> class contains methods such as <code>setColor()</code> to choose a paint color, <code>drawRect()</code> to draw a rectangle, and <code>fillOval()</code> to paint a filled-in oval on the screen, just to name a few. We’ll use <code>fillOval()</code> to draw our circles, so add the following <code>import</code> statement to the top of the <em>BubblePanel.java</em> file:</p>&#13;
<p class="pre">import java.awt.Graphics;<br/>&#13;
<span class="gray">import java.util.Random;<br/>&#13;
import java.awt.Color;<br/>&#13;
import javax.swing.JPanel;</span></p>&#13;
<p class="indent">Next, let’s add a <code>draw()</code> method to the <code>Bubble</code> inner class, below the <code>Bubble()</code> constructor:</p>&#13;
<p class="pre">    <span class="gray">private class Bubble {</span><br/>&#13;
        <span class="gray">private int x;</span><br/>&#13;
        <span class="gray">private int y;</span><br/>&#13;
        <span class="gray">private int size;</span><br/>&#13;
        <span class="gray">private Color color;</span><br/>&#13;
        <span class="gray">public Bubble(int newX, int newY, int newSize) {</span><br/>&#13;
            <span class="gray">--<span class="codeitalic">snip</span>--<br/>&#13;
        }</span><br/>&#13;
        public void draw(Graphics canvas) {<br/>&#13;
            <span class="ent">➊</span> canvas.setColor(color);<br/>&#13;
            <span class="ent">➋</span> canvas.fillOval(x - size/2, y - size/2, size, size);<br/>&#13;
        }<br/>&#13;
<span class="gray">}</span></p>&#13;
<p class="indent">The <code>draw()</code> method accepts one parameter, a <code>Graphics</code> canvas called <code>canvas</code>. Inside the <code>draw()</code> method, we call the <code>setColor()</code> method on <code>canvas</code> <span class="ent">➊</span> to set the drawing color to the color stored in the <code>color</code> variable of the bubble we’ll draw. At <span class="ent">➋</span>, we call <code>fillOval()</code> to paint a filled-in circle on the screen. The <code>fillOval()</code> method takes four parameters, the x- and y-coordinate of <span epub:type="pagebreak" id="page_205"/>the upper-left corner of a bounding box in which we’ll draw the oval, followed by the width and height of the box. Think of the bounding box as an invisible rectangle at that (x, y) location with the given width and height and the oval as a balloon that will be blown up until it touches all four sides of the box (see <a href="ch9.xhtml#ch9fig2">Figure 9-2</a>). By setting the same width and height for the box to make it square, we’ll end up with a circle instead of an oval.</p>&#13;
<p class="indent">Because our ovals are actually circles, the width and height are the same value—the size of the bubble in pixels we stored in the <code>size</code> attribute. At <span class="ent">➋</span>, we want the bubble to be centered on the (x, y) location the user clicked, so we adjust the upper-left corner of each bubble by subtracting half the size (<code>size/2</code>) from each of the <code>x</code> and <code>y</code> values.</p>&#13;
<div class="imagef"><img src="../images/f0205-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch9fig2"/>Figure 9-2: The fillOval() method takes four parameters, the upper-left corner’s xand y-coordinates, followed by the oval’s width and height.</em></p>&#13;
<p class="indent">With the addition of the <code>draw()</code> method, we now have a complete <code>Bubble</code> class that can remember the location, size, and color of a bubble. The class methods we made can be used to create new bubbles and draw them on the screen. It’s time to add logic to the <code>BubblePanel</code> class to use those methods to create and draw bubbles whenever the user clicks and drags on the screen.</p>&#13;
<h3 class="h3"><a id="toc_lev155"/>Storing Bubbles in an ArrayList</h3>&#13;
<p class="noindent">We need a way to store all the bubbles the user creates when they click and drag around the screen. Java’s libraries contain several useful <em>data structures</em>, which are classes for storing groups of objects.</p>&#13;
<p class="indent">The <code>java.util.ArrayList</code> is a <em>dynamic</em> data structure. That means it not only stores a collection of objects but can also grow or shrink depending on the needs of the program. For the BubbleDraw app, we can’t predict how many bubbles the user will draw, so a dynamic data structure like an <code>ArrayList</code> is the perfect option for storing all the bubbles a user could create. An <code>ArrayList</code> is a flexible way to store things when you don’t know how many items you’ll need in advance. A regular array in Java has a fixed size, but an <code>ArrayList</code> can keep adding new bubbles every time the user clicks.</p>&#13;
<p class="indent">First, let’s import <code>java.util.ArrayList</code> at the top of the <em>BubblePanel.java</em> file so we can access <code>ArrayList</code> data types:</p>&#13;
<p class="pre">import java.util.ArrayList;<br/>&#13;
<span class="gray">import java.awt.Graphics;<br/>&#13;
import java.util.Random;<br/>&#13;
import java.awt.Color;<br/>&#13;
import javax.swing.JPanel;</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_206"/>Next, we need to declare an <code>ArrayList</code> that will hold objects of the <code>Bubble</code> class. Inside the <code>BubblePanel</code> class, add the following declaration:</p>&#13;
<p class="pre"><span class="gray">public class BubblePanel extends JPanel {</span><br/>&#13;
    <span class="gray">Random rand = new Random();</span><br/>&#13;
    ArrayList&lt;Bubble&gt; bubbleList;</p>&#13;
<p class="indent">The <code>ArrayList</code> data structure can accept a type specifier inside the angle brackets, <code>&lt;</code> and <code>&gt;</code>, to tell Java what type of objects the <code>ArrayList</code> will hold. An <code>ArrayList</code> can hold any type of object, but the <code>ArrayList</code> we’re declaring, <code>bubbleList</code>, will contain only objects of the <code>Bubble</code> class.</p>&#13;
<p class="indent">Next, let’s take care of one additional variable, <code>size</code>, for the default bubble size:</p>&#13;
<p class="pre"><span class="gray">public class BubblePanel extends JPanel {</span><br/>&#13;
    <span class="gray">Random rand = new Random();</span><br/>&#13;
    <span class="gray">ArrayList&lt;Bubble&gt; bubbleList;</span><br/>&#13;
    int size = 25;</p>&#13;
<p class="indent">This <code>size</code> variable sets a starting size for bubble diameters in pixels. I picked <code>25</code> pixels, but you can choose a larger or smaller starting size if you’d like.</p>&#13;
<h4 class="h4"><em><a id="toc_lev156"/>Adding a Constructor to the BubblePanel Class</em></h4>&#13;
<p class="noindent">We’ve declared <code>bubbleList</code> to be a dynamic <code>ArrayList</code> of <code>Bubble</code> objects, so let’s add a constructor to the <code>BubblePanel</code> class to initialize <code>bubbleList</code> and set the background color of the drawing window.</p>&#13;
<p class="indent">Just as we saw in the <code>Bubble</code> inner class, the constructor for the <code>BubblePanel</code> class uses the format <code>public</code> plus the name of the class, followed by a pair of parentheses:</p>&#13;
<p class="pre"><span class="gray">public class BubblePanel extends JPanel {</span><br/>&#13;
    <span class="gray">Random rand = new Random();</span><br/>&#13;
    <span class="gray">ArrayList&lt;Bubble&gt; bubbleList;</span><br/>&#13;
    <span class="gray">int size = 25;</span><br/>&#13;
    public BubblePanel() {<br/>&#13;
    }</p>&#13;
<p class="indent">Notice that we end the constructor with open and close parentheses, because the constructor is a method. Inside the constructor, we initialize <code>bubbleList</code> to get it ready to store a flexible <code>ArrayList</code> of <code>Bubble</code> objects. We also set the background color of the drawing window to black:</p>&#13;
<p class="pre">    <span class="gray">public BubblePanel() {</span><br/>&#13;
     <span class="ent">➊</span> bubbleList = new ArrayList&lt;Bubble&gt;();<br/>&#13;
     <span class="ent">➋</span> setBackground(Color.<span class="codeitalic">BLACK</span>);<br/>&#13;
    <span class="gray">}</span></p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>Although I recommend a black background for the app, the images in this book show a white background for readability.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_207"/>Just as in the declaration of <code>bubbleList</code>, when we construct a new <code>ArrayList</code> at <span class="ent">➊</span>, we can specify the type of object we want to store in angle brackets: <code>&lt;Bubble&gt;</code>.</p>&#13;
<p class="indent">At <span class="ent">➋</span>, we can use the <code>setBackground()</code> method directly because <code>BubblePanel</code> is extending <code>JPanel</code>, and we’ve seen that <code>JPanel</code> objects have a background color. We’re setting the background to the color constant <code>Color.BLACK</code> from the <code>Color</code> class we imported earlier. This constant has an RGB value of (0, 0, 0).</p>&#13;
<p class="indent">Now, when we start the BubbleDraw app and create a <code>BubblePanel</code> drawing canvas, we’ll begin with an empty list of bubbles and a black screen background.</p>&#13;
<p class="indent">Save your changes so far. In the next section, we’ll fill that window with colorful bubbles!</p>&#13;
<h4 class="h4"><em><a id="toc_lev157"/>Adding a Method to Draw on the Screen</em></h4>&#13;
<p class="noindent">Next, we need to add a method to paint all the bubbles in <code>bubbleList</code> to the drawing screen.</p>&#13;
<p class="indent">All of the GUI components in the <code>javax.swing</code> toolkit, including the <code>JPanel</code> we extended for the <code>BubblePanel</code> drawing screen, have a <code>paintComponent()</code> method that draws that component on the screen. We’re going to modify, or <em>override</em>, the default <code>paintComponent()</code> method to make the <code>BubblePanel</code> draw all the bubbles in <code>bubbleList</code>.</p>&#13;
<p class="indent">First, we need to declare the <code>paintComponent()</code> method. Because we’re overriding the <code>paintComponent()</code> method that already exists in <code>JPanel</code>, the parent class of <code>BubblePanel</code>, we have to use the same <em>method signature</em>, or first line of code. That means we have to match the way <code>paintComponent()</code> is declared exactly, as a <code>public void</code> method, with one parameter, of type <code>Graphics</code>:</p>&#13;
<p class="pre"><span class="gray">public class BubblePanel extends JPanel {</span><br/>&#13;
    <span class="gray">--<span class="codeitalic">snip</span>--<br/>&#13;
    }</span><br/>&#13;
    public void paintComponent(Graphics canvas) {<br/>&#13;
    }</p>&#13;
<p class="indent">We place the <code>paintComponent()</code> method just below the <code>BubblePanel()</code> constructor. Notice that <code>paintComponent()</code> requires a <code>Graphics</code> object, which we call <code>canvas</code> just as in the <code>draw()</code> method we designed for the <code>Bubble</code> class. Any object that draws on the screen can use a <code>Graphics</code> object to color the individual pixels on the computer screen.</p>&#13;
<p class="indent">Inside this method, we first want to allow the <code>JPanel</code> parent class to clear the drawing screen and do any other setup it normally would before drawing anything else. We do this by calling <code>paintComponent()</code> from the parent class:</p>&#13;
<p class="pre">    <span class="gray">public void paintComponent(Graphics canvas) {</span><br/>&#13;
        super.paintComponent(canvas);<br/>&#13;
    <span class="gray">}</span></p>&#13;
<p class="indent">The keyword <code>super</code> tells Java to call the original <code>paintComponent()</code> method from <code>JPanel</code>. This means that all the code in the original <code>paintComponent()</code> method will be pulled into our new one. This is a useful object-oriented <span epub:type="pagebreak" id="page_208"/>programming feature: because we extended the <code>JPanel</code> class to create the new <code>BubblePanel</code> class, we can take advantage of all the functionality already built into <code>JPanel</code>, such as clearing the pixels inside the window when the app opens and preparing the <code>Graphics</code> canvas for drawing colorful graphics. We say that <code>BubblePanel</code> <em>inherits</em> these functions from <code>JPanel</code>.</p>&#13;
<p class="indent">Once we’ve prepared the canvas, it’s time to loop through the list of bubbles and draw each one on <code>canvas</code>. To accomplish this, we’ll use a <code>for</code> loop in a new way.</p>&#13;
<p class="indent">You first saw a <code>for</code> loop in <a href="ch6.xhtml#ch6">Chapter 6</a>, when we wanted to loop through each character in a string to encode secret messages. This time, we’re using a shorter version of a <code>for</code> loop, called a <code>for each</code> statement, that’s specially designed to loop through a list or collection of objects.</p>&#13;
<p class="indent">Let’s see the working code first, and then I’ll break down the <code>for each</code> statement piece by piece:</p>&#13;
<p class="pre">  <span class="gray">public void paintComponent(Graphics canvas) {</span><br/>&#13;
      <span class="gray">super.paintComponent(canvas);</span><br/>&#13;
    <span class="ent">➊</span> for(Bubble b : bubbleList) {<br/>&#13;
        <span class="ent">➋</span> b.draw(canvas);<br/>&#13;
      }<br/>&#13;
  <span class="gray">}</span></p>&#13;
<p class="indent">You can read the <code>for each</code> statement at <span class="ent">➊</span> as “For each <code>Bubble</code> <code>b</code> in <code>bubbleList</code>.” You can tell this is a <code>for each</code> statement instead of a regular <code>for</code> loop, first because of the colon in the middle and, second, because it doesn’t have the three parts we saw in <code>for</code> loops back in <a href="ch6.xhtml#ch6">Chapter 6</a>: <em>initialization, condition</em>, and <em>update</em>. Java uses the same keyword <code>for</code> and parentheses for both loops, but the <code>for each</code> statement is designed just for collections of objects, such as arrays, <code>ArrayList</code>s, and so on.</p>&#13;
<p class="indent">For each <code>Bubble</code> <code>b</code> in the <code>ArrayList</code> <code>bubbleList</code>, the loop will call <code>b.draw(canvas)</code> <span class="ent">➋</span> to draw that individual bubble on the drawing screen. The first time the loop executes, <code>b</code> will point to the first <code>Bubble</code> object in <code>bubbleList</code>, and each time the loop repeats, <code>b</code> will point to the next bubble in the list. Calling <code>b.draw(canvas)</code> tells that bubble to draw itself on the <code>canvas</code>.</p>&#13;
<p class="indent">This single, short <code>for each</code> loop will draw every bubble in the <code>bubbleList</code> to the screen. The only problem is that we don’t have any bubbles to test. Let’s generate some random bubbles to see the app in action before we move on to creating bubbles with the mouse.</p>&#13;
<h4 class="h4"><em><a id="toc_lev158"/>Testing the BubblePanel Class</em></h4>&#13;
<p class="noindent">To test what we’ve done so far, before we add the mouse interaction, we’ll write a test method that draws 100 bubbles of random sizes all over the app window. This will allow us to make sure the app works without writing the final code. This way we can debug any errors in our code early and see a preview of how cool the app will look when it’s finished.</p>&#13;
<p class="indent">Call the new method <code>testBubbles()</code>. Place it after the <code>paintComponent()</code> method and before the <code>private class Bubble</code>, as shown in <a href="ch9.xhtml#ch9list3">Listing 9-3</a>.</p>&#13;
<p class="pre"><span epub:type="pagebreak" id="page_209"/>  <span class="gray">public void paintComponent(Graphics canvas) {</span><br/>&#13;
      <span class="gray">--<span class="codeitalic">snip</span>--<br/>&#13;
      }</span><br/>&#13;
  <span class="gray">}</span><br/>&#13;
<span class="ent">➊</span> public void testBubbles() {<br/>&#13;
    <span class="ent">➋</span> for(int n = 0; n &lt; 100; n++) {<br/>&#13;
        <span class="ent">➌</span> int x = rand.nextInt(600);<br/>&#13;
        <span class="ent">➍</span> int y = rand.nextInt(400);<br/>&#13;
        <span class="ent">➎</span> int size = rand.nextInt(50);<br/>&#13;
        <span class="ent">➏</span> bubbleList.add( new Bubble(x, y, size) );<br/>&#13;
      }<br/>&#13;
    <span class="ent">➐</span> repaint();<br/>&#13;
  }<br/>&#13;
  <span class="gray">private class Bubble {</span></p>&#13;
<p class="code-title"><em><a id="ch9list3"/>Listing 9-3: Creating the testBubbles() method</em></p>&#13;
<p class="indent">At <span class="ent">➊</span>, we declare <code>testBubbles()</code> as <code>public</code> with <code>void</code> as the return type, meaning it doesn’t pass any information back to the program. Then, we use a regular <code>for</code> loop <span class="ent">➋</span> to go from <code>n = 0</code> to <code>99</code>, a total of 100 iterations. That means we’ll create 100 bubbles, and for each bubble, we need an (x, y) location and a size for its width and height in pixels.</p>&#13;
<p class="indent">We set the pixel dimensions of the BubbleDraw app frame to <code>600</code> wide by <code>400</code> tall at the beginning of this chapter, so for the bubble’s location, we need an <code>x</code> value between <code>0</code> and <code>600</code> and a <code>y</code> value between <code>0</code> and <code>400</code>. Inside the <code>for</code> loop, we use the random number generator <code>rand</code> to get a random integer between <code>0</code> and <code>600</code> and store it in the variable <code>x</code> <span class="ent">➌</span> for the x-coordinate of the center of the bubble on the screen. Then, we generate a y-coordinate value between <code>0</code> and <code>400</code> and store it in <code>y</code> <span class="ent">➍</span>. Next, for the size of the bubble in pixels, we generate a random number between <code>0</code> and <code>50</code> <span class="ent">➎</span>. The last step inside the loop creates a new <code>Bubble</code> object using the random <code>x</code>, <code>y</code>, and <code>size</code> that we just generated, and we add that new <code>Bubble</code> to the <code>ArrayList</code> <code>bubbleList</code> <span class="ent">➏</span>.</p>&#13;
<p class="indent">Finally, we call the <code>repaint()</code> method ➐. Normally before we draw new computer graphics, we have to clear the screen by drawing an empty, black background, but here <code>repaint()</code> does this for us. Notice that we didn’t have to clear the background of the screen inside the <code>paintComponent()</code> method either; all we had to do was draw the bubbles from <code>bubbleList</code>. The <code>repaint()</code> method takes care of redrawing the background as well as calling <code>paintComponent()</code>, so we’ll call it anytime we want to refresh or repaint the screen.</p>&#13;
<p class="indent">There’s just one more step to complete before we can test the app—we need to call the <code>testBubbles()</code> method from the <code>BubblePanel()</code> constructor. Add the following line of code to your constructor for the <code>BubblePanel</code>:</p>&#13;
<p class="pre">    <span class="gray">public BubblePanel() {</span><br/>&#13;
        <span class="gray">bubbleList = new ArrayList&lt;Bubble&gt;();</span><br/>&#13;
        <span class="gray">setBackground(Color.<span class="codeitalic">BLACK</span>);</span><br/>&#13;
        testBubbles();<br/>&#13;
    <span class="gray">}</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_210"/>Save <em>BubblePanel.java</em> and then switch to the <em>BubbleDraw.java</em> tab. Save that file and press the run button in Eclipse. You’ll need to run the file from the <em>BubbleDraw.java</em> tab the first time you compile and run, because <code>BubbleDraw</code> contains the <code>main()</code> method that runs the program. You should see a window full of colorful, randomly placed bubbles, similar to <a href="ch9.xhtml#ch9fig3">Figure 9-3</a>.</p>&#13;
<div class="imagef"><img src="../images/f0210-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch9fig3"/>Figure 9-3: Each time you run this version of the BubbleDraw app, the testBubbles() method will draw 100 bubbles on the screen.</em></p>&#13;
<p class="indent">If you like the look of the random bubbles, take a little time to play with the numbers in the <code>testBubbles()</code> method. See if you can draw 200, 500, or even 1,000 bubbles instead of 100. Make the bubbles larger, either by generating a larger random number for <code>size</code> or by adding a value to <code>size</code> after the random number is generated. Play with the <code>x</code> and <code>y</code> values to see if you can fit every bubble on the screen instead of having some bubbles cut off at the edges.</p>&#13;
<p class="indent">Modify the <code>testBubbles()</code> method as much as you’d like; this is a great opportunity to try new things and immediately see the visual effect of each change. We’ll comment out the <code>testBubbles()</code> method in the next section as we add mouse interaction, so you can feel free to experiment with <code>testBubbles()</code> without fear of messing up the rest of the program.</p>&#13;
<h3 class="h3"><a id="toc_lev159"/>Handling Mouse Events from the User</h3>&#13;
<p class="noindent">The goal of the BubbleDraw app is to allow the user to draw bubbles using their mouse. We saw in the last section that the bubble-drawing part is working. Now all we have to do is add the mouse interaction.</p>&#13;
<p class="indent">We’ll use event listeners to give the app the ability to handle mouse clicks, mouse movement, and even mouse wheel scrolling. We added event listeners to our GUI apps in <a href="ch3.xhtml#ch3">Chapters 3</a> and <a href="ch7.xhtml#ch7">7</a> using anonymous inner classes to handle button clicks, sliders, and text field changes; but if we <span epub:type="pagebreak" id="page_211"/>used anonymous inner classes in this app, we would need to make three separate listeners for each type of event, and that would be hard to keep track of. Plus, in two of those events, clicking and dragging the mouse, we want the result to be the same: the app should add bubbles each time the user clicks the mouse on the screen <em>and</em> whenever the user drags the mouse across the screen. It would be much easier to just have one block of code we could attach to both events than to write a listener for one event and copy and paste the code to another. So, to make the app more manageable, we’re going to create a single, named event listener that can respond to all three types of events.</p>&#13;
<h4 class="h4"><em><a id="toc_lev160"/>Creating a Reusable Event Listener</em></h4>&#13;
<p class="noindent">Before we can create our event listener, we need to import one additional library, <code>java.awt.event.*</code>, at the top of the <em>BubblePanel.java</em> file:</p>&#13;
<p class="pre">import java.awt.event.*;<br/>&#13;
<span class="gray">import java.util.ArrayList;<br/>&#13;
import java.awt.Graphics;<br/>&#13;
import java.util.Random;<br/>&#13;
import java.awt.Color;<br/>&#13;
import javax.swing.JPanel;</span></p>&#13;
<p class="indent">Our previous <code>import</code> statements have brought in only one class at a time, but this statement brings in every class in the <code>java.awt.event</code> library. The wildcard character, the asterisk (<code>*</code>), means that we want to bring in all the classes at the top level of <code>java.awt.event</code>, including all the mouse events and listeners, and much more. We could import each class individually as we use it, but importing <code>java.awt.event.*</code> will make the program much easier to write, allowing us to focus on coding instead of switching back and forth to the top of the file every time we need to use another event class.</p>&#13;
<p class="indent">Next, let’s start coding the private, named inner class to listen for mouse events. We’ll name it <code>BubbleListener</code>, as it will handle all the events related to bubbles in the <code>BubblePanel</code> class. Add this class below your <code>testBubbles()</code> method but above the private class <code>Bubble</code>. Java programmers usually include listener classes near the bottom of the class file, along with any other helper classes—this convention just helps us quickly find the listener code for debugging or modifying the file.</p>&#13;
<p class="pre">      <span class="gray">repaint();</span><br/>&#13;
  <span class="gray">}</span><br/>&#13;
  private class BubbleListener extends  MouseAdapter {<br/>&#13;
  }<br/>&#13;
  <span class="gray">private class Bubble {</span></p>&#13;
<p class="indent">The <code>BubbleListener</code> class extends <code>MouseAdapter</code>, which processes mouse events. Just as when we used the <code>extends</code> keyword to build a new type of <code>JFrame</code> that inherited all the features and functions of its parent class, the <code>BubbleListener</code> will inherit all the mouse event listener features of the <code>MouseAdapter</code> class. This adapter class includes the ability to handle <span epub:type="pagebreak" id="page_212"/><code>MouseListener</code> events for clicks, <code>MouseMotionListener</code> events for mouse movement, and <code>MouseWheelListener</code> events for scrolling with the mouse wheel or trackpad.</p>&#13;
<p class="indent">We’ll add these event handlers to the code step-by-step, and we’ll test the app after each addition to see the BubbleDraw app emerge one feature at a time.</p>&#13;
<h4 class="h4"><em><a id="toc_lev161"/>Handling Clicks and Drags</em></h4>&#13;
<p class="noindent">When we handle mouse events, we need to complete two steps. First, we have to add code to the <code>BubbleListener</code> to handle the individual event we’re after, like <code>mousePressed()</code>. Then, we have to add the listener to the <code>BubblePanel()</code> constructor so the drawing screen knows to listen for that type of event and call <code>BubbleListener</code> to handle the event when it happens. Let’s do this for the first case, when the user presses the mouse button to draw a bubble.</p>&#13;
<h5 class="h5">Listening for Mouse Button Events</h5>&#13;
<p class="noindent">There are three events that we can listen for from the mouse buttons:</p>&#13;
<p class="indent1"><span class="codestrong"><code>mousePressed()</code></span> Occurs when the user presses any mouse button</p>&#13;
<p class="indent1"><span class="codestrong"><code>mouseReleased()</code></span> Occurs when the user releases the button</p>&#13;
<p class="indent1"><span class="codestrong"><code>mouseClicked()</code></span> Occurs when the user presses and releases in quick succession</p>&#13;
<p class="indent">For the BubbleDraw app, we’ll use the <code>mousePressed()</code> handler so that the app will draw a bubble as soon as the user presses the mouse button. The signature for a <code>mousePressed()</code> event handler looks like the following:</p>&#13;
<p class="pre">  <span class="gray">private class BubbleListener extends MouseAdapter {</span><br/>&#13;
      public void mousePressed(MouseEvent e) {<br/>&#13;
      }<br/>&#13;
  <span class="gray">}</span></p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>Spelling and capitalization are especially important when you’re writing event handlers because they already have built-in names with specific capitalization. Make sure your mousePressed() method matches this one exactly.</em></p>&#13;
</div>&#13;
<p class="indent">The <code>mousePressed()</code> event handler goes inside the <code>BubbleListener</code> class, and it must be declared as <code>public</code> with a <code>void</code> return type to match the <code>mousePressed()</code> method in the <code>MouseAdapter</code> class. Notice it also takes a parameter of type <code>MouseEvent</code>. All of the mouse events get information about the mouse pointer’s location on the screen when the event happened. The x- and y-coordinates of the mouse event are stored in a <code>MouseEvent</code> object, and we can get those coordinates with the <code>getX()</code> and <code>getY()</code> methods.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_213"/>The following code adds a bubble to the <code>bubbleList</code> at the location where the user clicked the mouse, and then repaints the drawing screen to make the bubble appear.</p>&#13;
<p class="pre">    <span class="gray">private class BubbleListener extends MouseAdapter {</span><br/>&#13;
        <span class="gray">public void mousePressed(MouseEvent e) {</span><br/>&#13;
          <span class="ent">➊</span> bubbleList.add(new Bubble(e.getX(), e.getY(), size));<br/>&#13;
          <span class="ent">➋</span> repaint();<br/>&#13;
        <span class="gray">}</span><br/>&#13;
    <span class="gray">}</span></p>&#13;
<p class="indent">At <span class="ent">➊</span>, we create a new <code>Bubble</code> object at the (x, y) location where the user clicked the mouse, <code>e.getX()</code> and <code>e.getY()</code>. The <code>MouseEvent</code> class has several properties and methods for working with mouse events, like finding out which button was pressed and where the mouse is on the screen. As I just mentioned, the <code>getX()</code> and <code>getY()</code> methods tell us the x- and y-coordinates of the mouse event, such as a click or drag. Look back down in the <code>Bubble</code> class, and you’ll see that the constructor method we wrote there required three parameters: <code>int newX</code>, <code>int newY</code>, and <code>int newSize</code>. So, we must pass <code>e.getX()</code>, <code>e.getY()</code>, and <code>size</code> to the constructor to create a new <code>Bubble</code> object. Once the bubble is created, we add it to the <code>ArrayList</code> of bubbles with <code>bubbleList.add()</code>.</p>&#13;
<p class="indent">At <span class="ent">➋</span>, we call the <code>repaint()</code> method to refresh the screen and draw the updated <code>bubbleList</code> to the canvas.</p>&#13;
<p class="indent">This completes the <code>mousePressed()</code> event handler, but we still need to do one more thing to make the app listen for <code>mousePressed()</code> events and send them to the <code>BubbleListener</code> class. We have to tell the <code>BubblePanel</code> class to add <code>BubbleListener</code> as the listener for mouse events.</p>&#13;
<p class="indent">In the <code>BubblePanel()</code> constructor, make two changes. First, comment out the <code>testBubbles()</code> line by placing two forward slashes at the front of the line. Second, call the <code>addMouseListener()</code> command to use <code>BubbleListener</code> to process mouse events. The updated constructor is shown here:</p>&#13;
<p class="pre">    <span class="gray">public BubblePanel() {</span><br/>&#13;
        <span class="gray">bubbleList = new ArrayList&lt;Bubble&gt;();</span><br/>&#13;
        <span class="gray">setBackground(Color.<em>BLACK</em>);</span><br/>&#13;
      <span class="ent">➊</span> // testBubbles();<br/>&#13;
      <span class="ent">➋</span> addMouseListener( new BubbleListener() );<br/>&#13;
    <span class="gray">}</span></p>&#13;
<p class="indent">By commenting out the call to <code>testBubbles()</code><span class="ent">➊</span>, we’ve left it in place in case we want to draw random test bubbles again, but we’ve stopped it from running so that we can test the interactive BubbleDraw app using the mouse. The new line at <span class="ent">➋</span> tells the <code>BubblePanel</code> to listen for mouse events and to send them to the <code>BubbleListener</code> class when they happen.</p>&#13;
<p class="indent">With those changes in place, you should be able to run the BubbleDraw app and use the mouse button to place bubbles anywhere you click, as shown in <a href="ch9.xhtml#ch9fig4">Figure 9-4</a>.</p>&#13;
<div class="imagef"><span epub:type="pagebreak" id="page_214"/><img src="../images/f0214-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch9fig4"/>Figure 9-4: After adding the mousePressed() handler and setting BubbleListener as the listener for mouse events in the app, you should be able to draw by clicking anywhere on the screen.</em></p>&#13;
<p class="indent">Very cool! You can click repeatedly to draw shapes and patterns on the screen, but it would be easier to drag the mouse to draw bubbles. Let’s address that next.</p>&#13;
<h5 class="h5">Listening for Mouse Motion Events</h5>&#13;
<p class="noindent">Mouse motion events are a separate type of event from mouse button presses, but they can still be processed in a class that extends <code>MouseAdapter</code>, like <code>BubbleListener</code>. The two types of mouse motion events are <code>mouseMoved()</code> and <code>mouseDragged()</code>.</p>&#13;
<p class="indent">A <code>mouseMoved()</code> event happens anytime the mouse is moved over the drawing window. A <code>mouseDragged()</code> event occurs whenever the mouse is moved while a button is pressed. Since we want to draw bubbles only when the user clicks and drags the mouse, we’ll implement the <code>mouseDragged()</code> event handler in the <code>BubbleListener</code> class first, and then we’ll add a mouse motion listener to the <code>BubblePanel</code> constructor to activate the listener.</p>&#13;
<p class="indent">Add the <code>mouseDragged()</code> event handler to the <code>BubbleListener</code> class, as shown here:</p>&#13;
<p class="pre">  <span class="gray">private class BubbleListener extends MouseAdapter {</span><br/>&#13;
      <span class="gray">public void mousePressed(MouseEvent e) {</span><br/>&#13;
          <span class="gray">--<span class="codeitalic">snip</span>--<br/>&#13;
      }</span><br/>&#13;
      public void mouseDragged(MouseEvent e) {<br/>&#13;
          bubbleList.add(new Bubble(e.getX(), e.getY(), size));<br/>&#13;
          repaint();<br/>&#13;
      }<br/>&#13;
  <span class="gray">}</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_215"/>You’ll notice that the code looks almost exactly like the <code>mousePressed()</code> event handler, except for the name <code>mouseDragged()</code>. That’s because they both handle <code>MouseEvent</code>s. The <code>mousePressed()</code> method handles events when the user presses a mouse button, and <code>mouseDragged()</code> is called whenever the user drags the mouse. In this app, both events should behave the same way, adding bubbles to <code>bubbleList</code> and calling the <code>repaint()</code> function.</p>&#13;
<p class="indent">Next, add <code>BubbleListener</code> as the mouse motion listener to the <code>BubblePanel()</code> constructor with the following statement:</p>&#13;
<p class="pre">    <span class="gray">public BubblePanel() {</span><br/>&#13;
        <span class="gray">bubbleList = new ArrayList&lt;Bubble&gt;();</span><br/>&#13;
        <span class="gray">setBackground(Color.<em>BLACK</em>);</span><br/>&#13;
        <span class="gray">// testBubbles();</span><br/>&#13;
        <span class="gray">addMouseListener( new BubbleListener() );</span><br/>&#13;
        addMouseMotionListener( new BubbleListener() ); <br/>&#13;
    <span class="gray">}</span></p>&#13;
<p class="indent">Once again, let’s run the app to test this new event listener. Save your code, press the run button, and click and drag around the app window that appears, as shown in <a href="ch9.xhtml#ch9fig5">Figure 9-5</a>.</p>&#13;
<div class="imagef"><img src="../images/f0215-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch9fig5"/>Figure 9-5: Now you can click and drag to draw continuous streams of bubbles!</em></p>&#13;
<p class="indent">Impressive, huh? Just by adding two event handlers for mouse button and mouse motion events to the <code>BubblePanel</code> graphics app, we’ve built an interactive, multicolored drawing app in Java.</p>&#13;
<h4 class="h4"><em><a id="toc_lev162"/>Bonus: Handling MouseWheel Events</em></h4>&#13;
<p class="noindent">We’ve seen two small but powerful event handlers for mouse button presses and mouse click-and-drag events at work in the app so far, but there’s another event class in <code>MouseAdapter</code>: <code>MouseWheelEvent</code>. Depending on your system, you might have a physical wheel on your mouse or trackpad that you can use <span epub:type="pagebreak" id="page_216"/>to scroll up and down in documents and web pages. Or, you might have a laptop with a trackpad that allows you to scroll using a gesture, such as the two-finger swipe gesture on a MacBook or the vertical swipe along the far-right edge of the trackpad on most Windows laptops.</p>&#13;
<p class="indent">Java interprets either kind of scroll event as a <code>MouseWheelEvent</code>. We can add a <code>mouseWheelMoved()</code> listener to the <code>BubbleListener</code> to handle mouse wheel events or trackpad scroll gesture events on systems that provide them, as follows:</p>&#13;
<p class="pre">    <span class="gray">private class BubbleListener extends MouseAdapter {</span><br/>&#13;
        <span class="gray">public void mousePressed(MouseEvent e) {</span><br/>&#13;
            <span class="gray">--<span class="codeitalic">snip</span>--<br/>&#13;
        }</span><br/>&#13;
        <span class="gray">public void mouseDragged(MouseEvent e) {</span><br/>&#13;
            <span class="gray">--<span class="codeitalic">snip</span>--<br/>&#13;
        }</span><br/>&#13;
      <span class="ent">➊</span> public void mouseWheelMoved(MouseWheelEvent e) {<br/>&#13;
          <span class="ent">➋</span> size += e.getUnitsToScroll();<br/>&#13;
        }<br/>&#13;
    <span class="gray">}</span></p>&#13;
<p class="indent">At <span class="ent">➊</span>, the <code>mouseWheelMoved()</code> method accepts a <code>MouseWheelEvent</code>. At <span class="ent">➋</span>, we get the number of units the mouse wheel scrolled from the <code>MouseWheelEvent</code> <code>e</code> with <code>e.getUnitsToScroll()</code>, and we add this amount to <code>size</code>. The number returned by <code>getUnitsToScroll()</code> can be positive or negative, depending on your operating system and whether the wheel was scrolled up or down.</p>&#13;
<div class="sidebar">&#13;
<p class="sidetitle"><strong>DIFFERENCES IN SCROLLING BETWEEN OPERATING SYSTEMS</strong></p>&#13;
<p class="noindent">Windows, macOS, and Linux differ when it comes to scrolling. On macOS, scrolling or gesturing up returns a positive value, so the code we just wrote will increase the bubble size when the user scrolls or gestures up and shrink the size when the user scrolls down. On Windows and most Linux flavors, scrolling up with the mouse wheel moves a web page or document <em>down</em> instead, returning a negative number from <code>getUnitsToScroll()</code>. This means that scrolling up will cause the bubbles to get smaller, while scrolling down will add to the size and make them larger.</p>&#13;
<p class="indent">If you want to make your app work the same way on all three operating systems, change the code to the following:</p>&#13;
<p class="pre">        public void mouseWheelMoved(MouseWheelEvent e) {<br/>&#13;
            if(System.<em>getProperty</em>("os.name").startsWith("Mac"))<br/>&#13;
                size += e.getUnitsToScroll();<br/>&#13;
            else<br/>&#13;
                size -= e.getUnitsToScroll();<br/>&#13;
        }</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_217"/>The <code>if</code> statement gets the operating system name with <code>System.getProperty ("os.name")</code> and checks whether the name starts with the string <code>"Mac"</code>. If so, we add the units scrolled to <code>size</code>. Otherwise, we subtract the units scrolled from <code>size</code> to reverse Windows and Linux scrolling to positive for up, negative for down.</p>&#13;
</div>&#13;
<p class="indent">Lastly, add the mouse wheel listener to the <code>BubblePanel()</code> constructor, just below the previous two listeners:</p>&#13;
<p class="pre">    <span class="gray">public BubblePanel() {</span><br/>&#13;
        <span class="gray">bubbleList = new ArrayList&lt;Bubble&gt;();</span><br/>&#13;
        <span class="gray">setBackground(Color.<em>BLACK</em>);</span><br/>&#13;
        <span class="gray">// testBubbles();</span><br/>&#13;
        <span class="gray">addMouseListener( new BubbleListener() );</span><br/>&#13;
        <span class="gray">addMouseMotionListener( new BubbleListener() );</span><br/>&#13;
        addMouseWheelListener( new BubbleListener() );<br/>&#13;
    <span class="gray">}</span></p>&#13;
<p class="indent">Save and run the app now, and you should be able to change the bubble size by scrolling your mouse wheel or gesturing up or down on your trackpad, as shown in <a href="ch9.xhtml#ch9fig6">Figure 9-6</a>.</p>&#13;
<div class="imagef"><img src="../images/f0217-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch9fig6"/>Figure 9-6: Use your mouse wheel or trackpad to change the size of the bubbles.</em></p>&#13;
<p class="indent">The first version of the BubbleDraw app is complete! You can click and drag to draw with multicolored bubbles on the screen, scroll up and down to change the bubble size, maximize the window to draw fullscreen, and more.</p>&#13;
<h3 class="h3"><span epub:type="pagebreak" id="page_218"/><a id="toc_lev163"/>What You Learned</h3>&#13;
<p class="noindent">You’ve designed a colorful, interactive drawing app though an object-oriented programming approach by creating a <code>Bubble</code> class to capture the features and behaviors of bubbles.</p>&#13;
<p class="indentb">Here are some of the new things you’ve learned in this chapter:</p>&#13;
<p class="bull">• Building a single app with multiple classes and multiple Java source code files</p>&#13;
<p class="bull">• Using an object-oriented programming approach to break a problem down into smaller pieces</p>&#13;
<p class="bull">• Building the <code>Bubble</code> class from scratch, including attributes, methods, and a constructor</p>&#13;
<p class="bull">• Creating random colors using the <code>java.util.Random</code> and <code>java.awt.Color</code> classes</p>&#13;
<p class="bull">• Generating random numbers in a given range with <code>Random.nextInt(range)</code></p>&#13;
<p class="bull">• Drawing graphics with the <code>java.awt.Graphics</code> class</p>&#13;
<p class="bull">• Using the <code>paintComponent()</code> method to describe what your app should draw and using <code>repaint()</code> to clear the screen and redraw</p>&#13;
<p class="bull">• Writing event handlers for mouse events, including clicks, movement, and mouse wheel events</p>&#13;
<p class="bull">• Using the <code>java.util.ArrayList</code> class to store a dynamic list of objects, such as the bubbles in BubbleDraw</p>&#13;
<p class="bull">• Adding multiple event listeners to an app using a custom listener class, <code>BubbleListener</code></p>&#13;
<h3 class="h3"><a id="toc_lev164"/>Programming Challenges</h3>&#13;
<p class="noindent">Try these programming challenge exercises to review and practice what you’ve learned, as well as to expand your programming skills. Visit the book’s website at <em><a href="https://www.nostarch.com/learnjava/">https://www.nostarch.com/learnjava/</a></em> for sample solutions.</p>&#13;
<h4 class="h4"><em><a id="toc_lev165"/>#1: No Bubble Too Small</em></h4>&#13;
<p class="noindent">If you scroll the mouse down enough, the bubbles will simply disappear because the <code>size</code> value drops below <code>0</code>, resulting in a circle that Java can’t draw on the screen. In fact, a <code>size</code> of <code>2</code> or smaller will produce bubbles just a single pixel tall, so let’s make sure the value of <code>size</code> stays at least 3 pixels by 3 pixels to keep the bubbles circular.</p>&#13;
<p class="indent">Add a little logic to the <code>mouseWheelMoved()</code> method in the <code>BubbleListener</code> class in <em>BubblePanel.java</em> to check whether the <code>size</code> variable goes below a value of <code>3</code>. If so, set <code>size</code> equal to <code>3</code> to keep the bubble visible on the screen. Add this new <code>if</code> statement to the end of the <code>mouseWheelMoved()</code> method so that you check the size after it’s changed, not before.</p>&#13;
<p class="indent">Run the app with the change, and you should be able to scroll the mouse wheel until the bubbles are just a couple of pixels wide, but they’ll no longer disappear. Great work!</p>&#13;
<h4 class="h4"><span epub:type="pagebreak" id="page_219"/><em><a id="toc_lev166"/>#2: PixelDraw!</em></h4>&#13;
<p class="noindent">Add just a little bit of math to the constructor for new <code>Bubble()</code> objects, and you can create a cool, pixelated effect, as shown in <a href="ch9.xhtml#ch9fig7">Figure 9-7</a>.</p>&#13;
<div class="imagef"><img src="../images/f0219-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch9fig7"/>Figure 9-7: Changing the location of new Bubbles slightly can create a cool pixel-drawing effect.</em></p>&#13;
<p class="indent">Let’s copy the <em>BubbleDraw</em> project folder to make the changes in a new project without messing up the original app. Double-click your <em>BubblePanel .java</em> tab to restore the default view and then, in the Package Explorer, press <small>CTRL</small>-C or <img class="inline" src="../images/symbol.jpg" alt="Image"/>-C to copy the <em>BubbleDraw</em> project folder. Press <small>CTRL</small>-V or <img class="inline" src="../images/symbol.jpg" alt="Image"/>-V to paste a new copy of the folder into your workspace. Change the name of the folder to <strong>PixelDraw</strong>, as shown in <a href="ch9.xhtml#ch9fig8">Figure 9-8</a>.</p>&#13;
<div class="imagef"><img src="../images/f0219-02.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch9fig8"/>Figure 9-8: You can copy a project folder in the Package Explorer and paste it to create a new copy.</em></p>&#13;
<p class="indent">Change the code for the <code>Bubble()</code> constructor inside the private class <code>Bubble</code> as follows.</p>&#13;
<p class="pre"><span epub:type="pagebreak" id="page_220"/>    <span class="gray">public Bubble(int newX, int newY, int newSize) {</span><br/>&#13;
        x = (newX / newSize) * newSize + newSize/2;<br/>&#13;
        y = (newY / newSize) * newSize + newSize/2;<br/>&#13;
        <span class="gray">size = newSize;</span><br/>&#13;
        <span class="gray">color = new Color( rand.nextInt(256),</span><br/>&#13;
                <span class="gray">rand.nextInt(256),</span><br/>&#13;
                <span class="gray">rand.nextInt(256) );</span><br/>&#13;
    <span class="gray">}</span></p>&#13;
<p class="indent">This new math only alters the (x, y) location of each new bubble because of the way Java handles division of two integer values. Java keeps only the integer, or whole number, result when you divide two integers, so dividing by <code>newSize</code> and multiplying by <code>newSize</code> will make your bubbles appear to be on a grid, as you saw back in <a href="ch9.xhtml#ch9fig7">Figure 9-7</a>. For example, if <code>newSize</code> is <code>10</code> and <code>x</code> is <code>25</code>, then <code>x</code> divided by <code>newSize</code> would be <code>25 / 10</code>, which evaluates to <code>2</code> in Java. Multiplying by <code>10</code> then gives us <code>20</code>, the location of the bubble on a 10×10 pixel grid. We add <code>newSize/2</code> to each coordinate to center the dots within the imaginary grid. Remember, scrolling the mouse wheel still changes the size of the bubbles, so you can draw thick, blocky images or fine, pixel-perfect drawings.</p>&#13;
<p class="indent">If you’d like to make the pixel effect more <em>Minecraft</em>-y, you can make the bubbles into squares. To do so, change the <code>draw()</code> method to fill rectangles instead of ovals by commenting out the <code>fillOval()</code> command and using the <code>fillRect()</code> command instead:</p>&#13;
<p class="pre">    <span class="gray">public void draw(Graphics canvas) {</span><br/>&#13;
        <span class="gray">canvas.setColor(color);</span><br/>&#13;
        // <span class="gray">canvas.fillOval(x - size/2, y - size/2, size, size);</span><br/>&#13;
        canvas.fillRect(x - size/2, y - size/2, size, size);<br/>&#13;
    <span class="gray">}</span></p>&#13;
<p class="indent">Now you can draw in a pixelated style, as shown in <a href="ch9.xhtml#ch9fig9">Figure 9-9</a>.</p>&#13;
<div class="imagef"><img src="../images/f0220-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch9fig9"/>Figure 9-9: Drawing with rectangles instead of ovals creates a pixelated drawing effect.</em></p>&#13;
</body></html>