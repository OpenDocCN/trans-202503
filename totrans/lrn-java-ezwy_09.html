<html><head></head><body>
<h2 class="h2" id="ch9"><span epub:type="pagebreak" id="page_197"/><span class="big"><strong>9</strong></span></h2>&#13;
<h2 class="h2a">PAINT COLORFUL BUBBLES WITH YOUR MOUSE!</h2>&#13;
<div class="image21"><img src="../images/circle.jpg" alt="Image"/></div>&#13;
<p class="noindent">In the next three chapters, we’ll build BubbleDraw, an interactive, animated drawing app that lets the user draw floating, bouncy, colorful bubbles with their mouse in the desktop version and with their fingers in the mobile version!</p>&#13;
<p class="indent">The first version of the BubbleDraw app will look like <a href="ch9.xhtml#ch9fig1">Figure 9-1</a>, with each bubble in a different random color. It will let the user draw bubbles of random colors whenever they click and drag the mouse on the app window. The user will also be able to change the size of the bubbles by scrolling the mouse wheel up and down or by using a scroll gesture on a trackpad or touchscreen.</p>&#13;
<div class="imagef"><span epub:type="pagebreak" id="page_198"/><img src="../images/f0198-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch9fig1"/>Figure 9-1: The BubbleDraw app lets the user draw randomly colored bubbles using the mouse.</em></p>&#13;
<p class="indent">We’re going to use an object-oriented programming approach to build the BubbleDraw app. The variables, functions, loops, and conditional statements you’ve learned so far are known as <em>procedural programming</em>. Procedural programming involves writing programs step-by-step in a linear fashion, sort of like following a recipe. Object-oriented programming uses all of these concepts, but it allows us to program much larger and more complicated applications by breaking a big software project into smaller pieces called <em>objects</em>.</p>&#13;
<p class="indent">As an example, a bubble is an important entity in the BubbleDraw app, so bubbles might become objects as we begin to code this app. First, we’ll tackle the problem of defining what a bubble is. Second, we’ll figure out a way to store information on lots of bubbles and how to draw the bubbles on the screen. Finally, we’ll add the ability to click and drag the mouse to create bubbles. Instead of writing separate pieces of code to control each bubble individually, we’ll write one piece of code that applies to all bubble objects.</p>&#13;
<p class="indent">We’ll begin with two source code files: one for the app window called <em>BubbleDraw</em> and one for the drawing canvas called <em>BubblePanel</em>. The app window will extend a familiar class, <span class="literal">JFrame</span>, and the drawing canvas inside the window frame will use a new kind of GUI container called a <span class="literal">JPanel</span>. By building two separate files, we’ll be able to reuse the drawing canvas in a GUI app in <a href="ch10.xhtml#ch10">Chapter 10</a>. Let’s start coding!</p>&#13;
<h3 class="h3"><a id="toc_lev150"/>Creating the BubbleDraw Project Files</h3>&#13;
<p class="noindent">In Eclipse, go to <strong>File</strong> <span class="ent">▸</span> <strong>New</strong> <span class="ent">▸</span> <strong>Java Project</strong> and create a new project folder for the BubbleDraw app. Name the project <span class="codestrong"><span class="literal">BubbleDraw</span></span> and click <strong>Finish</strong>.</p>&#13;
<p class="indent">Expand the <em>BubbleDraw</em> project folder in the Project Explorer pane, right-click the <em>src</em> folder, and select <strong>New</strong> <span class="ent">▸</span> <strong>Class</strong>. Create a class called <span epub:type="pagebreak" id="page_199"/><span class="literal">BubbleDraw</span> for the app window, with <span class="literal">javax.swing.JFrame</span> as the superclass, and under <strong>Which method stubs . . .</strong> select the <strong>public static void main(String[] args)</strong> checkbox. Then click <strong>Finish</strong>.</p>&#13;
<p class="indent">Next, we’ll create the BubblePanel drawing canvas. Right-click the <em>src</em> folder and select <strong>New</strong> <span class="ent">▸</span> <strong>Class</strong>. Name this class <span class="codestrong"><span class="literal">BubblePanel</span></span>, with a superclass of <span class="literal">javax.swing.JPanel</span>. Click <strong>Finish</strong>.</p>&#13;
<p class="indent">Using these classes, we’ll create a reusable <span class="literal">BubblePanel</span> canvas that we can expand and put into other apps. The <span class="literal">BubbleDraw</span> frame will be a container that displays the <span class="literal">BubblePanel</span>.</p>&#13;
<h3 class="h3"><a id="toc_lev151"/>Building the BubbleDraw Frame</h3>&#13;
<p class="noindent">Let’s begin by setting up the main app window in the <em>BubbleDraw.java</em> source code file. Click the <em>BubbleDraw.java</em> tab at the top of the content pane in Eclipse, and you’ll see the following code has already been filled in:</p>&#13;
<p class="pre">import javax.swing.JFrame;<br/>&#13;
public class BubbleDraw extends JFrame {<br/>&#13;
    public static void main(String[] args) {<br/>&#13;
    }<br/>&#13;
}</p>&#13;
<p class="indent">The app window runs in a <span class="literal">JFrame</span>, like our previous GUI apps did. In this app, we need the window to display the drawing canvas, our <span class="literal">BubblePanel</span>. We won’t add any other GUI components to this first version of the app.</p>&#13;
<p class="indent">We want to create a <span class="literal">JFrame</span> window and add setup code for the frame as we have in previous chapters, but we’ll also add a <span class="literal">BubblePanel</span> to the frame for our drawing canvas. The complete <span class="literal">BubbleDraw</span> class will look like <a href="ch9.xhtml#ch9list1">Listing 9-1</a>:</p>&#13;
<p class="pre">import javax.swing.JFrame;<br/>&#13;
public class BubbleDraw extends JFrame {<br/>&#13;
    public static void main(String[] args) {<br/>&#13;
      <span class="ent">➊</span> JFrame frame = new JFrame("<em>Your Name</em>'s BubbleDraw App");<br/>&#13;
      <span class="ent">➋</span> frame.setDefaultCloseOperation(JFrame.<em>EXIT_ON_CLOSE</em>);<br/>&#13;
      <span class="ent">➌</span> frame.getContentPane().add(new BubblePanel());<br/>&#13;
      <span class="ent">➍</span> frame.setSize(new java.awt.Dimension(600,400));<br/>&#13;
      <span class="ent">➎</span> frame.setVisible(true);<br/>&#13;
    }<br/>&#13;
}</p>&#13;
<p class="code-title"><em><a id="ch9list1"/>Listing 9-1: The BubbleDraw</em>  <em>class</em></p>&#13;
<p class="indent">Start by creating a new <span class="literal">JFrame</span> with a title bar at the top <span class="ent">➊</span>. Put your own name in the title string. Next, set the default close operation so that the app exits when the user closes the window <span class="ent">➋</span>. Then add the code to open a new <span class="literal">BubblePanel</span> drawing canvas as the content inside this frame <span class="ent">➌</span>. The last two lines set the size of the window <span class="ent">➍</span> and make it visible <span class="ent">➎</span>.</p>&#13;
<p class="indent">Save the <em>BubbleDraw.java</em> file and run it once. You’ll see a gray Java frame with <span class="literal">"</span><em>Your Name</em><span class="literal">'s BubbleDraw App"</span> in the title bar. We’ll build the logic for the <span class="literal">BubblePanel</span> drawing canvas next.</p>&#13;
<h3 class="h3"><span epub:type="pagebreak" id="page_200"/><a id="toc_lev152"/>Creating a Class for Bubbles</h3>&#13;
<p class="noindent">Switch to the tab for the <em>BubblePanel.java</em> file. This file will contain all the logic for drawing bubbles on the screen. Our first task will be creating a <span class="literal">Bubble</span> class to store each bubble’s color, size, and location on the screen.</p>&#13;
<h4 class="h4"><em><a id="toc_lev153"/>Defining a Bubble</em></h4>&#13;
<p class="noindent">The reason for building a class is quite practical: in the older, procedural approach to programming, we would need a separate variable for each bubble’s x- and y-coordinates, size, and so on. For example, we’d need a <span class="literal">bubble1x</span> variable for the first bubble’s x-location, as well as <span class="literal">bubble1y</span>, <span class="literal">bubble1size</span>, and <span class="literal">bubble1color</span> variables for that bubble. That wouldn’t be so bad, but what if we drag the mouse for a few seconds and wind up with a thousand bubbles? We would need 4,000 variables just to keep track! Instead, we can use properties inside a class to store those values for each bubble.</p>&#13;
<p class="indent">Before we start writing code, let’s define what a bubble is. As shown earlier in <a href="ch9.xhtml#ch9fig1">Figure 9-1</a>, a bubble is a colorful, filled circle, and bubbles can be different sizes and in different locations.</p>&#13;
<p class="indent">All of those features are attributes of bubbles in this app. In object-oriented programming, we use the nouns and adjectives that describe an object to build a list of attributes when we create a new class. Attributes are stored as class variables.</p>&#13;
<p class="indent">Besides attributes, a class can also contain methods. A method is a type of function associated with a specific class. Methods enable a class to do something. Think about what we want the bubbles in the drawing app to do. We need to create a bubble whenever the user clicks or drags the mouse. We’ll also draw a bubble every time the screen refreshes. The verbs—like <em>create</em> and <em>draw</em>—will help us identify the methods we need in our bubble class.</p>&#13;
<p class="indent">When we capture all of those attributes and methods into a single class, we can describe any bubble we might want to show on the screen. This is how a coder solves problems with object-oriented programming: by breaking big applications into smaller pieces, creating classes by asking questions about what the program contains, and then identifying methods and attributes by asking what each object of a new class should do and what kind of information it needs.</p>&#13;
<p class="indent">Let’s begin writing the <span class="literal">Bubble</span> class. We’ll do this inside the <span class="literal">BubblePanel</span> class, as <span class="literal">BubblePanel</span> is the only place we need to draw bubbles. Start coding your <span class="literal">Bubble</span> class before the closing brace at the end of <span class="literal">BubblePanel</span>, as follows:</p>&#13;
<p class="pre"><span class="gray">import javax.swing.JPanel;</span><br/>&#13;
<span class="gray">public class BubblePanel extends JPanel {</span><br/>&#13;
    private class Bubble {<br/>&#13;
    }<br/>&#13;
<span class="gray">}</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_201"/>We usually make internal and helper classes private to keep other programs from accessing them directly. So, to make <span class="literal">Bubble</span> an internal class accessible only from a <span class="literal">BubblePanel</span>, we declare it as <span class="literal">private</span>. This technique, called <em>encapsulation</em>, means that the <span class="literal">BubblePanel</span> class hides its inner workings from other classes. Encapsulation is one of the core principles of object-oriented programming, and it’s a best practice worth following because it means we can change the way the <span class="literal">Bubble</span> class works internally and know for certain that we won’t break other parts of the code. Since <span class="literal">Bubble</span> is declared as <span class="literal">private</span>, we know that there isn’t any code outside of the <span class="literal">BubblePanel</span> class that depends on it. This is especially important for bigger applications that contain a large number of classes and are worked on by many programmers.</p>&#13;
<p class="indent"><span class="literal">BubblePanel</span> will rely on the <span class="literal">Bubble</span> class to store information on individual bubbles as the user draws on the screen. A bubble has an (x, y) location on the screen, a size, and a color, so we can make these attributes as variables inside <span class="literal">Bubble</span>. The x- and y-coordinates of the bubble’s location and the size of the bubble can all be stored as integer values:</p>&#13;
<p class="pre"><span class="gray">import javax.swing.JPanel;<br/>&#13;
public class BubblePanel extends JPanel {<br/>&#13;
    private class Bubble {</span><br/>&#13;
        private int x;<br/>&#13;
        private int y;<br/>&#13;
        private int size;<br/>&#13;
    <span class="gray">}</span><br/>&#13;
<span class="gray">}</span></p>&#13;
<p class="indent">Here we make two separate variables called <span class="literal">x</span> and <span class="literal">y</span> to store the bubble’s coordinates, as well as a <span class="literal">size</span> variable. These attributes are <span class="literal">private</span>, so only the <span class="literal">Bubble</span> class itself can change those values directly. We encapsulate all the data a bubble should have inside the <span class="literal">Bubble</span> class, and we interact with bubbles using the methods in that class only.</p>&#13;
<p class="indent">As mentioned earlier, each bubble in our app can have its own color. The <span class="literal">java.awt</span> library has a <span class="literal">Color</span> class that handles <em>RGB</em> (<em>red-green-blue</em>) color values to reproduce any color that we can display on our monitor. We’ll talk a bit more about RGB when we actually write the code to control bubble colors later in the chapter, so for now just import the <span class="literal">java.awt.Color</span> class at the top of the file and add an attribute called <span class="literal">color</span> to the <span class="literal">Bubble</span> class, like so:</p>&#13;
<p class="pre">import java.awt.Color;<br/>&#13;
<span class="gray">import javax.swing.JPanel;<br/>&#13;
public class BubblePanel extends JPanel {<br/>&#13;
    private class Bubble {</span><br/>&#13;
        <span class="gray">private int x;</span><br/>&#13;
        <span class="gray">private int y;</span><br/>&#13;
        <span class="gray">private int size;</span><br/>&#13;
        private Color color;<br/>&#13;
    <span class="gray">}<br/>&#13;
}</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_202"/>Now that we’ve added the four attributes we want each bubble to have (<span class="literal">x</span>, <span class="literal">y</span>, <span class="literal">size</span>, and <span class="literal">color</span>), we can start building the behaviors, or functions, of a bubble to give values to these attributes. We’ll do that by adding methods inside the <span class="literal">Bubble</span> class.</p>&#13;
<h4 class="h4"><em><a id="toc_lev154"/>Designing a Bubble’s Methods</em></h4>&#13;
<p class="noindent">The <span class="literal">Bubble</span> class will have two actions, which we’ll turn into methods: creating a bubble and drawing a bubble on the desktop screen.</p>&#13;
<p class="indent">Methods that create objects have a special name: <em>constructors</em>. A constructor sets up an object by assigning values to the object’s attributes. When we assign values to the attributes inside a constructor, we’re <em>initializing</em> them. For the <span class="literal">Bubble</span> class, we want to initialize the <span class="literal">x</span>, <span class="literal">y</span>, <span class="literal">size</span>, and <span class="literal">color</span> attributes of an individual bubble.</p>&#13;
<h5 class="h5">Building the Constructor</h5>&#13;
<p class="noindent">A constructor method begins with the keyword <span class="literal">public</span>, followed by the name of the class and a pair of parentheses. If there are any parameters you want to pass in as you set up an object, you place those inside the parentheses. We want to assign each bubble its <span class="literal">x</span>, <span class="literal">y</span>, and <span class="literal">size</span> values when it is created, so the constructor for the <span class="literal">Bubble</span> class looks like <a href="ch9.xhtml#ch9list2">Listing 9-2</a>.</p>&#13;
<p class="pre">    <span class="gray">private class Bubble {</span><br/>&#13;
        <span class="gray">private int x;</span><br/>&#13;
        <span class="gray">private int y;</span><br/>&#13;
        <span class="gray">private int size;</span><br/>&#13;
        <span class="gray">private Color color;</span><br/>&#13;
      <span class="ent">➊</span> public Bubble(int newX, int newY, int newSize) {<br/>&#13;
         <span class="ent">➋</span> x = newX;<br/>&#13;
         <span class="ent">➌</span> y = newY;<br/>&#13;
         <span class="ent">➍</span> size = newSize;<br/>&#13;
        }<br/>&#13;
    <span class="gray">}</span></p>&#13;
<p class="code-title"><em><a id="ch9list2"/>Listing 9-2: The Bubble class constructor</em></p>&#13;
<p class="indent">Each bubble’s coordinates and size will be determined by the user, so we want to pass the x- and y-coordinates and a size as integer values to the <span class="literal">Bubble()</span> constructor as each new bubble is created. These values are the three parameters we pass to the <span class="literal">Bubble()</span> method and are called <span class="literal">newX</span>, <span class="literal">newY</span>, and <span class="literal">newSize</span> <span class="ent">➊</span>. Later in the code, when we handle the user creating bubbles, we’ll be outside the private <span class="literal">Bubble</span> class. That means we won’t have direct access to the bubble’s attributes, so we can’t just assign values to the <span class="literal">x</span>, <span class="literal">y</span>, and <span class="literal">size</span> attributes of each bubble. In order to get around that, we assign the attributes values through the <span class="literal">Bubble()</span> constructor, which takes the input from the user; assigns the input values to <span class="literal">newX</span>, <span class="literal">newY</span>, and <span class="literal">newSize</span>; and then assigns the user input values to the bubble’s attributes at <span class="ent">➋</span>, <span class="ent">➌</span>, and <span class="ent">➍</span>.</p>&#13;
<p class="indent">We also want each bubble to have a random color. Because the color will be random, we don’t need to pass it to the constructor using a parameter. Instead, we can create the color inside the constructor.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_203"/>We’ll need to generate random RGB color values to create a color for each bubble. RGB works by combining different amounts of red, green, and blue light on your computer monitor to produce different colors. In programming, each of these three colors is represented by an integer between 0 (none of the color) and 255 (the maximum amount of the color possible). To make a color, we need to get three integers between 0 and 255, separate them with commas, and group them together between parentheses. For example, pure red has an RGB value of (255, 0, 0), meaning full red, no green, and no blue. Yellow is (255, 255, 0) in RGB, meaning full amounts of red and green, but no blue. In total, there are over 16 million RGB color values that can be created this way.</p>&#13;
<p class="indent">We’ve generated random numbers with the <span class="literal">Math</span> class’s <span class="literal">Math.random()</span> method before when we needed a single number, but in the BubbleDraw app, we’ll need three random numbers (one for each part of RGB), so let’s look at a new way to generate random values.</p>&#13;
<p class="indent">The <span class="literal">java.util.Random</span> class contains several useful methods, including <span class="literal">nextInt()</span>, which will let us instantly generate a random integer up to a certain size without having to do additional math or rounding. To use the <span class="literal">Random</span> class, we’ll have to import it first, at the top of the <em>BubblePanel.java</em> file:</p>&#13;
<p class="pre">import java.util.Random;<br/>&#13;
<span class="gray">import java.awt.Color;<br/>&#13;
import javax.swing.JPanel;</span></p>&#13;
<p class="indent">Because <span class="literal">Random</span> is a class, we need to create a new object or variable of the <span class="literal">Random</span> type to access its functions. Add the following line inside the top of the <span class="literal">BubblePanel</span> class:</p>&#13;
<p class="pre"><span class="gray">import java.util.Random;<br/>&#13;
import java.awt.Color;<br/>&#13;
import javax.swing.JPanel;<br/>&#13;
public class BubblePanel extends JPanel {</span><br/>&#13;
    Random rand = new Random();<br/>&#13;
    <span class="gray">private class Bubble {</span></p>&#13;
<p class="indent">This line creates a random number generator called <span class="literal">rand</span> that will allow us to generate random integer or floating-point values quickly. We’re encapsulating <span class="literal">rand</span> by putting it at the top of the <span class="literal">BubblePanel</span> class so that we can generate random numbers both in the drawing window and in the inner <span class="literal">Bubble</span> class, but not outside a <span class="literal">BubblePanel</span>.</p>&#13;
<p class="indent">To create a random color in Java, we can use the constructor for the <span class="literal">java.awt.Color</span> class that we imported earlier. The constructor will accept three integer arguments between <span class="literal">0</span> and <span class="literal">255</span> for the red, green, and blue values to create a color.</p>&#13;
<p class="indent">Add the following code to the <span class="literal">Bubble()</span> constructor method:</p>&#13;
<p class="pre">      <span class="gray">public Bubble(int newX, int newY, int newSize) {</span><br/>&#13;
          <span class="gray">x = newX;</span><br/>&#13;
          <span class="gray">y = newY;</span><br/>&#13;
          <span class="gray">size = newSize;</span><br/>&#13;
          color = new Color( rand.nextInt(256),<br/>&#13;
                  rand.nextInt(256),<br/>&#13;
                  rand.nextInt(256) );<br/>&#13;
      <span class="gray">}</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_204"/>We use the <span class="literal">new</span> keyword with the constructor for the <span class="literal">Color</span> class to create a new color, and each of the RGB color values will be a randomly generated integer between <span class="literal">0</span> and <span class="literal">255</span>. Every time you call the <span class="literal">nextInt()</span> method, it generates a new random integer between 0 and the maximum integer you pass it. Here, we want random color values from <span class="literal">0</span> to <span class="literal">255</span>, so we pass it <span class="literal">256</span> because <span class="literal">nextInt()</span> generates an integer up to, but not including, the upper bound passed to it.</p>&#13;
<h5 class="h5">Coding the Method to Draw a Bubble</h5>&#13;
<p class="noindent">Now that each bubble has an (x, y) location, a size, and a random color, let’s add the ability to draw bubbles on the screen. To draw colorful graphics on the screen, we’ll import the <span class="literal">java.awt.Graphics</span> class. This <span class="literal">Graphics</span> class contains methods such as <span class="literal">setColor()</span> to choose a paint color, <span class="literal">drawRect()</span> to draw a rectangle, and <span class="literal">fillOval()</span> to paint a filled-in oval on the screen, just to name a few. We’ll use <span class="literal">fillOval()</span> to draw our circles, so add the following <span class="literal">import</span> statement to the top of the <em>BubblePanel.java</em> file:</p>&#13;
<p class="pre">import java.awt.Graphics;<br/>&#13;
<span class="gray">import java.util.Random;<br/>&#13;
import java.awt.Color;<br/>&#13;
import javax.swing.JPanel;</span></p>&#13;
<p class="indent">Next, let’s add a <span class="literal">draw()</span> method to the <span class="literal">Bubble</span> inner class, below the <span class="literal">Bubble()</span> constructor:</p>&#13;
<p class="pre">    <span class="gray">private class Bubble {</span><br/>&#13;
        <span class="gray">private int x;</span><br/>&#13;
        <span class="gray">private int y;</span><br/>&#13;
        <span class="gray">private int size;</span><br/>&#13;
        <span class="gray">private Color color;</span><br/>&#13;
        <span class="gray">public Bubble(int newX, int newY, int newSize) {</span><br/>&#13;
            <span class="gray">--<span class="codeitalic">snip</span>--<br/>&#13;
        }</span><br/>&#13;
        public void draw(Graphics canvas) {<br/>&#13;
            <span class="ent">➊</span> canvas.setColor(color);<br/>&#13;
            <span class="ent">➋</span> canvas.fillOval(x - size/2, y - size/2, size, size);<br/>&#13;
        }<br/>&#13;
<span class="gray">}</span></p>&#13;
<p class="indent">The <span class="literal">draw()</span> method accepts one parameter, a <span class="literal">Graphics</span> canvas called <span class="literal">canvas</span>. Inside the <span class="literal">draw()</span> method, we call the <span class="literal">setColor()</span> method on <span class="literal">canvas</span> <span class="ent">➊</span> to set the drawing color to the color stored in the <span class="literal">color</span> variable of the bubble we’ll draw. At <span class="ent">➋</span>, we call <span class="literal">fillOval()</span> to paint a filled-in circle on the screen. The <span class="literal">fillOval()</span> method takes four parameters, the x- and y-coordinate of <span epub:type="pagebreak" id="page_205"/>the upper-left corner of a bounding box in which we’ll draw the oval, followed by the width and height of the box. Think of the bounding box as an invisible rectangle at that (x, y) location with the given width and height and the oval as a balloon that will be blown up until it touches all four sides of the box (see <a href="ch9.xhtml#ch9fig2">Figure 9-2</a>). By setting the same width and height for the box to make it square, we’ll end up with a circle instead of an oval.</p>&#13;
<p class="indent">Because our ovals are actually circles, the width and height are the same value—the size of the bubble in pixels we stored in the <span class="literal">size</span> attribute. At <span class="ent">➋</span>, we want the bubble to be centered on the (x, y) location the user clicked, so we adjust the upper-left corner of each bubble by subtracting half the size (<span class="literal">size/2</span>) from each of the <span class="literal">x</span> and <span class="literal">y</span> values.</p>&#13;
<div class="imagef"><img src="../images/f0205-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch9fig2"/>Figure 9-2: The fillOval() method takes four parameters, the upper-left corner’s xand y-coordinates, followed by the oval’s width and height.</em></p>&#13;
<p class="indent">With the addition of the <span class="literal">draw()</span> method, we now have a complete <span class="literal">Bubble</span> class that can remember the location, size, and color of a bubble. The class methods we made can be used to create new bubbles and draw them on the screen. It’s time to add logic to the <span class="literal">BubblePanel</span> class to use those methods to create and draw bubbles whenever the user clicks and drags on the screen.</p>&#13;
<h3 class="h3"><a id="toc_lev155"/>Storing Bubbles in an ArrayList</h3>&#13;
<p class="noindent">We need a way to store all the bubbles the user creates when they click and drag around the screen. Java’s libraries contain several useful <em>data structures</em>, which are classes for storing groups of objects.</p>&#13;
<p class="indent">The <span class="literal">java.util.ArrayList</span> is a <em>dynamic</em> data structure. That means it not only stores a collection of objects but can also grow or shrink depending on the needs of the program. For the BubbleDraw app, we can’t predict how many bubbles the user will draw, so a dynamic data structure like an <span class="literal">ArrayList</span> is the perfect option for storing all the bubbles a user could create. An <span class="literal">ArrayList</span> is a flexible way to store things when you don’t know how many items you’ll need in advance. A regular array in Java has a fixed size, but an <span class="literal">ArrayList</span> can keep adding new bubbles every time the user clicks.</p>&#13;
<p class="indent">First, let’s import <span class="literal">java.util.ArrayList</span> at the top of the <em>BubblePanel.java</em> file so we can access <span class="literal">ArrayList</span> data types:</p>&#13;
<p class="pre">import java.util.ArrayList;<br/>&#13;
<span class="gray">import java.awt.Graphics;<br/>&#13;
import java.util.Random;<br/>&#13;
import java.awt.Color;<br/>&#13;
import javax.swing.JPanel;</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_206"/>Next, we need to declare an <span class="literal">ArrayList</span> that will hold objects of the <span class="literal">Bubble</span> class. Inside the <span class="literal">BubblePanel</span> class, add the following declaration:</p>&#13;
<p class="pre"><span class="gray">public class BubblePanel extends JPanel {</span><br/>&#13;
    <span class="gray">Random rand = new Random();</span><br/>&#13;
    ArrayList&lt;Bubble&gt; bubbleList;</p>&#13;
<p class="indent">The <span class="literal">ArrayList</span> data structure can accept a type specifier inside the angle brackets, <span class="literal">&lt;</span> and <span class="literal">&gt;</span>, to tell Java what type of objects the <span class="literal">ArrayList</span> will hold. An <span class="literal">ArrayList</span> can hold any type of object, but the <span class="literal">ArrayList</span> we’re declaring, <span class="literal">bubbleList</span>, will contain only objects of the <span class="literal">Bubble</span> class.</p>&#13;
<p class="indent">Next, let’s take care of one additional variable, <span class="literal">size</span>, for the default bubble size:</p>&#13;
<p class="pre"><span class="gray">public class BubblePanel extends JPanel {</span><br/>&#13;
    <span class="gray">Random rand = new Random();</span><br/>&#13;
    <span class="gray">ArrayList&lt;Bubble&gt; bubbleList;</span><br/>&#13;
    int size = 25;</p>&#13;
<p class="indent">This <span class="literal">size</span> variable sets a starting size for bubble diameters in pixels. I picked <span class="literal">25</span> pixels, but you can choose a larger or smaller starting size if you’d like.</p>&#13;
<h4 class="h4"><em><a id="toc_lev156"/>Adding a Constructor to the BubblePanel Class</em></h4>&#13;
<p class="noindent">We’ve declared <span class="literal">bubbleList</span> to be a dynamic <span class="literal">ArrayList</span> of <span class="literal">Bubble</span> objects, so let’s add a constructor to the <span class="literal">BubblePanel</span> class to initialize <span class="literal">bubbleList</span> and set the background color of the drawing window.</p>&#13;
<p class="indent">Just as we saw in the <span class="literal">Bubble</span> inner class, the constructor for the <span class="literal">BubblePanel</span> class uses the format <span class="literal">public</span> plus the name of the class, followed by a pair of parentheses:</p>&#13;
<p class="pre"><span class="gray">public class BubblePanel extends JPanel {</span><br/>&#13;
    <span class="gray">Random rand = new Random();</span><br/>&#13;
    <span class="gray">ArrayList&lt;Bubble&gt; bubbleList;</span><br/>&#13;
    <span class="gray">int size = 25;</span><br/>&#13;
    public BubblePanel() {<br/>&#13;
    }</p>&#13;
<p class="indent">Notice that we end the constructor with open and close parentheses, because the constructor is a method. Inside the constructor, we initialize <span class="literal">bubbleList</span> to get it ready to store a flexible <span class="literal">ArrayList</span> of <span class="literal">Bubble</span> objects. We also set the background color of the drawing window to black:</p>&#13;
<p class="pre">    <span class="gray">public BubblePanel() {</span><br/>&#13;
     <span class="ent">➊</span> bubbleList = new ArrayList&lt;Bubble&gt;();<br/>&#13;
     <span class="ent">➋</span> setBackground(Color.<span class="codeitalic">BLACK</span>);<br/>&#13;
    <span class="gray">}</span></p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>Although I recommend a black background for the app, the images in this book show a white background for readability.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_207"/>Just as in the declaration of <span class="literal">bubbleList</span>, when we construct a new <span class="literal">ArrayList</span> at <span class="ent">➊</span>, we can specify the type of object we want to store in angle brackets: <span class="literal">&lt;Bubble&gt;</span>.</p>&#13;
<p class="indent">At <span class="ent">➋</span>, we can use the <span class="literal">setBackground()</span> method directly because <span class="literal">BubblePanel</span> is extending <span class="literal">JPanel</span>, and we’ve seen that <span class="literal">JPanel</span> objects have a background color. We’re setting the background to the color constant <span class="literal">Color.BLACK</span> from the <span class="literal">Color</span> class we imported earlier. This constant has an RGB value of (0, 0, 0).</p>&#13;
<p class="indent">Now, when we start the BubbleDraw app and create a <span class="literal">BubblePanel</span> drawing canvas, we’ll begin with an empty list of bubbles and a black screen background.</p>&#13;
<p class="indent">Save your changes so far. In the next section, we’ll fill that window with colorful bubbles!</p>&#13;
<h4 class="h4"><em><a id="toc_lev157"/>Adding a Method to Draw on the Screen</em></h4>&#13;
<p class="noindent">Next, we need to add a method to paint all the bubbles in <span class="literal">bubbleList</span> to the drawing screen.</p>&#13;
<p class="indent">All of the GUI components in the <span class="literal">javax.swing</span> toolkit, including the <span class="literal">JPanel</span> we extended for the <span class="literal">BubblePanel</span> drawing screen, have a <span class="literal">paintComponent()</span> method that draws that component on the screen. We’re going to modify, or <em>override</em>, the default <span class="literal">paintComponent()</span> method to make the <span class="literal">BubblePanel</span> draw all the bubbles in <span class="literal">bubbleList</span>.</p>&#13;
<p class="indent">First, we need to declare the <span class="literal">paintComponent()</span> method. Because we’re overriding the <span class="literal">paintComponent()</span> method that already exists in <span class="literal">JPanel</span>, the parent class of <span class="literal">BubblePanel</span>, we have to use the same <em>method signature</em>, or first line of code. That means we have to match the way <span class="literal">paintComponent()</span> is declared exactly, as a <span class="literal">public void</span> method, with one parameter, of type <span class="literal">Graphics</span>:</p>&#13;
<p class="pre"><span class="gray">public class BubblePanel extends JPanel {</span><br/>&#13;
    <span class="gray">--<span class="codeitalic">snip</span>--<br/>&#13;
    }</span><br/>&#13;
    public void paintComponent(Graphics canvas) {<br/>&#13;
    }</p>&#13;
<p class="indent">We place the <span class="literal">paintComponent()</span> method just below the <span class="literal">BubblePanel()</span> constructor. Notice that <span class="literal">paintComponent()</span> requires a <span class="literal">Graphics</span> object, which we call <span class="literal">canvas</span> just as in the <span class="literal">draw()</span> method we designed for the <span class="literal">Bubble</span> class. Any object that draws on the screen can use a <span class="literal">Graphics</span> object to color the individual pixels on the computer screen.</p>&#13;
<p class="indent">Inside this method, we first want to allow the <span class="literal">JPanel</span> parent class to clear the drawing screen and do any other setup it normally would before drawing anything else. We do this by calling <span class="literal">paintComponent()</span> from the parent class:</p>&#13;
<p class="pre">    <span class="gray">public void paintComponent(Graphics canvas) {</span><br/>&#13;
        super.paintComponent(canvas);<br/>&#13;
    <span class="gray">}</span></p>&#13;
<p class="indent">The keyword <span class="literal">super</span> tells Java to call the original <span class="literal">paintComponent()</span> method from <span class="literal">JPanel</span>. This means that all the code in the original <span class="literal">paintComponent()</span> method will be pulled into our new one. This is a useful object-oriented <span epub:type="pagebreak" id="page_208"/>programming feature: because we extended the <span class="literal">JPanel</span> class to create the new <span class="literal">BubblePanel</span> class, we can take advantage of all the functionality already built into <span class="literal">JPanel</span>, such as clearing the pixels inside the window when the app opens and preparing the <span class="literal">Graphics</span> canvas for drawing colorful graphics. We say that <span class="literal">BubblePanel</span> <em>inherits</em> these functions from <span class="literal">JPanel</span>.</p>&#13;
<p class="indent">Once we’ve prepared the canvas, it’s time to loop through the list of bubbles and draw each one on <span class="literal">canvas</span>. To accomplish this, we’ll use a <span class="literal">for</span> loop in a new way.</p>&#13;
<p class="indent">You first saw a <span class="literal">for</span> loop in <a href="ch6.xhtml#ch6">Chapter 6</a>, when we wanted to loop through each character in a string to encode secret messages. This time, we’re using a shorter version of a <span class="literal">for</span> loop, called a <span class="literal">for each</span> statement, that’s specially designed to loop through a list or collection of objects.</p>&#13;
<p class="indent">Let’s see the working code first, and then I’ll break down the <span class="literal">for each</span> statement piece by piece:</p>&#13;
<p class="pre">  <span class="gray">public void paintComponent(Graphics canvas) {</span><br/>&#13;
      <span class="gray">super.paintComponent(canvas);</span><br/>&#13;
    <span class="ent">➊</span> for(Bubble b : bubbleList) {<br/>&#13;
        <span class="ent">➋</span> b.draw(canvas);<br/>&#13;
      }<br/>&#13;
  <span class="gray">}</span></p>&#13;
<p class="indent">You can read the <span class="literal">for each</span> statement at <span class="ent">➊</span> as “For each <span class="literal">Bubble</span> <span class="literal">b</span> in <span class="literal">bubbleList</span>.” You can tell this is a <span class="literal">for each</span> statement instead of a regular <span class="literal">for</span> loop, first because of the colon in the middle and, second, because it doesn’t have the three parts we saw in <span class="literal">for</span> loops back in <a href="ch6.xhtml#ch6">Chapter 6</a>: <em>initialization, condition</em>, and <em>update</em>. Java uses the same keyword <span class="literal">for</span> and parentheses for both loops, but the <span class="literal">for each</span> statement is designed just for collections of objects, such as arrays, <span class="literal">ArrayList</span>s, and so on.</p>&#13;
<p class="indent">For each <span class="literal">Bubble</span> <span class="literal">b</span> in the <span class="literal">ArrayList</span> <span class="literal">bubbleList</span>, the loop will call <span class="literal">b.draw(canvas)</span> <span class="ent">➋</span> to draw that individual bubble on the drawing screen. The first time the loop executes, <span class="literal">b</span> will point to the first <span class="literal">Bubble</span> object in <span class="literal">bubbleList</span>, and each time the loop repeats, <span class="literal">b</span> will point to the next bubble in the list. Calling <span class="literal">b.draw(canvas)</span> tells that bubble to draw itself on the <span class="literal">canvas</span>.</p>&#13;
<p class="indent">This single, short <span class="literal">for each</span> loop will draw every bubble in the <span class="literal">bubbleList</span> to the screen. The only problem is that we don’t have any bubbles to test. Let’s generate some random bubbles to see the app in action before we move on to creating bubbles with the mouse.</p>&#13;
<h4 class="h4"><em><a id="toc_lev158"/>Testing the BubblePanel Class</em></h4>&#13;
<p class="noindent">To test what we’ve done so far, before we add the mouse interaction, we’ll write a test method that draws 100 bubbles of random sizes all over the app window. This will allow us to make sure the app works without writing the final code. This way we can debug any errors in our code early and see a preview of how cool the app will look when it’s finished.</p>&#13;
<p class="indent">Call the new method <span class="literal">testBubbles()</span>. Place it after the <span class="literal">paintComponent()</span> method and before the <span class="literal">private class Bubble</span>, as shown in <a href="ch9.xhtml#ch9list3">Listing 9-3</a>.</p>&#13;
<p class="pre"><span epub:type="pagebreak" id="page_209"/>  <span class="gray">public void paintComponent(Graphics canvas) {</span><br/>&#13;
      <span class="gray">--<span class="codeitalic">snip</span>--<br/>&#13;
      }</span><br/>&#13;
  <span class="gray">}</span><br/>&#13;
<span class="ent">➊</span> public void testBubbles() {<br/>&#13;
    <span class="ent">➋</span> for(int n = 0; n &lt; 100; n++) {<br/>&#13;
        <span class="ent">➌</span> int x = rand.nextInt(600);<br/>&#13;
        <span class="ent">➍</span> int y = rand.nextInt(400);<br/>&#13;
        <span class="ent">➎</span> int size = rand.nextInt(50);<br/>&#13;
        <span class="ent">➏</span> bubbleList.add( new Bubble(x, y, size) );<br/>&#13;
      }<br/>&#13;
    <span class="ent">➐</span> repaint();<br/>&#13;
  }<br/>&#13;
  <span class="gray">private class Bubble {</span></p>&#13;
<p class="code-title"><em><a id="ch9list3"/>Listing 9-3: Creating the testBubbles() method</em></p>&#13;
<p class="indent">At <span class="ent">➊</span>, we declare <span class="literal">testBubbles()</span> as <span class="literal">public</span> with <span class="literal">void</span> as the return type, meaning it doesn’t pass any information back to the program. Then, we use a regular <span class="literal">for</span> loop <span class="ent">➋</span> to go from <span class="literal">n = 0</span> to <span class="literal">99</span>, a total of 100 iterations. That means we’ll create 100 bubbles, and for each bubble, we need an (x, y) location and a size for its width and height in pixels.</p>&#13;
<p class="indent">We set the pixel dimensions of the BubbleDraw app frame to <span class="literal">600</span> wide by <span class="literal">400</span> tall at the beginning of this chapter, so for the bubble’s location, we need an <span class="literal">x</span> value between <span class="literal">0</span> and <span class="literal">600</span> and a <span class="literal">y</span> value between <span class="literal">0</span> and <span class="literal">400</span>. Inside the <span class="literal">for</span> loop, we use the random number generator <span class="literal">rand</span> to get a random integer between <span class="literal">0</span> and <span class="literal">600</span> and store it in the variable <span class="literal">x</span> <span class="ent">➌</span> for the x-coordinate of the center of the bubble on the screen. Then, we generate a y-coordinate value between <span class="literal">0</span> and <span class="literal">400</span> and store it in <span class="literal">y</span> <span class="ent">➍</span>. Next, for the size of the bubble in pixels, we generate a random number between <span class="literal">0</span> and <span class="literal">50</span> <span class="ent">➎</span>. The last step inside the loop creates a new <span class="literal">Bubble</span> object using the random <span class="literal">x</span>, <span class="literal">y</span>, and <span class="literal">size</span> that we just generated, and we add that new <span class="literal">Bubble</span> to the <span class="literal">ArrayList</span> <span class="literal">bubbleList</span> <span class="ent">➏</span>.</p>&#13;
<p class="indent">Finally, we call the <span class="literal">repaint()</span> method ➐. Normally before we draw new computer graphics, we have to clear the screen by drawing an empty, black background, but here <span class="literal">repaint()</span> does this for us. Notice that we didn’t have to clear the background of the screen inside the <span class="literal">paintComponent()</span> method either; all we had to do was draw the bubbles from <span class="literal">bubbleList</span>. The <span class="literal">repaint()</span> method takes care of redrawing the background as well as calling <span class="literal">paintComponent()</span>, so we’ll call it anytime we want to refresh or repaint the screen.</p>&#13;
<p class="indent">There’s just one more step to complete before we can test the app—we need to call the <span class="literal">testBubbles()</span> method from the <span class="literal">BubblePanel()</span> constructor. Add the following line of code to your constructor for the <span class="literal">BubblePanel</span>:</p>&#13;
<p class="pre">    <span class="gray">public BubblePanel() {</span><br/>&#13;
        <span class="gray">bubbleList = new ArrayList&lt;Bubble&gt;();</span><br/>&#13;
        <span class="gray">setBackground(Color.<span class="codeitalic">BLACK</span>);</span><br/>&#13;
        testBubbles();<br/>&#13;
    <span class="gray">}</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_210"/>Save <em>BubblePanel.java</em> and then switch to the <em>BubbleDraw.java</em> tab. Save that file and press the run button in Eclipse. You’ll need to run the file from the <em>BubbleDraw.java</em> tab the first time you compile and run, because <span class="literal">BubbleDraw</span> contains the <span class="literal">main()</span> method that runs the program. You should see a window full of colorful, randomly placed bubbles, similar to <a href="ch9.xhtml#ch9fig3">Figure 9-3</a>.</p>&#13;
<div class="imagef"><img src="../images/f0210-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch9fig3"/>Figure 9-3: Each time you run this version of the BubbleDraw app, the testBubbles() method will draw 100 bubbles on the screen.</em></p>&#13;
<p class="indent">If you like the look of the random bubbles, take a little time to play with the numbers in the <span class="literal">testBubbles()</span> method. See if you can draw 200, 500, or even 1,000 bubbles instead of 100. Make the bubbles larger, either by generating a larger random number for <span class="literal">size</span> or by adding a value to <span class="literal">size</span> after the random number is generated. Play with the <span class="literal">x</span> and <span class="literal">y</span> values to see if you can fit every bubble on the screen instead of having some bubbles cut off at the edges.</p>&#13;
<p class="indent">Modify the <span class="literal">testBubbles()</span> method as much as you’d like; this is a great opportunity to try new things and immediately see the visual effect of each change. We’ll comment out the <span class="literal">testBubbles()</span> method in the next section as we add mouse interaction, so you can feel free to experiment with <span class="literal">testBubbles()</span> without fear of messing up the rest of the program.</p>&#13;
<h3 class="h3"><a id="toc_lev159"/>Handling Mouse Events from the User</h3>&#13;
<p class="noindent">The goal of the BubbleDraw app is to allow the user to draw bubbles using their mouse. We saw in the last section that the bubble-drawing part is working. Now all we have to do is add the mouse interaction.</p>&#13;
<p class="indent">We’ll use event listeners to give the app the ability to handle mouse clicks, mouse movement, and even mouse wheel scrolling. We added event listeners to our GUI apps in <a href="ch3.xhtml#ch3">Chapters 3</a> and <a href="ch7.xhtml#ch7">7</a> using anonymous inner classes to handle button clicks, sliders, and text field changes; but if we <span epub:type="pagebreak" id="page_211"/>used anonymous inner classes in this app, we would need to make three separate listeners for each type of event, and that would be hard to keep track of. Plus, in two of those events, clicking and dragging the mouse, we want the result to be the same: the app should add bubbles each time the user clicks the mouse on the screen <em>and</em> whenever the user drags the mouse across the screen. It would be much easier to just have one block of code we could attach to both events than to write a listener for one event and copy and paste the code to another. So, to make the app more manageable, we’re going to create a single, named event listener that can respond to all three types of events.</p>&#13;
<h4 class="h4"><em><a id="toc_lev160"/>Creating a Reusable Event Listener</em></h4>&#13;
<p class="noindent">Before we can create our event listener, we need to import one additional library, <span class="literal">java.awt.event.*</span>, at the top of the <em>BubblePanel.java</em> file:</p>&#13;
<p class="pre">import java.awt.event.*;<br/>&#13;
<span class="gray">import java.util.ArrayList;<br/>&#13;
import java.awt.Graphics;<br/>&#13;
import java.util.Random;<br/>&#13;
import java.awt.Color;<br/>&#13;
import javax.swing.JPanel;</span></p>&#13;
<p class="indent">Our previous <span class="literal">import</span> statements have brought in only one class at a time, but this statement brings in every class in the <span class="literal">java.awt.event</span> library. The wildcard character, the asterisk (<span class="literal">*</span>), means that we want to bring in all the classes at the top level of <span class="literal">java.awt.event</span>, including all the mouse events and listeners, and much more. We could import each class individually as we use it, but importing <span class="literal">java.awt.event.*</span> will make the program much easier to write, allowing us to focus on coding instead of switching back and forth to the top of the file every time we need to use another event class.</p>&#13;
<p class="indent">Next, let’s start coding the private, named inner class to listen for mouse events. We’ll name it <span class="literal">BubbleListener</span>, as it will handle all the events related to bubbles in the <span class="literal">BubblePanel</span> class. Add this class below your <span class="literal">testBubbles()</span> method but above the private class <span class="literal">Bubble</span>. Java programmers usually include listener classes near the bottom of the class file, along with any other helper classes—this convention just helps us quickly find the listener code for debugging or modifying the file.</p>&#13;
<p class="pre">      <span class="gray">repaint();</span><br/>&#13;
  <span class="gray">}</span><br/>&#13;
  private class BubbleListener extends  MouseAdapter {<br/>&#13;
  }<br/>&#13;
  <span class="gray">private class Bubble {</span></p>&#13;
<p class="indent">The <span class="literal">BubbleListener</span> class extends <span class="literal">MouseAdapter</span>, which processes mouse events. Just as when we used the <span class="literal">extends</span> keyword to build a new type of <span class="literal">JFrame</span> that inherited all the features and functions of its parent class, the <span class="literal">BubbleListener</span> will inherit all the mouse event listener features of the <span class="literal">MouseAdapter</span> class. This adapter class includes the ability to handle <span epub:type="pagebreak" id="page_212"/><span class="literal">MouseListener</span> events for clicks, <span class="literal">MouseMotionListener</span> events for mouse movement, and <span class="literal">MouseWheelListener</span> events for scrolling with the mouse wheel or trackpad.</p>&#13;
<p class="indent">We’ll add these event handlers to the code step-by-step, and we’ll test the app after each addition to see the BubbleDraw app emerge one feature at a time.</p>&#13;
<h4 class="h4"><em><a id="toc_lev161"/>Handling Clicks and Drags</em></h4>&#13;
<p class="noindent">When we handle mouse events, we need to complete two steps. First, we have to add code to the <span class="literal">BubbleListener</span> to handle the individual event we’re after, like <span class="literal">mousePressed()</span>. Then, we have to add the listener to the <span class="literal">BubblePanel()</span> constructor so the drawing screen knows to listen for that type of event and call <span class="literal">BubbleListener</span> to handle the event when it happens. Let’s do this for the first case, when the user presses the mouse button to draw a bubble.</p>&#13;
<h5 class="h5">Listening for Mouse Button Events</h5>&#13;
<p class="noindent">There are three events that we can listen for from the mouse buttons:</p>&#13;
<p class="indent1"><span class="codestrong"><span class="literal">mousePressed()</span></span> Occurs when the user presses any mouse button</p>&#13;
<p class="indent1"><span class="codestrong"><span class="literal">mouseReleased()</span></span> Occurs when the user releases the button</p>&#13;
<p class="indent1"><span class="codestrong"><span class="literal">mouseClicked()</span></span> Occurs when the user presses and releases in quick succession</p>&#13;
<p class="indent">For the BubbleDraw app, we’ll use the <span class="literal">mousePressed()</span> handler so that the app will draw a bubble as soon as the user presses the mouse button. The signature for a <span class="literal">mousePressed()</span> event handler looks like the following:</p>&#13;
<p class="pre">  <span class="gray">private class BubbleListener extends MouseAdapter {</span><br/>&#13;
      public void mousePressed(MouseEvent e) {<br/>&#13;
      }<br/>&#13;
  <span class="gray">}</span></p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>Spelling and capitalization are especially important when you’re writing event handlers because they already have built-in names with specific capitalization. Make sure your mousePressed() method matches this one exactly.</em></p>&#13;
</div>&#13;
<p class="indent">The <span class="literal">mousePressed()</span> event handler goes inside the <span class="literal">BubbleListener</span> class, and it must be declared as <span class="literal">public</span> with a <span class="literal">void</span> return type to match the <span class="literal">mousePressed()</span> method in the <span class="literal">MouseAdapter</span> class. Notice it also takes a parameter of type <span class="literal">MouseEvent</span>. All of the mouse events get information about the mouse pointer’s location on the screen when the event happened. The x- and y-coordinates of the mouse event are stored in a <span class="literal">MouseEvent</span> object, and we can get those coordinates with the <span class="literal">getX()</span> and <span class="literal">getY()</span> methods.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_213"/>The following code adds a bubble to the <span class="literal">bubbleList</span> at the location where the user clicked the mouse, and then repaints the drawing screen to make the bubble appear.</p>&#13;
<p class="pre">    <span class="gray">private class BubbleListener extends MouseAdapter {</span><br/>&#13;
        <span class="gray">public void mousePressed(MouseEvent e) {</span><br/>&#13;
          <span class="ent">➊</span> bubbleList.add(new Bubble(e.getX(), e.getY(), size));<br/>&#13;
          <span class="ent">➋</span> repaint();<br/>&#13;
        <span class="gray">}</span><br/>&#13;
    <span class="gray">}</span></p>&#13;
<p class="indent">At <span class="ent">➊</span>, we create a new <span class="literal">Bubble</span> object at the (x, y) location where the user clicked the mouse, <span class="literal">e.getX()</span> and <span class="literal">e.getY()</span>. The <span class="literal">MouseEvent</span> class has several properties and methods for working with mouse events, like finding out which button was pressed and where the mouse is on the screen. As I just mentioned, the <span class="literal">getX()</span> and <span class="literal">getY()</span> methods tell us the x- and y-coordinates of the mouse event, such as a click or drag. Look back down in the <span class="literal">Bubble</span> class, and you’ll see that the constructor method we wrote there required three parameters: <span class="literal">int newX</span>, <span class="literal">int newY</span>, and <span class="literal">int newSize</span>. So, we must pass <span class="literal">e.getX()</span>, <span class="literal">e.getY()</span>, and <span class="literal">size</span> to the constructor to create a new <span class="literal">Bubble</span> object. Once the bubble is created, we add it to the <span class="literal">ArrayList</span> of bubbles with <span class="literal">bubbleList.add()</span>.</p>&#13;
<p class="indent">At <span class="ent">➋</span>, we call the <span class="literal">repaint()</span> method to refresh the screen and draw the updated <span class="literal">bubbleList</span> to the canvas.</p>&#13;
<p class="indent">This completes the <span class="literal">mousePressed()</span> event handler, but we still need to do one more thing to make the app listen for <span class="literal">mousePressed()</span> events and send them to the <span class="literal">BubbleListener</span> class. We have to tell the <span class="literal">BubblePanel</span> class to add <span class="literal">BubbleListener</span> as the listener for mouse events.</p>&#13;
<p class="indent">In the <span class="literal">BubblePanel()</span> constructor, make two changes. First, comment out the <span class="literal">testBubbles()</span> line by placing two forward slashes at the front of the line. Second, call the <span class="literal">addMouseListener()</span> command to use <span class="literal">BubbleListener</span> to process mouse events. The updated constructor is shown here:</p>&#13;
<p class="pre">    <span class="gray">public BubblePanel() {</span><br/>&#13;
        <span class="gray">bubbleList = new ArrayList&lt;Bubble&gt;();</span><br/>&#13;
        <span class="gray">setBackground(Color.<em>BLACK</em>);</span><br/>&#13;
      <span class="ent">➊</span> // testBubbles();<br/>&#13;
      <span class="ent">➋</span> addMouseListener( new BubbleListener() );<br/>&#13;
    <span class="gray">}</span></p>&#13;
<p class="indent">By commenting out the call to <span class="literal">testBubbles()</span><span class="ent">➊</span>, we’ve left it in place in case we want to draw random test bubbles again, but we’ve stopped it from running so that we can test the interactive BubbleDraw app using the mouse. The new line at <span class="ent">➋</span> tells the <span class="literal">BubblePanel</span> to listen for mouse events and to send them to the <span class="literal">BubbleListener</span> class when they happen.</p>&#13;
<p class="indent">With those changes in place, you should be able to run the BubbleDraw app and use the mouse button to place bubbles anywhere you click, as shown in <a href="ch9.xhtml#ch9fig4">Figure 9-4</a>.</p>&#13;
<div class="imagef"><span epub:type="pagebreak" id="page_214"/><img src="../images/f0214-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch9fig4"/>Figure 9-4: After adding the mousePressed() handler and setting BubbleListener as the listener for mouse events in the app, you should be able to draw by clicking anywhere on the screen.</em></p>&#13;
<p class="indent">Very cool! You can click repeatedly to draw shapes and patterns on the screen, but it would be easier to drag the mouse to draw bubbles. Let’s address that next.</p>&#13;
<h5 class="h5">Listening for Mouse Motion Events</h5>&#13;
<p class="noindent">Mouse motion events are a separate type of event from mouse button presses, but they can still be processed in a class that extends <span class="literal">MouseAdapter</span>, like <span class="literal">BubbleListener</span>. The two types of mouse motion events are <span class="literal">mouseMoved()</span> and <span class="literal">mouseDragged()</span>.</p>&#13;
<p class="indent">A <span class="literal">mouseMoved()</span> event happens anytime the mouse is moved over the drawing window. A <span class="literal">mouseDragged()</span> event occurs whenever the mouse is moved while a button is pressed. Since we want to draw bubbles only when the user clicks and drags the mouse, we’ll implement the <span class="literal">mouseDragged()</span> event handler in the <span class="literal">BubbleListener</span> class first, and then we’ll add a mouse motion listener to the <span class="literal">BubblePanel</span> constructor to activate the listener.</p>&#13;
<p class="indent">Add the <span class="literal">mouseDragged()</span> event handler to the <span class="literal">BubbleListener</span> class, as shown here:</p>&#13;
<p class="pre">  <span class="gray">private class BubbleListener extends MouseAdapter {</span><br/>&#13;
      <span class="gray">public void mousePressed(MouseEvent e) {</span><br/>&#13;
          <span class="gray">--<span class="codeitalic">snip</span>--<br/>&#13;
      }</span><br/>&#13;
      public void mouseDragged(MouseEvent e) {<br/>&#13;
          bubbleList.add(new Bubble(e.getX(), e.getY(), size));<br/>&#13;
          repaint();<br/>&#13;
      }<br/>&#13;
  <span class="gray">}</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_215"/>You’ll notice that the code looks almost exactly like the <span class="literal">mousePressed()</span> event handler, except for the name <span class="literal">mouseDragged()</span>. That’s because they both handle <span class="literal">MouseEvent</span>s. The <span class="literal">mousePressed()</span> method handles events when the user presses a mouse button, and <span class="literal">mouseDragged()</span> is called whenever the user drags the mouse. In this app, both events should behave the same way, adding bubbles to <span class="literal">bubbleList</span> and calling the <span class="literal">repaint()</span> function.</p>&#13;
<p class="indent">Next, add <span class="literal">BubbleListener</span> as the mouse motion listener to the <span class="literal">BubblePanel()</span> constructor with the following statement:</p>&#13;
<p class="pre">    <span class="gray">public BubblePanel() {</span><br/>&#13;
        <span class="gray">bubbleList = new ArrayList&lt;Bubble&gt;();</span><br/>&#13;
        <span class="gray">setBackground(Color.<em>BLACK</em>);</span><br/>&#13;
        <span class="gray">// testBubbles();</span><br/>&#13;
        <span class="gray">addMouseListener( new BubbleListener() );</span><br/>&#13;
        addMouseMotionListener( new BubbleListener() ); <br/>&#13;
    <span class="gray">}</span></p>&#13;
<p class="indent">Once again, let’s run the app to test this new event listener. Save your code, press the run button, and click and drag around the app window that appears, as shown in <a href="ch9.xhtml#ch9fig5">Figure 9-5</a>.</p>&#13;
<div class="imagef"><img src="../images/f0215-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch9fig5"/>Figure 9-5: Now you can click and drag to draw continuous streams of bubbles!</em></p>&#13;
<p class="indent">Impressive, huh? Just by adding two event handlers for mouse button and mouse motion events to the <span class="literal">BubblePanel</span> graphics app, we’ve built an interactive, multicolored drawing app in Java.</p>&#13;
<h4 class="h4"><em><a id="toc_lev162"/>Bonus: Handling MouseWheel Events</em></h4>&#13;
<p class="noindent">We’ve seen two small but powerful event handlers for mouse button presses and mouse click-and-drag events at work in the app so far, but there’s another event class in <span class="literal">MouseAdapter</span>: <span class="literal">MouseWheelEvent</span>. Depending on your system, you might have a physical wheel on your mouse or trackpad that you can use <span epub:type="pagebreak" id="page_216"/>to scroll up and down in documents and web pages. Or, you might have a laptop with a trackpad that allows you to scroll using a gesture, such as the two-finger swipe gesture on a MacBook or the vertical swipe along the far-right edge of the trackpad on most Windows laptops.</p>&#13;
<p class="indent">Java interprets either kind of scroll event as a <span class="literal">MouseWheelEvent</span>. We can add a <span class="literal">mouseWheelMoved()</span> listener to the <span class="literal">BubbleListener</span> to handle mouse wheel events or trackpad scroll gesture events on systems that provide them, as follows:</p>&#13;
<p class="pre">    <span class="gray">private class BubbleListener extends MouseAdapter {</span><br/>&#13;
        <span class="gray">public void mousePressed(MouseEvent e) {</span><br/>&#13;
            <span class="gray">--<span class="codeitalic">snip</span>--<br/>&#13;
        }</span><br/>&#13;
        <span class="gray">public void mouseDragged(MouseEvent e) {</span><br/>&#13;
            <span class="gray">--<span class="codeitalic">snip</span>--<br/>&#13;
        }</span><br/>&#13;
      <span class="ent">➊</span> public void mouseWheelMoved(MouseWheelEvent e) {<br/>&#13;
          <span class="ent">➋</span> size += e.getUnitsToScroll();<br/>&#13;
        }<br/>&#13;
    <span class="gray">}</span></p>&#13;
<p class="indent">At <span class="ent">➊</span>, the <span class="literal">mouseWheelMoved()</span> method accepts a <span class="literal">MouseWheelEvent</span>. At <span class="ent">➋</span>, we get the number of units the mouse wheel scrolled from the <span class="literal">MouseWheelEvent</span> <span class="literal">e</span> with <span class="literal">e.getUnitsToScroll()</span>, and we add this amount to <span class="literal">size</span>. The number returned by <span class="literal">getUnitsToScroll()</span> can be positive or negative, depending on your operating system and whether the wheel was scrolled up or down.</p>&#13;
<div class="sidebar">&#13;
<p class="sidetitle"><strong>DIFFERENCES IN SCROLLING BETWEEN OPERATING SYSTEMS</strong></p>&#13;
<p class="noindent">Windows, macOS, and Linux differ when it comes to scrolling. On macOS, scrolling or gesturing up returns a positive value, so the code we just wrote will increase the bubble size when the user scrolls or gestures up and shrink the size when the user scrolls down. On Windows and most Linux flavors, scrolling up with the mouse wheel moves a web page or document <em>down</em> instead, returning a negative number from <span class="literal">getUnitsToScroll()</span>. This means that scrolling up will cause the bubbles to get smaller, while scrolling down will add to the size and make them larger.</p>&#13;
<p class="indent">If you want to make your app work the same way on all three operating systems, change the code to the following:</p>&#13;
<p class="pre">        public void mouseWheelMoved(MouseWheelEvent e) {<br/>&#13;
            if(System.<em>getProperty</em>("os.name").startsWith("Mac"))<br/>&#13;
                size += e.getUnitsToScroll();<br/>&#13;
            else<br/>&#13;
                size -= e.getUnitsToScroll();<br/>&#13;
        }</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_217"/>The <span class="literal">if</span> statement gets the operating system name with <span class="literal">System.getProperty ("os.name")</span> and checks whether the name starts with the string <span class="literal">"Mac"</span>. If so, we add the units scrolled to <span class="literal">size</span>. Otherwise, we subtract the units scrolled from <span class="literal">size</span> to reverse Windows and Linux scrolling to positive for up, negative for down.</p>&#13;
</div>&#13;
<p class="indent">Lastly, add the mouse wheel listener to the <span class="literal">BubblePanel()</span> constructor, just below the previous two listeners:</p>&#13;
<p class="pre">    <span class="gray">public BubblePanel() {</span><br/>&#13;
        <span class="gray">bubbleList = new ArrayList&lt;Bubble&gt;();</span><br/>&#13;
        <span class="gray">setBackground(Color.<em>BLACK</em>);</span><br/>&#13;
        <span class="gray">// testBubbles();</span><br/>&#13;
        <span class="gray">addMouseListener( new BubbleListener() );</span><br/>&#13;
        <span class="gray">addMouseMotionListener( new BubbleListener() );</span><br/>&#13;
        addMouseWheelListener( new BubbleListener() );<br/>&#13;
    <span class="gray">}</span></p>&#13;
<p class="indent">Save and run the app now, and you should be able to change the bubble size by scrolling your mouse wheel or gesturing up or down on your trackpad, as shown in <a href="ch9.xhtml#ch9fig6">Figure 9-6</a>.</p>&#13;
<div class="imagef"><img src="../images/f0217-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch9fig6"/>Figure 9-6: Use your mouse wheel or trackpad to change the size of the bubbles.</em></p>&#13;
<p class="indent">The first version of the BubbleDraw app is complete! You can click and drag to draw with multicolored bubbles on the screen, scroll up and down to change the bubble size, maximize the window to draw fullscreen, and more.</p>&#13;
<h3 class="h3"><span epub:type="pagebreak" id="page_218"/><a id="toc_lev163"/>What You Learned</h3>&#13;
<p class="noindent">You’ve designed a colorful, interactive drawing app though an object-oriented programming approach by creating a <span class="literal">Bubble</span> class to capture the features and behaviors of bubbles.</p>&#13;
<p class="indentb">Here are some of the new things you’ve learned in this chapter:</p>&#13;
<p class="bull">• Building a single app with multiple classes and multiple Java source code files</p>&#13;
<p class="bull">• Using an object-oriented programming approach to break a problem down into smaller pieces</p>&#13;
<p class="bull">• Building the <span class="literal">Bubble</span> class from scratch, including attributes, methods, and a constructor</p>&#13;
<p class="bull">• Creating random colors using the <span class="literal">java.util.Random</span> and <span class="literal">java.awt.Color</span> classes</p>&#13;
<p class="bull">• Generating random numbers in a given range with <span class="literal">Random.nextInt(range)</span></p>&#13;
<p class="bull">• Drawing graphics with the <span class="literal">java.awt.Graphics</span> class</p>&#13;
<p class="bull">• Using the <span class="literal">paintComponent()</span> method to describe what your app should draw and using <span class="literal">repaint()</span> to clear the screen and redraw</p>&#13;
<p class="bull">• Writing event handlers for mouse events, including clicks, movement, and mouse wheel events</p>&#13;
<p class="bull">• Using the <span class="literal">java.util.ArrayList</span> class to store a dynamic list of objects, such as the bubbles in BubbleDraw</p>&#13;
<p class="bull">• Adding multiple event listeners to an app using a custom listener class, <span class="literal">BubbleListener</span></p>&#13;
<h3 class="h3"><a id="toc_lev164"/>Programming Challenges</h3>&#13;
<p class="noindent">Try these programming challenge exercises to review and practice what you’ve learned, as well as to expand your programming skills. Visit the book’s website at <em><a href="https://www.nostarch.com/learnjava/">https://www.nostarch.com/learnjava/</a></em> for sample solutions.</p>&#13;
<h4 class="h4"><em><a id="toc_lev165"/>#1: No Bubble Too Small</em></h4>&#13;
<p class="noindent">If you scroll the mouse down enough, the bubbles will simply disappear because the <span class="literal">size</span> value drops below <span class="literal">0</span>, resulting in a circle that Java can’t draw on the screen. In fact, a <span class="literal">size</span> of <span class="literal">2</span> or smaller will produce bubbles just a single pixel tall, so let’s make sure the value of <span class="literal">size</span> stays at least 3 pixels by 3 pixels to keep the bubbles circular.</p>&#13;
<p class="indent">Add a little logic to the <span class="literal">mouseWheelMoved()</span> method in the <span class="literal">BubbleListener</span> class in <em>BubblePanel.java</em> to check whether the <span class="literal">size</span> variable goes below a value of <span class="literal">3</span>. If so, set <span class="literal">size</span> equal to <span class="literal">3</span> to keep the bubble visible on the screen. Add this new <span class="literal">if</span> statement to the end of the <span class="literal">mouseWheelMoved()</span> method so that you check the size after it’s changed, not before.</p>&#13;
<p class="indent">Run the app with the change, and you should be able to scroll the mouse wheel until the bubbles are just a couple of pixels wide, but they’ll no longer disappear. Great work!</p>&#13;
<h4 class="h4"><span epub:type="pagebreak" id="page_219"/><em><a id="toc_lev166"/>#2: PixelDraw!</em></h4>&#13;
<p class="noindent">Add just a little bit of math to the constructor for new <span class="literal">Bubble()</span> objects, and you can create a cool, pixelated effect, as shown in <a href="ch9.xhtml#ch9fig7">Figure 9-7</a>.</p>&#13;
<div class="imagef"><img src="../images/f0219-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch9fig7"/>Figure 9-7: Changing the location of new Bubbles slightly can create a cool pixel-drawing effect.</em></p>&#13;
<p class="indent">Let’s copy the <em>BubbleDraw</em> project folder to make the changes in a new project without messing up the original app. Double-click your <em>BubblePanel .java</em> tab to restore the default view and then, in the Package Explorer, press <small>CTRL</small>-C or <img class="inline" src="../images/symbol.jpg" alt="Image"/>-C to copy the <em>BubbleDraw</em> project folder. Press <small>CTRL</small>-V or <img class="inline" src="../images/symbol.jpg" alt="Image"/>-V to paste a new copy of the folder into your workspace. Change the name of the folder to <strong>PixelDraw</strong>, as shown in <a href="ch9.xhtml#ch9fig8">Figure 9-8</a>.</p>&#13;
<div class="imagef"><img src="../images/f0219-02.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch9fig8"/>Figure 9-8: You can copy a project folder in the Package Explorer and paste it to create a new copy.</em></p>&#13;
<p class="indent">Change the code for the <span class="literal">Bubble()</span> constructor inside the private class <span class="literal">Bubble</span> as follows.</p>&#13;
<p class="pre"><span epub:type="pagebreak" id="page_220"/>    <span class="gray">public Bubble(int newX, int newY, int newSize) {</span><br/>&#13;
        x = (newX / newSize) * newSize + newSize/2;<br/>&#13;
        y = (newY / newSize) * newSize + newSize/2;<br/>&#13;
        <span class="gray">size = newSize;</span><br/>&#13;
        <span class="gray">color = new Color( rand.nextInt(256),</span><br/>&#13;
                <span class="gray">rand.nextInt(256),</span><br/>&#13;
                <span class="gray">rand.nextInt(256) );</span><br/>&#13;
    <span class="gray">}</span></p>&#13;
<p class="indent">This new math only alters the (x, y) location of each new bubble because of the way Java handles division of two integer values. Java keeps only the integer, or whole number, result when you divide two integers, so dividing by <span class="literal">newSize</span> and multiplying by <span class="literal">newSize</span> will make your bubbles appear to be on a grid, as you saw back in <a href="ch9.xhtml#ch9fig7">Figure 9-7</a>. For example, if <span class="literal">newSize</span> is <span class="literal">10</span> and <span class="literal">x</span> is <span class="literal">25</span>, then <span class="literal">x</span> divided by <span class="literal">newSize</span> would be <span class="literal">25 / 10</span>, which evaluates to <span class="literal">2</span> in Java. Multiplying by <span class="literal">10</span> then gives us <span class="literal">20</span>, the location of the bubble on a 10×10 pixel grid. We add <span class="literal">newSize/2</span> to each coordinate to center the dots within the imaginary grid. Remember, scrolling the mouse wheel still changes the size of the bubbles, so you can draw thick, blocky images or fine, pixel-perfect drawings.</p>&#13;
<p class="indent">If you’d like to make the pixel effect more <em>Minecraft</em>-y, you can make the bubbles into squares. To do so, change the <span class="literal">draw()</span> method to fill rectangles instead of ovals by commenting out the <span class="literal">fillOval()</span> command and using the <span class="literal">fillRect()</span> command instead:</p>&#13;
<p class="pre">    <span class="gray">public void draw(Graphics canvas) {</span><br/>&#13;
        <span class="gray">canvas.setColor(color);</span><br/>&#13;
        // <span class="gray">canvas.fillOval(x - size/2, y - size/2, size, size);</span><br/>&#13;
        canvas.fillRect(x - size/2, y - size/2, size, size);<br/>&#13;
    <span class="gray">}</span></p>&#13;
<p class="indent">Now you can draw in a pixelated style, as shown in <a href="ch9.xhtml#ch9fig9">Figure 9-9</a>.</p>&#13;
<div class="imagef"><img src="../images/f0220-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch9fig9"/>Figure 9-9: Drawing with rectangles instead of ovals creates a pixelated drawing effect.</em></p>&#13;
</body></html>