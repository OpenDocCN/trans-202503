- en: '**9**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**9**'
- en: '**COMPROMISING AUTHENTICATION**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**身份验证的风险**'
- en: '![image](Images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common01.jpg)'
- en: Most websites provide some sort of login functionality. This is a form of *authentication*,
    the process of identifying users when they return to your website. Authenticating
    your users allows them to have an identity in an online community where they can
    contribute content, send messages to others, make purchases, and so on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网站都提供某种形式的登录功能。这是一种*身份验证*形式，即当用户返回网站时识别其身份的过程。验证用户身份使他们能够在一个在线社区中拥有身份，贡献内容、发送消息、进行购买等。
- en: Nowadays, internet users are comfortable with signing up to a site with a username
    and password, and logging back in when they next want to use it. This is especially
    true since browsers and plug-ins help with caching or choosing passwords, and
    third-party authentication services have become ubiquitous.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，互联网用户习惯于使用用户名和密码注册网站，并在下次使用时重新登录。尤其是浏览器和插件有助于缓存或选择密码，而第三方身份验证服务也变得无处不在。
- en: There’s a downside to this, however. Getting access to a user’s account is a
    tantalizing prospect for hackers. In the age of the internet, it has never been
    easier for hackers to sell hacked credentials on the dark web, hijack social media
    accounts to spread clickbait, and commit financial fraud.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也有一个缺点。获取用户账户的访问权限对黑客来说是一个诱人的前景。在互联网时代，黑客通过暗网出售被盗凭证、劫持社交媒体账户传播诱饵链接，以及进行金融欺诈从未如此容易。
- en: In this chapter, you’ll investigate some of the ways that hackers can compromise
    a user’s account on your site during the login and authentication process. (The
    next chapter covers the vulnerabilities your users face after they’ve logged in
    and established a session.) Here, you’ll first see the most common ways websites
    implement authentication and look at how attackers use brute-force attacks to
    exploit them. Then you’ll learn how to protect users against these attacks through
    third-party authentication, single sign-on, and securing your own authentication
    system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将探讨黑客在登录和身份验证过程中如何破坏用户账户的几种方式。（下一章将讨论用户登录并建立会话后面临的漏洞。）在这里，你将首先看到网站实现身份验证的最常见方式，并了解攻击者如何通过暴力破解攻击来利用这些方式。然后，你将学习如何通过第三方身份验证、单点登录以及保护你自己身份验证系统的方式来防止这些攻击。
- en: '**Implementing Authentication**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实现身份验证**'
- en: 'Authentication is part of the HyperText Transfer Protocol. To present an authentication
    challenge, a web server needs to return a `401` status code in the HTTP response
    and add a `WWW-Authenticate` header describing the preferred authentication method.
    (There are two commonly supported authentication methods: basic authentication
    and digest authentication.) To fulfill this requirement, the user agent—usually
    a web browser—needs to request a username and password from the user, thus creating
    the login functionality.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证是超文本传输协议（HTTP）的一部分。为了提出身份验证挑战，Web 服务器需要在 HTTP 响应中返回 `401` 状态码，并添加 `WWW-Authenticate`
    头部，描述首选的身份验证方法。（常见的两种身份验证方法是基本身份验证和摘要身份验证。）为了满足这一要求，用户代理——通常是 Web 浏览器——需要向用户请求用户名和密码，从而创建登录功能。
- en: In the *basic authentication* scheme, the browser concatenates the username
    and password supplied by the user with a colon (`:`) character between them, generating
    the string username`:`password. It then uses the Base64 algorithm to encode this
    string and send it back to the server in the `Authorization` header of an HTTP
    request.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在*基本身份验证*方案中，浏览器将用户提供的用户名和密码与冒号（`:`）字符连接起来，生成字符串 username`:`password。然后，它使用
    Base64 算法对该字符串进行编码，并在 HTTP 请求的 `Authorization` 头部将其发送回服务器。
- en: The *digest authentication* scheme is a little more complex, and requires the
    browser to generate a hash consisting of the username, password, and URL. A *hash*
    is the output of a one-way encryption algorithm that makes it easy to generate
    a unique “fingerprint” for a set of input data, but makes it difficult to guess
    the input values if you have only the algorithm’s output. You’ll look at hashing
    in more depth later in this chapter, when we discuss how to securely store passwords.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*摘要身份验证*方案稍微复杂一些，要求浏览器生成一个哈希值，该哈希值由用户名、密码和 URL 组成。*哈希*是单向加密算法的输出，它使得为一组输入数据生成唯一的“指纹”变得容易，但如果只有算法的输出，则很难猜测输入值。在本章后面，我们将更深入地讨论哈希，当我们讲解如何安全存储密码时。'
- en: '***HTTP-Native Authentication***'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***HTTP原生身份验证***'
- en: Even though authentication is built into the HyperText Transfer Protocol, popular
    websites rarely use basic or digest authentication—mostly because of usability
    considerations. The native web browser authentication prompt is *not* a thing
    of beauty. It looks similar to a JavaScript alert dialog, grabbing focus from
    the browser, and interrupting the experience of using the site, as shown in [Figure
    9-1](ch09.xhtml#ch9fig1).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管身份验证是超文本传输协议的一部分，但流行的网站很少使用基本认证或摘要认证——主要是由于可用性考虑。原生的浏览器身份验证提示*并不是*一个美观的设计。它看起来类似于
    JavaScript 警告对话框，抢占浏览器的焦点，打断用户使用网站的体验，如[图 9-1](ch09.xhtml#ch9fig1)所示。
- en: Because browsers implement the authentication prompt outside HTML, we can’t
    style the native authentication prompt to match the website. As a native browser
    window that doesn’t appear in the web page, the browser also can’t autocomplete
    the user’s credentials. Finally, because HTTP authentication specifies no method
    of resetting a password if a user forgets it, we’d have to implement a reset feature
    separately from the login prompt, leading to a confusing user experience.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因为浏览器将身份验证提示实现为 HTML 之外的内容，我们无法将本地身份验证提示样式化以匹配网站。作为一个不在网页中显示的本地浏览器窗口，浏览器也无法自动填充用户的凭据。最后，由于
    HTTP 身份验证未指定忘记密码时的重置方法，我们必须在登录提示之外单独实现一个重置功能，这会导致用户体验的混乱。
- en: '![image](Images/09fig01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/09fig01.jpg)'
- en: '*Figure 9-1: The native Google Chrome login prompt rudely interrupts your browsing
    session.*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：原生 Google Chrome 登录提示粗鲁地打断了你的浏览会话。*'
- en: '***Non-Native Authentication***'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***非本地身份验证***'
- en: Because of this user-hostile design, the built-in HTTP authentication methods
    tend to be reserved mostly for applications where the user experience simply doesn’t
    matter that much. Modern websites usually implement their own login forms in HTML,
    like the one shown in [Listing 9-1](ch09.xhtml#ch9list1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种不友好的设计，内置的 HTTP 身份验证方法通常仅用于那些用户体验不太重要的应用程序。现代网站通常会使用 HTML 自定义登录表单，就像在[清单
    9-1](ch09.xhtml#ch9list1)中展示的那样。
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 9-1: A typical login form in HTML*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-1：HTML 中的典型登录表单*'
- en: A typical login form contains an `<input type="text">` element ❶ requiring the
    user to supply a username, and an `<input type="password">` element ❷ that replaces
    typed characters with a `•` character to obscure the password. The supplied username
    and password are sent to the server as a `POST` request when the user submits
    the form. If the login is unsuccessful because the user couldn’t be authenticated,
    the server replies with a `401` status code in the HTTP response. If the login
    is successful, the server redirects the user to their homepage.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的登录表单包含一个 `<input type="text">` 元素 ❶，要求用户提供用户名，还有一个 `<input type="password">`
    元素 ❷，该元素用 `•` 字符替换输入的字符以隐藏密码。用户提交表单时，提供的用户名和密码作为 `POST` 请求发送到服务器。如果登录失败，因为用户无法通过身份验证，服务器会在
    HTTP 响应中返回 `401` 状态码。如果登录成功，服务器会将用户重定向到其主页。
- en: '***Brute-Force Attacks***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***暴力破解攻击***'
- en: Attackers often attempt to compromise your site at the point of authentication
    by guessing passwords. Movies usually depict hackers using personal insights about
    a target to guess their password. While this might be a concern for high-profile
    targets, hackers usually have more success using *brute-force attacks*, which
    use scripts to try thousands of commonly used passwords against a login page.
    Because previous data breaches have already leaked millions of commonly used passwords,
    including the ones in [Listing 9-2](ch09.xhtml#ch9list2), it’s easy for an attacker
    to determine which passwords they should try first.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者经常试图通过猜测密码在身份验证环节入侵你的网站。电影中通常描绘黑客使用目标的个人信息来猜测密码。虽然这可能是高曝光目标的一个问题，但黑客通常更成功于使用*暴力破解攻击*，它通过脚本尝试成千上万的常用密码来攻击登录页面。因为之前的数据泄露已经泄漏了包括[清单
    9-2](ch09.xhtml#ch9list2)中的成千上万的常用密码，攻击者很容易确定应该首先尝试哪些密码。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 9-2: Security researchers publish a list of the most commonly used
    passwords each year; they change very little year to year. (This list is provided
    by the internet security firm SplashData.)*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-2：安全研究人员每年发布最常用密码的列表；这些密码几乎每年变化不大。（这个列表由互联网安全公司 SplashData 提供。）*'
- en: Let’s look at a few ways you can implement and secure your authentication against
    this type of threat.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些你可以实施并保护身份验证免受这种类型威胁的方法。
- en: '**Mitigation 1: Use Third-Party Authentication**'
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**缓解措施 1：使用第三方身份验证**'
- en: The most secure authentication system is the one you don’t have to write yourself.
    Instead of implementing your own authentication system, consider using a third-party
    service like Facebook Login, which allows users to authenticate to your website
    with their social media credentials. This is convenient for them, and relieves
    you of the burden of ever having to store user passwords.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最安全的认证系统是你不需要自己编写的系统。与其自己实现认证系统，不如考虑使用像Facebook Login这样的第三方服务，让用户可以用他们的社交媒体凭据登录你的网站。这对他们来说很方便，也减轻了你存储用户密码的负担。
- en: Large tech companies provide other similar authentication services. Most of
    them are based on the *open authentication (OAuth)* or *OpenID* standards—commonly
    implemented protocols for delegating authentication to a third party. You can
    always mix and match authentication systems. They’re typically straightforward
    to integrate with, so pick one or more that make sense with your userbase. If
    you’re providing email-related services, you can integrate with Google OAuth to
    ask your users for access to their Gmail accounts. If you’re providing technical
    services, use something like GitHub OAuth. Twitter, Microsoft, LinkedIn, Reddit,
    and Tumblr all offer authentication options, as do hundreds of other websites.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 大型科技公司提供了其他类似的认证服务。它们大多基于*开放认证（OAuth）*或*OpenID*标准——这些是将认证委托给第三方的常用协议。你可以随时混合使用不同的认证系统。它们通常易于集成，因此选择一个或多个与用户群体匹配的系统。如果你提供与电子邮件相关的服务，可以集成Google
    OAuth，要求用户授权访问其Gmail账户。如果你提供技术服务，可以使用像GitHub OAuth这样的系统。Twitter、Microsoft、LinkedIn、Reddit和Tumblr等都提供认证选项，其他数百个网站也是如此。
- en: '**Mitigation 2: Integrate with Single Sign-On**'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**缓解措施 2：与单点登录集成**'
- en: If you integrate with an OAuth or OpenID identity provider, your users will
    usually use their personal email addresses as usernames. However, if your website’s
    target audience is business users, consider integrating with a *single sign-on
    (SSO)* identity provider like Okta, OneLogin, or Centrify, which centralizes authentication
    across enterprise systems so employees can log in seamlessly to third-party applications
    under their business email. Company administrators retain ultimate control over
    which employees can access what sites, and user credentials are stored securely
    on the company’s servers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你与OAuth或OpenID身份提供者集成，用户通常会使用他们的个人电子邮件地址作为用户名。然而，如果你的网站目标用户群是企业用户，可以考虑与*单点登录（SSO）*身份提供者（如Okta、OneLogin或Centrify）集成，这些身份提供者集中管理企业系统中的认证，使员工可以无缝地使用他们的企业邮箱登录第三方应用。公司管理员可以控制哪些员工可以访问哪些网站，用户凭据也会安全地存储在公司的服务器上。
- en: To integrate with a single sign-on provider, you’ll usually have to use *Security
    Assertion Markup Language (SAML)*, which is an older (and less friendly) standard
    than OAuth or OpenID, though most programming languages have mature SAML libraries
    you can use.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要与单点登录提供者集成，你通常需要使用*安全断言标记语言（SAML）*，这是一种比OAuth或OpenID更古老（且不太友好）的标准，尽管大多数编程语言都有成熟的SAML库可供使用。
- en: '**Mitigation 3: Secure Your Own Authentication System**'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**缓解措施 3：保护你自己的认证系统**'
- en: Although third-party authentication will usually be more secure than your own
    system, having only third-party authentication could somewhat limit your userbase
    because not everyone has a social media presence or Gmail account. For everyone
    else, you’ll need to create a way for them to sign up and manually choose a username
    and password. This means creating separate pages on your website where users can
    sign up, log in, and log out; plus writing code to store and update credentials
    in your database, and to check that the credentials are correct when a user reenters
    them. More than likely, you will need to have a mechanism for a user to change
    their password too.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管第三方认证通常比你自己的系统更安全，但仅依赖第三方认证可能会在某种程度上限制你的用户群，因为并不是每个人都有社交媒体账户或Gmail账户。对于其他用户，你需要创建一种方式，让他们注册并手动选择用户名和密码。这意味着需要在你的网站上创建独立的页面，让用户能够注册、登录和退出；同时编写代码来存储和更新凭据，并在用户重新输入时检查凭据是否正确。很可能，你还需要为用户提供更改密码的机制。
- en: That’s a lot of functionality to implement! Before you start writing code, you’ll
    need to make a few design decisions. Let’s look at the key things you need to
    get right in order to have a secure authentication system.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要实现很多功能！在开始编写代码之前，你需要做一些设计决策。我们来看看你需要做对的关键事情，以便拥有一个安全的认证系统。
- en: '***Requiring Usernames, Email Address, or Both***'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***要求用户名、电子邮件地址或两者***'
- en: Your users will need to choose a username and password when they sign up. Most
    websites will also require a user to submit a valid email address when they sign
    up, which allows them to send password-reset emails when users forget their credentials.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在注册时需要选择一个用户名和密码。大多数网站还会要求用户在注册时提交一个有效的电子邮件地址，这样他们就可以在用户忘记凭证时发送密码重置邮件。
- en: For many sites, a user’s email address *is* their username. By necessity, each
    email address has to be unique to an account, so choosing a separate username
    would generally be redundant. The exception to this is when users have a visible
    presence on the site; for example, when a user has a public profile, or interacts
    with other users in comment sections. These types of sites require users to choose
    a separate *display name*. Using email addresses as display names is bad practice,
    since it invites harassment and spam.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多网站来说，用户的电子邮件地址*就是*他们的用户名。因为每个电子邮件地址必须对一个账户唯一，所以通常选择单独的用户名是多余的。例外情况是当用户在网站上有可见存在时；例如，当用户有公开个人资料，或在评论区与其他用户互动时。这类网站要求用户选择一个单独的*显示名称*。将电子邮件地址作为显示名称是不好的做法，因为这会引发骚扰和垃圾邮件。
- en: '**Validating Email Addresses**'
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**验证电子邮件地址**'
- en: If you intend to send email from your site—for instance, to allow users to reset
    their password—you need to validate that every user’s email address corresponds
    to a working email account. Emails that a website generates are called *transactional
    emails*, because the website sends them in response to a user action. Sending
    transactional emails to unverified addresses will quickly get you blacklisted
    by your email service provider, since they’re wary of enabling spammers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算从你的网站发送电子邮件——例如，允许用户重置密码——你需要验证每个用户的电子邮件地址是否对应一个有效的电子邮件账户。网站生成的电子邮件被称为*事务性电子邮件*，因为网站是响应用户的操作而发送这些邮件。向未经验证的地址发送事务性电子邮件会迅速使你被电子邮件服务提供商列入黑名单，因为他们不愿意为垃圾邮件提供支持。
- en: 'First, verify that the user’s email address appears valid on its face. This
    means validating that the email contains only valid characters: letters, numbers,
    or any of the special characters (``!#$%&''*+-/=?^_`{|}~;.``).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，验证用户的电子邮件地址是否在表面上有效。这意味着验证电子邮件仅包含有效字符：字母、数字或任何特殊字符（``!#$%&'*+-/=?^_`{|}~;.``）。
- en: The address must contain an *@* sign, and to the right of that, a valid internet
    domain. Usually, but not always, this domain should correspond to a website, like
    *@gmail.com* addresses that correspond to *[www.gmail.com](http://www.gmail.com)*.
    At a minimum, the internet’s *Domain Name System (DNS)*, which we discussed in
    [Chapter 2](ch02.xhtml#ch02), must contain a mail exchange (MX) record for that
    domain that tells software where to route emails. It’s possible to look up the
    MX record as part of your verification process, as shown in [Listing 9-3](ch09.xhtml#ch9list3).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 地址必须包含一个*@*符号，并且右边必须有一个有效的互联网域名。通常，但不总是，域名应对应一个网站，例如*@gmail.com*地址对应* [www.gmail.com](http://www.gmail.com)*。至少，互联网的*域名系统(DNS)*，我们在[第二章](ch02.xhtml#ch02)中讨论过的，必须包含该域的邮件交换(MX)记录，以告诉软件邮件应该路由到哪里。在验证过程中，您可以查找MX记录，正如在[清单9-3](ch09.xhtml#ch9list3)中所示。
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 9-3: Validating that a domain is capable of receiving email in Python
    by using the dnsresolver library*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单9-3：通过使用dnsresolver库验证一个域名是否能够接收电子邮件*'
- en: However, the only 100 percent reliable way to validate that an address corresponds
    to a working email account is to send an email message and check that it’s received.
    This means you’ll have to send each user an email that contains an *email verification
    link* that links back to your website and contains a *validation token*—a large,
    randomly generated string you store in your database against their email address.
    When the user clicks the link to verify ownership of their email address, you
    can check that the validation token is the one you sent out, and confirm that
    they do indeed have access to the email account.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，验证一个地址是否对应一个有效的电子邮件账户的唯一100%可靠方法是发送一封电子邮件并检查是否收到。这意味着你需要向每个用户发送一封包含*电子邮件验证链接*的邮件，该链接指向你的网站并包含一个*验证令牌*——一个大而随机生成的字符串，你会将其存储在数据库中与用户的电子邮件地址关联。当用户点击链接以验证他们的电子邮件地址的所有权时，你可以检查验证令牌是否与你发送的相符，从而确认他们确实能够访问该电子邮件账户。
- en: Many sites force users to validate their email before they can complete the
    sign-up process. Other sites allow the user to use a limited number of features
    on the site while they’re in an unvalidated state, in order to make the sign-up
    process less onerous. You should never assume a user has access to an email account
    until you’ve validated them. Until then, don’t send any other types of transactional
    email or sign the user up to mailing lists!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网站要求用户在完成注册过程之前验证他们的电子邮件。其他网站则允许用户在未验证状态下使用网站的部分功能，以减少注册过程的繁琐。你永远不能假设用户已经验证过电子邮件账户，直到你验证他们之前。直到那时，不要发送任何其他类型的交易邮件或将用户添加到邮件列表！
- en: '**Banning Disposable Email Accounts**'
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**禁止使用一次性电子邮件账户**'
- en: Some users are reluctant to sign up with an email address they commonly use,
    and will sign up to your site using a temporary email account generated by services
    like 10 Minute Mail or Mailinator or the one shown in [Figure 9-2](ch09.xhtml#ch9fig2).
    These types of services generate a disposable email account that’s good for receiving
    a handful of messages before shutting down. If a user uses this type of service,
    it usually means they’re wary of being signed up to mailing lists (quite a reasonable
    consideration, given the relentless approach of email marketers).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一些用户不愿意使用常用的电子邮件地址进行注册，他们会使用像 10 Minute Mail 或 Mailinator 这样的服务生成临时电子邮件账户，或使用[图
    9-2](ch09.xhtml#ch9fig2)所示的服务。这些服务生成一个一次性电子邮件账户，在接收几封邮件后即会关闭。如果用户使用这种类型的服务，通常意味着他们担心被加入邮件列表（考虑到电子邮件营销人员的无休止骚扰，这种担心是很合理的）。
- en: You may need to ban users from signing up with disposable email addresses if,
    for instance, some of your users are generating temporary accounts to harass others.
    If so, you can use well-maintained blacklists of disposable email providers to
    detect, reject, and ban disposable email domains during the sign-up process.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要禁止用户使用一次性电子邮件地址注册，例如，当部分用户生成临时账户以骚扰他人时。此时，你可以使用维护良好的一次性电子邮件服务提供商黑名单，在注册过程中检测、拒绝并禁止一次性电子邮件域名。
- en: '![image](Images/09fig02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/09fig02.jpg)'
- en: '*Figure 9-2: Want a temporary email address? Come get it at* [https://www.sharklasers.com/](https://www.sharklasers.com/).
    *(Yes, this is a real website. Pew pew pew.)*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-2：想要一个临时的电子邮件地址吗？来这里获取：* [https://www.sharklasers.com/](https://www.sharklasers.com/)。*（是的，这是一个真实的网站。嘭嘭嘭。）*'
- en: '**Securing Password Resets**'
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**保护密码重置**'
- en: Having a validated email address for each of your users allows you to handle
    the (inevitable) scenario when a user forgets their password. Simply send them
    an email with a *password-reset link*, containing a fresh validation token. When
    the forgetful user opens the email and clicks the link, you can validate the incoming
    token, and allow the user to choose a new password for their account.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有每个用户的已验证电子邮件地址，能帮助你处理用户忘记密码的（不可避免的）情况。只需向他们发送一封包含*密码重置链接*的邮件，链接内带有新的验证令牌。当健忘的用户打开邮件并点击链接时，你可以验证收到的令牌，并允许用户为其账户选择一个新密码。
- en: Password-reset links should be short-lived, and should expire after the user
    uses them. A good rule of thumb is to expire reset tokens after 30 minutes to
    prevent an attacker from abusing stale reset links. If an attacker hacks a user’s
    email account, you can’t let them search for emails containing reset links and
    then use those links to access your site under the victim’s account.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 密码重置链接应该是短期有效的，在用户使用后应立即过期。一个好的经验法则是，在30分钟后使重置令牌过期，以防止攻击者滥用过时的重置链接。如果攻击者入侵了用户的电子邮件账户，你不能让他们搜索包含重置链接的邮件，并使用这些链接以受害者身份访问你的网站。
- en: '***Requiring Complex Passwords***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***要求复杂密码***'
- en: Complex passwords are generally harder to guess, so you should require users
    to meet certain password complexity standards when they choose a password, for
    their own protection. Complex passwords include numbers and symbols as well as
    letters, have a mix of uppercase and lowercase characters, and are long rather
    than short. At the very least, you should enforce a minimum length of eight characters
    for passwords, but the longer the better. (Studies have shown that password length
    is more important than mixing in unusual characters.)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂密码通常更难猜测，因此你应该要求用户在选择密码时满足一定的密码复杂度标准，以保障他们的安全。复杂密码包含数字和符号以及字母，大小写字母混合，且密码长度较长而非较短。至少，你应该强制要求密码长度不低于八个字符，但密码越长越好。（研究表明，密码长度比混合使用不常见字符更为重要。）
- en: However, users often have trouble remembering complex passwords, so if you enforce
    overly strict password complexity requirements, a user will usually reuse a password
    they previously entered on another website. Some secure sites prevent a user from
    reusing a password they previously used to force them to choose a new, unique
    password each time, pushing them away from lazy habits. Unfortunately, most users
    will simply cycle passwords by adding a number at the end of a password they commonly
    use, which doesn’t make for a significantly less guessable password.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，用户通常很难记住复杂的密码，所以如果你强制要求过于严格的密码复杂性要求，用户通常会在其他网站上重新使用他们以前输入过的密码。一些安全的网站会防止用户重复使用他们以前用过的密码，迫使他们每次都选择新的、独特的密码，从而让他们远离懒惰的习惯。不幸的是，大多数用户通常通过在常用密码的末尾添加一个数字来循环使用密码，这样并不会显著降低密码的猜测难度。
- en: Ultimately, each user is responsible for their own security online, so it’s
    generally better to nudge your users toward strong password choices rather than
    forcing them to jump through hoops. Some JavaScript libraries, like the `password-strength-calculator`
    library, can be used to rate a user’s password’s complexity as they type it and
    to call out commonly used passwords, which you can use on sign-up and password-reset
    screens to push users toward a more secure password.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，每个用户对其在线安全负责，因此通常更好的是引导用户选择强密码，而不是强迫他们通过繁琐的步骤。有些JavaScript库，比如`password-strength-calculator`库，可以在用户输入密码时对其复杂性进行评分，并指出常见的密码，你可以在注册和密码重置页面上使用这些库，促使用户选择更安全的密码。
- en: '***Securely Storing Passwords***'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***安全存储密码***'
- en: After a user chooses a password, you need to record it in some form in your
    database against their username, so you can revalidate their credentials when
    they log in again. Do *not* simply store the password as is—we call this *cleartext*
    storage, and it’s a big security no-no. If an attacker accesses a database that
    stores passwords in cleartext form, they can compromise every user account, as
    well as accounts those users have on other websites under the same credentials.
    Luckily, there is a way of storing passwords in a secure fashion that makes them
    unreadable in the database, but allows you to check they have been reentered correctly
    by a user at a later date.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户选择密码后，你需要以某种形式将其记录在数据库中与用户名关联，以便在用户再次登录时重新验证其凭据。*不要*直接存储密码原文——我们称之为*明文存储*，这是一个巨大的安全隐患。如果攻击者访问了存储明文密码的数据库，他们可以危及每个用户账户，并且还会影响这些用户在其他网站上使用相同凭据的账户。幸运的是，有一种方法可以安全地存储密码，使其在数据库中不可读，但可以在稍后的时候验证用户是否正确地重新输入密码。
- en: '**Hashing Passwords**'
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**哈希密码**'
- en: Passwords should be processed with a *cryptographic hash algorithm* before being
    stored in your database. This will convert the raw string of input text into a
    bit string of fixed length in such a way that makes it computationally unfeasible
    to reverse the process. You should then store the output values of that algorithm—the
    *hashed values*—alongside each username.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 密码应该在存储到数据库之前，使用*加密哈希算法*进行处理。这将把原始输入字符串转换为一个固定长度的比特字符串，使得反向过程在计算上不可行。然后，你应该将该算法的输出值——*哈希值*——与每个用户名一起存储。
- en: Hashing algorithms are a type of one-way mathematical function. The only practical
    way to guess the input string that generated a given hashed output (or *hash*,
    for short) is to try every possible input string one after the other. By storing
    a hash of a user’s password, you can recalculate the hash when a user reenters
    their password and compare the new and old hash values to see if they’ve entered
    the correct password.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希算法是一种单向数学函数。猜测生成给定哈希输出（或简称*哈希*）的输入字符串的唯一实际方法是逐一尝试每一个可能的输入字符串。通过存储用户密码的哈希值，当用户重新输入密码时，你可以重新计算哈希值，并比较新旧哈希值以确认他们是否输入了正确的密码。
- en: Numerous cryptographic hash algorithms exist, each with varying implementations
    and strengths. A good hashing algorithm should be quick to calculate, but not
    *too* quick. Otherwise, as computation speeds increase, brute-force attempts to
    crack the password by enumerating all possible inputs become feasible. For this
    reason, a good algorithm to use is *bcrypt*, shown in [Listing 9-4](ch09.xhtml#ch9list4),
    which allows you to add extra iterations to the hashing function as the years
    go by to make it stronger and more time-consuming as computation power gets cheaper.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多加密哈希算法，每种算法都有不同的实现方式和强度。一个好的哈希算法应该计算快速，但又不能*过于*快速。否则，随着计算速度的提升，通过暴力破解枚举所有可能的输入来尝试破解密码变得可行。因此，一个不错的算法是*bcrypt*，如[示例
    9-4](ch09.xhtml#ch9list4)所示，它允许随着时间推移增加额外的迭代次数，使得哈希函数随着计算能力变得更强且更加耗时。
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 9-4: Hashing and then testing a password using the bcrypt algorithm
    in Python*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-4：使用 bcrypt 算法在 Python 中对密码进行哈希并进行测试*'
- en: The `rounds` parameter at ❶ can be incremented to make the password hashes even
    stronger. Storing hashed passwords rather than cleartext passwords is much more
    secure. No one who accesses the database, including you, can directly decipher
    the passwords, but your website can still determine whether a user has correctly
    reentered their password. This relieves you of a security burden—even if an attacker
    hacks your database, they can’t do much with the hashed passwords.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❶处的`rounds`参数可以增加，从而使密码哈希变得更强。存储哈希密码而不是明文密码要安全得多。包括你在内的任何访问数据库的人都无法直接解密密码，但你的网站仍然可以判断用户是否正确重新输入了密码。这为你减轻了安全负担——即使攻击者入侵了你的数据库，他们也无法对哈希密码做什么。
- en: '**Salting Hashes**'
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**哈希加盐**'
- en: Hashing passwords makes your site more secure, but users are frequently unimaginative
    in their password choice. When *cracking* password lists—reverse engineering passwords
    for a list of leaked password hashes—hackers frequently use *rainbow tables*,
    which are lists of commonly used passwords that have been put through a known
    hashing algorithm. Matching hashes against precalculated values yield a very good
    return for an attacker, allowing them to determine the password for many, if not
    most, of the hashes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对密码进行哈希处理可以使你的网站更加安全，但用户在选择密码时通常缺乏想象力。在*破解*密码列表——对泄露的密码哈希进行逆向工程——时，黑客经常使用*彩虹表*，这是一种包含了常用密码的列表，这些密码已经通过已知的哈希算法处理过。将哈希与预先计算的值进行匹配，可以为攻击者带来很好的回报，使他们能够破解许多哈希值的密码，甚至是大多数。
- en: To protect against rainbow table attacks, you need to *salt* your password hashes,
    which means adding an element of randomness to the hashing algorithm so the input
    password doesn’t solely determine the generated hash. You can store the salt input
    value in your configuration, or better yet, generate a salt input value separately
    for each user and store it alongside their password hash. This makes rainbow table
    attacks unfeasible, since an attacker has to regenerate the entire rainbow table
    for each salt value you use, which is computationally prohibitive and thus takes
    too long.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防范彩虹表攻击，你需要*加盐*你的密码哈希，这意味着向哈希算法中加入随机元素，使得输入的密码不会单独决定生成的哈希值。你可以将盐值输入存储在配置文件中，或者更好地，为每个用户生成一个单独的盐值，并将其与密码哈希一起存储。这使得彩虹表攻击变得不可行，因为攻击者必须为你使用的每个盐值重新生成整个彩虹表，而这在计算上是不可承受的，因而需要很长时间。
- en: '***Requiring Multifactor Authentication***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***要求多因素认证***'
- en: 'No matter how securely you store passwords, password-based authentication systems
    are always vulnerable to brute-force password-guessing attacks. To really secure
    your website, consider adding an extra layer of security by requiring *multifactor
    authentication (MFA)*, which requires a returning user to identify themselves
    with at least two of the following three categories of information: something
    they *know*, something they *have*, and something they *are*. One example of multifactor
    authentication is a bank ATM, which requires the account holder’s PIN (the thing
    they know) and their bank card (the thing they have). Another example would be
    devices that use biometrics to identify individuals, like fingerprint scanning
    on smartphones (the thing they are).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你如何安全地存储密码，基于密码的认证系统始终容易受到暴力破解密码攻击。为了真正保护你的网页，考虑通过要求*多因素认证（MFA）*来增加一层安全防护，这要求回访用户通过以下三类信息中的至少两项来确认身份：他们*知道*的东西、他们*拥有*的东西和他们*本身*的特征。多因素认证的一个例子是银行自动取款机（ATM），它要求账户持有人的PIN码（他们知道的东西）和银行卡（他们拥有的东西）。另一个例子是使用生物识别技术来识别个人的设备，例如智能手机上的指纹扫描（他们本身的特征）。
- en: For websites, multifactor authentication generally boils down to requiring a
    username and password (the thing the user knows), and confirming that the user
    has an authenticator installed on their smartphone (the thing they have). Each
    user will need to sync the authenticator app with the website during sign up (usually
    by taking a photograph of a QR code onscreen.) Thereafter, the app generates a
    six-digit random number that they need to supply at login time for the user to
    log in successfully, like the one shown in [Figure 9-3](ch09.xhtml#ch9fig3).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网站，多因素认证通常意味着要求输入用户名和密码（用户知道的东西），并确认用户的智能手机上安装了认证器应用（用户拥有的东西）。每个用户在注册时需要将认证器应用与网站同步（通常通过拍摄屏幕上的二维码）。之后，应用会生成一个六位数的随机数字，用户需要在登录时提供该数字，才能成功登录，就像在[图
    9-3](ch09.xhtml#ch9fig3)中所示。
- en: '![image](Images/09fig03.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/09fig03.jpg)'
- en: '*Figure 9-3: Your users will come to love typing in six-digit numbers.*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-3：你的用户会喜欢输入六位数的数字。*'
- en: This forces an attacker to have knowledge of a victim’s credentials *and* access
    to the victim’s smartphone in order to compromise their account, which is a highly
    unlikely combination. Support for multifactor authentication is increasingly becoming
    the norm, given the ubiquity of smartphones. If your website does any type of
    financial processing, you should definitely implement multifactor authentication.
    Thankfully, many code libraries make integrating it relatively easy.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这迫使攻击者既要知道受害者的凭证*又*要获得受害者的智能手机才能破坏他们的账户，这种组合是非常不可能发生的。鉴于智能手机的普及，多因素认证的支持逐渐成为常态。如果你的网站涉及任何类型的财务处理，绝对应该实施多因素认证。幸运的是，许多代码库使得集成它变得相对简单。
- en: '***Implementing and Securing the Logout Function***'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现和保护注销功能***'
- en: If you authenticate users on your site, don’t forget to add a function that
    lets them log out of your site too. This might seem like an anachronism, given
    that users seem to stay perpetually logged in to social media, but having a logout
    function is a key security consideration for users who log in on shared devices.
    Plenty of families share a laptop or iPad, and companies often reuse computers
    and portable devices, so make sure to let your users log out!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在网站上验证用户身份，别忘了添加一个功能，让他们也能退出网站。这看起来可能有些过时，因为用户似乎总是保持社交媒体的永久登录状态，但对于在共享设备上登录的用户来说，拥有注销功能是一个关键的安全考虑。许多家庭共享一台笔记本电脑或iPad，公司也常常重复使用计算机和便携设备，所以一定要确保让用户能够注销！
- en: Your logout function should clear the session cookie in the browser, *and* invalidate
    the session identifier if you are storing it on the server side. This protects
    against attackers who manage to intercept session cookies after the fact and attempt
    to reestablish a session using a stolen cookie. Clearing the session cookie is
    as simple as sending back an HTTP response containing a `Set-Cookie` header with
    a blank value for your session parameter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你的注销功能应该清除浏览器中的会话 cookie，*并*且如果你在服务器端存储了会话标识符，也应使其失效。这可以防止攻击者在事后截获会话 cookie，并尝试利用被窃取的
    cookie 重新建立会话。清除会话 cookie 就像通过 HTTP 响应发送一个带有空值的 `Set-Cookie` 头部来清空会话参数一样简单。
- en: '***Preventing User Enumeration***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***防止用户枚举***'
- en: You can cut down the risk of an attacker compromising your authentication system
    if they can’t *enumerate* users, which means testing each username from a list
    to see whether it exists on your website. Attackers frequently use leaked credentials
    from prior hacks and attempt to verify whether any of these usernames exist on
    a target website. After they narrow down the list, they then proceed to guess
    passwords for usernames that matched.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者无法*枚举*用户（即通过测试用户名列表中的每个用户名来查看其是否存在于你的网站上），那么你可以降低攻击者危及你的认证系统的风险。攻击者经常使用从先前泄露的密码中获得的凭据，尝试验证这些用户名是否存在于目标网站上。在缩小列表范围后，他们会尝试对匹配的用户名进行密码猜测。
- en: '**Preventing Potential Enumeration Vulnerabilities**'
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**防止潜在的枚举漏洞**'
- en: Login pages often allow an attacker to determine whether a username is taken
    on a site. If the page shows an error message for an incorrect password that differs
    from the error message for an unknown user, then an attacker can infer from the
    responses whether certain usernames correspond to accounts that exist on your
    site. It’s important to keep the error messages generic to avoid leaking this
    type of information. For example, simply use the error message `an incorrect username
    or password was entered` whenever the username is unrecognized or the password
    is incorrect.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 登录页面通常允许攻击者确定用户名是否已在网站上注册。如果页面对错误密码的错误信息与对未知用户的错误信息不同，攻击者便能从响应中推测出某些用户名是否对应你网站上存在的帐户。为了避免泄露这类信息，重要的是保持错误信息的通用性。例如，无论用户名是否未被识别，或者密码是否错误，都可以使用错误信息`用户名或密码错误`。
- en: Attackers may also use *timing attacks* to enumerate users by measuring HTTP
    response times. Hashing a password is a time-consuming operation; though it typically
    takes less than a second, it’s still a measurable amount of time. If your site
    calculates password hashes only when a user enters a valid username, an attacker
    can measure the slightly slower response time to infer which accounts exist on
    the site. Make sure your site calculates password hashes during authentication
    even for invalid usernames.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者还可能通过*时延攻击*来枚举用户，方法是通过测量HTTP响应时间。哈希密码是一个耗时操作；尽管通常不到一秒钟，但依然是一个可测量的时间。如果你的网站只在用户输入有效用户名时计算密码哈希，攻击者可以通过测量略微更慢的响应时间来推断哪些帐户在网站上存在。确保你的网站即使在无效用户名的情况下也进行密码哈希计算。
- en: 'You should prevent your password-reset screen from revealing that a username
    exists, too. If an attacker clicks a “Forgotten password” link and types in an
    email address to request a password-reset link, the response message on the page
    shouldn’t reveal whether a reset email was sent. This prevents the attacker from
    knowing whether that email address is tied to an account on your site. Keep the
    message neutral: something like `Check your inbox`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该防止密码重置页面透露某个用户名是否存在。如果攻击者点击“忘记密码”链接并输入电子邮件地址请求密码重置链接，页面上的响应信息不应透露是否发送了重置邮件。这可以防止攻击者得知该电子邮件地址是否与网站上的帐户相关联。保持消息中立，例如：`请检查您的收件箱`。
- en: '**Implementing CAPTCHA**'
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**实现验证码**'
- en: You can also defuse user enumeration attacks by implementing a *CAPTCHA (Completely
    Automated Public Turing test to tell Computers and Humans Apart)*, which asks
    web users to perform various image recognition tasks that are trivial for humans
    but tricky for computers. CAPTCHAs, like the one shown in [Figure 9-4](ch09.xhtml#ch9fig4),
    make it impractical for attackers to abuse a web page via hacking scripts.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过实现*验证码（完全自动化公共图灵测试区分计算机与人类）*来化解用户枚举攻击，验证码要求网页用户完成一些对人类来说简单、对计算机来说棘手的图像识别任务。[图9-4](ch09.xhtml#ch9fig4)中所示的验证码，使得攻击者无法通过黑客脚本滥用网页。
- en: CAPTCHAs aren’t perfect. Attackers can defeat them by using sophisticated machine
    learning techniques, or by paying human users to complete a task in their stead.
    However, they are generally reliable enough to deter most hacking attempts, and
    you can easily add them to a website. For example, Google implements a CAPTCHA
    widget called reCAPTCHA that you can install on your site with a few lines of
    code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 验证码并不完美。攻击者可以通过使用复杂的机器学习技术或支付人工用户代替他们完成任务来绕过验证码。然而，验证码通常足够可靠，能有效威慑大多数黑客攻击，而且你可以轻松地将其添加到网站上。例如，谷歌实现了一个名为reCAPTCHA的验证码小部件，你可以通过几行代码将其安装到你的网站上。
- en: '![image](Images/09fig04.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/09fig04.jpg)'
- en: '*Figure 9-4: Some tasks are simply too hard for a computer to complete successfully.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-4：某些任务对计算机来说实在是太难完成了。*'
- en: '**Summary**'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Hackers often attempt to attack your authentication system in an effort to steal
    your users’ credentials. To secure your website, you can use a third-party authentication
    system like Facebook Login or a single sign-on identity provider.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客经常试图攻击你的认证系统，企图窃取用户的凭证。为了保护你的网站，你可以使用第三方认证系统，如 Facebook 登录或单点登录身份提供者。
- en: If you’re implementing your own authentication system, you’ll need to have users
    choose a username and password upon sign-up. You should also store and validate
    an email address for each user. It makes sense to use this email as a username,
    unless you need users to have a visible display name.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在实现自己的认证系统，你需要让用户在注册时选择用户名和密码。你还应该为每个用户存储并验证电子邮件地址。除非你需要用户有可见的显示名称，否则使用电子邮件作为用户名是合理的。
- en: The only reliable way to validate an email address is to send it an email containing
    a link with a unique, temporary validation token that your site can check when
    the user clicks it. Your password-reset mechanism for users who have forgotten
    their password should work in the same way. Password-reset emails and the initial
    validation email should time out after a period of time, and after they’re used
    for the first time.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 验证电子邮件地址的唯一可靠方法是发送一封包含唯一临时验证令牌的链接的电子邮件，用户点击后你的网站可以检查此令牌。对于忘记密码的用户，密码重置机制应采用相同的方式。密码重置邮件和初始验证邮件应在一段时间后超时，且在第一次使用后失效。
- en: You should process passwords with a cryptographic hash algorithm before storing
    them. You should also salt your password hashes to prevent rainbow table attacks.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储密码之前，你应该使用加密哈希算法处理密码。你还应该为密码哈希加盐，以防止彩虹表攻击。
- en: Consider adding multifactor authentication if your site hosts sensitive data.
    Make sure to include a logout function somewhere on your site. Keep login failure
    messages generic, to prevent hackers from enumerating usernames on your site.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的网站托管敏感数据，考虑添加多因素认证。确保在你的网站上某处包含注销功能。保持登录失败消息的通用性，避免黑客枚举你网站上的用户名。
- en: In the next chapter, you will investigate ways that users on your site can have
    their account compromised after they log in, by having their session stolen by
    an attacker.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将调查用户在登录后如何可能因为会话被攻击者窃取而导致账户被入侵。
