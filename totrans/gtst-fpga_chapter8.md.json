["```\nmodule Turnstile_Example\n (input i_Reset,\n  input i_Clk,\n  input i_Coin,\n  input i_Push,\n  output o_Locked);\n❶ localparam LOCKED   = 1'b0;\n  localparam UNLOCKED = 1'b1;\n  reg r_Curr_State, r_Next_State;\n  // Current state register\n❷ always @(posedge i_Clk or posedge i_Reset)\n  begin\n    if (i_Reset)\n    ❸ r_Curr_State <= LOCKED;\n    else\n    ❹ r_Curr_State <= r_Next_State;\n  end\n  // Next state determination\n❺ always @(r_Curr_State or i_Coin or i_Push)\n  begin\n     r_Next_State <= r_Curr_State;\n  ❻ case (r_Curr_State)\n       LOCKED:\n         if (i_Coin)\n         ❼ r_Next_State <= UNLOCKED;\n       UNLOCKED:\n         if (i_Push)\n            r_Next_State <= LOCKED;\n       ❽\n     endcase\n  end\n❾ assign o_Locked = (r_Curr_State == LOCKED);\nendmodule\n```", "```\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nentity Turnstile_Example is\n  port (\n    i_Reset  : in std_logic;\n    i_Clk    : in std_logic;\n    i_Coin   : in std_logic;\n    i_Push   : in std_logic;\n    o_Locked : out std_logic);\nend entity Turnstile_Example;\narchitecture RTL of Turnstile_Example is\n❶ type t_State is (LOCKED, UNLOCKED);\n  signal r_Curr_State, r_Next_State : t_State;\nbegin\n  -- Current state register\n❷ process (i_Clk, i_Reset) is\n  begin\n    if i_Reset = '1' then\n    ❸ r_Curr_State <= LOCKED;\n    elsif rising_edge(i_Clk) then\n    ❹ r_Curr_State <= r_Next_State;\n    end if;\n  end process;\n  -- Next state determination\n❺ process (r_Curr_State, i_Coin, i_Push)\n  begin\n    r_Next_State <= r_Curr_State;\n ❻ case r_Curr_State is\n      when LOCKED =>\n        if i_Coin = '1' then\n        ❼ r_Next_State <= UNLOCKED;\n        end if;\n      when UNLOCKED =>\n        if i_Push = '1' then\n          r_Next_State <= LOCKED;\n        end if;\n     ❽\n    end case;\n  end process;\n❾ o_Locked <= '1' when r_Curr_State = LOCKED else '0';\nend RTL;\n```", "```\nCase statement contains all choices explicitly. You can safely remove the\nredundant 'others'(13).\n```", "```\nmodule Turnstile_Example\n (input i_Reset,\n  input i_Clk,\n  input i_Coin,\n  input i_Push,\n  output o_Locked);\n  localparam LOCKED   = 1'b0;\n  localparam UNLOCKED = 1'b1;\n  reg r_Curr_State;\n  // Single always block approach\n❶ always @(posedge i_Clk or posedge i_Reset)\n  begin\n    if (i_Reset)\n      r_Curr_State <= LOCKED;\n    else\n    begin\n    ❷ case (r_Curr_State)\n        LOCKED:\n          if (i_Coin)\n            r_Curr_State <= UNLOCKED;\n        UNLOCKED:\n          if (i_Push)\n            r_Curr_State <= LOCKED;\n      endcase\n    end\n  end\n  assign o_Locked = (r_Curr_State == LOCKED);\nendmodule\n```", "```\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nentity Turnstile_Example is\n  port (\n    i_Reset  : in std_logic;\n    i_Clk    : in std_logic;\n    i_Coin   : in std_logic;\n    i_Push   : in std_logic;\n    o_Locked : out std_logic);\nend entity Turnstile_Example;\narchitecture RTL of Turnstile_Example is\n  type t_State is (LOCKED, UNLOCKED);\n  signal r_Curr_State : t_State;\nbegin\n  -- Single always block approach\n❶ process (i_Clk, i_Reset) is\n  begin\n    if (i_Reset) then\n      r_Curr_State <= LOCKED;\n    elsif rising_edge(i_Clk) then\n  ❷ case r_Curr_State is\n      when LOCKED =>\n         if i_Coin = '1' then\n           r_Curr_State <= UNLOCKED;\n         end if;\n      when UNLOCKED =>\n         if i_Push = '1' then\n           r_Curr_State <= LOCKED;\n         end if;\n    end case;\n  end if;\nend process;\n o_Locked <= '1' when r_Curr_State = LOCKED else '0';\nend RTL;\n```", "```\nmodule Turnstile_Example_TB();\n❶ reg r_Reset = 1'b1, r_Clk = 1'b0, r_Coin = 1'b0, r_Push = 1'b0;\n  wire w_Locked;\n  Turnstile_Example UUT\n   (.i_Reset(r_Reset),\n   .i_Clk(r_Clk),\n   .i_Coin(r_Coin),\n   .i_Push(r_Push),\n   .o_Locked(w_Locked));\n  always #1 r_Clk <= !r_Clk;\n  initial begin\n    $dumpfile(\"dump.vcd\");\n    $dumpvars;\n    #10;\n ❷ r_Reset <= 1'b0;\n    #10;\n    ❸ assert (w_Locked == 1'b1);\n ❹ r_Coin <= 1'b1;\n    #10;\n    assert (w_Locked == 1'b0);\n    r_Push <= 1'b1;\n    #10;\n    assert (w_Locked == 1'b1);\n    r_Coin <= 1'b0;\n    #10;\n    assert (w_Locked == 1'b1);\n    r_Push <= 1'b0;\n    #10;\n    assert (w_Locked == 1'b1);\n    $finish();\n  end\nendmodule\n```", "```\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse std.env.finish;\nentity Turnstile_Example_TB is\nend entity Turnstile_Example_TB;\narchitecture test of Turnstile_Example_TB is\n❶ signal r_Reset : std_logic := '1';\n  signal r_Clk, r_Coin, r_Push : std_logic := '0';\n  signal w_Locked : std_logic;\nbegin\n  UUT : entity work.Turnstile_Example\n  port map (\n    i_Reset  => r_Reset,\n    i_Clk    => r_Clk,\n    i_Coin   => r_Coin,\n    i_Push   => r_Push,\n    o_Locked => w_Locked);\n  r_Clk <= not r_Clk after 1 ns;\n  process is\n  begin\n    wait for 10 ns;\n  ❷ r_Reset <= '0';\n    wait for 10 ns;\n  ❸ assert w_Locked = '1' severity failure;\n  ❹ r_Coin <= '1';\n    wait for 10 ns;\n    assert w_Locked = '0' severity failure;\n    r_Push <= '1';\n    wait for 10 ns;\n    assert w_Locked = '1' severity failure;\n    r_Coin <= '0';\n    wait for 10 ns;\n    assert w_Locked = '1' severity failure;\n    r_Push <= '0';\n    wait for 10 ns;\n    assert w_Locked = '1' severity failure;\n    finish;  -- need VHDL-2008\n  end process;\nend test;\n```", "```\nmodule Binary_To_7Segment\n  (input      i_Clk,\n❶ input [3:0] i_Binary_Num,\n  output      o_Segment_A,\n  output      o_Segment_B,\n  output      o_Segment_C,\n  output      o_Segment_D,\n  output      o_Segment_E,\n  output      o_Segment_F,\n  output      o_Segment_G);\n  reg [6:0]   r_Hex_Encoding;\n  always @(posedge i_Clk)\n    begin\n    ❷ case (i_Binary_Num)\n         4'b0000 : r_Hex_Encoding <= 7'b1111110; // 0x7E\n         4'b0001 : r_Hex_Encoding <= 7'b0110000; // 0x30\n         4'b0010 : r_Hex_Encoding <= 7'b1101101; // 0x6D\n         4'b0011 : r_Hex_Encoding <= 7'b1111001; // 0x79\n         4'b0100 : r_Hex_Encoding <= 7'b0110011; // 0x33\n         4'b0101 : r_Hex_Encoding <= 7'b1011011; // 0x5B\n         4'b0110 : r_Hex_Encoding <= 7'b1011111; // 0x5F\n      ❸ 4'b0111 : r_Hex_Encoding <= 7'b1110000; // 0x70\n         4'b1000 : r_Hex_Encoding <= 7'b1111111; // 0x7F\n         4'b1001 : r_Hex_Encoding <= 7'b1111011; // 0x7B\n         4'b1010 : r_Hex_Encoding <= 7'b1110111; // 0x77\n         4'b1011 : r_Hex_Encoding <= 7'b0011111; // 0x1F\n         4'b1100 : r_Hex_Encoding <= 7'b1001110; // 0x4E\n         4'b1101 : r_Hex_Encoding <= 7'b0111101; // 0x3D\n         4'b1110 : r_Hex_Encoding <= 7'b1001111; // 0x4F\n         4'b1111 : r_Hex_Encoding <= 7'b1000111; // 0x47\n         default : r_Hex_Encoding <= 7'b0000000; // 0x00\n      endcase\n    end\n❹ assign o_Segment_A = r_Hex_Encoding[6];\n  assign o_Segment_B = r_Hex_Encoding[5];\n  assign o_Segment_C = r_Hex_Encoding[4];\n  assign o_Segment_D = r_Hex_Encoding[3];\n  assign o_Segment_E = r_Hex_Encoding[2];\n  assign o_Segment_F = r_Hex_Encoding[1];\n  assign o_Segment_G = r_Hex_Encoding[0];\nendmodule\n```", "```\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nentity Binary_To_7Segment is\n  port (\n    i_Clk        : in std_logic;\n ❶ i_Binary_Num : in std_logic_vector(3 downto 0);\n    o_Segment_A  : out std_logic;\n    o_Segment_B  : out std_logic;\n    o_Segment_C  : out std_logic;\n    o_Segment_D  : out std_logic;\n    o_Segment_E  : out std_logic;\n    o_Segment_F  : out std_logic;\n    o_Segment_G  : out std_logic\n    );\nend entity Binary_To_7Segment;\narchitecture RTL of Binary_To_7Segment is\n  signal r_Hex_Encoding : std_logic_vector(6 downto 0);\nbegin\n  process (i_Clk) is\n  begin\n     if rising_edge(i_Clk) then\n     ❷ case i_Binary_Num is\n          when \"0000\" =>\n            r_Hex_Encoding <= \"1111110\"; -- 0x7E\n          when \"0001\" =>\n            r_Hex_Encoding <= \"0110000\"; -- 0x30\n          when \"0010\" =>\n            r_Hex_Encoding <= \"1101101\"; -- 0x6D\n          when \"0011\" =>\n            r_Hex_Encoding <= \"1111001\"; -- 0x79\n          when \"0100\" =>\n            r_Hex_Encoding <= \"0110011\"; -- 0x33\n          when \"0101\" =>\n            r_Hex_Encoding <= \"1011011\"; -- 0x5B\n          when \"0110\" =>\n            r_Hex_Encoding <= \"1011111\"; -- 0x5F\n        ❸ when \"0111\" =>\n            r_Hex_Encoding <= \"1110000\"; -- 0x70\n          when \"1000\" =>\n            r_Hex_Encoding <= \"1111111\"; -- 0x7F\n          when \"1001\" =>\n            r_Hex_Encoding <= \"1111011\"; -- 0x7B\n          when \"1010\" =>\n            r_Hex_Encoding <= \"1110111\"; -- 0x77\n          when \"1011\" =>\n            r_Hex_Encoding <= \"0011111\"; -- 0x1F\n          when \"1100\" =>\n            r_Hex_Encoding <= \"1001110\"; -- 0x4E\n          when \"1101\" =>\n            r_Hex_Encoding <= \"0111101\"; -- 0x3D\n          when \"1110\" =>\n            r_Hex_Encoding <= \"1001111\"; -- 0x4F\n          when \"1111\" =>\n            r_Hex_Encoding <= \"1000111\"; -- 0x47\n          when others =>\n            r_Hex_Encoding <= \"0000000\"; -- 0x00\n      end case;\n    end if;\n  end process;\n❹ o_Segment_A <= r_Hex_Encoding(6);\n  o_Segment_B <= r_Hex_Encoding(5);\n  o_Segment_C <= r_Hex_Encoding(4);\n  o_Segment_D <= r_Hex_Encoding(3);\n  o_Segment_E <= r_Hex_Encoding(2);\n  o_Segment_F <= r_Hex_Encoding(1);\n  o_Segment_G <= r_Hex_Encoding(0);\nend architecture RTL;\n```", "```\nmodule State_Machine_Project_Top\n (input i_Clk,\n  // Input switches for entering pattern\n  input i_Switch_1,\n  input i_Switch_2,\n  input i_Switch_3,\n  input i_Switch_4,\n  // Output LEDs for displaying pattern\n  output o_LED_1,\n  output o_LED_2,\n  output o_LED_3,\n  output o_LED_4,\n  // Scoreboard, 7-segment display\n  output o_Segment2_A,\n  output o_Segment2_B,\n  output o_Segment2_C,\n  output o_Segment2_D,\n  output o_Segment2_E,\n  output o_Segment2_F,\n  output o_Segment2_G);\n❶ localparam GAME_LIMIT     = 7;        // Increase to make game harder\n  localparam CLKS_PER_SEC   = 25000000; // 25 MHz clock\n  localparam DEBOUNCE_LIMIT = 250000;  // 10 ms debounce filter\n  wire w_Switch_1, w_Switch_2, w_Switch_3, w_Switch_4;\n  wire w_Segment2_A, w_Segment2_B, w_Segment2_C, w_Segment2_D;\n  wire w_Segment2_E, w_Segment2_F, w_Segment2_G;\n  wire [3:0] w_Score;\n  // Debounce all switch inputs to remove mechanical glitches\n❷ Debounce_Filter #(.DEBOUNCE_LIMIT(DEBOUNCE_LIMIT)) Debounce_SW1\n  (.i_Clk(i_Clk),\n   .i_Bouncy(i_Switch_1),\n   .o_Debounced(w_Switch_1)); Debounce_Filter #(.DEBOUNCE_LIMIT(DEBOUNCE_LIMIT)) Debounce_SW2\n  (.i_Clk(i_Clk),\n   .i_Bouncy(i_Switch_2),\n   .o_Debounced(w_Switch_2));\n  Debounce_Filter #(.DEBOUNCE_LIMIT(DEBOUNCE_LIMIT)) Debounce_SW3\n  (.i_Clk(i_Clk),\n   .i_Bouncy(i_Switch_3),\n   .o_Debounced(w_Switch_3));\n  Debounce_Filter #(.DEBOUNCE_LIMIT(DEBOUNCE_LIMIT)) Debounce_SW4\n  (.i_Clk(i_Clk),\n   .i_Bouncy(i_Switch_4),\n   .o_Debounced(w_Switch_4));\n❸ State_Machine_Game #(.CLKS_PER_SEC(CLKS_PER_SEC),\n                       .GAME_LIMIT(GAME_LIMIT)) Game_Inst\n  (.i_Clk(i_Clk),\n   .i_Switch_1(w_Switch_1),\n   .i_Switch_2(w_Switch_2),\n   .i_Switch_3(w_Switch_3),\n   .i_Switch_4(w_Switch_4),\n   .o_Score(w_Score),\n   .o_LED_1(o_LED_1),\n   .o_LED_2(o_LED_2),\n   .o_LED_3(o_LED_3),\n   .o_LED_4(o_LED_4));\n❹ Binary_To_7Segment Scoreboard\n  (.i_Clk(i_Clk),\n   .i_Binary_Num(w_Score),\n   .o_Segment_A(w_Segment2_A),\n   .o_Segment_B(w_Segment2_B),\n   .o_Segment_C(w_Segment2_C),\n   .o_Segment_D(w_Segment2_D),\n   .o_Segment_E(w_Segment2_E),\n   .o_Segment_F(w_Segment2_F),\n   .o_Segment_G(w_Segment2_G));\n❺ assign o_Segment2_A = !w_Segment2_A;\n  assign o_Segment2_B = !w_Segment2_B;\n  assign o_Segment2_C = !w_Segment2_C;\n  assign o_Segment2_D = !w_Segment2_D;\n  assign o_Segment2_E = !w_Segment2_E;\n  assign o_Segment2_F = !w_Segment2_F;\n  assign o_Segment2_G = !w_Segment2_G;\nendmodule\n```", "```\nlibrary IEEE;\nuse IEEE.std_logic_1164.all;\nentity State_Machine_Project_Top is port (\n    i_Clk : in std_logic;\n    -- Input switches for entering pattern\n    i_Switch_1 : in std_logic;\n    i_Switch_2 : in std_logic;\n    i_Switch_3 : in std_logic;\n    i_Switch_4 : in std_logic;\n    -- Output LEDs for displaying pattern\n    o_LED_1 : out std_logic;\n    o_LED_2 : out std_logic;\n    o_LED_3 : out std_logic;\n    o_LED_4 : out std_logic;\n    -- Scoreboard, 7-segment display\n    o_Segment2_A : out std_logic;\n    o_Segment2_B : out std_logic;\n    o_Segment2_C : out std_logic;\n    o_Segment2_D : out std_logic;\n    o_Segment2_E : out std_logic;\n    o_Segment2_F : out std_logic;\n    o_Segment2_G : out std_logic);\nend entity State_Machine_Project_Top;\narchitecture RTL of State_Machine_Project_Top is\n❶ constant GAME_LIMIT      : integer := 7;       -- Increase to make game harder\n   constant CLKS_PER_SEC   : integer := 25000000; -- 25 MHz clock\n   constant DEBOUNCE_LIMIT : integer := 250000;   -- 10 ms debounce filter\n   signal w_Switch_1, w_Switch_2, w_Switch_3, w_Switch_4 : std_logic;\n   signal w_Score : std_logic_vector(3 downto 0);\n   signal w_Segment2_A, w_Segment2_B, w_Segment2_C, w_Segment2_D : std_logic;\n   signal w_Segment2_E, w_Segment2_F, w_Segment2_G : std_logic;\nbegin\n❷ Debounce_SW1 : entity work.Debounce_Filter\n     generic map (\n       DEBOUNCE_LIMIT => DEBOUNCE_LIMIT)\n     port map (\n       i_Clk       => i_Clk,\n       i_Bouncy    => i_Switch_1,\n       o_Debounced => w_Switch_1);\n   Debounce_SW2 : entity work.Debounce_Filter\n     generic map (\n       DEBOUNCE_LIMIT => DEBOUNCE_LIMIT)\n     port map (\n       i_Clk       => i_Clk,\n       i_Bouncy    => i_Switch_2,\n       o_Debounced => w_Switch_2);\n   Debounce_SW3 : entity work.Debounce_Filter\n     generic map (\n       DEBOUNCE_LIMIT => DEBOUNCE_LIMIT) port map (\n       i_Clk       => i_Clk,\n       i_Bouncy    => i_Switch_3,\n       o_Debounced => w_Switch_3);\n   Debounce_SW4 : entity work.Debounce_Filter\n     generic map (\n       DEBOUNCE_LIMIT => DEBOUNCE_LIMIT)\n     port map (\n       i_Clk => i_Clk,\n       i_Bouncy => i_Switch_4,\n       o_Debounced => w_Switch_4);\n❸ Game_Inst : entity work.State_Machine_Game\n   generic map (\n     CLKS_PER_SEC => CLKS_PER_SEC,\n     GAME_LIMIT   => GAME_LIMIT)\n   port map (\n     i_Clk      => i_Clk,\n     i_Switch_1 => w_Switch_1,\n     i_Switch_2 => w_Switch_2,\n     i_Switch_3 => w_Switch_3,\n     i_Switch_4 => w_Switch_4,\n     o_Score    => w_Score,\n     o_LED_1    => o_LED_1,\n     o_LED_2    => o_LED_2,\n     o_LED_3    => o_LED_3,\n     o_LED_4    => o_LED_4);\n❹ Scoreboard : entity work.Binary_To_7Segment\n     port map (\n       i_Clk        => i_Clk,\n       i_Binary_Num => w_Score,\n       o_Segment_A  => w_Segment2_A,\n       o_Segment_B  => w_Segment2_B,\n       o_Segment_C  => w_Segment2_C,\n       o_Segment_D  => w_Segment2_D,\n       o_Segment_E  => w_Segment2_E,\n       o_Segment_F  => w_Segment2_F,\n       o_Segment_G  => w_Segment2_G);\n❺ o_Segment2_A <= not w_Segment2_A;\n   o_Segment2_B <= not w_Segment2_B;\n   o_Segment2_C <= not w_Segment2_C;\n   o_Segment2_D <= not w_Segment2_D;\n   o_Segment2_E <= not w_Segment2_E;\n   o_Segment2_F <= not w_Segment2_F;\n   o_Segment2_G <= not w_Segment2_G;\nend RTL;\n```", "```\nmodule State_Machine_Game # (parameter CLKS_PER_SEC = 25000000,\n                             parameter GAME_LIMIT = 6)\n (input i_Clk,\n  input i_Switch_1,\n  input i_Switch_2,\n  input i_Switch_3,\n  input i_Switch_4,\n  output reg [3:0] o_Score,\n  output o_LED_1,\n  output o_LED_2,\n  output o_LED_3,\n  output o_LED_4\n  ); ❶ localparam START        = 3'd0;\n  localparam PATTERN_OFF  = 3'd1;\n  localparam PATTERN_SHOW = 3'd2;\n  localparam WAIT_PLAYER  = 3'd3;\n  localparam INCR_SCORE   = 3'd4;\n  localparam LOSER        = 3'd5;\n  localparam WINNER       = 3'd6;\n❷ reg [2:0] r_SM_Main;\n  reg r_Toggle, r_Switch_1, r_Switch_2, r_Switch_3;\n  reg r_Switch_4, r_Button_DV;\n❸ reg [1:0] r_Pattern[0:10]; // 2D array: 2 bits wide x 11 deep\n  wire [21:0] w_LFSR_Data;\n  reg [$clog2(GAME_LIMIT)-1:0] r_Index; // Display index\n  reg [1:0] r_Button_ID;\n  wire w_Count_En, w_Toggle;\n`--snip--`\n```", "```\nlibrary IEEE;\nuse IEEE.std_logic_1164.all;\nuse IEEE.numeric_std.all;\nentity State_Machine_Game is\n  generic (\n    CLKS_PER_SEC : integer := 25000000;\n    GAME_LIMIT   : integer := 6);\n  port(\n    i_Clk      : in std_logic;\n    i_Switch_1 : in std_logic;\n    i_Switch_2 : in std_logic;\n    i_Switch_3 : in std_logic;\n    i_Switch_4 : in std_logic;\n    o_Score    : out std_logic_vector(3 downto 0);\n    o_LED_1    : out std_logic;\n    o_LED_2    : out std_logic;\n    o_LED_3    : out std_logic;\n    o_LED_4    : out std_logic);\nend entity State_Machine_Game;\narchitecture RTL of State_Machine_Game is\n❶ type t_SM_Main is (START, PATTERN_OFF, PATTERN_SHOW,\n                     WAIT_PLAYER, INCR_SCORE, LOSER, WINNER);\n❷ signal r_SM_Main : t_SM_Main;\n  signal w_Count_En, w_Toggle, r_Toggle, r_Switch_1 : std_logic;\n  signal r_Switch_2, r_Switch_3, r_Switch_4, r_Button_DV : std_logic;\n  type t_Pattern is array (0 to 10) of std_logic_vector(1 downto 0);\n❸ signal r_Pattern : t_Pattern; -- 2D Array: 2-bit wide x 11 deep signal w_LFSR_Data : std_logic_vector(21 downto 0);\n  signal r_Index : integer range 0 to GAME_LIMIT;\n  signal w_Index_SLV : std_logic_vector(7 downto 0);\n  signal r_Button_ID : std_logic_vector(1 downto 0);\n  signal r_Score : unsigned(3 downto 0);\n`--snip--`\n```", "```\n`--snip--`\n  always @(posedge i_Clk)\n  begin\n    // Reset game from any state\n  ❶ if (i_Switch_1 & i_Switch_2)\n       r_SM_Main <= START;\n    else\n    begin\n       // Main state machine switch statement\n    ❷ case (r_SM_Main)\n`--snip--`\n```", "```\n`--snip--`\nbegin\n  process (i_Clk) is\n  begin\n    if rising_edge(i_Clk) then\n       -- Reset game from any state\n    ❶ if i_Switch_1 = '1' and i_Switch_2 = '1' then\n        r_SM_Main <= START;\n      else\n         -- Main state machine switch statement\n      ❷ case r_SM_Main is\n`--snip--`\n```", "```\n`--snip--`\n     // Main state machine switch statement\n        case (r_SM_Main) // Stay in START state until user releases buttons\n        ❶ START:\n           begin\n              // Wait for reset condition to go away\n           ❷ if (!i_Switch_1 & !i_Switch_2 & r_Button_DV)\n              begin\n                o_Score   <= 0;\n                r_Index   <= 0;\n                r_SM_Main <= PATTERN_OFF;\n              end\n           end\n        ❸ PATTERN_OFF:\n           begin\n             if (!w_Toggle & r_Toggle) // Falling edge found\n                r_SM_Main <= PATTERN_SHOW;\n           end\n           // Show the next LED in the pattern\n        ❹ PATTERN_SHOW:\n           begin\n             if (!w_Toggle & r_Toggle) // Falling edge found\n             ❺ if (o_Score == r_Index)\n                begin\n                ❻ r_Index   <= 0;\n                   r_SM_Main <= WAIT_PLAYER;\n                end\n                else\n                begin\n                ❼ r_Index   <= r_Index + 1;\n                   r_SM_Main <= PATTERN_OFF;\n                end\n           end\n`--snip--`\n```", "```\n`--snip--`\n      -- Main state machine switch statement\n      case r_SM_Main is\n      -- Stay in START state until user releases buttons\n   ❶ when START =>\n         -- Wait for reset condition to go away\n         ❷ if (i_Switch_1 = '0' and i_Switch_2 = '0' and\n                r_Button_DV = '1') then\n              r_Score   <= to_unsigned(0, r_Score'length);\n              r_Index   <= 0;\n              r_SM_Main <= PATTERN_OFF;\n            end if;\n      ❸ when PATTERN_OFF =>\n            if w_Toggle = '0' and r_Toggle = '1' then -- Falling edge found r_SM_Main <= PATTERN_SHOW;\n            end if;\n         -- Show the next LED in the pattern\n      ❹ when PATTERN_SHOW =>\n           if w_Toggle = '0' and r_Toggle = '1' then -- Falling edge found\n           ❺ if r_Score = r_Index then\n              ❻ r_Index   <= 0;\n                 r_SM_Main <= WAIT_PLAYER;\n              else\n              ❼ r_Index   <= r_Index + 1;\n                 r_SM_Main <= PATTERN_OFF;\n              end if;\n            end if;\n`--snip--`\n```", "```\n`--snip--`\n       WAIT_PLAYER:\n       begin\n       ❶ if (r_Button_DV)\n          ❷ if (r_Pattern[r_Index] == r_Button_ID && r_Index == o_Score)\n             begin\n               r_Index   <= 0;\n               r_SM_Main <= INCR_SCORE;\n             end\n          ❹ else if (r_Pattern[r_Index] != r_Button_ID)\n               r_SM_Main <= LOSER;\n          ❺ else\n               r_Index <= r_Index + 1;\n       end\n`--snip--`\n```", "```\n`--snip--`\n        when WAIT_PLAYER =>\n        ❶ if r_Button_DV = '1' then\n           ❷ if (r_Pattern(r_Index) = r_Button_ID and\n                ❸ unsigned(w_Index_SLV) = r_Score) then\n                r_Index   <= 0;\n                r_SM_Main <= INCR_SCORE;\n           ❹ elsif r_Pattern(r_Index) /= r_Button_ID then\n                r_SM_Main <= LOSER;\n           ❺ else\n                r_Index <= r_Index + 1;\n              end if;\n           end if;\n`--snip--`\n```", "```\n`--snip--`\n         // Used to increment score counter\n      ❶ INCR_SCORE:\n         begin\n           o_Score <= o_Score + 1;\n           if (o_Score == GAME_LIMIT-1)\n             r_SM_Main <= WINNER;\n           else\n             r_SM_Main <= PATTERN_OFF;\n         end\n         // Display 0xA on 7-segment display, wait for new game\n      ❷ WINNER:\n         begin\n           o_Score <= 4'hA; // Winner!\n         end\n         // Display 0xF on 7-segment display, wait for new game\n      ❸ LOSER:\n         begin\n           o_Score <= 4'hF; // Loser!\n         end\n      ❹ default:\n           r_SM_Main <= START;\n      endcase\n    end\n  end\n`--snip--`\n```", "```\n`--snip--`\n          -- Used to increment score counter\n       ❶ when INCR_SCORE =>\n            r_Score <= r_Score + 1;\n            if r_Score = GAME_LIMIT then\n              r_SM_Main <= WINNER;\n            else\n              r_SM_Main <= PATTERN_OFF;\n            end if;\n          -- Display 0xA on 7-segment display, wait for new game\n       ❷ when WINNER =>\n            r_Score <= X\"A\"; -- Winner!\n          -- Display 0xF on 7-segment display, wait for new game\n       ❸ when LOSER =>\n            r_Score <= X\"F\"; -- Loser!\n       ❹ when others =>\n            r_SM_Main <= START;\n       end case;\n     end if;\n   end if;\n  end process;\n`--snip--`\n```", "```\n`--snip--`\n  // Register in the LFSR to r_Pattern when game starts\n  // Each 2 bits of LFSR is one value for r_Pattern 2D array\n  always @(posedge i_Clk)\n  begin\n  ❶ if (r_SM_Main == START)\n     begin\n       r_Pattern[0]  <= w_LFSR_Data[1:0];\n       r_Pattern[1]  <= w_LFSR_Data[3:2];\n       r_Pattern[2]  <= w_LFSR_Data[5:4];\n       r_Pattern[3]  <= w_LFSR_Data[7:6];\n       r_Pattern[4]  <= w_LFSR_Data[9:8];\n       r_Pattern[5]  <= w_LFSR_Data[11:10];\n       r_Pattern[6]  <= w_LFSR_Data[13:12];\n       r_Pattern[7]  <= w_LFSR_Data[15:14];\n       r_Pattern[8]  <= w_LFSR_Data[17:16];\n       r_Pattern[9]  <= w_LFSR_Data[19:18];\n       r_Pattern[10] <= w_LFSR_Data[21:20];\n     end\n  end\n`--snip--`\n```", "```\n`--snip--`\n  -- Register in the LFSR to r_Pattern when game starts\n  -- Each 2 bits of LFSR is one value for r_Pattern 2D array\n  process (i_Clk) is\n  begin\n     if rising_edge(i_Clk) then\n     ❶ if r_SM_Main = START then\n          r_Pattern(0)  <= w_LFSR_Data(1 downto 0);\n          r_Pattern(1)  <= w_LFSR_Data(3 downto 2);\n          r_Pattern(2)  <= w_LFSR_Data(5 downto 4);\n          r_Pattern(3)  <= w_LFSR_Data(7 downto 6);\n          r_Pattern(4)  <= w_LFSR_Data(9 downto 8);\n          r_Pattern(5)  <= w_LFSR_Data(11 downto 10);\n          r_Pattern(6)  <= w_LFSR_Data(13 downto 12);\n          r_Pattern(7)  <= w_LFSR_Data(15 downto 14);\n          r_Pattern(8)  <= w_LFSR_Data(17 downto 16); r_Pattern(9)  <= w_LFSR_Data(19 downto 18);\n          r_Pattern(10) <= w_LFSR_Data(21 downto 20);\n        end if;\n     end if;\n  end process;\n❷ w_Index_SLV <= std_logic_vector(to_unsigned(r_Index, w_Index_SLV'length));\n`--snip--`\n```", "```\n`--snip--`\n  assign o_LED_1 = (r_SM_Main == PATTERN_SHOW &&\n                    r_Pattern[r_Index] == 2'b00) ? 1'b1 : i_Switch_1;\n  assign o_LED_2 = (r_SM_Main == PATTERN_SHOW &&\n                    r_Pattern[r_Index] == 2'b01) ? 1'b1 : i_Switch_2;\n  assign o_LED_3 = (r_SM_Main == PATTERN_SHOW &&\n                    r_Pattern[r_Index] == 2'b10) ? 1'b1 : i_Switch_3;\n  assign o_LED_4 = (r_SM_Main == PATTERN_SHOW &&\n                    r_Pattern[r_Index] == 2'b11) ? 1'b1 : i_Switch_4;\n`--snip--`\n```", "```\n`--snip--`\n  o_LED_1 <= '1' when (r_SM_Main = PATTERN_SHOW and\n                       r_Pattern(r_Index) = \"00\") else i_Switch_1;\n  o_LED_2 <= '1' when (r_SM_Main = PATTERN_SHOW and\n                       r_Pattern(r_Index) = \"01\") else i_Switch_2;\n  o_LED_3 <= '1' when (r_SM_Main = PATTERN_SHOW and\n                       r_Pattern(r_Index) = \"10\") else i_Switch_3;\n  o_LED_4 <= '1' when (r_SM_Main = PATTERN_SHOW and\n                       r_Pattern(r_Index) = \"11\") else i_Switch_4;\n`--snip--`\n```", "```\n`--snip--`\n  // Create registers to enable falling edge detection\n  always @(posedge i_Clk)\n  begin\n  ❶ r_Toggle   <= w_Toggle;\n  ❷ r_Switch_1 <= i_Switch_1;\n     r_Switch_2 <= i_Switch_2;\n     r_Switch_3 <= i_Switch_3;\n     r_Switch_4 <= i_Switch_4;\n  ❸ if (r_Switch_1 & !i_Switch_1)\n     begin\n       r_Button_DV <= 1'b1;\n       r_Button_ID <= 0;\n     end\n     else if (r_Switch_2 & !i_Switch_2)\n     begin\n       r_Button_DV <= 1'b1;\n       r_Button_ID <= 1;\n     end\n     else if (r_Switch_3 & !i_Switch_3)\n     begin\n       r_Button_DV <= 1'b1;\n       r_Button_ID <= 2;\n     end\n     else if (r_Switch_4 & !i_Switch_4)\n     begin\n       r_Button_DV <= 1'b1;\n       r_Button_ID <= 3;\n     end\n  ❹ else\n     begin\n       r_Button_DV <= 1'b0;\n       r_Button_ID <= 0;\n     end\n  end\n`--snip--`\n```", "```\n`--snip--`\n  -- Create registers to enable falling edge detection\n  process (i_Clk) is\n  begin if rising_edge(i_Clk) then\n    ❶ r_Toggle   <= w_Toggle;\n    ❷ r_Switch_1 <= i_Switch_1;\n       r_Switch_2 <= i_Switch_2;\n       r_Switch_3 <= i_Switch_3;\n       r_Switch_4 <= i_Switch_4;\n    ❸ if r_Switch_1 = '1' and i_Switch_1 = '0' then\n         r_Button_DV <= '1';\n         r_Button_ID <= \"00\";\n       elsif r_Switch_2 = '1' and i_Switch_2 = '0' then\n         r_Button_DV <= '1';\n         r_Button_ID <= \"01\";\n       elsif r_Switch_3 = '1' and i_Switch_3 = '0' then\n         r_Button_DV <= '1';\n         r_Button_ID <= \"10\";\n       elsif r_Switch_4 = '1' and i_Switch_4 = '0' then\n         r_Button_DV <= '1';\n         r_Button_ID <= \"11\";\n    ❹ else\n         r_Button_DV <= '0';\n         r_Button_ID <= \"00\";\n       end if;\n    end if;\n  end process;\n`--snip--`\n```", "```\n`--snip--`\n   // w_Count_En is high when state machine is in\n   // PATTERN_SHOW state or PATTERN_OFF state, else low\n❶ assign w_Count_En = (r_SM_Main == PATTERN_SHOW ||\n                        r_SM_Main == PATTERN_OFF);\n❷ Count_And_Toggle #(.COUNT_LIMIT(CLKS_PER_SEC/4)) Count_Inst\n    (.i_Clk(i_Clk),\n     .i_Enable(w_Count_En),\n     .o_Toggle(w_Toggle));\n   // Generates 22-bit-wide random data\n❸ LFSR_22 LFSR_Inst\n    (.i_Clk(i_Clk),\n     .o_LFSR_Data(w_LFSR_Data),\n   ❹ .o_LFSR_Done()); // leave unconnected\nendmodule\n```", "```\n`--snip--`\n   -- w_Count_En is high when state machine is in\n   -- PATTERN_SHOW state or PATTERN_OFF state, else low\n❶ w_Count_En <= '1' when (r_SM_Main = PATTERN_SHOW or\n                           r_SM_Main = PATTERN_OFF) else '0';\n❷ Count_Inst : entity work.Count_And_Toggle\n   generic map (\n     COUNT_LIMIT => CLKS_PER_SEC/4)\n   port map (\n     i_Clk   => i_Clk,\n     i_Enable => w_Count_En,\n     o_Toggle => w_Toggle);\n   -- Generates 22-bit-wide random data\n❸ LFSR_Inst : entity work.LFSR_22\n   port map (\n     i_Clk       => i_Clk,\n     o_LFSR_Data => w_LFSR_Data,\n   ❹ o_LFSR_Done => open); -- leave unconnected\n❺ o_Score <= std_logic_vector(r_Score);\nend RTL;\n```", "```\nset_io o_Segment2_A 100\nset_io o_Segment2_B 99\nset_io o_Segment2_C 97\nset_io o_Segment2_D 95\nset_io o_Segment2_E 94\nset_io o_Segment2_F 8\nset_io o_Segment2_G 96\n```", "```\n`--snip--`\nRegister bits not including I/Os: 164 (12%)\n`--snip--`\nTotal LUTs: 239 (18%)\n```", "```\n`--snip--`\nRegister bits not including I/Os: 163 (12%)\n`--snip--`\nTotal LUTs: 225 (17%)\n```"]