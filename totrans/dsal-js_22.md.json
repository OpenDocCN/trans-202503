["```\n❶ const addLogging = (fn) => (...args) => {\n❷ console.log(`Entering ${fn.name}: ${args}`);\n  try {\n  ❸ const valueToReturn = fn(...args);\n  ❹ console.log(`Exiting ${fn.name} returning ${valueToReturn}`);\n  ❺ return valueToReturn;\n  } catch (thrownError) {\n  ❻ console.log(`Exiting ${fn.name} throwing ${thrownError}`);\n  ❼ throw thrownError;\n  }\n};\n```", "```\n❶ const {performance} = require(\"perf_hooks\");\n\n❷ const addTiming = (fn) => (...args) => {\n❸ const output = (text, name, tStart, tEnd) =>\n    console.log(`${name} - ${text} - Time: ${tEnd - tStart} ms`);\n\n❹ const tStart = performance.now();\n  try {\n  ❺ const valueToReturn = fn(...args);\n  ❻ output(\"normal exit\", fn.name, tStart, performance.now());\n  ❼ return valueToReturn;\n  } catch (thrownError) {\n  ❽ output(\"exception thrown\", fn.name, tStart, performance.now());\n  ❾ throw thrownError;\n  }\n};\n```", "```\nconst negate = (fn) => (...args) => !fn(...args);\n```", "```\n❶ const newBag = () => [];\n\n❷ const isEmpty = (bag) => bag.length === 0;\n\n❸ const find = (bag, value) => bag.includes(value);\n\n❹ const greatest = (bag) => isEmpty(bag) ? undefined : bag[bag.length - 1];\n\n❺ const add = (bag, value) => {\n  bag.push(value);\n bag.sort();\n  return bag;\n};\n\n❻ const remove = (bag, value) => {\n  const pos = bag.indexOf(value);\n  if (pos !== -1) {\n    bag.splice(pos);\n  }\n  return bag;\n};\n```", "```\nconst factorial = (n) => (n === 0 ? 1 : n * factorial(n – 1));\n```", "```\n❶ const solve = (goal, rings, score = 0, hit = []) => {\n  if (score === goal) {\n    return hit;\n  } else if (score > goal || rings.length === 0) {\n    return null;\n  } else {\n  ❷ const again = solve(goal, rings, score + rings[0], [      ...hit,       rings[0],     ]);\n  ❸ if (again) {\n     return again;\n  ❹} else {\n     const chosen = rings[0];\n     const others = rings.slice(1);\n     return (\n        solve(goal, others, score + chosen, [...hit, chosen]) ||\n        solve(goal, others, score, hit)\n      );\n    }\n  }\n};\n\nconsole.log(solve(100, [40, 39, 24, 23, 17, 16]));\n```", "```\nconsole.log(\n  solve(100, [\n    40, 40,\n    39, 39,\n    24, 24, 24, 24,\n    23, 23, 23, 23,\n    17, 17, 17, 17, 17,\n    16, 16, 16, 16, 16, 16\n  ])\n);\n```", "```\nconst costOfFragment = memoize((p, q) => {\n  ...\n  let optimum = Infinity;\n  let split = [];\n  for (let r = p; r < q; r++) {\n    **if (totalWidth(p, r) > MW) {**\n **break;**\n **}**\n    ...\n  }\n  return [optimum, split];\n});\n```", "```\nconst partial = blocks.reduce((a, c, i) => ((a[i + 1] = a[i] + c), a), [0]);\n```", "```\nconst {solve} = require(\"../send_more_money_puzzle\");\n\nconst toGoOut = (g, o, u, t) => {\n  if (t === 0 || g === 0 || o === 0) {\n    return false;\n  } else {\n    const TO = Number(`${t}${o}`);\n    const GO = Number(`${g}${o}`);\n    const OUT = Number(`${o}${u}${t}`);\n    return TO + GO === OUT;\n  }\n};\n\nsolve(toGoOut);\n```", "```\n❶ const higher = (a, b) => lower(b, a);\n❷ const equal = (a, b) => !lower(a, b) && !higher(a, b);\n```", "```\nconst sinkingSort = (arr, from = 0, to = arr.length - 1) => {\n  for (let j = from; j < to; j++) {\n    for (let i = to - 1; i >= j; i--) {\n      if (arr[i] > arr[i + 1]) {\n        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];\n      }\n    }\n  }\n  return arr;\n};\n```", "```\nconst bubbleSort = (arr, from = 0, to = arr.length - 1) => {\n  for (let j = to; j > from; j--) {\n **let swaps = false;**\n    for (let i = from; i < j; i++) {\n      if (arr[i] > arr[i + 1]) {\n        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];\n **swaps = true;**\n      }\n    }\n **if (!swaps) {**\n **break;**\n **}**\n  }\n  return arr;\n};\n```", "```\nconst insertionSort = (arr, from = 0, to = arr.length - 1) => {\n  if (to > from) {\n    insertionSort(arr, from, to - 1);\n    const temp = arr[to];\n    let j;\n    for (j = to; j > from && arr[j - 1] > temp; j--) {\n      arr[j] = arr[j - 1];\n    }\n    arr[j] = temp;\n  }\n  return arr;\n};\n```", "```\nconst quickSort = (arr, left = 0, right = arr.length - 1) => {\n  if (left < right) {\n    const pivot = arr[right];\n\n    let p = left;\n    for (let j = left; j < right; j++) {\n      if (pivot > arr[j]) {\n        [arr[p], arr[j]] = [arr[j], arr[p]];\n p++;\n      }\n    }\n  ❶ [arr[p], arr[right]] = [arr[right], arr[p]];\n\n  ❷ let pl = p;\n    for (let i = p - 1; i >= left; i--) {\n      if (arr[i] === pivot) {\n        pl--;\n        [arr[i], arr[pl]] = [arr[pl], arr[i]];\n      }\n    }\n\n  ❸ let pr = p;\n    for (let j = p + 1; j <= right; j++) {\n      if (arr[j] === pivot) {\n        pr++;\n        [arr[j], arr[pr]] = [arr[pr], arr[j]];\n      }\n    }\n\n  ❹ quickSort(arr, left, pl – 1);\n    quickSort(arr, pr + 1, right);\n  }\n\n  return arr;\n};\n```", "```\nconst medianOf5 = (a, b, c, d, e) => {\n❶ if (a > b) {\n    [a, b] = [b, a];\n  }\n\n❷ if (c > d) {\n    [c, d] = [d, c];\n  }\n\n❸ if (a > c) {\n    [a, c] = [c, a];\n    [b, d] = [d, b];\n  }\n\n❹ if (b > e) {\n    [b, e] = [e, b];\n  }\n\n❺ if (c > b) {\n   // b < c < d and b < e: b isn't the median, and d isn't either\n   return e > c ? c : e;\n❻} else {\n   return d > b ? b : d;\n  }\n};\n```", "```\nconst swapper = (arr, i, j) => ([arr[i], arr[j]] = [arr[j], arr[i]]);\n\nconst medianOf5 = (arr5) => {\n  if (arr5[0] > arr5[1]) {\n    swapper(arr5, 0, 1);\n  }\n\n  if (arr5[2] > arr5[3]) {\n    swapper(arr5, 2, 3);\n  }\n\n  if (arr5[0] > arr5[2]) {\n    swapper(arr5, 0, 2);\n    swapper(arr5, 1, 3);\n  }\n\n  if (arr5[1] > arr5[4]) {\n    swapper(arr5, 1, 4);\n  }\n\n  if (arr5[2] > arr5[1]) {\n    return arr5[4] > arr5[2] ? 2 : 4;\n  } else {\n    return arr5[3] > arr5[1] ? 1 : 3;\n  }\n};\n```", "```\nconst quickSelect = (arr, k, left = 0, right = arr.length - 1) => {\n❶ **while (left < right) {**\n    const pick = left + Math.floor((right - left) * Math.random());\n    if (pick !== right) {\n      [arr[pick], arr[right]] = [arr[right], arr[pick]];\n    }\n    const pivot = arr[right];\n\n    let p = left;\n    for (let j = left; j < right; j++) {\n      if (pivot > arr[j]) {\n        [arr[p], arr[j]] = [arr[j], arr[p]];\n        p++;\n      }\n    }\n    [arr[p], arr[right]] = [arr[right], arr[p]];\n\n❷ **if (p === k) {**\n **left = right = k;**\n **} else if (p > k) {**\n **right = p - 1;**\n **} else {**\n **left = p + 1;**\n **}**\n **}**\n};\n```", "```\nconst qSelect = (arr, k, left = 0, right = arr.length - 1) => {\n❶ const copy = [...arr];\n❷ quickSelect(copy, k, left, right);\n❸ return copy[k];\n};\n```", "```\n❶ const swapIfNeeded = (arr, i, j) => {\n  if (i !== j) {\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n  }\n};\n\n❷ const medianOf3 = (arr, left, right) => {\n  if (right - left === 2) {\n    const c01 = arr[left] > arr[left + 1];\n    const c12 = arr[left + 1] > arr[left + 2];\n    if (c01 === c12) {\n      return left + 1;\n    } else {\n      const c20 = arr[left + 2] > arr[left];\n      return c20 === c01 ? left : left + 2;\n    }\n  } else {\n    return left;\n  }\n};\n\nconst quickSelect = (arr, k, left = 0, right = arr.length - 1) => {\n  while (left < right) {\n❸ **let rr = right;**\n❹ **while (rr - left >= 3) {**\n **let ll = left - 1;**\n❺ **for (let i = left; i <= rr; i += 3) {**\n **const m3 = medianOf3(arr, i, Math.min(i + 2, rr));**\n **swapIfNeeded(arr, ++ll, m3);**\n **}**\n❻ **rr = ll;**\n **}**\n **const m3 = medianOf3(arr, left, rr);**\n **swapIfNeeded(arr, right, m3);**\n\n    const pivot = arr[right];\n\n    let p = left;\n    for (let j = left; j < right; j++) {\n      if (pivot > arr[j]) {\n        swapIfNeeded(arr, p, j);\n        p++;\n      }\n    }\n    swapIfNeeded(arr, p, right);\n\n    if (p === k) {\n      left = right = p;\n    } else if (p > k) {\n      right = p - 1;\n } else {\n      left = p + 1;\n    }\n  }\n};\n\nconst sicilianSelect = (arr, k, left = 0, right = arr.length - 1) => {\n  quickSelect(arr, k, left, right);\n  return arr[k];\n};\n```", "```\n❶ const logResults = (fn, from = 0, to = 10, n = to, times = 4000) => {\n❷ const bar = (len, val, max) =>\n    \"#\".repeat(Math.round((len * val) / max));\n❸ const result = {};\n  const compare = (a, b) => (a < b ? -1 : 1);\n❹ let max = 0;\n❺ for (let i = 1; i <= times; i++) {\n  ❻ const arr = Array(n)\n      .fill(0)\n      .map((v, i) =>\n        i < from || i > to ? i : String.fromCharCode(65 + i),\n      );\n  ❼ const x = fn(arr, from, to).join(“-”);\n  ❽ result[x] = x in result ? result[x] + 1 : 1;\n  ❾ max = Math.max(max, result[x]);\n  }\n❿ let count = 0;\n  for (const [key, val] of Object.entries(result).sort(compare)) {\n    count++;\n    console.log(\n      `${key}: ${String(val).padStart(5)} ${bar(50, val, max)}`,\n    );\n  }\n  console.log(\"COUNT=\", count);\n};\n```", "```\n❶ const random01 = () => (randomBit() ? 0 : 1);\n\nconst random3 = () => {\n  let num = 0;\n  do {\n  ❷ num = 2 * random01() + random01();\n❸} while (num > 2);\n\n❹ return [\"3-hi\", \"2-md\", \"1-lo\"][num];\n};\n```", "```\nconst randomDie = () => {\n  let num = 0;\n do {\n    num = 4 * random01() + 2 * random01() + random01();\n  } while (num > 5);\n  return num + 1;\n};\n```", "```\n❶ for (let num = 1, fact = 1; fact < fact + 1; num++) {\n  fact *= num;\n  console.log(`${num}=${fact}`);\n}\n```", "```\nfor (let num = 1n, fact = 1n; fact < fact + 1n; num++) {\n  fact *= num;\n  console.log(`${num}=${fact}`);\n}\n```", "```\n❶ const logResults = (fn, k, n = 10, times = 60000, noReps = true) => {\n  const bar = (len, val, max) =>\n    \"#\".repeat(Math.round((len * val) / max));\n\n  const result = {};\n\n  const compare = (a, b) => (a < b ? -1 : 1);\n\n  let max = 0;\n  for (let i = 1; i < times; i++) {\n    const arr = Array(n)\n      .fill(0)\n      .map((v, i) => String.fromCharCode(65 + i));\n\n❷  const x = noReps\n\n      ? fn(arr, k).sort().join(“-”)\n      : fn(arr, k).join(“-”);\n    result[x] = x in result ? result[x] + 1 : 1;\n    max = Math.max(max, result[x]);\n  }\n  let count = 0;\n  for (const [key, val] of Object.entries(result).sort(compare)) {\n    count++;\n    console.log(\n      `${key}: ${String(val).padStart(5)} ${bar(50, val, max)}`,\n    );\n  }\n  console.log(\"COUNT=\", count);\n};\n```", "```\nconst repeatedPick = (arr, k) =>\n  Array(k)\n    .fill(0)\n    .map(() => arr[randomInt(0, arr.length)]);\n```", "```\nconst sortingSample = (arr, k) => {\n❶ const rand = arr.map((v) => ({val: v, key: Math.random()}));\n\n❷ for (let i = 0; i < k; i++) {\n    let m = i;\n    for (let j = i + 1; j < arr.length; j++) {\n      if (rand[m].key > rand[j].key) {\n        m = j;\n      }\n    }\n    if (m !== i) {\n      [rand[i], rand[m]] = [rand[m], rand[i]];\n    }\n  }\n\n❸ return rand.slice(0, k).map((obj) => obj.val);\n};\n```", "```\nconst factorial = (p) => {\n  let result = 1;\n  for (let i=1; i <= p; i++) {\n    result = result * i\n }\n  return result;\n}\n```", "```\nconst checkSearch = (fn, sorted = false) => {\n❶ const data32 = sorted ? require(\"../data_sorted_32\") : require(\"../data32\");\n\n❷ const verify = (v, i, f) => {\n  ❸ if (i !== f) {\n      throw new Error(`Failure searching v=${v} i=${i} fn=${f}`);\n    }\n  ❹ if (i !== -1) {\n      console.log(\"Searching v=\", v, \" i=\", i);\n    }\n  };\n\n❺ data32.forEach((v, i) => {\n    const f = fn([...data32], v);\n    verify(v, i, f);\n  });\n\n❻ const m1 = Math.min(...data32);\n  const m2 = Math.max(...data32);\n❼ for (let i = m1 - 3; i <= m2 + 3; i++) {\n  ❽ if (!data32.includes(i)) {\n    ❾ verify(i, -1, fn([...data32], i));\n    }\n  }\n};\n```", "```\nconst binaryFindFirst = (arr, key, l = 0, r = arr.length - 1) => {\n❶ let result = -1;\n  while (l <= r) {\n    const m = (l + r) >> 1;\n    if (arr[m] === key) {\n    ❷ result = m;\n ❸ r = m – 1;\n    } else if (arr[m] > key) {\n      r = m - 1;\n    } else {\n      l = m + 1;\n    }\n  }\n❹ return result;\n};\n```", "```\nconst rotationFind = (arr) => {\n❶ let l = 0;\n  let r = arr.length - 1;\n❷ while (arr[l] > arr[r]) {\n  ❸ const m = (l + r) >> 1;\n  ❹ if (arr[m] > arr[r]) {\n      l = m + 1;\n  ❺} else {\n      r = m;\n    }\n  }\n❻ return l;\n};\n```", "```\nconst exponentialSearch = (arr, key) => {\n  const n = arr.length;\n❶ let i = 1;\n❷ while (i < n && key > arr[i]) {\n    i = i << 1;\n  }\n❸ return binarySearch(arr, key, i >> 1, Math.min(i, n – 1));\n};\n```", "```\nconst size = (list) => {\n❶ let count = 0;\n❷ for (let ptr = list; ptr !== null; ptr = ptr.next) {\n  ❸ count++;\n  }\n  return count;\n};\n```", "```\nconst find = (list, value) => {\n❶ for (let ptr = list; ptr !== null; ptr = ptr.next) {\n    if (ptr.value === value) {\n    ❷ return true;\n    }\n  }\n❸ return false;\n};\n```", "```\nconst add = (list, position, value) => {\n  if (position === 0) {\n    list = {value, next: list};\n  } else {\n    let ptr;\n    for (\n      ptr = list;\n      ptr.next !== null && position !== 1;\n      ptr = ptr.next\n    ) {\n      position--;\n    }\n    ptr = {value, next: ptr.next};\n  }\n};\n```", "```\nconst remove = (list, position) => {\n  if (!isEmpty(list)) {\n    if (position === 0) {\n      list.first = list.next;\n    } else {\n      let ptr;\n      for (\n        ptr = list;\n        ptr.next !== null && position !== 1;\n        ptr = ptr.next\n      ) {\n        position--;\n      }\n      if (ptr.next !== null) {\n        ptr.next = ptr.next.next;\n      }\n    }\n  }\n  return list;\n};\n```", "```\nconst reverse = (list) => {\n❶ let newList = null;\n❷ while (list !== null) {\n ❸ [list.next, newList, list] = [newList, list, list.next];\n  }\n❹ return newList;\n};\n```", "```\nconst append = (list1, list2) => {\n  if (list1 === null) {\n  ❶ list1 = list2;\n  } else {\n  ❷ let ptr = list1;\n    while (ptr.next !== null) {\n    ❸ ptr = ptr.next;\n    }\n  ❹ ptr.next = list2;\n  }\n  return list1;\n};\n```", "```\nconst hasALoop = (list) => {\n  if (list === null) {\n  ❶ return false;\n  } else {\n  ❷ let ptr1 = list;\n    let ptr2 = list.next;\n\n  ❸ while (ptr2 !== null && ptr2 !== ptr1) {\n    ❹ ptr1 = ptr1.next;\n    ❺ ptr2 = ptr2.next ? ptr2.next.next : null;\n    }\n\n ❻ return ptr2 === ptr1;\n  }\n};\n```", "```\n❶ const newStack = () => [];\n\n❷ const isEmpty = (stack) => stack.length === 0;\n\nconst push = (stack, value) => {\n❸ stack.push(value);\n  return stack;\n};\n\nconst pop = (stack) => {\n❹ if (!isEmpty(stack)) {\n    stack.pop();\n  }\n  return stack;\n};\n❺ const top = (stack) =>   isEmpty(stack) ? undefined : stack[stack.length – 1];\n```", "```\nconst print = (list) => {\n  for (let ptr = list; ptr !== null; ptr = ptr.next) {\n    console.log(ptr.value);\n  }\n};\n```", "```\nconst newStack = () => ({first: null, height: 0});\n```", "```\nconst _radixSort = (arr) => {\n  const ML = Math.max(...arr.map((x) => String(x).length));\n\n  for (let i = 0, div = 1; i < ML; i++, div *= 10) {\n    const buckets = Array(10)\n      .fill(0)\n    ❶ .map(() => ({first: null, last: null}));\n\n    arr.forEach((v) => {\n    ❷ const digit = Math.floor(v / div) % 10;\n    ❸ const newNode = {v, next: null};\n      if (buckets[digit].first === null) {\n        buckets[digit].first = newNode;\n      } else {\n        buckets[digit].last.next = newNode;\n      }\n buckets[digit].last = newNode;\n    });\n\n    arr = [];\n  ❹ buckets.forEach((b) => {\n      for (let ptr = b.first; ptr; ptr = ptr.next) {\n        arr.push(ptr.v);\n      }\n    });\n  }\n\n  return arr;\n};\n```", "```\nconst print = (circ) => {\n❶ if (!isEmpty(circ)) {\n  ❷ let ptr = circ;\n    do {\n    ❸ console.log(ptr.value);\n    ❹ ptr = ptr.next;\n  ❺} while (ptr !== circ);\n  }\n};\n```", "```\n❶ circ2.prev.next = circ1.next;\n❷ circ1.next.prev = circ2.prev;\n❸ circ1.next = circ2;\n❹ circ2.prev = circ1;\n```", "```\nconst find = (list, valueToFind) => {\n  if **(valueToFind < list.value)** {\n    return false;\n  } else if (valueToFind === list.value) {\n return true;\n  } else {\n    // valueToRemove > list.value\n    return find(list.next, valueToFind);\n  }\n};\n```", "```\nconst find = (tree, keyToFind) =>\n  !isEmpty(tree) &&\n  (keyToFind === tree.key ||\n    find(\n      tree[keyToFind < tree.key ? \"left\" : \"right\"],\n      keyToFind,\n    ));\n```", "```\nconst {\n  isEmpty,\n} = require(\"../binary_search_tree.js\");\n\nconst calcSize = (tree) =>\n **isEmpty(tree)**\n **? 0**\n **: 1 + getSize(tree.left) + getSize(tree.right);**\n```", "```\nconst {isEmpty} = require(\"../binary_search_tree.js\");\n\nconst calcHeight = (tree) =>\n  isEmpty(tree)\n    ? 0\n    : **1 + Math.max(getHeight(tree.left), getHeight(tree.right))**;\n```", "```\nconst {newNode, isEmpty} = require(\"../binary_search_tree.js\");\n\nconst makeCopy = (tree) =>\n  isEmpty(tree)\n    ? tree\n    : **newNode(tree.key, makeCopy(tree.left), makeCopy(tree.right))**;\n```", "```\nconst makeCopy2 = (tree) => {\n❶ if (isEmpty(tree)) {\n    return tree;\n  } else {\n  ❷ const newLeft = makeCopy2(tree.left);\n  ❸ const newRight = makeCopy2(tree.right);\n  ❹ return newNode(tree.key, newLeft, newRight);\n  }\n};\n```", "```\nconst evaluate = (tree) => {\n❶ if (!tree) {\n   return 0;\n❷} else if (typeof tree.key === \"number\") {\n   return tree.key;\n❸} else if (tree.key === \"+\") {\n   return evaluate(tree.left) + evaluate(tree.right);\n❹} else if (tree.key === \"-\") {\n   return evaluate(tree.left) - evaluate(tree.right);\n❺} else if (tree.key === \"*\") {\n   return evaluate(tree.left) * evaluate(tree.right);\n❻} else if (tree.key === \"/\") {\n   return evaluate(tree.left) / evaluate(tree.right);\n❼} else {\n   throw new Error(\"Don't know what to do with \", tree.key);\n  }\n};\n```", "```\nconst exampleInBook = {\n  key: \"*\",\n  left: {\n    key: \"+\",\n    left: {key: 2},\n    right: {key: 3}\n  },\n  right: {\n    key: 6\n  }\n};\n```", "```\nconst {isEmpty} = require(\"../binary_search_tree.js\");\n\nconst anyOrder = (tree, order, visit = (x) => console.log(x)) => {\n  if (!isEmpty(tree)) {\n    order === \"PRE\" && visit(tree.key);\n    anyOrder(tree.left, order, visit);\n    order === \"IN\" && visit(tree.key);\n    anyOrder(tree.right, order, visit);\n    order === \"POST\" && visit(tree.key);\n  }\n};\n```", "```\nconst anyOrder = (tree, order, visit = (x) => console.log(x)) => {\n  let pending = newStack();\n  let type = \"\";\n❶ pending = push(pending, {tree, type: \"T\"});\n\n❷ while (!isEmptyStack(pending)) {\n  ❸ [pending, {tree, type}] = pop(pending);\n\n  ❹ if (!isEmptyTree(tree)) {\n    ❺ if (type === \"K\") {\n visit(tree.key);\n    ❻} else {\n       if (order === \"POST\") {\n       pending = push(pending, {tree, type: \"K\"});\n       }\n       pending = push(pending, {tree: tree.right, type: \"T\"});\n       if (order === \"IN\") {\n         pending = push(pending, {tree, type: \"K\"});\n       }\n       pending = push(pending, {tree: tree.left, type: \"T\"});\n       if (order === \"PRE\") {\n         pending = push(pending, {tree, type: \"K\"});\n        }\n      }\n    }\n  }\n};\n```", "```\nconst add = (tree, keyToAdd) => {\n  if (isEmpty(tree)) {\n    return newNode(keyToAdd);\n ❶**} else if (keyToAdd === tree.key) {**\n **throw new Error(\"No duplicate keys allowed\");**\n  } else {\n  ❷ const side = keyToAdd < tree.key ? \"left\" : \"right\";\n    tree[side] = add(tree[side], keyToAdd);\n    return tree;\n  }\n};\n```", "```\nconst _removeMinFromTree = (tree) => {// not empty tree assumed\n  if (isEmpty(tree.left)) {\n  ❶ return [tree.right, tree.key];\n  } else {\n    let min;\n  ❷ [tree.left, min] = _removeMin(tree.left);\n  ❸ return [tree, min];\n  }\n};\n```", "```\nconst remove = (tree, keyToRemove) => {\n  if (isEmpty(tree)) {\n    // nothing to do\n  } else if (keyToRemove < tree.key) {\n    tree.left = remove(tree.left, keyToRemove);\n  } else if (keyToRemove > tree.key) {\n    tree.right = remove(tree.right, keyToRemove);\n  } else if (isEmpty(tree.left) && isEmpty(tree.right)) {\n    tree = null;\n  } else if (isEmpty(tree.left)) {\n    tree = tree.right;\n  } else if (isEmpty(tree.right)) {\n    tree = tree.left;\n  } else {\n    **[tree.right, tree.key] = _removeMin(tree.right);**\n  }\n  return tree;\n};\n```", "```\n❶ const _splay = (tree**, keyToUp**) => {\n❷ if (isEmpty(tree) **|| keyToUp === tree.key**) {\n    return tree;\n  } else {\n  ❸ const side = **keyToUp < tree.key ?** \"left\" **: \"right\"**;\n    if (isEmpty(tree[side])) {\n     return tree;\n  ❹**} else if (keyToUp === tree[side].key) {**\n **return _rotate(tree, side);**\n   } else {\n❺ **if (keyToUp <= tree[side].key === keyToUp <= tree.key) {**\n     ❻ tree[side][side] = _splay(tree[side][side]**, keyToUp**);\n       tree = _rotate(tree, side);\n❼**} else {**\n **const other = side === \"left\" ? \"right\" : \"left\";**\n **tree[side][other] = _splay(tree[side][other], keyToUp);**\n **if (!isEmpty(tree[side][other])) {**\n **tree[side] = _rotate(tree[side], other);**\n **}**\n **}**\n    return isEmpty(tree[side]) ? tree : _rotate(tree, side);\n   }\n }\n};\n```", "```\nconst _splayMin = (tree) => {\n  if (isEmpty(tree)) {\n    return tree;\n  } else {\n    if (isEmpty(tree.left)) {\n      return tree;\n } else {\n      tree.left.left = _splayMin(tree.left.left);\n      tree = _rotate(tree, \"left\");\n      return isEmpty(tree.left) ? tree : _rotate(tree, \"left\");\n    }\n  }\n};\n```", "```\nconst {\n  newBinaryTree,\n  newNode,\n  inOrder\n} = require(\"../binary_search_tree.js\");\n\n❶ const _buildPerfect = (keys) => {\n❷ if (keys.length === 0) {\n    return newBinaryTree();\n❸} else {\n  ❹ const m = Math.floor(keys.length / 2);\n  ❺ return newNode(\n      keys[m],\n      _buildPerfect(keys.slice(0, m)),\n      _buildPerfect(keys.slice(m + 1))\n    );\n  }\n};\n\n❻ const restructure = (tree) => {\n❼ const keys = [];\n  inOrder(tree, (x) => keys.push(x));\n❽ return _buildPerfect(keys);\n};\n```", "```\ndepthFirstNonRecursive(visit = (x) => console.log(x)) {\n❶ if (!isEmptyTree(tree)) {\n  ❷ const s = new Stack();\n    s = push(s, tree);\n  ❸ while (isEmptyStack(s)) {**DZ missing ! operator**\n      let t;\n    ❹ [s, t] = s.pop();\n      visit(t.key);\n    ❺ [...t.childNodes].reverse().forEach((v) => {s = push(s, v);});\n    }\n  }\n}\n```", "```\nconst {Tree} = require(\"../tree.class.js\");\n\nclass TreeWithMeasuring extends Tree {\n  calcSize() {\n    return this.isEmpty()\n ❶ ? 0\n    ❷ : 1 + this._children.reduce((a, v) => a + v.calcSize(), 0);\n  }\n\n  calcHeight() {\n    if (this.isEmpty()) {\n    ❸ return 0;\n    } else if (this._children.length === 0) {\n    ❹ return 1;\n    } else {\n    ❺ return 1 + Math.max(...this._children.map((v) => v.calcHeight()));\n    }\n  }\n}\n```", "```\nconst _findIndex = (tree, key) => {\n  let l = 0;\n  let r = tree.keys.length - 1;\n\n  while (l <= r) {\n    const m = Math.floor((l + r) / 2);\n    if (tree.keys[m] === key) {\n      return m;\n    } else if (tree.keys[m] > key) {\n      r = m - 1;\n    } else {\n      l = m + 1;\n    }\n  }\n **return l;**\n};\n```", "```\nfunction isHeap1(v) {\n  for (let i = 1; i < v.length; i++) {\n    if (v[i] > v[Math.floor((i - 1) / 2)]) {\n      return false;\n    }\n  }\n  return true;\n}\n```", "```\nfunction isHeap2(heap) {\n  return heap.every(    (v, i) => i === 0 || v <= heap[Math.floor((i - 1) / 2)],\n  );\n```", "```\nfunction merge_away(lists) {\n  const heap = [];\n\n  const add = (node) => {\n    const _bubbleUp = (i) => {\n      // Bubble up heap[i] comparing by heap[i].key\n      // (you'll have to modify the bubbling code we\n      // saw a bit for this).\n    };\n\n  ❶ if (node) {\n      heap.push(node);\n      _bubbleUp(heap.length - 1);\n    }\n\n    const remove = () => {\n      const _sinkDown = (i, h) => {\n        // sink down heap[i] comparing by heap[i].key\n };\n    };\n\n    const node = heap[0];\n    heap[0] = heap[heap.length - 1];\n    heap.pop();\n    _sinkDown(0, heap.length);\n    return node;\n  };\n\n❷ lists.forEach((list) => add(list));\n❸ const first = {next: null};\n  let last = first;\n❹ while (heap.length > 0) {\n    const node = remove();\n  ❺ add(node.next);\n  ❻ last.next = node;\n    last = node;\n    node.next = null;\n  }\n❼ return first.next;\n}\n```", "```\nconst list1 = {\n  key: 2,\n  next: {key: 3, next: {key: 8, next: null}},\n};\n\nconst list2 = {\n  key: 1,\n  next: {key: 13, next: {key: 55, next: null}},\n};\n\nconst list3 = null;\n\nconst list4 = {key: 21, next: null};\n\nconst list5 = {key: 5, next: {key: 34, next: null}};\n\nconst merged = merge_away([list1, list2, list3, list4, list5]);\n\nlet p = merged;\nwhile (p) {\n  console.log(p.key);\n  p = p.next;\n}\n```", "```\nconst removeMiddle = (heap, k) => {\n❶ if (isEmpty(heap)) {\n    throw new Error(\"Empty heap; cannot remove\");\n❷} else if (k < 0 || k >= heap.length) {\n    throw new Error(\"Not valid argument for removeMiddle\");\n  } else {\n  ❸ [heap[k], heap[heap.length - 1]] = [heap[heap.length - 1], heap[k]];\n    heap.pop();\n  ❹ _bubbleUp(heap, k);\n  ❺ _sinkDown(heap, k, heap.length);\n  }\n  return heap;\n};\n```", "```\nconst newHeap = (values = []) => {\n  const newH = [];\n❶ values.forEach((v) => newH.push(v));\n  for (let i = Math.floor((newH.length - 1) / 2); i >= 0; i--) {\n  ❷ _sinkDown(newH, i, newH.length);\n  }\n  return newH;\n};\n```", "```\nv.forEach((_, i) => _bubbleUp(v, i));\n```", "```\nfunction selection(k, values) {\n  const heap = [];\n\n  const _sinkDown = // ...omitted here...\n\n  // Build heap out of values.\n  values.forEach((v) => heap.push(v));\n  for (let i = Math.floor((heap.length - 1) / 2); i >= 0; i--) {\n    _sinkDown(i, heap.length);\n  }\n\n  // Trim the heap, if possible.\n **const maxPlace = 2 ** k - 1;**\n **if (heap.length > maxPlace) {**\n❶ **heap.length = maxPlace;**\n **}**\n\n  // Do the selection.\n  for (let i = heap.length - 1; i >= heap.length - k; i--) {\n    [heap[i], heap[0]] = [heap[0], heap[i]];\n _sinkDown(0, i);\n  }\n\n  return heap.slice(heap.length - k);\n}\n```", "```\nfunction isTreap(tr, valid = () => true) {\n  return (\n    tr === null ||\n  ❶ (valid(tr) &&\n    ❷ isTreap(\n        tr.left,\n        (t) => t.key <= tr.key && t.priority <= tr.priority,\n      ) &&\n    ❸ isTreap(\n        tr.right,\n        (t) => t.key >= tr.key && t.priority <= tr.priority,\n      ))\n  );\n}\n```", "```\nconst merge = (heap1, heap2) => {\n  if (isEmpty(heap2)) {\n    return heap1;\n  } else if (isEmpty(heap1)) {\n    return heap2;\n  } else if (goesHigher(heap1.key, heap2.key)) {\n    [heap1.left, heap1.right] = [merge(heap2, heap1.right), heap1.left];\n    return heap1;\n  } else {\n **[heap2.left, heap2.right] = [merge(heap1, heap2.right), heap2.left];**\n **return heap2;**\n }\n};\n```", "```\n❶ _findInTree(tree, keyToFind, stopT = null) {\n❷ let node = null;\n❸ if (tree && tree !== stopT) {\n  ❹ if (tree.key === keyToFind) {\n      node = tree;\n    } else {\n      node =\n      ❺ this._findInTree(tree.down, keyToFind) ||\n      ❻ this._findInTree(tree.right, keyToFind, stopT || tree);\n    }\n  }\n❼ return node;\n}\n```", "```\nif (high._down) {\n  low.right = high.down;\n  low.left = high.down.left;\n  **high.down.left.right = high.down.left** = low;\n}\n```", "```\n**newTree.left = newTree.right** = newTree;\n```", "```\n**bt.right = bt.left** = bt;\n```", "```\n**node.left = node.right** = node;\n```", "```\nconst newNode = () => **({links: new Map()})**;\n```", "```\nconst _find = (trie, [first, . . .rest]) => {\n  if (isEmpty(trie)) {\n    return null;\n  } else if (first === EOW) {\n    return isEmpty(trie.links.get(first))\n      ? null\n      : trie.links.get(first).data;\n  } else {\n    return _find(**trie.links.get(first)**, rest);\n  }\n};\n```", "```\nconst _add = (trie, [first, . . .rest], data) => {\n  if (first) {\n    if (isEmpty(trie)) {\n      trie = newNode();\n    }\n    if (first === EOW) {\n      **trie.links.set(first, {data})**;\n    } else {\n      **trie.links.set(first, _add(trie.links.get(first)**, rest, data));\n    }\n  }\n  return trie;\n};\n```", "```\nconst _remove = (trie, [first, . . .rest]) => {\n  if (isEmpty(trie)) {\n    // nothing to do\n  } else if (!first) {\n    trie = null;\n  } else {\n    **trie.links.set(first**, _remove(**trie.links.get(first)**, rest));\n    if (isEmpty(**trie.links.get(first))**) {\n      **trie.links.delete(first)**;\n      if (**trie.links.size** === 0) {\n        trie = null;\n      }\n    }\n  }\n  return trie;\n};\n```", "```\nconst distances = (graph) => {\n  const n = graph.length;\n\n  const distance = [];\n❶ const next = [];\n  for (let i = 0; i < n; i++) {\n    distance[i] = Array(n).fill(+Infinity);\n  ❷ next[i] = Array(n).fill(null);\n  }\n\n  graph.forEach((r, i) => {\n    distance[i][i] = 0;\n  ❸ next[i][i] = i;\n    r.forEach((c, j) => {\n      if (c > 0) {\n        distance[i][j] = graph[i][j];\n      ❹ next[i][j] = j;\n      }\n    });\n  });\n\n  for (let k = 0; k < n; k++) {\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < n; j++) {\n        ❺ if (distance[i][j] > distance[i][k] + distance[k][j]) {\n          distance[i][j] = distance[i][k] + distance[k][j];\n          next[i][j] = next[i][k];\n        }\n      }\n    }\n  }\n\n❻ return [distance, next];\n};\n```", "```\nconst path = (next, u, v) => {\n❶ const sequence = [];\n❷ if (next[u][v] !== null) {\n  ❸ sequence.push(u);\n  ❹ while (u !== v) {\n     ❺ u = next[u][v];\n     ❻ sequence.push(u);\n    }\n  }\n❼ return sequence;\n};\n```", "```\nfor (let i = 0; i < n - 1; i++) {\n❶ let changes = false;\n  edges.forEach((v) => {\n    const w = v.dist;\n    if (distance[v.from] + w < distance[v.to]) {\n      distance[v.to] = distance[v.from] + w;\n      previous[v.to] = v.from;\n    ❷ changes = true;\n    }\n  });\n❸ if (!changes) {\n    break;\n  }\n}\n```", "```\nwhile (heap.length **&& heap[0] !== to**) {\n```", "```\nconst groups = Array(n)\n  .fill(0)\n  .map(() => ({ptr: null, **size: 1**}));\n```", "```\nfor (let i = 0; i < n; i++) {\n  for (let j = i + 1; j < n; j++) {\n    if (graph[i][j]) {\n      const pf = findParent(groups[i]);\n      const pt = findParent(groups[j]);\n\n      if (pf !== pt) {\n        count--;\n **if (pf.size < pt.size) {**\n **pt.size += pf.size;**\n **pf.ptr = pt;**\n **} else {**\n **pf.size += pt.size;**\n **pt.ptr = pf;**\n **}**\n      }\n    }\n  }\n}\n```", "```\nconst findParent = (x) => {\n  if (x.ptr !== null) {\n    x.ptr = findParent(x.ptr);\n    return x.ptr;\n  } else {\n    return x;\n  }\n};\n```", "```\nconst front = (queue) => {\n❶ if (isEmpty(queue)) {\n    return undefined;\n❷} else if (queue.frontPart !== null) {\n    return queue.frontPart.value;\n❸} else {\n    let ptr = queue.backPart;\n    while (ptr.next !== null) {\n      ptr = ptr.next;\n    }\n    return ptr.value;\n  }\n};\n```", "```\nconst minKey = (tree) =>   isEmpty(tree.left) ? tree.key : minKey(tree.left);\n```"]