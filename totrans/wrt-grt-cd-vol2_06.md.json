["```\n\n\t\t\ti = 1000\n\nmov( 1000, i );\n```", "```\n\n\t\t\toneThousand = 1000\n    .\n    .\n    .\nx = x + oneThousand 'Using \"oneThousand\" rather than\n                    ' a literal constant.\ny = y + 1000        'Using a literal constant.\n```", "```\n\n\t\t\tmov( oneThousand, eax ); // x = x + oneThousand\nadd( eax, x );\n```", "```\nadd( 1000, y ); // y = y + 1000\n```", "```\n\n\t\t\t#include <stdlib.h>\n#include <stdio.h>\nint main( int argc, char **argv, char **envp )\n{\n  int i,j,k;\n\n  i = 1;\n  j = 16000;\n  k = 100000;\n  printf( \"%d, %d, %d\\n\", i, j, k );\n\n}\n```", "```\n\n\t\t\tL1$pb:\n    mflr r31\n    stw r3,120(r30)\n    stw r4,124(r30)\n    stw r5,128(r30)\n\n; The following two instructions copy the value 1 into the variable \"i\"\n\n    li r0,1\n    stw r0,64(r30)\n\n; The following two instructions copy the value 16,000 into the variable \"j\"\n\n    li r0,16000\n    stw r0,68(r30)\n\n; It takes three instructions to copy the value 100,000 into variable \"k\"\n\n    lis r0,0x1\n    ori r0,r0,34464\n    stw r0,72(r30)\n\n; The following code sets up and calls the printf function:\n\n    addis r3,r31,ha16(LC0-L1$pb)\n    la r3,lo16(LC0-L1$pb)(r3)\n    lwz r4,64(r30)\n    lwz r5,68(r30)\n    lwz r6,72(r30)\n    bl L_printf$stub\n    mr r3,r0\n    lwz r1,0(r1)\n    lwz r0,8(r1)\n    mtlr r0\n    lmw r30,-8(r1)\n    blr\n```", "```\n\n\t\t\t.LC0:\n    .ascii  \"i=%d, j=%d, k=%d\\012\\000\"\n    .text\n    .align  2\n    .global main\n    .type   main, %function\nmain:\n    @ args = 0, pretend = 0, frame = 24\n    @ frame_needed = 1, uses_anonymous_args = 0\n    stmfd   sp!, {fp, lr}\n    add fp, sp, #4\n    sub sp, sp, #24\n    str r0, [fp, #-24]\n    str r1, [fp, #-28]\n\n; Store 1 into 'i' variable:\n\n    mov r3, #1\n    str r3, [fp, #-8]\n@ Store 16000 into 'j' variable:\n\n    mov r3, #16000\n    str r3, [fp, #-12]\n\n@ Store 100,000 (constant appears in memory) into 'k' variable:\n\n    ldr r3, .L3\n    str r3, [fp, #-16]\n\n@ Fetch the values and print them:\n\n    ldr r0, .L3+4\n    ldr r1, [fp, #-8]\n    ldr r2, [fp, #-12]\n    ldr r3, [fp, #-16]\n    bl  printf\n    mov r3, #0\n    mov r0, r3\n    sub sp, fp, #4\n    @ sp needed\n    ldmfd   sp!, {fp, pc}\n.L4:\n\n@ constant value for k appears in memory:\n\n    .align  2\n.L3:\n    .word    100000\n    .word   .LC0\n```", "```\n\n\t\t\tadd( 5, ebx );\nadd( 500_000, ebx );\n```", "```\n\n\t\t\tconst someConstant:integer = 5;\n```", "```\n\n\t\t\tconst\n    maxIndex = 9;\n\nvar\n    a :array[0..maxIndex] of integer;\n        .\n        .\n        .\n    for i := 0 to maxIndex do\n        a[i] := 0;\n```", "```\n\n\t\t\t#define smArraySize 128\n#define bigArraySize (smArraySize*8)\n      .\n      .\n      .\nchar name[ smArraySize ];\nint  values[ bigArraySize ];\n```", "```\n\n\t\t\tchar name[ 128 ];\nint  values[ (smArraySize * 8) ];\n```", "```\n\n\t\t\tchar name[ 128 ];\nint  values[ (128 * 8) ];\n```", "```\n\n\t\t\tvar\n    i   :integer;\n            .\n            .\n            .\n    i := j + (5*2-3);\n```", "```\ni := j + 7;\n```", "```\n\n\t\t\t#include <stdio.h>\nint main( int argc, char **argv, char **envp )\n{\n  int j;\n\n  j = argc+2*5+1;\n  printf( \"%d %d\\n\", j, argc );\n}\n```", "```\n\n\t\t\t_main:\n    mflr r0\n    mr r4,r3            // Register r3 holds the ARGC value upon entry\n    bcl 20,31,L1$pb\nL1$pb:\n    mr r5,r4            // R5 now contains the ARGC value.\n    mflr r10\n    addi r4,r4,11       // R4 contains argc+ 2*5+1\n                        // (i.e., argc+11)\n    mtlr r0             // Code that calls the printf function.\n    addis r3,r10,ha16(LC0-L1$pb)\n    la r3,lo16(LC0-L1$pb)(r3)\n    b L_printf$stub\n```", "```\n\n\t\t\tconst int arraySize = 128;\n      .\n      .\n      .\nint anArray[ arraySize ];\n```", "```\n\n\t\t\tconst int arraySizes[2] = {128,256}; // This is legal\nconst int arraySize = arraySizes[0]; // This is also legal\n\nint array[ arraySize ]; // This is not legal\n```", "```\n\n\t\t\tlet someConstant = 5\n```", "```\n\n\t\t\t/*\n   Define a set of symbols representing the\n   different display technologies\n*/\n\n#define crt 0\n#define lcd (crt+1)\n#define led (lcd+1)\n#define plasma (led+1)\n```", "```\n\n\t\t\tenum displays {crt, lcd, led, plasma, oled };       // C++\ntype displays = (crt, lcd, led, plasma, oled );     // Pascal\ntype displays :enum{crt, lcd, led, plasma, oled };  // HLA\n// Swift example:\nenum Displays\n{\n    case crt\n    case lcd\n    case led\n    case plasma\n    case oled\n}\n```", "```\ncrt < lcd < led < plasma < oled\n```", "```\n\n\t\t\ttype\n    colors = (red, green, blue);\n    fasteners = (bolt, nut, screw, rivet );\n```", "```\n\n\t\t\ttype\n    boolean = (false, true);\n```", "```\n\n\t\t\tint i, j, k;\n      .\n      .\n      .\n    i = j && k;\n```", "```\n\n\t\t\t; Line 8\n        cmp     DWORD PTR j$[rsp], 0\n        je      SHORT $LN3@main\n        cmp     DWORD PTR k$[rsp], 0\n        je      SHORT $LN3@main\n        mov     DWORD PTR tv74[rsp], 1\n        jmp     SHORT $LN4@main\n$LN3@main:\n        mov     DWORD PTR tv74[rsp], 0\n$LN4@main:\n        mov     eax, DWORD PTR tv74[rsp]\n        mov     DWORD PTR i$[rsp], eax\n;\n```", "```\ni = j & k;  /* Notice the bitwise AND operator */\n```", "```\n\n\t\t\t; Line 8\n        mov     eax, DWORD PTR k$[rsp]\n        mov     ecx, DWORD PTR j$[rsp]\n        and     ecx, eax\n        mov     DWORD PTR i$[rsp], ecx\n```", "```\ni = ~j & 1; /* \"~\" is C's bitwise not operator */\n```", "```\n\n\t\t\t#include <stdlib.h>\n#include <stdio.h>\nint main( int argc, char **argv, char **envp )\n{\n  static int j;\n  static double i = 1.0;\n  static double a[8] = {0,1,2,3,4,5,6,7};\n  j = 0;\n  a[j] = i+1.0;\n\n}\n```", "```\n\n\t\t\t.lcomm _j.0,4,2\n.data\n// This is the variable i.\n// As it is a static object, GCC emits the data directly\n// for the variable in memory. Note that \"1072693248\" is\n// the HO 32-bits of the double-precision floating-point\n// value 1.0, 0 is the LO 32-bits of this value (in integer\n// form).\n\n    .align 3\n_i.1:\n    .long       1072693248\n    .long       0\n\n// Here is the \"a\" array. Each pair of double words below\n// holds one element of the array. The funny integer values\n// are the integer (bitwise) representation of the values\n// 0.0, 1.0, 2.0, 3.0, ..., 7.0.\n\n    .align 3\n_a.2:\n    .long       0\n    .long       0\n    .long       1072693248\n    .long       0\n    .long       1073741824\n    .long       0\n    .long       1074266112\n    .long       0\n    .long       1074790400\n    .long       0\n    .long       1075052544\n    .long       0\n    .long       1075314688\n    .long       0\n    .long       1075576832\n    .long       0\n\n// The following is a memory location that GCC uses to represent\n// the literal constant 1.0\\. Note that these 64 bits match the\n// same value as a[1] in the _a.2 array. GCC uses this memory\n// location whenever it needs the constant 1.0 in the program.\n\n.literal8\n    .align 3\nLC0:\n    .long       1072693248\n    .long       0\n\n// Here's the start of the main program:\n\n.text\n    .align 2\n    .globl _main\n_main:\n\n// This code sets up the static pointer register (R10), used to\n// access the static variables in this program.\n\n    mflr r0\n    bcl 20,31,L1$pb\nL1$pb:\n    mflr r10\n    mtlr r0\n\n    // Load floating-point register F13 with the value\n    // in variable \"i\":\n\n    addis r9,r10,ha16(_i.1-L1$pb)  // Point R9 at i\n    li r0,0\n    lfd f13,lo16(_i.1-L1$pb)(r9)   // Load F13 with i's value.\n\n    // Load floating-point register F0 with the constant 1.0\n    // (which is held in \"variable\" LC0:\n\n    addis r9,r10,ha16(LC0-L1$pb)   // Load R9 with the\n                                   //  address of LC0\n    lfd f0,lo16(LC0-L1$pb)(r9)     // Load F0 with the value\n                                   //  of LC0 (1.0).\n\n    addis r9,r10,ha16(_j.0-L1$pb)  // Load R9 with j's address\n    stw r0,lo16(_j.0-L1$pb)(r9)    // Store a zero into j.\n\n    addis r9,r10,ha16(_a.2-L1$pb)  // Load a[j]'s address into R9\n\n    fadd f13,f13,f0                // Compute i+1.0\n\n    stfd f13,lo16(_a.2-L1$pb)(r9)  // Store sum into a[j]\n    blr                            // Return to caller\n```", "```\n\n\t\t\tprogram main;\nstatic\n    j:int32;\n    i:real64 := 1.0;\n    a:real64[8] := [0,1,2,3,4,5,6,7];\n\nreadonly\n    OnePointZero : real64 := 1.0;\n\nbegin main;\n\n    mov( 0, j );  // j=0;\n\n    // push i onto the floating-point stack\n fld( i );\n\n    // push the value 1.0 onto the floating-point stack\n\n    fld( OnePointZero );\n\n    // pop i and 1.0, add them, push sum onto the FP stack\n\n    fadd();\n\n    // use j as an index\n\n    mov( j, ebx );\n\n    // Pop item off FP stack and store into a[j].\n\n    fstp( a[ ebx*8 ] );\n\nend main;\n```", "```\n\n\t\t\t#include <stdlib.h>\n#include <stdio.h>\nint main( int argc, char **argv, char **envp )\n{\n\n  static float i;\n\n  i = 1.0;\n\n}\n```", "```\n\n\t\t\t.lcomm _i.0,4,2 // Allocate storage for float variable i\n\n.text\n    .align 2\n    .globl _main\n_main:\n\n    // Set up the static data pointer in R10:\n\n    mflr r0\n    bcl 20,31,L1$pb\nL1$pb:\n    mflr r10\n    mtlr r0\n\n    // Load the address of i into R9:\n\n    addis r9,r10,ha16(_i.0-L1$pb)\n\n    // Load R0 with the floating-point representation of 1.0\n    // (note that 1.0 is equal to 0x3f800000):\n\n    lis r0,0x3f80 // Puts 0x3f80 in HO 16 bits, 0 in LO bits\n\n    // Store 1.0 into variable i:\n\n    stw r0,lo16(_i.0-L1$pb)(r9)\n\n    // Return to whomever called this code:\n\n    blr\n```", "```\n\n\t\t\tprogram main;\nstatic\n    i:real32;\nbegin main;\n\n    mov( $3f800_0000, i ); // i = 1.0;\n\nend main;\n```", "```\n\n\t\t\t#include <stdlib.h>\n#include <stdio.h>\n\nstatic double OnePointZero_c = 1.0;\n\nint main( int argc, char **argv, char **envp )\n{\n  static double i;\n\n  i = OnePointZero_c;\n}\n```", "```\n\n\t\t\t#define strConst \"A string constant\"\n        .\n        .\n        .\n    printf( \"string: %s\\n\", strConst );\n        .\n        .\n        .\n    sptr = strConst;\n        .\n        .\n        .\n    result = strcmp( s, strConst );\n        .\n        .\n        .\n```", "```\n\n\t\t\t    .\n    .\n    .\nprintf( \"string: %s\\n\", \"A string constant\" );\n    .\n    .\n    .\nsptr = \"A string constant\";\n    .\n    .\n    .\nresult = strcmp( s, \"A string constant\" );\n```", "```\n\n\t\t\tsptr = \"A String Constant\";\n    .\n    .\n    .\n*(sptr+2) = 's';\n    .\n    .\n    .\n/* The following displays \"string: 'a string Constant'\" */\n\nprintf( \"string: '%s'\\n\", sptr );\n    .\n    .\n    .\n/* This prints \"a string Constant\"! */\n\nprintf( \"A String Constant\" );\n```", "```\n\n\t\t\tsptr1 = \"A String Constant\";\nsptr2 = \"A String Constant\";\ns1EQs2 = sptr1 == sptr2;\n```", "```\n\n\t\t\tchar strconst[] = \"A String Constant\";\n        .\n        .\n        .\n    sptr = strconst;\n        .\n        .\n        .\n    printf( strconst );\n        .\n        .\n        .\n    if( strcmp( string, strconst ) == 0 )\n    {\n        .\n        .\n        .\n    }\n```", "```\nstatic int arrayOfInts[8] = {1,2,3,4,5,6,7,8};\n```", "```\n\n\t\t\tLC0:          // LC0 is the internal label associated\n              //  with arrayOfInts\n    .long       1\n    .long       2\n    .long       3\n    .long       4\n    .long       5\n    .long       6\n    .long       7\n    .long       8\n```", "```\n\n\t\t\tint f()\n{\n  int arrayOfInts[8] = {1,2,3,4,5,6,7,8};\n    .\n    .\n    .\n} // end f\n```", "```\n\n\t\t\tint f()\n{\n  static int arrayOfInts[8] = {1,2,3,4,5,6,7,8};\n    .\n    .\n    .\n} // end f\n```", "```\n\n\t\t\tconst\n    ary: array[0..7] of integer = (1,2,3,4,5,6,7,8);\n```", "```\n\n\t\t\tlet someArray = [1,2,3,4,11,12,13,14]\n```"]