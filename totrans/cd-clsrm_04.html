<html><head></head><body>
<div>&#13;
<header>&#13;
<h1 class="ChapterStart"><a id="_idTextAnchor053"/>4</h1>&#13;
<h1 class="ChapterTitle"><a id="_idTextAnchor054"/>Computational Thinking Gamified and Unplugged</h1>&#13;
</header>&#13;
<p class="ChapterIntroFirst">In this chapter, we’ll look at some of the more discrete elements of computer programs. This information includes coding concepts, such as variables; control structures; functions; and computational thinking concepts, such as algorithms, modeling, and abstraction.</p>&#13;
<p class="ChapterIntroNext">A common lament among K–8 teachers now tasked with teaching computer science concepts in addition to their other subjects is that they don’t know how to teach these seemingly technical concepts. But as we’ll see, they’re concepts we’re already using in our daily lives. Recognizing that fact turns each concept into a tool we can integrate with existing classroom topics to enhance our teaching practice.</p>&#13;
<p class="Body">Throughout this chapter, you’ll learn about ways to teach these concepts in class without the use of computers. Computers are powerful tools for learning, but they’re also isolating: students quietly turn away from each other while they’re plugged into screens that put them through rote learning exercises. There is a time and place for such deep, sustained focus. But here you’ll learn about group activities, games, and creative projects that will exercise your students’ computational thinking muscles without screen time.</p>&#13;
<h2 class="HeadA"><a id="_idTextAnchor055"/>Variables</h2>&#13;
<p class="BodyFirst">Let’s begin with the most elementary programming unit, the <em class="EmphasisItalic">variable</em>, a label—preferably one intuitive to other humans—that identifies a piece of data. As we learned in the previous chapter, in low-level programming languages, variables are coupled to specific storage locations in the computer. In high-level programming languages, we don’t need to worry about memory allocation; instead, we only need to understand a variable as a name identifier given to a piece of information known as its <em class="EmphasisItalic">value</em>. Variables can point to different kinds of data as values, such as integers, strings, Booleans, and lists; because variables don’t actually hold data, but rather point to a location in the computer’s memory, we can reuse a single variable throughout a software application.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="feature1">&#13;
<h2 class="BoxHead">Math Variables and Programming Variables</h2>&#13;
<p class="BoxBodyFirst">Your students might be familiar with variables from their math classes. But the way variables are applied in mathematics is very different from how they’re used in programming. Consider the statement in Listing 4-1.</p>&#13;
<pre>x = 2 + 2</pre>&#13;
<p class="BoxListing">Listing 4-1: A statement found in algebra and in programming</p>&#13;
<p class="BoxBody">In algebra, this statement means that x equals 4. It’s a statement of fact. In programming, this statement means we’re assigning the value 4 to x. It’s a statement of process. To understand this difference, determine whether the statements in Listing 4-2 are possible in algebra.</p>&#13;
<pre>x = 2 + 2 &#13;
x = 5&#13;
</pre>&#13;
<p class="BoxListing">Listing 4-2: Two statements found together only in programming</p>&#13;
<p class="BoxBodyLast">In algebra, x can’t equal both 4 and 5; therefore, the statement is invalid. But in programming, we’re first assigning the value 4 to x and then assigning it a new value of 5. Making your students aware of this important difference when discussing the concept of variables between the two subjects might help prevent confusion when they’re working with them.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside><p class="Body">A popular way to explain variables to students with a real-world example is to have them think of each variable in a program as a container in a series of named containers, such as labeled folders in a filing cabinet. To see this concept in action, try taking your students to the library. The shelves are like memory in a computer, and each one can only hold so many books or so much data. The labels are like the memory addresses in the computer. What is the book variable value for the address <span class="Literal _idGenCharOverride-1">343.73099 Les</span>? <span class="Literal _idGenCharOverride-1">793.93 Coo</span>? With a little forethought, you can construct a fun adventure using the Dewey Decimal System classifications, pretending they’re memory addresses in a huge computer that is the library. </p>&#13;
<p class="Body">As their name suggests, a key feature of variables is that their contents can vary. For example, a string variable named <span class="Literal _idGenCharOverride-1">currentPresidentOfTheUnitedStates</span> might at one time contain the value <span class="Literal _idGenCharOverride-1">George Washington</span> and later contain the value <span class="Literal _idGenCharOverride-1">Abraham Lincoln</span>. An integer variable named <span class="Literal _idGenCharOverride-1">currentYear</span> might increment by one each time the date equals the first second of January 1. A Boolean variable named <span class="Literal _idGenCharOverride-1">stopLightGreen</span> will switch between true and false as the light changes.</p>&#13;
<p class="Body">Variables can also point to lists of values. Many programming languages allow you to store an <em class="EmphasisItalic">array</em>, or list of items, in a variable. Think of an array as a list of variables where each variable is identified by its location in the array. For example, the array of <span class="Literal _idGenCharOverride-1">foodGroups[]</span> might contain [<span class="Literal _idGenCharOverride-1">'vegetables'</span>, <span class="Literal _idGenCharOverride-1">'fruits'</span>, <span class="Literal _idGenCharOverride-1">'grains'</span>, <span class="Literal _idGenCharOverride-1">'meats'</span>, <span class="Literal _idGenCharOverride-1">'dairy'</span>]. The first element in an array is identified with a 0 instead of a 1—a fact that often trips up novice programmers and leads to many software bugs. So when we reference <span class="Literal _idGenCharOverride-1">foodGroups[0]</span>, we get <span class="Literal _idGenCharOverride-1">vegetables</span>, and <span class="Literal _idGenCharOverride-1">foodGroups[4]</span> would return <span class="Literal _idGenCharOverride-1">dairy</span>. We can also have arrays of arrays, making them more complex. Table 4-1 shows a possible two-dimensional array of this food groups example.</p>&#13;
<p class="TableTitle"><strong class="EmphasisBold">Table 4-1:</strong> Two-Dimensional Food Groups Array</p>&#13;
<table class="CitC-Table" id="table001-1">&#13;
<colgroup>&#13;
<col/>&#13;
<col/>&#13;
<col/>&#13;
<col/>&#13;
<col/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr class="CitC-Table">&#13;
<td class="CitC-Table CitCHead CitCHead">&#13;
<p class="TableHeader">Vegetables</p>&#13;
</td>&#13;
<td class="CitC-Table CitCHead CitCHead">&#13;
<p class="TableHeader">Fruits</p>&#13;
</td>&#13;
<td class="CitC-Table CitCHead CitCHead">&#13;
<p class="TableHeader">Grains</p>&#13;
</td>&#13;
<td class="CitC-Table CitCHead CitCHead">&#13;
<p class="TableHeader">Meats</p>&#13;
</td>&#13;
<td class="CitC-Table CitCHead CitCHead">&#13;
<p class="TableHeader">Dairy</p>&#13;
</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="CitC-Table">&#13;
<td class="CitC-Table">&#13;
<p class="TableBody">Celery</p>&#13;
</td>&#13;
<td class="CitC-Table CitC-Cell-style">&#13;
<p class="TableBody">Apples</p>&#13;
</td>&#13;
<td class="CitC-Table CitC-Cell-style">&#13;
<p class="TableBody">Barley</p>&#13;
</td>&#13;
<td class="CitC-Table CitC-Cell-style">&#13;
<p class="TableBody">Beef</p>&#13;
</td>&#13;
<td class="CitC-Table">&#13;
<p class="TableBody">Cheese</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="CitC-Table">&#13;
<td class="CitC-Table">&#13;
<p class="TableBody">Peas</p>&#13;
</td>&#13;
<td class="CitC-Table CitC-Cell-style">&#13;
<p class="TableBody">Bananas</p>&#13;
</td>&#13;
<td class="CitC-Table CitC-Cell-style">&#13;
<p class="TableBody">Oats</p>&#13;
</td>&#13;
<td class="CitC-Table CitC-Cell-style">&#13;
<p class="TableBody">Chicken</p>&#13;
</td>&#13;
<td class="CitC-Table">&#13;
<p class="TableBody">Milk</p>&#13;
</td>&#13;
</tr>&#13;
<tr class="CitC-Table">&#13;
<td class="CitC-Table">&#13;
<p class="TableBody">Spinach</p>&#13;
</td>&#13;
<td class="CitC-Table CitC-Cell-style">&#13;
<p class="TableBody">Oranges</p>&#13;
</td>&#13;
<td class="CitC-Table CitC-Cell-style">&#13;
<p class="TableBody">Wheat</p>&#13;
</td>&#13;
<td class="CitC-Table CitC-Cell-style">&#13;
<p class="TableBody">Pork</p>&#13;
</td>&#13;
<td class="CitC-Table">&#13;
<p class="TableBody">Yogurt</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="Body">Not including the table headers as part of this array of arrays, <span class="Literal _idGenCharOverride-1">foodGroups[0][0]</span> would return <span class="Literal _idGenCharOverride-1">Celery</span>, <span class="Literal _idGenCharOverride-1">foodGroups[2][1]</span> <span class="Literal _idGenCharOverride-1">Oats</span>, and <span class="Literal _idGenCharOverride-1">foodGroups[4][2]</span> <span class="Literal _idGenCharOverride-1">Yogurt</span>. Returning to the library, you can use the bookshelves to explain arrays and arrays of arrays. For example, the reference shelves might include labels like [<span class="Literal _idGenCharOverride-1">'001-372'</span>, <span class="Literal _idGenCharOverride-1">'373–803'</span>, <span class="Literal _idGenCharOverride-1">'803–979'</span>], and each of these labels references an array of books within these addresses. </p>&#13;
<p class="Body">Changing a single variable can have dramatic effects. A single character, or <em class="EmphasisItalic">char</em> data type variable, labeled <span class="Literal _idGenCharOverride-1">currentVowel</span> used to represent the second letter in the string <span class="Literal _idGenCharOverride-1">'b_t'</span> could generate words with very different meanings, such as <span class="Literal _idGenCharOverride-1">'bat'</span>,<span class="Literal _idGenCharOverride-1"> 'bet'</span>,<span class="Literal _idGenCharOverride-1"> 'bit'</span>,<span class="Literal _idGenCharOverride-1"> 'bot'</span>,<span class="Literal _idGenCharOverride-1"> </span>or<span class="Literal _idGenCharOverride-1"> 'but'</span>. Here’s another example: as the floating-point variable representing parts per million (PPM) of carbon dioxide (CO2) molecules in the atmosphere—named <span class="Literal _idGenCharOverride-1">cO2PPM</span>—increases, solar radiation is captured as thermal radiation on planet Earth, and the average planetary temperature increases. When we model these subjects into programming code, we find that changing a single variable in a computational process can produce wildly different outputs.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="feature1">&#13;
<h2 class="BoxHead">Parts-of-Speech Games</h2>&#13;
<p class="BoxBodyFirst">Most people associate variables with mathematics and calculations. But you can bring variables into English classes in many ways. One way is the classic <em class="EmphasisItalicBox">Mad Libs</em> games, which are great for teaching children about parts of speech. </p>&#13;
<p class="BoxBody">In this game, the teacher has a block of prose scattered with blanks that have labels, such as “While [exercise], [famous scientist] slipped on a [adjective] [food] and landed on his/her [body part].” The teacher reads the label aloud, and students provide values to fill them without seeing the context within which these parts of speech appear. Then the teacher fills in the blanks with these values and reads the text to the class. This results in silly outputs like “While <em class="EmphasisItalicBox">jumping rope</em>, <em class="EmphasisItalicBox">Benjamin Franklin</em> slipped on a <em class="EmphasisItalicBox">pink pizza</em> and landed on his <em class="EmphasisItalicBox">ear</em>.”</p>&#13;
<p class="BoxBodyLast">You can also play a game that is the obverse of <em class="EmphasisItalicBox">Mad Libs</em>, where students try to identify the variables in a text. After reading a book in class, have students spin a wheel with the variables “character,” “action,” and “setting” listed on it. Then have them identify an element from that text that fits the variable. Variables are everywhere in our literary world; we only need to identify and draw attention to them.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside><p class="Body">As you might have realized, and as your students will hopefully recognize, we’re already working with variables in our day-to-day academic lives. Identifying the variables in a range of academic contexts can formalize how we think about them. In the next section, we’ll explore how to formally manipulate variables using logical controls.</p>&#13;
<h2 class="HeadA"><a id="_idTextAnchor056"/>Control Structures</h2>&#13;
<p class="BodyFirst">Variables are the most basic elements of our computational world. Once we define these elements, we can then start making decisions based on their values through <em class="EmphasisItalic">control structures</em>. Control structures are conditional statements that evaluate variables and decide what to do based on the values of those variables. There are also control structures that iteratively perform computational tasks, looping over conditional statements and evaluations.</p>&#13;
<p class="Body">As noted in “Programming is Communication” on <a href="CitC_c02.xhtml#_idTextAnchor029">page 19</a> communicating with a computer is like communicating with a very literal person. The control structures explained in the following subsections are formal, whereas natural language is messy. If we hold students’ use of natural language to formal standards, we can cultivate in them a more precise use of language.</p>&#13;
<h3 class="HeadB"><a id="_idTextAnchor057"/>Boolean Conditions</h3>&#13;
<p class="BodyFirst">Programming control structures rely heavily on <em class="EmphasisItalic">Boolean conditions</em> to direct their flow. These statements evaluate to <span class="Literal _idGenCharOverride-1">true </span>or <span class="Literal _idGenCharOverride-1">false</span> and chain together with any number of <span class="Literal _idGenCharOverride-1">and</span><em class="EmphasisItalic"> </em>and <span class="Literal _idGenCharOverride-1">or</span><em class="EmphasisItalic"> </em>operators. When Boolean conditions are connected with <span class="Literal _idGenCharOverride-1">and</span>, <em class="EmphasisItalic">all </em>the conditions must evaluate to <span class="Literal _idGenCharOverride-1">true</span> to satisfy the <span class="Literal _idGenCharOverride-1">if</span> statement. For example, <span class="Literal _idGenCharOverride-1">if</span> an organism eats other organisms <span class="Literal _idGenCharOverride-1">and</span> it has a spinal cord <span class="Literal _idGenCharOverride-1">and</span> it feeds its young with milk <span class="Literal _idGenCharOverride-1">and</span> it lays eggs <span class="Literal _idGenCharOverride-1">and</span> it has a beak, <span class="Literal _idGenCharOverride-1">then</span> it’s a platypus. When Boolean conditions are connected with <span class="Literal _idGenCharOverride-1">or</span>, <em class="EmphasisItalic">any</em> condition evaluating to <span class="Literal _idGenCharOverride-1">true</span> will satisfy the <span class="Literal _idGenCharOverride-1">if</span> statement. For example, <span class="Literal _idGenCharOverride-1">if</span> an organism nurses its young <span class="Literal _idGenCharOverride-1">or</span> it possesses a neocortex <span class="Literal _idGenCharOverride-1">or</span> it has fur <span class="Literal _idGenCharOverride-1">or</span> it has three middle ear bones, <span class="Literal _idGenCharOverride-1">then</span> it’s a mammal.</p>&#13;
<h3 class="HeadB"><a id="_idTextAnchor058"/>if-then and else</h3>&#13;
<p class="BodyFirst">A clerk evaluating a voter registration form in the United States must consider two variables: the applicant’s birth date and citizenship. If the birth date is equal to or greater than today’s date minus 18 years and they’re a US citizen, then the applicant will be registered to vote. This is an example of an <span class="Literal _idGenCharOverride-1">if-then</span> control statement, which works like this: <span class="Literal _idGenCharOverride-1">if</span> the Boolean conditions are true, <span class="Literal _idGenCharOverride-1">then</span> take this action. Likewise, there is also the <span class="Literal _idGenCharOverride-1">if-then-else</span> statement: <span class="Literal _idGenCharOverride-1">if</span> the conditions are true, <span class="Literal _idGenCharOverride-1">then</span> take this action; <span class="Literal _idGenCharOverride-1">else</span><em class="EmphasisItalic"> </em>take a different action. Although unstated in the voter registration example, the <span class="Literal _idGenCharOverride-1">else</span> flow path would be to deny the application, and the applicant would remain unregistered to vote. </p>&#13;
<p class="Body">Between the <span class="Literal _idGenCharOverride-1">if</span> and <span class="Literal _idGenCharOverride-1">else</span> statements can come any number of <span class="Literal _idGenCharOverride-1">else if</span> conditions. Each evaluates a condition before moving on to the <span class="Literal _idGenCharOverride-1">else </span>statement. For example, <span class="Literal _idGenCharOverride-1">if</span> the <span class="Literal _idGenCharOverride-1">birthDate</span> check failed but the citizenship check passed, we might follow the <span class="Literal _idGenCharOverride-1">if</span> with <span class="Literal _idGenCharOverride-1">else if USCitizen == true</span> <span class="Literal _idGenCharOverride-1">then</span> deny the application and ask the applicant to reapply later when they’re old enough. Listing 4-3 shows an example of checking these conditions in JavaScript, a programming language for adding dynamic features to websites (you’ll learn to execute these features from your web browser in the next chapter).</p>&#13;
<pre>var birthDate = new Date("01/01/2000");&#13;
var USCitizen = true;&#13;
var today = new Date();&#13;
var diffDays = parseInt(today - birthDate); &#13;
if (USCitizen == true &amp;&amp; diffDays &gt; 567648000000)&#13;
  console.log("You are registered to vote!");&#13;
else if (USCitizen == true)&#13;
  console.log("Come back later.");&#13;
else&#13;
  console.log("You are not eligible to vote.")&#13;
</pre>&#13;
<p class="Listing">Listing 4-3: Checking whether an applicant can register to vote</p>&#13;
<p class="Body">In this very basic example that doesn’t account for leap years, time zones, or daylight saving  time, the <span class="Literal _idGenCharOverride-1">birthDate</span> is set to the first day of the year 2000 and <span class="Literal _idGenCharOverride-1">USCitizen</span> is set to <span class="Literal _idGenCharOverride-1">true</span>. We then calculate the difference between the <span class="Literal _idGenCharOverride-1">birthDate</span> and today into <span class="Literal _idGenCharOverride-1">diffDays</span>, and check whether the user is older than 567,648,000,000 milliseconds in the first <span class="Literal _idGenCharOverride-1">if </span>statement, which is the number of milliseconds in 18 years. If they’re not, we check whether <span class="Literal _idGenCharOverride-1">USCitizen</span> is <span class="Literal _idGenCharOverride-1">true</span> and tell them to come back later in the <span class="Literal _idGenCharOverride-1">else</span> <span class="Literal _idGenCharOverride-1">if</span> statement; finally, we tell them they’re ineligible if neither old enough or a US citizen in the <span class="Literal _idGenCharOverride-1">else</span> statement. </p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="feature1">&#13;
<h2 class="BoxHead">Gamebooks</h2>&#13;
<p class="BoxBodyFirst"><em class="EmphasisItalicBox">Gamebooks</em> involve a style of writing that uses <span class="LiteralBox _idGenCharOverride-1">if-then</span> control structures to provide a dynamic reading experience. In this kind of book, often written in the second person, the reader is asked to make choices that will determine the direction of the story. For example, the book might ask, “If you drink the potion, turn to page 10. If you try to squeeze through the tiny door, turn to page 20.” Some books might ask the reader to track variables to answer questions like “If you found the gold key, turn to page 100. Otherwise, turn to page 50.” As a result, reading a book becomes a game with interactivity on par with some old text-based computer adventure games.</p>&#13;
<p class="BoxBody">Notable book series in this genre of fiction are <em class="EmphasisItalicBox">Choose Your Own Adventure (CYOA)</em>, <em class="EmphasisItalicBox">Fighting Fantasy</em>, or the <em class="EmphasisItalicBox">Endless Quest</em> series of books. All of them place the user in fantastic settings and situations to navigate. Known for their educational value, the <em class="EmphasisItalicBox">Time Machine</em> books place the reader in various historical contexts, such as the Underground Railroad, Revolutionary War, or Wild West. Reading gamebooks can provide hours of engagement with a text as the user tries to navigate their way to the most satisfying conclusion.</p>&#13;
<p class="BoxBody">An exercise that combines computational thinking and reading is to have your students draw a map of a gamebook. Using page numbers to identify locations, have students draw lines to destination page numbers and create a branching tree of <span class="LiteralBox _idGenCharOverride-1">if-then</span> logic and Boolean conditions. Figure 4-1 shows a map of the gamebook <em class="EmphasisItalicBox">Time Machine: World War II Code Breaker</em> where the reader is a time traveler who must use their history knowledge to find and assist Alan Turing and the Allied code breakers against the Axis forces. This map illustrates how control structures can create a maze of conditional logic.</p>&#13;
<figure>&#13;
<p class="AnchoredBoxGraphic"><img alt="" class="_idGenObjectAttribute-1" src="image/CitC04_01_WWII_SecretAgentMap02.png"/></p>&#13;
<figcaption class="BoxCaption">Figure 4-1: Map of <span class="EmphasisRevCaption">Time Machine: World War II Code Breaker</span></figcaption>&#13;
</figure>&#13;
<p class="BoxBody">Once they’ve fully mapped the book’s many paths, have them critique the story. If each path is a separate timeline, ask whether the events make sense. Are there logical cause-and-effect relationships between the decisions you make as a reader and the outcomes the book presents? This kind of critical analysis blends computational thinking with literary criticism.</p>&#13;
<p class="BoxBody">Writing a simple gamebook can also merge computational thinking with literary practice. Start by having students outline their gamebook and map the various paths it will take. To keep the scope manageable, have students use numbered paragraphs instead of page numbers and keep the prose to just a few sentences before presenting choices to the reader. For younger students, filling their book with illustrations depicting the action can make their gamebook even more fun.</p>&#13;
<p class="BoxBodyLast">You could also try mapping a gamebook as a group activity. Choose a topic the class is currently covering, and let different students define different branches of the story. In the end, you’ll produce a book to which everyone has contributed and that all can enjoy.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside><p class="Body">Once students understand Boolean conditions and <span class="Literal _idGenCharOverride-1">if-then</span> control structures in programming flow, you can add the next powerful level of control: iteration through loops.</p>&#13;
<h3 class="HeadB"><a id="_idTextAnchor059"/>Loops</h3>&#13;
<p class="BodyFirst">One of the central concepts in computer science is <em class="EmphasisItalic">iteration</em>, where a set of programming instructions are executed repeatedly for a specified number of times or until a condition is met. We iterate over various things in our daily lives often without realizing it. We iterate over the days of the week to keep track of our schedules. We iterate over our future bills and paychecks to manage our finances. In programming, we emulate these iterative processes in controls called <em class="EmphasisItalic">loops</em>.</p>&#13;
<p class="Body">In a <span class="Literal _idGenCharOverride-1">while</span> loop, we iterate over a process until a condition is met. For example, we might say that <span class="Literal _idGenCharOverride-1">while</span> a student hasn’t completed their in-class assignment, they don’t get screen time. In this case, we check for the condition (have they not completed their in-class assignment) and then perform the action (deny screen time). In a <span class="Literal _idGenCharOverride-1">do-while</span> <em class="EmphasisItalic">loop</em>, we perform an action and <em class="EmphasisItalic">then</em> check for the condition; for example, <span class="Literal _idGenCharOverride-1">do</span> add one milligram to the balance scale <span class="Literal _idGenCharOverride-1">while</span> the object we’re measuring is on the lower plate. In this situation, we first perform the action and then check for the condition before continuing, because we want to see how our action affects the condition.</p>&#13;
<p class="Body">The <span class="Literal _idGenCharOverride-1">while</span> loop performs an action until a condition is met. But sometimes, we need to iterate a specific number of times. In that case, we use a <span class="Literal _idGenCharOverride-1">for</span> loop. In some programming languages, a <span class="Literal _idGenCharOverride-1">for</span> loop takes three arguments, or inputs: a starting value, a condition, and an operation to perform on the starting value on each iteration. We can use these three arguments to iterate a set number of times. The second line of code in Listing 4-4 shows what this looks like in JavaScript. </p>&#13;
<pre>var x = 0; // set x equal to 0&#13;
for (var i=0; i&lt;10; i=i+1) {&#13;
   x = x + 1; // add one to x&#13;
}&#13;
// x will now equal 10.&#13;
console.log(x);</pre>&#13;
<p class="Listing">Listing 4-4: A <span class="LiteralCaption">for</span> loop counting to 10</p>&#13;
<p class="Body">Note the line that reads <span class="Literal _idGenCharOverride-1">for (var i=0; i&lt;10; i=i+1)</span>. The <span class="Literal _idGenCharOverride-1">var i=0</span> portion sets the variable <span class="Literal _idGenCharOverride-1">i</span> equal to 0. The second part, <span class="Literal _idGenCharOverride-1">i&lt;10</span>, has the loop execute while <span class="Literal _idGenCharOverride-1">i</span> is less than 10. Finally, the <span class="Literal _idGenCharOverride-1">i=i+1</span> part instructs the computer to add one to <span class="Literal _idGenCharOverride-1">i</span> each iteration so this loop executes 10 times. Between the opening and closing curly brackets are the instructions we want to execute. In this case, we’re adding one to <span class="Literal _idGenCharOverride-1">x</span> each iteration so <span class="Literal _idGenCharOverride-1">x</span> will equal 10 when the loop finishes processing.</p>&#13;
<p class="Body">Alternatively, the <span class="Literal _idGenCharOverride-1">foreach</span> control will iterate over each element in a list or array. As an example, <span class="Literal _idGenCharOverride-1">foreach</span> color in [<span class="Literal _idGenCharOverride-1">"Red","Orange","Yellow","Green","Blue","Indigo","Violet"</span>], append the first letter to a string. This statement will iterate over the sequence and output the mnemonic “ROYGBIV.” Listing 4-5 shows executable JavaScript code for this operation.</p>&#13;
<pre>var mnem = ""; // set to an empty string&#13;
//define the color array&#13;
var colors = ["Red","Orange","Yellow","Green","Blue","Indigo","Violet"];&#13;
colors.forEach(function(color) {&#13;
    mnem += color.charAt(0);&#13;
});&#13;
console.log(mnem);</pre>&#13;
<p class="Listing">Listing 4-5: A <span class="LiteralCaption">foreach</span> loop that constructs “ROYGBIV”</p>&#13;
<p class="Body">Loops can lead to interesting errors. Consider a sheet of paper that reads “What’s an infinite loop? (Answer on back)” on one side and “What’s an infinite loop? (Answer on back)” on the other. A human gets the joke instantly, but a computer will flip the sheet of paper over and over indefinitely. In programming, we must make sure our loops end at some point. We must make certain our <span class="Literal _idGenCharOverride-1">while</span> condition will be met and that the list in our <span class="Literal _idGenCharOverride-1">foreach</span> doesn’t grow as we iterate over it. For example, if we set <span class="Literal _idGenCharOverride-1">x</span> equal to <span class="Literal _idGenCharOverride-1">1</span>, and <span class="Literal _idGenCharOverride-1">while</span> <span class="Literal _idGenCharOverride-1">x</span> doesn’t equal <span class="Literal _idGenCharOverride-1">4</span>, add two to <span class="Literal _idGenCharOverride-1">x</span>, then <span class="Literal _idGenCharOverride-1">x</span> will iterate from one to three to five without ever satisfying the condition—meaning it will run forever. If we have a <span class="Literal _idGenCharOverride-1">foreach</span> loop that runs <span class="Literal _idGenCharOverride-1">foreach</span> egg in our basket, and in each iteration we add one egg to the basket, the eggs in our basket will grow indefinitely and the loop will never terminate, as in Listing 4-6.</p>&#13;
<pre>var basket = ["egg"];&#13;
for (var i = 0; i &lt; basket.length; i++) {&#13;
  basket.push("egg");&#13;
}&#13;
console.log(basket.length);</pre>&#13;
<p class="Listing">Listing 4-6: A <span class="LiteralCaption">foreach</span> loop that will never terminate</p>&#13;
<p class="Body">In this code is an array <span class="Literal _idGenCharOverride-1">basket</span> that contains a single <span class="Literal _idGenCharOverride-1">"egg"</span> string. The <span class="Literal _idGenCharOverride-1">for</span> loop starts at zero and iterates as long as <span class="Literal _idGenCharOverride-1">i</span> is less than <span class="Literal _idGenCharOverride-1">basket.length</span>, which is a count of the number of values stored in <span class="Literal _idGenCharOverride-1">basket</span>. With one string stored, this value is <span class="Literal _idGenCharOverride-1">1</span>. Inside the loop, the <span class="Literal _idGenCharOverride-1">basket.push()</span> function adds another <span class="Literal _idGenCharOverride-1">"egg"</span> string variable to the array, making the length 2, 3, 4, and so on, meaning <span class="Literal _idGenCharOverride-1">i</span> will always be less than <span class="Literal _idGenCharOverride-1">basket.length</span>. This code will execute indefinitely or at least until the computer runs out of memory locations in which to store all these <span class="Literal _idGenCharOverride-1">"egg"</span> strings and crashes.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="feature1">&#13;
<h2 class="BoxHead">Flowchart Loop</h2>&#13;
<p class="BoxBodyFirst">Scoping out requirements is a crucial part of developing software in the professional world. It demands clear communication between nontechnical people who understand the business processes and the programmers translating those processes into formal control structures. <em class="EmphasisItalicBox">Flowcharts</em> are an effective visual tool for facilitating these conversations. In these diagrams, symbols represent different points in the control flow. For example, an oval represents the start or end of the flow, rectangles represent process steps, arrows direct readers along the process, and diamonds represent decision points where the flow can branch in different directions.</p>&#13;
<p class="BoxBody">Communicating logical operations in a visual map makes them easier for nontechnical peers to understand. A list of <span class="LiteralBox _idGenCharOverride-1">if-then</span> or <span class="LiteralBox _idGenCharOverride-1">foreach</span> statements in text is harder to process than a map of decision points and possible paths. For this reason, project managers and technical writers will present colleagues with minute business rules in flowcharts so everyone has the same understanding of the process. When it comes time to write the code, programmers can easily translate the flowchart into programming syntax. Then the quality assurance experts can use the flowchart as a map to navigate the software to ensure it follows the requirements.</p>&#13;
<p class="BoxBody">This powerful bridge between nontechnical and technical understanding of a subject makes flowcharts an extremely effective tool for easing students into programming concepts visually while illustrating concepts covered in class. For example, Figure 4-2 shows two flowcharts illustrating the nuclear arms race between the United States and the USSR. The chart on the left shows the escalation rate starting in 1945 and continuing to 1986; the chart on the right shows the de-escalation that occurred from 1987 to 2014. The two charts also show different loop structures: the chart on the left shows a <span class="LiteralBox _idGenCharOverride-1">while</span> loop, and the chart on the right shows a <span class="LiteralBox _idGenCharOverride-1">do-while</span> loop.</p>&#13;
<figure>&#13;
<p class="AnchoredBoxGraphic"><img alt="" class="_idGenObjectAttribute-2" src="image/CitC04_02_FlowChart.png"/></p>&#13;
<figcaption class="BoxCaption">Figure 4-2: Escalation and de-escalation of nuclear warheads</figcaption>&#13;
</figure>&#13;
<p class="BoxBodyLast">As these loops iterate, you can highlight historical moments that occurred along them, such as the 1949 Soviet Union development of the A-bomb, the 1952 and 1953 developments of the H-bomb, and the 1962 Cuban Missile Crisis. On the de-escalation side, you can highlight the 1991 and 1993 START I and START II treaties that cut nuclear warhead counts. The steadily increasing and decreasing numbers illustrate part of the half-century epic of the Cold War, which forced the two world powers into a race of mutually assured destruction (MAD) that strained both sides economically and socially.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside><p class="Body">With variables, conditional statements, and loops now under our belt, we can start combining these elements into more complex, formal processes. </p>&#13;
<h2 class="HeadA"><a id="_idTextAnchor060"/>Algorithms and Functions</h2>&#13;
<p class="BodyFirst">Familiar with the concept of variables, your students can start identifying the basic units of information they want to work with. Armed with programming controls, students can direct the flows of logic based on those variables. Now they’re ready to begin learning how to intentionally combine these concepts into computational constructs that will achieve their goals.</p>&#13;
<h3 class="HeadB"><a id="_idTextAnchor061"/>Algorithms</h3>&#13;
<p class="BodyFirst">As we noted in Chapter 1, an <em class="EmphasisItalic">algorithm</em> is a set of rules specifying how to solve a problem. The word “algorithm” can be intimidating. It sounds highly technical but is actually a simple concept. Like with variables and logical controls, your students are already working with algorithms when they follow any kind of instructions. For example, following this algorithm will produce the first line of stitches needed to crochet a cute Yoda doll: <strong class="EmphasisBold">Rnd 1</strong>: ch2, work 6 sc into first ch—6st </p>&#13;
<p class="Body">This instruction is cryptic, just like a line from a computer program if you’re not familiar with the notation. It instructs the crafter to execute two chain stitches and then work six double crochets into it. </p>&#13;
<p class="Body">Following the algorithm in Figure 4-3 will produce the distinctive opening notes of Beethoven’s Symphony No. 5.</p>&#13;
<figure>&#13;
<p class="AnchoredGraphic"><img alt="" class="_idGenObjectAttribute-3" src="image/CitC04_04_beethovensyphony5.png"/></p>&#13;
<figcaption class="Caption">Figure 4-3: The opening of Beethoven’s Symphony No. 5</figcaption>&#13;
</figure>&#13;
<p class="Body">If you know how to read music, you might hear the notes in your head when you read this notation. But unless you’re a true virtuoso, you’d have a hard time playing these notes on every kind of musical instrument. The algorithms in the Yoda crochet instructions and the opening notes of Beethoven's Symphony No. 5 require certain levels of expertise and knowledge to understand and implement. Without understanding crochet notation or being able to read sheet music, you couldn’t understand these commands, let alone execute them. Similarly, your students’ lives are filled with algorithms that require some expertise to execute. The schedules they follow, the tests they take, and the rules of conduct they emulate are all algorithms for which they should find pride in being able to follow. Hopefully, appreciating the many complex algorithms your students are already successfully navigating in their daily lives will demystify the challenge of constructing new algorithms.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="feature1">&#13;
<h2 class="BoxHead">The PB&amp;J Algorithm Game</h2>&#13;
<p class="BoxBodyFirst">Humans have an easy time with many algorithms because we fill in the blanks when things aren’t fully defined. Consider a game of tic-tac-toe. We might need to be told the rules of the game, but we generally don’t need to be told to place the paper where both players can mark it. We also understand that we must take a reasonable amount of time in choosing our next mark. We can make inferences like that, but a computer needs all these details spelled out for it.</p>&#13;
<p class="BoxBody">To illustrate this concept in class, play the role of the computer for your students. Set out some bread, peanut butter, jelly, and utensils on a newspaper for easy cleaning. Then have your students instruct you, the computer, to assemble a peanut butter and jelly sandwich. </p>&#13;
<p class="BoxBodyLast">Have fun with this. If a student says, “Put peanut butter on the bread,” use your bare hands and spread it on both sides of a piece of bread. After they clarify this step, if a student says, “Put the two pieces of bread together,” put them together backward. Continue on until your students are expressing themselves as clearly and exactly as possible, making them understand that this is how to properly instruct a computer.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside><p class="Body">Simple algorithms can provide us with powerful solutions. We can solve mazes that have all their walls connected to an outer boundary with a simple algorithm of following either the right or left wall. If your students can memorize 10 short algorithms then with a little practice they can solve a Rubik’s Cube in less than five minutes. Students familiar with various sorting algorithms and their relative efficiencies will have an easier time organizing index cards, file folders, books, and other collections.</p>&#13;
<p class="Body">Algorithms are powerful tools for documenting solutions to complex problems so that others may solve them, and in computing they become even more powerful when we can automate and abstract them away into functions that are more convenient and easier to work with. </p>&#13;
<h3 class="HeadB"><a id="_idTextAnchor062"/>Functions</h3>&#13;
<p class="BodyFirst">As we learned in the previous chapter, a computer system is filled with computational solutions that have been layered on top of one another over decades, like geological strata over eons of time. If we had to expose ourselves to all these algorithms every time we wanted to write a program, we would be overwhelmed. Even working in a single program, if we had to read past the detailed algorithms needed to generate random numbers, round decimals, concatenate strings, or sort arrays, we would spend all our time sifting through code rather than writing it.</p>&#13;
<p class="Body">For these reasons, in software development we use <em class="EmphasisItalic">functions</em> to hold algorithms. A function <em class="EmphasisItalic">encapsulates </em>the algorithm. In other words, it conceptually wraps up many lines of instructions into a process you can simply invoke by name—like clicking an icon that represents a program. For example, the algorithm to generate pseudorandom numbers might be 5 to 30 lines of mathematically dense code, but in a function, we only need to call <span class="Literal _idGenCharOverride-1">random()</span>. Encapsulating the code also makes it reusable. We can call <span class="Literal _idGenCharOverride-1">random()</span>repeatedly in our code, and if we find a bug in the function or a way to enhance it, we need only edit the one function to improve it everywhere.</p>&#13;
<p class="Body">The function also abstracts away the complexity of the algorithm. We don’t need to know what’s inside the function. We only need to know what arguments to give it and what outputs we should expect. If I can set a start and end range for my random number as <span class="Literal _idGenCharOverride-1">random(1,20)</span>, I can expect to get the same results as a 20-sided dice roll without needing to know anything about how that number was produced. The function is a black box that takes inputs and gives us outputs.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="feature1">&#13;
<h2 class="BoxHead">Guess the Function Game</h2>&#13;
<p class="BoxBodyFirst">It’s time to play the role of the computer once again. In this game, the teacher represents a function. Students don’t know what that function does, but they can give it inputs and observe the outputs. For example, if the students give you the numbers 2, 8, and 3 and you give back 5, 11, and 6, you might be a function that adds 3 to any number. Likewise, if the students give you 1, 4, and 6 and you output 2, 8, and 12, you might be a function that doubles any input.</p>&#13;
<p class="BoxBody">You can also be a function that returns truth values. For example, you might be a function that evaluates numbers and returns true if the number meets a certain criteria. If the function returns true for the numbers 2, 4, 6, and 8 but false for 1, 3, and 5 you might be a function that checks for even numbers. </p>&#13;
<p class="BoxBodyLast">On a more advanced level, you could be a function that checks for primes, squares, or whole numbers. Your functions need not be restricted to mathematics. You could be a phonetic function, taking letters the students input and outputting words. For example, the “it” function would output words like “bit,” “fit,” and “grit.” Have the students try to predict what words would come out of the function with novel letter combinations to practice phonetic patterns. Encourage your students to play this game with one another, and observe them for insights they might have.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside><p class="Body">Once your students are comfortable with algorithms and functions, they’re ready to take everything we’ve covered in this chapter and blend it together in a complex ecosystem of interacting variables, conditional logic, and encapsulated functions, also known as games!</p>&#13;
<h2 class="HeadA"><a id="_idTextAnchor063"/>Bringing It All Together with Game-Based Learning</h2>&#13;
<p class="BodyFirst">Many activities in this chapter introduced computational concepts to your students. Exercises like the Parts of Speech Games, Gamebooks, the PB&amp;J Algorithm Game, and the Guess the Function Game are all meant to be playful ways of engaging complex subjects. These are also examples of <em class="EmphasisItalic">game-based learning</em>, a kind of instruction growing in popularity that combines naturally engaging play with serious instruction to encourage students to more fully explore the subject matter.</p>&#13;
<p class="Body">It’s important to note that game-based learning is different from <em class="EmphasisItalic">gamified learning</em>, which uses points, badges, and rewards in the classroom to motivate students the same way an addictive video game keeps players clicking buttons for little rewards. The former is intended to facilitate deep engagement with a complex subject; the latter is associated with Pavlovian conditioning. An example of gamified learning would be giving a student a badge for doing well on a timed test. An example of game-based learning would be having students play a game about the Electoral College where they work as two teams competing to get 538 votes across a map of the United States. The former rewards students for exhibiting a desired behavior, whereas the latter immerses them in the subject matter for a deeper understanding.</p>&#13;
<p class="Body">Games are valuable learning tools because of the way they engage their players. Game designers often refer to the <em class="EmphasisItalic">magic circle</em>, the state of mind a player enters when playing a game where they forget about the outside world and are totally immersed in the game’s microworld. In education and in programming, there is a related psychological concept of <em class="EmphasisItalic">flow </em>where the student or programmer forgets themselves and completely engages the task at hand. The magic circle is a safe space where students can play and experiment within an artificial world without consequences. It’s also a space that promotes flow.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="feature1">&#13;
<h2 class="BoxHead">Modeling Boards</h2>&#13;
<p class="BoxBodyFirst">A challenge your students might encounter following some algorithm instructions is tracking the state of many variables throughout their execution. For example, in the nuclear arms race flowchart algorithm in Figure 4-2, we were simultaneously tracking the year and number of nuclear warheads. We could do this on a sheet of paper, writing down each variable one-to-one down the page as the algorithm executes. But this can become tedious and unwieldy as the number of variables increases.</p>&#13;
<p class="BoxBody">Board games provide great examples of ways to track the states of variables. Using tokens, dice, cards, dials, and tracks, board game designers have developed many innovative ways for players to easily follow the game’s current state. In many games, each player is given a board with areas identifying the variables being tracked. For example, some gamebooks provide readers with a character sheet that tracks their health and inventory. Figure 4-5 shows an example of a sheet you could use in a classroom lesson on graphs and probability.</p>&#13;
<figure>&#13;
<p class="AnchoredBoxGraphic"><img alt="" class="_idGenObjectAttribute-4" src="image/CitC04_05_ModelingBoard.png"/></p>&#13;
<figcaption class="BoxCaption">Figure 4-5: Modeling board for graphing probabilities</figcaption>&#13;
</figure>&#13;
<p class="BoxBody">This exercise requires a lot of six-sided dice to maximize the fun. Students execute the algorithm: they roll two six-sided dice, read the value, and place the dice in the appropriate value column. When a column is full, they stop the exercise: translating this into programming speak could read as follows: <span class="LiteralBox _idGenCharOverride-1">while</span> no column is full, <span class="LiteralBox _idGenCharOverride-1">do<a id="_idTextAnchor064"/></span> the exercise. When the algorithm completes, students should have a nice probability curve with six, seven, and eight occurring with the highest frequency. Ask your students what makes those numbers come up most often. Why do 2 and 12 occur so rarely? Why did they never roll a one?</p>&#13;
<p class="BoxBodyLast">Tracking the variables this way not only makes it easier to follow along, but also makes the activity more game-like and hands-on. By using dice and tokens instead of pencils and erasers, students are encouraged to reuse the materials and manipulate the variables to experiment with the outcomes. The modeling board is like a control panel that lets students feel like the master of the algorithm’s execution.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside><p class="Body">Games are also especially effective in engaging students in computational thinking because games are computational artifacts. Games are filled with variables. They have conditional logic in player choices. Each game round is a loop of players executing their turns. The rule book is an algorithm where we conceptualize many of the rules into functions. Board games are like software but run on human brainpower.</p>&#13;
<p class="Body">Consider the following example. Figure 4-6 shows a 7 × 9 version of the ancient Indian board game <em class="EmphasisItalic">Snakes and Ladders</em>, also known as <em class="EmphasisItalic">Chutes and Ladders</em> in the West. In this game, players take turns rolling a six-sided die and moving that many squares. If they land on a square at the bottom of ladder, they slide up to the top of that ladder. If they land on a square with the head of a snake, they slide down to the square at the end of the snake’s tail.</p>&#13;
<p class="Body">Because the game is simple and we don’t need to factor in player choices, it’s very easy to model in programming code. Listing 4-7 shows all the JavaScript code needed to emulate a game of <em class="EmphasisItalic">Snakes and Ladders</em>.</p>&#13;
<figure>&#13;
<p class="AnchoredGraphic"><img alt="" class="_idGenObjectAttribute-5" src="image/CitC04_06_SnakesAndLadders.png"/></p>&#13;
<figcaption class="Caption">Figure 4-6: <span class="EmphasisRevCaption">Snakes and Ladders</span> board game</figcaption>&#13;
</figure>&#13;
<pre>//An array of arrays naming our players and their scores.&#13;
var players = [&#13;
   ["Ada",0]&#13;
   ,["Alan",0]&#13;
   ,["Claude",0]&#13;
   ,["Grace",0]&#13;
];&#13;
var winner = "nobody";&#13;
//Keep playing until we have a winnner.&#13;
while (winner == "nobody") {&#13;
  //Loop through Ada, Alan, Claude, and Grace&#13;
  players.forEach(function(player) {&#13;
    //Role a 6-sided die.&#13;
    var spin = Math.floor(Math.random() * 6) + 1;&#13;
    var value = player[1] + spin;&#13;
    console.log(player[0] + " " + player[1] + " -&gt; " + value);&#13;
&#13;
    //Check for Snakes and Ladders&#13;
    if (value == 3) value = 17;&#13;
    else if (value == 20) value = 33;&#13;
    else if (value == 22) value = 36;&#13;
    else if (value == 25) value = 11;&#13;
    else if (value == 32) value = 16;&#13;
    else if (value == 38) value = 46;&#13;
    else if (value == 47) value = 61;&#13;
    else if (value == 48) value = 34;&#13;
    else if (value == 58) value = 45;&#13;
&#13;
    //Assign new value to player&#13;
    player[1] = value;&#13;
    console.log(player[0] + " " + player[1]);     &#13;
&#13;
    //Check for winner&#13;
    if (player[1] &gt;= 63 &amp;&amp; winner == "nobody") {&#13;
        winner = player[0]; &#13;
    }&#13;
  });&#13;
}&#13;
//Tell us who won.&#13;
console.log("The winner is " + winner + "!");</pre>&#13;
<p class="Listing">Listing 4-7: <span class="EmphasisRevCaption">Snakes and Ladders</span> code</p>&#13;
<p class="Body">This code example illustrates how the logical structure and algorithms of games can translate to programming logic. The players and their scores are stored in an array data type. The game executes as long as there is no winner. Each player takes a turn where a random number is assigned to their current score, which is then subjected to conditional logic that checks for snakes and ladders. Finally, once a player’s score is equal to or greater than 63, we set the winner variable, and the program tells us the winner.</p>&#13;
<p class="Body">The act of translating <em class="EmphasisItalic">Snakes and Ladders</em> into a formal algorithm reveals insights into the game. Seeing the game translated into just 35 lines of code illustrates its simplicity. The fact that we didn’t need to code any player input emphasizes the lack of player agency: the game outcome is entirely out of the players’ hands. In fact, this is by design. <em class="EmphasisItalic">Snakes and Ladders</em> was invented to teach children the concept of karma and accepting one’s fate. In the Western world, we use <em class="EmphasisItalic">Chutes and Ladders</em> as an early childhood exercise in following rules and learning basic arithmetic. By writing the game as code, we’re extending the game’s use in the classroom to older students and giving them a fresh look at a nostalgic activity. The code is an isomorph of the board game, a concept touched on in Chapter 2 where the same logic is presented in a different way.</p>&#13;
<p class="Body">Children tend to get bored with <em class="EmphasisItalic">Chutes and Ladders</em> quickly. They rapidly recognize the lack of agency the game provides and how they have no control over the outcome. The game becomes a tedious chore where players execute the algorithm again and again waiting to see the random outcome. That makes this coding exercise also perfect for illustrating the power of automation. Once translated into a syntactically correct program, a 10- to 20-minute board game would execute in milliseconds. In a sense, automating the game makes it obsolete, but there is also a new opportunity here. Students can now review the gameplay algorithm and find ways to make it more fun.</p>&#13;
<h3 class="HeadB"><a id="_idTextAnchor065"/>Refactor Your Gameplay</h3>&#13;
<p class="BodyFirst">Playing games and analyzing them as computational artifacts helps us understand them more deeply. If you can explain the game to our dense, overly literal friend the computer, then you know it completely. Once you know it completely, you can take ownership of it, enhance it, and make it your own.</p>&#13;
<p class="Body">The same is true of software code. When a programmer encounters new code, they must take the time to get familiar with its organization and flow. After taking ownership of a codebase, a programmer might take time to <em class="EmphasisItalic">refactor </em>that code, which is the art—not science—of reorganizing the code to potentially make it more reusable, efficient, intuitive, or elegant.</p>&#13;
<p class="Body">Board games are great laboratories to experiment with refactoring. <em class="EmphasisItalic">Snakes and Ladders</em> loses its engagement as the players catch on to the fact that the game’s outcome is out of their hands. So let’s change that. Instead of having players roll a die to move each turn, they each roll 10 dice at the start of the game. Then they “program” their token with these values, lining up the dice in a stack of moves to most optimally navigate the snakes and ladders. The player who can reach the end in the fewest steps is the winner. Thus, with a minor rule change, we’ve transformed a game with a purely random output to one with much deeper strategy requiring computational thinking.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="feature1">&#13;
<h2 class="BoxHead">Customizable Card Games</h2>&#13;
<p class="BoxBodyFirst">A family of games demanding a great deal of computational thinking that has grown immensely in popularity over the last 30 years are <em class="EmphasisItalicBox">customizable card games</em>. Also referred to as <em class="EmphasisItalicBox">collectible card games (CCGs)</em> or <em class="EmphasisItalicBox">Living Card Games (LCGs)</em>, these games give players a large pool of cards from which to build a customized deck that they hope will win against players with other customized decks. Recent examples include <em class="EmphasisItalicBox">Pokémon</em>, the enormously popular <em class="EmphasisItalicBox">Magic the Gathering</em>, and the free print-and-play science game <em class="EmphasisItalicBox">Phylo: The Trading Card Game</em>.</p>&#13;
<p class="BoxBody">In this family of games, there are overarching rules to the game, a top-level algorithm analogous to an operating system or programming environment. Each unique card can be thought of as a function, taking inputs and producing outputs based on the game’s current state. The collection of cards the player chooses for their deck is like the set of functions they choose to use in their programming environment.</p>&#13;
<p class="BoxBody">Much of the time spent on CCGs occurs off the tabletop. Players commit most of their time to evaluating the cards, speculating about how they can use them, and imagining interactions with other cards, using those hypothetical results to assemble their decks. In essence, these decks are like untested programs. When they come to the table, they get a chance to test their program to see how their chosen combinations of functions execute in a production environment. </p>&#13;
<p class="BoxBodyLast">Because of their time-intensive nature, CCGs are better played as an extracurricular activity rather than in class. They could be played in an after-school club where students can bring in their decks to test them once a week after plotting them out and configuring them during the rest of the week. When choosing a CCG, let your students lead the way. Games rise and fall in popularity, and selecting a popular game as an after-school activity will maximize enthusiasm for it. While the students play, emphasize the computational thinking aspects to the game. An after-school club could potentially lure more students into computer science as they discover their hobby is so similar to computer programming.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside><p class="Body">When questioning and modifying the rules of existing games, challenge your students to identify the variables, logical flows, and algorithms in the rules and game mechanics. When isolated and articulated, these elements become parts they can use to modify other games or even assemble their own. This is just like computer programming. Coders always start out working with artifacts others have created. They might include a high-level coding language, software framework, or existing application, so the coder must learn about the environment in which they’re developing, adapt to it, and make it their own. Once your students are comfortable experimenting with the rules of existing games, it’s time to see how they do crafting games from scratch.</p>&#13;
<h3 class="HeadB"><a id="_idTextAnchor066"/>Modeling with Games</h3>&#13;
<p class="BodyFirst">Many popular board games are effective for the way their mechanics model real-world elements. From schooling and professional choices, to mortgages, raising children, and retirement, Hasbro’s <em class="EmphasisItalic">Game of Life</em> models the economic life span of an average US citizen. The cooperative game <em class="EmphasisItalic">Pandemic</em> models global disease outbreaks for specialists to mitigate. The board game <em class="EmphasisItalic">Evolution</em> models how species adapt to environmental changes through natural selection. With the proper variables and algorithms, games can serve as valuable computational models for students to play with.</p>&#13;
<p class="Body">Having students model topics from class in games provides an avenue for project-based learning. A student modeling the life of a piece of legislation in a game, where each player represents a branch of government, will have a more precise and intimate understanding of the process than a student who only reads the algorithm in a textbook. A student tracing the energy stored in gasoline back to its ancient origin in the sun through a conceptual maze of electrons, photons, and nuclear fusions in a game they design will have detailed knowledge beyond their peers who solely followed a diagram in a book.</p>&#13;
<p class="Body">Likewise, modeling aspects of the real world in a game, and highlighting the ways in which that modeling is computational thinking, will give students a strong grasp of computer science concepts. Seeing the board and playing pieces as tracking variables, the rules as the software algorithm, and the players as testing the execution of that algorithm as they process it in play will all solidify these concepts in the student’s head. The skills learned in modeling for games are directly transferable to computational tasks in computer science and will prepare students for working with the rules in computers and software development environments.</p>&#13;
<h2 class="HeadA"><a id="_idTextAnchor067"/>Summary</h2>&#13;
<p class="BodyFirst">In this chapter, you learned about the basic logical elements that make up an algorithm. We covered the variables our algorithms process and their inputs and outputs. We covered the control structures that direct the flow of our algorithms, and we covered the functions that encapsulate complex algorithms and make them easier to work with.</p>&#13;
<p class="Body">Throughout this chapter, we explored sample exercises to engage in with each of these concepts. None of these exercises required us to get anywhere near a computer, and many focused on how we’re already using these concepts in our daily lives. Because we’re already using the elements of computational thinking in our routines, we only need to draw attention to these elements to make our students aware.</p>&#13;
<p class="Body">In board games, we explored a medium that brings together variables, controls, algorithms, and modeling into an experience where students can feel safe to experiment with topics in class while also engaging with them more formally. As students refactor the existing rules of games, they make these games their own—just as a computer programmer uses existing code and modifies it to meet their requirements.</p>&#13;
<p class="Body">In the next chapter, we’ll learn about a tool any student with a web browser can use to start instantly exploring and experimenting with existing code. As with board games, they’ll learn about web applications by editing the logic of existing applications in a safe and experimental environment. </p>&#13;
</div>&#13;
</body></html>