<html><head></head><body>
<h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_281"/><strong><span class="big">10</span><br/>TESTING</strong></h2>&#13;
<p class="quote"><em>“How could [the computer] pick up a picture of Ender’s brother and put it into the graphics in this Fairyland routine?” “Colonel Graff, I wasn’t there when it was programmed. All I know is that the computer’s never taken anyone to this place before.”<br/>—Orson Scott Card</em>, Ender’s Game</p>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">Many ways are available to you to test your software. The common thread running through all these testing methods is that each test provides some kind of input to your code and you evaluate the test’s output for suitability. The nature of the environment, the scope of the investigation, and the form of the evaluation vary widely among testing types. This chapter covers how to perform testing with a few different frameworks, but the material is extensible to other testing varieties. Before diving in, let’s take a quick survey of several kinds of testing.</p>&#13;
<h3 class="h3" id="ch10lev1sec1"><span epub:type="pagebreak" id="page_282"/><strong>Unit Tests</strong></h3>&#13;
<p class="noindent"><em>Unit tests</em> verify that a focused, cohesive collection of code—a <em>unit</em>, such as a function or a class—behaves exactly as the programmer intended. Good unit tests isolate the unit being tested from its dependencies. Sometimes this can be hard to do: the unit might depend on other units. In such situations, you use mocks to stand in for these dependencies. <em>Mocks</em> are fake objects you use solely during testing to provide you with fine-grained control over how a unit’s dependencies behave during the test. Mocks can also record how a unit interacted with them, so you can test whether a unit is interacting with its dependencies as expected. You can also use mocks to simulate rare events, such as a system running out of memory, by programming them to throw an exception.</p>&#13;
<h4 class="h4" id="ch10lev2sec1"><strong><em>Integration Tests</em></strong></h4>&#13;
<p class="noindent">Testing a collection of units together is called an <em>integration test</em>. Integration tests can also refer to testing interactions between software and hardware, which system programmers deal with often. Integration tests are an important layer on top of unit tests, because they ensure that the software you’ve written works together as a system. These tests complement, but don’t replace, unit tests.</p>&#13;
<h4 class="h4" id="ch10lev2sec2"><strong><em>Acceptance Tests</em></strong></h4>&#13;
<p class="noindent"><em>Acceptance tests</em> ensure that your software meets all of your customers’ requirements. High-performing software teams can use acceptance tests to guide development. Once all of the acceptance tests pass, your software is deliverable. Because these acceptance tests become part of the code base, there is built-in protection against refactoring or feature regression, where you break an existing feature in the process of adding a new one.</p>&#13;
<h4 class="h4" id="ch10lev2sec3"><strong><em>Performance Tests</em></strong></h4>&#13;
<p class="noindent"><em>Performance tests</em> evaluate whether software meets effectiveness requirements, such as speed of execution or memory/power consumption. Optimizing code is a fundamentally empirical exercise. You can (and should) have ideas about which parts of your code are causing performance bottlenecks but can’t know for sure unless you measure. Also, you cannot know whether the code changes you implement with the intent of optimizing are improving performance unless you measure again. You can use performance tests to instrument your code and provide relevant measures. <em>Instrumentation</em> is a technique for measuring product performance, detecting errors, and logging how a program executes. Sometimes customers have strict performance requirements (for example, computation cannot take more than 100 milliseconds or the system cannot allocate more than 1MB of memory). You can automate testing such requirements and make sure that future code changes don’t violate them.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_283"/>Code testing can be an abstract, dry subject. To avoid this, the next section introduces an extended example that lends context to the discussion.</p>&#13;
<h3 class="h3" id="ch10lev1sec2"><strong>An Extended Example: Taking a Brake</strong></h3>&#13;
<p class="noindent">Suppose you’re programming the software for an autonomous vehicle. Your team’s software is very complicated and involves hundreds of thousands of code lines. The entire software solution is composed of several binaries. To deploy your software, you must upload the binaries into a car (using a relatively time-consuming process). Making a change to your code, compiling, uploading, and executing it in a live vehicle takes several hours per iteration.</p>&#13;
<p class="indent">The monumental task of writing all the vehicle’s software is broken out into teams. Each team is responsible for a <em>service</em>, such as the steering wheel control, audio/video, or vehicle detection. Services interact with each other via a service bus, where each service publishes events. Other services subscribe to these events as needed. This design pattern is called a <em>service bus architecture</em>.</p>&#13;
<p class="indent">Your team is responsible for the autonomous braking service. The service must determine whether a collision is about to happen and, if so, tell the car to brake. Your service subscribes to two event types: the <span class="literal">SpeedUpdate</span> class, which tells you that the car’s speed has changed, and the <span class="literal">CarDetected</span> class, which tells you that some other car has been detected in front of you. Your system is responsible for publishing a <span class="literal">BrakeCommand</span> to the service bus whenever an imminent collision is detected. These classes appear in <a href="ch10.xhtml#ch10ex01">Listing 10-1</a>.</p>&#13;
<pre>struct SpeedUpdate {&#13;
  double velocity_mps;&#13;
};&#13;
&#13;
struct CarDetected {&#13;
  double distance_m;&#13;
  double velocity_mps;&#13;
};&#13;
&#13;
struct BrakeCommand {&#13;
  double time_to_collision_s;&#13;
};</pre>&#13;
<p class="listing"><a id="ch10ex01"/><em>Listing 10-1: The POD classes that your service interacts with</em></p>&#13;
<p class="indent">You’ll publish the <span class="literal">BrakeCommand</span> using a <span class="literal">ServiceBus</span> object that has a <span class="literal">pub</span><span class="literal">lish</span> method:</p>&#13;
<pre>struct ServiceBus {&#13;
  void publish(const BrakeCommand&amp;);&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_284"/>The lead architect wants you to expose an <span class="literal">observe</span> method so you can subscribe to <span class="literal">SpeedUpdate</span> and <span class="literal">CarDetected</span> events on the service bus. You decide to build a class called <span class="literal">AutoBrake</span> that you’ll initialize in the program’s entry point. The <span class="literal">AutoBrake</span> class will keep a reference to the <span class="literal">publish</span> method of the service bus, and it will subscribe to <span class="literal">SpeedUpdate</span> and <span class="literal">CarDetected</span> events through its <span class="literal">observe</span> method, as in <a href="ch10.xhtml#ch10ex02">Listing 10-2</a>.</p>&#13;
<pre>template &lt;typename T&gt;&#13;
struct AutoBrake {&#13;
  AutoBrake(const T&amp; publish);&#13;
  void observe(const SpeedUpdate&amp;);&#13;
  void observe(const CarDetected&amp;);&#13;
private:&#13;
  const T&amp; publish;&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};</pre>&#13;
<p class="listing"><a id="ch10ex02"/><em>Listing 10-2: The <span class="literal">AutoBrake</span> class, which provides the automatic braking service</em></p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10fig01">Figure 10-1</a> summarizes the relationship between the service bus <span class="literal">ServiceBus</span>, the automatic braking system <span class="literal">AutoBrake</span>, and other services.</p>&#13;
<div class="image"><img src="../images/fig10_1.jpg" alt="image"/></div>&#13;
<p class="figcap" id="ch10fig01"><em>Figure 10-1: A high-level depiction of the interaction between services and the service bus</em></p>&#13;
<p class="indent">The service integrates into the car’s software, yielding something like the code in <a href="ch10.xhtml#ch10ex03">Listing 10-3</a>.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
int main() {&#13;
  ServiceBus bus;&#13;
  AutoBrake auto_brake{ [&amp;bus<span class="ent">➊</span>] (const auto&amp; cmd) {&#13;
                          bus.publish(cmd); <span class="ent">➋</span>&#13;
                      }&#13;
  };&#13;
  while (true) {  // Service bus's event loop&#13;
    auto_brake.observe(SpeedUpdate{ 10L }); <span class="ent">➌</span>&#13;
<span epub:type="pagebreak" id="page_285"/>    auto_brake.observe(CarDetected{ 250L, 25L }); <span class="ent">➍</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex03"/><em>Listing 10-3: A sample entry point using your <span class="literal">AutoBrake</span> service</em></p>&#13;
<p class="indent">You construct an <span class="literal">AutoBrake</span> with a lambda that captures a reference to a <span class="literal">ServiceBus</span> <span class="ent">➊</span>. All the details of how <span class="literal">AutoBrake</span> decides when to brake are completely hidden from the other teams. The service bus mediates all interservice communication. You’ve simply passed any commands from the <span class="literal">AutoBrake</span> directly to the <span class="literal">ServiceBus</span> <span class="ent">➋</span>. Within the event loop, a <span class="literal">ServiceBus</span> can pass <span class="literal">SpeedUpdate</span> <span class="ent">➌</span> and <span class="literal">CarDetected</span> objects <span class="ent">➍</span> to the <span class="literal">observe</span> method on your <span class="literal">auto_brake</span>.</p>&#13;
<h4 class="h4" id="ch10lev2sec4"><strong><em>Implementing AutoBrake</em></strong></h4>&#13;
<p class="noindent">The conceptually simple way to implement <span class="literal">AutoBrake</span> is to iterate among writing some code, compiling the production binary, uploading it to a car, and testing functionality manually. This approach is likely to cause program (and car) crashes and to waste a whole lot of time. A better approach is to write code, compile a unit-test binary, and run it in your desktop development environment. You can iterate among these steps more quickly; once you’re reasonably confident that the code you’ve written works as intended, you can do a manual test with a live car.</p>&#13;
<p class="indent">The <em>unit-test binary</em> will be a simple console application targeting the desktop operating system. In the unit-test binary, you’ll run a suite of unit tests that pass specific inputs into an <span class="literal">AutoBrake</span> and assert that it produces the expected results.</p>&#13;
<p class="indent">After consulting with your management team, you’ve collected the following requirements:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">AutoBrake</span> will consider the car’s initial speed zero.</li>&#13;
<li class="noindent"><span class="literal">AutoBrake</span> should have a configurable sensitivity threshold based on how many seconds are forecast until a collision. The sensitivity must not be less than 1 second. The default sensitivity is 5 seconds.</li>&#13;
<li class="noindent"><span class="literal">AutoBrake</span> must save the car’s speed in between <span class="literal">SpeedUpdate</span> observations.</li>&#13;
<li class="noindent">Each time <span class="literal">AutoBrake</span> observes a <span class="literal">CarDetected</span> event, it must publish a <span class="literal">BrakeCommand</span> if a collision is forecasted in less time than the configured sensitivity threshold.</li>&#13;
</ul>&#13;
<p class="indent">Because you have such a pristine requirements list, the next step is to try implementing the automatic braking service using <em>test-driven development (TDD)</em>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Because this book is about C++ and not about physics, your <span class="literal">AutoBrake</span> only works when a car is directly in front of you.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch10lev2sec5"><span epub:type="pagebreak" id="page_286"/><strong><em>Test-Driven Development</em></strong></h4>&#13;
<p class="noindent">At some point in the history of unit-testing adoption, some intrepid software engineers thought, “If I know I’m going to write a bunch of unit tests for this class, why not write the tests first?” This manner of writing software, known as TDD, underpins one of the great religious wars in the software engineering community. Vim or Emacs? Tabs or spaces? To use TDD or not to use TDD? This book humbly abstains from weighing in on these questions. But we’ll use TDD because it fits so naturally into a unit-testing discussion.</p>&#13;
<h5 class="h5" id="ch10lev3sec1"><strong>Advantages of TDD</strong></h5>&#13;
<p class="noindent">The process of writing a test that encodes a requirement <em>before</em> implementing the solution is the fundamental idea behind TDD. Proponents say that code written this way tends to be more modular, robust, clean, and well designed. Writing good tests is the best way to document your code for other developers. A good test suite is a fully working set of examples that never gets out of sync. It protects against regressions in functionality whenever you add new features.</p>&#13;
<p class="indent">Unit tests also serve as a fantastic way to submit bug reports by writing a unit test that fails. Once the bug is fixed, it will stay fixed because the unit test and the code that fixes the bug become part of the test suite.</p>&#13;
<h5 class="h5" id="ch10lev3sec2"><strong>Red-Green-Refactor</strong></h5>&#13;
<p class="noindent">TDD practitioners have a mantra: <em>red, green, refactor</em>. Red is the first step, and it means to implement a failing test. This is done for several reasons, principal of which is to make sure you’re actually testing something. You might be surprised how common it is to accidentally design a test that doesn’t make any assertions. Next, you implement code that makes the test pass. No more, no less. This turns the test from red to green. Now that you have working code and a passing test, you can refactor your production code. To refactor means to restructure existing code without changing its functionality. For example, you might find a more elegant way to write the same code, replace your code with a third-party library, or rewrite your code to have better performance characteristics.</p>&#13;
<p class="indent">If you accidentally break something, you’ll know immediately because your test suite will tell you. Then you continue to implement the remainder of the class using TDD. You can work on the collision threshold next.</p>&#13;
<h5 class="h5" id="ch10lev3sec3"><strong>Writing a Skeleton AutoBrake Class</strong></h5>&#13;
<p class="noindent">Before you can write tests, you need to write a <em>skeleton class</em>, which implements an interface but provides no functionality. It’s useful in TDD because you can’t compile a test without a shell of the class you’re testing.</p>&#13;
<p class="indent">Consider the skeleton <span class="literal">AutoBrake</span> class in <a href="ch10.xhtml#ch10ex04">Listing 10-4</a>.</p>&#13;
<pre>struct SpeedUpdate {&#13;
  double velocity_mps;&#13;
<span epub:type="pagebreak" id="page_287"/>};&#13;
&#13;
struct CarDetected {&#13;
  double distance_m;&#13;
  double velocity_mps;&#13;
};&#13;
&#13;
struct BrakeCommand {&#13;
  double time_to_collision_s;&#13;
};&#13;
&#13;
template &lt;typename T&gt;&#13;
struct AutoBrake {&#13;
  AutoBrake(const T&amp; publish<span class="ent">➊</span>) : publish{ publish } { }&#13;
  void observe(const SpeedUpdate&amp; cd) { } <span class="ent">➋</span>&#13;
  void observe(const CarDetected&amp; cd) { } <span class="ent">➌</span>&#13;
  void set_collision_threshold_s(double x) { <span class="ent">➍</span>&#13;
    collision_threshold_s = x;&#13;
  }&#13;
  double get_collision_threshold_s() const { <span class="ent">➎</span>&#13;
    return collision_threshold_s;&#13;
  }&#13;
  double get_speed_mps() const { <span class="ent">➏</span>&#13;
    return speed_mps;&#13;
  }&#13;
private:&#13;
  double collision_threshold_s;&#13;
  double speed_mps;&#13;
  const T&amp; publish;&#13;
};</pre>&#13;
<p class="listing"><a id="ch10ex04"/><em>Listing 10-4: A skeleton <span class="literal">AutoBrake</span> class</em></p>&#13;
<p class="indent">The <span class="literal">AutoBrake</span> class has a single constructor that takes the template parameter <span class="literal">publish</span> <span class="ent">➊</span>, which you save off into a <span class="literal">const</span> member. One of the requirements states that you’ll invoke <span class="literal">publish</span> with a <span class="literal">BrakeCommand</span>. Using the template parameter <span class="literal">T</span> allows you to program generically against any type that supports invocation with a <span class="literal">BrakeCommand</span>. You provide two different observe functions: one for each kind of event you want to subscribe to <span class="ent">➋➌</span>. Because this is just a skeleton class, no instructions are in the body. You just need a class that exposes the appropriate methods and compiles without error. Because the methods return <span class="literal">void</span>, you don’t even need a return statement.</p>&#13;
<p class="indent">You implement a setter <span class="ent">➍</span> and getter <span class="ent">➎</span>. These methods mediate interaction with the private member variable <span class="literal">collision_threshold_s</span>. One of the requirements implies a class invariant about valid values for <span class="literal">collision_threshold_s</span>. Because this value can change after construction, you can’t just use the constructor to establish a class invariant. You need a way to enforce this class invariant throughout the object’s lifetime. You can use the setter to perform validation before the class sets a member’s value. The getter allows you to read the value of <span class="literal">collision_threshold_s</span> without permitting modification. It enforces a kind of <em>external constness</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_288"/>Finally, you have a getter for <span class="literal">speed_mps</span> <span class="ent">➏</span> with no corresponding setter. This is similar to making <span class="literal">speed_mps</span> a public member, with the important difference that it would be possible to modify <span class="literal">speed_mps</span> from an external class if it were public.</p>&#13;
<h5 class="h5" id="ch10lev3sec4"><strong>Assertions: The Building Blocks of Unit Tests</strong></h5>&#13;
<p class="noindent">A unit test’s most essential component is the <em>assertion</em>, which checks that some condition is met. If the condition isn’t met, the enclosing test fails.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10ex05">Listing 10-5</a> implements an <span class="literal">assert_that</span> function that throws an exception with an error message whenever some Boolean <span class="literal">statement</span> is <span class="literal">false</span>.</p>&#13;
<pre>#include &lt;stdexcept&gt;&#13;
constexpr void assert_that(bool statement, const char* message) {&#13;
  if (!statement<span class="ent">➊</span>) throw std::runtime_error{ message }; <span class="ent">➋</span>&#13;
}&#13;
&#13;
int main() {&#13;
  assert_that(1 + 2 &gt; 2, "Something is profoundly wrong with the universe."); <span class="ent">➌</span>&#13;
  assert_that(24 == 42, "This assertion will generate an exception."); <span class="ent">➍</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">terminate called after throwing an instance of 'std::runtime_error'</span>&#13;
  <span class="color1">what():  This assertion will generate an exception. <span class="ent">➍</span></span></pre>&#13;
<p class="listing"><a id="ch10ex05"/><em>Listing 10-5: A program illustrating <span class="literal">assert_that</span> (Output is from a binary compiled by GCC v7.1.1.)</em></p>&#13;
<p class="indent">The <span class="literal">assert_that</span> function checks whether the <span class="literal">statement</span> <span class="ent">➊</span> parameter is <span class="literal">false</span>, in which case it throws an exception with the <span class="literal">message</span> parameter <span class="ent">➋</span>. The first assertion checks that <span class="literal">1 + 2 &gt; 2</span>, which passes <span class="ent">➌</span>. The second assertion checks that <span class="literal">24 == 42</span>, which fails and throws an uncaught exception <span class="ent">➍</span>.</p>&#13;
<h5 class="h5" id="ch10lev3sec5"><strong>Requirement: Initial Speed Is Zero</strong></h5>&#13;
<p class="noindent">Consider the first requirement that the car’s initial speed is zero. Before implementing this functionality in <span class="literal">AutoBrake</span>, you need to write a unit test that encodes this requirement. You’ll implement the unit test as a function that creates an <span class="literal">AutoBrake</span>, exercises the class, and makes assertions about the results. <a href="ch10.xhtml#ch10ex06">Listing 10-6</a> contains a unit test that encodes the requirement that the initial speed is zero.</p>&#13;
<pre>void initial_speed_is_zero() {&#13;
  AutoBrake auto_brake{ [](const BrakeCommand&amp;) {} }; <span class="ent">➊</span>&#13;
  assert_that(auto_brake.get_speed_mps() == 0L, "speed not equal 0"); <span class="ent">➋</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex06"/><em>Listing 10-6: A unit test encoding the requirement that the initial speed be zero</em></p>&#13;
<p class="indent">You first construct an <span class="literal">AutoBrake</span> with an empty <span class="literal">BrakeCommand publish</span> function <span class="ent">➊</span>. This unit test is only concerned with the initial value of <span class="literal">AutoBrake</span> <span epub:type="pagebreak" id="page_289"/>for car speed. Because this unit test is not concerned with how or when <span class="literal">AutoBrake</span> publishes a <span class="literal">BrakeCommand</span>, you give it the simplest argument that will still compile.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>A subtle but important feature of unit tests is that if you don’t care about some dependency of the unit under test, you can just provide an empty implementation that performs some innocuous, default behavior. This empty implementation is sometimes called a</em> stub.</p>&#13;
</div>&#13;
<p class="indent">In <span class="literal">initial_speed_is_zero</span>, you only want to assert that the initial speed of the car is zero and nothing else <span class="ent">➋</span>. You use the getter <span class="literal">get_speed_mps</span> and compare the return value to <span class="literal">0</span>. That’s all you have to do; <span class="literal">assert</span> will throw an exception if the initial speed isn't zero.</p>&#13;
<p class="indent">Now you need a way to run the unit tests.</p>&#13;
<h5 class="h5" id="ch10lev3sec6"><strong>Test Harnesses</strong></h5>&#13;
<p class="noindent">A <em>test harness</em> is code that executes unit tests. You can make a test harness that will invoke your unit test functions, like <span class="literal">initial_speed_is_zero</span>, and handle failed assertions gracefully. Consider the test harness <span class="literal">run_test</span> in <a href="ch10.xhtml#ch10ex07">Listing 10-7</a>.</p>&#13;
<pre>#include &lt;exception&gt;&#13;
--<span class="codeitalic1">snip</span>--&#13;
void run_test(void(*unit_test)(), const char* name) {&#13;
  try {&#13;
    unit_test(); <span class="ent">➊</span>&#13;
    printf("[+] Test %s successful.\n", name); <span class="ent">➋</span>&#13;
  } catch (const std::exception&amp; e) {&#13;
    printf("[-] Test failure in %s. %s.\n", name, e.what()); <span class="ent">➌</span>&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex07"/><em>Listing 10-7: A test harness</em></p>&#13;
<p class="indent">The <span class="literal">run_test</span> harness accepts a unit test as a function pointer named <span class="literal">unit_test</span> and invokes it within a <span class="literal">try</span>-<span class="literal">catch</span> statement <span class="ent">➊</span>. As long as <span class="literal">unit_test</span> doesn’t throw an exception, <span class="literal">run_test</span> will print a friendly message stating that the unit test passed before returning <span class="ent">➋</span>. If any <span class="literal">exception</span> is thrown, the test fails and prints a disapproving message <span class="ent">➌</span>.</p>&#13;
<p class="indent">To make a <em>unit-test program</em> that will run all of your unit tests, you place the <span class="literal">run_test</span> test harness inside the <span class="literal">main</span> function of a new program. All together, the unit-test program looks like <a href="ch10.xhtml#ch10ex08">Listing 10-8</a>.</p>&#13;
<pre>#include &lt;stdexcept&gt;&#13;
&#13;
struct SpeedUpdate {&#13;
  double velocity_mps;&#13;
};&#13;
&#13;
struct CarDetected {&#13;
<span epub:type="pagebreak" id="page_290"/>  double distance_m;&#13;
  double velocity_mps;&#13;
};&#13;
&#13;
struct BrakeCommand {&#13;
  double time_to_collision_s;&#13;
};&#13;
&#13;
template &lt;typename T&gt;&#13;
struct AutoBrake {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
constexpr void assert_that(bool statement, const char* message) {&#13;
  if (!statement) throw std::runtime_error{ message };&#13;
}&#13;
&#13;
void initial_speed_is_zero() {&#13;
  AutoBrake auto_brake{ [](const BrakeCommand&amp;) {} };&#13;
  assert_that(auto_brake.get_speed_mps() == 0L, "speed not equal 0");&#13;
}&#13;
&#13;
void run_test(void(*unit_test)(), const char* name) {&#13;
  try {&#13;
    unit_test();&#13;
    printf("[+] Test %s successful.\n", name);&#13;
  } catch (const std::exception&amp; e) {&#13;
    printf("[-] Test failure in %s. %s.\n", name, e.what());&#13;
  }&#13;
}&#13;
&#13;
int main() {&#13;
  run_test(initial_speed_is_zero, "initial speed is 0"); <span class="ent">➊</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">[-] Test failure in initial speed is 0. speed not equal 0. <span class="ent">➊</span></span></pre>&#13;
<p class="listing"><a id="ch10ex08"/><em>Listing 10-8: The unit-test program</em></p>&#13;
<p class="indent">When you compile and run this unit-test binary, you can see that the unit test <span class="literal">initial_speed_is_zero</span> fails with an informative message <span class="ent">➊</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Because the <span class="literal">AutoBrake</span> member <span class="literal">speed_mps</span> is uninitialized in <a href="ch10.xhtml#ch10ex08">Listing 10-8</a>, this program has undefined behavior. It’s not actually certain that the test will fail. The solution, of course, is that you shouldn’t write programs with undefined behavior.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch10lev3se7"><strong>Getting the Test to Pass</strong></h5>&#13;
<p class="noindent">To get <span class="literal">initial_speed_is_zero</span> to pass, all that’s required is to initialize <span class="literal">speed_mps</span> to zero in the constructor of <span class="literal">AutoBrake</span>:</p>&#13;
<pre>template &lt;typename T&gt;&#13;
struct AutoBrake {&#13;
<span epub:type="pagebreak" id="page_291"/>  AutoBrake(const T&amp; publish) : speed_mps{}<span class="ent">➊</span>, publish{ publish } { }&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};</pre>&#13;
<p class="indent">Simply add the initialization to zero <span class="ent">➊</span>. Now, if you update, compile, and run the unit-test program in <a href="ch10.xhtml#ch10ex08">Listing 10-8</a>, you’re greeted with more pleasant output:</p>&#13;
<pre>[+] Test initial speed is 0 successful.</pre>&#13;
<h5 class="h5" id="ch10lev3sec8"><strong>Requirement: Default Collision Threshold Is Five</strong></h5>&#13;
<p class="noindent">The default collision threshold needs to be 5. Consider the unit test in <a href="ch10.xhtml#ch10ex09">Listing 10-9</a>.</p>&#13;
<pre>void initial_sensitivity_is_five() {&#13;
  AutoBrake auto_brake{ [](const BrakeCommand&amp;) {} };&#13;
  assert_that(auto_brake.get_collision_threshold_s() == 5L,&#13;
              "sensitivity is not 5");&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex09"/><em>Listing 10-9: A unit test encoding the requirement that the initial speed be zero</em></p>&#13;
<p class="indent">You can insert this test into the test program, as shown in <a href="ch10.xhtml#ch10ex10">Listing 10-10</a>.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
int main() {&#13;
  run_test(initial_speed_is_zero, "initial speed is 0");&#13;
  run_test(initial_sensitivity_is_five, "initial sensitivity is 5");&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">[+] Test initial speed is 0 successful.</span>&#13;
<span class="color1">[-] Test failure in initial sensitivity is 5. sensitivity is not 5.</span></pre>&#13;
<p class="listing"><a id="ch10ex10"/><em>Listing 10-10: Adding the <span class="literal">initial-sensitivity-is-5 test</span> to the test harness</em></p>&#13;
<p class="indent">As expected, <a href="ch10.xhtml#ch10ex10">Listing 10-10</a> reveals that <span class="literal">initial_speed_is_zero</span> still passes and the new test <span class="literal">initial_sensitivity_is_five</span> fails.</p>&#13;
<p class="indent">Now, make it pass. Add the appropriate member initializer to <span class="literal">AutoBrake</span>, as demonstrated in <a href="ch10.xhtml#ch10ex11">Listing 10-11</a>.</p>&#13;
<pre>template &lt;typename T&gt;&#13;
struct AutoBrake {&#13;
  AutoBrake(const T&amp; publish)&#13;
    : collision_threshold_s{ 5 }, <span class="ent">➊</span>&#13;
      speed_mps{},&#13;
      publish{ publish } { }&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};</pre>&#13;
<p class="listing"><a id="ch10ex11"/><em>Listing 10-11: Updating <span class="literal">AutoBrake</span> to satisfy the collision threshold requirement</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_292"/>The new member initializer <span class="ent">➊</span> sets <span class="literal">collision_threshold_s</span> to 5. Recompiling the test program, you can see <span class="literal">initial_sensitivity_is_five</span> is now passing:</p>&#13;
<pre>[+] Test initial speed is 0 successful.&#13;
[+] Test initial sensitivity is 5 successful.</pre>&#13;
<p class="indent">Next, handle the class invariant that the sensitivity must be greater than 1.</p>&#13;
<h5 class="h5" id="ch10lev3sec9"><strong>Requirement: Sensitivity Must Always Be Greater Than One</strong></h5>&#13;
<p class="noindent">To encode the sensitivity validation errors using exceptions, you can build a test that expects an exception to be thrown when <span class="literal">collision_threshold_s</span> is set to a value less than 1, as <a href="ch10.xhtml#ch10ex12">Listing 10-12</a> shows.</p>&#13;
<pre>void sensitivity_greater_than_1() {&#13;
  AutoBrake auto_brake{ [](const BrakeCommand&amp;) {} };&#13;
  try {&#13;
    auto_brake.set_collision_threshold_s(0.5L); <span class="ent">➊</span>&#13;
  } catch (const std::exception&amp;) {&#13;
    return; <span class="ent">➋</span>&#13;
  }&#13;
  assert_that(false, "no exception thrown"); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex12"/><em>Listing 10-12: A test encoding the requirement that sensitivity is always greater than 1</em></p>&#13;
<p class="indent">You expect the <span class="literal">set_collision_threshold_s</span> method of <span class="literal">auto_brake</span> to throw an exception when called with a value of 0.5 <span class="ent">➊</span>. If it does, you catch the exception and return immediately from the test <span class="ent">➋</span>. If <span class="literal">set_collision_threshold_s</span> doesn’t throw an exception, you fail an assertion with the message <span class="literal">no excep</span><span class="literal">tion thrown</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">Next, add <span class="literal">sensitivity_greater_than_1</span> to the test harness, as demonstrated in <a href="ch10.xhtml#ch10ex13">Listing 10-13</a>.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
int main() {&#13;
  run_test(initial_speed_is_zero, "initial speed is 0");&#13;
  run_test(initial_sensitivity_is_five, "initial sensitivity is 5");&#13;
  run_test(sensitivity_greater_than_1, "sensitivity greater than 1"); <span class="ent">➊</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">[+] Test initial speed is 0 successful.</span>&#13;
<span class="color1">[+] Test initial sensitivity is 5 successful.</span>&#13;
<span class="color1">[-] Test failure in sensitivity greater than 1. no exception thrown. <span class="ent">➊</span></span></pre>&#13;
<p class="listing"><a id="ch10ex13"/><em>Listing 10-13: Adding <span class="literal">set_collision_threshold_s</span> to the test harness</em></p>&#13;
<p class="indent">As expected, the new unit test fails <span class="ent">➊</span>.</p>&#13;
<p class="indent">You can implement validation that will make the test pass, as <a href="ch10.xhtml#ch10ex14">Listing 10-14</a> shows.</p>&#13;
<pre><span epub:type="pagebreak" id="page_293"/>#include &lt;exception&gt;&#13;
--<span class="codeitalic1">snip</span>--&#13;
template &lt;typename T&gt;&#13;
struct AutoBrake {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
  void set_collision_threshold_s(double x) {&#13;
    if (x &lt; 1) throw std::exception{ "Collision less than 1." };&#13;
    collision_threshold_s = x;&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex14"/><em>Listing 10-14: Updating the <span class="literal">set_collision_threshold</span> method of <span class="literal">AutoBrake</span> to validate its input</em></p>&#13;
<p class="indent">Recompiling and executing the unit-test suite turns the test green:</p>&#13;
<pre>[+] Test initial speed is 0 successful.&#13;
[+] Test initial sensitivity is 5 successful.&#13;
[+] Test sensitivity greater than 1 successful.</pre>&#13;
<p class="indent">Next, you want to make sure that an <span class="literal">AutoBrake</span> saves the car’s speed in between each <span class="literal">SpeedUpdate</span>.</p>&#13;
<h5 class="h5" id="ch10lev3sec10"><strong>Requirement: Save the Car’s Speed Between Updates</strong></h5>&#13;
<p class="noindent">The unit test in <a href="ch10.xhtml#ch10ex15">Listing 10-15</a> encodes the requirement that an <span class="literal">AutoBrake</span> saves the car’s speed.</p>&#13;
<pre>void speed_is_saved() {&#13;
  AutoBrake auto_brake{ [](const BrakeCommand&amp;) {} }; <span class="ent">➊</span>&#13;
  auto_brake.observe(SpeedUpdate{ 100L }); <span class="ent">➋</span>&#13;
  assert_that(100L == auto_brake.get_speed_mps(), "speed not saved to 100"); <span class="ent">➌</span>&#13;
  auto_brake.observe(SpeedUpdate{ 50L });&#13;
  assert_that(50L == auto_brake.get_speed_mps(), "speed not saved to 50");&#13;
  auto_brake.observe(SpeedUpdate{ 0L });&#13;
  assert_that(0L == auto_brake.get_speed_mps(), "speed not saved to 0");&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex15"/><em>Listing 10-15: Encoding the requirement that an <span class="literal">AutoBrake</span> saves the car’s speed</em></p>&#13;
<p class="indent">After constructing an <span class="literal">AutoBrake</span> <span class="ent">➊</span>, you pass a <span class="literal">SpeedUpdate</span> with <span class="literal">velocity_mps</span> equal to 100 into its <span class="literal">observe</span> method <span class="ent">➋</span>. Next, you get the speed back from <span class="literal">auto_brake</span> using the <span class="literal">get_speed_mps</span> method and expect it is equal to 100 <span class="ent">➌</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>As a general rule, you should have a single assertion per test. This test violates the strictest interpretation of this rule, but it’s not violating its spirit. All of the assertions are examining the same, cohesive requirement, which is that the speed is saved whenever a <span class="literal">SpeedUpdate</span> is observed.</em></p>&#13;
</div>&#13;
<p class="indent">You add the test in <a href="ch10.xhtml#ch10ex15">Listing 10-15</a> to the test harness in the usual way, as demonstrated in <a href="ch10.xhtml#ch10ex16">Listing 10-16</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_294"/>--<span class="codeitalic1">snip</span>--&#13;
int main() {&#13;
  run_test(initial_speed_is_zero, "initial speed is 0");&#13;
  run_test(initial_sensitivity_is_five, "initial sensitivity is 5");&#13;
  run_test(sensitivity_greater_than_1, "sensitivity greater than 1");&#13;
  run_test(speed_is_saved, "speed is saved"); <span class="ent">➊</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">[+] Test initial speed is 0 successful.</span>&#13;
<span class="color1">[+] Test initial sensitivity is 5 successful.</span>&#13;
<span class="color1">[+] Test sensitivity greater than 1 successful.</span>&#13;
<span class="color1">[-] Test failure in speed is saved. speed not saved to 100. <span class="ent">➊</span></span></pre>&#13;
<p class="listing"><a id="ch10ex16"/><em>Listing 10-16: Adding the speed-saving unit test into the test harness</em></p>&#13;
<p class="indent">Unsurprisingly, the new test fails <span class="ent">➊</span>. To make this test pass, you implement the appropriate <span class="literal">observe</span> function:</p>&#13;
<pre>template &lt;typename T&gt;&#13;
struct AutoBrake {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
  void observe(const SpeedUpdate&amp; x) {&#13;
    speed_mps = x.velocity_mps; <span class="ent">➊</span>&#13;
  }&#13;
};</pre>&#13;
<p class="indent">You extract the <span class="literal">velocity_mps</span> from the <span class="literal">SpeedUpdate</span> and store it into the <span class="literal">speed_mps</span> member variable <span class="ent">➊</span>. Recompiling the test binary shows that the unit test now passes:</p>&#13;
<pre>[+] Test initial speed is 0 successful.&#13;
[+] Test initial sensitivity is 5 successful.&#13;
[+] Test sensitivity greater than 1 successful.&#13;
[+] Test speed is saved successful.</pre>&#13;
<p class="indent">Finally, you require that <span class="literal">AutoBrake</span> can compute the correct time to collision and, if appropriate, publish a <span class="literal">BrakeCommand</span> using the <span class="literal">publish</span> function.</p>&#13;
<h5 class="h5" id="ch10lev3sec11"><strong>Requirement: AutoBrake Publishes a BrakeCommand When Collision Detected</strong></h5>&#13;
<p class="noindent">The relevant equations for computing times to collision come directly from high school physics. First, you calculate your car’s relative velocity to the detected car:</p>&#13;
<div class="image"><img src="../images/fig294_1.jpg" alt="image"/></div>&#13;
<p class="indent">If your relative velocity is constant and positive, the cars will eventually collide. You can compute the time to such a collision as follows:</p>&#13;
<div class="image"><img src="../images/fig294_2.jpg" alt="image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_295"/>If Time<sub>Collision</sub> is greater than zero and less than or equal to <span class="literal">collision_threshold_s</span>, you invoke <span class="literal">publish</span> with a <span class="literal">BrakeCommand</span>. The unit test in <a href="ch10.xhtml#ch10ex17">Listing 10-17</a> sets the collision threshold to 10 seconds and then observes events that indicate a crash.</p>&#13;
<pre>void alert_when_imminent() {&#13;
  int brake_commands_published{}; <span class="ent">➊</span>&#13;
  AutoBrake auto_brake{&#13;
    [&amp;brake_commands_published<span class="ent">➋</span>](const BrakeCommand&amp;) {&#13;
      brake_commands_published++; <span class="ent">➌</span>&#13;
  } };&#13;
  auto_brake.set_collision_threshold_s(10L); <span class="ent">➍</span>&#13;
  auto_brake.observe(SpeedUpdate{ 100L }); <span class="ent">➎</span>&#13;
  auto_brake.observe(CarDetected{ 100L, 0L }); <span class="ent">➏</span>&#13;
  assert_that(brake_commands_published == 1, "brake commands published not&#13;
one"); <span class="ent">➐</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex17"/><em>Listing 10-17: Unit testing for brake events</em></p>&#13;
<p class="indent">Here, you initialize the local variable <span class="literal">brake_commands_published</span> to zero <span class="ent">➊</span>. This will keep track of the number of times that the <span class="literal">publish</span> callback is invoked. You pass this local variable by reference into the lambda used to construct your <span class="literal">auto_brake</span> <span class="ent">➋</span>. Notice that you increment <span class="literal">brake_commands_published</span> <span class="ent">➌</span>. Because the lambda captures by reference, you can inspect the value of <span class="literal">brake_commands_published</span> later in the unit test. Next, you set <span class="literal">set_collision_threshold</span> to 10 <span class="ent">➍</span>. You update the car’s speed to 100 meters per second <span class="ent">➎</span>, and then you detect a car 100 meters away traveling at 0 meters per second (it is stopped) <span class="ent">➏</span>. The <span class="literal">AutoBrake</span> class should determine that a collision will occur in 1 second. This should trigger a callback, which will increment <span class="literal">brake_commands_published</span>. The assertion <span class="ent">➐</span> ensures that the callback happens exactly once.</p>&#13;
<p class="indent">After adding to <span class="literal">main</span>, compile and run to yield a new red test:</p>&#13;
<pre>[+] Test initial speed is 0 successful.&#13;
[+] Test initial sensitivity is 5 successful.&#13;
[+] Test sensitivity greater than 1 successful.&#13;
[+] Test speed is saved successful.&#13;
[-] Test failure in alert when imminent. brake commands published not one.</pre>&#13;
<p class="indent">You can implement the code to make this test pass. <a href="ch10.xhtml#ch10ex18">Listing 10-18</a> provides all the code needed to issue brake commands.</p>&#13;
<pre>template &lt;typename T&gt;&#13;
struct AutoBrake {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
  void observe(const CarDetected&amp; cd) {&#13;
    const auto relative_velocity_mps = speed_mps - cd.velocity_mps; <span class="ent">➊</span>&#13;
    const auto time_to_collision_s = cd.distance_m / relative_velocity_mps; <span class="ent">➋</span>&#13;
    if (time_to_collision_s &gt; 0 &amp;&amp;  <span class="ent">➌</span>&#13;
        time_to_collision_s &lt;= collision_threshold_s <span class="ent">➍</span>) {&#13;
<span epub:type="pagebreak" id="page_296"/>      publish(BrakeCommand{ time_to_collision_s }); <span class="ent">➎</span>&#13;
    }&#13;
  }&#13;
};</pre>&#13;
<p class="listing"><a id="ch10ex18"/><em>Listing 10-18: Code implementing the braking functionality</em></p>&#13;
<p class="indent">First, you calculate the relative velocity <span class="ent">➊</span>. Next, you use this value to compute the time to collision <span class="ent">➋</span>. If this value is positive <span class="ent">➌</span> and less than or equal to the collision threshold <span class="ent">➍</span>, you publish a <span class="literal">BrakeCommand</span> <span class="ent">➎</span>.</p>&#13;
<p class="indent">Recompiling and running the unit-test suite yields success:</p>&#13;
<pre>[+] Test initial speed is 0 successful.&#13;
[+] Test initial sensitivity is 5 successful.&#13;
[+] Test sensitivity greater than 1 successful.&#13;
[+] Test speed is saved successful.&#13;
[+] Test alert when imminent successful.</pre>&#13;
<p class="indent">Finally, you need to check that the <span class="literal">AutoBrake</span> will not invoke <span class="literal">publish</span> with a <span class="literal">BrakeCommand</span> if a collision will occur later than <span class="literal">collision_threshold_s</span>. You can repurpose the <span class="literal">alert_when_imminent</span> unit test, as in <a href="ch10.xhtml#ch10ex19">Listing 10-19</a>.</p>&#13;
<pre>void no_alert_when_not_imminent() {&#13;
  int brake_commands_published{};&#13;
  AutoBrake auto_brake{&#13;
    [&amp;brake_commands_published](const BrakeCommand&amp;) {&#13;
      brake_commands_published++;&#13;
  } };&#13;
  auto_brake.set_collision_threshold_s(2L);&#13;
  auto_brake.observe(SpeedUpdate{ 100L });&#13;
  auto_brake.observe(CarDetected{ 1000L, 50L });&#13;
  assert_that(brake_commands_published == 0 <span class="ent">➊</span>, "brake command published");&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex19"/><em>Listing 10-19: Testing that the car doesn’t issue a <span class="literal">BrakeCommand</span> if a collision isn’t anticipated within the collision threshold</em></p>&#13;
<p class="indent">This changes the setup. Your car’s threshold is set to 2 seconds with a speed of 100 meters per second. A car is detected 1,000 meters away traveling 50 meters per second. The <span class="literal">AutoBrake</span> class should forecast a collision in 20 seconds, which is more than the 2-second threshold. You also change the assertion <span class="ent">➊</span>.</p>&#13;
<p class="indent">After adding this test to <span class="literal">main</span> and running the unit-test suite, you have the following:</p>&#13;
<pre>[+] Test initial speed is 0 successful.&#13;
[+] Test initial sensitivity is 5 successful.&#13;
[+] Test sensitivity greater than 1 successful.&#13;
[+] Test speed is saved successful.&#13;
[+] Test alert when imminent successful.&#13;
[+] Test no alert when not imminent successful. <span class="ent">➊</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_297"/>For this test case, you already have all the code needed for this test to pass <span class="ent">➊</span>. Not having a failing test at the outset bends the red, green, refactor mantra, but that’s okay. This test case is closely related to <span class="literal">alert_when_imminent</span>. The point of TDD is not dogmatic adherence to strict rules. TDD is a set of reasonably loose guidelines that helps you write better software.</p>&#13;
<h4 class="h4" id="ch10lev2sec6"><strong><em>Adding a Service-Bus Interface</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">AutoBrake</span> class has a few dependencies: <span class="literal">CarDetected, SpeedUpdated</span>, and a generic dependency on some <span class="literal">publish</span> object callable with a single <span class="literal">BrakeCommand</span> parameter. The <span class="literal">CarDetected</span> and <span class="literal">SpeedUpdated</span> classes are plain-old-data types that are easy to use directly in your unit tests. The <span class="literal">publish</span> object is a little more complicated to initialize, but thanks to lambdas, it’s really not bad.</p>&#13;
<p class="indent">Suppose you want to refactor the service bus. You want to accept a <span class="literal">std::function</span> to subscribe to each service, as in the new <span class="literal">IServiceBus</span> interface in <a href="ch10.xhtml#ch10ex20">Listing 10-20</a>.</p>&#13;
<pre>#include &lt;functional&gt;&#13;
&#13;
using SpeedUpdateCallback = std::function&lt;void(const SpeedUpdate&amp;)&gt;;&#13;
using CarDetectedCallback = std::function&lt;void(const CarDetected&amp;)&gt;;&#13;
&#13;
struct IServiceBus {&#13;
  virtual ~IServiceBus() = default;&#13;
  virtual void publish(const BrakeCommand&amp;) = 0;&#13;
  virtual void subscribe(SpeedUpdateCallback) = 0;&#13;
  virtual void subscribe(CarDetectedCallback) = 0;&#13;
};</pre>&#13;
<p class="listing"><a id="ch10ex20"/><em>Listing 10-20: The <span class="literal">IServiceBus</span> interface</em></p>&#13;
<p class="indent">Because <span class="literal">IServiceBus</span> is an interface, you don’t need to know the implementation details. It’s a nice solution because it allows you to do your own wiring into the service bus. But there’s a problem. How do you test <span class="literal">AutoBrake</span> in isolation? If you try to use the production bus, you’re firmly in integration-test territory, and you want easy-to-configure, isolated unit tests.</p>&#13;
<h5 class="h5" id="ch10lev3sec12"><strong>Mocking Dependencies</strong></h5>&#13;
<p class="noindent">Fortunately, you don’t depend on the implementation: you depend on the interface. You can create a mock class that implements the <span class="literal">IServiceBus</span> interface and use this within <span class="literal">AutoBrake</span>. A mock is a special implementation that you generate for the express purpose of testing a class that depends on the mock.</p>&#13;
<p class="indent">Now when you exercise <span class="literal">AutoBrake</span> in your unit tests, <span class="literal">AutoBrake</span> interacts with the mock rather than the production service bus. Because you have complete control over the mock’s implementation and the mock is a <span epub:type="pagebreak" id="page_298"/>unit-test-specific class, you have major flexibility in how you can test classes that depend on the interface:</p>&#13;
<ul>&#13;
<li class="noindent">You can capture arbitrarily detailed information about how the mock gets called. This can include information about the parameters and the number of times the mock was called, for example.</li>&#13;
<li class="noindent">You can perform arbitrary computation in the mock.</li>&#13;
</ul>&#13;
<p class="indent">In other words, you have complete control over the inputs and the outputs of the dependency of <span class="literal">AutoBrake</span>. How does <span class="literal">AutoBrake</span> handle the case where the service bus throws an out-of-memory exception inside of a <span class="literal">publish</span> invocation? You can unit test that. How many times did <span class="literal">AutoBrake</span> register a callback for <span class="literal">SpeedUpdates</span>? Again, you can unit test that.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10ex21">Listing 10-21</a> presents a simple mock class you can use for your unit tests.</p>&#13;
<pre>struct MockServiceBus : IServiceBus {&#13;
  void publish(const BrakeCommand&amp; cmd) override {&#13;
    commands_published++; <span class="ent">➊</span>&#13;
    last_command = cmd; <span class="ent">➋</span>&#13;
  }&#13;
  void subscribe(SpeedUpdateCallback callback) override {&#13;
    speed_update_callback = callback; <span class="ent">➌</span>&#13;
  }&#13;
  void subscribe(CarDetectedCallback callback) override {&#13;
    car_detected_callback = callback; <span class="ent">➍</span>&#13;
  }&#13;
  BrakeCommand last_command{};&#13;
  int commands_published{};&#13;
  SpeedUpdateCallback speed_update_callback{};&#13;
  CarDetectedCallback car_detected_callback{};&#13;
};</pre>&#13;
<p class="listing"><a id="ch10ex21"/><em>Listing 10-21: A definition of <span class="literal">MockServiceBus</span></em></p>&#13;
<p class="indent">The <span class="literal">publish</span> method records the number of times a <span class="literal">BrakeCommand</span> is published <span class="ent">➊</span> and the <span class="literal">last_command</span> that was published <span class="ent">➋</span>. Each time <span class="literal">AutoBrake</span> publishes a command to the service bus, you’ll see updates to the members of <span class="literal">MockServiceBus</span>. You’ll see in a moment that this allows for some very powerful assertions about how <span class="literal">AutoBrake</span> behaved during a test. You save the callback functions used to subscribe to the service bus <span class="ent">➌</span><span class="ent">➍</span>. This allows you to simulate events by manually invoking these callbacks on the mock object.</p>&#13;
<p class="indent">Now, you can turn your attention to refactoring <span class="literal">AutoBrake</span>.</p>&#13;
<h5 class="h5" id="ch10lev3sec13"><strong>Refactoring AutoBrake</strong></h5>&#13;
<p class="noindent"><a href="ch10.xhtml#ch10ex22">Listing 10-22</a> updates <span class="literal">AutoBrake</span> with the minimum changes necessary to get the unit-test binary compiling again (but not necessarily passing!).</p>&#13;
<pre>#include &lt;exception&gt;&#13;
--<span class="codeitalic1">snip</span>--&#13;
struct AutoBrake { <span class="ent">➊</span>&#13;
<span epub:type="pagebreak" id="page_299"/>  AutoBrake(IServiceBus&amp; bus) <span class="ent">➋</span>&#13;
    : collision_threshold_s{ 5 },&#13;
      speed_mps{} {&#13;
  }&#13;
  void set_collision_threshold_s(double x) {&#13;
    if (x &lt; 1) throw std::exception{ "Collision less than 1." };&#13;
    collision_threshold_s = x;&#13;
  }&#13;
  double get_collision_threshold_s() const {&#13;
    return collision_threshold_s;&#13;
  }&#13;
  double get_speed_mps() const {&#13;
    return speed_mps;&#13;
  }&#13;
private:&#13;
  double collision_threshold_s;&#13;
  double speed_mps;&#13;
};</pre>&#13;
<p class="listing"><a id="ch10ex22"/><em>Listing 10-22: A refactored <span class="literal">AutoBrake</span> skeleton taking an <span class="literal">IServiceBus</span> reference</em></p>&#13;
<p class="indent">Notice that all the <span class="literal">observe</span> functions have been removed. Additionally, <span class="literal">AutoBrake</span> is no longer a template <span class="ent">➊</span>. Rather, it accepts an <span class="literal">IServiceBus</span> reference in its constructor <span class="ent">➋</span>.</p>&#13;
<p class="indent">You’ll also need to update your unit tests to get the test suite compiling again. One TDD-inspired approach is to comment out all the tests that are not compiling and update <span class="literal">AutoBrake</span> so all the failing unit tests pass. Then, one by one, uncomment each unit test. You reimplement each unit test using the new <span class="literal">IServiceBus</span> mock, then update <span class="literal">AutoBrake</span> so the tests pass.</p>&#13;
<p class="indent">Let’s give it a try.</p>&#13;
<h5 class="h5" id="ch10lev3sec14"><strong>Refactoring the Unit Tests</strong></h5>&#13;
<p class="noindent">Because you’ve changed the way to construct an <span class="literal">AutoBrake</span> object, you’ll need to reimplement every test. The first three are easy: <a href="ch10.xhtml#ch10ex23">Listing 10-23</a> just plops the mock into the <span class="literal">AutoBrake</span> constructor.</p>&#13;
<pre>void initial_speed_is_zero() {&#13;
  MockServiceBus bus{}; <span class="ent">➊</span>&#13;
  AutoBrake auto_brake{ bus }; <span class="ent">➋</span>&#13;
  assert_that(auto_brake.get_speed_mps() == 0L, "speed not equal 0");&#13;
}&#13;
&#13;
void initial_sensitivity_is_five() {&#13;
  MockServiceBus bus{}; <span class="ent">➊</span>&#13;
  AutoBrake auto_brake{ bus }; <span class="ent">➋</span>&#13;
  assert_that(auto_brake.get_collision_threshold_s() == 5,&#13;
              "sensitivity is not 5");&#13;
}&#13;
&#13;
void sensitivity_greater_than_1() {&#13;
  MockServiceBus bus{}; <span class="ent">➊</span>&#13;
  AutoBrake auto_brake{ bus }; <span class="ent">➋</span>&#13;
<span epub:type="pagebreak" id="page_300"/>  try {&#13;
    auto_brake.set_collision_threshold_s(0.5L);&#13;
  } catch (const std::exception&amp;) {&#13;
    return;&#13;
  }&#13;
  assert_that(false, "no exception thrown");&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex23"/><em>Listing 10-23: Reimplemented unit-test functions using the <span class="literal">MockServiceBus</span></em></p>&#13;
<p class="indent">Because these three tests deal with functionality not related to the service bus, it’s unsurprising that you didn’t need to make any major changes to <span class="literal">AutoBrake</span>. All you need to do is create a <span class="literal">MockServiceBus</span> <span class="ent">➊</span> and pass it into the <span class="literal">AutoBrake</span> constructor <span class="ent">➋</span>. Running the unit-test suite, you have the following:</p>&#13;
<pre>[+] Test initial speed is 0 successful.&#13;
[+] Test initial sensitivity is 5 successful.&#13;
[+] Test sensitivity greater than 1 successful.</pre>&#13;
<p class="indent">Next, look at the <span class="literal">speed_is_saved</span> test. The <span class="literal">AutoBrake</span> class no longer exposes an <span class="literal">observe</span> function, but because you’ve saved the <span class="literal">SpeedUpdateCallback</span> on the mock service bus, you can invoke the callback directly. If <span class="literal">AutoBrake</span> subscribed properly, this callback will update the car’s speed, and you’ll see the effects when you call the <span class="literal">get_speed_mps</span> method. <a href="ch10.xhtml#ch10ex24">Listing 10-24</a> contains the refactor.</p>&#13;
<pre>void speed_is_saved() {&#13;
  MockServiceBus bus{};&#13;
  AutoBrake auto_brake{ bus };&#13;
&#13;
  bus.speed_update_callback(SpeedUpdate{ 100L }); <span class="ent">➊</span>&#13;
  assert_that(100L == auto_brake.get_speed_mps(), "speed not saved to 100"); <span class="ent">➋</span>&#13;
  bus.speed_update_callback(SpeedUpdate{ 50L });&#13;
  assert_that(50L == auto_brake.get_speed_mps(), "speed not saved to 50");&#13;
  bus.speed_update_callback(SpeedUpdate{ 0L });&#13;
  assert_that(0L == auto_brake.get_speed_mps(), "speed not saved to 0");&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex24"/><em>Listing 10-24: Reimplemented <span class="literal">speed_is_saved</span> unit-test function using the <span class="literal">MockServiceBus</span></em></p>&#13;
<p class="indent">The test didn’t change too much from the previous implementation. You invoke the <span class="literal">speed_update_callback function</span> stored on the mock bus <span class="ent">➊</span>. You make sure that the <span class="literal">AutoBrake</span> object updated the car’s speed correctly <span class="ent">➋</span>. Compiling and running the resulting unit-test suite results in the following output:</p>&#13;
<pre>[+] Test initial speed is 0 successful.&#13;
[+] Test initial sensitivity is 5 successful.&#13;
[+] Test sensitivity greater than 1 successful.&#13;
[-] Test failure in speed is saved. bad function call.</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_301"/>Recall that the <span class="literal">bad function call</span> message comes from the <span class="literal">std::bad_func</span><span class="literal">tion_call</span> exception. This is expected: you still need to subscribe from <span class="literal">AutoBrake</span>, so <span class="literal">std::function</span> throws an exception when you invoke it.</p>&#13;
<p class="indent">Consider the approach in <a href="ch10.xhtml#ch10ex25">Listing 10-25</a>.</p>&#13;
<pre>struct AutoBrake {&#13;
  AutoBrake(IServiceBus&amp; bus)&#13;
    : collision_threshold_s{ 5 },&#13;
    speed_mps{} {&#13;
    bus.subscribe([this](const SpeedUpdate&amp; update) {&#13;
      speed_mps = update.velocity_mps;&#13;
    });&#13;
  }&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex25"/><em>Listing 10-25: Subscribing the <span class="literal">AutoBrake</span> to speed updates from the <span class="literal">IServiceBus</span></em></p>&#13;
<p class="indent">Thanks to <span class="literal">std::function</span>, you can pass your callback into the subscribe method of <span class="literal">bus</span> as a lambda that captures <span class="literal">speed_mps</span>. (Notice that you don’t need to save a copy of <span class="literal">bus</span>.) Recompiling and running the unit-test suite yields the following:</p>&#13;
<pre>[+] Test initial speed is 0 successful.&#13;
[+] Test initial sensitivity is 5 successful.&#13;
[+] Test sensitivity greater than 1 successful.&#13;
[+] Test speed is saved successful.</pre>&#13;
<p class="indent">Next, you have the first of the alert-related unit tests, <span class="literal">no_alert_when_not_imminent</span>. <a href="ch10.xhtml#ch10ex26">Listing 10-26</a> highlights one way to update this test with the new architecture.</p>&#13;
<pre>void no_alert_when_not_imminent() {&#13;
  MockServiceBus bus{};&#13;
  AutoBrake auto_brake{ bus };&#13;
  auto_brake.set_collision_threshold_s(2L);&#13;
  bus.speed_update_callback(SpeedUpdate{ 100L }); <span class="ent">➊</span>&#13;
  bus.car_detected_callback(CarDetected{ 1000L, 50L }); <span class="ent">➋</span>&#13;
  assert_that(bus.commands_published == 0, "brake commands were published");&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex26"/><em>Listing 10-26: Updating the <span class="literal">no_alert_when_not_imminent</span> test with the <span class="literal">IServiceBus</span></em></p>&#13;
<p class="indent">As in the <span class="literal">speed_is_saved</span> test, you invoke the callbacks on the <span class="literal">bus</span> mock to simulate events on the service bus <span class="ent">➊➋</span>. Recompiling and running the unit-test suite results in an expected failure.</p>&#13;
<pre>[+] Test initial speed is 0 successful.&#13;
[+] Test initial sensitivity is 5 successful.&#13;
[+] Test sensitivity greater than 1 successful.&#13;
[+] Test speed is saved successful.&#13;
[-] Test failure in no alert when not imminent. bad function call.</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_302"/>You need to subscribe with <span class="literal">CarDetectedCallback</span>. You can add this into the <span class="literal">AutoBus</span> constructor, as demonstrated in <a href="ch10.xhtml#ch10ex27">Listing 10-27</a>.</p>&#13;
<pre>struct AutoBrake {&#13;
  AutoBrake(IServiceBus&amp; bus)&#13;
    : collision_threshold_s{ 5 },&#13;
    speed_mps{} {&#13;
    bus.subscribe([this](const SpeedUpdate&amp; update) {&#13;
      speed_mps = update.velocity_mps;&#13;
    });&#13;
    bus.subscribe([this<span class="ent">➊</span>, &amp;bus<span class="ent">➋</span>](const CarDetected&amp; cd) {&#13;
      const auto relative_velocity_mps = speed_mps - cd.velocity_mps;&#13;
      const auto time_to_collision_s = cd.distance_m / relative_velocity_mps;&#13;
      if (time_to_collision_s &gt; 0 &amp;&amp;&#13;
          time_to_collision_s &lt;= collision_threshold_s) {&#13;
        bus.publish(BrakeCommand{ time_to_collision_s }); <span class="ent">➌</span>&#13;
      }&#13;
    });&#13;
  }&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex27"/><em>Listing 10-27: An updated <span class="literal">AutoBrake</span> constructor that wires itself into the service bus</em></p>&#13;
<p class="indent">All you’ve done is port over the original <span class="literal">observe</span> method corresponding to <span class="literal">CarDetected</span> events. The lambda captures <span class="literal">this</span> <span class="ent">➊</span> and <span class="literal">bus</span> <span class="ent">➋</span> by reference in the callback. Capturing <span class="literal">this</span> allows you to compute collision times, whereas capturing <span class="literal">bus</span> allows you to publish a <span class="literal">BrakeCommand</span> <span class="ent">➌</span> if the conditions are satisfied. Now the unit-test binary outputs the following:</p>&#13;
<pre>[+] Test initial speed is 0 successful.&#13;
[+] Test initial sensitivity is 5 successful.&#13;
[+] Test sensitivity greater than 1 successful.&#13;
[+] Test speed is saved successful.&#13;
[+] Test no alert when not imminent successful.</pre>&#13;
<p class="indent">Finally, turn on the last test, <span class="literal">alert_when_imminent</span>, as displayed in <a href="ch10.xhtml#ch10ex28">Listing 10-28</a>.</p>&#13;
<pre>void alert_when_imminent() {&#13;
  MockServiceBus bus{};&#13;
  AutoBrake auto_brake{ bus };&#13;
  auto_brake.set_collision_threshold_s(10L);&#13;
  bus.speed_update_callback(SpeedUpdate{ 100L });&#13;
  bus.car_detected_callback(CarDetected{ 100L, 0L });&#13;
  assert_that(bus.commands_published == 1, "1 brake command was not published");&#13;
  assert_that(bus.last_command.time_to_collision_s == 1L,&#13;
              "time to collision not computed correctly."); <span class="ent">➊</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex28"/><em>Listing 10-28: Refactoring the <span class="literal">alert_when_imminent</span> unit test</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_303"/>In <span class="literal">MockServiceBus</span>, you actually saved the last <span class="literal">BrakeCommand</span> published to the bus into a member. In the test, you can use this member to verify that the time to collision was computed correctly. If a car is going 100 meters per second, it will take 1 second to hit a stationary car parked 100 meters away. You check that the <span class="literal">BrakeCommand</span> has the correct time to collision recorded by referring to the <span class="literal">time_to_collision_s</span> field on our mock <span class="literal">bus</span> <span class="ent">➊</span>.</p>&#13;
<p class="indent">Recompiling and rerunning, you finally have the test suite fully green again:</p>&#13;
<pre>[+] Test initial speed is 0 successful.&#13;
[+] Test initial sensitivity is 5 successful.&#13;
[+] Test sensitivity greater than 1 successful.&#13;
[+] Test speed is saved successful.&#13;
[+] Test no alert when not imminent successful.&#13;
[+] Test alert when imminent successful.</pre>&#13;
<p class="indent">Refactoring is now complete.</p>&#13;
<h5 class="h5" id="ch10lev3sec15"><strong>Reevaluating the Unit-Testing Solution</strong></h5>&#13;
<p class="noindent">Looking back at the unit-testing solution, you can identify several components that have nothing to do with <span class="literal">AutoBrake</span>. These are general purpose unit-testing components that you could reuse in future unit tests. Recall the two helper functions created in <a href="ch10.xhtml#ch10ex29">Listing 10-29</a>.</p>&#13;
<pre>#include &lt;stdexcept&gt;&#13;
#include &lt;cstdio&gt;&#13;
&#13;
void assert_that(bool statement, const char* message) {&#13;
  if (!statement) throw std::runtime_error{ message };&#13;
}&#13;
&#13;
void run_test(void(*unit_test)(), const char* name) {&#13;
  try {&#13;
    unit_test();&#13;
    printf("[+] Test %s successful.\n", name);&#13;
    return;&#13;
  } catch (const std::exception&amp; e) {&#13;
    printf("[-] Test failure in %s. %s.\n", name, e.what());&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex29"/><em>Listing 10-29: An austere unit-testing framework</em></p>&#13;
<p class="indent">These two functions reflect two fundamental aspects of unit testing: making assertions and running tests. Rolling your own simple <span class="literal">assert_that</span> function and <span class="literal">run_test</span> harness works, but this approach doesn’t scale very well. You can do a lot better by leaning on a unit-testing framework.</p>&#13;
<h3 class="h3" id="ch10lev1sec3"><span epub:type="pagebreak" id="page_304"/><strong>Unit-Testing and Mocking Frameworks</strong></h3>&#13;
<p class="noindent"><em>Unit-testing frameworks</em> provide commonly used functions and the scaffolding you need to tie your tests together into a user-friendly program. These frameworks provide a wealth of functionality that helps you create concise, expressive tests. This section offers a tour of several popular unit-testing and mocking frameworks.</p>&#13;
<h4 class="h4" id="ch10lev2sec7"><strong><em>The Catch Unit-Testing Framework</em></strong></h4>&#13;
<p class="noindent">One of the most straightforward unit-testing frameworks, Catch by Phil Nash, is available at <a href="https://github.com/catchorg/Catch2/">https://github.com/catchorg/Catch2/</a>. Because it's a header-only library, you can set up Catch by downloading the single-header version and including it in each translation unit that contains unit-testing code.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>At press time, Catch’s latest version is 2.9.1.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch10lev3sec16"><strong>Defining an Entry Point</strong></h5>&#13;
<p class="noindent">Tell Catch to provide your test binary’s entry point with <span class="literal">#define CATCH_CONFIG_MAIN</span>. Together, the Catch unit-test suite starts as follows:</p>&#13;
<pre>#define CATCH_CONFIG_MAIN&#13;
#include "catch.hpp"</pre>&#13;
<p class="indent">That’s it. Within the <span class="literal">catch.hpp</span> header, it looks for the <span class="literal">CATCH_CONFIG_MAIN</span> preprocessor definition. When present, Catch will add in a <span class="literal">main</span> function so you don’t have to. It will automatically grab all the unit tests you’ve defined and wrap them with a nice harness.</p>&#13;
<h5 class="h5" id="ch10lev3sec17"><strong>Defining Test Cases</strong></h5>&#13;
<p class="noindent">Earlier, in “Unit Tests” on <a href="ch10.xhtml#page_282">page 282</a>, you defined a separate function for each unit test. Then you would pass a pointer to this function as the first parameter to <span class="literal">run_test</span>. You passed the name of the test as the second parameter, which is a bit redundant because you’ve already provided a descriptive name for the function pointed to by the first argument. Finally, you had to implement your own <span class="literal">assert</span> function. Catch handles all of this ceremony implicitly. For each unit test, you use the <span class="literal">TEST_CASE</span> macro, and Catch handles all the integration for you.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10ex30">Listing 10-30</a> illustrates how to build a trivial Catch unit test program.</p>&#13;
<pre>#define CATCH_CONFIG_MAIN&#13;
#include "catch.hpp"&#13;
&#13;
TEST_CASE("AutoBrake") { <span class="ent">➊</span>&#13;
  // Unit test here&#13;
}&#13;
<span epub:type="pagebreak" id="page_305"/>--------------------------------------------------------------------------&#13;
<span class="color1">==========================================================================</span>&#13;
<span class="color1">test cases: 1 | 1 passed <span class="ent">➊</span></span>&#13;
<span class="color1">assertions: - none - <span class="ent">➋</span></span></pre>&#13;
<p class="listing"><a id="ch10ex30"/><em>Listing 10-30: A simple Catch unit-test program</em></p>&#13;
<p class="indent">The Catch entry point detects that you declared one test called <span class="literal">AutoBrake</span> <span class="ent">➊</span>. It also provides a warning that you haven’t made any assertions <span class="ent">➋</span>.</p>&#13;
<h5 class="h5" id="ch10lev3sec18"><strong>Making Assertions</strong></h5>&#13;
<p class="noindent">Catch comes with a built-in assertion that features two distinct families of assertion macros: <span class="literal">REQUIRE</span> and <span class="literal">CHECK</span>. The difference between them is that <span class="literal">REQUIRE</span> will fail a test immediately, whereas <span class="literal">CHECK</span> will allow the test to run to completion (but still cause a failure). <span class="literal">CHECK</span> can be useful sometimes when groups of related assertions that fail lead the programmer down the right path of debugging problems. Also included are <span class="literal">REQUIRE_FALSE</span> and <span class="literal">CHECK_FALSE</span>, which check that the contained statement evaluates to false rather than true. In some situations, you might find this a more natural way to represent a requirement.</p>&#13;
<p class="indent">All you need to do is wrap a Boolean expression with the <span class="literal">REQUIRE</span> macro. If the expression evaluates to false, the assertion fails. You provide an <em>assertion expression</em> that evaluates to true if the assertion passes and false if it fails:</p>&#13;
<pre>REQUIRE(assertion-expression);</pre>&#13;
<p class="indent">Let’s look at how to combine <span class="literal">REQUIRE</span> with a <span class="literal">TEST_CASE</span> to build a unit test.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Because it’s by far the most common Catch assertion, we’ll use <span class="literal">REQUIRE</span> here. Refer to the Catch documentation for more information.</em></p>&#13;
</div>&#13;
<h5 class="h5" id="ch10lev3sec19"><strong>Refactoring the initial_speed_is_zero Test to Catch</strong></h5>&#13;
<p class="noindent"><a href="ch10.xhtml#ch10ex31">Listing 10-31</a> shows the <span class="literal">initial_speed_is_zero</span> test refactored to use Catch.</p>&#13;
<pre>#define CATCH_CONFIG_MAIN&#13;
#include "catch.hpp"&#13;
#include &lt;functional&gt;&#13;
&#13;
struct IServiceBus {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct MockServiceBus : IServiceBus {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct AutoBrake {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
<span epub:type="pagebreak" id="page_306"/>TEST_CASE<span class="ent">➊</span>("initial car speed is zero"<span class="ent">➋</span>) {&#13;
  MockServiceBus bus{};&#13;
  AutoBrake auto_brake{ bus };&#13;
  REQUIRE(auto_brake.get_speed_mps() == 0); <span class="ent">➌</span>&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex31"/><em>Listing 10-31: An <span class="literal">initial_speed_is_zero</span> unit test refactored to use Catch</em></p>&#13;
<p class="indent">You use the <span class="literal">TEST_CASE</span> macro to define a new unit test <span class="ent">➊</span>. The test is described by its sole parameter <span class="ent">➋</span>. Inside the body of the <span class="literal">TEST_CASE</span> macro, you proceed with the unit test. You also see the <span class="literal">REQUIRE</span> macro in action <span class="ent">➌</span>. To see how Catch handles failed tests, comment out the <span class="literal">speed_mps</span> member initializer to cause a failing test and observe the program’s output, as shown in <a href="ch10.xhtml#ch10ex32">Listing 10-32</a>.</p>&#13;
<pre>struct AutoBrake {&#13;
  AutoBrake(IServiceBus&amp; bus)&#13;
    : collision_threshold_s{ 5 }/*,&#13;
    speed_mps{} */{ <span class="ent">➊</span>&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};</pre>&#13;
<p class="listing"><a id="ch10ex32"/><em>Listing 10-32: Intentionally commenting out the <span class="literal">speed_mps</span> member initializer to cause test failures (using Catch)</em></p>&#13;
<p class="indent">The appropriate member initializer <span class="ent">➊</span> is commented out, resulting in a test failure. Rerunning the Catch test suite in <a href="ch10.xhtml#ch10ex31">Listing 10-31</a> yields the output in <a href="ch10.xhtml#ch10ex33">Listing 10-33</a>.</p>&#13;
<pre>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&#13;
catch_example.exe is a Catch v2.0.1 host application.&#13;
Run with -? for options&#13;
&#13;
------------------------------------------------------------------------------&#13;
initial car speed is zero&#13;
------------------------------------------------------------------------------&#13;
c:\users\jalospinoso\catch-test\main.cpp(82)&#13;
..............................................................................&#13;
&#13;
c:\users\jalospinoso\catch-test\main.cpp(85):<span class="ent">➊</span> FAILED:&#13;
  REQUIRE( auto_brake.get_speed_mps()L == 0 ) <span class="ent">➋</span>&#13;
with expansion:&#13;
  -92559631349317830736831783200707727132248687965119994463780864.0 <span class="ent">➌</span>&#13;
  ==&#13;
  0&#13;
&#13;
==============================================================================&#13;
test cases: 1 | 1 failed&#13;
assertions: 1 | 1 failed</pre>&#13;
<p class="listing"><a id="ch10ex33"/><em>Listing 10-33: The output from running the test suite after implementing Listing 10-31</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_307"/>This is vastly superior output to what you had produced in the home-grown unit-test suite. Catch tells you the exact line where the unit test failed <span class="ent">➊</span> and then prints this line for you <span class="ent">➋</span>. Next, it expands this line into the actual values encountered at runtime. You can see that the grotesque (uninitialized) value returned by <span class="literal">get_speed_mps()</span> is clearly not <span class="literal">0</span> <span class="ent">➌</span>. Compare this output to the output of the home-grown unit test; I think you’ll agree that there’s immediate value to using Catch.</p>&#13;
<h5 class="h5" id="ch10lev3sec20"><strong>Assertions and Exceptions</strong></h5>&#13;
<p class="noindent">Catch also provides a special assertion called <span class="literal">REQUIRE_THROWS</span>. This macro requires that the contained expression throw an exception. To achieve similar functionality in the home-grown unit-test framework, consider this multiline monstrosity:</p>&#13;
<pre>  try {&#13;
    auto_brake.set_collision_threshold_s(0.5L);&#13;
  } catch (const std::exception&amp;) {&#13;
    return;&#13;
  }&#13;
  assert_that(false, "no exception thrown");</pre>&#13;
<p class="indent">Other exception-aware macros are available as well. You can require that some expression evaluation not throw an exception using the <span class="literal">REQUIRE_NOTHROW</span> and <span class="literal">CHECK_NOTHROW</span> macros. You can also be specific about the type of the exception you expect to be thrown by using the <span class="literal">REQUIRE_THROWS_AS</span> and <span class="literal">CHECK_THROWS_AS</span> macros. These expect a second parameter describing the expected type. Their usages are similar to <span class="literal">REQUIRE</span>; you simply provide some expression that must throw an exception for the assertion to pass:</p>&#13;
<pre>REQUIRE_THROWS(<span class="codeitalic1">expression-to-evaluate</span>);</pre>&#13;
<p class="indent">If the <span class="codeitalic">expression-to-evaluate</span> doesn’t throw an exception, the assertion fails.</p>&#13;
<h5 class="h5" id="ch10lev3sec21"><strong>Floating-Point Assertions</strong></h5>&#13;
<p class="noindent">The <span class="literal">AutoBrake</span> class involves floating-point arithmetic, and we’ve been glossing over a potentially very serious problem with the assertions. Because floating-point numbers entail rounding errors, it’s not a good idea to check for equality using <span class="literal">operator==</span>. The more robust approach is to test whether the difference between floating-point numbers is arbitrarily small. With Catch, you can handle these situations effortlessly using the <span class="literal">Approx</span> class, as shown in <a href="ch10.xhtml#ch10ex34">Listing 10-34</a>.</p>&#13;
<pre>TEST_CASE("AutoBrake") {&#13;
  MockServiceBus bus{};&#13;
  AutoBrake auto_brake{ bus };&#13;
  REQUIRE(auto_brake.get_collision_threshold_s() == Approx(5L));&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex34"/><em>Listing 10-34: A refactor of the “initializes sensitivity to five” test using the <span class="literal">Approx</span> class</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_308"/>The <span class="literal">Approx</span> class helps Catch perform tolerant comparisons of floating-point values. It can exist on either side of a comparison expression. It has sensible defaults for how tolerant it is, but you have fine-grained control over the specifics (see the Catch documentation on <span class="literal">epsilon, margin</span>, and <span class="literal">scale</span>).</p>&#13;
<h5 class="h5" id="ch10lev3sec22"><strong>Fail</strong></h5>&#13;
<p class="noindent">You can cause a Catch test to fail using the <span class="literal">FAIL()</span> macro. This can sometimes be useful when combined with conditional statements, as in the following:</p>&#13;
<pre>if (something-bad) FAIL("Something bad happened.")</pre>&#13;
<p class="indent">Use a <span class="literal">REQUIRE</span> statement if a suitable one is available.</p>&#13;
<h5 class="h5" id="ch10lev3sec23"><strong>Test Cases and Sections</strong></h5>&#13;
<p class="noindent">Catch supports the idea of test cases and sections, which make common setup and teardown in your unit tests far easier. Notice that each of the tests has some repeated ceremony each time you construct an <span class="literal">AutoBrake</span>:</p>&#13;
<pre>  MockServiceBus bus{};&#13;
  AutoBrake auto_brake{ bus };</pre>&#13;
<p class="indent">There’s no need to repeat this code over and over again. Catch’s solution to this common setup is to use nested <span class="literal">SECTION</span> macros. You can nest <span class="literal">SECTION</span> macros within a <span class="literal">TEST_CASE</span> in the basic usage pattern, as demonstrated in <a href="ch10.xhtml#ch10ex35">Listing 10-35</a>.</p>&#13;
<pre>TEST_CASE("MyTestGroup") {&#13;
  // Setup code goes here <span class="ent">➊</span>&#13;
  SECTION("MyTestA") { <span class="ent">➋</span>&#13;
    // Code for Test A&#13;
  }&#13;
  SECTION("MyTestB") { <span class="ent">➌</span>&#13;
    // Code for Test B&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex35"/><em>Listing 10-35: An example Catch setup with nested macros</em></p>&#13;
<p class="indent">You can perform all of the setup once at the beginning of a <span class="literal">TEST_CASE</span> <span class="ent">➊</span>. When Catch sees <span class="literal">SECTION</span> macros nested within a <span class="literal">TEST_CASE</span>, it (conceptually) copies and pastes all the setup into each <span class="literal">SECTION</span> <span class="ent">➋➌</span>. Each <span class="literal">SECTION</span> runs independently of the others, so generally any side effects on objects created in the <span class="literal">TEST_CASE</span> aren’t observed across <span class="literal">SECTION</span> macros. Further, you can embed a <span class="literal">SECTION</span> macro within another <span class="literal">SECTION</span> macro. This might be useful if you have a lot of setup code for a suite of closely related tests (although it may just make sense to split this suite into its own <span class="literal">TEST_CASE</span>).</p>&#13;
<p class="indent">Let’s look at how this approach simplifies the <span class="literal">AutoBrake</span> unit-test suite.</p>&#13;
<h5 class="h5" id="ch10lev3sec24"><span epub:type="pagebreak" id="page_309"/><strong>Refactoring the AutoBrake Unit Tests to Catch</strong></h5>&#13;
<p class="noindent"><a href="ch10.xhtml#ch10ex36">Listing 10-36</a> refactors all the unit tests into a Catch style.</p>&#13;
<pre>#define CATCH_CONFIG_MAIN&#13;
#include "catch.hpp"&#13;
#include &lt;functional&gt;&#13;
#include &lt;stdexcept&gt;&#13;
&#13;
struct IServiceBus {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct MockServiceBus : IServiceBus {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct AutoBrake {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
TEST_CASE("AutoBrake"<span class="ent">➊</span>) {&#13;
  MockServiceBus bus{}; <span class="ent">➋</span>&#13;
  AutoBrake auto_brake{ bus }; <span class="ent">➌</span>&#13;
&#13;
  SECTION<span class="ent">➍</span>("initializes speed to zero"<span class="ent">➎</span>) {&#13;
    REQUIRE(auto_brake.get_speed_mps() == Approx(0));&#13;
  }&#13;
&#13;
  SECTION("initializes sensitivity to five") {&#13;
    REQUIRE(auto_brake.get_collision_threshold_s() == Approx(5));&#13;
  }&#13;
&#13;
  SECTION("throws when sensitivity less than one") {&#13;
    REQUIRE_THROWS(auto_brake.set_collision_threshold_s(0.5L));&#13;
  }&#13;
&#13;
  SECTION("saves speed after update") {&#13;
    bus.speed_update_callback(SpeedUpdate{ 100L });&#13;
    REQUIRE(100L == auto_brake.get_speed_mps());&#13;
    bus.speed_update_callback(SpeedUpdate{ 50L });&#13;
    REQUIRE(50L == auto_brake.get_speed_mps());&#13;
    bus.speed_update_callback(SpeedUpdate{ 0L });&#13;
    REQUIRE(0L == auto_brake.get_speed_mps());&#13;
  }&#13;
&#13;
  SECTION("no alert when not imminent") {&#13;
    auto_brake.set_collision_threshold_s(2L);&#13;
    bus.speed_update_callback(SpeedUpdate{ 100L });&#13;
    bus.car_detected_callback(CarDetected{ 1000L, 50L });&#13;
    REQUIRE(bus.commands_published == 0);&#13;
  }&#13;
&#13;
  SECTION("alert when imminent") {&#13;
    auto_brake.set_collision_threshold_s(10L);&#13;
<span epub:type="pagebreak" id="page_310"/>    bus.speed_update_callback(SpeedUpdate{ 100L });&#13;
    bus.car_detected_callback(CarDetected{ 100L, 0L });&#13;
    REQUIRE(bus.commands_published == 1);&#13;
    REQUIRE(bus.last_command.time_to_collision_s == Approx(1));&#13;
  }&#13;
}&#13;
------------------------------------------------------------------------------&#13;
<span class="color1">==============================================================================</span>&#13;
<span class="color1">All tests passed (9 assertions in 1 test case)</span></pre>&#13;
<p class="listing"><a id="ch10ex36"/><em>Listing 10-36: Using the Catch framework to implement the unit tests</em></p>&#13;
<p class="indent">Here, <span class="literal">TEST_CASE</span> is renamed to <span class="literal">AutoBrake</span> to reflect its more generic purpose <span class="ent">➊</span>. Next, the body of the <span class="literal">TEST_CASE</span> begins with the common setup code that all the <span class="literal">AutoBrake</span> unit tests share <span class="ent">➋➌</span>. Each of the unit tests has been converted into a <span class="literal">SECTION</span> macro <span class="ent">➍</span>. You name each of the sections <span class="ent">➎</span> and then place the test-specific code within the <span class="literal">SECTION</span> body. Catch will do all the work of stitching together the setup code with each of the <span class="literal">SECTION</span> bodies. In other words, you get a fresh <span class="literal">AutoBrake</span> each time: the order of the <span class="literal">SECTIONS</span> doesn’t matter here, and they’re totally independent.</p>&#13;
<h4 class="h4" id="ch10lev2sec8"><strong><em>Google Test</em></strong></h4>&#13;
<p class="noindent">Google Test is another extremely popular unit-testing framework. Google Test follows the xUnit unit-testing framework tradition, so if you’re familiar with, for example, junit for Java or nunit for .NET, you’ll feel right at home using Google Test. One nice feature when you’re using Google Test is that the mocking framework Google Mocks was merged in some time ago.</p>&#13;
<h5 class="h5" id="ch10lev3sec25"><strong>Configuring Google Test</strong></h5>&#13;
<p class="noindent">Google Test takes some time to get up and running. Unlike Catch, Google Test is not a header-only library. You must download it from <em><a href="https://github.com/google/googletest/">https://github.com/google/googletest/</a></em>, compile it into a set of libraries, and link those libraries into your test project as appropriate. If you use a popular desktop build system, such as GNU Make, Mac Xcode, or Visual Studio, some templates are available that you can use to start building the relevant libraries.</p>&#13;
<p class="indent">For more information about getting Google Test up and running, refer to the Primer available in the repository’s <span class="literal">docs</span> directory.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>At press time, Google Test’s latest version is 1.8.1. See this book’s companion source, available at</em> <a href="https://ccc.codes">https://ccc.codes</a>, <em>for one method of integrating Google Test into a Cmake build</em>.</p>&#13;
</div>&#13;
<p class="indent">Within your unit-test project, you must perform two operations to set up Google Test. First, you must ensure that the included directory of your Google Test installation is in the header search path of your unit-test project. This allows you to use <span class="literal">#include "gtest/gtest.h"</span> within your tests. Second, you must instruct your linker to include <span class="literal">gtest</span> and <span class="literal">gtest_main</span> static libraries from your Google Test installation. Make sure that you link in the correct architecture and configuration settings for your computer.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_311"/><em>A common gotcha getting Google Test set up in Visual Studio is that the C/C++ &gt; Code Generation &gt; Runtime Library option for Google Test must match your project’s option. By default, Google Test compiles the runtime statically (that is, with the /MT or MTd options). This choice is different from the default, which is to compile the runtime dynamically (for example, with the <span class="literal">/MD</span> or <span class="literal">/MDd</span> options in Visual Studio)</em>.</p>&#13;
</div>&#13;
<h5 class="h5" id="ch10lev3sec26"><strong>Defining an Entry Point</strong></h5>&#13;
<p class="noindent">Google Test will supply a <span class="literal">main()</span> function for you when you link <span class="literal">gtest_main</span> into your unit-test project. Think of this as Google Test’s analogy for Catch’s <span class="literal">#define CATCH_CONFIG_MAIN</span>; it will locate all the unit tests you’ve defined and roll them together into a nice test harness.</p>&#13;
<h5 class="h5" id="ch10lev3sec27"><strong>Defining Test Cases</strong></h5>&#13;
<p class="noindent">To define test cases, all you need to do is provide unit tests using the <span class="literal">TEST</span> macro, which is quite similar to Catch’s <span class="literal">TEST_CASE</span>. <a href="ch10.xhtml#ch10ex37">Listing 10-37</a> illustrates the basic setup of a Google Test unit test.</p>&#13;
<pre>#include "gtest/gtest.h" <span class="ent">➊</span>&#13;
&#13;
TEST<span class="ent">➋</span>(AutoBrake<span class="ent">➌</span>, UnitTestName<span class="ent">➍</span>) {&#13;
  // Unit test here <span class="ent">➎</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Running main() from gtest_main.cc <span class="ent">➏</span></span>&#13;
<span class="color1">[==========] Running 1 test from 1 test case.</span>&#13;
<span class="color1">[----------] Global test environment set-up.</span>&#13;
<span class="color1">[----------] 1 test from AutoBrake</span>&#13;
<span class="color1"><span class="color1">[ RUN      ] AutoBrake.UnitTestName</span></span>&#13;
<span class="color1">[       OK ] AutoBrake.UnitTestName (0 ms)</span>&#13;
<span class="color1">[----------] 1 test from AutoBrake (0 ms total)</span>&#13;
&#13;
<span class="color1">[----------] Global test environment tear-down</span>&#13;
<span class="color1">[==========] 1 test from 1 test case ran. (1 ms total)</span>&#13;
<span class="color1">[  PASSED  ] 1 test. <span class="ent">➐</span></span></pre>&#13;
<p class="listing"><a id="ch10ex37"/><em>Listing 10-37: An example Google Test unit test</em></p>&#13;
<p class="indent">First, you include the <span class="literal">gtest/gtest.h</span> header <span class="ent">➊</span>. This pulls in all the definitions you need to define your unit tests. Each unit test starts with the <span class="literal">TEST</span> macro <span class="ent">➋</span>. You define each unit test with two labels: a <em>test case name</em>, which is <span class="literal">AutoBrake</span> <span class="ent">➌</span> and a <em>test name</em>, which is <span class="literal">UnitTestName</span> <span class="ent">➍</span>. These are roughly analogous to the <span class="literal">TEST_CASE</span> and <span class="literal">SECTION</span> names (respectively) in Catch. A test case contains one or many tests. Usually, you place tests together that share some a common theme. The framework will group the tests together, which can be useful for some of the more advanced uses. Different test cases can have tests with the same name.</p>&#13;
<p class="indent">You would put the code for your unit test within the braces <span class="ent">➎</span>. When you run the resulting unit-test binary, you can see that Google Test provides an entry point for you <span class="ent">➏</span>. Because you provided no assertions (or code that could throw an exception), your unit tests pass with flying colors <span class="ent">➐</span>.</p>&#13;
<h5 class="h5" id="ch10lev3sec28"><span epub:type="pagebreak" id="page_312"/><strong>Making Assertions</strong></h5>&#13;
<p class="noindent">Assertions in Google Test are less magical than in Catch’s <span class="literal">REQUIRE</span>. Although they’re also macros, the Google Test assertions require a lot more work on the programmer’s part. Where <span class="literal">REQUIRE</span> will parse the Boolean expression and determine whether you’re testing for equality, a greater-than relationship, and so on, Google Test’s assertions don’t. You must pass in each component of the assertion separately.</p>&#13;
<p class="indent">There are many other options for formulating assertions in Google Test. <a href="ch10.xhtml#ch10tab01">Table 10-1</a> summarizes them.</p>&#13;
<p class="tabcap"><a id="ch10tab01"><strong>Table 10-1:</strong> <span class="literal">Google Test Assertions</span></a></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Assertion</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Verifies that</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">ASSERT_TRUE(</span><span class="codeitalic">condition</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codeitalic">condition</span> is true.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">ASSERT_FALSE(</span><span class="codeitalic">condition</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codeitalic">condition</span> is false.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">ASSERT_EQ(</span><span class="codeitalic">val1, val2</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codeitalic">val1</span> == <span class="codeitalic">val2</span> is true.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">ASSERT_FLOAT_EQ(</span><span class="codeitalic">val1</span><span class="literal">,</span> <span class="codeitalic">val2</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codeitalic">val1</span> <span class="literal">-</span> <span class="codeitalic">val2</span> is a rounding error (<span class="literal">float</span>).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">ASSERT_DOUBLE_EQ(</span><span class="codeitalic">val1</span><span class="literal">,</span> <span class="codeitalic">val2</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codeitalic">val1</span> <span class="literal">-</span> <span class="codeitalic">val2</span> is a rounding error (<span class="literal">double</span>).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">ASSERT_NE(</span><span class="codeitalic">val1</span><span class="literal">,</span> <span class="codeitalic">val2</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codeitalic">val1</span> <span class="literal">!=</span> <span class="codeitalic">val2</span> is true.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">ASSERT_LT(</span><span class="codeitalic">val1</span><span class="literal">,</span> <span class="codeitalic">val2</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codeitalic">val1</span> <span class="literal">&lt;</span> <span class="codeitalic">val2</span> is true.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">ASSERT_LE(</span><span class="codeitalic">val1</span><span class="literal">,</span> <span class="codeitalic">val2</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codeitalic">val1</span> <span class="literal">&lt;=</span> <span class="codeitalic">val2</span> is true.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">ASSERT_GT(</span><span class="codeitalic">val1</span><span class="literal">,</span> <span class="codeitalic">val2</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="codeitalic">val1</span> <span class="literal">&gt;</span> <span class="codeitalic">val2</span> is true.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">ASSERT_GE(</span><span class="codeitalic">val1</span><span class="literal">,</span> <span class="codeitalic">val2</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="codeitalic">val1</span> <span class="literal">&gt;=</span> <span class="codeitalic">val2</span> is true.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">ASSERT_STREQ(</span><span class="codeitalic">str1</span><span class="literal">,</span> <span class="codeitalic">str2</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The two C-style strings <span class="literal"><em>str1</em></span> and <span class="literal"><em>str2</em></span> have the same content.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">ASSERT_STRNE(</span><span class="codeitalic">str1</span><span class="literal">,</span> <span class="codeitalic">str2</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The two C-style strings <span class="literal"><em>str1</em></span> and <span class="literal"><em>str2</em></span> have different content.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">ASSERT_STRCASEEQ(</span><span class="codeitalic">str1</span><span class="literal">,</span> <span class="codeitalic">str2</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The two C-style strings <span class="literal"><em>str1</em></span> and <span class="literal"><em>str2</em></span> have the same content, ignoring case.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">ASSERT_STRCASENE(</span><span class="codeitalic">str1</span><span class="literal">,</span> <span class="codeitalic">str2</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The two C-style strings <span class="literal"><em>str1</em></span> and <span class="literal"><em>str2</em></span> have different content, ignoring case.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">ASSERT_THROW(</span><span class="codeitalic">statement</span><span class="literal">,</span> <span class="codeitalic">ex_type</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The evaluating <span class="literal"><em>statement</em></span> causes an exception of type <span class="literal"><em>ex_type</em></span> to be thrown.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">ASSERT_ANY_THROW(</span><span class="codeitalic">statement</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The evaluating <span class="literal"><em>statement</em></span> causes an exception of any type to be thrown.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">ASSERT_NO_THROW(</span><span class="codeitalic">statement</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">The evaluating <span class="literal"><em>statement</em></span> causes no exception to be thrown.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">ASSERT_HRESULT_SUCCEEDED(</span><span class="codeitalic">statement</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The <span class="literal">HRESULT</span> returned by <span class="literal"><em>statement</em></span> corresponds with a success (Win32 API only).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">ASSERT_HRESULT_FAILED(</span><span class="codeitalic">statement</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">The <span class="literal">HRESULT</span> returned by <span class="literal"><em>statement</em></span> corresponds with a failure (Win32 API only).</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Let’s combine a unit-test definition with an assertion to see Google Test in action.</p>&#13;
<h5 class="h5" id="ch10lev3sec29"><span epub:type="pagebreak" id="page_313"/><strong>Refactoring the initial_car_speed_is_zero Test to Google Test</strong></h5>&#13;
<p class="noindent">With the intentionally broken <span class="literal">AutoBrake</span> in <a href="ch10.xhtml#ch10ex32">Listing 10-32</a>, you can run  the following unit test to see what the test harness’s failure messages look like. (Recall that you commented out the member initializer for <span class="literal">speed_mps</span>.) <a href="ch10.xhtml#ch10ex38">Listing 10-38</a> uses <span class="literal">ASSERT_FLOAT_EQ</span> to assert that the car’s initial speed is zero.</p>&#13;
<pre>#include "gtest/gtest.h"&#13;
#include &lt;functional&gt;&#13;
&#13;
struct IServiceBus {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct MockServiceBus : IServiceBus {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct AutoBrake {&#13;
  AutoBrake(IServiceBus&amp; bus)&#13;
    : collision_threshold_s{ 5 }/*,&#13;
    speed_mps{} */ {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
TEST<span class="ent">➊</span>(AutoBrakeTest<span class="ent">➋</span>, InitialCarSpeedIsZero<span class="ent">➌</span>) {&#13;
  MockServiceBus bus{};&#13;
  AutoBrake auto_brake{ bus };&#13;
  ASSERT_FLOAT_EQ<span class="ent">➍</span>(0<span class="ent">➎</span>, auto_brake.get_speed_mps()<span class="ent">➏</span>);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Running main() from gtest_main.cc</span>&#13;
<span class="color1">[==========] Running 1 test from 1 test case.</span>&#13;
<span class="color1">[----------] Global test environment set-up.</span>&#13;
<span class="color1">[----------] 1 test from AutoBrakeTest</span>&#13;
<span class="color1">[ RUN      ] AutoBrakeTest.InitialCarSpeedIsZero</span>&#13;
<span class="color1">C:\Users\josh\AutoBrake\gtest.cpp(80): error: Expected equality of these values:</span>&#13;
<span class="color1">  0 <span class="ent">➎</span></span>&#13;
<span class="color1">  auto_brake.get_speed_mps()<span class="ent">➏</span></span>&#13;
<span class="color1">    Which is: -inf</span>&#13;
<span class="color1">[  FAILED  ] AutoBrakeTest<span class="ent">➋</span>.InitialCarSpeedIsZero<span class="ent">➌</span> (5 ms)</span>&#13;
<span class="color1">[----------] 1 test from AutoBrakeTest (5 ms total)</span>&#13;
&#13;
<span class="color1">[----------] Global test environment tear-down</span>&#13;
<span class="color1">[==========] 1 test from 1 test case ran. (7 ms total)</span>&#13;
<span class="color1">[  PASSED  ] 0 tests.</span>&#13;
<span class="color1">[  FAILED  ] 1 test, listed below:</span>&#13;
<span class="color1">[  FAILED  ] AutoBrakeTest.InitialCarSpeedIsZero</span>&#13;
&#13;
<span class="color1"> 1 FAILED TEST</span></pre>&#13;
<p class="listing"><a id="ch10ex38"/><em>Listing 10-38: Intentionally commenting out the <span class="literal">collision_threshold_s</span> member initializer to cause test failures (using Google Test)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_314"/>You declare a unit test <span class="ent">➊</span> with the test case name <span class="literal">AutoBrakeTest</span> <span class="ent">➋</span> and test name <span class="literal">InitialCarSpeedIsZero</span> <span class="ent">➌</span>. Within the test, you set up the <span class="literal">auto_brake</span> and assert <span class="ent">➍</span> that the car’s initial speed is zero <span class="ent">➎</span>. Notice that the constant value is the first parameter and the quantity you’re testing is the second parameter <span class="ent">➏</span>.</p>&#13;
<p class="indent">Like the Catch output in <a href="ch10.xhtml#ch10ex33">Listing 10-33</a>, the Google Test output in <a href="ch10.xhtml#ch10ex38">Listing 10-38</a> is very clear. It tells you that a test failed, identifies the failed assertion, and gives a good indication of how you might fix the issue.</p>&#13;
<h5 class="h5" id="ch10lev3sec30"><strong>Test Fixtures</strong></h5>&#13;
<p class="noindent">Unlike Catch’s <span class="literal">TEST_CASE</span> and <span class="literal">SECTION</span> approach, Google Test’s approach is to formulate <em>test fixture classes</em> when a common setup is involved. These fixtures are classes that inherit from the <span class="literal">::testing::Test</span> class that the framework provides.</p>&#13;
<p class="indent">Any members you plan to use inside tests you should mark as <span class="literal">public</span> or <span class="literal">protected</span>. If you want some setup or teardown computation, you can put it inside the (default) constructor or destructor (respectively).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>You can also place such setup and teardown logic in overridden <span class="literal">SetUp()</span> and <span class="literal">TearDown()</span> functions, although it’s rare that you would need to. One case is if the teardown computation might throw an exception. Because you generally shouldn’t allow an uncaught exception to throw from a destructor, you would have to put such code in a <span class="literal">TearDown()</span> function. (Recall from “Throwing in Destructors” on <a href="ch04.xhtml#page_106">page 106</a> that throwing an uncaught exception in a destructor when another exception is already in flight calls <span class="literal">std::terminate</span>.)</em></p>&#13;
</div>&#13;
<p class="indent">If a test fixture is like a Catch <span class="literal">TEST_CASE</span>, then <span class="literal">TEST_F</span> is like a Catch <span class="literal">SECTION</span>. Like <span class="literal">TEST, TEST_F</span> takes two parameters. The first <em>must</em> be the exact name of the test fixture class. The second is the name of the unit test. <a href="ch10.xhtml#ch10ex39">Listing 10-39</a> illustrates the basic usage of Google Test’s test fixtures.</p>&#13;
<pre>#include "gtest/gtest.h"&#13;
&#13;
struct MyTestFixture<span class="ent">➊</span> : ::testing::Test<span class="ent">➋</span> { };&#13;
&#13;
TEST_F(MyTestFixture<span class="ent">➌</span>, MyTestA<span class="ent">➍</span>) {&#13;
  // Test A here&#13;
}&#13;
&#13;
TEST_F(MyTestFixture, MyTestB<span class="ent">➎</span>) {&#13;
  // Test B here&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Running main() from gtest_main.cc</span>&#13;
<span class="color1">[==========] Running 2 tests from 1 test case.</span>&#13;
<span class="color1">[----------] Global test environment set-up.</span>&#13;
<span class="color1">[----------] 2 tests from MyTestFixture</span>&#13;
<span class="color1">[ RUN      ] MyTestFixture.MyTestA</span>&#13;
<span class="color1">[       OK ] MyTestFixture.MyTestA (0 ms)</span>&#13;
<span class="color1">[ RUN      ] MyTestFixture.MyTestB</span>&#13;
<span class="color1"><span epub:type="pagebreak" id="page_315"/>[       OK ] MyTestFixture.MyTestB (0 ms)</span>&#13;
<span class="color1">[----------] 2 tests from MyTestFixture (1 ms total)</span>&#13;
&#13;
<span class="color1">[----------] Global test environment tear-down</span>&#13;
<span class="color1">[==========] 2 tests from 1 test case ran. (3 ms total)</span>&#13;
<span class="color1">[  PASSED  ] 2 tests.</span></pre>&#13;
<p class="listing"><a id="ch10ex39"/><em>Listing 10-39: The basic setup of Google Test’s test fixtures</em></p>&#13;
<p class="indent">You declare a class <span class="literal">MyTestFixture</span> <span class="ent">➊</span> that inherits from the <span class="literal">::testing::Test</span> class that Google Test provides <span class="ent">➋</span>. You use the class’s name as the first parameter to the <span class="literal">TEST_F</span> macro <span class="ent">➌</span>. The unit test then has access to any public or protected methods inside <span class="literal">MyTestFixture</span>, and you can use the constructor and destructor of <span class="literal">MyTestFixture</span> to perform any common test setup/teardown. The second argument is the name of the unit test <span class="ent">➍➎</span>.</p>&#13;
<p class="indent">Next, let’s look at how to use Google Test Fixtures to reimplement the <span class="literal">AutoBrake</span> unit tests.</p>&#13;
<h5 class="h5" id="ch10lev3sec31"><strong>Refactoring AutoBrake Unit Tests with Google Test</strong></h5>&#13;
<p class="noindent"><a href="ch10.xhtml#ch10ex40">Listing 10-40</a> reimplements all the <span class="literal">AutoBrake</span> unit tests into Google Test’s test-fixture framework.</p>&#13;
<pre>#include "gtest/gtest.h"&#13;
#include &lt;functional&gt;&#13;
&#13;
struct IServiceBus {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct MockServiceBus : IServiceBus {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct AutoBrake {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct AutoBrakeTest : ::testing::Test { <span class="ent">➊</span>&#13;
  MockServiceBus bus{};&#13;
  AutoBrake auto_brake { bus };&#13;
};&#13;
&#13;
TEST_F<span class="ent">➋</span>(AutoBrakeTest<span class="ent">➌</span>, InitialCarSpeedIsZero<span class="ent">➍</span>) {&#13;
  ASSERT_DOUBLE_EQ(0, auto_brake.get_speed_mps()); <span class="ent">➎</span>&#13;
}&#13;
&#13;
TEST_F(AutoBrakeTest, InitialSensitivityIsFive) {&#13;
  ASSERT_DOUBLE_EQ(5, auto_brake.get_collision_threshold_s());&#13;
}&#13;
&#13;
TEST_F(AutoBrakeTest, SensitivityGreaterThanOne) {&#13;
  ASSERT_ANY_THROW(auto_brake.set_collision_threshold_s(0.5L)); <span class="ent">➏</span>&#13;
}&#13;
<span epub:type="pagebreak" id="page_316"/>&#13;
TEST_F(AutoBrakeTest, SpeedIsSaved) {&#13;
  bus.speed_update_callback(SpeedUpdate{ 100L });&#13;
  ASSERT_EQ(100, auto_brake.get_speed_mps());&#13;
  bus.speed_update_callback(SpeedUpdate{ 50L });&#13;
  ASSERT_EQ(50, auto_brake.get_speed_mps());&#13;
  bus.speed_update_callback(SpeedUpdate{ 0L });&#13;
  ASSERT_DOUBLE_EQ(0, auto_brake.get_speed_mps());&#13;
}&#13;
&#13;
TEST_F(AutoBrakeTest, NoAlertWhenNotImminent) {&#13;
  auto_brake.set_collision_threshold_s(2L);&#13;
  bus.speed_update_callback(SpeedUpdate{ 100L });&#13;
  bus.car_detected_callback(CarDetected{ 1000L, 50L });&#13;
  ASSERT_EQ(0, bus.commands_published);&#13;
}&#13;
&#13;
TEST_F(AutoBrakeTest, AlertWhenImminent) {&#13;
  auto_brake.set_collision_threshold_s(10L);&#13;
  bus.speed_update_callback(SpeedUpdate{ 100L });&#13;
  bus.car_detected_callback(CarDetected{ 100L, 0L });&#13;
  ASSERT_EQ(1, bus.commands_published);&#13;
  ASSERT_DOUBLE_EQ(1L, bus.last_command.time_to_collision_s);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Running main() from gtest_main.cc</span>&#13;
<span class="color1">[==========] Running 6 tests from 1 test case.</span>&#13;
<span class="color1">[----------] Global test environment set-up.</span>&#13;
<span class="color1">[----------] 6 tests from AutoBrakeTest</span>&#13;
<span class="color1">[ RUN      ] AutoBrakeTest.InitialCarSpeedIsZero</span>&#13;
<span class="color1">[       OK ] AutoBrakeTest.InitialCarSpeedIsZero (0 ms)</span>&#13;
<span class="color1">[ RUN      ] AutoBrakeTest.InitialSensitivityIsFive</span>&#13;
<span class="color1">[       OK ] AutoBrakeTest.InitialSensitivityIsFive (0 ms)</span>&#13;
<span class="color1">[ RUN      ] AutoBrakeTest.SensitivityGreaterThanOne</span>&#13;
<span class="color1">[       OK ] AutoBrakeTest.SensitivityGreaterThanOne (1 ms)</span>&#13;
<span class="color1">[ RUN      ] AutoBrakeTest.SpeedIsSaved</span>&#13;
<span class="color1">[       OK ] AutoBrakeTest.SpeedIsSaved (0 ms)</span>&#13;
<span class="color1">[ RUN      ] AutoBrakeTest.NoAlertWhenNotImminent</span>&#13;
<span class="color1">[       OK ] AutoBrakeTest.NoAlertWhenNotImminent (1 ms)</span>&#13;
<span class="color1">[ RUN      ] AutoBrakeTest.AlertWhenImminent</span>&#13;
<span class="color1">[       OK ] AutoBrakeTest.AlertWhenImminent (0 ms)</span>&#13;
<span class="color1">[----------] 6 tests from AutoBrakeTest (3 ms total)</span>&#13;
&#13;
<span class="color1">[----------] Global test environment tear-down</span>&#13;
<span class="color1">[==========] 6 tests from 1 test case ran. (4 ms total)</span>&#13;
<span class="color1">[  PASSED  ] 6 tests.</span></pre>&#13;
<p class="listing"><a id="ch10ex40"/><em>Listing 10-40: Using Google Test to implement the <span class="literal">AutoBrake</span> unit tests</em></p>&#13;
<p class="indent">First, you implement the test fixture <span class="literal">AutoBrakeTest</span> <span class="ent">➊</span>. This class encapsulates the common setup code across all the unit tests: to construct a <span class="literal">MockServiceBus</span> and use it to construct an <span class="literal">AutoBrake</span>. Each of the unit tests is represented by a <span class="literal">TEST_F</span> macro <span class="ent">➋</span>. These macros take two parameters: the test fixture, such as <span class="literal">AutoBrakeTest</span> <span class="ent">➌</span>, and the name of the test, such as <span epub:type="pagebreak" id="page_317"/><span class="literal">InitialCarSpeedIsZero</span> <span class="ent">➍</span>. Within the body of the unit tests, you have the correct invocations for each of the assertions, such as <span class="literal">ASSERT_DOUBLE_EQ</span> <span class="ent">➎</span> and <span class="literal">ASSERT_ANY_THROW</span> <span class="ent">➏</span>.</p>&#13;
<h5 class="h5" id="ch10lev3sec32"><strong>Comparing Google Test and Catch</strong></h5>&#13;
<p class="noindent">As you’ve seen, several major differences exist between Google Test and Catch. The most striking initial impression should be your investment in installing Google Test and making it work correctly in your solution. Catch is on the opposite end of this spectrum: as a header-only library, it’s trivial to make it work in your project.</p>&#13;
<p class="indent">Another major difference is the assertions. To a newcomer, <span class="literal">REQUIRE</span> is a lot simpler to use than the Google Test assertion style. To a seasoned user of another xUnit framework, Google Test might seem more natural. The failure messages are also a bit different. It’s really up to you to determine which of these styles is more sensible.</p>&#13;
<p class="indent">Finally, there’s performance. Theoretically, Google Test will compile more quickly than Catch because all of Catch must be compiled for each translation unit in your unit-test suite. This is the trade-off for header-only libraries; the setup investment you make when setting up Google Test pays you back later with faster compilation. This might or might not be perceptible depending on the size of your unit-test suite.</p>&#13;
<h4 class="h4" id="ch10lev2sec9"><strong><em>Boost Test</em></strong></h4>&#13;
<p class="noindent">Boost Test is a unit-testing framework that ships as part of the <em>Boost C++ libraries</em> (or simply <em>Boost</em>). Boost is an excellent collection of open source C++ libraries. It has a history of incubating many ideas that are eventually incorporated into the C++ standard, although not all Boost libraries aim for eventual inclusion. You’ll see mention of a number of Boost libraries throughout the remainder of this book, and Boost Test is the first. For help installing boost into your environment, see Boost’s home page <a href="https://www.boost.org">https://www.boost.org</a> or have a look at this book’s companion code.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>At press time, the latest version of the Boost libraries is 1.70.0.</em></p>&#13;
</div>&#13;
<p class="indent">You can use Boost Test in three modes: as a header-only library (like Catch), as a static library (like Google Test), or as a shared library, which will link the Boost Test module at runtime. The dynamic library usage can save quite a bit of disk space in the event you have multiple unit-test binaries. Rather than baking the unit-test framework into each of the unit-test binaries, you can build a single shared library (like a <em>.so</em> or <em>.dll</em>) and load it at runtime.</p>&#13;
<p class="indent">As you’ve discovered while exploring Catch and Google Test, trade-offs are involved with each of these approaches. A major advantage of Boost Test is that it allows you to choose the best mode as you see fit. It’s not terribly difficult to switch modes should a project evolve, so one possible approach is to begin using Boost Test as a header-only library and transition into another mode as requirements change.</p>&#13;
<h5 class="h5" id="ch10lev3sec33"><strong><span epub:type="pagebreak" id="page_318"/>Setting Up Boost Test</strong></h5>&#13;
<p class="noindent">To set up Boost Test in the header-only mode (what Boost documentation calls the “single-header variant”), you simply include the <span class="literal">&lt;boost/test/included/unit_test.hpp&gt;</span> header. For this header to compile, you need to define <span class="literal">BOOST_TEST_MODULE</span> with a user-defined name. For example:</p>&#13;
<pre>#define BOOST_TEST_MODULE test_module_name&#13;
#include &lt;boost/test/included/unit_test.hpp&gt;</pre>&#13;
<p class="indent">Unfortunately, you cannot take this approach if you have more than one translation unit. For such situations, Boost Test contains prebuilt static libraries that you can use. By linking these in, you avoid having to compile the same code for every translation unit. When taking this approach, you include the <span class="literal">boost/test/unit_test.hpp</span> header for each translation unit in the unit-test suite:</p>&#13;
<pre>#include &lt;boost/test/unit_test.hpp&gt;</pre>&#13;
<p class="indent">In exactly <em>one</em> translation unit, you also include the <span class="literal">BOOST_TEST_MODULE</span> definition:</p>&#13;
<pre>#define BOOST_TEST_MODULE AutoBrake&#13;
#include &lt;boost/test/unit_test.hpp&gt;</pre>&#13;
<p class="indent">You must also configure the linker to include the appropriate Boost Test static library that comes with the Boost Test installation. The compiler and architecture corresponding to the selected static library must match the rest of your unit-test project.</p>&#13;
<h5 class="h5" id="ch10lev3sec34"><strong>Setting Up Shared Library Mode</strong></h5>&#13;
<p class="indent">To set up Boost Test in shared library mode, you must add the following lines to each translation unit of the unit-test suite:</p>&#13;
<pre>#define BOOST_TEST_DYN_LINK&#13;
#include &lt;boost/test/unit_test.hpp&gt;</pre>&#13;
<p class="indent">In exactly <em>one</em> translation unit, you must also define <span class="literal">BOOST_TEST_MODULE</span>:</p>&#13;
<pre>#define BOOST_TEST_MODULE AutoBrake&#13;
#define BOOST_TEST_DYN_LINK&#13;
#include &lt;boost/test/unit_test.hpp&gt;</pre>&#13;
<p class="indent">As with the static library usage, you must instruct the linker to include Boost Test. At runtime, the unit-test shared library must be available as well.</p>&#13;
<h5 class="h5" id="ch10lev3sec35"><span epub:type="pagebreak" id="page_319"/><strong>Defining Test Cases</strong></h5>&#13;
<p class="noindent">You can define a unit test in Boost Test with the <span class="literal">BOOST_AUTO_TEST_CASE</span> macro, which takes a single parameter corresponding to the name of the test. <a href="ch10.xhtml#ch10ex41">Listing 10-41</a> shows the basic usage.</p>&#13;
<pre>#define BOOST_TEST_MODULE TestModuleName <span class="ent">➊</span>&#13;
#include &lt;boost/test/unit_test.hpp&gt; <span class="ent">➋</span>&#13;
&#13;
BOOST_AUTO_TEST_CASE<span class="ent">➌</span>(TestA<span class="ent">➍</span>) {&#13;
  // Unit Test A here <span class="ent">➎</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Running 1 test case...</span>&#13;
&#13;
<span class="color1">*** No errors detected</span></pre>&#13;
<p class="listing"><a id="ch10ex41"/><em>Listing 10-41: Using Google Test to implement the <span class="literal">AutoBrake</span> unit tests</em></p>&#13;
<p class="indent">The test module’s name is <span class="literal">TestModuleName</span> <span class="ent">➊</span>, which you define as the <span class="literal">BOOST_TEST_MODULE</span>. You include the <span class="literal">boost/test/unit_test.hpp</span> header <span class="ent">➋</span>, which provides you with access to all the components you need from Boost Test. The <span class="literal">BOOST_AUTO_TEST_CASE</span> declaration <span class="ent">➌</span> denotes a unit test called <span class="literal">TestA</span> <span class="ent">➍</span>. The body of the unit test goes between the braces <span class="ent">➎</span>.</p>&#13;
<h5 class="h5" id="ch10lev3sec36"><strong>Making Assertions</strong></h5>&#13;
<p class="noindent">Assertions in Boost are very similar to the assertions in Catch. The <span class="literal">BOOST_</span><span class="literal">TEST</span> macro is like the <span class="literal">REQUIRE</span> macro in Catch. You simply provide an expression that evaluates to true if the assertion passes and false if it fails:</p>&#13;
<pre>BOOST_TEST(<span class="codeitalic1">assertion-expression</span>)</pre>&#13;
<p class="indent">To require an expression to throw an exception upon evaluation, use the <span class="literal">BOOST_REQUIRE_THROW</span> macro, which is similar to Catch’s <span class="literal">REQUIRE_THROWS</span> macro, except you must also provide the type of the exception you want thrown. Its usage is as follows:</p>&#13;
<pre>BOOST_REQUIRE_THROW(<span class="codeitalic1">expression</span>, <span class="codeitalic1">desired-exception-type</span>);</pre>&#13;
<p class="indent">If the <span class="literal"><em>expression</em></span> doesn’t throw an exception of type <span class="literal"><em>desired-exception-type</em></span>, the assertion will fail.</p>&#13;
<p class="indent">Let’s examine what the <span class="literal">AutoBrake</span> unit-test suite looks like using Boost Test.</p>&#13;
<h5 class="h5" id="ch10lev3sec37"><strong>Refactoring the initial_car_speed_is_zero Test to Boost Test</strong></h5>&#13;
<p class="noindent">You’ll use the intentionally broken <span class="literal">AutoBrake</span> in <a href="ch10.xhtml#ch10ex32">Listing 10-32</a> with the missing member initializer for <span class="literal">speed_mps</span>. <a href="ch10.xhtml#ch10ex42">Listing 10-42</a> causes Boost Test to deal with a failed unit test.</p>&#13;
<pre><span epub:type="pagebreak" id="page_320"/>#define BOOST_TEST_MODULE AutoBrakeTest <span class="ent">➊</span>&#13;
#include &lt;boost/test/unit_test.hpp&gt;&#13;
#include &lt;functional&gt;&#13;
&#13;
struct IServiceBus {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct MockServiceBus : IServiceBus {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct AutoBrake {&#13;
  AutoBrake(IServiceBus&amp; bus)&#13;
    : collision_threshold_s{ 5 }/*,&#13;
      speed_mps{} */<span class="ent">➋</span> {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
BOOST_AUTO_TEST_CASE(InitialCarSpeedIsZero<span class="ent">➌</span>) {&#13;
  MockServiceBus bus{};&#13;
  AutoBrake auto_brake{ bus };&#13;
  BOOST_TEST(0 == auto_brake.get_speed_mps()); <span class="ent">➍</span>&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Running 1 test case...</span>&#13;
<span class="color1">C:/Users/josh/projects/cpp-book/manuscript/part_2/10-testing/samples/boost/</span>&#13;
<span class="color1">minimal.cpp(80): error: in "InitialCarSpeedIsZero": check 0 == auto_brake.</span>&#13;
<span class="color1">get_speed_mps() has failed [0 != -9.2559631349317831e+61] <span class="ent">➎</span></span>&#13;
<span class="color1">*** 1 failure is detected in the test module "AutoBrakeTest"</span></pre>&#13;
<p class="listing"><a id="ch10ex42"/><em>Listing 10-42: Intentionally commenting out the <span class="literal">speed_mps</span> member initializer to cause test failures (using Boost Test)</em></p>&#13;
<p class="indent">The test module name is <span class="literal">AutoBrakeTest</span> <span class="ent">➊</span>. After commenting out the <span class="literal">speed_mps</span> member initializer <span class="ent">➋</span>, you have the <span class="literal">InitialCarSpeedIsZero</span> test <span class="ent">➌</span>. The <span class="literal">BOOST_TEST</span> assertion tests whether <span class="literal">speed_mps</span> is zero <span class="ent">➍</span>. As with Catch and Google Test, you have an informative error message that tells you what went wrong <span class="ent">➎</span>.</p>&#13;
<h5 class="h5" id="ch10lev3sec38"><strong>Test Fixtures</strong></h5>&#13;
<p class="noindent">Like Google Test, Boost Test deals with common setup code using the notion of test fixtures. Using them is as simple as declaring an RAII object where the setup logic for the test is contained in that class’s constructor and the teardown logic is contained in the destructor. Unlike Google Test, you don’t have to derive from a parent class in your test fixture. The test fixtures work with any user-defined structure.</p>&#13;
<p class="indent">To use the test fixture in a unit test, you employ the <span class="literal">BOOST_FIXTURE_TEST_CASE</span> macro, which takes two parameters. The first parameter is the name of the unit test, and the second parameter is the test fixture class. Within <span epub:type="pagebreak" id="page_321"/>the body of the macro, you implement a unit test as if it were a method of the test fixture class, as demonstrated in <a href="ch10.xhtml#ch10ex43">Listing 10-43</a>.</p>&#13;
<pre>#define BOOST_TEST_MODULE TestModuleName&#13;
#include &lt;boost/test/unit_test.hpp&gt;&#13;
&#13;
struct MyTestFixture { }; <span class="ent">➊</span>&#13;
&#13;
BOOST_FIXTURE_TEST_CASE<span class="ent">➋</span>(MyTestA<span class="ent">➌</span>, MyTestFixture) {&#13;
  // Test A here&#13;
}&#13;
&#13;
BOOST_FIXTURE_TEST_CASE(MyTestB<span class="ent">➍</span>, MyTestFixture) {&#13;
  // Test B here&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Running 2 test cases...</span>&#13;
&#13;
<span class="color1">*** No errors detected</span></pre>&#13;
<p class="listing"><a id="ch10ex43"/><em>Listing 10-43: Illustrating Boost test fixture usage</em></p>&#13;
<p class="indent">Here, you define a class called <span class="literal">MyTestFixture</span> <span class="ent">➊</span> and use it as the second parameter for each instance of <span class="literal">BOOST_FIXTURE_TEST_CASE</span> <span class="ent">➋</span>. You declare two unit tests: <span class="literal">MyTestA</span> <span class="ent">➌</span> and <span class="literal">MyTestB</span> <span class="ent">➍</span>. Any setup you perform within <span class="literal">MyTestFixture</span> affects each <span class="literal">BOOST_FIXTURE_TEST_CASE</span>.</p>&#13;
<p class="indent">Next, you’ll use Boost Test fixtures to reimplement the <span class="literal">AutoBrake</span> test suite.</p>&#13;
<h5 class="h5" id="ch10lev3sec39"><strong>Refactoring AutoBrake Unit Tests with Boost Test</strong></h5>&#13;
<p class="noindent"><a href="ch10.xhtml#ch10ex44">Listing 10-44</a> implements the <span class="literal">AutoBrake</span> unit-test suite using Boost Test’s test fixture.</p>&#13;
<pre>#define BOOST_TEST_MODULE AutoBrakeTest&#13;
#include &lt;boost/test/unit_test.hpp&gt;&#13;
#include &lt;functional&gt;&#13;
&#13;
struct IServiceBus {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct MockServiceBus : IServiceBus {&#13;
  --<span class="codeitalic1">snip</span>--&#13;
};&#13;
&#13;
struct AutoBrakeTest { <span class="ent">➊</span>&#13;
  MockServiceBus bus{};&#13;
  AutoBrake auto_brake{ bus };&#13;
};&#13;
&#13;
BOOST_FIXTURE_TEST_CASE<span class="ent">➋</span>(InitialCarSpeedIsZero, AutoBrakeTest) {&#13;
  BOOST_TEST(0 == auto_brake.get_speed_mps());&#13;
}&#13;
<span epub:type="pagebreak" id="page_322"/>BOOST_FIXTURE_TEST_CASE(InitialSensitivityIsFive, AutoBrakeTest) {&#13;
  BOOST_TEST(5 == auto_brake.get_collision_threshold_s());&#13;
}&#13;
&#13;
BOOST_FIXTURE_TEST_CASE(SensitivityGreaterThanOne, AutoBrakeTest) {&#13;
  BOOST_REQUIRE_THROW(auto_brake.set_collision_threshold_s(0.5L),&#13;
                      std::exception);&#13;
}&#13;
&#13;
BOOST_FIXTURE_TEST_CASE(SpeedIsSaved, AutoBrakeTest) {&#13;
  bus.speed_update_callback(SpeedUpdate{ 100L });&#13;
  BOOST_TEST(100 == auto_brake.get_speed_mps());&#13;
  bus.speed_update_callback(SpeedUpdate{ 50L });&#13;
  BOOST_TEST(50 == auto_brake.get_speed_mps());&#13;
  bus.speed_update_callback(SpeedUpdate{ 0L });&#13;
  BOOST_TEST(0 == auto_brake.get_speed_mps());&#13;
}&#13;
&#13;
BOOST_FIXTURE_TEST_CASE(NoAlertWhenNotImminent, AutoBrakeTest) {&#13;
  auto_brake.set_collision_threshold_s(2L);&#13;
  bus.speed_update_callback(SpeedUpdate{ 100L });&#13;
  bus.car_detected_callback(CarDetected{ 1000L, 50L });&#13;
  BOOST_TEST(0 == bus.commands_published);&#13;
}&#13;
&#13;
BOOST_FIXTURE_TEST_CASE(AlertWhenImminent, AutoBrakeTest) {&#13;
  auto_brake.set_collision_threshold_s(10L);&#13;
  bus.speed_update_callback(SpeedUpdate{ 100L });&#13;
  bus.car_detected_callback(CarDetected{ 100L, 0L });&#13;
  BOOST_TEST(1 == bus.commands_published);&#13;
  BOOST_TEST(1L == bus.last_command.time_to_collision_s);&#13;
}&#13;
--------------------------------------------------------------------------&#13;
<span class="color1">Running 6 test cases...</span>&#13;
&#13;
<span class="color1">*** No errors detected</span></pre>&#13;
<p class="listing"><a id="ch10ex44"/><em>Listing 10-44: Using Boost Test to implement your unit tests</em></p>&#13;
<p class="indent">You define the test fixture class <span class="literal">AutoBrakeTest</span> to perform the setup of the <span class="literal">AutoBrake</span> and <span class="literal">MockServiceBus</span> <span class="ent">➊</span>. It’s identical to the Google Test test fixture except you didn’t need to inherit from any framework-issued parent classes. You represent each unit test with a <span class="literal">BOOST_FIXTURE_TEST_CASE</span> macro <span class="ent">➋</span>. The rest of the tests use the <span class="literal">BOOST_TEST</span> and <span class="literal">BOOST_REQUIRE_THROW</span> assertion macros; otherwise, the tests look very similar to Catch tests. Instead of <span class="literal">TEST_CASE</span> and <span class="literal">SECTION</span> elements, you have a test fixture class and <span class="literal">BOOST_FIXTURE_TEST_CASE</span>.</p>&#13;
<h4 class="h4" id="ch10lev2sec10"><strong><em>Summary: Testing Frameworks</em></strong></h4>&#13;
<p class="noindent">Although three different unit-testing frameworks were presented in this section, dozens of high-quality options are available. None of them is universally superior. Most frameworks support the same basic set of features, <span epub:type="pagebreak" id="page_323"/>whereas some of the more advanced features will have heterogeneous support. Mainly, you should select a unit-testing framework based on the style that makes you comfortable and productive.</p>&#13;
<h3 class="h3" id="ch10lev1sec4"><strong>Mocking Frameworks</strong></h3>&#13;
<p class="noindent">The unit-testing frameworks you just explored will work in a wide range of settings. It would be totally feasible to build integration tests, acceptance tests, unit tests, and even performance tests using Google Test, for example. The testing frameworks support a broad range of programming styles, and their creators have only modest opinions about how you must design your software to make them testable.</p>&#13;
<p class="indent">Mocking frameworks are a bit more opinionated than unit-testing frameworks. Depending on the mocking framework, you must follow certain design guidelines for how classes depend on each other. The <span class="literal">AutoBrake</span> class used a modern design pattern called <em>dependency injection</em>. The <span class="literal">AutoBrake</span> class depends on an <span class="literal">IServiceBus</span>, which you injected using the constructor of <span class="literal">AutoBrake</span>. You also made <span class="literal">IServiceBus</span> an interface. Other methods for achieving polymorphic behavior exist (like templates), and each involves trade-offs.</p>&#13;
<p class="indent">All the mocking frameworks discussed in this section work extremely well with dependency injection. To varying degrees, the mocking frameworks remove the need to define your own mocks. Recall that you implemented a <span class="literal">MockServiceBus</span> to allow you to unit test <span class="literal">AutoBrake</span>, as displayed in <a href="ch10.xhtml#ch10ex45">Listing 10-45</a>.</p>&#13;
<pre>struct MockServiceBus : IServiceBus {&#13;
  void publish(const BrakeCommand&amp; cmd) override {&#13;
    commands_published++;&#13;
    last_command = cmd;&#13;
  };&#13;
  void subscribe(SpeedUpdateCallback callback) override {&#13;
    speed_update_callback = callback;&#13;
  };&#13;
  void subscribe(CarDetectedCallback callback) override {&#13;
    car_detected_callback = callback;&#13;
  };&#13;
  BrakeCommand last_command{};&#13;
  int commands_published{};&#13;
  SpeedUpdateCallback speed_update_callback{};&#13;
  CarDetectedCallback car_detected_callback{};&#13;
};</pre>&#13;
<p class="listing"><a id="ch10ex45"/><em>Listing 10-45: Your hand-rolled <span class="literal">MockServiceBus</span></em></p>&#13;
<p class="indent">Each time you want to add a unit test involving some new kind of interaction with <span class="literal">IServiceBus</span>, you’ll likely need to update your <span class="literal">MockServiceBus</span> class. This is tedious and error prone. Additionally, it’s not clear that you can share this mock class with other teams: you’ve implemented a lot of your own logic in it that won’t be very useful to, say, the tire-pressure-sensor team. Also, each test might have different requirements. Mocking frameworks enables you to define mock classes, often using macro or template <span epub:type="pagebreak" id="page_324"/>voodoo. Within each unit test, you can customize the mock specifically for that test. This would be extremely difficult to do with a single mock definition.</p>&#13;
<p class="indent">This decoupling of the mock’s declaration from the mock’s test-specific definition is extremely powerful for two reasons. First, you can define different kinds of behavior for each unit test. This allows you to, for example, simulate exceptional conditions for some unit tests but not for others. Second, it makes the unit tests far more specific. By placing the custom mock’s behavior within a unit test rather than in a separate source file, it’s much clearer to the developer what the test is trying to achieve.</p>&#13;
<p class="indent">The net effect of using a mocking framework is that it makes mocking much less problematic. When mocking is easy, it makes good unit testing (and TDD) possible. Without mocking, unit testing can be very difficult; tests can be slow, unreliable, and brittle due to slow or error-prone dependencies. It’s generally preferable, for example, to use a mock database connection instead of a full-blown production instance while you’re trying to use TDD to implement new features into a class.</p>&#13;
<p class="indent">This section provides a tour of two mocking frameworks, Google Mock and HippoMocks, and includes a brief mention of two others, FakeIt and Trompeloeil. For technical reasons having to do with a lack of compile time code generation, creating a mocking framework is much harder in C++ than in most other languages, especially those with type reflection, a language feature that allows code to programmatically reason about type information. Consequently, there are a lot of high-quality mocking frameworks, each with their own trade-offs resulting from the fundamental difficulties associated with mocking C++.</p>&#13;
<h4 class="h4" id="ch10lev2sec11"><strong><em>Google Mock</em></strong></h4>&#13;
<p class="noindent">One of the most popular mocking frameworks is the Google C++ Mocking Framework (or Google Mock), which is included as part of Google Test. It’s one of the oldest and most feature-rich mocking frameworks. If you’ve already installed Google Test, incorporating Google Mock is easy. First, make sure you include the <span class="literal">gmock</span> static library in your linker, as you did for <span class="literal">gtest</span> and <span class="literal">gtest_main</span>. Next, add <span class="literal">#include "gmock/gmock.h"</span>.</p>&#13;
<p class="indent">If you’re using Google Test as your unit-testing framework, that’s all the setup you’ll need to do. Google Mock will work seamlessly with its sister library. If you’re using another unit-testing framework, you’ll need to provide the initialization code in the entry point of the binary, as shown in <a href="ch10.xhtml#ch10ex46">Listing 10-46</a>.</p>&#13;
<pre>#include "gmock/gmock.h"&#13;
&#13;
int main(int argc, char** argv) {&#13;
  ::testing::GTEST_FLAG(throw_on_failure) = true; <span class="ent">➊</span>&#13;
  ::testing::InitGoogleMock(&amp;argc, argv); <span class="ent">➋</span>&#13;
  // Unit test as usual, Google Mock is initialized&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex46"/><em>Listing 10-46: Adding Google Mock to a third-party unit-testing framework</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_325"/>The <span class="literal">GTEST_FLAG</span><span class="literal"> throw_on_failure</span> <span class="ent">➊</span> causes Google Mock to throw an exception when some mock-related assertion fails. The call to <span class="literal">InitGoogleMock</span> <span class="ent">➋</span> consumes the command line arguments to make any necessary customization (refer to the Google Mock documentation for more details).</p>&#13;
<h5 class="h5" id="ch10lev3sec40"><strong>Mocking an Interface</strong></h5>&#13;
<p class="noindent">For each interface you need to mock, there is some unfortunate ceremony. You need to take each <span class="literal">virtual</span> function of the interface and transmute it into a macro. For non-<span class="literal">const</span> methods, you use <span class="literal">MOCK_METHOD*</span>, and for <span class="literal">const</span> methods, you use <span class="literal">MOCK_CONST_METHOD*</span>, replacing <span class="literal">*</span> with the number of parameters that the function takes. The first parameter of <span class="literal">MOCK_METHOD</span> is the name of the <span class="literal">virtual</span> function. The second parameter is the function prototype. For example, to make a mock <span class="literal">IServiceBus</span>, you would build the definition shown in <a href="ch10.xhtml#ch10ex47">Listing 10-47</a>.</p>&#13;
<pre>struct MockServiceBus : IServiceBus { <span class="ent">➊</span>&#13;
  MOCK_METHOD1<span class="ent">➋</span>(publish<span class="ent">➌</span>, void(const BrakeCommand&amp; cmd)<span class="ent">➍</span>);&#13;
  MOCK_METHOD1(subscribe, void(SpeedUpdateCallback callback));&#13;
  MOCK_METHOD1(subscribe, void(CarDetectedCallback callback));&#13;
};</pre>&#13;
<p class="listing"><a id="ch10ex47"/><em>Listing 10-47: A Google Mock <span class="literal">MockServiceBus</span></em></p>&#13;
<p class="indent">The beginning of the definition of <span class="literal">MockServiceBus</span> is identical to the definition of any other <span class="literal">IServiceBus</span> implementation <span class="ent">➊</span>. You then employ <span class="literal">MOCK_METHOD</span> three times <span class="ent">➋</span>. The first parameter <span class="ent">➌</span> is the name of the <span class="literal">virtual</span> function, and the second parameter <span class="ent">➍</span> is the prototype of the function.</p>&#13;
<p class="indent">It’s a bit tedious to have to generate these definitions on your own. There’s no additional information in the <span class="literal">MockServiceBus</span> definition that isn’t already available in the <span class="literal">IServiceBus</span>. For better or worse, this is one of the costs of using Google Mock. You can take the sting out of generating this boilerplate by using the <span class="literal">gmock_gen.py</span> tool included in the <span class="literal">scripts/generator</span> folder of the Google Mock distribution. You’ll need Python 2 installed, and it’s not guaranteed to work in all situations. See the Google Mock documentation for more information.</p>&#13;
<p class="indent">Now that you’ve defined a <span class="literal">MockServiceBus</span>, you can use it in your unit tests. Unlike the mock you defined on your own, you can configure a Google Mock specifically for each unit test. You have an incredible amount of flexibility in this configuration. The key to successful mock configuration is the use of appropriate expectations.</p>&#13;
<h5 class="h5" id="ch10lev3sec41"><strong>Expectations</strong></h5>&#13;
<p class="noindent">An <em>expectation</em> is like an assertion for a mock object; it expresses the circumstances in which the mock expects to be called and what it should do in response. The “circumstances” are specified using objects called <em>matchers</em>. The “what it should do in response” part is called an <em>action</em>. The sections that follow will introduce each of these concepts.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_326"/>Expectations are declared with the <span class="literal">EXPECT_CALL</span> macro. The first parameter to this macro is the mock object, and the second is the expected method call. This method call can optionally contain matchers for each parameter. These matchers help Google Mock decide whether a particular method invocation qualifies as an expected call. The format is as follows:</p>&#13;
<pre>EXPECT_CALL(<span class="codeitalic1">mock_object</span>, <span class="codeitalic1">method</span>(<span class="codeitalic1">matchers</span>))</pre>&#13;
<p class="indent">There are several ways to formulate assertions about expectations, and which you choose depends on how strict your requirements are for how the unit being tested interacts with the mock. Do you care whether your code calls mocked functions that you didn’t expect? It really depends on the application. That’s why there are three options: naggy, nice, and strict.</p>&#13;
<p class="indent">A <em>naggy mock</em> is the default. If a naggy mock’s function is called and no <span class="literal">EXPECT_CALL</span> matches the call, Google Mock will print a warning about an “uninteresting call,” but the test won’t fail just because of the uninteresting call. You can just add an <span class="literal">EXPECT_CALL</span> into the test as a quick fix to suppress the uninteresting call warning, because the call then ceases to be unexpected.</p>&#13;
<p class="indent">In some situations, there might be too many uninteresting calls. In such cases, you should use a <em>nice mock</em>. The nice mock won’t produce a warning about uninteresting calls.</p>&#13;
<p class="indent">If you’re very concerned about any interaction with the mock that you haven’t accounted for, you might use a <em>strict mock</em>. Strict mocks will fail the test if any call is made to the mock for which you don’t have a corresponding <span class="literal">EXPECT_CALL</span>.</p>&#13;
<p class="indent">Each of these types of mocks is a class template. The way to instantiate these classes is straightforward, as outlined in <a href="ch10.xhtml#ch10ex48">Listing 10-48</a>.</p>&#13;
<pre>MockServiceBus naggy_mock<span class="ent">➊</span>;&#13;
::testing::NiceMock&lt;MockServiceBus&gt; nice_mock<span class="ent">➋</span>;&#13;
::testing::StrictMock&lt;MockServiceBus&gt; strict_mock<span class="ent">➌</span>;</pre>&#13;
<p class="listing"><a id="ch10ex48"/><em>Listing 10-48: Three different styles of Google Mock</em></p>&#13;
<p class="indent">Naggy mocks <span class="ent">➊</span> are the default. Every <span class="literal">::testing::NiceMock</span> <span class="ent">➋</span> and <span class="literal">::testing::StrictMock</span> <span class="ent">➌</span> takes a single template parameter, the class of the underlying mock. All three of these options are perfectly valid first parameters to an <span class="literal">EXPECT_CALL</span>.</p>&#13;
<p class="indent">As a general rule, you should use nice mocks. Using naggy and strict mocks can lead to very brittle tests. When you’re using a strict mock, consider whether it’s really necessary to be so restrictive about the way the unit under test collaborates with the mock.</p>&#13;
<p class="indent">The second parameter to <span class="literal">EXPECT_CALL</span> is the name of the method you expect to be called followed by the parameters you expect the method to be called with. Sometimes, this is easy. Other times, there are more complicated conditions you want to express for what invocations match and don’t match. In such situations, you use matchers.</p>&#13;
<h5 class="h5" id="ch10lev3sec42"><span epub:type="pagebreak" id="page_327"/><strong>Matchers</strong></h5>&#13;
<p class="noindent">When a mock’s method takes arguments, you have broad discretion over whether an invocation matches the expectation. In simple cases, you can use literal values. If the mock method is invoked with exactly the specified literal value, the invocation matches the expectation; otherwise, it doesn’t. On the other extreme, you can use Google Mock’s <span class="literal">::testing::_</span> object, which tells Google Mock that <em>any</em> value matches.</p>&#13;
<p class="indent">Suppose, for example, that you want to invoke <span class="literal">publish</span>, and you don’t care what the argument is. The <span class="literal">EXPECT_CALL</span> in <a href="ch10.xhtml#ch10ex49">Listing 10-49</a> would be appropriate.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
using ::testing::_; <span class="ent">➊</span>&#13;
&#13;
TEST(AutoBrakeTest, PublishIsCalled) {&#13;
  MockServiceBus bus;&#13;
  EXPECT_CALL(bus, publish(_<span class="ent">➋</span>));&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex49"/><em>Listing 10-49: Using the <span class="literal">::testing::_</span> matcher in an expectation</em></p>&#13;
<p class="indent">To make the unit test nice and tidy, you employ a <span class="literal">using</span> for <span class="literal">::testing::_</span><span class="ent">➊</span>. You use <span class="literal">_</span> to tell Google Mock that <em>any</em> invocation of <span class="literal">publish</span> with a single argument will match <span class="ent">➋</span>.</p>&#13;
<p class="indent">A slightly more selective matcher is the class template <span class="literal">::testing::A</span>, which will match only if a method is invoked with a particular type of parameter. This type is expressed as the template parameter to <span class="literal">A</span>, so <span class="literal">A&lt;MyType&gt;</span> will match only a parameter of type <span class="literal">MyType</span>. In <a href="ch10.xhtml#ch10ex50">Listing 10-50</a>, the modification to <a href="ch10.xhtml#ch10ex49">Listing 10-49</a> illustrates a more restrictive expectation that requires a <span class="literal">BrakeCommand</span> as the parameter to <span class="literal">publish</span>.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
using ::testing::A; <span class="ent">➊</span>&#13;
&#13;
TEST(AutoBrakeTest, PublishIsCalled) {&#13;
  MockServiceBus bus;&#13;
  EXPECT_CALL(bus, publish(A&lt;BrakeCommand&gt;()<span class="ent">➋</span>));&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex50"/><em>Listing 10-50: Using the <span class="literal">::testing::A</span> matcher in an expectation</em></p>&#13;
<p class="indent">Again, you employ <span class="literal">using</span> <span class="ent">➊</span> and use <span class="literal">A&lt;BrakeCommand&gt;</span> to specify that only a <span class="literal">BrakeCommand</span> will match this expectation.</p>&#13;
<p class="indent">Another matcher, <span class="literal">::testing::Field</span>, allows you to inspect fields on arguments passed to the mock. The <span class="literal">Field</span> matcher takes two parameters: a pointer to the field you want to expect and then another matcher to express whether the pointed-to field meets the criteria. Suppose you want to be even more specific about the call to <span class="literal">publish</span> <span class="ent">➋</span>: you want to specify that the <span class="literal">time_to_collision_s</span> is equal to 1 second. You can accomplish this task with the refactor of <a href="ch10.xhtml#ch10ex49">Listing 10-49</a> shown in <a href="ch10.xhtml#ch10ex51">Listing 10-51</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_328"/>--<span class="codeitalic1">snip</span>--&#13;
using ::testing::Field; <span class="ent">➊</span>&#13;
using ::testing::DoubleEq; <span class="ent">➋</span>&#13;
&#13;
TEST(AutoBrakeTest, PublishIsCalled) {&#13;
  MockServiceBus bus;&#13;
  EXPECT_CALL(bus, publish(Field(&amp;BrakeCommand::time_to_collision_s<span class="ent">➌</span>,&#13;
                                 DoubleEq(1L)<span class="ent">➍</span>)));&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex51"/><em>Listing 10-51: Using the <span class="literal">Field</span> matcher in an expectation</em></p>&#13;
<p class="indent">You employ <span class="literal">using</span> for <span class="literal">Field</span> <span class="ent">➊</span> and <span class="literal">DoubleEq</span> <span class="ent">➋</span> to clean up the expectation code a bit. The <span class="literal">Field</span> matcher takes a pointer to the field you’re interested in <span class="literal">time_to_collision_s</span> <span class="ent">➌</span> and the matcher that decides whether the field meets the criteria <span class="literal">DoubleEq</span> <span class="ent">➍</span>.</p>&#13;
<p class="indent">Many other matchers are available, and they’re summarized in <a href="ch10.xhtml#ch10tab02">Table 10-2</a>. But refer to the Google Mock documentation for all the details about their usages.</p>&#13;
<p class="tabcap"><a id="ch10tab02"><strong>Table 10-2:</strong> Google Mock Matchers</a></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Matcher</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Matches when argument is . . .</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">_</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Any value of the correct type</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">A&lt;</span><span class="codeitalic">type</span><span class="literal">&gt;)()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Of the given <span class="literal"><em>type</em></span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">An&lt;</span><span class="codeitalic">type</span><span class="literal">&gt;)()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Of the given <span class="literal"><em>type</em></span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">Ge(</span><span class="codeitalic">value</span><span class="literal">)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Greater than or equal to <span class="literal"><em>value</em></span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">Gt(<span class="codeitalic">value</span>)</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Greater than <span class="literal"><em>value</em></span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">Le</span>(<span class="codeitalic">value</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Less than or equal to <span class="literal"><em>value</em></span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">Lt(</span><span class="codeitalic">value</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Less than <span class="literal"><em>value</em></span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">Ne(</span><span class="codeitalic">value</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Not equal to <span class="literal"><em>value</em></span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">IsNull()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Null</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">NotNull()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Not null</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">Ref</span>(<span class="codeitalic">variable</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A reference to <span class="literal"><em>variable</em></span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">DoubleEq</span>(<span class="codeitalic">variable</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A <span class="literal">double</span> value approximately equal to <span class="literal"><em>variable</em></span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">FloatEq</span>(<span class="codeitalic">variable</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A <span class="literal">float</span> value approximately equal to <span class="literal"><em>variable</em></span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">EndsWith</span>(<span class="codeitalic">str</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A string ending with <span class="literal"><em>str</em></span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">HasSubstr</span>(<span class="codeitalic">str</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A string containing the substring <span class="literal"><em>str</em></span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">StartsWith</span>(<span class="codeitalic">str</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A string starting with <span class="literal"><em>str</em></span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">StrCaseEq</span>(<span class="codeitalic">str</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A string equal to <span class="literal"><em>str</em></span> (ignoring case)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">StrCaseNe</span>(<span class="codeitalic">str</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">A string not equal to <span class="literal"><em>str</em></span> (ignoring case)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">StrEq</span>(<span class="codeitalic">str</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">A string equal to <span class="literal"><em>str</em></span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">StrNeq</span>(<span class="codeitalic">string</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">A string not equal to <span class="literal"><em>str</em></span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_329"/><em>One beneficial feature of matchers is that you can use them as an alternate kind of assertion for your unit tests. The alternate macro is one of <span class="literal">EXPECT_THAT</span></em>(<span class="literal">value, matcher</span>) or <span class="literal"><em>ASSERT_THAT</em></span>(<span class="literal">value, matcher</span>). <em>For example, you could replace the assertion</em></p>&#13;
<pre>ASSERT_GT(power_level, 9000);</pre>&#13;
<p class="noindent"><em>with the more syntactically pleasing</em></p>&#13;
<pre>ASSERT_THAT(power_level, Gt(9000));</pre>&#13;
</div>&#13;
<p class="indent">You can use <span class="literal">EXPECT_CALL</span> with <span class="literal">StrictMock</span> to enforce how the unit under test interacts with the mock. But you might also want to specify how many times the mock should respond to calls. This is called the expectation’s <em>cardinality</em>.</p>&#13;
<h5 class="h5" id="ch10lev3sec43"><strong>Cardinality</strong></h5>&#13;
<p class="noindent">Perhaps the most common method for specifying cardinality is <span class="literal">Times</span>, which specifies the number of times that a mock should expect to be called. The <span class="literal">Times</span> method takes a single parameter, which can be an integer literal or one of the functions listed in <a href="ch10.xhtml#ch10tab03">Table 10-3</a>.</p>&#13;
<p class="tabcap"><a id="ch10tab03"><strong>Table 10-3:</strong> A Listing of the Cardinality Specifiers in Google Mock</a></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Cardinality</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Specifies that a method will be called . . .</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">AnyNumber()</span></p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Any number of times</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">AtLeast</span>(<span class="codeitalic">n</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">At least <span class="codeitalic">n</span> times</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">AtMost</span>(<span class="codeitalic">n</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">At most <span class="codeitalic">n</span> times</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">Between</span>(<span class="codeitalic">m</span><span class="literal">,</span> <span class="codeitalic">n</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Between <span class="codeitalic">m</span> and <span class="codeitalic">n</span> times</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba"><span class="literal">Exactly</span>(<span class="codeitalic">n</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b2"><p class="taba">Exactly <span class="codeitalic">n</span> times</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><a href="ch10.xhtml#ch10ex52">Listing 10-52</a> elaborates <a href="ch10.xhtml#ch10ex51">Listing 10-51</a> to indicate that <span class="literal">publish</span> must be called only once.</p>&#13;
<pre>--<span class="codeitalic1">snip</span>--&#13;
using ::testing::Field;&#13;
using ::testing::DoubleEq;&#13;
&#13;
TEST(AutoBrakeTest, PublishIsCalled) {&#13;
  MockServiceBus bus;&#13;
  EXPECT_CALL(bus, publish(Field(&amp;BrakeCommand::time_to_collision_s,&#13;
                                 DoubleEq(1L)))).Times(1)<span class="ent">➊</span>;&#13;
  --<span class="codeitalic1">snip</span>--&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex52"/><em>Listing 10-52: Using the <span class="literal">Times</span> cardinality specifier in an expectation</em></p>&#13;
<p class="indent">The <span class="literal">Times</span> call <span class="ent">➊</span> ensures that <span class="literal">publish</span> gets called exactly once (regardless of whether you use a nice, strict, or naggy mock).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_330"/><em>Equivalently, you could have specified <span class="codeitalic">Times(Exactly(1))</span>.</em></p>&#13;
</div>&#13;
<p class="indent">Now that you have some tools to specify the criteria and cardinality for an expected invocation, you can customize how the mock should respond to expectations. For this, you employ actions.</p>&#13;
<h5 class="h5" id="ch10lev3sec44"><strong>Actions</strong></h5>&#13;
<p class="noindent">Like cardinalities, all actions are chained off <span class="literal">EXPECT_CALL</span> statements. These statements can help clarify how many times a mock expects to be called, what values to return each time it’s called, and any side effects (like throwing an exception) it should perform. The <span class="literal">WillOnce</span> and <span class="literal">WillRepeatedly</span> actions specify what a mock should do in response to a query. These actions can get quite complicated, but for brevity’s sake, this section covers two usages. First, you can use the <span class="literal">Return</span> construct to return values to the caller:</p>&#13;
<pre>EXPECT_CALL(jenny_mock, get_your_number()) <span class="ent">➊</span>&#13;
  .WillOnce(Return(8675309)) <span class="ent">➋</span>&#13;
  .WillRepeatedly(Return(911))<span class="ent">➌</span>;</pre>&#13;
<p class="indent">You set up an <span class="literal">EXPECT_CALL</span> the usual way and then tag on some actions that specify what value the <span class="literal">jenny_mock</span> will return each time <span class="literal">get_your_number</span> is called <span class="ent">➊</span>. These are read sequentially from left to right, so the first action, <span class="literal">WillOnce</span> <span class="ent">➋</span>, specifies that the first time <span class="literal">get_your_number</span> is called, the value <span class="literal">8675309</span> is returned by <span class="literal">jenny_mock</span>. The next action, <span class="literal">WillRepeatedly</span> <span class="ent">➌</span>, specifies that for all subsequent calls, the value <span class="literal">911</span> will be returned.</p>&#13;
<p class="indent">Because <span class="literal">IServiceBus</span> doesn’t return any values, you’ll need the action to be a little more involved. For highly customizable behavior, you can use the <span class="literal">Invoke</span> construct, which enables you to pass an <span class="literal">Invocable</span> that will get called with the exact arguments passed into the mock’s method. Let’s say you want to save off a reference to the callback function that the <span class="literal">AutoBrake</span> registers via <span class="literal">subscribe</span>. You can do this easily with an <span class="literal">Invoke</span>, as illustrated in <a href="ch10.xhtml#ch10ex53">Listing 10-53</a>.</p>&#13;
<pre>CarDetectedCallback callback; <span class="ent">➊</span>&#13;
EXPECT_CALL(bus, subscribe(A&lt;CarDetectedCallback&gt;()))&#13;
    .Times(1)&#13;
    .WillOnce(Invoke([&amp;callback<span class="ent">➋</span>](const auto&amp; callback_in<span class="ent">➌</span>) {&#13;
      callback = callback_in; <span class="ent">➍</span>&#13;
    }));</pre>&#13;
<p class="listing"><a id="ch10ex53"/><em>Listing 10-53: Using <span class="literal">Invoke</span> to save off a reference to the <span class="literal">subscribe</span> callback registered by an <span class="literal">AutoBrake</span></em></p>&#13;
<p class="indent">The first (and only) time that <span class="literal">subscribe</span> is called with a <span class="literal">CarDetectedCallback</span>, the <span class="literal">WillOnce(Invoke(...))</span> action will call the lambda that’s been passed in as a parameter. This lambda captures the <span class="literal">CarDetectedCallback</span> declared <span class="ent">➊</span> by reference <span class="ent">➋</span>. By definition, the lambda has the same function prototype as the <span class="literal">subscribe</span> function, so you can use auto-type deduction <span class="ent">➌</span> to determine the correct type for <span class="literal">callback_in</span> (it’s <span class="literal">CarDetectedCallback</span>). Finally, you assign <span class="literal">callback_in</span> to <span class="literal">callback</span> <span class="ent">➍</span>. Now, you can pass events off to whoever <span class="literal">subscribes</span> <span epub:type="pagebreak" id="page_331"/>simply by invoking your <span class="literal">callback</span> <span class="ent">➊</span>. The <span class="literal">Invoke</span> construct is the Swiss Army Knife of actions, because you get to execute arbitrary code with full information about the invocation parameters. <em>Invocation parameters</em> are the parameters that the mocked method received at runtime.</p>&#13;
<h5 class="h5" id="ch10lev3sec45"><strong>Putting It All Together</strong></h5>&#13;
<p class="noindent">Reconsidering our <span class="literal">AutoBrake</span> testing suite, you can reimplement the Google Test unit-test binary to use Google Mock rather than the hand-rolled mock, as demonstrated in <a href="ch10.xhtml#ch10ex54">Listing 10-54</a>.</p>&#13;
<pre>#include "gtest/gtest.h"&#13;
#include "gmock/gmock.h"&#13;
#include &lt;functional&gt;&#13;
&#13;
using ::testing::_;&#13;
using ::testing::A;&#13;
using ::testing::Field;&#13;
using ::testing::DoubleEq;&#13;
using ::testing::NiceMock;&#13;
using ::testing::StrictMock;&#13;
using ::testing::Invoke;&#13;
&#13;
struct NiceAutoBrakeTest : ::testing::Test { <span class="ent">➊</span>&#13;
  NiceMock&lt;MockServiceBus&gt; bus;&#13;
  AutoBrake auto_brake{ bus };&#13;
};&#13;
&#13;
struct StrictAutoBrakeTest : ::testing::Test { <span class="ent">➋</span>&#13;
  StrictAutoBrakeTest() {&#13;
    EXPECT_CALL(bus, subscribe(A&lt;CarDetectedCallback&gt;())) <span class="ent">➌</span>&#13;
      .Times(1)&#13;
      .WillOnce(Invoke([this](const auto&amp; x) {&#13;
        car_detected_callback = x;&#13;
      }));&#13;
    EXPECT_CALL(bus, subscribe(A&lt;SpeedUpdateCallback&gt;())) <span class="ent">➍</span>&#13;
      .Times(1)&#13;
      .WillOnce(Invoke([this](const auto&amp; x) {&#13;
        speed_update_callback = x;&#13;
      }));;&#13;
  }&#13;
  CarDetectedCallback car_detected_callback;&#13;
  SpeedUpdateCallback speed_update_callback;&#13;
  StrictMock&lt;MockServiceBus&gt; bus;&#13;
};&#13;
&#13;
TEST_F(NiceAutoBrakeTest, InitialCarSpeedIsZero) {&#13;
  ASSERT_DOUBLE_EQ(0, auto_brake.get_speed_mps());&#13;
}&#13;
&#13;
TEST_F(NiceAutoBrakeTest, InitialSensitivityIsFive) {&#13;
  ASSERT_DOUBLE_EQ(5, auto_brake.get_collision_threshold_s());&#13;
}&#13;
&#13;
<span epub:type="pagebreak" id="page_332"/>TEST_F(NiceAutoBrakeTest, SensitivityGreaterThanOne) {&#13;
  ASSERT_ANY_THROW(auto_brake.set_collision_threshold_s(0.5L));&#13;
}&#13;
&#13;
TEST_F(StrictAutoBrakeTest, NoAlertWhenNotImminent) {&#13;
  AutoBrake auto_brake{ bus };&#13;
&#13;
  auto_brake.set_collision_threshold_s(2L);&#13;
  speed_update_callback(SpeedUpdate{ 100L });&#13;
  car_detected_callback(CarDetected{ 1000L, 50L });&#13;
}&#13;
&#13;
TEST_F(StrictAutoBrakeTest, AlertWhenImminent) {&#13;
  EXPECT_CALL(bus, publish(&#13;
                       Field(&amp;BrakeCommand::time_to_collision_s, DoubleEq{ 1L&#13;
}))&#13;
                   ).Times(1);&#13;
  AutoBrake auto_brake{ bus };&#13;
  auto_brake.set_collision_threshold_s(10L);&#13;
  speed_update_callback(SpeedUpdate{ 100L });&#13;
  car_detected_callback(CarDetected{ 100L, 0L });&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex54"/><em>Listing 10-54: Reimplementing your unit tests using a Google Mock rather than a roll-your-own mock</em></p>&#13;
<p class="indent">Here, you actually have two different test fixtures: <span class="literal">NiceAutoBrakeTest</span> <span class="ent">➊</span> and <span class="literal">StrictAutoBrakeTest</span> <span class="ent">➋</span>. The <span class="literal">NiceAutoBrakeTest</span> test instantiates a <span class="literal">NiceMock</span>. This is useful for <span class="literal">InitialCarSpeedIsZero, InitialSensitivityIsFive</span>, and <span class="literal">SensitivityGreaterThanOne</span>, because you don’t want to test any meaningful interactions with the mock; it’s not the focus of these tests. But you do want to focus on <span class="literal">AlertWhenImminent</span> and <span class="literal">NoAlertWhenNotImminent</span>. Each time an event is published or a type is subscribed to, it could have potentially major ramifications on your system. The paranoia of a <span class="literal">StrictMock</span> here is warranted.</p>&#13;
<p class="indent">In the <span class="literal">StrictAutoBrakeTest</span> definition, you can see the <span class="literal">WillOnce</span>/<span class="literal">Invoke</span> approach to saving off the callbacks for each subscription <span class="ent">➌➍</span>. These are used in <span class="literal">AlertWhenImminent</span> and <span class="literal">NoAlertWhenNotImminent</span> to simulate events coming off the service bus. It gives the unit tests a nice, clean, succinct feel, even though there’s a lot of mocking logic going on behind the scenes. Remember, you don’t even require a working service bus to do all this testing!</p>&#13;
<h4 class="h4" id="ch10lev2sec12"><strong><em>HippoMocks</em></strong></h4>&#13;
<p class="noindent">Google Mock is one of the original C++ mocking frameworks, and it’s still a mainstream choice today. HippoMocks is an alternative mocking framework created by Peter Bindels. As a header-only library, HippoMocks is trivial <span epub:type="pagebreak" id="page_333"/>to install. Simply pull down the latest version from GitHub (<a href="https://github.com/dascandy/hippomocks/">https://github.com/dascandy/hippomocks/</a>). You must include the <span class="literal">"hippomocks.h"</span> header in your tests. HippoMocks will work with any testing framework.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>At press time, the latest version of HippoMocks is v5.0.</em></p>&#13;
</div>&#13;
<p class="indent">To create a mock using HippoMocks, you start by instantiating a <span class="literal">MockRespository</span> object. By default, all the mocks derived from this <span class="literal">MockRepository</span> will require <em>strict ordering</em> of expectations. Strictly ordered expectations cause a test to fail if each of the expectations is not invoked in the exact order you’ve specified. Usually, this is not what you want. To modify this default behavior, set the <span class="literal">autoExpect</span> field on <span class="literal">MockRepository</span> to <span class="literal">false</span>:</p>&#13;
<pre>MockRepository mocks;&#13;
mocks.autoExpect = false;</pre>&#13;
<p class="indent">Now you can use <span class="literal">MockRepository</span> to generate a mock of <span class="literal">IServiceBus</span>. This is done through the (member) function template <span class="literal">Mock</span>. This function will return a pointer to your newly minted mock:</p>&#13;
<pre>auto* bus = mocks.Mock&lt;IServiceBus&gt;();</pre>&#13;
<p class="indent">A major selling point of <span class="literal">HippoMocks</span> is illustrated here: notice that you didn’t need to generate any macro-laden boilerplate for the mock <span class="literal">IServiceBus</span> like you did for Google Mock. The framework can handle vanilla interfaces without any further effort on your part.</p>&#13;
<p class="indent">Setting up expectations is very straightforward as well. For this, use the <span class="literal">ExpectCall</span> macro on <span class="literal">MockRespository</span>. The <span class="literal">ExpectCall</span> macro takes two parameters: a pointer to your mock and a pointer to the method you’re expecting:</p>&#13;
<pre>mocks.ExpectCall(bus, IServiceBus::subscribe_to_speed)</pre>&#13;
<p class="indent">This example adds an expectation that <span class="literal">bus.subscribe_to_speed</span> will be invoked. You have several matchers you can add to this expectation, as summarized in <a href="ch10.xhtml#ch10tab04">Table 10-4</a>.</p>&#13;
<p class="tabcap"><a id="ch10tab04"><strong>Table 10-4:</strong> HippoMocks Matchers</a></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Matcher</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Specifies that an expectation matches when . . .</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">With</span>(<span class="codeitalic">args</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">The invocation parameters match <span class="literal"><em>args</em></span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">Match</span>(<span class="codeitalic">predicate</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal"><em>predicate</em></span> invoked with the invocation parameters returns true</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">After</span>(<span class="codeitalic">expectation</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal"><em>expectation</em></span> has already been satisfied (This is useful for referring to a previously registered call.)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">You can define actions to perform in response to <span class="literal">ExpectCall</span>, as summarized in <a href="ch10.xhtml#ch10tab05">Table 10-5</a>.</p>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_334"/><a id="ch10tab05"><strong>Table 10-5:</strong> HippoMocks Actions</a></p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Action</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Does the following upon invocation:</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba"><span class="literal">Return</span>(<span class="codeitalic">value</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b1"><p class="taba">Returns <span class="literal"><em>value</em></span> to the caller</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">Throw</span>(<span class="codeitalic">exception</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-b"><p class="taba">Throws <span class="literal"><em>exception</em></span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">Do</span>(<span class="codeitalic">callable</span>)</p></td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">Executes <span class="literal"><em>callable</em></span> with the invocation parameters</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">By default, HippoMocks requires an expectation to be met exactly once (like Google Mock’s <span class="literal">.Times(1)</span> cardinality).</p>&#13;
<p class="indent">For example, you can express the expectation that <span class="literal">publish</span> is called with a <span class="literal">BrakeCommand</span> having a <span class="literal">time_to_collision_s</span> of <span class="literal">1.0</span> in the following way:</p>&#13;
<pre>mocks.ExpectCall<span class="ent">➊</span>(bus, IServiceBus::publish)&#13;
  .Match<span class="ent">➋</span>([](const BrakeCommand&amp; cmd) {&#13;
    return cmd.time_to_collision_s == Approx(1); <span class="ent">➌</span>&#13;
  });</pre>&#13;
<p class="indent">You use <span class="literal">ExpectCall</span> to specify that <span class="literal">bus</span> should be called with the <span class="literal">publish</span> method <span class="ent">➊</span>. You refine this expectation with the <span class="literal">Match</span> matcher <span class="ent">➋</span>, which takes a predicate accepting the same arguments as the <span class="literal">publish</span> method—a single <span class="literal">const BrakeCommand</span> reference. You return <span class="literal">true</span> if the <span class="literal">time_to_collision_s</span> field of the <span class="literal">BrakeCommand</span> is 1.0; otherwise, you return <span class="literal">false</span> <span class="ent">➌</span>, which is fully compatible.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>As of v5.0, HippoMocks doesn’t have built-in support for approximate matchers. Instead, Catch’s <span class="literal">Approx</span> <span class="ent">➌</span> was used.</em></p>&#13;
</div>&#13;
<p class="indent">HippoMocks supports function overloads for free functions. It also supports overloads for methods, but the syntax is not very pleasing to the eye. If you are using HippoMocks, it is best to avoid method overloads in your interface, so it would be better to refactor <span class="literal">IServiceBus</span> along the following lines:</p>&#13;
<pre>struct IServiceBus {&#13;
  virtual ~IServiceBus() = default;&#13;
  virtual void publish(const BrakeCommand&amp;) = 0;&#13;
  virtual void subscribe_to_speed(SpeedUpdateCallback) = 0;&#13;
  virtual void subscribe_to_car_detected(CarDetectedCallback) = 0;&#13;
};</pre>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>One design philosophy states that it’s undesirable to have an overloaded method in an interface, so if you subscribe to that philosophy, the lack of support in HippoMocks is a moot point.</em></p>&#13;
</div>&#13;
<p class="indent">Now <span class="literal">subscribe</span> is no longer overloaded, and it’s possible to use HippoMocks. <a href="ch10.xhtml#ch10ex55">Listing 10-55</a> refactors the test suite to use HippoMocks with Catch.</p>&#13;
<pre><span epub:type="pagebreak" id="page_335"/>#include "hippomocks.h"&#13;
--<span class="codeitalic1">snip</span>--&#13;
TEST_CASE("AutoBrake") {&#13;
  MockRepository mocks; <span class="ent">➊</span>&#13;
  mocks.autoExpect = false;&#13;
  CarDetectedCallback car_detected_callback;&#13;
  SpeedUpdateCallback speed_update_callback;&#13;
  auto* bus = mocks.Mock&lt;IServiceBus&gt;();&#13;
  mocks.ExpectCall(bus, IServiceBus::subscribe_to_speed) <span class="ent">➋</span>&#13;
    .Do([&amp;](const auto&amp; x) {&#13;
      speed_update_callback = x;&#13;
    });&#13;
  mocks.ExpectCall(bus, IServiceBus::subscribe_to_car_detected) <span class="ent">➌</span>&#13;
    .Do([&amp;](const auto&amp; x) {&#13;
    car_detected_callback = x;&#13;
  });&#13;
  AutoBrake auto_brake{ *bus };&#13;
&#13;
  SECTION("initializes speed to zero") {&#13;
    REQUIRE(auto_brake.get_speed_mps() == Approx(0));&#13;
  }&#13;
&#13;
  SECTION("initializes sensitivity to five") {&#13;
    REQUIRE(auto_brake.get_collision_threshold_s() == Approx(5));&#13;
  }&#13;
&#13;
  SECTION("throws when sensitivity less than one") {&#13;
    REQUIRE_THROWS(auto_brake.set_collision_threshold_s(0.5L));&#13;
  }&#13;
&#13;
  SECTION("saves speed after update") {&#13;
    speed_update_callback(SpeedUpdate{ 100L }); <span class="ent">➍</span>&#13;
    REQUIRE(100L == auto_brake.get_speed_mps());&#13;
    speed_update_callback(SpeedUpdate{ 50L });&#13;
    REQUIRE(50L == auto_brake.get_speed_mps());&#13;
    speed_update_callback(SpeedUpdate{ 0L });&#13;
    REQUIRE(0L == auto_brake.get_speed_mps());&#13;
  }&#13;
&#13;
  SECTION("no alert when not imminent") {&#13;
    auto_brake.set_collision_threshold_s(2L);&#13;
    speed_update_callback(SpeedUpdate{ 100L }); <span class="ent">➎</span>&#13;
    car_detected_callback(CarDetected{ 1000L, 50L });&#13;
  }&#13;
&#13;
  SECTION("alert when imminent") {&#13;
    mocks.ExpectCall(bus, IServiceBus::publish) <span class="ent">➏</span>&#13;
      .Match([](const auto&amp; cmd) {&#13;
        return cmd.time_to_collision_s == Approx(1);&#13;
      });&#13;
&#13;
    auto_brake.set_collision_threshold_s(10L);&#13;
    speed_update_callback(SpeedUpdate{ 100L });&#13;
<span epub:type="pagebreak" id="page_336"/>    car_detected_callback(CarDetected{ 100L, 0L });&#13;
  }&#13;
}</pre>&#13;
<p class="listing"><a id="ch10ex55"/><em>Listing 10-55: Reimplementing <a href="ch10.xhtml#ch10ex54">Listing 10-54</a> to use HippoMocks and Catch rather than Google Mock and Google Test.</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>This section couples HippoMocks with Catch for demonstration purposes, but HippoMocks works with all the unit-testing frameworks discussed in this chapter.</em></p>&#13;
</div>&#13;
<p class="indent">You create the <span class="literal">MockRepository</span> <span class="ent">➊</span> and relax the strict ordering requirements by setting <span class="literal">autoExpect</span> to <span class="literal">false</span>. After declaring the two callbacks, you create an <span class="literal">IServiceBusMock</span> (without having to define a mock class!), and then set expectations <span class="ent">➋➌</span> that will hook up your callback functions with <span class="literal">AutoBrake</span>. Finally, you create <span class="literal">auto_brake</span> using a reference to the mock bus.</p>&#13;
<p class="indent">The <span class="literal">initializes speed to zero, initializes sensitivity to five</span>, and <span class="literal">throws when sensitivity less than one</span> tests require no further interaction with the mock. In fact, as a strict mock, <span class="literal">bus</span> won’t let any further interactions happen without complaining. Because HippoMocks doesn’t allow nice mocks like Google Mock, this is actually a fundamental difference between <a href="ch10.xhtml#ch10ex54">Listing 10-54</a> and <a href="ch10.xhtml#ch10ex55">Listing 10-55</a>.</p>&#13;
<p class="indent">In the <span class="literal">saves speed after update</span> test <span class="ent">➍</span>, you issue a series of <span class="literal">speed_update</span> callbacks and assert that the speeds are saved off correctly as before. Because <span class="literal">bus</span> is a strict mock, you’re also implicitly asserting that no further interaction happens with the service bus here.</p>&#13;
<p class="indent">In the <span class="literal">no alert when not imminent</span> test, no changes are needed to <span class="literal">speed_update_callback</span> <span class="ent">➎</span>. Because the mock is strict (and you don’t expect a <span class="literal">BrakeCommand</span> to get published), no further expectations are needed.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>HippoMocks offers the <span class="literal">NeverCall</span> method on its mocks, which will improve the clarity of your tests and errors if it’s called.</em></p>&#13;
</div>&#13;
<p class="indent">However, in the <span class="literal">alert when imminent</span> test, you expect that your program will invoke <span class="literal">publish</span> on a <span class="literal">BrakeCommand</span>, so you set up this expectation <span class="ent">➏</span>. You use the <span class="literal">Match</span> matcher to provide a predicate that checks for <span class="literal">time_to_collision_s</span> to equal approximately <span class="literal">1</span>. The rest of the test is as before: you send <span class="literal">AutoBrake</span> a <span class="literal">SpeedUpdate</span> event and a subsequent <span class="literal">CarDetected</span> event that should cause a collision to be detected.</p>&#13;
<p class="indent">HippoMocks is a more streamlined mocking framework than Google Mock is. It requires far less ceremony, but it’s a little less flexible.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>One area where HippoMocks is <em>more</em> flexible than Google Mock is in mocking free functions. HippoMocks can mock free functions and static class functions directly, whereas Google Mock requires you to rewrite the code to use an interface.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch10lev2sec13"><span epub:type="pagebreak" id="page_337"/><strong><em>A Note on Other Mocking Options: FakeIt and Trompeloeil</em></strong></h4>&#13;
<p class="noindent">A number of other excellent mocking frameworks are available. But for the sake of keeping an already long chapter from getting much longer, let’s briefly look at two more frameworks: FakeIt (by Eran Pe’er, available at <em><a href="https://github.com/eranpeer/FakeIt/">https://github.com/eranpeer/FakeIt/</a></em>) and Trompeloeil (by Björn Fahller, available at <em><a href="https://github.com/rollbear/trompeloeil/">https://github.com/rollbear/trompeloeil/</a></em>).</p>&#13;
<p class="indent">FakeIt is similar to HippoMocks in its succinct usage patterns, and it’s a header-only library. It differs in that it follows the record-by-default pattern in building expectations. Rather than specifying expectations up front, FakeIt verifies that a mock’s methods were invoked correctly at the <em>end</em> of the test. Actions, of course, are still specified at the beginning.</p>&#13;
<p class="indent">Although this is a totally valid approach, I prefer the Google Mock/HippoMocks approach of specifying expectations—and their associated actions—all up front in one concise location.</p>&#13;
<p class="indent">Trompeloeil (from the French <em>trompe-l’œil</em> for “deceive the eye”) can be considered a modern replacement for Google Mock. Like Google Mock, it requires some macro-laden boilerplate for each of the interfaces you want to mock. In exchange for this extra effort, you gain many powerful features, including actions, such as setting test variables, returning values based on invocation parameters, and forbidding particular invocations. Like Google Mock and HippoMocks, Trompeloeil requires you to specify your expectations and actions up front (see the documentation for more details).</p>&#13;
<h3 class="h3" id="ch10lev1sec5"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter used an extended example of building the automatic braking system for an autonomous vehicle to explore the basics of TDD. You rolled your own testing and mocking framework, then learned about the many benefits of using available testing and mocking frameworks. You toured Catch, Google Test, and Boost Test as possible testing frameworks. For mocking frameworks, you dove into Google Mock and HippoMocks (with a brief mention of FakeIt and Trompeloeil). Each of these frameworks has strengths and weaknesses. Which you choose should be driven principally by which frameworks make you most efficient and productive.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For the remainder of the book, examples will be couched in terms of unit tests. Accordingly, I had to choose a framework for the examples. I’ve chosen Catch for a few reasons. First, Catch’s syntax is the most succinct, and it lends itself well to book form. In header-only mode, Catch compiles much quicker than Boost Test. This might be considered an endorsement of the framework (and it is), but it’s not my intention to discourage the use of Google Test, Boost Test, or any other testing framework. You should make such decisions after careful consideration (and hopefully some experimentation.)</em></p>&#13;
</div>&#13;
<div class="box5" id="bm01">&#13;
<p class="boxtitle-d"><span epub:type="pagebreak" id="page_338"/><strong>EXERCISES</strong></p>&#13;
<p class="noindent"><strong>10-1.</strong> Your car company has completed work on a service that detects speed limits based on signage it observes on the side of the road. The speed-limit-detection team will publish objects of the following type to the event bus periodically:</p>&#13;
<pre>struct SpeedLimitDetected {&#13;
  unsigned short speed_mps;&#13;
}</pre>&#13;
<p class="indent">The service bus has been extended to incorporate this new type:</p>&#13;
<pre>#include &lt;functional&gt;&#13;
--snip--&#13;
using SpeedUpdateCallback = std::function&lt;void(const SpeedUpdate&amp;)&gt;;&#13;
using CarDetectedCallback = std::function&lt;void(const CarDetected&amp;)&gt;;&#13;
using SpeedLimitCallback = std::function&lt;void(const SpeedLimitDetected&amp;)&gt;;&#13;
&#13;
struct IServiceBus {&#13;
  virtual ~IServiceBus() = default;&#13;
  virtual void publish(const BrakeCommand&amp;) = 0;&#13;
  virtual void subscribe(SpeedUpdateCallback) = 0;&#13;
  virtual void subscribe(CarDetectedCallback) = 0;&#13;
  virtual void subscribe(SpeedLimitCallback) = 0;&#13;
};</pre>&#13;
<p class="indent">Update the service with the new interface and make sure the tests still pass.</p>&#13;
<p class="noindent"><strong>10-2.</strong> Add a private field for the last known speed limit. Implement a getter method for this field.</p>&#13;
<p class="noindent"><strong>10-3.</strong> The product owner wants you to initialize the last known speed limit to 39 meters per second. Implement a unit test that checks a newly constructed AutoBrake that has a last known speed limit of 39.</p>&#13;
<p class="noindent"><strong>10-4.</strong> Make unit tests pass.</p>&#13;
<p class="noindent"><strong>10-5.</strong> Implement a unit test where you publish three different <span class="literal">SpeedLimitDetected</span> objects using the same callback technique you used for <span class="literal">SpeedUpdate</span> and  <span class="literal">CarDetected</span>. After invoking each of the callbacks, check the last known speed limit on the <span class="literal">AutoBrake</span> object to ensure it matches.</p>&#13;
<p class="noindent"><strong>10-6.</strong> Make all unit tests pass.</p>&#13;
<p class="noindent"><strong>10-7.</strong> Implement a unit test where the last known speed limit is 35 meters per second, and you’re traveling at 34 meters per second. Ensure that no <span class="literal">BrakeCommand</span> is published by  <span class="literal">AutoBrake</span>.</p>&#13;
<p class="noindent"><strong>10-8.</strong> Make all unit tests pass.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_339"/><strong>10-9.</strong> Implement a unit test where the last known speed limit is 35 meters per second and then publish a <span class="literal">SpeedUpdate</span> at 40 meters per second. Ensure  that exactly one <span class="literal">BrakeCommand</span> is issued. The <span class="literal">time_to_collision_s</span> field  should equal 0.</p>&#13;
<p class="noindent"><strong>10-10.</strong> Make all unit tests pass.</p>&#13;
<p class="noindent"><strong>10-11.</strong> Implement a new unit test where the last known speed limit is 35 meters per second and then publish a <span class="literal">SpeedUpdate</span> at 30 meters per second. Then issue a <span class="literal">SpeedLimitDetected</span> with a <span class="literal">speed_mps</span> of 25 meters per second. Ensure that exactly one  <span class="literal">BrakeCommand</span> is issued. The <span class="literal">time_to_collision_s</span> field should equal 0.</p>&#13;
<p class="noindent"><strong>10-12.</strong> Make all unit tests pass.</p>&#13;
</div>&#13;
<div class="box6" id="bm02">&#13;
<p class="boxtitle-d"><strong>FURTHER READING</strong></p>&#13;
<ul>&#13;
<li class="noindent"><em>Specification by Example</em> by Gojko Adzic (Manning, 2011)</li>&#13;
<li class="noindent"><em>BDD in Action</em> by John Ferguson Smart (Manning, 2014)</li>&#13;
<li class="noindent"><em>Optimized C++: Proven Techniques for Heightened Performance</em> by Kurt Guntheroth (O’Reilly, 2016)</li>&#13;
<li class="noindent"><em>Agile Software Development and Agile Principles, Patterns, and Practices in C#</em> by Robert C. Martin (Prentice Hall, 2006)</li>&#13;
<li class="noindent"><em>Test-Driven Development: By Example</em> by Kent Beck (Pearson, 2002)</li>&#13;
<li class="noindent"><em>Growing Object-Oriented Software, Guided by Tests</em> by Steve Freeman and Nat Pryce (Addison-Wesley, 2009)</li>&#13;
<li class="noindent">“Editor war.” <em><a href="https://en.wikipedia.org/wiki/Editor_war">https://en.wikipedia.org/wiki/Editor_war</a></em></li>&#13;
<li class="noindent">“Tabs versus Spaces: An Eternal Holy War” by Jamie Zawinski. <em><a href="https://www.jwz.org/doc/tabs-vs-spaces.html">https://www.jwz.org/doc/tabs-vs-spaces.html</a></em></li>&#13;
<li class="noindent">“Is TDD dead?” by Martin Fowler. <em><a href="https://martinfowler.com/articles/is-tdd-dead/">https://martinfowler.com/articles/is-tdd-dead/</a></em></li>&#13;
</ul>&#13;
</div>&#13;
</body></html>