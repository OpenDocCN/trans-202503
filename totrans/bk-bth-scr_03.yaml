- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 2 VARIABLES AND VALUES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2 变量和值
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/chapter.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/chapter.jpg)'
- en: Now that we’re ready to start coding, we’ll explore variables, values, and the
    Batch set command, which assigns values to variables. Although these topics may
    seem trivial if you’ve coded in other languages, Batch has some unique quirks
    that are worth noting.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备开始编码，我们将探讨变量、值和 Batch 的 set 命令，后者用于将值分配给变量。虽然这些话题如果你在其他语言中有过编码经验可能显得微不足道，但
    Batch 有一些独特的怪癖，值得注意。
- en: You’ll learn how to display the value of a variable in the console to confirm
    that it has been set correctly. Additionally, I’ll introduce the *command separator*,
    which allows you to enter multiple commands on a single line. I’ll also show you
    how to create remarks and set variables that are saved on your computer and remain
    available even after the bat file is closed. Finally, you’ll learn how to access
    documentation for any Batch command at the command prompt, a useful skill for
    anyone working with bat files.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何在控制台显示变量的值，以确认它已经正确设置。此外，我将介绍 *命令分隔符*，它允许你在一行中输入多个命令。我还会向你展示如何创建注释以及如何设置保存到你计算机上的变量，这些变量即使在关闭
    bat 文件后也能继续使用。最后，你将学习如何在命令提示符下访问任何 Batch 命令的文档，这对任何使用 bat 文件的人来说都是一项有用的技能。
- en: Setting and Resolving a Variable
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置和解析变量
- en: A *variable* is a named field defining a place in memory that holds a value
    for later use. Many if not most languages allow, and usually require, variables
    to be defined as a particular data type, often some sort of text or number, before
    they can be assigned a value. Batch will have none of this; variables come into
    existence the first time they are “set” to a value, and that value can contain
    letters, numbers, and other characters. It’s then up to the coder to treat them
    as certain data types, or not. In [Chapters 5](chapter5.xhtml) and [6](chapter6.xhtml)
    I’ll return to ways to handle data types, but this chapter focuses on the seemingly
    simple task of assigning a value to a variable.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量* 是一个命名字段，定义了一个内存位置，用于存储稍后使用的值。许多甚至大多数语言允许并通常要求在赋值之前定义变量的特定数据类型，通常是某种文本或数字类型。但
    Batch 不这么做；变量在第一次被“设置”值时就会存在，而且该值可以包含字母、数字和其他字符。之后，程序员可以选择将其视为某种数据类型，或者不做任何处理。在
    [第 5 章](chapter5.xhtml) 和 [第 6 章](chapter6.xhtml) 中，我会回到如何处理数据类型的方法，但本章重点讨论将值赋给变量这一看似简单的任务。'
- en: 'To consider one example of a variable, a coder might have a field that contains
    the state of their mood; whether it be for narcissistic or obsessive-compulsive
    reasons is of little importance. The variable is defined as or named myMood, and
    two possible values out of many are happy and sad. To set the variable to happy,
    you would use, obviously enough, the set command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以变量为例，程序员可能有一个字段来表示他们的心情状态；无论是出于自恋还是强迫症原因都无关紧要。该变量定义为或命名为 myMood，可能的两种值是 happy
    和 sad。要将变量设置为 happy，显然可以使用 set 命令：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After this executes, the myMood variable contains the value happy.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作后，myMood 变量将包含值 happy。
- en: 'If the topic is particularly bewildering, the following command wipes out the
    prior value and replaces it with a different one:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个话题特别令人困惑，以下命令会清除之前的值，并用不同的值替换它：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: But how do you know for sure the value of this or any other variable? In Batch,
    the act of revealing the value of a variable is referred to as *resolving a variable*,
    and it’s usually done by surrounding the variable with percent signs. That is,
    %myMood% will resolve to nonplussed after the prior set command executes. Now,
    to actually see the results of resolving a variable, we’ll need a bit of a digression—a
    very important digression.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但你怎么能确定这个或任何其他变量的值呢？在 Batch 中，揭示变量的值被称为 *解析变量*，通常是通过将变量用百分号包围来完成的。也就是说，%myMood%
    会在执行先前的 set 命令后解析为 nonplussed。现在，为了实际看到解析变量的结果，我们需要稍微偏离一下——一个非常重要的偏离。
- en: Displaying the Value of a Variable
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示变量的值
- en: In this section, you’ll learn how to quickly display the resolved value of a
    variable on your computer screen, but this technique will be useful for far more
    than just that. We’ll return to it in future chapters to demonstrate many other
    features of Batch, such as using it as a testing technique, which is instrumental
    for any Batch coder.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何快速显示计算机屏幕上已解析的变量值，但这种技巧不仅仅用于此。我们将在未来的章节中回到这一点，展示 Batch 的其他许多特性，例如将其作为测试技术，这对于任何
    Batch 程序员来说都是至关重要的。
- en: Writing to the Console
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 写入控制台
- en: 'To display the contents of a variable on the screen, we need two additional
    commands: echo and pause. To demonstrate, let’s create a small bat file. Open
    a new folder on your computer, perhaps *C:\Batch\*, and in it, create a bat file
    called *Mood.bat* that contains the three lines shown in [Listing 2-1](#Lis2-1).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要在屏幕上显示一个变量的内容，我们需要两个额外的命令：echo 和 pause。为了演示，让我们创建一个小的 bat 文件。打开计算机上的一个新文件夹，可能是
    *C:\Batch\*，然后在其中创建一个名为 *Mood.bat* 的 bat 文件，文件内容为 [Listing 2-1](#Lis2-1) 中显示的三行。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 2-1: The bat file, Mood.bat, displays a resolved variable.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 2-1: bat 文件 Mood.bat 显示已解析的变量'
- en: If you double-click or open *Mood.bat*, the bat file should execute, and a black
    window with white text should appear. This window is the DOS window, or *console*,
    which is how I’ll refer to it throughout this book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你双击或打开 *Mood.bat*，bat 文件应该会执行，并且一个黑色窗口将显示白色文字。这个窗口是 DOS 窗口，或称为 *控制台*，在本书中我会称它为控制台。
- en: We’ve already discussed the set command in the first line of [Listing 2-1](#Lis2-1).
    In this context, the echo command writes out the remainder of the statement, excluding
    the space succeeding the actual text echo, to the console. The text My mood is
    and a trailing space is displayed, followed by the contents or the value of myMood—that
    is, the text happy—and the trailing period. The pause command keeps the console
    open. Without it, the window would open and close before you could read it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 [Listing 2-1](#Lis2-1) 的第一行讨论过 set 命令。在此上下文中，echo 命令将剩余的语句（不包括实际文本 echo
    后面的空格）输出到控制台。显示的文本是 "My mood is" 和一个尾随的空格，然后是 myMood 的内容或值——也就是文本 happy——以及尾随的句点。pause
    命令保持控制台打开。如果没有它，窗口会在你来得及阅读之前打开并关闭。
- en: '[Listing 2-2](#Lis2-2) shows everything written to the console when this bat
    file executes, which is more than you may have expected.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 2-2](#Lis2-2) 显示了当这个 bat 文件执行时写入控制台的所有内容，这比你预期的可能还要多。'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 2-2: The console display of the Mood.bat bat file'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 2-2: Mood.bat bat 文件的控制台显示'
- en: Each command is preceded with the current directory, *C:\Batch\*, followed by
    a greater-than sign (>) as a delimiter. (You’ll learn more about the current directory
    in [Chapter 8](chapter8.xhtml). For now, just consider it to be the path of the
    bat file being executed.)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令前面都有当前目录 *C:\Batch\*，然后是一个大于号（>）作为分隔符。（你将在 [第8章](chapter8.xhtml) 中了解当前目录的更多内容。现在，只需将其视为正在执行的
    bat 文件的路径。）
- en: The first line shows the execution of the set command, and the second shows
    the execution of the echo command. The third line is the result of executing that
    echo—that is, the output to the console described in [Listing 2-2](#Lis2-2). You
    can tell that it’s not a command because of the lack of the preceding text *C:\Batch>*.
    More important, %myMood% resolves to the text happy. The pause command also creates
    output, the text Press any key to continue ... , and as the message indicates,
    the execution is on hold until any key is depressed, at which point the bat file
    will end, and the console will close. Also, notice that the set command doesn’t
    produce any output since it’s just setting the value of a variable—there’s nothing
    to output.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行显示了 set 命令的执行，第二行显示了 echo 命令的执行。第三行是执行 echo 命令后的结果——即 [Listing 2-2](#Lis2-2)
    中描述的输出到控制台。你可以从缺少前缀文本 *C:\Batch>* 来判断它不是一个命令。更重要的是，%myMood% 解析为文本 happy。pause
    命令也会生成输出，显示文本 Press any key to continue ... ，正如消息所示，执行会暂停，直到按下任意键，此时 bat 文件将结束，控制台也会关闭。另外，注意
    set 命令不会生成任何输出，因为它只是设置一个变量的值——没有东西需要输出。
- en: Cleaning Up the Console
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 清理控制台
- en: 'One problem with what’s written to the console is that it’s a mess with commands
    interspersed with the desired output from the echo and pause commands. In [Chapter
    12](chapter12.xhtml), you’ll learn more about the various outputs and how to manage
    them; here we’ll just look at a quick means of cleaning this up. An echo command
    followed by the argument off is executed at the top of the *Mood.bat* bat file
    from [Listing 2-1](#Lis2-1):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 输出到控制台的问题之一是，命令与来自 echo 和 pause 命令的期望输出交织在一起，造成了一团乱。有关不同输出和如何管理它们的更多内容，你将在 [第12章](chapter12.xhtml)
    中学习；在这里，我们只快速看一下清理这些内容的方式。在 *Mood.bat* 文件的顶部执行一个 echo 命令，后跟参数 off，正如 [Listing
    2-1](#Lis2-1) 中所示：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This echo off command suppresses not the actual output of the subsequent commands
    but rather the lines showing that each of those commands is being executed—that
    is, the line prefixed with the current directory. Also, prefixing the echo command
    with the at sign (@) suppresses its own execution from being written to the console.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: echo off 命令并不是抑制后续命令的实际输出，而是抑制显示每个命令正在执行的行——即，显示当前目录的那一行。此外，在 echo 命令前加上 @ 符号，可以抑制它自身执行的内容不显示在控制台上。
- en: 'Compared to [Listing 2-2](#Lis2-2), the console display is now much cleaner
    when the modified bat file is executed:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [Listing 2-2](#Lis2-2) 相比，当执行修改后的 bat 文件时，控制台的显示变得更加简洁：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we can easily demonstrate how to initialize the myMood variable to the
    gloomy value and then reset it to the cheerful value:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以轻松演示如何将 myMood 变量初始化为忧郁值，然后将其重置为快乐值：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The result shows the same variable resolved to two different values at two
    different times:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示相同的变量在不同时间解析为两个不同的值：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As our bat files become more complex, the echo command can send the output
    to someplace other than the console (see [Chapter 12](chapter12.xhtml) for more
    details). Prepending the command with > con explicitly redirects the data to the
    console:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的 bat 文件变得越来越复杂，echo 命令可以将输出发送到控制台以外的其他地方（有关更多细节，请参见 [第12章](chapter12.xhtml)）。通过在命令前加上
    > con，可以显式地将数据重定向到控制台：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This technique will be very useful in coming chapters to demonstrate what’s
    going on in a code snippet. For the sake of brevity, I won’t include the initial
    echo off and trailing pause commands in later examples, but I encourage you to
    add them to clean up and hold open the console.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术将在后续章节中非常有用，用于演示代码片段中的操作。为了简洁起见，后面的示例中我不会包含初始的 echo off 和尾随的 pause 命令，但我建议你添加它们来清理并保持控制台开启。
- en: The Idiosyncrasies of the set Command
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: set 命令的特性
- en: Setting variables is usually a straightforward topic for most coding languages,
    but Batch isn’t like most coding languages. All Batch coders need to understand
    the following idiosyncrasies of the set command to avoid some level of future
    pain.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 设置变量通常是大多数编程语言中的简单话题，但批处理并不像大多数编程语言。所有批处理程序员都需要理解以下 set 命令的特性，以避免将来可能遇到的一些问题。
- en: Case Sensitivity
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 大小写敏感性
- en: 'Closely inspect the following two commands. They look a little different but
    are functionally equivalent:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查以下两个命令。它们看起来有些不同，但功能上是等效的：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Batch commands and variables are case-insensitive. Here the set command is uppercase
    in one command and lowercase in the other, but the interpreter treats them both
    the same. You also could’ve used Set with no change in functionality. For good
    measure, sET and SeT also work in the same fashion, but you’d have to be a real
    contrarian to code in such a manner. Likewise, you can use the myMood, MYMOOD,
    and mymood variables interchangeably. The value, however, is stored just as it’s
    typed, so it’s case-sensitive. If the variable is set to WHIMSICAL, it will be
    resolved as WHIMSICAL; likewise, if it’s set to Whimsical, it will be resolved
    as Whimsical.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理命令和变量不区分大小写。这里 set 命令在一个命令中是大写的，在另一个命令中是小写的，但解释器将它们视为相同。你也可以使用 Set，而功能不受影响。为了保险起见，sET
    和 SeT 也能以相同方式工作，但你得真是个反叛者才会这样编码。同样，你可以交替使用 myMood、MYMOOD 和 mymood 变量。然而，变量的值是按输入的方式存储的，因此它是区分大小写的。如果变量被设置为
    WHIMSICAL，它将被解析为 WHIMSICAL；同样，如果设置为 Whimsical，它将被解析为 Whimsical。
- en: It’s all a matter of style and personal preference. I find that many bat files
    have far too much content capitalized. Capitalization is meant to make something
    stand out, but nothing stands out when everything is flashing neon. Most Batch
    coders capitalize all the letters in command names, but in this book I use only
    lowercase characters for all Batch commands. Also, I greatly prefer camel case
    variables.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全是风格和个人偏好的问题。我发现许多 bat 文件中过多的内容都被大写了。大写本应让某些东西突出，但如果一切都在闪烁霓虹灯，什么也就没法突出。大多数批处理程序员将命令名称中的所有字母都大写，但在本书中，我使用小写字符来表示所有批处理命令。此外，我更喜欢使用驼峰命名法的变量。
- en: NOTE
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: Camel case *text is easily readable even though it contains multiple words not
    separated by spaces or other characters. The first letter of camel case text can
    be either uppercase (head up) or lowercase (head down). But to qualify as camel
    case, the first letter of all subsequent words must be capitalized with the rest
    of the word being lowercase. An example of the* head up *variant (also called*
    Pascal *or* upper camel case*) is MyMood. The corresponding* head down *variant
    (also called* dromedary *or* lower camel case*) would be myMood. Imagine a camel
    drinking water with his head down.*
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 驼峰式命名*文本易于阅读，即使它包含多个没有空格或其他字符分隔的单词。驼峰式命名的第一个字母可以是大写（首字母大写）或小写（首字母小写）。但要符合驼峰式命名规则，所有后续单词的第一个字母必须大写，其余部分小写。一个*首字母大写*变体（也叫做*Pascal*或*大驼峰命名法*）是
    MyMood。对应的*首字母小写*变体（也叫做*dromedary*或*小驼峰命名法*）将是 myMood。想象一下，一只骆驼低着头喝水。*
- en: Valid Variable Characters
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 有效的变量字符
- en: Most programming languages have strict rules concerning the list of permissible
    characters in variable names. Typically, numbers and the 26 letters of the alphabet,
    uppercase and lowercase, are allowed, with just a few special characters to boot.
    But Batch is unique in that nearly every character on the keyboard is a valid
    variable name character, although you should avoid using numbers as the first
    character in a variable name. (While you can set variables named with a leading
    digit, resolving them is problematic, and I’ll explain why in [Chapter 3](chapter3.xhtml).)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都有严格的规则，规定了变量名中可使用的字符列表。通常，数字和 26 个字母（大小写均可）是允许的，另外还有一些特殊字符可以使用。但批处理语言不同，几乎键盘上的每个字符都是有效的变量名字符，尽管你应该避免将数字作为变量名的第一个字符。（虽然你可以设置以数字开头的变量名，但解决这些变量时会有问题，为什么会这样，我会在[第
    3 章](chapter3.xhtml)中解释。）
- en: A few characters are illegal because they have specific uses in Batch; for example,
    the tilde (~), ampersand (&), percent sign (%), and the less-than (<) and greater-than
    (>) signs are reserved characters, but several others would surprise any coder
    not already familiar with Batch. The three set commands in [Listing 2-3](#Lis2-3)
    successfully set these three variables with odd-looking single-character names
    to their respective descriptions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一些字符是非法的，因为它们在批处理语言中有特定用途；例如，波浪号 (~)、和号 (&)、百分号 (%)，以及小于号 (<) 和大于号 (>) 是保留字符，但其他一些字符会让任何不熟悉批处理语言的程序员感到惊讶。
    [列表 2-3](#Lis2-3) 中的三个 set 命令成功地将这三个具有奇怪单字符名称的变量设置为它们各自的描述。
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 2-3: Setting variables with odd-looking single-character names'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-3：设置具有奇怪单字符名称的变量
- en: The echo command in [Listing 2-3](#Lis2-3) writes the text semicolon at hashtag
    to the console.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-3](#Lis2-3) 中的 echo 命令将文本分号和井号写入控制台。'
- en: 'Even the following monstrosity stores the text This actually works in the variable
    with a dollar sign, dot, and mismatched brackets:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是以下这种怪异的做法，也能将文本“这确实有效”存储到包含美元符号、点和不匹配括号的变量中：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This variable name demonstrates what’s possible, but it’s hard to read and not
    recommended.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量名展示了可能的内容，但它难以阅读，并不推荐使用。
- en: 'Judicious use of such characters in variable names, however, can be a handy
    tool. For example, a group of related variables might all have a leading or trailing
    underscore as a visual cue to that relationship; number can be abbreviated as
    #, which is even more succinct than nbr and clearer than no. Much later in this
    book I’ll use this interesting feature to build arrays and hash tables with meaningful
    names containing brackets.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，明智地使用这些字符在变量名中，可以成为一个方便的工具。例如，一组相关的变量可能都带有前导或尾部的下划线，作为它们之间关系的视觉提示；数字可以用
    # 来表示，这比 nbr 更简洁，也比 no 更清晰。在本书的后面，我将利用这个有趣的特性构建包含括号的有意义的数组和哈希表。'
- en: Spaces Around the Assignment Operator
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 等号两侧的空格
- en: The following classic rookie mistake bites most new Batch coders familiar with
    other languages. Inspect the set command shown in [Listing 2-4](#Lis2-4) carefully.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是大多数新手批处理程序员在学习其他语言时常犯的经典错误。仔细检查[列表 2-4](#Lis2-4)中显示的 set 命令。
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 2-4: Setting a variable with spaces around the equal sign'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-4：设置带有等号两侧空格的变量
- en: If you expect the result of the echo command to be
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你期望 echo 命令的结果是
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'that would be an understandable mistake, but a mistake nonetheless. The result
    is actually this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 那将是一个可以理解的错误，但仍然是错误。实际结果是这样的：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The empty quotes mean that X isn’t set or is set to null, meaning nothing at
    all, not even a space.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 空的引号意味着 X 没有被设置，或者被设置为 null，意味着根本没有任何内容，甚至没有空格。
- en: NOTE
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*In [Chapter 1](chapter1.xhtml), I mentioned that inside the command prompt,
    the syntax and output can differ in comparison to a bat file, and this is a prime
    example. The same code entered at the command prompt displays the attempted resolution
    of the unset variable very differently:*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 [第 1 章](chapter1.xhtml) 中，我提到过在命令提示符下，语法和输出可能与 bat 文件有所不同，这是一个典型的例子。在命令提示符下输入相同的代码，显示的是对未设置变量的尝试解析，表现得非常不同：*'
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*I won’t be noting every discrepancy in the pages ahead, so if you see any
    future anomalies working at the command prompt, try putting the code in a bat
    file.*'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我不会在接下来的页面中指出每个差异，因此如果你在命令提示符下看到任何异常，尝试将代码放入 bat 文件中。*'
- en: Now, the set command in [Listing 2-4](#Lis2-4) isn’t all that complex, and it
    clearly is setting X to the text Hello, correct? Furthermore, it looks a lot like
    assignment commands in other more modern languages that would’ve performed the
    assignment as desired.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，[Listing 2-4](#Lis2-4) 中的 set 命令并不复杂，显然是在将 X 设置为文本 Hello，对吧？而且它看起来与其他更现代的语言中的赋值命令很像，应该会按预期进行赋值。
- en: 'This is our first *batveat* (Batch caveat; see the Introduction for details
    on batveats). The key to this issue is the space preceding the equal sign. The
    Batch interpreter is as literal as difficult teenagers, too smart and unforgiving
    for their own good. The variable name starts with the first nonspace character
    after the set command and ends with the character just before the assignment operator
    or equal sign—no matter what that character is. Therefore, the variable being
    set here is two characters in length, an X followed by a space:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个 *batveat*（批处理警告；有关 batveat 的详细信息，请参见介绍部分）。这个问题的关键是等号前的空格。批处理解释器就像难搞的青少年一样，聪明而且无情，对自己都不好。变量名从
    set 命令后的第一个非空格字符开始，到赋值运算符或等号之前的字符结束——不管这个字符是什么。因此，这里设置的变量由两个字符组成，一个 X 后跟一个空格：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The %X% resolved to nothing, but %X % does have a value, and that value is Hello,
    correct? Not quite; this is our second batveat. The value of the variable is the
    string of characters after the equal sign extending to the end of the statement.
    Therefore, the assigned value is the space after the equal sign followed by the
    five characters in the word Hello.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '%X% 没有解析出任何内容，但 %X % 确实有一个值，这个值是 Hello，对吧？其实不完全是；这是我们的第二个警告。变量的值是等号后的字符串，一直到语句的末尾。因此，赋值的内容是等号后面的空格，然后是单词
    Hello 中的五个字符。'
- en: 'Let’s modify the echo command from [Listing 2-4](#Lis2-4) like so:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们像这样修改 [Listing 2-4](#Lis2-4) 中的 echo 命令：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Resolving the variable with the trailing space now reveals its value, which
    contains a leading space:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，解决带空格的变量会显示其值，而该值包含一个前导空格：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This works, but typically a variable name with a trailing space is an accident
    waiting to happen. We even can embed spaces in the middle of a variable name,
    but there’s a big difference between being able to do something and it being a
    good idea. This in no way should be construed as an invitation to create cryptic
    code; it’s more of a warning about spaces around the equal sign in a set command.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可行，但通常变量名后带空格是一个潜在的意外。我们甚至可以在变量名中间嵌入空格，但能做某件事和做这件事是个好主意之间有很大区别。这绝不应被解读为鼓励创建晦涩的代码；这更像是一个关于在
    set 命令中等号两侧空格的警告。
- en: 'Taking one last pass of [Listing 2-4](#Lis2-4), let’s remove the spaces before
    and after the equal sign and go back to the original echo command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看 [Listing 2-4](#Lis2-4)，我们去掉等号前后空格，回到原始的 echo 命令：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we get the desired result written to the console:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到了写入控制台的预期结果：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: An even easier mistake to make is to add an unintentional space or two to the
    end of a line trailing the value. Because it won’t be obvious just looking at
    the text in the editor, it’s quite easy to miss. (In Notepad++, go to **View**
    ▶ **Show Symbol** ▶ **Show Space and Tab** to represent spaces as faint dots.
    Other good editors will have a similar feature.)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更容易犯的错误是无意中在行末加上一个或两个空格。因为在编辑器中看不到空格，这很容易被忽略。（在 Notepad++ 中，进入 **查看** ▶ **显示符号**
    ▶ **显示空格和制表符**，可以将空格显示为淡点。其他优秀的编辑器也会有类似的功能。）
- en: There are valid reasons to prepend or append a variable’s value with spaces,
    as you’ll learn later in this book, but be careful not to do it by accident. However,
    I’m hard-pressed to come up with an example of a variable’s name legitimately
    being appended with one or more spaces. Ensure that there’s no space between the
    variable name and the equal sign when using a basic set command.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书后面你会学到，有些有效的原因会将变量的值前置或后置空格，但一定要小心不要不小心这样做。然而，我很难想到一个合法的例子，说明变量的名称后面会被附加一个或多个空格。在使用基本的
    set 命令时，确保变量名和等号之间没有空格。
- en: The Command Separator
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令分隔符
- en: 'The ampersand is a special character that functions as a command separator;
    it’s not treated like simple text. For instance, you can string the three lines
    of code from [Listing 2-3](#Lis2-3) together into a single line, with each command
    separated by the & character:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '& 符号是一个特殊字符，作为命令分隔符使用，它不像普通文本那样处理。例如，你可以将 [Listing 2-3](#Lis2-3) 中的三行代码串联成一行，每个命令之间用
    & 字符分隔：'
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is functionally equivalent to the three commands on three distinct lines.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这在功能上等同于将三个命令写在三行上。
- en: On occasion this technique is useful for consolidating simple and similar commands,
    but using it excessively can make the code difficult to read. However, I’ve found
    two very handy uses for the command separator.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这种技巧对于合并简单且相似的命令很有用，但过度使用它会使代码难以阅读。然而，我发现了命令分隔符的两个非常有用的应用。
- en: Appending Remarks to a Command
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向命令添加备注
- en: 'One use of the command separator is to add text at the end of a line so that
    it’s treated as a comment. The rem command creates a *remark* out of the text
    that follows it. Typically, we place a rem command on the line (or lines) preceding
    some interesting code as a comment, but we also can attach it to a specific command
    with the command separator. For instance, the following two lines perform the
    same logic:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 命令分隔符的一个用途是将文本添加到一行的末尾，使其被视为注释。rem 命令将其后面的文本变成*注释*。通常，我们会在某些有趣的代码前面（或前几行）放置
    rem 命令作为注释，但我们也可以将它与特定命令一起使用，通过命令分隔符来附加它。例如，下面的两行执行相同的逻辑：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The second line, however, provides a little more information to anyone reading
    the code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第二行为任何阅读代码的人提供了更多的信息。
- en: Terminating a Command
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 终止命令
- en: The second use of the command separator is to terminate a command definitively
    so the coder can clearly delineate the existence or nonexistence of any trailing
    spaces. Is the following command setting the variable to null, a space, or multiple
    spaces?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 命令分隔符的第二个用途是明确地终止命令，以便编码人员能够清楚地区分是否有多余的空格。以下命令是在将变量设置为空值、一个空格还是多个空格？
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As written, it is impossible to tell (unless you make your editor display spaces
    as visible characters).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 按照现在的写法，不可能告诉（除非你让编辑器显示空格作为可见字符）。
- en: 'If you hadn’t read the earlier discussion, the following command might appear
    to be setting the variable to an ampersand:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有阅读前面的讨论，下面的命令可能会让你觉得它正在将变量设置为一个 & 符号：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: But this command unequivocally tells the reader that the variable is being set
    to null because the statement is terminated by the ampersand immediately after
    the equality operator.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个命令明确地告诉读者，变量被设置为空值，因为该语句在等号操作符后立即被 & 符号终止。
- en: 'Likewise, there are instances when the coder might want a variable to be a
    certain length (you’ll see a great application of this when formatting reports
    in [Chapter 22](chapter22.xhtml)). The following sets the variable to a 10-byte
    left- justified value containing the text pensive followed by three spaces:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，编码人员可能希望变量具有特定长度（你将在 [第22章](chapter22.xhtml) 中看到这个应用，特别是在格式化报告时）。下面的命令将变量设置为一个
    10 字节左对齐的值，包含文本 pensive 后跟三个空格：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Without the ampersand it would be quite difficult to determine how many spaces
    come after the text, if any. Technically, the ampersand isn’t separating two commands,
    but it definitely is terminating the one command.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 & 符号，确定文本后面跟了多少个空格（如果有的话）将非常困难。从技术上讲，& 符号并没有分隔两个命令，但它无疑终止了一个命令。
- en: Displaying Variable Information
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示变量信息
- en: 'The set command has one more interesting use. When used without an equal sign,
    it writes out the value of the variable, so if the myMood variable is already
    defined, you can enter this command in a bat file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: set 命令还有一个有趣的用法。当没有等号时，它会输出变量的值，因此，如果 myMood 变量已经定义，你可以在 bat 文件中输入此命令：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The resulting output written to the console might be as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 输出到控制台的结果可能如下所示：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If only the first part of the variable name is typed after the set command,
    all variables that start with that text will be displayed. Thus, the following
    command might output more than the value of the myMood variable:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 set 命令后仅输入变量名的第一部分，则所有以该文本开头的变量将会被显示。因此，以下命令可能会输出比 myMood 变量的值更多的内容：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Maybe, just maybe, it might output this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，真的也许，它会输出如下内容：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It’s unlikely that such a variable would’ve been set, but if it does exist and
    if these were the only two variables set on the machine starting with mym, that
    would’ve been the output. Note that the command finds all variables, regardless
    of case. Also notice the example of a variable value containing embedded spaces.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不太可能设置这样的变量，但如果它存在，并且如果这些是以 mym 开头的唯一两个变量，那么输出的结果将是这些变量的值。请注意，该命令会查找所有变量，忽略大小写。同时还要注意，变量值中包含了嵌入空格的示例。
- en: 'After seeing this technique work with complete variable names and then partial
    variable names, we can extend it to no variable name at all:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到此技巧在完整变量名和部分变量名中都能正常工作之后，我们可以将其扩展到完全没有变量名的情况：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This command without arguments generates a list of all active variables, those
    loaded when the bat file started, along with any additions and modifications to
    the list from the bat file itself.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个没有参数的命令会生成所有活动变量的列表，这些变量是在 bat 文件启动时加载的，以及来自 bat 文件本身的任何添加和修改。
- en: Persistently Setting a Variable
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久设置变量
- en: The set command is ephemeral in nature. It defines variables in a particular
    Batch stream until the variable is reassigned or the script terminates, at which
    point all variables set via the set command vanish into the ether. But at times
    we’ll want a variable to be accessible to other processes or other bat files on
    the computer—and for long after the original bat file has terminated, even after
    the computer is shut down and rebooted. What we want is an extreme set command,
    or a *set Xtreme* command. Aptly named, we have the setx command just for this
    purpose. (Truthfully, I have no idea where the name of the command originated,
    but it’s a story I tell at parties. In the Introduction you were warned about
    inviting my ilk to parties.)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: set 命令本质上是临时的。它在特定的批处理流中定义变量，直到变量被重新赋值或脚本终止，此时通过 set 命令设置的所有变量都会消失在记忆中。但有时我们希望一个变量能够供其他进程或计算机上的其他
    bat 文件访问——甚至在原始 bat 文件终止后很久，甚至在计算机关机和重启后也能访问。我们需要的是一种极限版的 set 命令，或者叫做 *set Xtreme*
    命令。名字起得很恰当，我们有了专为此目的设计的 setx 命令。（说实话，我不知道这个命令名字的来源，但这是我在聚会上讲的一个故事。在引言中你已经被提醒过不要邀请我这种人去参加派对。）
- en: 'It would be logical to assume that the syntax of the set and setx commands
    would be the same. What else would you expect other than a variable, an equal
    sign, and a value? It’s a bit puzzling why, but this isn’t the case. The setx
    command doesn’t call for an equal sign. Instead, the variable name and value are
    delimited (or separated) by a space or spaces like so:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 合乎逻辑的假设是 set 和 setx 命令的语法应该是相同的。你还能期待什么呢，除了变量、等号和一个值？这有点令人困惑，但事实并非如此。setx 命令不需要等号。相反，变量名和值之间由空格或多个空格分隔，如下所示：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'While discussing the set command, it became clear that variable names and values
    can indeed contain spaces. That obviously presents a predicament when a space
    is the delimiter in the command that sets the variable. But encasing the variable
    name and/or value in double quotes makes quick work of the issue. This command
    creates a variable with a two-word name and assigns it a two-word value:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论 set 命令时，我们明确看到变量名和值确实可以包含空格。这显然会在设置变量的命令中造成困扰，因为空格是命令的分隔符。但将变量名和/或值用双引号括起来，可以轻松解决这个问题。这个命令创建了一个有两个词的变量名，并将一个包含两个词的值赋给它：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To test this, first execute the previous statement in one bat file, and then
    execute the following command in another bat file or even at the command prompt:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个，首先在一个 bat 文件中执行上面的命令，然后在另一个 bat 文件中或直接在命令提示符下执行以下命令：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To see the effect, you must start the second bat file or open the command prompt
    *after* the setx command completes, because the interpreter loads a session with
    the computer’s existing variables when that session begins.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看效果，你必须在 setx 命令完成后启动第二个 bat 文件或打开命令提示符，因为当会话开始时，解释器会加载计算机现有的变量。
- en: All variables starting with my m (case-insensitive and inclusive of the embedded
    space) will be displayed, including the variable my mood. Unless this variable
    is reassigned by some other process, such as a future setx command, it’ll exist
    with this value for as long as the computer is operable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所有以我的 m 开头的变量（不区分大小写，包括嵌入的空格）都会被显示，包括变量 my mood。除非该变量被其他进程重新赋值，例如未来的 setx 命令，否则它会在计算机可操作时一直存在，直到被改变。
- en: The setx command is a great tool to aid in the development of compiled code.
    When a particular program being developed eventually runs in production, it’ll
    obviously be running on a different machine with its own environment variables.
    While animating that program, some IDEs have a good mechanism of simulating those
    environment variables and the setting of file connectors; others sadly do not.
    I’ve seen a few inelegant solutions to get around this shortcoming, but a great
    solution is to actually set all the needed values on your development machine
    before animating.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: setx 命令是一个很棒的工具，可以帮助开发已编译的代码。当开发中的某个程序最终在生产环境中运行时，显然它会在不同的机器上运行，并且有自己的环境变量。在启用该程序时，一些
    IDE 有很好的机制来模拟这些环境变量和文件连接设置；而其他 IDE 遗憾地没有。我见过一些不太优雅的解决方案来绕过这个缺陷，但一个好的解决方案是实际上在开发机器上设置所有需要的值，然后再启用程序。
- en: For each program developed in certain languages, I’ll create a bat file with
    a series of setx commands, one for each variable that needs to be set persistently.
    After executing the bat file, I can animate the program, and it’ll find all the
    environment variables that I expect it to find when it’ll later execute in its
    production environment. If I want to animate a different program, I can first
    run the bat file associated with it, quickly and easily, and if I feel a need
    to restore some variables to their prior state when I’m done, I can create a bat
    file for that as well. (Some IDEs store all variables from the environment just
    once when it opens. If your IDE behaves this way, ensure that you run the bat
    file before opening the IDE.)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用某些语言开发的每个程序，我会创建一个包含一系列 setx 命令的 bat 文件，每个变量都需要被持久化设置。执行 bat 文件后，我可以启用程序，它会在后续的生产环境中找到我预期的所有环境变量。如果我想启用另一个程序，我可以首先快速且轻松地运行与其关联的
    bat 文件。如果在操作完成后，我希望恢复某些变量的先前状态，我也可以为此创建一个 bat 文件。（某些集成开发环境（IDE）在打开时只会存储一次环境中的所有变量。如果你的
    IDE 是这种行为，确保在打开 IDE 之前运行 bat 文件。）
- en: Command Line Help
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令行帮助
- en: The last Batch command that I’ll introduce in this chapter is the command that
    documents the ones I’ve already discussed along with all of the many others to
    come. The help command accepts another command as its argument and returns a wealth
    of information about the command, starting with a brief description of its function
    and its general syntax.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍的最后一个批处理命令是记录我已经讨论过的命令以及将来会介绍的所有其他命令的命令。help 命令接受另一个命令作为参数，并返回关于该命令的大量信息，从简要的功能描述和一般语法开始。
- en: 'I’ll demonstrate with the set command simply because it’s been so central to
    this chapter. To invoke the help command, enter it into a command prompt (type
    **CMD** into the Windows Start menu and press ENTER). Then, to receive more details
    on the set command in particular, enter the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用 set 命令进行演示，因为它在本章中起着核心作用。要调用 help 命令，请在命令提示符下输入它（在 Windows 开始菜单中输入 **CMD**
    然后按回车）。接着，要获取更多关于 set 命令的详细信息，请输入以下内容：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The interpreter produces far too much information about the set command to
    display here in its entirety, but here are the first few lines:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器生成了关于 set 命令的过多信息，无法在此完全显示，但以下是前几行内容：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The command’s brief description is followed immediately by its general syntax,
    which obviously starts with the command name itself. All text inside of square
    brackets (also called hard brackets) is optional. The square brackets surrounding
    the text, [variable=[string]], indicate that the command can work with or without
    the text inside. Remember that the set command used without an argument returns
    a list of all active variables. The nested square brackets take it a step further,
    indicating that string is also optional—that is, variable can be set to nothing
    at all.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的简要描述后紧接着是其一般语法，显然语法的开头是命令名本身。所有方括号中的文本（也称为硬括号）是可选的。方括号包围的文本，[variable=[string]]，表示命令可以使用或不使用括号内的文本。请记住，未带参数的
    set 命令会返回所有活动变量的列表。嵌套的方括号进一步表明，string 也是可选的——也就是说，variable 可以设置为空值。
- en: The help for some commands gives examples of the command’s use along with additional
    notes and a list of available options. An *option* is a setting or tweak assigned
    to a command to turn on or off some additional functionality. They’re also called
    *switches*; in fact, the help command frustratingly uses the two terms interchangeably.
    For consistency, I’ll use only the more popular term *option*, but if someone
    mentions a Batch command switch, they’re referring to an option.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一些命令的帮助信息中提供了该命令的使用示例、附加说明和可用选项列表。*选项*是指为命令分配的设置或调整，用于开启或关闭某些附加功能。它们也叫做*开关*；事实上，帮助命令令人沮丧地将这两个术语交替使用。为了保持一致性，我将仅使用更常见的术语*选项*，但如果有人提到批处理命令开关，他们指的其实是选项。
- en: Options are usually defined with a forward slash followed by a single letter,
    but you’ll eventually encounter some that are more complex. Scroll down in the
    command prompt displaying the help for the set command to see two interesting
    and useful options. The /A option allows for the command to perform arithmetic
    ([Chapter 6](chapter6.xhtml)). The /P or prompt option is used to set a variable
    with user-entered data ([Chapter 15](chapter15.xhtml)).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 选项通常由一个斜杠和一个字母组成，但你最终会遇到一些更复杂的选项。在命令提示符下滚动显示set命令的帮助信息，可以看到两个有趣且有用的选项。/A选项允许命令执行算术运算（[第6章](chapter6.xhtml)）。/P或prompt选项用于通过用户输入的数据设置变量（[第15章](chapter15.xhtml)）。
- en: In [Chapter 1](chapter1.xhtml), what was possibly your first bat file contained
    a command to copy some files. I won’t cover the details of the xcopy command until
    [Chapter 7](chapter7.xhtml), but in the previous chapter it used three options
    (/F, /S, and /Y). What those do exactly isn’t important—yet. What’s important
    is that they turn some functionality on or off and that they’re documented with
    the help command.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](chapter1.xhtml)中，你可能遇到了第一个批处理文件，其中包含了一个用于复制文件的命令。我不会在[第7章](chapter7.xhtml)中详细讲解xcopy命令，但在前一章中，它使用了三个选项（/F、/S
    和 /Y）。这些选项具体的作用暂时不重要——但它们能够开启或关闭某些功能，并且这些选项在帮助命令中有文档说明。
- en: Some commands have many options, others just a few, and others still none. As
    I introduce commands, I’ll detail options that I find important and useful, but
    you’ll want to use the help command to find a more complete list. Some undocumented
    options, however, aren’t found with the help command, and to uncover those gems,
    go to *[https://<wbr>ss64<wbr>.com<wbr>/nt<wbr>/](https://ss64.com/nt/)* or some
    other resource.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一些命令有许多选项，其他命令则只有少数选项，甚至有些命令没有选项。在介绍命令时，我会详细讲解我认为重要且实用的选项，但你还需要使用帮助命令来查找更完整的列表。然而，一些未记录的选项无法通过帮助命令找到，要发现这些隐藏的宝藏，请访问
    *[https://<wbr>ss64<wbr>.com<wbr>/nt<wbr>/](https://ss64.com/nt/)* 或其他相关资源。
- en: I recommend using help when you first work with a particular command or as a
    reminder of available options. Try using it for any of the other commands mentioned
    in this chapter, even the help command itself. Yes, entering this at the command
    prompt
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在第一次使用某个特定命令时，或者作为可用选项的提示时使用帮助命令。尝试将其用于本章中提到的任何其他命令，甚至是帮助命令本身。是的，在命令提示符下输入此命令
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: displays documentation about the help command.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 显示有关帮助命令的文档。
- en: NOTE
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Following any Batch command with* /? *retrieves the same information. That
    is, entering* set /? *works the same way as* help set*.*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*在任何批处理命令后跟上* /? *将检索相同的信息。也就是说，输入* set /? *的效果与* help set*相同。*'
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Batch coding can be complex, and even something as seemingly simple as setting
    variables can have some nuances. In this chapter, I detailed the set command and
    its quirks as well as compared it to the setx command, which sets variables persistently.
    You also learned how to resolve variables and display them on the console. You
    can now add remarks to your bat files, use the command separator for multiple
    purposes, and, most important, quickly access documentation for any command.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理编程可能很复杂，即使是看似简单的设置变量也可能有一些细微差别。在本章中，我详细介绍了set命令及其特殊之处，并将其与setx命令进行了比较，后者设置的变量是持久化的。你还学习了如何解析变量并将其显示在控制台上。现在你可以向批处理文件中添加注释，使用命令分隔符来实现多种功能，最重要的是，能够快速访问任何命令的文档。
- en: 'In the next chapter, we’ll delve further into variables, specifically the scope
    of variables. We’ll examine how to define where and when variables possess certain
    values and how to enable the powerful feature of delayed expansion. As a preview,
    I’ll let you in on a secret: one variable’s value can be the name of a second
    variable with its own value.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将进一步探讨变量，特别是变量的作用域。我们将研究如何定义变量在何时何地拥有特定的值，以及如何启用强大的延迟扩展功能。作为预告，我将告诉你一个秘密：一个变量的值可以是另一个变量的名称，而这个变量本身有自己的值。
