- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 2 VARIABLES AND VALUES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we’re ready to start coding, we’ll explore variables, values, and the
    Batch set command, which assigns values to variables. Although these topics may
    seem trivial if you’ve coded in other languages, Batch has some unique quirks
    that are worth noting.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn how to display the value of a variable in the console to confirm
    that it has been set correctly. Additionally, I’ll introduce the *command separator*,
    which allows you to enter multiple commands on a single line. I’ll also show you
    how to create remarks and set variables that are saved on your computer and remain
    available even after the bat file is closed. Finally, you’ll learn how to access
    documentation for any Batch command at the command prompt, a useful skill for
    anyone working with bat files.
  prefs: []
  type: TYPE_NORMAL
- en: Setting and Resolving a Variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *variable* is a named field defining a place in memory that holds a value
    for later use. Many if not most languages allow, and usually require, variables
    to be defined as a particular data type, often some sort of text or number, before
    they can be assigned a value. Batch will have none of this; variables come into
    existence the first time they are “set” to a value, and that value can contain
    letters, numbers, and other characters. It’s then up to the coder to treat them
    as certain data types, or not. In [Chapters 5](chapter5.xhtml) and [6](chapter6.xhtml)
    I’ll return to ways to handle data types, but this chapter focuses on the seemingly
    simple task of assigning a value to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To consider one example of a variable, a coder might have a field that contains
    the state of their mood; whether it be for narcissistic or obsessive-compulsive
    reasons is of little importance. The variable is defined as or named myMood, and
    two possible values out of many are happy and sad. To set the variable to happy,
    you would use, obviously enough, the set command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After this executes, the myMood variable contains the value happy.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the topic is particularly bewildering, the following command wipes out the
    prior value and replaces it with a different one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: But how do you know for sure the value of this or any other variable? In Batch,
    the act of revealing the value of a variable is referred to as *resolving a variable*,
    and it’s usually done by surrounding the variable with percent signs. That is,
    %myMood% will resolve to nonplussed after the prior set command executes. Now,
    to actually see the results of resolving a variable, we’ll need a bit of a digression—a
    very important digression.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the Value of a Variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to quickly display the resolved value of a
    variable on your computer screen, but this technique will be useful for far more
    than just that. We’ll return to it in future chapters to demonstrate many other
    features of Batch, such as using it as a testing technique, which is instrumental
    for any Batch coder.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to the Console
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To display the contents of a variable on the screen, we need two additional
    commands: echo and pause. To demonstrate, let’s create a small bat file. Open
    a new folder on your computer, perhaps *C:\Batch\*, and in it, create a bat file
    called *Mood.bat* that contains the three lines shown in [Listing 2-1](#Lis2-1).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-1: The bat file, Mood.bat, displays a resolved variable.'
  prefs: []
  type: TYPE_NORMAL
- en: If you double-click or open *Mood.bat*, the bat file should execute, and a black
    window with white text should appear. This window is the DOS window, or *console*,
    which is how I’ll refer to it throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already discussed the set command in the first line of [Listing 2-1](#Lis2-1).
    In this context, the echo command writes out the remainder of the statement, excluding
    the space succeeding the actual text echo, to the console. The text My mood is
    and a trailing space is displayed, followed by the contents or the value of myMood—that
    is, the text happy—and the trailing period. The pause command keeps the console
    open. Without it, the window would open and close before you could read it.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-2](#Lis2-2) shows everything written to the console when this bat
    file executes, which is more than you may have expected.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-2: The console display of the Mood.bat bat file'
  prefs: []
  type: TYPE_NORMAL
- en: Each command is preceded with the current directory, *C:\Batch\*, followed by
    a greater-than sign (>) as a delimiter. (You’ll learn more about the current directory
    in [Chapter 8](chapter8.xhtml). For now, just consider it to be the path of the
    bat file being executed.)
  prefs: []
  type: TYPE_NORMAL
- en: The first line shows the execution of the set command, and the second shows
    the execution of the echo command. The third line is the result of executing that
    echo—that is, the output to the console described in [Listing 2-2](#Lis2-2). You
    can tell that it’s not a command because of the lack of the preceding text *C:\Batch>*.
    More important, %myMood% resolves to the text happy. The pause command also creates
    output, the text Press any key to continue ... , and as the message indicates,
    the execution is on hold until any key is depressed, at which point the bat file
    will end, and the console will close. Also, notice that the set command doesn’t
    produce any output since it’s just setting the value of a variable—there’s nothing
    to output.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning Up the Console
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One problem with what’s written to the console is that it’s a mess with commands
    interspersed with the desired output from the echo and pause commands. In [Chapter
    12](chapter12.xhtml), you’ll learn more about the various outputs and how to manage
    them; here we’ll just look at a quick means of cleaning this up. An echo command
    followed by the argument off is executed at the top of the *Mood.bat* bat file
    from [Listing 2-1](#Lis2-1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This echo off command suppresses not the actual output of the subsequent commands
    but rather the lines showing that each of those commands is being executed—that
    is, the line prefixed with the current directory. Also, prefixing the echo command
    with the at sign (@) suppresses its own execution from being written to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to [Listing 2-2](#Lis2-2), the console display is now much cleaner
    when the modified bat file is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can easily demonstrate how to initialize the myMood variable to the
    gloomy value and then reset it to the cheerful value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The result shows the same variable resolved to two different values at two
    different times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As our bat files become more complex, the echo command can send the output
    to someplace other than the console (see [Chapter 12](chapter12.xhtml) for more
    details). Prepending the command with > con explicitly redirects the data to the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This technique will be very useful in coming chapters to demonstrate what’s
    going on in a code snippet. For the sake of brevity, I won’t include the initial
    echo off and trailing pause commands in later examples, but I encourage you to
    add them to clean up and hold open the console.
  prefs: []
  type: TYPE_NORMAL
- en: The Idiosyncrasies of the set Command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting variables is usually a straightforward topic for most coding languages,
    but Batch isn’t like most coding languages. All Batch coders need to understand
    the following idiosyncrasies of the set command to avoid some level of future
    pain.
  prefs: []
  type: TYPE_NORMAL
- en: Case Sensitivity
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Closely inspect the following two commands. They look a little different but
    are functionally equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Batch commands and variables are case-insensitive. Here the set command is uppercase
    in one command and lowercase in the other, but the interpreter treats them both
    the same. You also could’ve used Set with no change in functionality. For good
    measure, sET and SeT also work in the same fashion, but you’d have to be a real
    contrarian to code in such a manner. Likewise, you can use the myMood, MYMOOD,
    and mymood variables interchangeably. The value, however, is stored just as it’s
    typed, so it’s case-sensitive. If the variable is set to WHIMSICAL, it will be
    resolved as WHIMSICAL; likewise, if it’s set to Whimsical, it will be resolved
    as Whimsical.
  prefs: []
  type: TYPE_NORMAL
- en: It’s all a matter of style and personal preference. I find that many bat files
    have far too much content capitalized. Capitalization is meant to make something
    stand out, but nothing stands out when everything is flashing neon. Most Batch
    coders capitalize all the letters in command names, but in this book I use only
    lowercase characters for all Batch commands. Also, I greatly prefer camel case
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Camel case *text is easily readable even though it contains multiple words not
    separated by spaces or other characters. The first letter of camel case text can
    be either uppercase (head up) or lowercase (head down). But to qualify as camel
    case, the first letter of all subsequent words must be capitalized with the rest
    of the word being lowercase. An example of the* head up *variant (also called*
    Pascal *or* upper camel case*) is MyMood. The corresponding* head down *variant
    (also called* dromedary *or* lower camel case*) would be myMood. Imagine a camel
    drinking water with his head down.*
  prefs: []
  type: TYPE_NORMAL
- en: Valid Variable Characters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most programming languages have strict rules concerning the list of permissible
    characters in variable names. Typically, numbers and the 26 letters of the alphabet,
    uppercase and lowercase, are allowed, with just a few special characters to boot.
    But Batch is unique in that nearly every character on the keyboard is a valid
    variable name character, although you should avoid using numbers as the first
    character in a variable name. (While you can set variables named with a leading
    digit, resolving them is problematic, and I’ll explain why in [Chapter 3](chapter3.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: A few characters are illegal because they have specific uses in Batch; for example,
    the tilde (~), ampersand (&), percent sign (%), and the less-than (<) and greater-than
    (>) signs are reserved characters, but several others would surprise any coder
    not already familiar with Batch. The three set commands in [Listing 2-3](#Lis2-3)
    successfully set these three variables with odd-looking single-character names
    to their respective descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-3: Setting variables with odd-looking single-character names'
  prefs: []
  type: TYPE_NORMAL
- en: The echo command in [Listing 2-3](#Lis2-3) writes the text semicolon at hashtag
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even the following monstrosity stores the text This actually works in the variable
    with a dollar sign, dot, and mismatched brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This variable name demonstrates what’s possible, but it’s hard to read and not
    recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Judicious use of such characters in variable names, however, can be a handy
    tool. For example, a group of related variables might all have a leading or trailing
    underscore as a visual cue to that relationship; number can be abbreviated as
    #, which is even more succinct than nbr and clearer than no. Much later in this
    book I’ll use this interesting feature to build arrays and hash tables with meaningful
    names containing brackets.'
  prefs: []
  type: TYPE_NORMAL
- en: Spaces Around the Assignment Operator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following classic rookie mistake bites most new Batch coders familiar with
    other languages. Inspect the set command shown in [Listing 2-4](#Lis2-4) carefully.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-4: Setting a variable with spaces around the equal sign'
  prefs: []
  type: TYPE_NORMAL
- en: If you expect the result of the echo command to be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'that would be an understandable mistake, but a mistake nonetheless. The result
    is actually this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The empty quotes mean that X isn’t set or is set to null, meaning nothing at
    all, not even a space.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In [Chapter 1](chapter1.xhtml), I mentioned that inside the command prompt,
    the syntax and output can differ in comparison to a bat file, and this is a prime
    example. The same code entered at the command prompt displays the attempted resolution
    of the unset variable very differently:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*I won’t be noting every discrepancy in the pages ahead, so if you see any
    future anomalies working at the command prompt, try putting the code in a bat
    file.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now, the set command in [Listing 2-4](#Lis2-4) isn’t all that complex, and it
    clearly is setting X to the text Hello, correct? Furthermore, it looks a lot like
    assignment commands in other more modern languages that would’ve performed the
    assignment as desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is our first *batveat* (Batch caveat; see the Introduction for details
    on batveats). The key to this issue is the space preceding the equal sign. The
    Batch interpreter is as literal as difficult teenagers, too smart and unforgiving
    for their own good. The variable name starts with the first nonspace character
    after the set command and ends with the character just before the assignment operator
    or equal sign—no matter what that character is. Therefore, the variable being
    set here is two characters in length, an X followed by a space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The %X% resolved to nothing, but %X % does have a value, and that value is Hello,
    correct? Not quite; this is our second batveat. The value of the variable is the
    string of characters after the equal sign extending to the end of the statement.
    Therefore, the assigned value is the space after the equal sign followed by the
    five characters in the word Hello.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the echo command from [Listing 2-4](#Lis2-4) like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Resolving the variable with the trailing space now reveals its value, which
    contains a leading space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This works, but typically a variable name with a trailing space is an accident
    waiting to happen. We even can embed spaces in the middle of a variable name,
    but there’s a big difference between being able to do something and it being a
    good idea. This in no way should be construed as an invitation to create cryptic
    code; it’s more of a warning about spaces around the equal sign in a set command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking one last pass of [Listing 2-4](#Lis2-4), let’s remove the spaces before
    and after the equal sign and go back to the original echo command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we get the desired result written to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: An even easier mistake to make is to add an unintentional space or two to the
    end of a line trailing the value. Because it won’t be obvious just looking at
    the text in the editor, it’s quite easy to miss. (In Notepad++, go to **View**
    ▶ **Show Symbol** ▶ **Show Space and Tab** to represent spaces as faint dots.
    Other good editors will have a similar feature.)
  prefs: []
  type: TYPE_NORMAL
- en: There are valid reasons to prepend or append a variable’s value with spaces,
    as you’ll learn later in this book, but be careful not to do it by accident. However,
    I’m hard-pressed to come up with an example of a variable’s name legitimately
    being appended with one or more spaces. Ensure that there’s no space between the
    variable name and the equal sign when using a basic set command.
  prefs: []
  type: TYPE_NORMAL
- en: The Command Separator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ampersand is a special character that functions as a command separator;
    it’s not treated like simple text. For instance, you can string the three lines
    of code from [Listing 2-3](#Lis2-3) together into a single line, with each command
    separated by the & character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is functionally equivalent to the three commands on three distinct lines.
  prefs: []
  type: TYPE_NORMAL
- en: On occasion this technique is useful for consolidating simple and similar commands,
    but using it excessively can make the code difficult to read. However, I’ve found
    two very handy uses for the command separator.
  prefs: []
  type: TYPE_NORMAL
- en: Appending Remarks to a Command
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One use of the command separator is to add text at the end of a line so that
    it’s treated as a comment. The rem command creates a *remark* out of the text
    that follows it. Typically, we place a rem command on the line (or lines) preceding
    some interesting code as a comment, but we also can attach it to a specific command
    with the command separator. For instance, the following two lines perform the
    same logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The second line, however, provides a little more information to anyone reading
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: Terminating a Command
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second use of the command separator is to terminate a command definitively
    so the coder can clearly delineate the existence or nonexistence of any trailing
    spaces. Is the following command setting the variable to null, a space, or multiple
    spaces?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As written, it is impossible to tell (unless you make your editor display spaces
    as visible characters).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you hadn’t read the earlier discussion, the following command might appear
    to be setting the variable to an ampersand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: But this command unequivocally tells the reader that the variable is being set
    to null because the statement is terminated by the ampersand immediately after
    the equality operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, there are instances when the coder might want a variable to be a
    certain length (you’ll see a great application of this when formatting reports
    in [Chapter 22](chapter22.xhtml)). The following sets the variable to a 10-byte
    left- justified value containing the text pensive followed by three spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Without the ampersand it would be quite difficult to determine how many spaces
    come after the text, if any. Technically, the ampersand isn’t separating two commands,
    but it definitely is terminating the one command.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying Variable Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The set command has one more interesting use. When used without an equal sign,
    it writes out the value of the variable, so if the myMood variable is already
    defined, you can enter this command in a bat file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output written to the console might be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If only the first part of the variable name is typed after the set command,
    all variables that start with that text will be displayed. Thus, the following
    command might output more than the value of the myMood variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Maybe, just maybe, it might output this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It’s unlikely that such a variable would’ve been set, but if it does exist and
    if these were the only two variables set on the machine starting with mym, that
    would’ve been the output. Note that the command finds all variables, regardless
    of case. Also notice the example of a variable value containing embedded spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'After seeing this technique work with complete variable names and then partial
    variable names, we can extend it to no variable name at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This command without arguments generates a list of all active variables, those
    loaded when the bat file started, along with any additions and modifications to
    the list from the bat file itself.
  prefs: []
  type: TYPE_NORMAL
- en: Persistently Setting a Variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The set command is ephemeral in nature. It defines variables in a particular
    Batch stream until the variable is reassigned or the script terminates, at which
    point all variables set via the set command vanish into the ether. But at times
    we’ll want a variable to be accessible to other processes or other bat files on
    the computer—and for long after the original bat file has terminated, even after
    the computer is shut down and rebooted. What we want is an extreme set command,
    or a *set Xtreme* command. Aptly named, we have the setx command just for this
    purpose. (Truthfully, I have no idea where the name of the command originated,
    but it’s a story I tell at parties. In the Introduction you were warned about
    inviting my ilk to parties.)
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be logical to assume that the syntax of the set and setx commands
    would be the same. What else would you expect other than a variable, an equal
    sign, and a value? It’s a bit puzzling why, but this isn’t the case. The setx
    command doesn’t call for an equal sign. Instead, the variable name and value are
    delimited (or separated) by a space or spaces like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'While discussing the set command, it became clear that variable names and values
    can indeed contain spaces. That obviously presents a predicament when a space
    is the delimiter in the command that sets the variable. But encasing the variable
    name and/or value in double quotes makes quick work of the issue. This command
    creates a variable with a two-word name and assigns it a two-word value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this, first execute the previous statement in one bat file, and then
    execute the following command in another bat file or even at the command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: To see the effect, you must start the second bat file or open the command prompt
    *after* the setx command completes, because the interpreter loads a session with
    the computer’s existing variables when that session begins.
  prefs: []
  type: TYPE_NORMAL
- en: All variables starting with my m (case-insensitive and inclusive of the embedded
    space) will be displayed, including the variable my mood. Unless this variable
    is reassigned by some other process, such as a future setx command, it’ll exist
    with this value for as long as the computer is operable.
  prefs: []
  type: TYPE_NORMAL
- en: The setx command is a great tool to aid in the development of compiled code.
    When a particular program being developed eventually runs in production, it’ll
    obviously be running on a different machine with its own environment variables.
    While animating that program, some IDEs have a good mechanism of simulating those
    environment variables and the setting of file connectors; others sadly do not.
    I’ve seen a few inelegant solutions to get around this shortcoming, but a great
    solution is to actually set all the needed values on your development machine
    before animating.
  prefs: []
  type: TYPE_NORMAL
- en: For each program developed in certain languages, I’ll create a bat file with
    a series of setx commands, one for each variable that needs to be set persistently.
    After executing the bat file, I can animate the program, and it’ll find all the
    environment variables that I expect it to find when it’ll later execute in its
    production environment. If I want to animate a different program, I can first
    run the bat file associated with it, quickly and easily, and if I feel a need
    to restore some variables to their prior state when I’m done, I can create a bat
    file for that as well. (Some IDEs store all variables from the environment just
    once when it opens. If your IDE behaves this way, ensure that you run the bat
    file before opening the IDE.)
  prefs: []
  type: TYPE_NORMAL
- en: Command Line Help
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last Batch command that I’ll introduce in this chapter is the command that
    documents the ones I’ve already discussed along with all of the many others to
    come. The help command accepts another command as its argument and returns a wealth
    of information about the command, starting with a brief description of its function
    and its general syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll demonstrate with the set command simply because it’s been so central to
    this chapter. To invoke the help command, enter it into a command prompt (type
    **CMD** into the Windows Start menu and press ENTER). Then, to receive more details
    on the set command in particular, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The interpreter produces far too much information about the set command to
    display here in its entirety, but here are the first few lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The command’s brief description is followed immediately by its general syntax,
    which obviously starts with the command name itself. All text inside of square
    brackets (also called hard brackets) is optional. The square brackets surrounding
    the text, [variable=[string]], indicate that the command can work with or without
    the text inside. Remember that the set command used without an argument returns
    a list of all active variables. The nested square brackets take it a step further,
    indicating that string is also optional—that is, variable can be set to nothing
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: The help for some commands gives examples of the command’s use along with additional
    notes and a list of available options. An *option* is a setting or tweak assigned
    to a command to turn on or off some additional functionality. They’re also called
    *switches*; in fact, the help command frustratingly uses the two terms interchangeably.
    For consistency, I’ll use only the more popular term *option*, but if someone
    mentions a Batch command switch, they’re referring to an option.
  prefs: []
  type: TYPE_NORMAL
- en: Options are usually defined with a forward slash followed by a single letter,
    but you’ll eventually encounter some that are more complex. Scroll down in the
    command prompt displaying the help for the set command to see two interesting
    and useful options. The /A option allows for the command to perform arithmetic
    ([Chapter 6](chapter6.xhtml)). The /P or prompt option is used to set a variable
    with user-entered data ([Chapter 15](chapter15.xhtml)).
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](chapter1.xhtml), what was possibly your first bat file contained
    a command to copy some files. I won’t cover the details of the xcopy command until
    [Chapter 7](chapter7.xhtml), but in the previous chapter it used three options
    (/F, /S, and /Y). What those do exactly isn’t important—yet. What’s important
    is that they turn some functionality on or off and that they’re documented with
    the help command.
  prefs: []
  type: TYPE_NORMAL
- en: Some commands have many options, others just a few, and others still none. As
    I introduce commands, I’ll detail options that I find important and useful, but
    you’ll want to use the help command to find a more complete list. Some undocumented
    options, however, aren’t found with the help command, and to uncover those gems,
    go to *[https://<wbr>ss64<wbr>.com<wbr>/nt<wbr>/](https://ss64.com/nt/)* or some
    other resource.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend using help when you first work with a particular command or as a
    reminder of available options. Try using it for any of the other commands mentioned
    in this chapter, even the help command itself. Yes, entering this at the command
    prompt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: displays documentation about the help command.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Following any Batch command with* /? *retrieves the same information. That
    is, entering* set /? *works the same way as* help set*.*'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Batch coding can be complex, and even something as seemingly simple as setting
    variables can have some nuances. In this chapter, I detailed the set command and
    its quirks as well as compared it to the setx command, which sets variables persistently.
    You also learned how to resolve variables and display them on the console. You
    can now add remarks to your bat files, use the command separator for multiple
    purposes, and, most important, quickly access documentation for any command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we’ll delve further into variables, specifically the scope
    of variables. We’ll examine how to define where and when variables possess certain
    values and how to enable the powerful feature of delayed expansion. As a preview,
    I’ll let you in on a secret: one variable’s value can be the name of a second
    variable with its own value.'
  prefs: []
  type: TYPE_NORMAL
