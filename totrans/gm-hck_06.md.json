["```\nunsigned char ubyteValue = 0xFF;\nchar byteValue = 0xFE;\nunsigned short uwordValue = 0x4142;\nshort wordValue = 0x4344;\nunsigned int udwordValue = 0xDEADBEEF;\nint dwordValue = 0xDEADBEEF;\nunsigned long long ulongLongValue = 0xEFCDAB8967452301;\nlong long longLongValue = 0xEFCDAB8967452301;\nfloat floatValue = 1337.7331;\n```", "```\n// char will be 1 byte per character\nchar* thinStringP = \"my_thin_terminated_value_pointer\";\nchar thinStringA[40] = \"my_thin_terminated_value_array\";\n\n// wchar_t will be 2 bytes per character\nwchar_t* wideStringP = L\"my_wide_terminated_value_pointer\";\nwchar_t wideStringA[40] = L\"my_wide_terminated_value_array\";\n```", "```\nstruct MyStruct {\n    unsigned char ubyteValue;\n    char byteValue;\n    unsigned short uwordValue;\n    short wordValue;\n    unsigned int udwordValue;\n    int dwordValue;\n    unsigned long long ulongLongValue;\n    long long longLongValue;\n    float floatValue;\n};\nMyStruct& m = 0;\nprintf(\"Offsets: %d,%d,%d,%d,%d,%d,%d,%d,%d\\n\",\n        &m->ubyteValue, &m->byteValue,\n        &m->uwordValue, &m->wordValue,\n        &m->udwordValue, &m->dwordValue,\n        &m->ulongLongValue, &m->longLongValue,\n        &m->floatValue);\n```", "```\nOffsets: 0,1,2,4,8,12,16,24,32\n```", "```\nOffsets: 0,1,2,4,8,12,16,28,36\n```", "```\nOriginal: Offsets: 0,1,2,4,8,12,16,24,32\nModified: Offsets: 0,1,2,4,8,12,16,28,36\n```", "```\nstruct {\n    int current;\n    int max;\n} vital;\nvital health;\n```", "```\nint currentHealth = readIntegerFromMemory(currentHealthAddress);\nint maxHealth =  readIntegerFromMemory(maxHealthAddress);\n```", "```\n   struct {\n       int current;\n       int max;\n   } _vital;\n➊ _vital health = readTypeFromMemory<_vital>(healthStructureAddress);\n```", "```\nunion {\n    BYTE byteValue;\n    struct {\n        WORD first;\n        WORD second;\n    } words;\n    DWORD value;\n} dwValue;\ndwValue.value = 0xDEADBEEF;\nprintf(\"Size %d\\nAddresses 0x%x,0x%x\\nValues 0x%x,0x%x\\n\",\n    sizeof(dwValue), &dwValue.value, &dwValue.words,\n    dwValue.words.first, dwValue.words.second);\n```", "```\nSize 4\nAddresses 0x2efda8,0x2efda8 \nValues 0xbeef,0xdead\n```", "```\nclass bar {\npublic:\n    bar() : bar1(0x898989), bar2(0x10203040) {}\n    void myfunction() { bar1++; }\n    int bar1, bar2;\n};\n\nbar _bar = bar();\nprintf(\"Size %d; Address 0x%x : _bar\\n\", sizeof(_bar), &_bar);\n```", "```\nSize 8; Address 0x2efd80 : _bar\n```", "```\nclass foo {\npublic:\nfoo() : myValue1(0xDEADBEEF), myValue2(0xBABABABA) {}\n    int myValue1;\n    static int myStaticValue;\n    virtual void bar() { printf(\"call foo::bar()\\n\"); }\n    virtual void baz() { printf(\"call foo::baz()\\n\"); }\n    virtual void barbaz() {}\n    int myValue2;\n};\n\nint foo::myStaticValue = 0x12121212;\n\nclass fooa : public foo {\npublic:\n    fooa() : foo() {}\n    virtual void bar() { printf(\"call fooa::bar()\\n\"); }\n    virtual void baz() { printf(\"call fooa::baz()\\n\"); }\n};\n\nclass foob : public foo {\npublic:\n    foob() : foo() {}\n    virtual void bar() { printf(\"call foob::bar()\\n\"); }\n    virtual void baz() { printf(\"call foob::baz()\\n\"); }\n};\n```", "```\nfoo* _testfoo = (foo*)new fooa();\n_testfoo->bar(); // calls fooa::bar()\n```", "```\ncall fooa::bar()\n```", "```\nfoo _foo = foo();\nfooa _fooa = fooa();\nfoob _foob = foob();\n```", "```\nMOV DWORD PTR DS:[EAX], VFADDR\n```", "```\nif (EBX > EAX)\n    ECX = EDX\nelse\n    ECX = 0\n```", "```\n    CMP EBX, EAX\n    JG label1\n    MOV ECX, 0\n    JMP label2\nlabel1:\n    MOV ECX, EDX\nlabel2:\n```", "```\n   MOV R1, 1          ; set R1 (register) to 1 (immediate)\n➊ MOV R1, [BADF00Dh] ; set R1 to value at [BADFOODh] (memory offset)\n   MOV R1, [R2+10h]   ; set R1 to value at [R2+10h] (memory offset)\n   MOV R1, [R2-20h]   ; set R1 to value at [R2+20h] (memory offset)\n```", "```\nMOV $1, %R1         ; set R1 (register) to 1 (immediate)\nMOV 0xBADF00D, %R1  ; set R1 to value at 0xBADFOOD (memory offset)\nMOV 0x10(%R2), %R1  ; set R1 to value at 0x10(%R2) (memory offset)\nMOV -0x20(%R2), %R1 ; set R1 to value at -0x20(%R2) (memory offset)\n```", "```\n PUSH EBP     ; put EBP (register) on the stack\nMOV EBP, ESP ; set EBP to value of ESP (register, top of stack)\nPUSH -1      ; put -1 (immediate) on the stack\nADD ESP, 4   ; negate the 'PUSH -1' to put ESP back where it was (a PUSH\n                 ; subtracts 4 from ESP, since it grows the stack)\nMOV ESP, EBP ; set ESP to the value of EBP (they will be the same anyway,\n                 ; since we have kept ESP in the same place)\nPOP EBP      ; set EBP to the value on top of the stack (it will be what\n                 ; EBP started with, put on the stack by PUSH EBP)\nXOR EAX, EAX ; exclusive-or EAX (register) with itself (same effect as\n                 ; 'MOV EAX, 0' but much faster)\nRETN         ; return from the function with a value of 0 (EAX typically\n                 ; holds the return value)\n```", "```\nunion {\n    DWORD EAX;\n    WORD AX;\n    struct {\n        BYTE L;\n        BYTE H;\n    } A;\n} EAX;\n```", "```\n? CALC (DS==SS && SS==GS && GS==ES)\n? 1\n? CALC DS-CS\n? 8\n? CALC FS-DS\n; returns nonzero (and changes between threads)\n```", "```\nPUSH EBP      ; saves the bottom of the lower stack frame\nMOV EBP, ESP  ; stores the bottom of the current stack frame, in EBP\n                  ; (also 4 bytes above the lower stack frame)\nSUB ESP, 0x0C ; subtracts 0x0C bytes from ESP, moving it up the stack\n                  ; to mark the top of the stack frame\n```", "```\nMOV ESP, EBP  ; demolishes the stack frame, bringing ESP to 4 bytes above\n                  ; its original value (0xFF00-4)\nPOP EBP       ; restores the bottom of the old stack frame that was saved by\n                  ; 'PUSH EBP'. Also adds 4 bytes to ESP, putting it back at\n                  ; its original value\n```", "```\nMOV EAX, [EBP+10h]   ; copy memory from EBP+0x10 to EAX\nMOV [DEADBEEFh], EAX ; MOV the copied memory to memory at 0xDEADBEEF\n```", "```\nIMUL [BADFOODh] ; 32-bit operand is at address 0xBADFOOD\n```", "```\nEDX:EAX = EAX * [BADFOODh]\n```", "```\nIMUL CX ; 16-bit operand is stored in CX\n```", "```\nDX:AX = AX * CX\n```", "```\nIMUL CL ; 8-bit operand is stored in CL\n```", "```\nAX = AL * CL\n```", "```\nMOV EDX, 0          ; there's no high-order DWORD in the input, so EDX is 0\nMOV EAX, inputValue ; 32-bit input value \nIDIV ECX            ; divide EDX:EAX by ECX\n```", "```\nEAX = EDX:EAX / ECX ; quotient\nEDX = EDX:EAX % ECX ; remainder\n```", "```\n--snip--\nif (EBX > EAX)\n    ECX = EDX;\nelse\n    ECX = 0;\n--snip--\n```", "```\n       --snip--\n       CMP EBX, EAX  ; if (EBX > EAX)\n       JG label1     ; jump to label1 if EBX > EAX\n       MOV ECX, 0    ; ECX = 0 (else block)\n       JMP label2    ; jump over the if block\n   label1: \n➊     MOV ECX, EDX ; ECX = EDX (if block)\n   label2:\n       --snip--\n```", "```\n0x1: CALL EAX\n0x2: ...\n```", "```\n0x1: PUSH 3h\n0x2: JMP EAX\n0x3: ...\n```", "```\nPUSH 300h   ; arg3\nPUSH 200h   ; arg2 \nPUSH 100h   ; arg1 \nCALL ECX    ; call\n```"]