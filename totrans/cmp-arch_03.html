<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="chn"><span epub:type="pagebreak" id="page_45"/><strong>2</strong></h2>&#13;
<h2 class="cht"><strong>DATA REPRESENTATION</strong></h2>&#13;
<div class="image1"><img src="../images/f0045-01.jpg" alt="Image" width="252" height="252"/></div>&#13;
<p class="chq">A computer is a device that represents things in the real world and performs manipulations on these representations. Entities that we might want to represent and make computations about include physical objects, numbers, words, sounds, and pictures. This chapter examines systems for representing each of these types of entities.</p>&#13;
<p class="indent">We’ll begin by exploring the history of how representations of objects, numbers, and text have evolved. We’ll then look at the modern symbol systems used to represent numbers—including decimal, binary, and hex—and use number representations to construct representations of further entities, such as text, audio, and video.</p>&#13;
<p class="indent">In this chapter, the modern representations are built from 0s and 1s, which are left as symbols themselves. In later chapters, we’ll consider how to instantiate these zero and one symbols in digital electronics and make use of them in computations.</p>&#13;
<h3 class="h3" id="lev49"><span epub:type="pagebreak" id="page_46"/>A Brief History of Data Representations</h3>&#13;
<p class="noindent">The concepts of representation and computation are closely linked. Humans often need to represent the state of part of their world, as an aid to their own memories or as proof to other humans that something has happened or is going to happen. Once you have a representation, you can also use it to perform computations, to simulate what would happen if certain actions were done, or to deduce conclusions from what is known.</p>&#13;
<p class="indent">For example, we often need to keep track of who owns what and who has debts to be paid. Static representations are useful for these purposes, and once these exist we can use them in computations to answer questions such as what would happen if we bought something, or how long it will take to repay a debt. Representation thus comes before computation, both conceptually and historically. Let’s trace how it evolved, from humanity’s first efforts to the symbol systems that we use today.</p>&#13;
<h4 class="h4" id="lev50"><em>Tally Sticks and Trading Tokens</em></h4>&#13;
<p class="noindent">The oldest-known data representation is the use of <em>tally sticks</em>, such as the Lebombo bone shown in <a href="ch01.xhtml">Chapter 1</a>. These are simple sticks with several marks, where each mark represents one object. For example, the number 13 is represented by 13 marks, usually made in a row, as in <a href="ch02.xhtml#ch02fig1">Figure 2-1</a>.</p>&#13;
<div class="image"><img id="ch02fig1" src="../images/f0046-01.jpg" alt="Image" width="369" height="107"/></div>&#13;
<p class="figcap"><em>Figure 2-1: A simple tally</em></p>&#13;
<p class="indent">By Sumerian times (4000 BCE), physical tokens were used to represent objects, as in <a href="ch02.xhtml#ch02fig2">Figure 2-2</a>. A small clay model of an animal, for example, represented the actual animal and could probably have been exchanged for it. This would have simplified trading, as you could travel from the city of Ur to the city of Uruk with 10 animal tokens and make a deal by swapping them for, say, 20 beer tokens, with the actual objects only being moved around later, after a successful deal. These tokens could also have been divided between groups of people or given as tax to the king.</p>&#13;
<div class="image"><img id="ch02fig2" src="../images/f0046-02.jpg" alt="Image" width="394" height="385"/></div>&#13;
<p class="figcap"><em>Figure 2-2: Sumerian trading tokens</em></p>&#13;
<p class="indent">Computing with tally sticks and tokens is, however, quite slow. To add <em>m</em> tallies or tokens to <em>n</em>, you have to go through the process of adding each of the <em>m</em> into the <em>n</em>, one at a time. If you’ve studied complexity theory, this means that addition is order O(<em>m</em>) in the size of the numbers being added.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_47"/>By 3000 BCE—still before the abacus—the Sumerians sped up their calculations by sealing many tokens in a clay “envelope” called a <em>bulla</em>, shown in <a href="ch02.xhtml#ch02fig3">Figure 2-3</a>. The bulla was sealed both physically, by joining its clay to encapsulate the contents, and informationally, by stamping a complex, unforgeable mark onto it. (This is the origin of ceremonial seals still used today on royal and governmental documents, such as the Great Seal of the USA. It’s also the origin of later digital signatures.) The seal guaranteed, probably in the name of the king or another powerful and trustworthy person, that a certain number of tokens were contained within it. This way, instead of counting out 12 animal tokens, you could hand over a bulla of 12 animals at a time. The bulla would function like a 12-token coin or banknote, but one that physically contained the 12 tokens inside.</p>&#13;
<div class="image"><img id="ch02fig3" src="../images/f0047-01.jpg" alt="Image" width="394" height="546"/></div>&#13;
<p class="figcap"><em>Figure 2-3: A bulla</em></p>&#13;
<p class="indent">A similar development to the bulla is found in tally sticks from this period, where tally marks started to be grouped together, as shown in <a href="ch02.xhtml#ch02fig4">Figure 2-4</a>. Counting out <em>n</em> scratches usually requires <em>n</em> operations, but if we replace, say, every fifth vertical stroke with a diagonal one going through the previous four, we can quickly count how many groups of five we have.</p>&#13;
<div class="image"><img id="ch02fig4" src="../images/f0047-02.jpg" alt="Image" width="372" height="110"/></div>&#13;
<p class="figcap"><em>Figure 2-4: A grouped tally</em></p>&#13;
<h4 class="h4" id="lev51"><em>Roman Numerals</em></h4>&#13;
<p class="noindent">In a closely related notation to grouped tallies, we can replace the fifth stroke with two shorter diagonal strokes to make a V, and the tenth with an X, as in <a href="ch02.xhtml#ch02fig5">Figure 2-5</a>, forming the beginnings of the <em>Roman numerals</em>.</p>&#13;
<div class="image"><img id="ch02fig5" src="../images/f0047-03.jpg" alt="Image" width="366" height="106"/></div>&#13;
<p class="figcap"><em>Figure 2-5: Early Roman numerals</em></p>&#13;
<p class="indent">Roman numerals developed further to closely represent the human perception of numbers. Humans appear to perceive the sizes of sets of 1, 2, 3, and 4 objects directly and immediately. Beyond this, our immediate perception is of <em>numerosity</em> or approximate size rather than exact number, based on sizes roughly around 5, 10, 20, 50, 100, and 1,000. Most number symbol alphabets reflect this, with Egyptian, <span epub:type="pagebreak" id="page_48"/>Chinese, and Arabic numbers having special symbols for 1, 2, 3, and 4 that feature the corresponding number of strokes, and more abstract symbols for 5 and above. The Roman numeral system also uses symbols to represent the “landmark” numbers, such as V = 5, X = 10, L = 50, C = 100, and M = 1,000, with smaller-valued symbols positioned before or after to indicate adjustments to the landmark, such as VI = 6 and IX = 9.</p>&#13;
<p class="indent">Roman numerals have the advantage of being a close model of how humans actually think about numbers, but if you try to do large-scale arithmetic such as adding and multiplying with them, you’ll quickly run into difficulty. This is a classic example of how the choice of representation can heavily affect your ability to do certain types of computation.</p>&#13;
<h4 class="h4" id="lev52"><em>Split Tallies</em></h4>&#13;
<p class="noindent">A <em>split tally</em> was a variation of the tally stick, in which the stick was marked up, then split into two pieces down its length, as in <a href="ch02.xhtml#ch02fig6">Figure 2-6</a>.</p>&#13;
<div class="image"><img id="ch02fig6" src="../images/f0048-01.jpg" alt="Image" width="371" height="103"/></div>&#13;
<p class="figcap"><em>Figure 2-6: A split tally</em></p>&#13;
<p class="indent">Both halves contain parts of the same notches, and both halves could be reunited to show they were genuine and fitted together. They were used to record loans, with the long and short halves (the <em>stock</em> and <em>foil</em>) given to the lender and borrower, the origin of our modern financial <em>long</em> and <em>short</em> positions in stocks. The British government continued to use split tally sticks until it burned its last wooden tallies to modernize its IT systems around 1836, the time of Babbage’s Analytical Engine.</p>&#13;
<h4 class="h4" id="lev53"><em>Arabic and Other Numerals</em></h4>&#13;
<p class="noindent">Other civilizations developed number representations using copies of symbols for large numbers, as shown in <a href="ch02.xhtml#ch02fig7">Figure 2-7</a>.</p>&#13;
<p class="indent">For example, the ancient Egyptians had symbols for 10, 100, 1,000, and 10,000. The number 23 would be shown using two copies of the 10 symbol (a heel) and three copies of the 1 symbol (a tally stroke). The number 354,000 would be shown using three copies of the 100,000 symbol (a tadpole), five copies of the 10,000 symbol (a finger), and four copies of the 1,000 symbol (a lotus flower).</p>&#13;
<p class="indent">Eastern Arabic numbers appeared in the Islamic Golden Age, based on an earlier Indian system from around 500 CE. This system introduced the base-exponent method that we use today, with fixed columns containing symbols for numbers of 1s, 10s, 100s, 1,000s, and so on. Importantly, this introduced the need for a concept and symbol of zero to fill in columns having no counts, which is missing from ancient Egyptian and similar systems. These symbols evolved into the Arabic numerals (1, 2, 3, and so on) used in the West today.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_49"/><img id="ch02fig7" src="../images/f0049-01.jpg" alt="Image" width="707" height="1017"/></div>&#13;
<p class="figcap"><em>Figure 2-7: Modern Arabic, Ancient Egyptian, Suzhou Chinese, and Eastern Arabic numerals</em></p>&#13;
<p class="indent">Suzhou Chinese numerals evolved from ancient Chinese symbols relating to the base 10 abacus seen previously in <a href="ch01.xhtml#ch01fig4">Figure 1-4</a>, and are occasionally still in use today. You can see the symbols for 1 to 4 are based on tally strokes, while those from 5 to 9 are similar symbols placed under a “bead” for 5. For a few significant digits, Suzhou uses a column system similar to Arabic numerals. For larger numbers, however, it uses a more advanced representation that shows the first few significant digits, followed by a separate symbol denoting what power of 10 they are multiplied by. In English we sometimes do this by writing <em>354 thousand</em> or <em>354k</em> rather than <em>354,000</em>.</p>&#13;
<p class="indent">This history of number <em>representation</em> belongs more properly to computer science than to mathematics. We can see that, historically, <em>typed</em> quantities such as “five cows plus three cows” were represented and computed with before more abstract mathematical number concepts such as “five plus three.” Mathematics takes numbers for granted and performs proofs about <span epub:type="pagebreak" id="page_50"/>their properties. By contrast, the business of representation, both of actual objects and of abstract number concepts derived from them, is computer science, as is the question of how to build algorithms and machines based on these representations.</p>&#13;
<h3 class="h3" id="lev54">Modern Number Systems</h3>&#13;
<p class="noindent">We’ve seen how our modern concept of numbers evolved from tallies into the symbolic, Arabic system used in everyday life today. The key innovation of the Arabic system is the use of columns to represent digits in a base. This (as we’ll see when we start computing) makes algorithmic arithmetic easier, and also reduces the size of representations. For example, you only need four symbols to represent the number 2,021, rather than 2,021 clay tokens.</p>&#13;
<p class="indent">Our everyday Arabic numbers are decimal, using base 10, but this isn’t necessarily the base for computers. This section generalizes the idea of bases and exponents and presents several related systems that are useful in computers.</p>&#13;
<h4 class="h4" id="lev55"><em>Bases and Exponents</em></h4>&#13;
<p class="noindent">We will make heavy use of exponentiation in representing numbers. <em>Exponentiation</em> is the repeated multiplication of a <em>base</em>, such as:</p>&#13;
<p class="equ">2<sup>3</sup> = 2 × 2 × 2</p>&#13;
<p class="noindent">Here, 2 is the base and 3 is the exponent. This may also be written as 2^3. In some computer languages, it appears as <code>2**3</code>, or is written via a power function, such as <code>pow(2,3)</code>. Exponentiation is sometimes called “raising to the power,” as in “two to the power of three.”</p>&#13;
<p class="indent">More generally, we write a base <em>b</em> to the power of an exponent <em>n</em> as</p>&#13;
<p class="equ"><em>b<sup>n</sup></em> = <em>b</em> × <em>b</em> × <em>b</em> × . . . × <em>b</em></p>&#13;
<p class="noindent">meaning there are <em>n</em> copies of <em>b</em>. Zero and negative exponentiation are defined as:</p>&#13;
<div class="imagec"><img src="../images/f0050-01.jpg" alt="Image" width="223" height="58"/></div>&#13;
<p class="indent">If we choose a base <em>b</em>, we may then define a <em>number system</em> as a mapping from a list of <em>numeral symbols</em> to a <em>number</em>. Symbols are marks on a piece of paper or entries in some other type of storage system; numbers are the actual mathematical objects being represented.</p>&#13;
<p class="indent">To write base <em>b</em> numbers, we need an alphabet containing <em>b</em> symbols. Strings of <em>N</em> of these symbols can have <em>b<sup>N</sup></em> different states, which are used to represent numbers from 0 to <em>b<sup>N</sup></em> – 1.</p>&#13;
<p class="indent">When we work with symbols in different bases, we will sometimes use a subscript to indicate what base the symbols are written in. For example, 123<sub>10</sub> means one hundred and twenty-three in base 10, while 1001<sub>2</sub> means one 8, no 4s, no 2s, and one 1 in base 2 (which equals 9<sub>10</sub>). In other cases, we’ll omit the subscript where the base is clear from the context.</p>&#13;
<h4 class="h4" id="lev56"><span epub:type="pagebreak" id="page_51"/><em>Base 10: Decimal</em></h4>&#13;
<p class="noindent">Everyday arithmetic uses base 10, in which, for example, the string of symbols 7, 4, 3, written as 743, is interpreted as representing the number seven hundred and forty-three. We can see this mathematically using exponents of 10:</p>&#13;
<p class="equ">743 = 7 × 10<sup>2</sup> + 4 × 10<sup>1</sup> + 3 × 10<sup>0</sup></p>&#13;
<p class="noindent">Using a point notation and negative exponents, we can represent fractional numbers. For example:</p>&#13;
<p class="equ">743.29 = 7 × 10<sup>2</sup> + 4 × 10<sup>1</sup> + 3 × 10<sup>0</sup> + 2 × 10<sup>–1</sup> + 9 × 10<sup>–2</sup></p>&#13;
<p class="noindent">For base 10 we have an alphabet of 10 symbols: 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9. Strings of <em>n</em> symbols from this alphabet can specify one of 10<sup><em>n</em></sup> numbers; for example, with <em>n</em> = 4, there are 10,000 numbers, 0 to 9,999 inclusive.</p>&#13;
<h4 class="h4" id="lev57"><em>Base 2: Binary</em></h4>&#13;
<p class="noindent">Base 2 is known as <em>binary</em> and is used in almost all modern computers. It has an alphabet of two symbols, usually written as 0 and 1, but sometimes as T and F for <em>true</em> and <em>false</em>. In electronic computers, the two symbols are represented using high and low voltages. <em>High</em> is usually the system’s positive voltage, such as 5 V or 3.3 V, while <em>low</em> is usually ground or 0 V. Binary is useful for electrical machines because real voltages are noisy, and attempts to include extra symbols such as <em>medium</em> have been doomed to failure. But <em>high</em> and <em>low</em> can more easily and cheaply be separated into two clear classes.</p>&#13;
<p class="indent">A single symbol in base 2 is called a <em>bit</em>, short for <em>bi</em>nary dig<em>it</em>. A string of <em>N</em> bits can represent one of 2<sup><em>N</em></sup> numbers, such as ranging from 0 to 2<sup><em>N</em></sup> – 1. The columns of the string represent powers of 2. For example:</p>&#13;
<div class="imagec"><img src="../images/f0051-01.jpg" alt="Image" width="910" height="118"/></div>&#13;
<p class="noindent">The powers of two that appear in this calculation (0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1,024, 2,048, and so on) should be instantly recognizable to anyone used to computing. They often appear as sizes of memory capacity and as sizes in bits or bytes of data structures used at the hardware level. If you plan to work at or near the hardware level, you’ll need to memorize these powers of two for everyday use.</p>&#13;
<p class="indent">To convert from binary to decimal, add up the powers of two for each column that has a 1 in it. To convert from decimal to binary, at each step, try to subtract the highest power of two from the decimal, and make a note of which powers of two have been subtracted. Write 1s in those columns and 0s in the others.</p>&#13;
<p class="indent">Some mathematical operations are faster or slower in different bases. In base 10, you can quickly multiply or divide by 10 by shifting the decimal (radix) point one place to the left or right. Where numbers are represented <span epub:type="pagebreak" id="page_52"/>in binary, you can use a similar trick to quickly multiply or divide by 2. This is known as <em>binary shift</em> and is implemented in hardware by most CPUs. In the C language, for example, a fast multiplication by 8 (2<sup>3</sup>) can be done by writing <code>y=x&gt;&gt;3;</code>.</p>&#13;
<p class="indent">Alternate notations used in some books and programming languages for binary include 1110<sub>2</sub>, 0b1110, and 1110b.</p>&#13;
<p class="notes"><strong><span class="nt">NOTE</span></strong></p>&#13;
<p class="noindent"><em>A famous computer science joke says, “There are 10 kinds of computer scientists: those who know nothing, and those who know binary.”</em></p>&#13;
<h4 class="h4" id="lev58"><em>Base 1,000</em></h4>&#13;
<p class="noindent">As a means of introducing other notations—hex and byte codes—let’s look at decimal notation in a different way, which we’ll call <em>compound notation</em>. It’s common to write large numbers by grouping them into chunks of three digits separated by commas, to make them easier to read. For example, the number 123,374,743,125 symbolizes the value one hundred and twenty-three <em>billion</em>, three hundred and seventy-four <em>million</em>, seven hundred and forty-three <em>thousand</em>, one hundred and twenty-five. (The “one hundred and twenty-five” at the end refers to the number of <em>ones</em>.)</p>&#13;
<p class="indent">Imagine for a moment that these chunks are individual symbols, from an alphabet containing 1,000 symbols from 0 to 999. Don’t think of 999 as three 9s, but as a single symbol. Under this view, we can consider the comma-separated string as a string of 4 symbols in base 1,000, rather than 12 symbols in base 10:</p>&#13;
<p class="equ">123,374,743,125 = 123 × 1,000<sup>3</sup> + 374 × 1,000<sup>2</sup> + 743 × 1,000<sup>1</sup> + 125 × 1,000<sup>0</sup></p>&#13;
<p class="noindent">This reflects our spoken language more accurately than thinking in base 10: we have names for powers of 1,000 (thousand, million, billion, trillion), but we don’t have names for 10,000 or 100,000 or 10,000,000. Scientific units also follow this base 1,000 convention: kilo, mega, giga, and so on.</p>&#13;
<p class="indent">What’s interesting about base 1,000 is the special relationship it has to base 10. Usually when we change bases, we expect the symbols to have a completely different appearance in the two bases. But when we switch between base 10 and base 1,000, the written symbols don’t change at all. We’ve simply gone from thinking of, say, 123 as three symbols in base 10 to thinking of it as a single symbol in base 1,000. This makes it very easy and convenient to convert between the bases, as we do in our heads whenever we see or hear large numbers in everyday life.</p>&#13;
<h4 class="h4" id="lev59"><em>Base 60: Sexagesimal</em></h4>&#13;
<p class="noindent">Let’s talk about <em>sexagesimal</em>, also known as <em>base 60</em>. This system is relevant to modern computing for two reasons: first, like base 1,000, it’s another example of the sort of compound notation we’ll explore later; and second, it’s still in heavy computational use today.</p>&#13;
<p class="indent">We believe that some prehistoric human groups counted in base 12. When we reach the time of the first cities (4000 BCE), the Sumerians <span epub:type="pagebreak" id="page_53"/>switched to base 60 for their scientific studies, which included astronomy and the invention of an algorithmic version of the Pythagorean theorem. This may have arisen through a fusion, collision, or compromise between people using bases 10 and 12, as 60 is readily divisible by both.</p>&#13;
<p class="indent">Rather than invent an alphabet of 60 distinct symbols, which would have required a large effort to learn, the Sumerians used a hybrid notation. They wrote the numbers from 0 to 59 (inclusive) in the existing base 10, but they treated these compound symbols as individual numerals in a base 60 system. For example, the symbols (using modern Arabic digits with compounds separated by colons) 11:23:13 would represent the following number:</p>&#13;
<p class="equ">11 × 60<sup>2</sup> + 23 × 60<sup>1</sup> + 13 × 10<sup>0</sup> = 39,889<sub>10</sub></p>&#13;
<p class="noindent">We still use a sexagesimal system today to represent time: the number above means 23 minutes and 13 seconds past 11, which is equal to 39,889 seconds into the day. Modern databases, data science systems, and date-time libraries therefore need to be carefully designed to handle conversions between sexagesimal, binary, and decimal.</p>&#13;
<h4 class="h4" id="lev60"><em>Base 16: Hexadecimal</em></h4>&#13;
<p class="noindent">Let’s talk about hex! Short for <em>hexadecimal</em> or <em>hex code</em>, <em>hex</em> is a base 16 system. Its symbols are a mix of the digits 0 through 9 and the letters a through <code>f</code> (for the decimal numbers 10 through 15), often prefixed by 0x to indicate they are hex.</p>&#13;
<p class="indent">You’ve probably seen hex numbers around in any computer programs in languages that allow direct access to and use of memory, including C and assembly. They also appear in higher-level languages as a way to differentiate copies of objects that otherwise have the same properties. For example, if you copy a <code>Cat</code> object (in an object-oriented language) with properties <code>numberOfLegs = 4</code> and <code>age = 6,</code> you’ll get a second <code>Cat</code> object with those same properties, but the two copies are distinct because they have different names and are stored in different locations in memory. Some debugging tools will show these memory locations to allow you to see which object is which. For example, when you ask Python to print an object, you’ll see a hex address, like this:</p>&#13;
<pre>&lt;&lt; <span class="codestrong1">print(cat)</span>&#13;
&lt;__main__.Cat at 0x7f475bbf6860&gt;</pre>&#13;
<p class="indent">Human interfaces to low-level computer architecture, such as memory locations, often use hex as an alternative, more human-readable way to display what is binary information. The address in the output above is really a long string of 0s and 1s in binary, but this would be hard for a human to recognize, for example, when comparing two addresses to see if they’re the same or different. Comparing hex numbers is much easier.</p>&#13;
<p class="indent">Hex is used for displaying binary, rather than some other system, because it has a similar relationship to binary as base 1,000 has to base 10. Because 16 is a power of 2, just as 1,000 is a power of 10, there’s a one-to-one <span epub:type="pagebreak" id="page_54"/>relationship between groups of columns in binary and columns in hex. This allows for fast, easy conversion between the two systems. Consider a binary number with its digits organized into groups of four: 0010,1111,0100,1101. We can view this as</p>&#13;
<p class="equ">0010<sub>2</sub> × 2<sup>12</sup> + 1111<sub>2</sub> × 2<sup>8</sup> + 0100<sub>2</sub> × 2<sup>4</sup> + 1101<sub>2</sub> × 2<sup>0</sup></p>&#13;
<p class="noindent">which is the same as:</p>&#13;
<p class="equ">2<sub>10</sub> × 16<sup>3</sup> + 15<sub>10</sub> × 16<sup>2</sup> + 4<sub>10</sub> × 16<sup>1</sup> + 13<sub>10</sub> × 16<sup>0</sup></p>&#13;
<p class="noindent">Each of these powers of 16 has a number from 0 to 15 inclusive, so if we use the letters a<sub>16</sub> to f<sub>16</sub> to denote 10<sub>10</sub> to 15<sub>10</sub>, then we can write the number in hex as 2f4d<sub>16</sub>. Every 4 bits in the binary number (a quantity sometimes called a <em>nybble</em>) corresponds to one hex digit: the 2 in hex corresponds exactly to the first 4 bits, 0010; the <code>f</code> to 1111; the 4 to 0100; and the d to 1101. This four-to-one correspondence makes it easy to convert back and forth between hex and binary—much easier than, say, converting between decimal and binary.</p>&#13;
<div class="sidebar">&#13;
<p class="stitle"><strong>HEX EDITORS</strong></p>&#13;
<p class="stext">Hex editors (for example, in Vim, %!xxd, as shown in the following image) display the contents of files or memory in byte notation, sometimes together with other translations such as ASCII characters. They allow you to edit the corresponding binary data directly. This is useful for editing binary data and executable (compiled program) files on disk, or poking (overwriting programs and data) in the computer’s memory, such as programs currently running. These editors have many interesting security-related applications. For example, you might use one to try to find and circumvent parts of a proprietary program that check for verified purchases, or to overwrite your number of lives in a computer game to get 255 instead of 3.</p>&#13;
<div class="imagec"><img src="../images/f0054-01.jpg" alt="Image" width="630" height="407"/></div>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_55"/>Hex is a convenient tool for humans to think about binary numbers in a computer, but it’s important to recognize that hex isn’t a tool the computers themselves use. We don’t build physical computers using hex as a base; we build them using binary. Then we chunk the computers’ binary numbers into fours and translate them into hex to make them more human-friendly. After all, 16 is just a bit more than 10, and so is the kind of number that humans can get used to thinking in, rather than binary.</p>&#13;
<p class="indent">Alternate notations used in some books and programming languages for hex include 2F4D<sub>16</sub>, 0x2f4d, 2F4Dh, &amp;2F4D, and $2F4D.</p>&#13;
<h4 class="h4" id="lev61"><em>Base 256: Bytes</em></h4>&#13;
<p class="noindent">Using the base 1,000 trick again, it’s common to see hex code grouped into <em>pairs</em> of hex digits, such as 2D 4F 13 A7. Here, each pair can be viewed as a single symbol from an alphabet of 256 symbols, with each symbol representing 8 bits, known as a <em>byte</em>. Bytes were the main unit of computation in the 8-bit era. The nybble is so-called because it’s half a byte. Remember that a nybble is one hex digit; a byte is a pair of hex digits.</p>&#13;
<h4 class="h4" id="lev62"><em>How to Convert Between Bases</em></h4>&#13;
<p class="noindent">To convert from any base <em>b</em> representation to decimal, sum the decimal values of each of the base <em>b</em> columns:</p>&#13;
<p class="equ"><em>x</em><sub><em>n</em></sub><em>b</em><sup><em>n</em></sup> + <em>x</em><sub><em>n</em> – 1</sub><em>b</em><sup><em>n</em> – 1</sup> + . . . + <em>x</em><sub>0</sub><em>b</em><sup>0</sup></p>&#13;
<p class="noindent">For example, here’s how to convert a number from base 19 to decimal:</p>&#13;
<div class="imagec"><img src="../images/f0055-01.jpg" alt="Image" width="875" height="118"/></div>&#13;
<p class="noindent">To convert from decimal to base <em>b</em>, use repeated integer division by <em>b</em> with remainders. <a href="ch02.xhtml#ch02tab1">Table 2-1</a> shows the steps of converting 186<sub>10</sub> to binary.</p>&#13;
<p class="tabcap" id="ch02tab1"><strong>Table 2-1:</strong> Converting 186 to Base 2</p>&#13;
<table class="allc">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Step</strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Result</strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Remainder</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">186/2</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">93</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">93/2</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">46</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">46/2</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">23</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">23/2</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">11</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">11/2</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">5</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">5/2</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">2</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">2/2</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">1</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">1/2</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">0</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Here, the binary form of 186<sub>10</sub> is obtained by reading up the remainder column: 10111010<sub>2</sub>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_56"/>Most programming languages provide functions that automatically carry out common conversions, with names like <code>bin2hex</code> and <code>hex2dec</code>.</p>&#13;
<h3 class="h3" id="lev63">Representing Data</h3>&#13;
<p class="noindent">Once you have a basic representation for whole numbers, such as any of the base systems we’ve discussed, you can use it as a first building block to construct representations of other things: more complicated types of numbers, text, multimedia, and any general hierarchical data structure. Here we’ll see such representations, often using systems we’ve already defined as components of other higher-level systems. This can be as simple as using a pair of whole numbers to represent a fractional number or as complex as using billions of floating-point numbers grouped into spatiotemporal hierarchies to represent a multimedia stream of video, multilingual audio, and text subtitles, as found in your movie player.</p>&#13;
<h4 class="h4" id="lev64"><em>Natural Numbers</em></h4>&#13;
<p class="noindent">The <em>natural numbers</em> (traditionally denoted by the set symbol N) are the numbers 0, 1, 2, 3, 4, and so on. They’re often used to represent numbers of <em>physical</em> things in the world, such as rocks or cows.</p>&#13;
<p class="indent">Natural numbers can be represented in many ways, including tallies and Roman numerals. In computer architecture, the most obvious way is to use one of the base-exponent systems we’ve discussed. Some computers have used the decimal base (see the “Decimal Computers” box), while most modern machines use binary. For example, using light bulbs that can be either on or off, we can represent the binary columns of the number 74 (one 64, one 8, one 2), as in <a href="ch02.xhtml#ch02fig8">Figure 2-8</a>.</p>&#13;
<div class="image"><img id="ch02fig8" src="../images/f0056-01.jpg" alt="Image" width="449" height="61"/></div>&#13;
<p class="figcap"><em>Figure 2-8: A representation of the number 74 in binary</em></p>&#13;
<p class="indent">There’s some subtlety to this, which will become important in more complex representations. First, you need to choose a convention for how to read the bulbs. In this case, we’ve chosen to put the highest power on the left, as with human-readable decimal numbers. We could equally have chosen the other way around, however, with the highest power on the right. Second, we’ve assumed in our example that eight bulbs are available and are being used. This means we can only represent the numbers 0 through 255. If we want to represent larger numbers, or even communicate the fact that we’ve run out of bulbs to represent a larger number, we’ll need a new plan.</p>&#13;
<div class="sidebar">&#13;
<p class="stitle"><span epub:type="pagebreak" id="page_57"/><strong>DECIMAL COMPUTERS</strong></p>&#13;
<p class="stext">Decimal computers have a long history, spanning the mechanical and electronic ages. Here are some details of how they worked.</p>&#13;
<p class="stextd"><strong>Babbage’s Analytical Engine</strong></p>&#13;
<p class="stext">Like Babbage’s Difference Engine, his Analytical Engine uses a decimal representation, with gear wheels containing the digits 0 through 9. A gear’s orientation represents a particular decimal digit, <em>d</em>, when that digit is oriented toward a fixed marker, as shown in the following figure. As in Pascal’s calculator (and unlike da Vinci’s), the gear never stops at continuous angles in between digits; it has only 10 discrete states.</p>&#13;
<div class="imagec"><img src="../images/f0057-01.jpg" alt="Image" width="552" height="335"/></div>&#13;
<p class="stext">The gear is hollow, and there’s a shaft inside it. The gear and this shaft may connect via two tappets, one attached to each of their circumferences. These tappets are arranged so that if the shaft is rotated by a full circle, the tappets will connect for part of the circle, with the effect of rotating the gear by the value of its digit rather than the full circle. To read the represented number, you rotate the shaft by a full circle. For the first part of this rotation, the tappets aren’t in contact and the gear doesn’t move. For the second part of this rotation, the tappets come into contact and the rotating shaft makes the gear rotate along with it for <em>n</em>-tenths of a rotation, where <em>n</em> is the number represented. This rotation of the gear is what gives you access to the number. For example, if you first connect the gear to a second gear, it will have the effect of advancing that second gear’s digit by <em>n</em>.</p>&#13;
<p class="stext">Importantly, the data is lost from the first gear when it’s read, as the tappet always moves the gear into its zero position during the second part of the rotation. The act of reading the data is thus a <em>move</em> rather than a <em>copy</em>.</p>&#13;
<p class="stext">Many gears can be stacked vertically to represent digits of larger decimal numbers. Likewise, many of these vertical stacks are arranged horizontally in the Analytical Engine to represent many numbers together.</p>&#13;
<p class="stextd"><span epub:type="pagebreak" id="page_58"/><strong>Electronic Decimal Machines</strong></p>&#13;
<p class="stext">Less well known in history are decimal machines of the early electronic age. The first commercial computer, UNIVAC (1951), discussed in the previous chapter, was one of them. Its main console (see the following figure) is characterized by many groups of 10 lights, used for displaying various decimals.</p>&#13;
<div class="imagec"><img src="../images/f0058-01.jpg" alt="Image" width="552" height="414"/></div>&#13;
<p class="stext">The IBM 650 in the following figure, dating from 1953, was notable for its use of a “bi-quinary” representation. Exactly as in the abacus, this involved a mixture of units and fives making up decimal columns.</p>&#13;
<div class="imagec"><img src="../images/f0058-02.jpg" alt="Image" width="551" height="649"/></div>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_59"/>Binary isn’t the only way for digital systems, such as light bulbs, to represent natural numbers. Sometimes a one-of-<em>N</em> representation is more useful, as in <a href="ch02.xhtml#ch02fig9">Figure 2-9</a>.</p>&#13;
<div class="image"><img id="ch02fig9" src="../images/f0059-01.jpg" alt="Image" width="453" height="63"/></div>&#13;
<p class="figcap"><em>Figure 2-9: A representation of the number 5 in a one-of</em>-N <em>system (the leftmost bulb represents 0)</em></p>&#13;
<p class="indent">Here, we assume that <em>N</em> bulbs are available and being used, and that exactly one of them will be on at any time. This can be wasteful, because we don’t use most of the possible states of the set of bulbs. But it can also be useful: for example, if we want to actually shine a light on some object in the real world, such as the fifth car in a row, we now have a single physical light bulb dedicated to that purpose. This will be very useful in computer architecture, as we very often want to switch on and off one of <em>N</em> physical circuits in a similar way. As with binary, we need to agree on a left-to-right or opposite convention, and there’s no way to indicate that we’ve run out of bulbs if a number is too large.</p>&#13;
<h4 class="h4" id="lev65"><em>Integers</em></h4>&#13;
<p class="noindent">The <em>integers</em> (set symbol Z) are the numbers . . . , –3, 2, –1, 0, 1, 2, 3, and so on. They can be defined as pairing natural numbers with positive or negative signs (apart from zero, where +0 = –0). <a href="ch02.xhtml#ch02tab2">Table 2-2</a> shows three different options for encoding them in binary.</p>&#13;
<p class="tabcap" id="ch02tab2"><strong>Table 2-2:</strong> Three Possible Binary Encodings for Integers</p>&#13;
<table class="allc">&#13;
<colgroup>&#13;
<col style="width:15%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Integer</strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Signed</strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>One’s complement</strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Two’s complement</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext"> 3</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">011</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">011</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">011</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext"> 2</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">010</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">010</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">010</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext"> 1</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">001</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">001</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">001</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext"> 0</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">000 and 100</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">000 and 111</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">000</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">–1</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">101</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">110</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">111</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">–2</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">110</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">101</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">110</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">–3</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">111</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">100</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">101</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">–4</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">n/a</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">n/a</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">100</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">A naive way to represent integers is to use binary codes for the natural numbers corresponding to their absolute values, together with an extra bit for their sign, as in the signed column of <a href="ch02.xhtml#ch02tab2">Table 2-2</a> (the leftmost bit indicates the sign). It’s difficult to build machinery to correctly process these representations, however, as the sign has to be handled separately and used to select what should be done with the rest of the number. Having two different representations of the number 0 may also be a problem, requiring extra machinery to sort out.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_60"/>Consider for a moment the alternative one’s complement representation of the same integers given in the table. (Few people actually use this, but it will help you understand the next one.) In this representation, the codes for the positive integers are the same as for natural numbers, but the codes for negatives are obtained by inverting all of the bits for their corresponding naturals. For example, to get the code for –2, we start with the code for +2, which is 010, and invert all the bits to get 101.</p>&#13;
<p class="indent">Now consider the two’s complement representation of integers in the table. This is formed by taking the one’s complement codes and adding 1 to them for negative numbers only. For example, –2 becomes 110, which is 101 + 1. This may seem like a random thing to do, but as you’ll see later, the two’s complement approach turns out to be very useful. It simplifies the required arithmetic machinery, which is why today’s computers typically use it.</p>&#13;
<h4 class="h4" id="lev66"><em>Rationals</em></h4>&#13;
<p class="noindent">The <em>rationals</em> (set symbol ℚ) are defined as, and may be represented by, pairs of integers <em>a</em>/<em>b</em>, with <em>b</em> ≠ 0. Examples include 1/2, –3/4, 50/2, –150/2, and 0/2. Many rationals are equivalent to one another, such as 4/2 and 2/1. Detecting and simplifying equivalences requires dedicated computational work, and without this work rationals tend to expand to silly scales such as the representation 1,000,000,000/2,000,000,000 representing the number 1/2.</p>&#13;
<p class="indent">Representing rationals is our first example of combining multiple existing representations: we need to use a pair of integers. For example, consider <a href="ch02.xhtml#ch02fig8">Figure 2-8</a>, which we previously interpreted as a single natural number; this figure could instead be viewed as representing the rational 4/10 = 2/5 by assuming that the first and second groups of four bulbs represent 4 and 10.</p>&#13;
<p class="indent">There’s some subtlety in this: we need to agree that the first four of the eight bulbs are to represent the first integer, and the second four the second integer, plus we need to agree on conventions for the integers themselves (how to convey positive versus negative values), as discussed earlier. We will end up with multiple representations for many rationals, such as 4/10 and 2/5, which may initially confuse us if we want to ask whether two rationals are equal.</p>&#13;
<h4 class="h4" id="lev67"><em>Fixed Point</em></h4>&#13;
<p class="noindent"><em>Fixed-point numbers</em>, such as 4.56, 136.78, and –14.23, are numbers with a limited number of digits before and after the point. In these examples there are always two digits after the point. Formally, fixed-point numbers are a subset of the rationals, as they can always be written as an integer divided by some power of 10. They can be easily represented in computers as pairs of integers, corresponding to the two parts of the number before and after the decimal point, provided we agree on a convention for their ordering and size, as well as a convention for the integers themselves.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_61"/>For example, the bulbs in <a href="ch02.xhtml#ch02fig8">Figure 2-8</a> could now represent the fixed-point binary number <img src="../images/f0061-01.jpg" alt="Image" width="150" height="30"/> if we agree that the point is fixed after the fourth bulb. Note that these are exactly the same bulbs that we previously used to represent the rational 4/10 and the integer 74; to interpret data as a representation, we need to agree on which representation system is being used.</p>&#13;
<h4 class="h4" id="lev68"><em>Floating Point</em></h4>&#13;
<p class="noindent"><em>Floating-point numbers</em>, such as 4.56 × 10<sup>34</sup> and –1.23 × 10<sup>–2</sup>, are a computational version of the Suzhou place notation system seen previously in <a href="ch02.xhtml#ch02fig7">Figure 2-7</a>, and are composed of a fixed-point mantissa (here, 4.56) and an integer exponent (here, 34). They are easily represented in computers by pairing together an integer representation and a fixed-point representation.</p>&#13;
<p class="indent">To do this in practice, you need to choose specific representations for the fixed-point and integer parts, with specific bit lengths and a specific ordering for how to pack them together into a pair. It’s also useful to reserve a few bit strings for special codes, such as plus and minus infinity (which can be used to code results for 1/0 and –1/0) and “not a number” (<em>NaN</em>, used to code exceptions such as when trying to compute 0/0.0). <em>IEEE 754</em> is a commonly used standard for making these choices. It includes a set of bit orderings to best make use of 8, 16, 32, 64, 128, or 256 bits as floating-point representations. For example, IEEE 754’s 64-bit standard specifies that the first 53 bits should be used as the fixed-point mantissa in a signed encoding, with the first bit holding the sign; the remaining 11 bits should serve as a two’s complement integer exponent. Some bit patterns are reserved for infinities and NaNs.</p>&#13;
<div class="sidebar">&#13;
<p class="stitle"><strong>COMPUTABLE REALS</strong></p>&#13;
<p class="stext">Beyond floating points, computer science has its own concept of <em>computable real numbers</em>, sometimes written as 𝕋, which are different from—and better than—the <em>real numbers</em> used in mathematics, denoted with ℝ. Computable reals are all the numbers that can be defined by programs. In contrast, the much larger set of mathematicians’ real numbers are useless as they can’t be individually defined or used in computation.</p>&#13;
<p class="stext">Imagine a physical turtle robot controlled by a language like Scratch, moving left and right along a number line. The computable reals are all the locations on the number line that you can write a program for the turtle to stop at. Specifically, they’re all the numbers whose <em>n</em>th digit can be specified by some finitelength computer program.</p>&#13;
<p class="stext"><span epub:type="pagebreak" id="page_62"/>For example, we can write a function <code>pi(n)</code> that takes an integer n as input and returns the <em>n</em>th digit of <em>π</em>. Likewise, we can add two computable reals, <code>a(n)</code> + <code>b(n)</code>, by forming a new program from the programs <code>a(n)</code> and <code>b(n)</code>. The new program will take <code>n</code> as an input and call <code>a()</code> and <code>b()</code> one or more times to generate the <em>n</em>th digit of the output.</p>&#13;
<p class="stext">Computable reals have many fascinating and almost paradoxical properties, which have deep implications for both computer and human arithmetic. For example, it’s generally impossible (uncomputable) to know whether two computable reals are equal or different! The programs formed from performing just a few basic arithmetic operations on computable reals can quickly get quite large and unwieldy. It would be nice if we could optimize them by replacing them with shorter (or shortest) programs that give the same outputs, but it’s impossible to do this. There is a “countable” number of computable reals, which is the same “size” of infinity as the integers. This is different from the mathematicians’ reals, which have a larger “size” that’s “uncountable.”</p>&#13;
<p class="stext">Alan Turing defined the computable reals in his great paper “On Computable Numbers,” hence the letter 𝕋. They are his true genius contribution to computer science, rather than “inventing the computer” (the title of this paper is a clue that it’s about computable numbers, rather than about computers). Turing’s theory is still underappreciated. If it were more widely developed and used, we might one day get rid of the errors caused by floating-point approximations and be able to make perfectly accurate computations.</p>&#13;
</div>&#13;
<h4 class="h4" id="lev69"><em>Arrays</em></h4>&#13;
<p class="noindent">A <em>one-dimensional array</em> is a sequence of <em>R</em> values:</p>&#13;
<p class="equ">{<em>a</em><sub><em>r</em></sub>}<sub><em>r</em>=0:<em>R</em>–1</sub></p>&#13;
<p class="noindent">A <em>two-dimensional array</em> is a collection of <em>R</em> × <em>C</em> values (standing for numbers of rows and columns), where:</p>&#13;
<p class="equ">{<em>a</em><sub><em>r,c</em></sub>}<sub><em>r</em>=0:<em>R</em>–1,<em>c</em>=0:<em>C</em>–1</sub></p>&#13;
<p class="noindent">A <em>D-dimensional array</em> is a collection of values with <em>D</em> indices, such as the 3D <em>R</em> × <em>C</em> × <em>D</em> array with the following elements:</p>&#13;
<p class="equ">{<em>t<sub>r,c,d</sub></em>}<sub><em>r</em>=0:<em>R</em>–1,<em>c</em>=0:<em>C</em>–1,<em>d</em>=0:<em>D</em>–1</sub></p>&#13;
<p class="noindent">The values in arrays may be numbers (of any of the types of numbers we’ve discussed) or other types of data.</p>&#13;
<p class="indent">Often numerical arrays are used to represent vectors, matrices, and tensors. These are mathematical concepts that <em>extend</em> the data structure with specific, defined, mathematical operations. For example, a <em>vector</em> is a 1D array with specific rules for addition, multiplication by a scalar, and computing dot products and norms. A <em>matrix</em> is a 2D array with specific rules such as for multiplication and inversion. A <em>tensor</em> is an <em>N</em>-dimensional array with specific rules for covariant and contravariant coordinate transforms, in addition to multiplication and inversion. Vectors and matrices are special cases <span epub:type="pagebreak" id="page_63"/>of tensors. (Many computer scientists use the term <em>tensor</em> incorrectly to refer only to the <em>N</em>-dimensional data structure, forgetting the other mathematical requirements of true tensors.)</p>&#13;
<p class="indent">A basic data representation for all types of arrays is to “pack” them into a series of individual numbers in contiguous areas of computer memory. For example, <a href="ch02.xhtml#ch02fig8">Figure 2-8</a> might represent the 1D array of integers [1,0,2,2] if we agree on a convention that each integer is represented by two bulbs. Similarly, it might represent this 2D array of integers:</p>&#13;
<div class="imagec"><img src="../images/f0063-01.jpg" alt="Image" width="106" height="71"/></div>&#13;
<p class="noindent">In this case we’re considering each of the 2D array’s rows as a 1D array, [1,0] and [2,2]. We encode each 1D array using two bulbs per integer and store the series of encodings for the rows in order. By extension, for a general <em>N</em>-dimension array, we may do the same: split it into a series of (<em>N</em> – 1)-dimension arrays, encode each of them, and store the series of encodings in order.</p>&#13;
<p class="indent">Optimizing data representation and computation architectures for vectors, matrices, and tensors has become a major driver of the tech industry. GPUs were first built to perform fast 3D vector-matrix operations for realtime 3D games, and have more recently been generalized for fast tensor computations, which have found important applications in neural network acceleration. Google’s tensor processing units (TPUs) are designed specifically for this task.</p>&#13;
<h4 class="h4" id="lev70"><em>Text</em></h4>&#13;
<p class="noindent">Let’s talk about text. Once you have a finite, discrete alphabet of symbols, such as the characters we use to write human-readable text, you can assign a natural number to represent each one. You can then use a bunch of natural numbers in an array to represent <em>strings</em> of text. This idea has evolved from the long-standard-but-now-outdated ASCII to modern Unicode.</p>&#13;
<div class="sidebar">&#13;
<p class="stitle"><strong>A HISTORY OF TEXT</strong></p>&#13;
<p class="stext">Numbers aren’t very useful by themselves: we need to know <em>what</em> is being counted. Sumerian trading tokens were “typed”—three cow tokens to represent three cows. But when we moved from tokens to more abstract numerals, we lost the information about what the numbers were supposed to represent. The numbers needed to be accompanied by extra symbols describing the type, as in “3 cows.” Writing thus emerged from the same trading tokens as numbers, but it forked to become pictograms and then text.</p>&#13;
<p class="stext"><span epub:type="pagebreak" id="page_64"/>The first writing appeared in Sumeria around 4000 BCE. It used pictures of objects (pictograms) to represent them. Pictograms appeared in many cultures, then gradually transformed into phonetic symbols. The phonetic and semantic uses may coexist for a while—as in modern Chinese—but the phonetic use usually becomes dominant. Text symbols also evolved over time to become simplified and easier to write, losing the original pictorial similarities to their objects. Where writing was carved on stone, the symbols evolved to be made from straight lines that are easier to carve. The most common symbols evolved fastest into quick-to-write shapes. They thus became the handiest to use in phonetic transcriptions, so the phonetic letters that survived the transition from pictures to sounds tended to come from the most common words.</p>&#13;
<p class="stext">Text isn’t always written from left to right. Arabic and Hebrew go right to left, and many East Asian languages can be written from top to bottom.</p>&#13;
<p class="stext">Morse code was developed around the great computing year, 1836, to enable operators of the Victorian internet—the telegraph—to communicate quickly. Samuel Morse studied the frequency of letter usage in English to give the common ones the shortest representations. Morse is <em>almost</em> a binary code, as it uses sequences of two symbols to represent letters, but they’re usually used together with a third symbol, empty space, to show breaks between words.</p>&#13;
<p class="stext">Braille was also developed around 1836 by Louis Braille. It’s a true binary code, with each letter represented by binary states of a 2×3 grid. It was originally developed for secret use by soldiers but became popular for its present-day use by blind readers.</p>&#13;
</div>&#13;
<h4 class="h4a"><strong>ASCII</strong></h4>&#13;
<p class="noindent">The <em>American Standard Code for Information Interchange (ASCII)</em>, shown in <a href="ch02.xhtml#ch02fig10">Figure 2-10</a>, represents each character as a unique 7-bit code, meaning it can represent 128 characters in total. This allows for uppercase and lowercase letters, digits, symbols, and punctuation, as well as historical <em>controls</em> such as delete, carriage return, line feed, and ring a bell.</p>&#13;
<p class="indent">In old email systems, ASCII control codes would sometimes be transmitted and displayed as part of the email message rather than actually being executed. The backspace control code was particularly prone to this effect, so you would get emails such as:</p>&#13;
<p class="block1">The team has identified several fuckups^H^H^H^H^H^H^Hchallenges in the plan.</p>&#13;
<p class="noindent">Today, old-timers sometimes type out similar “backspace fails” on purpose for humor.</p>&#13;
<p class="indent">Some operating systems use different conventions to represent the ends of lines, involving line feeds (code 10) and carriage returns (code 13) in text files, which may need to be fixed if you move text files between systems. In the days of typewriters and then teletype machines, these were two different physical controls, one to advance the paper in the machine by a row, and the other to return the print head carriage back to the left side of the paper.</p>&#13;
<p class="indent">ASCII code 0 is commonly used to represent the end of a string. If a string is laid out in memory, programs need a way to work their way through <span epub:type="pagebreak" id="page_65"/>it one character at a time. The convention is that when they reach a zero, they know to stop.</p>&#13;
<p class="indent">As a 1960s American standard, ASCII is a product of a time before globalization and the internet, and it has come to show its age. It can only represent characters from the Latin alphabet, so it can’t directly represent characters needed by languages other than English. Many European languages require multiple versions of Latin characters containing accents, for example, while languages such as Chinese and Arabic use completely different alphabets.</p>&#13;
<p class="indent">However, in one of the most foresighted design decisions ever made in computing, coupled with coincidence, the designers of ASCII were aware of this potential future issue and planned for it. The coincidence was that the machines of the time used groups of 8 bits, while the size of the set of characters needed for English was just under 7 bits. The design decision was to thus use 8-bit representations for ASCII characters but to always make the first bit a 0. In the future, if additional characters were needed, this first bit could be used for other purposes. This has now happened, giving rise to the modern Unicode Standard.</p>&#13;
<div class="image"><img id="ch02fig10" src="../images/f0065-01.jpg" alt="Image" width="998" height="826"/></div>&#13;
<p class="figcap"><em>Figure 2-10: The ASCII character representations</em></p>&#13;
<div class="sidebar">&#13;
<p class="stitle"><span epub:type="pagebreak" id="page_66"/><strong>ASCII AS BASE 256</strong></p>&#13;
<p class="stext">Suppose you’ve written a program in your favorite language, such as the following in BASIC:</p>&#13;
<pre>10 PRINT "HELLO"&#13;
20 GOTO 10</pre>&#13;
<p class="stext">Then suppose you encode the characters of this program as ASCII characters and save them in a text file. Each one of these characters is a byte. If you open your program in a hex editor rather than a normal text editor, you’ll see your program represented as a list of byte codes, such as:</p>&#13;
<pre>31 30 20 50 52 49 4E 54 ... 30</pre>&#13;
<p class="stext">Think about the compound notation concept we’ve previously used in base 1,000, sexagesimal, and byte codes themselves, and apply it to this whole list of byte codes. Consider each byte code as a base 256 digit, and form the <em>entire program</em> into a single very large number, such as:</p>&#13;
<p class="stextc">31<sub>256</sub> × 256<sup>27</sup> + 30<sub>256</sub> × 256<sup>26</sup> + 20<sub>256</sub> × 256<sup>25</sup> + 50<sub>256</sub> × 256<sup>24</sup> . . . + 30<sub>256</sub> × 256<sup>0</sup></p>&#13;
<p class="stext">This calculation would give a single astronomically sized integer. This means we have a mapping between programs and integers: we can represent any program with a single integer. When you write a program, you’re just choosing which integer to apply. This view can be used in computational theory, because it allows math about numbers to talk about programs.</p>&#13;
</div>&#13;
<h4 class="h4a"><strong>Unicode</strong></h4>&#13;
<p class="noindent">What we collectively know as <em>Unicode</em> actually refers to three different but related standards defined in 1991: UTF-8, UTF-16, and UTF-32. <em>UTF-8</em> extends ASCII by making use of the previously unused eighth bit. If it’s a 1, then a second byte follows to enlarge the space of symbols. If the second byte starts with a 1, then a third byte follows as well. If the third byte starts with a 1, then a final, fourth byte is also used. UTF-8 thus allows for more than one million different characters. Its standard doesn’t use all of them, but it includes mappings to symbols needed for all major world languages. So many character encodings are available that international communities have been able to add to the standard, including symbols for less widely spoken languages, ancient languages such as Cuneiform, fictional languages such as Klingon, other symbols such as from mathematics and music, and a large number of emoji (see <a href="ch02.xhtml#ch02fig11">Figure 2-11</a>).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_67"/><img id="ch02fig11" src="../images/f0067-01.jpg" alt="Image" width="680" height="343"/></div>&#13;
<p class="figcap"><em>Figure 2-11: Unicode Thai, math, emoji, and Cuneiform sectors</em></p>&#13;
<p class="indent">For efficiency, the most widely used languages are given the symbols that require only 2 bytes, with the rarer ones requiring 3 bytes and the comedy ones requiring 4 bytes. There are sometimes lively debates about which of these sectors a newly proposed character set should be assigned to. The next time you send a text with just the right emojum to express your feelings, you can thank the ASCII designers for their foresight.</p>&#13;
<p class="indent"><em>UTF-32</em> is a fixed-width encoding that uses all four available bytes in <em>every</em> character. From a storage standpoint, this is obviously inefficient, but for some applications it may speed up the process of looking up symbols. For example, if you want to read the 123rd symbol, then you can find it right away in bytes 123×4 to 123×5.</p>&#13;
<p class="indent"><em>UTF-16</em> is like UTF-8, but at least 2 bytes are always used, even for ASCII characters. This covers a large set of symbols in common use around the world, so it can often act as if it were a fixed-width coding, to enable fast look-ups as in UTF-32. It’s a compromise encoding.</p>&#13;
<p class="indent">Converting files between the different UTF formats is a modern version of the pain we used to have with carriage returns and line feeds in ASCII. Especially with CSV spreadsheet files, using the wrong UTF import can make good files look like garbage.</p>&#13;
<h4 class="h4" id="lev71"><em>Multimedia Data Representation</em></h4>&#13;
<p class="noindent">Data representation gets more fun as we move to images, video, and audio to bring our computers to life. These representations are all built on the arrays of numbers we’ve previously constructed.</p>&#13;
<h4 class="h4a"><strong>Image Data</strong></h4>&#13;
<p class="noindent">Grayscale images can be represented by 2D arrays of numbers, with each element representing a pixel, and its value representing the shade of gray. The type of integer representation within this array affects the quality of the image: if 1-bit integers are used, then each pixel can only be black (0) or white (1), whereas if 8-bit integers are used, then 256 shades of gray are available between black (0) and white (255).</p>&#13;
<p class="indent">Human eyes are receptive to three main frequencies of light: red, green, and blue. This means the experience of seeing an image in color can be <span epub:type="pagebreak" id="page_68"/>reproduced by shining lights at each of these frequencies from each pixel. To represent a color image, we can therefore take three grayscale image representations; use them to represent the red, green, and blue channels of the image; and somehow store them together. Different systems may use different approaches to this storage. For example, we might store the complete red image first, then the green after it, then the blue. But some computations may run faster if we <em>interleave</em> the channels, with the red, green, and blue values for the top-left pixel stored first, one after the other, then the red, green, and blue values for the pixel next to it, and so on.</p>&#13;
<p class="indent">For some applications, it’s useful to add a fourth channel, called <em>alpha</em>, to represent the transparency of each pixel. This representation is known as RGBA. For example, in sprite-based games this tells the graphics code how to mask each sprite, leaving the background intact behind its shape. Non-binary alphas can also be used to blend images together by making them partially transparent to various degrees. Including an alpha channel is especially convenient because having four channels makes a power of two, which plays nicely with binary architectures. For example, it is common to use 32-bit colors with four 8-bit channels, rather than 24-bit colors with three 8-bit channels, on a 32-bit machine. Of course, this requires more storage, so pixel values might be stored as 24 bits and converted to 32 bits when loaded into memory. (Since 24-bit RGB is usually considered the maximum color depth that humans can distinguish, there’s little point in going to 64-bit color, even on 64-bit machines.)</p>&#13;
<p class="indent">Video can be represented (most basically) as a sequence of still images packed in temporal sequence.</p>&#13;
<h4 class="h4a"><strong>Audio Data</strong></h4>&#13;
<p class="noindent">Continuous sound waves can be represented as a series of discrete samples. The samples need to be taken at a rate of double the highest frequency present in the signal. Human hearing ranges from around 20 to 20,000 Hz, so common audio sample rates are around 40,000 Hz. Each sample is a number, and as with color depth, the choice of the number of bits to devote to each sample affects the sound quality. Consumer media such as Blu-ray uses a depth of 24 bits, around the maximum distinguishable to humans, while 32 bits may be used internally and by audio producers, as it’s a power of two and gives more robustness to editing manipulations.</p>&#13;
<p class="indent">Stereo or multichannel audio can be thought of as a collection of sound waves meant to be played together. These might be stored as one whole wave at a time in memory, or interleaved over time, with one sample from each channel stored contiguously for each sample time.</p>&#13;
<p class="indent">Almost all sound representations use either integer or fixed-point representations for the individual samples. A consequence of this is that there are clear minimum and maximum values that samples can take. If the signal goes out of this “headroom” range it will <em>clip</em>, losing information and sounding distorted. Musicians and voice actors often curse these data representations if they have just performed a perfect take but it got clipped and they have to do it again. A recent trend in professional audio systems is a move <span epub:type="pagebreak" id="page_69"/>to all floating-point representations, which are much more computationally intensive but free the artists from the clipping problem.</p>&#13;
<p class="indent">When dealing with <em>multi</em>media, such as movies that include video and audio together, the interleaving representation concept is often extended so that data from each medium for a point in time is coded together in a contiguous area of memory—for example, all the data for one video frame, plus an audio segment for the duration of that frame. The interleaving schemes are known as <em>containers</em>. <em>Ogg</em> and <em>MP4</em> are two well-known container data representations used for movies.</p>&#13;
<h4 class="h4a"><strong>Compression</strong></h4>&#13;
<p class="noindent">The simple media representations for images, video, and audio that we’ve just discussed are good during computation, but they aren’t usually ideal in terms of storage. For efficiency, we often look for ways to <em>compress</em> the data without changing the human experience of it.</p>&#13;
<p class="indent">The natural world tends to contain a lot of redundancy—that is, it has regions of space and time that are composed of similar stuff. For example, in a video of a thrown red ball, if you see one red pixel belonging to the ball, then it’s very likely that the pixels around it are also red, and that this pixel or nearby pixels will be red in the next frame as well. Also, the human senses have particular focuses and blind spots, for example being sensitive to the amplitude but not the phase of audio frequencies, and not hearing some frequencies in the background when others are present.</p>&#13;
<p class="indent">Information theory explains how to compress media data by exploiting and removing these redundancies and perceptual blind spots. This way, a smaller number of bits can be used in a more complex way to represent the same or perceptually similar media data. This is useful both to reduce physical storage needs, such as the size of a Blu-ray disc, and also to reduce network use when streaming media. However, it comes at a cost of additional computation: we usually need to convert the compressed representations back to the raw ones, which can be quite complex, depending on the compression scheme used. Most schemes rely on mathematical operations like Fourier transforms to find spatial or temporal frequencies. These can be costly for conventional CPUs to compute and have been a major driver of specialized signal processing architectures to accelerate them. Implementations of compression algorithms are known as <em>codecs</em>.</p>&#13;
<h4 class="h4" id="lev72"><em>Data Structures</em></h4>&#13;
<p class="noindent">Any data structure, such as the structs and objects found in most programming languages, can be represented through <em>serialization</em>, whereby the data is transformed into a <em>series</em> of bits to store in memory. Serialization can be performed hierarchically: if a complex structure is composed of several smaller structures, we serialize it by first serializing each of these components, then joining their representations together in series to make the total representation. If the component structures are themselves complex, the process becomes recursive, but eventually we always reach a level of simple <span epub:type="pagebreak" id="page_70"/>elements such as numbers or text, and we’ve already discussed how to represent these as a series of bits (that is, serialize them).</p>&#13;
<p class="indent">To give an example, say we have the following data structure:</p>&#13;
<pre>class Cat:&#13;
  int age&#13;
  int legs&#13;
  string name</pre>&#13;
<p class="noindent">This will be serialized as a bit sequence beginning with the encoding for integer <code>age</code>, followed by the encoding for integer <code>legs</code>, and then perhaps a Unicode sequence for the string <code>name</code>.</p>&#13;
<p class="indent">Now say a <code>Cat</code> object is included in another structure:</p>&#13;
<pre>class Game:&#13;
  Cat scratch&#13;
  int lives&#13;
  int score</pre>&#13;
<p class="noindent">The <code>Game</code> object will be serialized with its first bits being the encoding of the <code>Cat</code> object (itself a serialization of various components), followed by the encodings of the <code>lives</code> and <code>score</code> integers. We can continue to build higher and higher levels of structure in this way, which is how real-world large-scale programs work.</p>&#13;
<h3 class="h3" id="lev73">Measuring Data</h3>&#13;
<p class="noindent">The basic unit of data is the <em>bit (b)</em>, which can take one of two possible states, usually written as 0 and 1. When studying data, we’ll often be working with very large numbers of bits, however, so we need notations and visualizations to handle these.</p>&#13;
<p class="indent"><em>SI (Système Internationale)</em> is an international organization of scientists and engineers that sets generally accepted standards for scientific measurement units. This includes defining standard prefixes for powers of 1,000, as shown in <a href="ch02.xhtml#ch02tab3">Table 2-3</a>.</p>&#13;
<p class="tabcap" id="ch02tab3"><strong>Table 2-3:</strong> Large SI Prefixes</p>&#13;
<table class="allc">&#13;
<colgroup>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Name</strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Symbol</strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Value</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">kilo</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">k</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">10<sup>3</sup> =1,000</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">mega</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">M</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">10<sup>6</sup> = 1,000,000</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">giga</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">G</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">10<sup>9</sup> = 1,000,000,000</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">tera</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">T</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">10<sup>12</sup> = 1,000,000,000,000</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">peta</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">P</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">10<sup>15</sup> = 1,000,000,000,000,000</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">exa</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">E</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">10<sup>18</sup> = 1,000,000,000,000,000,000</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">zetta</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">Z</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">10<sup>21</sup> = 1,000,000,000,000,000,000,000</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_71"/>To visualize the large scales represented by SI prefixes, it can be useful to imagine 3D cubes, based on a cubic meter. Perhaps the reason we give special names and prefixes to powers of 1,000 is that 1,000 is three scalings of 10, which in 3D means scaling an object by 10 in all three of its dimensions.</p>&#13;
<p class="indent">Using SI prefixes with bits should be the preferred standard for describing quantities of data, according to SI—for example, 5 megabits means 5,000 bits. In fact, network speeds are often measured in megabits per second. However, at the architectural level we more commonly need to work with numbers that are exact powers of 2, not 10. For example, a 10-bit address space provides 2<sup>10</sup> = 1,024 addresses, while a 16-bit address space provides 2<sup>16</sup> = 65,536 addresses. Before architects adopted the SI standards—during the 8-bit era, for example—it was common for architects to abuse the prefix “kilo” to refer to 1,024 instead of 1,000.</p>&#13;
<p class="indent">This naturally led to much confusion. Data sizes have gotten larger, and most computer people operate at a higher level, where working in proper SI units makes more sense. As a compromise, in 1998 the International Electrotechnical Commission defined an alternate set of prefixes to distinguish the powers of two from the SI prefixes. These have the morpheme <em>bi</em> in them, from the word <em>binary</em>. For example, 2<sup>10</sup> has become kibi, 2<sup>20</sup> has become mebi, and so on, as in <a href="ch02.xhtml#ch02tab4">Table 2-4</a>.</p>&#13;
<p class="tabcap" id="ch02tab4"><strong>Table 2-4:</strong> Large Binary Prefixes</p>&#13;
<table class="allc">&#13;
<colgroup>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Name</strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Symbols</strong></p></th>&#13;
<th style="vertical-align: top" class="borderb"><p class="tabtext"><strong>Value</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">kibi</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">k<sub>2</sub>, ki</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">2<sup>10</sup> = 1,024</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">mebi</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">M<sub>2</sub>, Mi</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">2<sup>20</sup> = 1,048,576</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">gibi</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">G<sub>2</sub>, Gi</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">2<sup>30</sup> = 1,073,741,824</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">tebi</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">T<sub>2</sub>, Ti</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">2<sup>40</sup> = 1,099,511,627,776</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">pebi</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">P<sub>2</sub>, Pi</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">2<sup>50</sup> = 1,125,899,906,842,624</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tabtext">exbi</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">E<sub>2</sub>, Ei</p></td>&#13;
<td style="vertical-align: top"><p class="tabtext">2<sup>60</sup> = 1,152,921,504,606,846,976</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">zebi</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">Z<sub>2</sub>, Zi</p></td>&#13;
<td style="vertical-align: top" class="gray"><p class="tabtext">2<sup>70</sup> = 1,180,591,620,717,411,303,424</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Binary prefixes are slightly larger than their SI counterparts. Not everyone is using them yet, and many older people and machines still use SI names to refer to binary units. Unscrupulous hardware manufacturers often exploit this ambiguity by picking whichever interpretation of the SI names will give them the best-looking numbers on their products.</p>&#13;
<h3 class="h3" id="lev74">Summary</h3>&#13;
<p class="noindent">Computers usually need to represent various types of numbers, text, and media data. It’s convenient for modern machines to do this using binary. Hex representations chunk binary together to appear more readable to humans. Different representations make different computations easier to perform.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_72"/>Once we have methods for representing data, we can begin to build up methods for computing with the data. In the next chapter, we’ll preview a simple but complete computer that does this. We’ll then build up a more detailed modern electronic computer to do similar.</p>&#13;
<h3 class="h3" id="lev75">Exercises</h3>&#13;
<h4 class="h4a"><strong>Base System Conversions</strong></h4>&#13;
<ol class="number">&#13;
<li class="tm">Convert your phone number to binary.</li>&#13;
<li class="tm">Convert your phone number to hex. Making use of the binary from before might be helpful. Convert it again to byte codes, and convert the bytes to ASCII characters. What do they spell out?</li>&#13;
<li class="tm">Negate your phone number and convert this negative number to its two’s complement.</li>&#13;
<li class="tm">Place a decimal point halfway through your phone number to make a floating-point number. Write it in IEEE 754 standard binary.</li>&#13;
</ol>&#13;
<h4 class="h4a"><strong>Text and Media</strong></h4>&#13;
<p class="noindent">Find out how to type in Unicode on your computer. On many Linuxes, for example, you can press and release <small>SHIFT-CTRL</small>-U, then type a series of hex numbers such as 131bc to enter an ancient Egyptian digit at your command line or in your editor.</p>&#13;
<h4 class="h4a"><strong>Measuring Data</strong></h4>&#13;
<p class="noindent">Obtain street, aerial, and satellite photos of an area you know, and draw a kilocube, megacube, gigacube, teracube, petacube, exacube, and zettacube on them, where, for example, each side of a kilocube is 10 m long.</p>&#13;
<h4 class="h4a"><strong>More Challenging</strong></h4>&#13;
<p class="noindent">Use a hex editor and the internet to reverse engineer and modify some of your favorite media files.</p>&#13;
<h3 class="h3" id="lev76">Further Reading</h3>&#13;
<ul class="bullet">&#13;
<li class="tm">For discussions and psychological models of numerosity, see Stanislas Dehaene, <em>The Number Sense</em> (Oxford: Oxford University Press, 2011), and the “Numbo” chapter in Douglas R. Hofstadter, <em>Fluid Concepts and Creative Analogies</em> (New York: Basic Books, 1995).</li>&#13;
<li class="tm">For an advanced but classic paper full of details on floating points, see D. Goldberg, “What Every Programmer Should Know About Floating Point Arithmetic,” <em>ACM Computing Surveys (CSUR)</em> 23, no. 1 (1991): 5–48.</li>&#13;
<li class="tm">For an extremely advanced but blindingly beautiful book on Turing reals, see Oliver Aberth, <em>Computable Calculus</em> (San Diego: Academic Press, 2001).</li>&#13;
</ul>&#13;
</div>
</div>
</body></html>