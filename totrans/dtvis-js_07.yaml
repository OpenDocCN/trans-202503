- en: Chapter 7. Custom Visualizations with D3.js
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 7 章：使用 D3.js 创建自定义可视化
- en: In this book we’ve looked at many JavaScript libraries that were designed for
    specific types of visualizations. If you need a certain type of visualization
    for your web page and there’s a library that can create it, using that library
    is often the quickest and easiest way to create your visualization. There are
    drawbacks to such libraries, however. They all make assumptions about how the
    visualization should look and act, and despite the configuration options they
    provide, you don’t have complete control over the results. Sometimes that’s not
    an acceptable trade-off.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们讨论了许多为特定类型可视化设计的 JavaScript 库。如果你需要某种特定类型的可视化，而恰好有一个库可以创建它，使用该库通常是创建可视化的最快且最简便的方法。然而，这些库也有缺点。它们都对可视化的外观和行为做出假设，尽管它们提供了一些配置选项，你对结果并没有完全的控制权。有时候，这种权衡是不可接受的。
- en: 'In this chapter, we’ll look at an entirely different approach to JavaScript
    visualizations, one that allows us to be creative and to retain complete control
    over the results. As you might expect, that approach isn’t always as easy as,
    for example, adding a charting library and feeding it data. Fortunately, there
    is a very powerful JavaScript library that can help: D3.js (*[http://d3js.org/](http://d3js.org/)*).
    D3.js doesn’t provide predefined visualizations such as charts, graphs, or maps.
    Instead, it’s a toolbox for data visualization, and it gives you the tools to
    create *your own* charts, graphs, maps, and more.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将探索一种完全不同的 JavaScript 可视化方法，这种方法允许我们发挥创意并保持对结果的完全控制。如你所料，这种方法并不像例如添加一个图表库并将数据输入其中那样简单。幸运的是，有一个非常强大的
    JavaScript 库可以帮助我们：D3.js（* [http://d3js.org/](http://d3js.org/) *）。D3.js 不提供预定义的可视化，如图表、图形或地图。相反，它是一个数据可视化工具箱，提供创建
    *你自己的* 图表、图形、地图等的工具。
- en: 'To see some of the powerful features of D3.js, we’ll take a whirlwind tour.
    This chapter’s examples include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 D3.js 的一些强大功能，我们将进行一个快速的概览。本章的示例包括以下内容：
- en: Adapting a traditional chart type for particular data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为特定数据调整传统图表类型
- en: Building a force-directed graph that responds to user interactions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个响应用户交互的力导向图
- en: Displaying map-based data using high-quality SVGs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高质量的 SVG 显示基于地图的数据
- en: Creating a fully customized visualization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建完全自定义的可视化
- en: Adapting a Traditional Chart Type
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整传统图表类型
- en: The most significant difference between D3.js and other JavaScript libraries
    is its philosophy. D3.js is not a tool for creating predefined types of charts
    and visualizations. Instead, it’s a library to help you create any visualization,
    including custom and unique presentations. It takes more effort to create a standard
    chart with D3.js, but by using it we’re not limited to standard charts. To get
    a sense of how D3.js works, we can create a custom chart that wouldn’t be possible
    with a typical charting library.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js 与其他 JavaScript 库的最大区别在于它的哲学理念。D3.js 不是用来创建预定义的图表和可视化工具的工具，而是一个帮助你创建任何可视化（包括自定义和独特展示）的库。使用
    D3.js 创建标准图表需要更多的工作，但通过它，我们不受限于标准图表。为了了解 D3.js 是如何工作的，我们可以创建一个使用典型图表库无法实现的自定义图表。
- en: For this example, we’ll visualize one of the most important findings in modern
    physics—Hubble’s law. According to that law, the universe is expanding, and as
    a result, the speed at which we perceive distant galaxies to be moving varies
    according to their distance from us. More precisely, Hubble’s law proposes that
    the variation, or shift, in this speed is a linear function of distance. To visualize
    the law, we can chart the speed variation (known as *red shift velocity*) versus
    distance for several galaxies. If Hubble is right, the chart should look like
    a line. For our data, we’ll use galaxies and clusters from Hubble’s original 1929
    paper (*[http://www.pnas.org/content/15/3/168.full](http://www.pnas.org/content/15/3/168.full)*)
    but updated with current values for distance and red shift velocities.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将可视化现代物理学中最重要的发现之一——哈勃定律。根据该定律，宇宙正在膨胀，因此我们感知到远处星系的运动速度会根据它们与我们的距离而变化。更准确地说，哈勃定律提出，这种速度变化（称为
    *红移速度*）是距离的线性函数。为了可视化这个定律，我们可以将多个星系的速度变化（即 *红移速度*）与距离进行对比。如果哈勃定律正确，那么图表应该呈现出一条直线。对于我们的数据，我们将使用哈勃
    1929 年原始论文中的星系和星系团数据（* [http://www.pnas.org/content/15/3/168.full](http://www.pnas.org/content/15/3/168.full)
    *），但更新为当前的距离和红移速度值。
- en: 'So far this task seems like a good match for a scatter chart. Distance could
    serve as the x-axis and velocity the y-axis. There’s a twist, though: physicists
    don’t actually know the distances or velocities that we want to chart, at least
    not exactly. The best they can do is estimate those values, and there is potential
    for error in both. But that’s no reason to abandon the effort. In fact, potential
    errors in the values might be an important aspect for us to highlight in our visualization.
    To do that, we won’t draw each value as a point. Rather, we’ll show it as a box,
    and the box dimensions will correspond to the potential errors in the value. This
    approach isn’t common for scatter plots, but D3.js can accommodate it with ease.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这个任务看起来很适合用散点图展示。距离可以作为 x 轴，速度作为 y 轴。不过，有一点不同：物理学家其实并不知道我们要绘制的距离或速度，至少不是准确的数值。他们最多能做的是估算这些值，并且这两个值都可能存在误差。但这并不是放弃这个努力的理由。事实上，这些潜在的误差可能是我们在可视化中需要强调的一个重要方面。为此，我们不会将每个值作为一个点来绘制，而是将它们显示为一个框，框的尺寸将对应该值的潜在误差。虽然这种方法在散点图中不常见，但
    D3.js 可以轻松实现。
- en: 'Step 1: Prepare the Data'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步：准备数据
- en: Here is the data for our chart according to recent estimates.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是根据最新估算得出的图表数据。
- en: Table 7-1. Distance and Red Shift Velocity for Nebulae and Clusters
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 表7-1. 星云和星系团的距离与红移速度
- en: '| Nebulae/cluster | Distance (Mpc) | Red shift velocity (km/s) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 星云/星系团 | 距离（Mpc） | 红移速度（km/s） |'
- en: '| --- | --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| NGC 6822 | 0.500±0.010 | 57±2 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| NGC 6822 | 0.500±0.010 | 57±2 |'
- en: '| NGC 221 | 0.763±0.024 | 200±6 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| NGC 221 | 0.763±0.024 | 200±6 |'
- en: '| NGC 598 | 0.835±0.105 | 179±3 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| NGC 598 | 0.835±0.105 | 179±3 |'
- en: '| NGC 4736 | 4.900±0.400 | 308±1 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| NGC 4736 | 4.900±0.400 | 308±1 |'
- en: '| NGC 5457 | 6.400±0.500 | 241±2 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| NGC 5457 | 6.400±0.500 | 241±2 |'
- en: '| NGC 4258 | 7.000±0.500 | 448±3 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| NGC 4258 | 7.000±0.500 | 448±3 |'
- en: '| NGC 5194 | 7.100±1.200 | 463±3 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| NGC 5194 | 7.100±1.200 | 463±3 |'
- en: '| NGC 4826 | 7.400±0.610 | 408±4 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| NGC 4826 | 7.400±0.610 | 408±4 |'
- en: '| NGC 3627 | 11.000±1.500 | 727±3 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| NGC 3627 | 11.000±1.500 | 727±3 |'
- en: '| NGC 7331 | 12.200±1.000 | 816±1 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| NGC 7331 | 12.200±1.000 | 816±1 |'
- en: '| NGC 4486 | 16.400±0.500 | 1307±7 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| NGC 4486 | 16.400±0.500 | 1307±7 |'
- en: '| NGC 4649 | 16.800±1.200 | 1117±6 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| NGC 4649 | 16.800±1.200 | 1117±6 |'
- en: '| NGC 4472 | 17.100±1.200 | 729±2 |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| NGC 4472 | 17.100±1.200 | 729±2 |'
- en: We can represent that in JavaScript using the following array.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下数组在 JavaScript 中表示这些数据。
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Step 2: Set Up the Web Page'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步：设置网页
- en: D3.js doesn’t depend on any other libraries, and it’s available on most CDNs.
    All we need to do is include it in the page.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js 不依赖其他任何库，而且它在大多数 CDN 上都可以获取。我们所需要做的就是将其引入页面。
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We include D3.js at ➋, and we set up a `<div>` with the `id "container"` at
    ➊ to contain our visualization.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➋位置引入 D3.js，并在➊位置设置一个`id "container"`的 `<div>`，用来容纳我们的可视化内容。
- en: 'Step 3: Create a Stage for the Visualization'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步：为可视化创建一个舞台
- en: Unlike higher-level libraries, D3.js doesn’t draw the visualization on the page.
    We’ll have to do that ourselves. In exchange for the additional effort, though,
    we get the freedom to pick our own drawing technology. We could follow the same
    approach as most libraries in this book and use HTML5’s `<canvas>` element, or
    we could simply use native HTML. Now that we’ve seen it in action in [Chapter 6](ch06.html
    "Chapter 6. Visualizing Geographic Data"), however, it seems using SVG is the
    best approach for our chart. The root of our graph, therefore, will be an `<svg>`
    element, and we need to add that to the page. We can define its dimensions at
    the same time using attributes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与更高层次的库不同，D3.js 并不会自动在页面上绘制可视化图表。我们需要自己动手做这件事。作为回报，我们获得了自由选择绘图技术的权利。我们可以像本书中大多数库那样使用
    HTML5 的 `<canvas>` 元素，或者直接使用原生 HTML。不过，既然我们已经在[第6章](ch06.html "第6章. 可视化地理数据")看到过它的应用，使用
    SVG 似乎是最适合我们图表的方法。因此，我们图表的根元素将是一个 `<svg>` 元素，我们需要将它添加到页面中。我们可以同时通过属性定义它的尺寸。
- en: 'If we were using jQuery, we might do something like the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 jQuery，可能会做如下操作：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With D3.js our code is very similar:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 D3.js 时，我们的代码非常相似：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this statement, we’re selecting the container, appending an `<svg>` element
    to it, and setting the attributes of that `<svg>` element. This statement highlights
    one important difference between D3.js and jQuery that often trips up developers
    starting out with D3.js. In jQuery the `append()` method returns the original
    selection so that you can continue operating on that selection. More specifically,
    `$("#container").append(svg)` returns `$("#container")`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这条语句中，我们选择了容器，向其中添加了一个`<svg>`元素，并设置了该`<svg>`元素的属性。这条语句突出了D3.js与jQuery之间一个重要的区别，这个区别常常让刚开始学习D3.js的开发者感到困惑。在jQuery中，`append()`方法返回原始选择，这样你就可以继续对该选择进行操作。更具体地说，`$("#container").append(svg)`返回的是`$("#container")`。
- en: With D3.js, on the other hand, `append()` returns a different selection, the
    newly appended element(s). So `d3.select("#container").append("svg")` doesn’t
    return the container selection, but rather a selection of the new `<svg>` element.
    The `attr()` calls that follow, therefore, apply to the `<svg>` element and not
    the `"#container"`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在D3.js中，`append()`返回的是一个不同的选择，即新添加的元素。因此，`d3.select("#container").append("svg")`并不返回容器选择，而是返回新`<svg>`元素的选择。随后调用的`attr()`方法因此应用于`<svg>`元素，而不是`"#container"`。
- en: 'Step 4: Control the Chart’s Dimensions'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步：控制图表的维度
- en: So far we haven’t specified the actual values for the chart’s height and width;
    we’ve only used `height` and `width` variables. Having the dimensions in variables
    will come in handy, and it will make it easy to incorporate margins into the visualization.
    The following code sets up those dimensions; its form is a common convention in
    D3.js visualizations.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有指定图表的实际高度和宽度；我们只使用了`height`和`width`变量。将这些维度存储在变量中会非常有用，并且它使得在可视化中加入边距变得更加容易。下面的代码设置了这些维度；它的形式是D3.js可视化中常见的惯例。
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We’ll have to adjust the code that creates the main `<svg>` container to account
    for these margins.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调整创建主`<svg>`容器的代码，以考虑这些边距。
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To make sure our chart honors the defined margins, we’ll construct it entirely
    within a child SVG group (`<g>`) element. The `<g>` element is just an arbitrary
    containing element in SVG, much like the `<div>` element for HTML. We can use
    D3.js to create the element and position it appropriately within the main `<svg>`
    element.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的图表符合定义的边距，我们将在一个子SVG组（`<g>`）元素内完全构建图表。`<g>`元素只是SVG中的一个任意容器元素，就像HTML中的`<div>`元素一样。我们可以使用D3.js来创建这个元素，并将其适当地定位在主`<svg>`元素中。
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Visualizations must often rescale the source data. In our case, we’ll need to
    rescale the data to fit within the chart dimensions. Instead of ranging from 0.5
    to 17 Mpc, for example, galactic distance should be scaled between 0 and 920 pixels.
    Since this type of requirement is common for visualizations, D3.js has tools to
    help. Not surprisingly, they’re `scale` objects. We’ll create scales for both
    the x- and y-dimensions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化通常需要对源数据进行重新缩放。在我们的案例中，我们需要将数据重新缩放以适应图表的维度。例如，星系距离不再从0.5到17 Mpc，而是需要缩放到0到920像素之间。由于这种需求在可视化中很常见，D3.js提供了相关工具来帮助实现。毫不奇怪，这些工具就是`scale`对象。我们将为x轴和y轴的维度创建比例尺。
- en: As the following code indicates, both of our scales are linear. Linear transformations
    are pretty simple (and we really don’t need D3.js to manage them); however, D3.js
    supports other types of scales that can be quite complex. With D3.js, using more
    sophisticated scaling is just as easy as using linear scales.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如下面的代码所示，我们的两个比例尺都是线性的。线性变换相对简单（而且我们实际上不需要D3.js来管理它们）；然而，D3.js还支持其他类型的比例尺，这些比例尺可能相当复杂。在D3.js中，使用更复杂的比例尺和使用线性比例尺一样简单。
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We define both ranges as the desired limits for each scale. The x-scale ranges
    from `0` to the chart’s width, and the y-scale ranges from `0` to the chart’s
    height. Note, though, that we’ve reversed the normal order for the y-scale. That’s
    because SVG dimensions (just like HTML dimensions) place 0 at the top of the area.
    That convention is the opposite of the normal chart convention, which places 0
    at the bottom. To account for the reversal, we swap the values when defining the
    range.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将两个范围定义为每个比例尺的期望极限。x比例尺的范围是从`0`到图表的宽度，y比例尺的范围是从`0`到图表的高度。不过需要注意的是，我们已经反转了y比例尺的常规顺序。这是因为SVG的维度（就像HTML的维度一样）将0放在区域的顶部。这个惯例与常规图表惯例相反，后者将0放在底部。为了应对这种反转，我们在定义范围时交换了值。
- en: 'At this point, we’ve set the ranges for each scale, and those ranges define
    the desired output. We also have to specify the possible inputs to each scale,
    which D3.js calls the *domain.* Those inputs are the minimum and maximum values
    for the distance and velocity. We can use D3.js to extract the values directly
    from the data. Here’s how to get the minimum distance:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经为每个刻度设置了范围，这些范围定义了所需的输出。我们还需要为每个刻度指定可能的输入，这些输入在 D3.js 中被称为 *domain*（领域）。这些输入是距离和速度的最小值和最大值。我们可以使用
    D3.js 直接从数据中提取这些值。以下是获取最小距离的方法：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can’t simply find the minimum value in the data, because we have to account
    for the distance error. As we can see in the preceding snippet, D3.js accepts
    a function as a parameter to `d3.min()`, and that function can make the necessary
    adjustment. We can use the same approach for maximum values as well. Here’s the
    complete code for defining the domains of both scales:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地在数据中找到最小值，因为我们必须考虑到距离误差。正如在前面的代码片段中所看到的，D3.js 接受一个函数作为 `d3.min()` 的参数，而这个函数可以进行必要的调整。我们也可以对最大值使用相同的方法。以下是定义两个刻度的领域的完整代码：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Step 5: Draw the Chart Framework'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 5 步：绘制图表框架
- en: Axes are another common feature in visualizations, and D3.js has tools for those
    as well. To create the axes for our chart, we specify the appropriate scales and
    an orientation. As you can see from the following code, D3.js supports axes as
    part of its SVG utilities.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标轴是可视化中的另一个常见特性，D3.js 也为此提供了工具。为了为我们的图表创建坐标轴，我们指定适当的刻度和方向。正如你从以下代码中看到的，D3.js
    将坐标轴作为其 SVG 工具的一部分来支持。
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After defining the axes, we can use D3.js to add the appropriate SVG elements
    to the page. We’ll contain each axis within its own `<g>` group. For the x-axis,
    we need to shift that group to the bottom of the chart.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了坐标轴之后，我们可以使用 D3.js 将适当的 SVG 元素添加到页面中。我们会将每个坐标轴放置在各自的 `<g>` 组中。对于 x 轴，我们需要将该组移到图表的底部。
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To create the SVG elements that make up the axis, we could call the `xAxis`
    object and pass it the containing group as a parameter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建构成坐标轴的 SVG 元素，我们可以调用 `xAxis` 对象，并将包含组作为参数传递给它。
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With D3.js, though, there’s a more concise expression that avoids creating unnecessary
    local variables and preserves method chaining.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 D3.js 中，有一种更简洁的表达方式，它避免了创建不必要的局部变量，并保持方法链的使用。
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And as long as we’re preserving method chaining, we can take advantage of it
    to add yet another element to our chart: this time, it’s the label for the axis.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们保持方法链的使用，就可以利用它再向图表中添加一个元素：这次是轴的标签。
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you look under the hood, you’ll find that D3.js has done quite a bit of
    work for us in creating the axis, its tick marks, and its labels. Here’s a taste
    of the SVG it builds:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你深入查看，你会发现 D3.js 为我们做了很多工作，创建了坐标轴、刻度线和标签。这是它生成的部分 SVG 代码：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When we add the code for the y-axis, we’ve completed the framework for the chart.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为 y 轴添加代码时，我们就完成了图表的框架。
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The result of [Figure 7-1](ch07.html#d3dotjs_provides_tools_to_create_the_fra
    "Figure 7-1. D3.js provides tools to create the framework for a chart.") isn’t
    very exciting without any data, but it does give us a framework for the chart.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-1](ch07.html#d3dotjs_provides_tools_to_create_the_fra "图 7-1. D3.js 提供了用于创建图表框架的工具")
    的结果没有数据时看起来并不特别吸引人，但它确实为我们提供了图表的框架。'
- en: '![D3.js provides tools to create the framework for a chart.](figs/web/07fig01.png.jpg)Figure 7-1. D3.js
    provides tools to create the framework for a chart.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![D3.js 提供了用于创建图表框架的工具。](figs/web/07fig01.png.jpg)图 7-1. D3.js 提供了用于创建图表框架的工具。'
- en: As you can tell, we’ve had to write quite a bit of code just to get a couple
    of axes on the page. That’s the nature of D3.js. It’s not a library to which you
    can simply pass a data set and get a chart as an output. Instead, think of it
    as a collection of very useful utilities that you can use to help create your
    own charts.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，为了在页面上添加几个坐标轴，我们已经写了不少代码。这就是 D3.js 的特性。它不是一个你可以简单地传入数据集并获得图表输出的库。相反，应该将其视为一组非常有用的工具，帮助你创建自己的图表。
- en: 'Step 6: Add the Data to the Chart'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 6 步：将数据添加到图表中
- en: Now that our chart’s framework is ready, we can add the actual data. Because
    we want to show both the distance and velocity errors in the data, we can draw
    each point as a rectangle. For a simple, static chart, we can add SVG `<rect>`
    elements just as we’ve created the rest of the chart. We can take advantage of
    our x- and y-scales to calculate the dimensions of the rectangles.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的图表框架已经准备好，我们可以添加实际的数据。由于我们希望显示数据中的距离和速度误差，我们可以将每个点绘制为一个矩形。对于一个简单的静态图表，我们可以像创建其他图表元素一样添加
    SVG `<rect>` 元素。我们可以利用我们的 x 和 y 比例尺来计算矩形的尺寸。
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding approach works fine for this example and results in the chart
    in [Figure 7-2](ch07.html#d3dotjs_can_render_the_data_elements_usi "Figure 7-2. D3.js
    can render the data elements using any valid markup, including SVG <rect> elements
    with defined dimensions."). Typically, however, D3.js visualizations combine their
    data sets directly with markup elements and rely on D3’s `enter`, `update`, and
    `exit` selections to add the data to the page. We’ll defer further discussion
    of this alternative approach until the next example.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法对于这个示例来说效果很好，生成了图表如[图 7-2](ch07.html#d3dotjs_can_render_the_data_elements_usi
    "图 7-2。D3.js 可以使用任何有效的标记语言渲染数据元素，包括具有定义尺寸的 SVG <rect> 元素。")所示。然而，通常情况下，D3.js 可视化会直接将数据集与标记元素结合，并依赖
    D3 的 `enter`、`update` 和 `exit` 选择来将数据添加到页面上。我们将推迟在下一个示例中讨论这种替代方法。
- en: '![D3.js can render the data elements using any valid markup, including SVG
    <rect> elements with defined dimensions.](figs/web/07fig02.png.jpg)Figure 7-2. D3.js
    can render the data elements using any valid markup, including SVG `<rect>` elements
    with defined dimensions.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![D3.js 可以使用任何有效的标记语言渲染数据元素，包括具有定义尺寸的 SVG <rect> 元素。](figs/web/07fig02.png.jpg)图
    7-2。D3.js 可以使用任何有效的标记语言渲染数据元素，包括具有定义尺寸的 SVG `<rect>` 元素。'
- en: 'Step 7: Answer Users’ Questions'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 7：回答用户的问题
- en: Whenever you create a visualization, it’s a good idea to anticipate questions
    that users might ask when they view it. In our example so far, we’ve presented
    a data set that leads to Hubble’s law. But we haven’t (yet) shown how well the
    data fits that law. Since that is such an obvious question, let’s answer it right
    on the chart itself.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你创建一个可视化时，提前考虑用户在查看它时可能提出的问题是一个好主意。在我们目前的示例中，我们展示了一个导致哈勃定律的数据集。但我们还没有（尚未）展示这些数据与该定律的拟合程度。由于这是一个显而易见的问题，我们可以直接在图表上回答它。
- en: The current estimate for the Hubble constant (H[0]) is about 70 km/s/Mpc. To
    show how that matches the data on our chart, we can create a line graph with that
    slope beginning at the point (0,0). A single SVG `<line>` is all that’s required.
    Once again we rely on the D3.js scales to define the line’s coordinates.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当前对哈勃常数（H[0]）的估计值约为 70 km/s/Mpc。为了展示这个值如何与我们图表中的数据相匹配，我们可以创建一个从（0,0）点开始的直线图。只需要一个简单的
    SVG `<line>` 元素即可。我们再次依赖 D3.js 的比例尺来定义线条的坐标。
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In [Figure 7-3](ch07.html#complete_custom_chart_shows_the_data_set "Figure 7-3. The
    complete custom chart shows the data set exactly as we wish.") we can see that
    Hubble’s law remains a good approximation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 7-3](ch07.html#complete_custom_chart_shows_the_data_set "图 7-3。完整的自定义图表精确展示了我们所需的数据集。")中，我们可以看到哈勃定律仍然是一个很好的近似值。
- en: '![The complete custom chart shows the data set exactly as we wish.](figs/web/07fig03.png.jpg)Figure 7-3. The
    complete custom chart shows the data set exactly as we wish.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![完整的自定义图表精确地展示了我们所需的数据集。](figs/web/07fig03.png.jpg)图 7-3。完整的自定义图表精确地展示了我们所需的数据集。'
- en: Creating a Force-Directed Network Graph
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个力导向网络图
- en: Unlike the JavaScript plotting libraries we considered in the early chapters,
    D3.js is not limited to standard charts. In fact, it excels at specialized and
    custom graph types. To see its power, we’ll create another version of the network
    graph from [Chapter 4](ch04.html "Chapter 4. Creating Specialized Graphs"). In
    the earlier implementation we used the Sigma library, and most of our work was
    structuring the data into the format that library requires. We didn’t have to
    decide how to draw the nodes and edges, how to connect them, or, once we enabled
    layouts, how to position them on the page. As we’ll see next, D3.js doesn’t make
    those decisions for us. For this example, we’ll have to draw the nodes and edges,
    connect them to each other appropriately, and position them on the page. That
    may sound like a lot of work, but, as we’ll also see, D3.js gives us a lot of
    tools to help.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在前几章中考虑的 JavaScript 绘图库不同，D3.js 不仅限于标准图表。事实上，它在专业和自定义图形类型方面表现优异。为了展示其强大功能，我们将创建一个来自[第
    4 章](ch04.html "第 4 章：创建专业图表")的网络图的另一个版本。在之前的实现中，我们使用了 Sigma 库，并且大部分工作是将数据结构化为该库所需的格式。我们不需要决定如何绘制节点和边，如何连接它们，或者在启用布局后，如何将它们定位在页面上。正如我们接下来所看到的，D3.js
    并不会为我们做这些决策。对于这个例子，我们将需要自己绘制节点和边，适当地连接它们，并将它们定位在页面上。这听起来可能像是很多工作，但正如我们接下来也会看到的，D3.js
    提供了许多工具来帮助我们。
- en: 'Step 1: Prepare the Data'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 1 步：准备数据
- en: Since we’re replicating the network graph from [Chapter 4](ch04.html "Chapter 4. Creating
    Specialized Graphs"), we start with the same data set.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在复制来自[第 4 章](ch04.html "第 4 章：创建专业图表")的网络图，因此我们从相同的数据集开始。
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For the visualization, it will be helpful to have two separate arrays, one
    for the graph’s nodes and one for the graph’s edges. Extracting those arrays from
    the original data is straightforward, so we won’t bother looking at it in this
    chapter. You can, however, see the full implementation in the book’s source code.
    The result looks like the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可视化，拥有两个独立的数组将会很有帮助，一个用于图的节点，一个用于图的边。从原始数据中提取这些数组非常简单，因此我们在本章中不会讨论。你可以在书籍的源代码中看到完整的实现。结果如下所示：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For the nodes, we’ve added `x` and `y` properties to define a position on the
    graph. Initially the code arbitrarily sets these values so that the nodes are
    positioned in a circle.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于节点，我们已添加 `x` 和 `y` 属性来定义图上的位置。最初，代码任意设置这些值，使得节点呈圆形分布。
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The edges indicate the two nodes that they connect as indices in the `nodes`
    array, and they include an array of the individual musicians that are common between
    the albums.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 边表示它们连接的两个节点，作为 `nodes` 数组中的索引，并且它们包含在专辑之间共有的独立音乐家的数组。
- en: 'Step 2: Set Up the Page'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 2 步：设置页面
- en: As noted in the previous example, D3.js doesn’t depend on any other libraries,
    and it’s available on most content distribution networks. All we need to do is
    include it in the page.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个例子所述，D3.js 不依赖任何其他库，并且它可以在大多数内容分发网络上使用。我们所需要做的就是将其包含在页面中。
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Just as in the previous example, we set up a container for the visualization
    by including a `<div>` with the `id "container"`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在前一个例子中一样，我们通过包含一个 `id` 为 "container" 的 `<div>` 来为可视化设置容器。
- en: 'Step 3: Create a Stage for the Visualization'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 3 步：为可视化创建舞台
- en: This step is also the same as in the previous example.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这一阶段与之前的例子相同。
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We ask D3.js to select the container element and then insert an `<svg>` element
    within it. We also define `<svg>` element’s size by setting the `height` and `width`
    attributes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求 D3.js 选择容器元素，然后在其中插入一个 `<svg>` 元素。我们还通过设置 `height` 和 `width` 属性来定义 `<svg>`
    元素的大小。
- en: 'Step 4: Draw the Graph’s Nodes'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 4 步：绘制图表的节点
- en: We’ll draw each node as a circle by appending `<circle>` elements inside the
    `<svg>` stage. Based on the previous step, you might think that would be as simple
    as executing `svg.append("circle")` for each element in the `nodes` array.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在 `<svg>` 阶段内附加 `<circle>` 元素来绘制每个节点。基于前一步，你可能会认为这就像对 `nodes` 数组中的每个元素执行
    `svg.append("circle")` 一样简单。
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That code will indeed add 25 circles to the visualization. What it *won’t* do,
    though, is create any links between the data (nodes in the array) and the document
    (circle elements on the page). D3.js has another way to add the circles to the
    page that does create that linkage. In fact, not only will D3.js create the links,
    it will even manage them for us. This support becomes especially valuable as visualizations
    grow more complex.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码确实会向可视化中添加 25 个圆形。然而，它*不会*做的是在数据（数组中的节点）和文档（页面上的圆形元素）之间建立任何链接。D3.js 有另一种方法可以向页面添加圆形，并创建这种链接。事实上，D3.js
    不仅会创建链接，它甚至会为我们管理这些链接。随着可视化变得越来越复杂，这种支持变得尤为重要。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**This feature is really the core of D3.js and, in fact, is the source for
    the name** *D3***, which is shorthand for** *data-driven documents*.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**这个特性实际上是 D3.js 的核心，事实上，它也是该名称的来源** *D3*，即** *数据驱动文档* 的缩写。'
- en: 'Here’s how we can use D3.js more effectively to add the `<circle>` elements
    to the graph:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何更有效地使用 D3.js 向图表中添加`<circle>`元素的方法：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you haven’t seen D3.js code before, that fragment surely looks very strange.
    What are we trying to do by selecting `<circle>` elements before we’ve even created
    any? Won’t the result just be empty? And if so, what’s the point of the `data()`
    function that follows? To answer those questions, we have to understand how D3.js
    differs from traditional JavaScript libraries like jQuery. In those libraries
    a selection represents elements of HTML markup. With jQuery, `$("circle")` is
    nothing more than the `<circle>` elements in the page. With D3.js, however, selections
    are more than just markup elements. D3.js selections can contain both markup *and*
    data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前没见过 D3.js 代码，这段代码肯定看起来很奇怪。我们在没有创建任何 `<circle>` 元素之前选择它们到底是想做什么呢？结果不就是空的吗？如果是这样，那紧随其后的
    `data()` 函数又有什么意义呢？为了回答这些问题，我们必须理解 D3.js 如何与传统的 JavaScript 库（如 jQuery）不同。在那些库中，选择代表的是
    HTML 标记元素。而在 jQuery 中，`$("circle")` 仅仅是页面上的 `<circle>` 元素。然而，在 D3.js 中，选择不仅仅是标记元素。D3.js
    选择可以同时包含标记*和*数据。
- en: D3.js puts markup elements and data objects together with the `data()` function.
    The object on which it operates (`svg.selectAll("circle")` in the preceding code)
    supplies the elements, and its parameter (`nodes`, in this case) provides the
    data. The first statement in the fragment, therefore, tells D3.js that we want
    to match `<circle>` elements with nodes in our graph. We are, in effect, saying
    that we want one `<circle>` to represent each value in the `nodes` array.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js 使用 `data()` 函数将标记元素和数据对象结合在一起。它操作的对象（在前面的代码中是 `svg.selectAll("circle")`）提供了元素，而它的参数（在本例中是
    `nodes`）提供了数据。因此，这段代码的第一条语句告诉 D3.js 我们希望将 `<circle>` 元素与图中的节点匹配。实际上，我们是在说，希望每个
    `<circle>` 都代表 `nodes` 数组中的一个值。
- en: The result is easiest to understand when there are exactly as many elements
    as there are data values. [Figure 7-4](ch07.html#d3dotjs_selections_can_associate_page_co
    "Figure 7-4. D3.js selections can associate page content such as <circle> elements
    with data items such as albums.") shows four `<circle>` elements and four albums.
    D3.js dutifully combines the two sets, giving us a selection of four objects.
    Each object has both a `<circle>` and an album.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当元素的数量与数据值的数量恰好相等时，结果最容易理解。[图 7-4](ch07.html#d3dotjs_selections_can_associate_page_co
    "图 7-4. D3.js 选择可以将页面内容（如 `<circle>` 元素）与数据项（如专辑）关联。") 显示了四个 `<circle>` 元素和四个专辑。D3.js
    认真地将这两组数据结合在一起，给我们选择了四个对象。每个对象既包含一个 `<circle>` 元素，也包含一个专辑。
- en: '![D3.js selections can associate page content such as <circle> elements with
    data items such as albums.](figs/web/07fig04.png.jpg)Figure 7-4. D3.js selections
    can associate page content such as `<circle>` elements with data items such as
    albums.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![D3.js 选择可以将页面内容（如 `<circle>` 元素）与数据项（如专辑）关联。](figs/web/07fig04.png.jpg)图
    7-4. D3.js 选择可以将页面内容（如 `<circle>` 元素）与数据项（如专辑）关联。'
- en: In general, though, we can’t guarantee that there will be exactly as many elements
    as data values. Suppose, for example, only two `<circle>` elements existed for
    our four albums. As [Figure 7-5](ch07.html#d3dotjs_selections_keep_track_of_page_co
    "Figure 7-5. D3.js selections keep track of page content that doesn’t exist (yet).")
    shows, D3.js still creates a selection of four objects, even though there aren’t
    enough circles for all of them. Two of the objects will have a data value but
    no element.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们无法保证元素的数量与数据值完全相等。例如，假设只有两个`<circle>`元素对应我们的四个专辑。如[图 7-5](ch07.html#d3dotjs_selections_keep_track_of_page_co
    "图 7-5. D3.js 选择保持页面内容的跟踪，尽管该内容（尚未）存在。")所示，D3.js 仍然会创建四个对象的选择，尽管并没有足够的圆形元素与所有对象匹配。两个对象会有数据值，但没有对应的元素。
- en: '![D3.js selections keep track of page content that doesn’t exist (yet).](figs/web/07fig05.png.jpg)Figure 7-5. D3.js
    selections keep track of page content that doesn’t exist (yet).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![D3.js 选择保持页面内容的跟踪，尽管该内容（尚未）存在。](figs/web/07fig05.png.jpg)图 7-5. D3.js 选择保持页面内容的跟踪，尽管该内容（尚未）存在。'
- en: Our code fragment is an even more extreme example. When it executes, there are
    absolutely no circles on the page. There are, however, values in the `nodes` array
    that we’re telling D3.js to use as data. D3.js, therefore, creates an object for
    each of those data values. It just won’t have a `<circle>` element to go with
    them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码片段是一个更极端的例子。当它执行时，页面上根本没有圆形元素。然而，`nodes`数组中有一些值，我们告诉 D3.js 将其作为数据使用。因此，D3.js
    会为每个数据值创建一个对象。只是，它不会为这些数据值创建一个`<circle>`元素。
- en: (Take a breath because magic is about to happen.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: （深呼吸，因为魔法即将发生。）
- en: Now we can look at the second statement in our code fragment. It starts with
    `selection.enter()`. The `enter()` function is a special D3.js function. It tells
    D3.js to search through the selection and find all of the objects that have a
    data value *but no markup element.* We then complete the statement by taking that
    subset of the selection and calling `append("circle")`. And with that function
    call, D3.js will take any object in the selection without a markup element and
    create a circle for it. That’s how we add `<circle>` elements to the graph.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看看代码片段中的第二个语句。它以`selection.enter()`开头。`enter()`函数是一个特殊的 D3.js 函数。它告诉 D3.js
    在选择中查找所有有数据值*但没有标记元素*的对象。然后我们通过调用`append("circle")`来完成语句。通过这个函数调用，D3.js 会为选择中没有标记元素的任何对象创建一个圆形。这就是我们如何将`<circle>`元素添加到图形中的方式。
- en: To be a little more concise, we can combine our two statements into a single
    one.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁一点，我们可以将这两条语句合并成一句。
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The effect for our visualization is to create a `<circle>` within the `<svg>`
    container for every node in the graph.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的可视化效果是：为图形中的每个节点在 `<svg>` 容器内创建一个 `<circle>` 元素。
- en: 'Step 5: Draw the Graph’s Edges'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 5：绘制图形的边
- en: You won’t be surprised to find that adding the edges to the graph works just
    like adding nodes. We simply append `<line>` elements instead of circles.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该不会感到惊讶，添加边缘到图形的工作方式与添加节点类似。我们只需要追加`<line>`元素，而不是圆形。
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Even though we won’t need to use them for this example, D3.js has other functions
    that complement the `enter()` function. To find objects that have a markup element
    but no data value, you can use the function `exit()`. And to find objects that
    have a markup element with a data value that has changed, you can use the function
    `update()`. The names *enter* and *exit* derive from a theater metaphor that D3.js
    associates with a visualization. The `enter()` subset represents those elements
    that are entering the stage, while the `exit()` subset represents elements exiting
    the stage.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个例子中我们不需要使用它们，D3.js 还有一些与 `enter()` 函数互补的其他函数。要查找那些有标记元素但没有数据值的对象，可以使用 `exit()`
    函数。而要查找那些有标记元素并且数据值已改变的对象，可以使用 `update()` 函数。`enter` 和 `exit` 的命名源自 D3.js 所关联的视觉化戏剧隐喻。`enter()`
    子集代表那些进入舞台的元素，而 `exit()` 子集代表退出舞台的元素。
- en: Because we’re using SVG elements for both the nodes and the edges, we can use
    CSS rules to style them. That’s especially important for the edges because, by
    default, SVG lines have a stroke width of `0`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用 SVG 元素来表示节点和边，所以可以使用 CSS 规则来样式化它们。这对边特别重要，因为默认情况下，SVG 线条的描边宽度是`0`。
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Step 6: Position the Elements'
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 6：定位元素
- en: At this point, we’ve added the necessary markup elements to our visualization,
    but we haven’t given them any dimensions or positions. As noted before, D3.js
    doesn’t do any drawing, so we’ll have to write the code to do it. And as noted
    in Step 2, we did assign somewhat arbitrary positions to the nodes by arranging
    them in a circle. For now, we can use that to position them.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经为可视化添加了必要的标记元素，但尚未为它们指定任何尺寸或位置。正如之前所述，D3.js 不进行任何绘制工作，因此我们需要编写代码来完成这一任务。正如步骤
    2 中所提到的，我们确实通过将节点排列成圆形为它们分配了某些任意位置。现在，我们可以使用这个圆形来定位它们。
- en: 'To position an SVG circle, we set its `cx` and `cy` attributes to correspond
    to the circle’s center. We also specify the circle’s radius with the `r` attribute.
    Let’s start with the radius; we’ll set it to a fixed value for all nodes. We’ve
    already created a D3.js selection for all of those nodes. Setting their `r` attributes
    is a simple statement:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要定位 SVG 圆形，我们将其 `cx` 和 `cy` 属性设置为圆心的位置。我们还通过 `r` 属性指定圆的半径。让我们从半径开始；我们将其设置为所有节点的固定值。我们已经为所有这些节点创建了
    D3.js 的选择。设置它们的 `r` 属性是一个简单的语句：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `cx` and `cy` values are a little trickier because they’re not the same
    for all of the nodes. Those values depend on properties of the data associated
    with the nodes. More specifically, each element in the `nodes` array has `x` and
    `y` properties. D3.js, however, makes it very easy to access those properties.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`cx` 和 `cy` 值稍微复杂一些，因为它们对所有节点并不相同。这些值取决于与节点相关的数据属性。更具体地说，`nodes` 数组中的每个元素都有
    `x` 和 `y` 属性。不过，D3.js 使得访问这些属性变得非常容易。'
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Instead of providing constant values for the attributes, we provide functions.
    D3.js will then call those functions and pass the data values as parameters. Our
    functions will return the appropriate value for the attribute.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有为属性提供常量值，而是提供了函数。D3.js 会调用这些函数并将数据值作为参数传递给它们。我们的函数将返回适当的属性值。
- en: Positioning the edges relies on a similar strategy. We want to set the endpoints
    of the lines to the centers of the corresponding nodes. Those endpoints are the
    `x1,y1` and `x2,y2` attributes of the `<line>` elements. Here’s the code to set
    those attributes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 边的定位采用了类似的策略。我们希望将线条的端点设置为相应节点的中心。这些端点是 `<line>` 元素的 `x1,y1` 和 `x2,y2` 属性。以下是设置这些属性的代码：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As is conventional with D3.js, the parameter `d` is the data value.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 按照 D3.js 的惯例，参数 `d` 是数据值。
- en: With the elements finally drawn and positioned, we have the first version of
    our visualization with [Figure 7-6](ch07.html#d3dotjs_provides_tools_to_help_draw_the
    "Figure 7-6. D3.js provides tools to help draw the circles and lines for a network
    graph.").
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 随着元素终于被绘制并定位，我们得到了可视化的第一版，见[图 7-6](ch07.html#d3dotjs_provides_tools_to_help_draw_the
    "图 7-6. D3.js 提供工具帮助绘制网络图的圆圈和线条。")。
- en: '![D3.js provides tools to help draw the circles and lines for a network graph.](figs/web/07fig06.png.jpg)Figure 7-6. D3.js
    provides tools to help draw the circles and lines for a network graph.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![D3.js 提供工具帮助绘制网络图的圆圈和线条。](figs/web/07fig06.png.jpg)图 7-6. D3.js 提供工具帮助绘制网络图的圆圈和线条。'
- en: 'Step 7: Add Force Direction to the Graph'
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 7：为图形添加力导向
- en: The graph has all the essential components, but its layout doesn’t make identifying
    the connections as easy as we’d like. In [Chapter 4](ch04.html "Chapter 4. Creating
    Specialized Graphs") the Sigma library could automate the layout with only a couple
    of lines of JavaScript. To perform that automation, Sigma uses a force-direction
    algorithm. Force direction treats nodes as physical objects and simulates the
    effect of forces such as gravity and electromagnetism.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图形已经具备了所有基本组件，但其布局并不像我们希望的那样便于识别连接关系。在[第 4 章](ch04.html "第 4 章：创建专门的图形")中，Sigma
    库可以通过仅仅几行 JavaScript 代码自动完成布局。为了实现这一自动化，Sigma 使用了一个力导向算法。力导向将节点视为物理对象，并模拟如重力和电磁力等力的作用。
- en: With D3.js we cannot rely on the library to fully automate the layout. As we’ve
    seen, D3.js does not draw any of the graph elements, so it cannot, by itself,
    set positions and dimensions. D3.js does, however, provide a lot of tools to help
    us create our own graph layouts. One of those tools is the *force layout tool.*
    As you might expect, the force layout tool helps us draw our own force-directed
    graph. It handles all of the messy and complex calculations that underlie force
    direction and gives us results we can use directly in code that draws the graph.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 D3.js 时，我们不能依赖库来完全自动化布局。正如我们所看到的，D3.js 并不会绘制任何图形元素，因此它不能单独设置位置和尺寸。然而，D3.js
    提供了许多工具，帮助我们创建自己的图形布局。其中一个工具就是*力导向布局工具*。正如你所料，力导向布局工具帮助我们绘制自己的力导向图。它处理了力方向背后的所有复杂计算，并给我们提供了可以直接在绘制图形的代码中使用的结果。
- en: 'To get started with the layout, we define a new `force` object. That object
    accepts many configuration parameters, but only five are essential for our visualization:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始布局，我们定义一个新的`force`对象。该对象接受许多配置参数，但只有五个对我们的可视化至关重要：
- en: The dimensions of the graph
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形的尺寸
- en: The nodes in the graph
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图中的节点
- en: The edges in the graph
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图中的边
- en: The distance we’d like to see between connected nodes
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望看到的连接节点之间的距离
- en: How strongly nodes repel each other, a parameter D3.js calls *charge*
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点相互排斥的强度，这是 D3.js 所称的*电荷*参数
- en: 'The last parameter can take a bit of trial and error to optimize for any particular
    visualization. In our case, we’ll want to increase it substantially above its
    default (`-30`) because we have a lot of nodes in a small space. (Negative charge
    values indicate repulsion.) Here’s the code to set all of those values:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的参数可能需要一些反复试验，以优化特定的可视化效果。在我们的例子中，我们希望将其大幅提高，超过默认值（`-30`），因为我们有很多节点且空间很小。（负电荷值表示排斥力。）以下是设置所有这些值的代码：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When we tell D3.js to start its force-direction calculations, it will generate
    events at intermediate steps and when the calculations complete. Force direction
    often takes several seconds to execute fully, and if we wait until the calculations
    are complete before we draw the graph, users may think the browser has frozen.
    It’s usually better to update the graph at each iteration so users see some indication
    of progress. To do that, we can add a function to respond to the intermediate
    force-direction calculations. That happens on a D3.js `tick` event.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们告诉 D3.js 开始其力的方向计算时，它将在中间步骤和计算完成时生成事件。力的方向通常需要几秒钟才能完全执行，如果我们等到计算完成再绘制图形，用户可能会认为浏览器已经冻结。通常，最好在每次迭代时更新图形，让用户看到进度的某些提示。为此，我们可以添加一个函数来响应中间的力方向计算。这发生在
    D3.js 的`tick`事件上。
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Each time D3.js calls our event handler function, it will have updated the `x`
    and `y` properties of the `nodes` array. The new values will reflect how the force
    direction has nudged the nodes on the graph’s stage. We can update our graph accordingly
    by changing the SVG attributes of the circles and lines. Before we do that, however,
    we can take advantage of the fact that D3.js is giving us an opportunity to tweak
    the force-direction algorithm as it executes. One problem that we may encounter,
    especially with the large charge force we defined, is that nodes may repel each
    other so strongly that some tend to drift off the stage entirely. We can prevent
    that by ensuring that the node positions remain within the dimensions of the graph.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 每次 D3.js 调用我们的事件处理函数时，它都会更新`nodes`数组中的`x`和`y`属性。新值将反映力的方向如何推动节点在图形舞台上的位置。我们可以通过更改圆圈和线条的
    SVG 属性来相应地更新我们的图形。然而，在此之前，我们可以利用 D3.js 提供的机会，在执行过程中调整力的方向算法。我们可能遇到的一个问题，尤其是当我们定义了较大的电荷力时，节点可能会相互排斥，导致某些节点完全漂移出舞台。我们可以通过确保节点的位置保持在图形的尺寸范围内来避免这种情况。
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We’ve added or subtracted `5` in the preceding fragment to account for the radius
    of the nodes’ circles.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的代码片段中加上或减去了`5`，以考虑节点圆圈的半径。
- en: Once we’ve adjusted the nodes’ properties to keep them on the stage, we can
    update their positions. The code is exactly the same as the code we used to position
    them initially.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们调整了节点的属性，以确保它们留在舞台上，我们就可以更新它们的位置。代码与我们最初定位它们时使用的代码完全相同。
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We’ll also want to adjust the endpoints of our edge lines. For these objects,
    however, there’s a small twist. When we initialized the `edges` array, we set
    the `source` and `target` properties to the indices of the respective nodes in
    the `nodes` array. When the D3.js force layout tool begins execution, it replaces
    those indices with direct references to the nodes themselves. That makes it a
    little easier for us to find the appropriate coordinates for the lines.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要调整边线的端点。然而，对于这些对象，有一个小的变化。当我们初始化 `edges` 数组时，我们将 `source` 和 `target` 属性设置为相应节点在
    `nodes` 数组中的索引。当 D3.js 力导向布局工具开始执行时，它会将这些索引替换为对节点本身的直接引用。这使得我们更容易找到适当的坐标来绘制这些边线。
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With our function ready to handle updates from the force-direction calculations,
    we can tell D3.js to start its work. That’s a simple method of the `force` object.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的函数准备好处理来自力导向计算的更新时，我们可以告诉 D3.js 开始工作。这是 `force` 对象的一个简单方法。
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With that statement, the graph begins an animated transition to its final, force-directed
    state, as [Figure 7-7](ch07.html#d3dotjs_force_layout_tool_provides_the_i "Figure 7-7. The
    D3.js force layout tool provides the information to reposition network graph elements.")
    shows.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这行代码，图形开始执行动画过渡到最终的力导向状态，如[图 7-7](ch07.html#d3dotjs_force_layout_tool_provides_the_i
    "图 7-7. D3.js 力导向布局工具提供了重新定位网络图元素的信息。")所示。
- en: '![The D3.js force layout tool provides the information to reposition network
    graph elements.](figs/web/07fig07.png.jpg)Figure 7-7. The D3.js force layout tool
    provides the information to reposition network graph elements.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![D3.js 力导向布局工具提供了重新定位网络图元素的信息。](figs/web/07fig07.png.jpg)图 7-7. D3.js 力导向布局工具提供了重新定位网络图元素的信息。'
- en: 'Step 8: Add Interactivity'
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 8 步：添加交互性
- en: Since D3.js is a JavaScript library, you would expect it to support interactions
    with the user. It does, and to demonstrate, we can add a simple interaction to
    the graph. When a user clicks on one of the nodes in the graph, we can emphasize
    that node and its neighbors.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 D3.js 是一个 JavaScript 库，你可以期望它支持与用户的交互。它确实支持，为了演示这一点，我们可以向图形添加一个简单的交互功能。当用户点击图形中的一个节点时，我们可以突出显示该节点及其邻居。
- en: Event handlers in D3.js closely resemble those in other JavaScript libraries
    such as jQuery. We define an event handler using the `on()` method of a selection,
    as in the following code.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: D3.js 中的事件处理程序与其他 JavaScript 库（如 jQuery）中的事件处理程序非常相似。我们通过选择集的`on()`方法定义事件处理程序，如以下代码所示。
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first parameter to `on()` is the event type, and the second parameter is
    a function that D3.js will call when the event occurs. The parameter to this function
    is the data object that corresponds to the selection element, and by convention
    it’s named `d`. Because we’re adding the event to the selection of nodes (`nodeSelection`),
    `d` will be one of the graph nodes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`on()`的第一个参数是事件类型，第二个参数是 D3.js 在事件发生时调用的函数。该函数的参数是与选择集元素对应的数据对象，通常命名为`d`。因为我们将事件添加到节点的选择集（`nodeSelection`），所以`d`将是图中的一个节点。'
- en: 'For our visualization, we’ll emphasize the clicked node by adding a CSS-accessible
    class to the corresponding `<circle>` and by increasing the circle’s size. The
    class makes it possible to style the circle uniquely, but a circle’s size cannot
    be specified with CSS rules. Ultimately, therefore, we have to do two things to
    the circle: add the `selected` class and increase the radius using the `r` attribute.
    Of course, in order to do either, we have to select the `<circle>` element. When
    D3.js calls an event handler, it sets `this` equal to the target of the event;
    we can turn that target into a selection with `d3.select(this)`. The following
    code, therefore, is all it takes to change the clicked node’s circle.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的可视化效果，我们通过为对应的 `<circle>` 元素添加一个 CSS 可访问类并增大圆的大小来强调被点击的节点。这个类使得我们可以对圆形进行独特的样式设置，但圆形的大小不能通过
    CSS 规则来指定。因此，我们最终需要对圆形做两件事：添加 `selected` 类并使用 `r` 属性增加半径。当然，为了做到这两点，我们需要选择 `<circle>`
    元素。当 D3.js 调用事件处理程序时，它会将 `this` 设置为事件的目标；我们可以通过 `d3.select(this)` 将该目标转换为选择集。因此，以下代码就是改变被点击节点的圆形所需要的全部代码。
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We can do something similar by adding a `selected` class to all the edges that
    connect to the clicked node. To find those edges we can iterate through the full
    edge selection. D3.js provides the `each()` function to do just that.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过向所有与点击节点连接的边添加一个 `selected` 类来做类似的事情。为了找到这些边，我们可以遍历整个边选择集。D3.js 提供了 `each()`
    函数来完成这项工作。
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As we look at each edge, we check the `source` and `target` properties to see
    if either matches our clicked node. When we find a match, we add the `selected`
    class to the edge. Note that at ➊ we’re once again using `d3.select(this)`. In
    this example the code is inside the `each()` function, so `this` will equal the
    particular element of the current iteration. In our case that’s the `<line>` for
    the edge.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看每个边时，我们检查`source`和`target`属性，以查看它们是否与我们点击的节点匹配。当我们找到匹配项时，我们将`selected`类添加到该边。请注意，在➊处我们再次使用`d3.select(this)`。在这个例子中，代码位于`each()`函数内部，因此`this`将等于当前迭代的特定元素。在我们的例子中，就是边的`<line>`元素。
- en: The preceding code handles setting the `selected` class, but we still need to
    remove it when appropriate. We can remove it from all the other circles (and make
    sure their radii are restored to their default values) by operating on the node
    selection.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码处理了设置`selected`类的问题，但我们仍然需要在适当的时候将其移除。我们可以通过操作节点选择来从所有其他圆圈中移除它（并确保它们的半径恢复到默认值）。
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The code looks the same as we’ve seen before, except that at ➊ we use the D3.js
    `filter()` function to limit the selection to the nodes other than the one that
    was clicked.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们之前见过的相同，唯一不同的是在➊处我们使用D3.js的`filter()`函数，将选择范围限制为除了被点击的节点之外的其他节点。
- en: 'A similar process resets the `selected` class on all the edges. We can remove
    the class from all edges first, before we add to the appropriate edges in the
    previous code fragment. Here’s the code that removes it; with D3.js it takes only
    a single line:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的过程会重置所有边的`selected`类。我们可以先从所有边中移除该类，再在前面的代码片段中添加到适当的边上。下面是移除它的代码；在D3.js中，只需要一行代码：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And finally, if the user clicks on a node that’s already selected, we can restore
    it to its default state like so:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果用户点击的是已经选中的节点，我们可以像这样将其恢复到默认状态：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When you put all of the preceding code fragments together, you have the complete
    event handler shown here:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将所有前面的代码片段组合在一起时，你将得到完整的事件处理程序，如下所示：
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Along with a bit of CSS styling to emphasize the selected circles and lines,
    this code results in the interactive visualization of [Figure 7-8](ch07.html#d3dotjs_includes_functions_to_make_visua
    "Figure 7-8. D3.js includes functions to make visualizations interactive.").
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 结合一些CSS样式，用于突出显示选中的圆圈和线条，这段代码生成了交互式可视化，如[图7-8](ch07.html#d3dotjs_includes_functions_to_make_visua
    "图7-8。D3.js包含使可视化具有交互功能的函数。")所示。
- en: '![D3.js includes functions to make visualizations interactive.](figs/web/07fig08.png.jpg)Figure 7-8. D3.js
    includes functions to make visualizations interactive.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![D3.js包含使可视化具有交互功能的函数。](figs/web/07fig08.png.jpg)图7-8。D3.js包含使可视化具有交互功能的函数。'
- en: 'Step 9: Experiment with Other Enhancements'
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第9步：尝试其他增强功能
- en: Our example has explored many of the features that D3.js provides for custom
    visualizations. The code so far, however, has only scratched the surface of D3’s
    capabilities. We haven’t added labels to our graph or animated the transitions
    in the graph’s state. In fact, it’s a pretty safe bet that if there is anything
    we want to add to the visualization, D3.js has tools to help. And although we
    don’t have the time or space to consider other enhancements here, the source code
    for the book does include a more full-featured implementation that takes advantage
    of other D3.js capabilities.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例已经探索了D3.js提供的许多自定义可视化功能。然而，到目前为止，代码只触及了D3功能的表面。我们还没有为图形添加标签，或者使图形状态的过渡动画化。实际上，如果我们想为可视化添加任何功能，D3.js几乎总能提供相关工具。尽管我们在这里没有时间或空间讨论其他增强功能，但本书的源代码包含一个功能更全面的实现，利用了其他D3.js的功能。
- en: Creating a Scalable Map
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个可缩放的地图
- en: The first two examples touched on some of the capabilities of D3.js, but the
    library includes many others. From the examples in [Chapter 6](ch06.html "Chapter 6. Visualizing
    Geographic Data"), we know some of the best visualizations rely on maps, and D3.js—as
    a general-purpose visualization library—has extensive support for mapping. To
    illustrate that support, we’ll create a map that shows tornado sightings in the
    continental United States.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个示例介绍了D3.js的一些功能，但该库还包含许多其他功能。从[第6章](ch06.html "第6章。可视化地理数据")的示例中，我们知道一些最好的可视化依赖于地图，而D3.js作为一个通用可视化库，对地图有广泛的支持。为了说明这一点，我们将创建一个显示美国本土龙卷风观察的地图。
- en: 'Step 1: Prepare the Data'
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步：准备数据
- en: The US National Oceanic and Atmospheric Administration (*[http://www.noaa.gov/](http://www.noaa.gov/)*)
    publishes an extensive set of weather and climate data on its Climate Data Online
    site (*[http://www.ncdc.noaa.gov/cdo-web/](http://www.ncdc.noaa.gov/cdo-web/)*).
    That data includes all storm events reported in the United States and its territories.
    We can download the data set for the year 2013 as a comma-separated value (CSV)
    file. Because the file is extremely large and contains many events that aren’t
    tornadoes, we can edit it to remove the extraneous information using a spreadsheet
    application such as Microsoft Excel or Numbers for Mac. For this visualization,
    we need only records that have an `event_type` equal to `"Tornado"`, and we want
    only the columns for the tornado’s latitude, longitude, and Enhanced Fujita Scale
    classification (a measure of tornado strength). Once we’ve pruned the CSV file
    appropriately, it will look something like the following data.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 美国国家海洋和大气管理局（* [http://www.noaa.gov/](http://www.noaa.gov/) *）在其气候数据在线网站（* [http://www.ncdc.noaa.gov/cdo-web/](http://www.ncdc.noaa.gov/cdo-web/)
    *）上发布了大量的天气和气候数据。该数据包括美国及其领土内所有报告的风暴事件。我们可以下载2013年年度的数据集，格式为逗号分隔值（CSV）文件。由于该文件非常大，并且包含许多不是龙卷风的事件，我们可以使用电子表格应用程序，如
    Microsoft Excel 或 Mac 的 Numbers，编辑文件以删除多余的信息。对于这个可视化，我们只需要 `event_type` 为 `"Tornado"`
    的记录，并且只需要包含龙卷风的纬度、经度和增强富吉塔等级（龙卷风强度的衡量标准）这几列数据。一旦我们适当地修剪了 CSV 文件，它将看起来像下面这样的数据。
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Since we’re going to access this data using JavaScript, you might be tempted
    to convert the file from CSV to JSON format. It’s better, however, to keep the
    data in a CSV file. D3.js has full support for CSV, so we don’t really gain anything
    by converting to JSON. More importantly, the JSON file would be more than four
    times larger than the CSV version, and that extra size would slow down the loading
    of our web page.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用 JavaScript 访问这些数据，你可能会想将文件从 CSV 格式转换为 JSON 格式。然而，最好还是将数据保留在 CSV 文件中。D3.js
    完全支持 CSV 格式，因此将其转换为 JSON 并不会带来实际的好处。更重要的是，JSON 文件的大小将是 CSV 版本的四倍以上，这额外的大小会导致我们网页加载变慢。
- en: 'Step 2: Set Up the Page'
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 2：设置页面
- en: Our skeletal web page is no different from the other D3.js examples. We set
    aside a container for the map and include the D3.js library.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的骨架网页与其他 D3.js 示例没有什么不同。我们为地图留出了一个容器，并包含了 D3.js 库。
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Step 3: Create a Map Projection'
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 3：创建地图投影
- en: If you can’t quite recall your geography lessons about map projections, don’t
    worry; D3.js can handle all of the heavy lifting. Not only does it have extensive
    support for common projections, but it also supports extensions for custom projections
    tailored specifically for visualizations. For example, there’s a modified Albers
    projection that’s optimized for choropleth maps of the United States. It repositions
    (and resizes) Alaska and Hawaii to provide a convenient map of all 50 states.
    In our case, since there were no tornado sightings in Alaska or Hawaii in 2013,
    we can use a standard Albers projection.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有些记不起关于地图投影的地理课内容，不用担心；D3.js 可以处理所有繁重的工作。它不仅对常见的投影提供广泛的支持，而且还支持为可视化量身定制的自定义投影扩展。例如，有一种经过修改的
    Albers 投影，经过优化后适用于美国的分层地图。它重新定位（并调整大小）了阿拉斯加和夏威夷，以提供一个方便的涵盖所有50个州的地图。在我们的例子中，由于2013年阿拉斯加和夏威夷没有龙卷风出现，因此我们可以使用标准的
    Albers 投影。
- en: We set up the projection in the following code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以下代码中设置了投影。
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, at ➊ and ➋, we define the size of our map in pixels. Then, at ➌, we create
    the Albers projection. D3.js supports many adjustments to position the projection
    appropriately on the page, but the default values are fine in our case. We need
    only to scale the map at ➍ and center it at ➎.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 ➊ 和 ➋，我们定义了地图的像素大小。然后，在 ➌，我们创建了 Albers 投影。D3.js 支持许多调整方式来将投影适当定位到页面上，但在我们的情况下，默认值就足够了。我们只需要在
    ➍ 缩放地图，并在 ➎ 居中它。
- en: To draw the map on the page, we’re going to use SVG `<path>` elements, but our
    map data takes the form of latitude and longitude values. D3.js has a `path` object
    to translate geographic coordinates to SVG paths based on a particular map projection.
    At ➏ and ➐, we create our `path` object.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在页面上绘制地图，我们将使用 SVG `<path>` 元素，但我们的地图数据是以经纬度值的形式呈现的。D3.js 有一个 `path` 对象，可以根据特定的地图投影将地理坐标转换为
    SVG 路径。在 ➏ 和 ➐，我们创建了我们的 `path` 对象。
- en: 'Step 4: Initialize the SVG Container'
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤 4：初始化 SVG 容器
- en: We can create an SVG container to hold the map, just as we did in the previous
    D3.js example.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个 SVG 容器来容纳地图，就像我们在之前的 D3.js 示例中做的那样。
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As we’ll see in later steps, it will be helpful have an inner group in which
    to place the map. This inner group (defined by a `<g>` element) acts much like
    an arbitrary `<div>` element in HTML. We create that inner group at ➊.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们将在后续步骤中看到的，拥有一个内嵌组将对放置地图非常有帮助。这个内嵌组（由 `<g>` 元素定义）就像 HTML 中的一个任意 `<div>` 元素。我们在
    ➊ 创建这个内嵌组。
- en: 'Step 5: Retrieve the Map Data'
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 5 步：获取地图数据
- en: For our visualization, the map data is nothing but a map of the United States
    with individual states. D3.js uses GeoJSON (*[http://geojson.org/](http://geojson.org/)*)
    for its map data. Unlike most of the image tiles that we used in [Chapter 6](ch06.html
    "Chapter 6. Visualizing Geographic Data"), GeoJSON data is vector based, so it
    can be used at any scale. GeoJSON data is also in JSON format, which makes it
    especially compatible with JavaScript.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的可视化，地图数据就是包含各州的美国地图。D3.js 使用 GeoJSON (*[http://geojson.org/](http://geojson.org/)*)
    作为地图数据。与我们在[第 6 章](ch06.html "第 6 章. 可视化地理数据")中使用的大多数图像切片不同，GeoJSON 数据是基于矢量的，因此可以在任何比例下使用。GeoJSON
    数据也是 JSON 格式，这使得它与 JavaScript 特别兼容。
- en: Since our data is in a JSON format, we can use the `d3.json()` function to retrieve
    it. This function is almost identical to the jQuery `$.getJSON()` function.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的数据是 JSON 格式，我们可以使用 `d3.json()` 函数来获取数据。这个函数几乎与 jQuery 的 `$.getJSON()` 函数相同。
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Step 6: Draw the Map'
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 6 步：绘制地图
- en: Once we have our data, we can draw the map on the page. The code in this step
    is very similar to that in the previous example. Each state will be a `<path>`
    element within the `<g>` container.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了数据，就可以在页面上绘制地图。此步骤中的代码与前一个示例中的非常相似。每个州将是 `<g>` 容器内的一个 `<path>` 元素。
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Using D3.js conventions, we create a selection of `<path>` elements at ➊ and
    bind those elements to our data at ➋. When there is no element, we create one
    ➌ and we set its `d` attribute to be the path associated with the data, given
    our projection. Note that `path` at ➍ is the object we created in Step 4\. It
    is a function that translates the latitude and longitude information into appropriate
    SVG coordinates.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 D3.js 的约定，我们在 ➊ 创建 `<path>` 元素的选择，并在 ➋ 将这些元素绑定到我们的数据上。当没有元素时，我们在 ➌ 创建一个，并将其
    `d` 属性设置为与数据相关的路径，根据我们的投影。注意，图 ➍ 中的 `path` 是我们在第 4 步创建的对象。它是一个函数，用于将纬度和经度信息转换为适当的
    SVG 坐标。
- en: As we can see from [Figure 7-9](ch07.html#d3dotjs_helps_create_vector_maps_from_ge
    "Figure 7-9. D3.js helps create vector maps from geographic JSON data."), D3.js
    gives us the paths required to create a nice SVG map.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[图 7-9](ch07.html#d3dotjs_helps_create_vector_maps_from_ge "图 7-9. D3.js
    帮助从地理 JSON 数据创建矢量地图")中看到的，D3.js 为我们提供了创建漂亮 SVG 地图所需的路径。
- en: '![D3.js helps create vector maps from geographic JSON data.](figs/web/07fig09.png.jpg)Figure 7-9. D3.js
    helps create vector maps from geographic JSON data.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '![D3.js 帮助从地理 JSON 数据创建矢量地图。](figs/web/07fig09.png.jpg)图 7-9. D3.js 帮助从地理 JSON
    数据创建矢量地图。'
- en: 'Step 7: Retrieve the Weather Data'
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 7 步：获取天气数据
- en: Now our map is ready for some data. We can retrieve the CSV file using another
    D3.js utility. Note, though, that all of the properties of a CSV file are considered
    text strings. We’ll want to convert those strings to numbers. We also want to
    filter out the few tornado sightings that don’t include latitude and longitude
    information.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的地图已准备好接受一些数据。我们可以使用另一个 D3.js 工具来获取 CSV 文件。不过，请注意，CSV 文件的所有属性都被视为文本字符串。我们将需要将这些字符串转换为数字。我们还想过滤掉那些没有包含纬度和经度信息的少数龙卷风目击数据。
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Once the browser has retrieved the CSV file from the server, we can begin processing
    it at ➊. Here we’re using the `.filter()` method of arrays to iterate through
    the data values. The `.filter()` method eliminates the data points without latitude
    and longitude values. It only returns `true` at ➑ if both values are present ➋.
    While we’re checking the data points for latitude and longitude, we convert the
    string values into numbers at ➌ and ➍, extract the number from the Enhanced Fujita
    Scale classification at ➎, and calculate the position of the sighting in SVG coordinates
    at ➏ and ➐ using the projection function we created in Step 3.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦浏览器从服务器检索到 CSV 文件，我们可以在 ➊ 开始处理它。在这里，我们使用数组的 `.filter()` 方法来遍历数据值。`.filter()`
    方法会去除没有纬度和经度值的数据点。只有在 ➑ 两个值都存在时，它才返回 `true` ➋。当我们检查数据点的纬度和经度时，我们会在 ➌ 和 ➍ 将字符串值转换为数字，在
    ➎ 提取增强富吉塔等级分类中的数字，并使用我们在第 3 步创建的投影函数，在 ➏ 和 ➐ 计算目击位置的 SVG 坐标。
- en: 'Step 8: Plot the Data'
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 8 步：绘制数据
- en: With the data retrieved, cleaned, and converted, it’s a simple matter to plot
    the points on the map. Once again we’ll use the traditional D3.js approach.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 数据获取、清洗和转换完成后，绘制地图上的点变得非常简单。我们再次将使用传统的D3.js方法。
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Each data point is an SVG `<circle>` element, so we select those elements, bind
    the data to the selection, and use the `.enter()` function to create new `<circle>`
    elements to match the data.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据点是一个SVG的`<circle>`元素，因此我们选择这些元素，将数据绑定到选择集，并使用`.enter()`函数创建新的`<circle>`元素，以匹配数据。
- en: As you can see, we set the position of the circles using the `position` property
    we created in the previous step. Also, to indicate the relative strength of each
    tornado, we make the size of the circle proportional to the Enhanced Fujita Scale
    classification at ➊. The result in [Figure 7-10](ch07.html#adding_points_to_a_map_is_easy_with_d3do
    "Figure 7-10. Adding points to a map is easy with D3.js projections.") is a nice
    map of 2013 tornado sightings in the continental United States.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们使用前一步中创建的`position`属性来设置圆圈的位置。此外，为了表示每个龙卷风的相对强度，我们使圆圈的大小与增强福吉塔等级（➊）的分类成正比。结果如[图7-10](ch07.html#adding_points_to_a_map_is_easy_with_d3do
    "图7-10. 使用D3.js投影将点添加到地图上很容易。")所示，是2013年美国本土龙卷风目击情况的一个精美地图。
- en: '![Adding points to a map is easy with D3.js projections.](figs/web/07fig10.png.jpg)Figure 7-10. Adding
    points to a map is easy with D3.js projections.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用D3.js投影将点添加到地图上很容易。](figs/web/07fig10.png.jpg)图7-10. 使用D3.js投影将点添加到地图上很容易。'
- en: 'Step 9: Add Interactivity'
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第9步：添加交互性
- en: Maps naturally invite users to zoom in and pan around, and D3.js makes it easy
    to support those standard map interactions. In fact, D3.js gives us complete control,
    so we’re not limited to standard map interaction conventions. Let’s do something
    a little different with our map. We can make it so that a user can click any state
    to zoom in on it. Clicking a state that’s already zoomed in on will then zoom
    the map back out to its default. As you’ll see, this behavior is easy to implement
    with D3.js.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 地图自然鼓励用户进行缩放和平移，D3.js使得支持这些标准地图交互变得很容易。事实上，D3.js赋予了我们完全的控制权，因此我们不受限于标准的地图交互惯例。让我们对地图做些不同的事情。我们可以使用户点击任何一个州来进行缩放。点击一个已经缩放的州则会将地图缩放回默认视图。如你所见，这种行为用D3.js实现起来非常简单。
- en: The first bit of code we’ll add is a variable that keeps track of the particular
    state into which the map is zoomed. Initially, the user won’t have zoomed anywhere,
    so that variable is empty.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加的第一段代码是一个变量，用于追踪地图当前缩放的特定州。最初，用户还没有缩放任何位置，所以该变量为空。
- en: '[PRE53]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Next we add an event handler to all of the state `<path>` elements. We can do
    that when we create the elements (which we did earlier in Step 6).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为所有州的`<path>`元素添加一个事件处理器。在我们创建这些元素时（即在第6步中），我们已经完成了这一步。
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The extra statement is at ➊. Like jQuery, D3.js gives us an easy way to add
    event handlers to HTML and SVG elements. Now we have to write that event handler.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的语句位于➊。像jQuery一样，D3.js为我们提供了一种简单的方式来为HTML和SVG元素添加事件处理器。现在，我们需要编写这个事件处理器。
- en: 'The handler needs to identify the state that the user clicked, calculate the
    position of that state (in SVG coordinates), and transition the map to zoom to
    those coordinates. Before we look at the implementation in detail, it’s worth
    noting that D3.js event handlers are optimized to work with data visualizations
    (which shouldn’t be surprising). In particular, the parameter passed to the handler
    is the data item associated with the target element (conventionally named `d`).
    The JavaScript context (`this`) is set to the specific element that received the
    event. If the handler needs access to the other properties of the JavaScript event,
    they’re available in the `d3.event` global variable. Here’s how those conventions
    work in a real event handler:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理器需要识别用户点击的州，计算该州的位置（以SVG坐标表示），并将地图过渡到这些坐标进行缩放。在详细查看实现之前，值得注意的是，D3.js事件处理器经过优化，能很好地与数据可视化配合工作（这并不令人惊讶）。具体来说，传递给处理器的参数是与目标元素相关的数据项（通常命名为`d`）。JavaScript上下文（`this`）被设置为接收到事件的特定元素。如果处理器需要访问JavaScript事件的其他属性，这些属性可以通过全局变量`d3.event`获得。以下是这些约定在实际事件处理器中的工作方式：
- en: '[PRE55]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the first code block (starting at ➊), we manipulate the map colors. The previously
    zoomed state is reset to a muted gray, and the clicked state is filled with a
    vibrant orange. Notice that this same code resets the `active` variable so that
    it accurately tracks the zoomed state. Next, starting at ➋, we calculate the bounds
    of the zoomed state. Or rather, we let D3.js do the calculation. All the work
    happens in the `bounds()` function we call at ➋. The other lines are mostly just
    extracting the individual parts of that calculation. At ➌, we calculate how to
    scale the map so that the zoomed state fills 90 percent of the map. Then, starting
    at ➍, we calculate how to shift the map to center that state. The final block
    of code, starting at ➎, adjusts the map by scaling and translating the SVG. As
    you can see, we’re using a D3.js transition to animate the change in view.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个代码块中（从 ➊ 开始），我们操作了地图的颜色。之前缩放的州被重置为一种灰色，而被点击的州则被填充为鲜艳的橙色。请注意，这段代码还重置了 `active`
    变量，以便准确跟踪缩放的州。接下来，从 ➋ 开始，我们计算了缩放州的边界。或者说，我们让 D3.js 来进行计算。所有的工作都发生在我们在 ➋ 处调用的 `bounds()`
    函数中。其他的代码行主要是提取该计算的各个部分。在 ➌ 处，我们计算了如何缩放地图，以便让缩放的州占据地图的 90% 区域。然后，从 ➍ 开始，我们计算了如何移动地图以使该州居中。最后一块代码，从
    ➎ 开始，通过缩放和平移 SVG 来调整地图。正如你所见，我们使用 D3.js 的过渡效果来动画化视图的变化。
- en: The code we’ve seen so far still needs a few minor additions to deal with some
    loose ends, but I’ll leave those to the book’s source code (*[http://jsDataV.is/source/](http://jsDataV.is/source/)*).
    The result in [Figure 7-11](ch07.html#d3dotjs_makes_it_easy_to_add_custom_inte
    "Figure 7-11. D3.js makes it easy to add custom interactions to maps.") is a nice
    interactive map of our data.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的代码还需要一些小的修改来处理一些未完成的部分，但这些我将留给本书的源代码（* [http://jsDataV.is/source/](http://jsDataV.is/source/)
    *）。[图 7-11](ch07.html#d3dotjs_makes_it_easy_to_add_custom_inte "图 7-11. D3.js
    使得在地图上添加自定义交互变得容易") 中的结果是一个漂亮的互动地图，展示了我们的数据。
- en: '![D3.js makes it easy to add custom interactions to maps.](figs/web/07fig11.png.jpg)Figure 7-11. D3.js
    makes it easy to add custom interactions to maps.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![D3.js 使得在地图上添加自定义交互变得容易。](figs/web/07fig11.png.jpg)图 7-11. D3.js 使得在地图上添加自定义交互变得容易。'
- en: Creating a Unique Visualization
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建独特的可视化
- en: If you’ve followed the first three examples in this chapter, you’re probably
    beginning to appreciate the level of flexibility D3.js offers compared to traditional
    JavaScript libraries. Instead of creating visualizations for you, it provides
    many tools and utilities that you can use however you wish. We’ve used that flexibility
    to add unconventional error bars to a chart, to refine the behavior of a network
    graph, and to customize user interactions with a map. With D3.js, however, we
    aren’t limited to minor adjustments to existing visualization types. Instead,
    we can use the library to create unique visualizations that are nothing like those
    found in traditional libraries.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经跟随了本章的前三个例子，你可能开始意识到与传统 JavaScript 库相比，D3.js 提供了多少灵活性。它不是为你创建可视化，而是提供了许多工具和功能，供你按需使用。我们利用这种灵活性向图表中添加了非常规的误差条，调整了网络图的行为，并定制了用户与地图的互动。然而，使用
    D3.js 时，我们并不局限于对现有可视化类型进行微调。相反，我们可以利用这个库创造出与传统库完全不同的独特可视化效果。
- en: In this example, we’ll use the same data from the previous visualization—tornado
    sightings in 2013 from the US National Oceanic and Atmospheric Administration’s
    Climate Data Online site (*[http://www.noaa.gov/cdo-web/](http://www.noaa.gov/cdo-web/)*).
    Rather than placing the sightings on a map, however, we’ll create an interactive,
    hierarchical visualization that lets users understand the number of sightings
    by region, state, or even counties within a state. A circular hierarchy can be
    especially effective for this subject matter, so we’ll create a sunburst visualization
    with rotational animations. The code that follows is based on an example (*[http://bl.ocks.org/mbostock/4348373/](http://bl.ocks.org/mbostock/4348373/)*)
    developed by Mike Bostock, the lead D3.js developer.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用前面可视化中的相同数据——来自美国国家海洋和大气管理局气候数据在线网站的2013年龙卷风目击记录（* [http://www.noaa.gov/cdo-web/](http://www.noaa.gov/cdo-web/)
    *）。然而，我们不会将这些目击记录放在地图上，而是会创建一个互动式的层次化可视化，让用户通过区域、州，甚至是州内的县来理解目击次数。对于这个主题，圆形层次结构尤其有效，因此我们将创建一个带有旋转动画的旭日图可视化。接下来的代码基于
    Mike Bostock（D3.js 的首席开发者）开发的一个示例（* [http://bl.ocks.org/mbostock/4348373/](http://bl.ocks.org/mbostock/4348373/)
    *）。
- en: Note
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**It is also possible to create sunburst visualizations using some charting
    libraries, generally by customizing a variation of the pie chart. Those libraries,
    however, are much more focused on off-the-shelf use. Creating custom visualizations
    is generally much easier with a library like D3.js, which is designed especially
    for customization.**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**也可以使用一些图表库创建日晕（sunburst）可视化，通常通过定制饼图的变体来实现。然而，这些图表库更专注于现成的使用。而使用像 D3.js 这样的库来创建自定义可视化则通常更容易，它特别设计用于定制化。**'
- en: 'Step 1: Prepare the Data'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第1步：准备数据
- en: As before, we’ll clean and prune the 2013 tornado sightings data set. Instead
    of longitude, latitude, and Enhanced Fujita Scale classification, however, we’ll
    keep the state and county. We’ll also add a region name as a way to group subsets
    of states. The resulting CSV file begins as follows.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将清理并修剪2013年的龙卷风目击数据集。不过，这一次我们将保留州和县，而不使用经度、纬度和增强富士塔等级分类。我们还将添加一个区域名称，用于将各州分组。结果生成的CSV文件如下所示。
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Step 2: Set Up the Page'
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2步：设置页面
- en: Our skeletal web page is no different from the other D3.js examples. We set
    aside a container for the visualization and include the D3.js library.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基础网页与其他 D3.js 示例没有什么不同。我们为可视化预留了一个容器，并包含了 D3.js 库。
- en: '[PRE57]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Step 3: Create a Stage for the Visualization'
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3步：为可视化创建舞台
- en: As with our other D3.js examples, we start by creating an `<svg>` container
    for the visualization. Within that container, we’ll also add a group (`<g>`) element.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们其他的 D3.js 示例一样，我们首先创建一个 `<svg>` 容器来存放可视化图形。在这个容器内，我们还将添加一个 `<g>` 元素。
- en: '[PRE58]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This code contains a couple of new wrinkles. First, at ➊, we calculate the maximum
    radius for the visualization. This value—which is half of the height or the width,
    whichever is smaller—will come in handy in the code that follows. More interestingly,
    starting at ➋, we translate the inner `<g>` container so that its coordinate system
    places the point (0,0) right in the center of the visualization. This translation
    makes it easy to center the sunburst and calculate sunburst parameters.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含了一些新的细节。首先，在 ➊ 处，我们计算了可视化的最大半径。这个值——即高度或宽度的一半，取较小者——将在后续的代码中派上用场。更有趣的是，从
    ➋ 开始，我们对内部的 `<g>` 容器进行平移，使其坐标系的原点（0,0）恰好位于可视化图形的中心。这个平移使得日晕的居中变得容易，同时也能计算出日晕的参数。
- en: 'Step 4: Create Scales'
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第4步：创建刻度
- en: When it’s complete, our visualization will consist of areas corresponding to
    regions in the United States; larger areas will represent regions with more tornadoes.
    Because we’re dealing with areas, we’ll need two dimensions for each region. But
    we’re not going to draw our areas as simple rectangles; instead we’re going to
    use arcs. That will require a bit of trigonometry, but fortunately, D3.js provides
    a lot of help. We’ll start by defining some `scale` objects. We first saw scales
    in Step 4 of [Adapting a Traditional Chart Type](ch07.html#adapting_a_traditional_chart_type
    "Adapting a Traditional Chart Type"), where we used them to translate data values
    to SVG coordinates. The scales in the following code do much the same, except
    they’re using polar coordinates.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当完成时，我们的可视化将由对应于美国各个地区的面积构成；更大的面积将代表龙卷风更多的地区。因为我们处理的是面积数据，所以每个地区需要两个维度。但我们不会将这些面积绘制成简单的矩形；而是要使用弧形。这需要一些三角学知识，但幸运的是，D3.js提供了大量的帮助。我们将首先定义一些
    `scale` 对象。我们在《[适配传统图表类型](ch07.html#adapting_a_traditional_chart_type "Adapting
    a Traditional Chart Type")》的第4步中首次看到过刻度，我们用它们来将数据值转换为SVG坐标。以下代码中的刻度实现了类似功能，不同之处在于它们使用的是极坐标。
- en: '[PRE59]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see, the angular scale is a linear scale that ranges from 0 to 2π
    (or 360°). The radial scale ranges from 0 to the maximum radius, but it’s not
    linear. Instead, this scale is a square root scale; D3.js takes the square root
    of the input before computing the output. The area of an arc varies as the square
    of its radius, and the square root scale compensates for this effect.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，角度刻度是一个从0到2π（或360°）的线性刻度。径向刻度的范围从0到最大半径，但它不是线性的。相反，这个刻度是一个平方根刻度；D3.js在计算输出之前，会对输入值进行平方根处理。弧形的面积随着半径的平方变化，平方根刻度能够补偿这一效果。
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**In prior examples, we’ve set both ranges (outputs) and domains (inputs) for
    our scales. In this case, however, we won’t need to set domains explicitly. The
    default domain of [0,1] is exactly what we need for both scales.**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**在之前的示例中，我们为刻度设置了范围（输出）和域（输入）。然而，在本例中，我们不需要显式地设置域。[0,1] 的默认域正是我们对这两个刻度所需的。**'
- en: 'The scales we’ve defined come in handy in the next bit of code, where we define
    a function that calculates the SVG path for a single arc. Most of the work takes
    place in the D3.js function `d3.svg.arc()`, which computes an arc’s path. That
    function, though, needs four parameters: the starting and ending angles and the
    starting and ending radii for the arc. The values for those parameters come from
    our scales.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的刻度在接下来的代码中非常有用，我们将在其中定义一个函数来计算单个弧形的 SVG 路径。大多数工作发生在 D3.js 函数 `d3.svg.arc()`
    中，该函数计算弧形路径。然而，该函数需要四个参数：起始角度、结束角度、起始半径和结束半径。这些参数的值来自我们的刻度。
- en: 'When we use our `arc()` function later in the code, we’re going to call it
    with a D3.js selection. That selection will have a data value associated with
    it, and the data value will include four properties:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在代码中稍后使用 `arc()` 函数时，我们会使用 D3.js 的选择集来调用它。该选择集将与一个数据值相关联，并且数据值将包含四个属性：
- en: '**`.x`** the starting x–position for the data'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`.x`** 数据的起始 x 位置'
- en: '**`.dx`** the data’s length along the x–axis (Δ*x*)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`.dx`** 数据在 x 轴上的长度（Δ*x*）'
- en: '**`.y`** the starting y–position for the data'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`.y`** 数据的起始 y 位置'
- en: '**`.dx`** the data’s length along the y–axis (Δ*y*)'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`.dx`** 数据在 y 轴上的长度（Δ*y*）'
- en: Given those properties, here’s the code that generates the arc path.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些属性，以下是生成弧形路径的代码。
- en: '[PRE60]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The code itself is pretty straightforward, but a picture helps explain why
    we’re using the code this way. Assume that the data associated with a selection
    has an (*x*,*y*) position of (12.5,10), a width of 25, and a height of 30\. The
    data properties would then be:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 代码本身相当直观，但一张图能更好地解释为什么我们要这样使用代码。假设与选择集相关联的数据具有 (*x*,*y*) 位置为 (12.5,10)，宽度为 25，高度为
    30。数据属性将如下所示：
- en: '`.x = 12.5`'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.x = 12.5`'
- en: '`.dx = 25`'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.dx = 25`'
- en: '`.y = 10`'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.y = 10`'
- en: '`.dy = 30`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.dy = 30`'
- en: With Cartesian coordinates, we could draw the selection as on the left side
    of [Figure 7-12](ch07.html#d3dotjs_helps_transform_a_rectangular_ar "Figure 7-12. D3.js
    helps transform a rectangular area into an arc."). Our scales and arc function
    will transform the rectangle to the arc shown on the right side of the figure.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用笛卡尔坐标系，我们可以像图 [7-12](ch07.html#d3dotjs_helps_transform_a_rectangular_ar) 左侧那样绘制选择集。我们的刻度和弧形函数将把矩形转换为图中右侧所示的弧形。
- en: '![D3.js helps transform a rectangular area into an arc.](figs/web/07fig12.png.jpg)Figure 7-12. D3.js
    helps transform a rectangular area into an arc.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '![D3.js 帮助将矩形区域转换为弧形。](figs/web/07fig12.png.jpg)图 7-12. D3.js 帮助将矩形区域转换为弧形。'
- en: We haven’t specified the ranges of the x- and y-scales, but assume for now that
    each ranges from 0 to 100\. The starting x-value of 12.5, therefore, is 12.5 percent
    of the full range. When we convert that value to polar coordinates, the result
    will be 12.5 percent of the full 360°. That’s 45°, or π/4\. The x-value extends
    another 25 percent, so the final x-value adds another 90°, or π/2, to the starting
    value. For the y-values, our scales take the square root and map the results to
    the domain from 0 to 250 (`maxRadius`). The initial value of 10, therefore, is
    divided by 100 (for the range) and transformed to ![](figs/web/256equ01.png.jpg),
    or 79\. The final value of 10 + 30 results in a radius of ![](figs/web/256equ02.png.jpg),
    or 158\. That’s the process that creates an SVG for each data value.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未指定 x 轴和 y 轴的刻度范围，但暂时假设每个范围是从 0 到 100。因此，起始的 x 值 12.5，表示该范围的 12.5%。当我们将这个值转换为极坐标时，结果将是完整
    360° 范围的 12.5%。也就是 45°，或 π/4。x 值再延伸 25%，所以最终的 x 值会再增加 90°，或 π/2，作为起始值。对于 y 值，我们的刻度会对其进行平方根转换，并将结果映射到
    0 到 250（`maxRadius`）的范围。因此，初始值 10 会被除以 100（表示范围），并转换为 ![](figs/web/256equ01.png.jpg)，也就是
    79。最终值 10 + 30 将产生一个半径值为 ![](figs/web/256equ02.png.jpg)，也就是 158。这就是为每个数据值创建 SVG
    的过程。
- en: 'Step 5: Retrieve the Data'
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 5 步：获取数据
- en: With the initial preparation complete, we’re now ready to process the data.
    As in the previous example, we’ll use `d3.csv()` to retrieve the CSV file from
    the server.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在初步准备工作完成后，我们现在可以开始处理数据。像之前的示例一样，我们将使用 `d3.csv()` 从服务器获取 CSV 文件。
- en: '[PRE61]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: When D3.js retrieves the file, it creates a data structure that begins like
    the following fragment.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当 D3.js 获取文件时，它会创建一个类似以下片段的数据结构。
- en: '[PRE62]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: That data structure reflects the data, but it doesn’t include the `.x`, `.dx`,
    `.y`, and `.dy` properties that we need to draw the arcs. There’s additional work
    to be done to calculate those values. If you recall the second example in this
    chapter, we’ve seen this situation before. We have a set of raw data, but we need
    to augment that raw data with additional properties for the visualization. In
    the earlier example, we used the D3.js force layout to calculate the extra properties.
    In this case, we can use the partition layout.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据结构反映了数据本身，但它没有包含我们绘制弧形所需的 `.x`、`.dx`、`.y` 和 `.dy` 属性。计算这些值还需要进一步的工作。如果你回想一下本章的第二个示例，我们以前见过这种情况。我们有一组原始数据，但我们需要用额外的属性来增强这些数据以进行可视化。在之前的示例中，我们使用
    D3.js 的力导向布局来计算这些额外的属性。在这种情况下，我们可以使用分区布局来实现。
- en: Before we can use the partition layout, however, we have to restructure our
    data. The partition layout works with hierarchical data, and right now all we
    have is a single dimensional array. We must structure the data to reflect the
    natural hierarchy of region, state, and county. Here again, however, D3.js can
    help us. The `d3.nest()` operator analyzes an array of data and extracts the hierarchy
    from it. If you’re familiar with database commands, it’s the D3.js equivalent
    of the `GROUP BY` operation. We can use the operator to create a new version of
    the data.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用分区布局之前，我们必须重新结构化数据。分区布局需要层次化的数据，而现在我们只有一个单维数组。我们必须将数据结构化，以反映区域、州和县的自然层级结构。不过，在这里
    D3.js 仍然能够帮助我们。`d3.nest()` 操作符分析一个数据数组并从中提取层次结构。如果你熟悉数据库命令，它相当于 D3.js 中的 `GROUP
    BY` 操作。我们可以使用这个操作符来创建数据的新版本。
- en: '[PRE63]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'First, at ➊, we define the variable that will hold our restructured data. It’s
    an object with two properties. The `.key` property is set to `"United States"`,
    and the `.values` property is the result of the `d3.nest()` operation. Starting
    at ➋, we tell the operator to group the data, first by `.region`, then by `.state`,
    and finally by `.county`. Then, at ➌ and ➍, we tell the operator to set the final
    value to be the count of entries for the final grouping. Finally, at ➎, we pass
    the original data set to the operator. When this statement finishes, the `hierarchy`
    variable contains a structured version of our data that begins like the following
    fragment:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 ➊ 处，我们定义了一个变量来保存我们重新结构化后的数据。它是一个具有两个属性的对象。`.key` 属性被设置为 `"United States"`，而
    `.values` 属性则是 `d3.nest()` 操作的结果。从 ➋ 开始，我们告诉操作符按 `.region`、然后按 `.state`，最后按 `.county`
    来对数据进行分组。然后，在 ➌ 和 ➍ 处，我们告诉操作符将最终值设置为每个分组中的条目计数。最后，在 ➎ 处，我们将原始数据集传递给操作符。当这个语句完成时，`hierarchy`
    变量包含了一个结构化的数据版本，其开头类似于以下片段：
- en: '[PRE64]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This structure matches what the partition layout needs, but there’s still one
    more step we need to take. The `d3.nest()` operator places both child arrays and
    leaf data in the `.values` property. By default, however, the partition layout
    expects the data to use different property names for each type of property. More
    specifically, it expects child nodes to be stored in the `.children` property
    and data values in the `.value` property. Since the `d3.nest()` operator doesn’t
    create exactly that structure, we have to extend the default partition layout.
    Here’s the code to do that:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构与分区布局的需求相匹配，但我们还需要进行一步操作。`d3.nest()` 操作符将子数组和叶子数据放在 `.values` 属性中。然而，默认情况下，分区布局期望数据使用不同的属性名称来表示每种类型的属性。更具体来说，它期望子节点存储在
    `.children` 属性中，而数据值存储在 `.value` 属性中。由于 `d3.nest()` 操作符并没有创建完全符合这种结构的结果，我们需要扩展默认的分区布局。下面是实现这一操作的代码：
- en: '[PRE65]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: At ➊ and ➋, we provide a custom function to return a node’s children. If the
    node’s `.values` property is an array, then that property contains the children.
    Otherwise, the node has no children and we return `null`. Then at ➌ and ➍, we
    provide a custom function to return a node’s value. Since this function is used
    only when no children exist, the `.values` property has to contain the node value.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 和 ➋ 处，我们提供了一个自定义函数来返回节点的子节点。如果节点的 `.values` 属性是一个数组，那么该属性就包含了子节点。否则，节点没有子节点，我们返回
    `null`。然后，在 ➌ 和 ➍ 处，我们提供了一个自定义函数来返回节点的值。由于这个函数只在没有子节点时使用，因此 `.values` 属性必须包含节点的值。
- en: 'Step 6: Draw the Visualization'
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第6步：绘制可视化效果
- en: It’s taken a bit of work to get to this point, but now we’re ready to draw the
    visualization. Here’s where we see the payoff for all the work. It takes only
    a few lines of code to create the visualization.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止已经花了一些功夫，但现在我们已经准备好绘制可视化效果了。这是我们为所有工作付出的代价的回报。只需几行代码就可以创建可视化效果。
- en: '[PRE66]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This code follows the same structure we’ve used for all of our D3.js examples.
    At ➊, we create a selection of the SVG elements that represent our data; in this
    case we’re using `<path>` elements. We then bind the selection to the hierarchical
    data using the custom partition layout. At ➋, we identify the data values that
    don’t (yet) have an associated SVG element, and at ➌ we create new elements for
    those values. That final step relies on the `.arc()` function that we created
    in Step 4\. We haven’t yet added any colors or labels, but we can see from [Figure 7-13](ch07.html#d3dotjs_handles_the_math_required_to_cre
    "Figure 7-13. D3.js handles the math required to create a sunburst diagram.")
    that we’re on the right track.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码遵循了我们在所有D3.js示例中使用的相同结构。在➊处，我们创建了表示数据的SVG元素的选择集；在本例中，我们使用的是`<path>`元素。然后，我们使用自定义的分区布局将选择集与层次数据绑定。在➋处，我们识别出那些尚未（或还没有）关联SVG元素的数据值，而在➌处，我们为这些值创建新的元素。最后一步依赖于我们在步骤4中创建的`.arc()`函数。虽然我们还没有添加颜色或标签，但从[图7-13](ch07.html#d3dotjs_handles_the_math_required_to_cre
    "图7-13. D3.js处理创建Sunburst图所需的数学运算。")可以看出，我们已经走在了正确的道路上。
- en: '![D3.js handles the math required to create a sunburst diagram.](figs/web/07fig13.png.jpg)Figure 7-13. D3.js
    handles the math required to create a sunburst diagram.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '![D3.js处理创建Sunburst图所需的数学运算。](figs/web/07fig13.png.jpg)图7-13. D3.js处理创建Sunburst图所需的数学运算。'
- en: 'Step 7: Color the Areas'
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第7步：给区域上色
- en: Now we can turn our attention to coloring the visualization. We want to give
    each region a unique, dominant color and then shade that color for states and
    counties within the region. A good starting point for us is a different type of
    D3.js scale, a categorical scale for colors. All of the scales we’ve seen so far
    are cardinal scales; they map numerical values to properties for the visualization.
    Categorical scales work with data values that are not numerical; rather, the values
    simply represent different categories of some quantity. In our case, the regions
    represent categorical data. After all, there isn’t anything intrinsically numerical
    about New England or the Southwest.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将注意力转向为可视化上色。我们希望给每个区域一个独特的主色，并为该区域内的各州和县使用该颜色的不同色调。一个好的起点是使用D3.js的另一种比例尺——分类颜色比例尺。到目前为止，我们所看到的所有比例尺都是基数比例尺；它们将数值映射到可视化的属性上。分类比例尺处理的则是非数值型数据；这些值仅仅代表某一量的不同类别。在我们的例子中，区域代表的是分类数据。毕竟，"新英格兰"或"西南部"本身并没有什么数值含义。
- en: As the name suggests, a categorical *color* scale maps different category values
    to different colors. D3.js includes several of these predefined color scales.
    Since we have fewer than 10 regions in our data, the `d3.scale.category10()` scale
    works fine for this example. [Figure 7-14](ch07.html#d3dotjs_includes_color_scales_for_catego
    "Figure 7-14. D3.js includes color scales for categorical data.") shows the colors
    in this scale.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，分类的*颜色*比例尺将不同的类别值映射到不同的颜色。D3.js包含了几种预定义的颜色比例尺。由于我们的数据中区域少于10个，`d3.scale.category10()`比例尺非常适合这个例子。[图7-14](ch07.html#d3dotjs_includes_color_scales_for_catego
    "图7-14. D3.js为分类数据提供颜色比例尺。")显示了该比例尺中的颜色。
- en: '![D3.js includes color scales for categorical data.](figs/web/07fig14.png)Figure 7-14. D3.js
    includes color scales for categorical data.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '![D3.js为分类数据提供颜色比例尺。](figs/web/07fig14.png)图7-14. D3.js为分类数据提供颜色比例尺。'
- en: Our next task is assigning colors from this scale to the arcs in our visualization.
    To do that, we’ll define our own `color()` function. That function will accept
    a data node from the partition layout as input.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是将该比例尺的颜色分配到可视化中的弧形区域。为此，我们将定义我们自己的`color()`函数。该函数将接受分区布局中的数据节点作为输入。
- en: '[PRE67]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: First, at ➊, we create a local variable that we’ll use to store colors. We then
    check to see if the input node is the root of the hierarchy. If it is, we then
    create a color scale at ➋ for the node’s children and assign the node its own
    color at ➌. The root node in our visualization, which represents the entire United
    States, will be white. That assigned color will eventually be returned by the
    function.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在➊处，我们创建了一个局部变量，用于存储颜色。接着，我们检查输入节点是否为层次结构的根节点。如果是，我们就在➋处为该节点的子节点创建颜色比例尺，并在➌处为该节点分配自己的颜色。在我们的可视化中，代表整个美国的根节点将是白色的。该分配的颜色最终会由函数返回。
- en: After we create a color scale for the child nodes, we want to distribute the
    individual colors to those nodes. There’s a slight catch, though. The nodes in
    the `d.children` array aren’t necessarily distributed in the clockwise order we
    want for our visualization. To make sure the colors from our scale are distributed
    in order, we’ll have to sort the `d.children` array first. Here’s the complete
    code for this step.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在为子节点创建颜色比例之后，我们需要将个别颜色分配给这些节点。然而，有一个小问题。`d.children`数组中的节点不一定按我们希望的顺时针顺序分布。为了确保我们颜色比例中的颜色按顺序分布，我们必须先对`d.children`数组进行排序。以下是这一步的完整代码。
- en: '[PRE68]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In the first line, we make sure that there is a children array. If there is,
    we create a copy of the children array that contains just the node values and
    their original array index at ➊. Then, at ➋, we sort that copy based on the node
    values. Finally, at ➌, we iterate through the sorted array and assign colors to
    the child nodes.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们确保有一个子节点数组。如果有，我们会创建该子节点数组的副本，副本只包含节点值及其原始数组索引，见➊。然后，在➋，我们根据节点值对副本进行排序。最后，在➌，我们遍历排序后的数组，并为子节点分配颜色。
- en: So far we’ve created a categorical color scale and assigned its colors to the
    first-level children. That takes care of colors for the regions, but there are
    also states and counties that need colors. For those, we can create a different
    scale based on the parent color. Let’s go back to our function definition and
    add an `else` clause for non-root nodes. In this clause, we also create a color
    scale for the children. These child nodes, however, are not regions; they are
    states or counties. For states of a region and counties of a state, we don’t want
    unique, distinct colors like those from a categorical scale. Instead, we want
    colors related to the color of the parent. That calls for a linear gradient.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个分类颜色比例并将其颜色分配给了第一层子节点。这解决了区域的颜色问题，但还有州和县需要颜色。对于这些，我们可以基于父节点颜色创建一个不同的比例。让我们回到函数定义，并为非根节点添加一个`else`分支。在这个分支中，我们也为子节点创建一个颜色比例。然而，这些子节点不是区域；它们是州或县。对于一个区域的州和一个州的县，我们不希望使用像分类比例那样的独特颜色。相反，我们希望颜色与父节点的颜色相关。这就需要一个线性渐变。
- en: '[PRE69]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Starting at ➊, we define the starting and ending colors for our gradient. To
    create those colors, we start with the parent node’s color (`d.color`) and darken
    or brighten it. In both cases we use hue, chroma, and luminance (HCL) as the basis
    for the color manipulations. The HCL color space is based on human visual perception,
    unlike the purely mathematical basis for the more familiar RGB color space. Using
    HCL generally results in a more visually pleasing gradient.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 从➊开始，我们定义渐变的起始色和结束色。为了创建这些颜色，我们从父节点的颜色（`d.color`）开始，并将其加深或加亮。在这两种情况下，我们使用色调、饱和度和亮度（HCL）作为颜色操作的基础。HCL颜色空间基于人类的视觉感知，不同于更常见的RGB颜色空间那样的纯数学基础。使用HCL通常能得到更具视觉吸引力的渐变效果。
- en: The code block starting at ➋ actually creates the gradient. We’re using a D3.js
    linear scale and a built-in interpolation algorithm for HCL colors ➌. Our gradient
    ranges between the start and end colors ➍, and its domain is the indices of the
    node’s children ➎.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 从➋开始的代码块实际上创建了渐变。我们使用的是D3.js的线性比例和内置的HCL颜色插值算法 ➌。我们的渐变在起始和结束颜色之间变化 ➍，它的域是节点子节点的索引
    ➎。
- en: Now all we need to do is assign the appropriate color when we create each data
    value’s `<path>` element. That requires a oneline addition, `.attr("fill", color)`,
    to the code that creates those paths.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的就是在创建每个数据值的`<path>`元素时分配适当的颜色。这只需要在创建路径的代码中添加一行`.attr("fill", color)`。
- en: '[PRE70]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: As [Figure 7-15](ch07.html#d3dotjs_provides_tools_to_add_attractive "Figure 7-15. D3.js
    provides tools to add attractive colors to visualizations such as our sunburst.")
    shows, our visualization now includes appropriate colors.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图7-15](ch07.html#d3dotjs_provides_tools_to_add_attractive "图7-15. D3.js提供了工具，将吸引人的颜色添加到可视化中，比如我们的日冕图.")所示，我们的可视化现在包含了合适的颜色。
- en: '![D3.js provides tools to add attractive colors to visualizations such as our
    sunburst.](figs/web/07fig15.png.jpg)Figure 7-15. D3.js provides tools to add attractive
    colors to visualizations such as our sunburst.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![D3.js提供了工具，将吸引人的颜色添加到可视化中，比如我们的日冕图。](figs/web/07fig15.png.jpg)图7-15. D3.js提供了工具，将吸引人的颜色添加到可视化中，比如我们的日冕图。'
- en: 'Step 8: Make the Visualization Interactive'
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第8步：使可视化交互式
- en: To conclude this example, we will add some interactivity. When a user clicks
    an area in the chart, the chart will zoom in to show more detail for that area.
    To emphasize the subject matter, we’ll create a custom rotating animation effect
    for this zoom. The easiest part of this step is adding the function to handle
    click events. We can do that when we add the `<path>` elements to the page.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结这个例子，我们将增加一些交互功能。当用户点击图表中的某个区域时，图表将缩放以显示该区域的更多细节。为了强调主题，我们将为这个缩放效果创建一个自定义的旋转动画效果。这个步骤中最简单的部分是添加处理点击事件的函数。我们可以在将
    `<path>` 元素添加到页面时完成这一操作。
- en: '[PRE71]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `handleClick` function at ➊ is the event handler that we’ll have to write.
    Conceptually, the function is pretty straightforward. When the user clicks an
    area, we want to modify all the paths to make that area the focal point of the
    visualization. The complete function is shown in the following code.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 位于 ➊ 处的 `handleClick` 函数是我们需要编写的事件处理程序。从概念上讲，这个函数相当简单。当用户点击某个区域时，我们希望修改所有的路径，使该区域成为可视化的焦点。完整的函数在以下代码中展示。
- en: '[PRE72]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The function’s single parameter is the data value corresponding to the clicked
    element. Conventionally, D3.js uses `d` for that value; in this case, however,
    we’re using `datum` to avoid confusion with the SVG `"d"` attribute. The first
    line in the function references all of the paths in the visualization and sets
    up an animated transition for those paths. The next line tells D3.js what values
    we’re going to transition. In this case, we’re changing an attribute of the `<path>`
    elements (so we use the function `attrTween`), and the specific attribute we’re
    changing is the `"d"` attribute (the first parameter to that function). The second
    parameter, `arcTween(datum)`, is a function that returns a function.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的唯一参数是与点击元素对应的数据值。通常情况下，D3.js 使用 `d` 作为该值；然而，在本例中，为了避免与 SVG 的 `"d"` 属性混淆，我们使用
    `datum`。函数中的第一行引用了可视化中的所有路径，并为这些路径设置了动画过渡效果。接下来的这一行告诉 D3.js 我们要进行过渡的值。在这个例子中，我们正在更改
    `<path>` 元素的一个属性（因此我们使用 `attrTween` 函数），而我们更改的具体属性是 `"d"` 属性（该函数的第一个参数）。第二个参数
    `arcTween(datum)` 是一个返回函数的函数。
- en: Here’s the complete implementation of `arcTween()`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `arcTween()` 的完整实现。
- en: '[PRE73]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You can see that this code block defines several different functions. First,
    there’s `arcTween()`. It returns another function `calculateNewPath()`, and *that*
    function returns either `interpolatePathForRoot()` or `interpolatePathForNonRoot()`.
    Before we look at the details of the implementation, let me go over the distinctions
    between these functions.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这段代码定义了几个不同的函数。首先是 `arcTween()`，它返回另一个函数 `calculateNewPath()`，而 *这个* 函数返回的是
    `interpolatePathForRoot()` 或 `interpolatePathForNonRoot()`。在查看实现的细节之前，先让我简单介绍一下这些函数之间的区别。
- en: '`arcTween()` is called once (for a single click) in the click event handler.
    Its input parameter is the data value corresponding to the clicked element.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arcTween()` 会在点击事件处理程序中被调用一次（针对单次点击）。它的输入参数是与点击元素对应的数据值。'
- en: '`calculateNewPath()` is then called once for every path element, a total of
    702 times for each click. Its input parameters are the data value and index of
    the path element.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接着，`calculateNewPath()` 会针对每个路径元素调用一次，每次点击总共调用 702 次。它的输入参数是路径元素的数据值和索引。
- en: '`interpolatePathForRoot()` or `interpolatePathForNonRoot()` are called multiple
    times for each path element. Every call provides the input parameter `t` (for
    time) that represents the amount of progress in the current animation transition.
    The time parameter ranges from 0 when the animation starts to 1 when the animation
    ends. If, for example, D3.js requires 100 individual animation steps for the transition,
    then these functions will be called 70,200 times for each click.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interpolatePathForRoot()` 或 `interpolatePathForNonRoot()` 会针对每个路径元素多次调用。每次调用都会提供输入参数
    `t`（表示时间），它代表当前动画过渡的进度。时间参数的范围从动画开始时的 0 到动画结束时的 1。例如，如果 D3.js 需要 100 个独立的动画步骤来完成过渡，那么这些函数将在每次点击时被调用
    70,200 次。'
- en: Now that we know when each of these functions is called, we can start to look
    at what they actually do. A concrete example definitely helps, so let’s consider
    what happens when the user clicks the state of Kentucky. As [Figure 7-16](ch07.html#tornado_sightings_sunburst_graph_with_ke
    "Figure 7-16. The tornado sightings sunburst graph with Kentucky highlighted")
    shows, it’s on the second row in the upper-right section of the visualization.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了这些函数何时被调用，我们可以开始查看它们实际做了什么。一个具体的例子无疑会有所帮助，所以让我们来看看用户点击肯塔基州时会发生什么。如[图7-16](ch07.html#tornado_sightings_sunburst_graph_with_ke
    "图7-16. 突出显示肯塔基州的龙卷风观测图")所示，它位于可视化图表的右上部分第二行。
- en: '![The tornado sightings sunburst graph with Kentucky highlighted](figs/web/07fig16.png.jpg)Figure 7-16. The
    tornado sightings sunburst graph with Kentucky highlighted'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '![突出显示肯塔基州的龙卷风观测图](figs/web/07fig16.png.jpg)图7-16. 突出显示肯塔基州的龙卷风观测图'
- en: 'The data value associated with this SVG `<path>` will have properties calculated
    by the partition layout, specifically:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 与此SVG `<path>` 相关的数据值将由分区布局计算得出，具体包括：
- en: an `x` value of 0.051330798479087454
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`x`值为0.051330798479087454
- en: a `y` value of 0.5
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`y`值为0.5
- en: a `dx` value of 0.04182509505703422
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`dx`值为0.04182509505703422
- en: a `dy` value of 0.25
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`dy`值为0.25
- en: In terms of our visualization, the area begins at an angular position of 18.479°
    (`x`) and continues for another 15.057° (`dx`). Its innermost radius begins 177
    pixels (`y`) from the center. When the user clicks Kentucky, we want the visualization
    to zoom in on Kentucky and its counties. That’s the region that [Figure 7-17](ch07.html#when_the_user_clicks_kentuckycomma_we_wa
    "Figure 7-17. When the user clicks Kentucky, we want the visualization to focus
    on that small area.") highlights. The angle begins at 18.479° and continues for
    another 15.057°; the radius begins at 177 pixels and continues to the `maxRadius`
    value, a total length of 73 pixels.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的可视化中，该区域从18.479°的角度位置（`x`）开始，接着延续15.057°（`dx`）。它的最内层半径从离中心177像素（`y`）的位置开始。当用户点击肯塔基州时，我们希望可视化聚焦于肯塔基州及其县。这正是[图7-17](ch07.html#when_the_user_clicks_kentuckycomma_we_wa
    "图7-17. 当用户点击肯塔基州时，我们希望可视化聚焦于那个小区域。")突出显示的区域。角度从18.479°开始，继续延伸15.057°；半径从177像素开始，直到`maxRadius`值，总长度为73像素。
- en: '![When the user clicks Kentucky, we want the visualization to focus on that
    small area.](figs/web/07fig17.png.jpg)Figure 7-17. When the user clicks Kentucky,
    we want the visualization to focus on that small area.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '![当用户点击肯塔基州时，我们希望可视化聚焦于那个小区域。](figs/web/07fig17.png.jpg)图7-17. 当用户点击肯塔基州时，我们希望可视化聚焦于那个小区域。'
- en: The concrete example helps explain the `arcTween()` implementation. The function
    first creates three `d3.interpolate` objects. These objects provide a convenient
    way to handle the mathematical calculations for interpolations. The first object
    interpolates from the starting `theta` domain (initially 0 to 1) to our desired
    subset (0.051 to 0.093 for Kentucky). The second object does the same for the
    radius, interpolating from the starting radius domain (initially 0 to 1) to our
    desired subset (0.5 to 1 for Kentucky and its counties). The final object provides
    a new, interpolated range for the radius. If the clicked element has a non-zero
    `y` value, the new range will start at 20 instead of 0\. If the clicked element
    was the `<path>` representing the entire United States, then the range reverts
    to the initial starting value of 0.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的例子有助于解释`arcTween()`的实现。该函数首先创建三个`d3.interpolate`对象。这些对象提供了一种方便的方式来处理插值的数学计算。第一个对象将起始`theta`域（最初为0到1）插值到我们所需的子集（肯塔基州的范围是0.051到0.093）。第二个对象对半径做相同的操作，将起始半径域（最初为0到1）插值到我们所需的子集（肯塔基州及其县的范围是0.5到1）。最后一个对象为半径提供了一个新的插值范围。如果点击的元素具有非零的`y`值，则新的范围将从20开始，而不是从0开始。如果点击的元素是表示整个美国的`<path>`，那么范围将恢复到初始的起始值0。
- en: '`arcTween()` returns the `calculateNewPath` function after creating the `d3.interpolate`
    objects. D3.js calls this function once for each `<path>` element. When it executes,
    `calculateNewPath()` checks to see if the associated `<path>` element is the root
    (representing the entire United States). If so, `calculateNewPath()` returns the
    `interpolatePathForRoot` function. For the root, no interpolation is necessary,
    so the desired path is just the regular path that our `arc()` function (from Step
    4) creates. For all other elements, however, we use the `d3.interpolate` objects
    to redefine the `theta` and `radius` scales. Instead of the full 0 to 2π and 0
    to `maxRadius`, we set these scales to be the desired area of focus. Furthermore,
    we use the amount of progress in the transition from the parameter `t` to interpolate
    how close we are to those desired values. With the scales redefined, calling the
    `arc()` function returns a path appropriate for the new scales. As the transition
    progresses, the paths reshape themselves to fit the desired outcome. You can see
    the intermediate steps in [Figure 7-18](ch07.html#transition_smoothly_animates_the_visuali
    "Figure 7-18. The transition smoothly animates the visualization to zoom in on
    the area of focus.").'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`arcTween()`在创建`d3.interpolate`对象后返回`calculateNewPath`函数。D3.js为每个`<path>`元素调用此函数一次。执行时，`calculateNewPath()`检查相关的`<path>`元素是否为根元素（代表整个美国）。如果是，`calculateNewPath()`返回`interpolatePathForRoot`函数。对于根元素，不需要插值，所需路径就是我们的`arc()`函数（来自第4步）创建的常规路径。然而，对于所有其他元素，我们使用`d3.interpolate`对象重新定义`theta`和`radius`比例尺。我们将这些比例尺设置为所需的焦点区域，而不是完整的0到2π和0到`maxRadius`。此外，我们使用过渡中的进度量`t`来插值我们距离这些期望值有多近。重新定义比例尺后，调用`arc()`函数返回适合新比例尺的路径。随着过渡的进行，路径会重新塑造以适应期望的结果。您可以在[图7-18](ch07.html#transition_smoothly_animates_the_visuali
    "图7-18. 平滑过渡使可视化效果缩放到焦点区域。")中看到中间步骤。'
- en: '![The transition smoothly animates the visualization to zoom in on the area
    of focus.](figs/web/07fig18.png.jpg)Figure 7-18. The transition smoothly animates
    the visualization to zoom in on the area of focus.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '![平滑过渡使可视化效果缩放到焦点区域。](figs/web/07fig18.png.jpg)图7-18. 平滑过渡使可视化效果缩放到焦点区域。'
- en: With this final bit of code, our visualization is complete. [Figure 7-19](ch07.html#d3dotjs_provides_all_the_tools_needed_fo
    "Figure 7-19. D3.js provides all the tools needed for complex custom interactive
    visualizations like this animated zoomable sunburst.") shows the result. It includes
    some additional hover effects in lieu of a true legend; you can find the complete
    implementation in the book’s source code (*[http://jsDataV.is/source/](http://jsDataV.is/source/)*).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这最后一部分代码，我们的可视化完成了。[图7-19](ch07.html#d3dotjs_provides_all_the_tools_needed_fo
    "图7-19. D3.js提供了构建复杂自定义交互式可视化所需的所有工具。")展示了结果。它包括一些额外的悬停效果，而不是真正的图例；您可以在本书的源代码中找到完整的实现（*[http://jsDataV.is/source/](http://jsDataV.is/source/)*）。
- en: '![D3.js provides all the tools needed for complex custom interactive visualizations
    like this animated zoomable sunburst.](figs/web/07fig19.png.jpg)Figure 7-19. D3.js
    provides all the tools needed for complex custom interactive visualizations like
    this animated zoomable sunburst.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '![D3.js提供了构建像这样的复杂自定义交互式可视化所需的所有工具。](figs/web/07fig19.png.jpg)图7-19. D3.js提供了构建像这样的复杂自定义交互式可视化所需的所有工具。'
- en: Summing Up
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: As we’ve seen in these examples, D3.js is a very powerful library for building
    JavaScript visualizations. Using it effectively requires a deeper understanding
    of JavaScript techniques than most of the other libraries we’ve seen in this book.
    If you make the investment to learn D3.js, though, you’ll have more control and
    flexibility over the results.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这些示例中看到的，D3.js是一个非常强大的用于构建JavaScript可视化的库。要有效地使用它，需要比本书中看到的大多数其他库更深入地了解JavaScript技术。然而，如果您投入学习D3.js，您将对结果拥有更多的控制和灵活性。
