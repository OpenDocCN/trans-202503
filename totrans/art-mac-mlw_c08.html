<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 8: Debugging</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:a248aa67-aa2c-49b1-a34e-c916914c0e30" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_165" title="165"/>8</span><br/>
<span class="ChapterTitle">Debugging</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">While the passive dynamic analysis tools covered in the last chapter can often provide insight into a malicious sample, they allow you to observe the sample’s actions only indirectly and may not fully reveal its internal workings. In certain cases, you’ll need something more comprehensive. </p>
<p>The ultimate dynamic analysis tool is the debugger. A <em>debugger</em> is a program that allows you to execute another program instruction by instruction. At any time, you can examine or modify its registers and memory contents, manipulate control flow, and much more. In this chapter, I’ll introduce various debugging concepts by means of the de facto debugger for macOS: LLDB. Then we’ll walk through a case study, applying these concepts to uncover surreptitious cryptocurrency mining logic in an application that was found in Apple’s official App Store. </p>
<h2 id="h1-501942c08-0001"><span epub:type="pagebreak" id="Page_166" title="166"/>Why You Need a Debugger</h2>
<p class="BodyFirst">The following example should clearly illustrate the power of the debugger. Take a look at this snippet of disassembled code from malware known as Mami (and named by yours truly). In this snippet, we find a large chunk of embedded, encrypted data that is passed to a method named <code>setDefaultConfiguration</code> (<a href="#listing8-1" id="listinganchor8-1">Listing 8-1</a>):</p>
<pre><code>[SBConfigManager setDefaultConfiguration:<br/>@"uZmgulcipekSbayTO9ByamTUu_zVtsflazc2Nsuqgq0dXkoOzKMJMNTULoLpd-QV9qQy6VRluzRXqWOGscgheRvikLkPR<br/>zs1pJbey2QdaUSXUZCX-UNERrosul22NsW2vYpS7HQO4VG5l8qic3rSH_fAhxsBXpEe557eHIr245LUYcEIpemnvSPTZ_lN<br/>p2XwyOJjzcJWirKbKwtc3Q61pD..."];</code></pre>
<p class="CodeListingCaption"><a id="listing8-1">Listing 8-1</a>: Encrypted data (Mami)</p>
<p>If a malicious sample includes encrypted data, the malware author is generally attempting to conceal something, either from detection tools or a malware analyst. Therefore, when we encounter such data, we should be motivated to decrypt it in order to uncover its secrets. Based on the Mami method’s name, we can reasonably assume that this embedded data determines some initial configuration. It may contain information valuable to malware analysts, such as the addresses of command and control servers, insights into the malware’s capabilities, and more. </p>
<p>So how do we decrypt it? Static analysis approaches are generally inefficient, as they require us to both understand the cryptographic algorithm used and recover the decryption key. File or process monitors are also of little use in this case, because Mami’s encrypted configuration information is not written to disk, nor passed to any other processes. In other words, it exists decrypted solely in the Mami process memory space. </p>
<p>Using a debugger, we can easily extract this information. First, we can instruct the malware to execute until it reaches the <code>setDefaultConfiguration:</code> method. Then, by <em>stepping through</em>, or executing each instruction one at a time, we can allow the malware to continue execution in a controlled manner, pausing when it has completed the decryption of its configuration information. As a debugger can directly inspect the memory of the process it is debugging, we can then <em>dump</em>, or print, the now-decrypted configuration information (<a href="#listing8-2" id="listinganchor8-2">Listing 8-2</a>):</p>
<pre><code>{<br/> "dnsChanger" =  {<br/>   "affiliate" = "";<br/>   "blacklist_dns" = ();<br/>   "encrypt" = true;<br/>   "external_id" = 0;<br/>   "product_name" = dnsChanger;<br/>   "publisher_id" = 0;<br/>    ...<br/>   "setup_dns" =         (<br/>      "82.163.143.135",<br/><span epub:type="pagebreak" id="Page_167" title="167"/>      "82.163.142.137"<br/>    );<br/>    "shared_storage" = "/Users/%USER_NAME%/Library/Application Support";<br/>    "storage_timeout" = 120;<br/>   };<br/> "installer_id" = 1359747970602718687;<br/> ...<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing8-2">Listing 8-2</a>: Decrypted configuration data (Mami)</p>
<p>Various decrypted key/value pairs, such as <code>"product_name" = dnsChanger</code> and the <code>setup_dns</code> array, provide insight into the malware’s goal: hijacking infected systems’ DNS settings and then forcing domain name resolutions to be routed through attacker-controlled servers. Incidentally, from the decrypted configuration we now know that these servers are found at <code>82.163.143.135</code> and <code>82.163.142.137</code>. Perhaps the most noteworthy aspect of this analysis is that we barely lifted a finger. Nor did we have to spend any time understanding how exactly this data was encrypted! </p>
<p>This is but one example of a debugger’s power. In general, you should use a debugger to fully understand a code sample, as well as to dynamically modify it on the fly, such as to bypass anti-analysis logic (discussed in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>). Of course, some challenges temper these benefits. A debugger is a complex tool requiring specific, low-level knowledge; thus, completing an analysis can require a significant amount of time. However, once you understand debugger concepts and the techniques for debugging efficiently, a debugger will become your best malware analysis friend. Often it proves to be both the most efficient and comprehensive way to analyze any sample. </p>
<p>However, one word of caution that is worth reiterating. Dynamic analysis of a sample (which includes analysis within a debugger) involves executing the (potentially) malicious code, so it should always be performed on an isolated analysis system or virtual machine. The latter affords the benefit of snapshots, which allow you to easily revert if a debugging session of a malicious sample goes awry.</p>
<h2 id="h1-501942c08-0002">The LLDB Debugger</h2>
<p class="BodyFirst">In this chapter we’ll focus on using <em>LLDB</em>, the de facto tool for debugging programs, including malware, on macOS. Although other applications, such as Hopper, have built user-friendly interfaces on top of it, you’ll probably discover that directly interacting with LLDB’s command line interface is the most efficient approach. If you already have Apple’s Xcode installed, you’ll find LLDB installed alongside at <em>/usr/bin/lldb</em>. If not, you can install LLDB as a standalone program by entering <code>lldb</code> in the terminal and agreeing to the installation prompt. </p>
<p><span epub:type="pagebreak" id="Page_168" title="168"/>In this section we’ll look at various debugging concepts such as breakpoints and manipulating control flow, and I’ll illustrate how these can be applied via LLDB to facilitate the analysis of malicious software. It should be noted that the LLDB website provides a wealth of detailed knowledge, such as an in-depth tutorial.<sup class="endnote"><a href="#c08-endnote-1" id="c08-noteref-1">1</a></sup> Moreover, while debugging, you can always consult the LLDB <code>help</code> command for inline information about any command.</p>
<p>At a high level, a debugging session generally flows in the following manner: </p>
<ol class="decimal">
<li value="1">You initialize a debugger session by loading an item, such as a malicious sample, into the debugger. </li>
<li value="2">You set breakpoints at various locations in the sample’s code, such as at its main entry point or at method calls of interest. The sample is started and runs uninhibited until a breakpoint is encountered, at which point execution is halted.</li>
<li value="3">Once the debugger has halted execution, you are free to poke around, examining memory and register values, manipulating control flow, setting other breakpoints, and more.</li>
<li value="4">You can either resume execution until another breakpoint is hit or execute individual instructions one at a time. </li>
</ol>
<p>Remember that when a malicious sample is debugged, it is being allowed to execute. As such, always perform debugging in a virtual machine or a standalone analysis system. This ensures that no persistent damage occurs, and if you are debugging in a virtual machine, you can always revert it to a previous state. This is often quite useful during debugging sessions. For example, you might accidentally miss a breakpoint and run the malware in its entirety.</p>
<h3 id="h2-501942c08-0001">Starting a Debugger Session</h3>
<p class="BodyFirst">There are several ways to start a debugging session in LLDB. The simplest is to execute LLDB from the terminal, passing it the path of a binary to analyze, followed by any additional arguments (<a href="#listing8-3" id="listinganchor8-3">Listing 8-3</a>):</p>
<pre><code>% <b>lldb ~/Downloads/malware</b> <var class="bold">&lt;arg0 arg1 arg2&gt;</var><br/><br/>(lldb) <b>target create "malware"</b><br/>Current executable set to 'malware' (x86_64).</code></pre>
<p class="CodeListingCaption"><a id="listing8-3">Listing 8-3</a>: Starting a debugging session</p>
<p>As you can see, the debugger will display a target creation message, make note of the executable set to be debugged, and identify its architecture. Although LLDB has created the debugging session, it has not yet executed any of the program’s instructions. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" id="Page_169" title="169"/><h2><span class="NoteHead">Note</span></h2>
<p>	If you’re attempting to debug core operating system processes, you’ll likely fail due to macOS’s System Integrity Protection (SIP). To debug such processes, turn off SIP by executing <code>csrutil disable</code> from a terminal in macOS’s Recovery Mode.<sup class="endnote"><a href="#c08-endnote-2" id="c08-noteref-2">2</a></sup></p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>You can also attach LLDB to an instance of a running process as follows:</p>
<pre><code>% <b>lldb -pid</b><b> </b><var class="bold">&lt;target pid&gt;</var></code></pre>
<p>Once the debugger has attached to the process, a debugging session can commence. However, we rarely use this approach to analyze malware, because once the malware is already running, its core logic, which we are generally seeking to understand, may have already executed. Moreover, this logic could include anti-debugger code that prevents the debugger from attaching. </p>
<p>A third way of starting a debugging session is to run the <code>process attach</code> command with a process name and the <code>--waitfor</code> flag from the LLDB shell, as shown in <a href="#listing8-4" id="listinganchor8-4">Listing 8-4</a>. This instructs the debugger to wait for a process that matches this name and then attach as the process is starting. </p>
<pre><code>% <b>lldb</b><br/>(lldb) <b>process attach --name malware --waitfor</b></code></pre>
<p class="CodeListingCaption"><a id="listing8-4">Listing 8-4</a>: Waiting to attach to a process (named malware)</p>
<p>After attaching to the process, the debugger will pause execution. The output will look similar to <a href="#listing8-5" id="listinganchor8-5">Listing 8-5</a>:</p>
<pre><code>Process 14980 stopped<br/>* thread #1, queue = 'com.apple.main-thread', stop reason = signal SIGSTOP<br/>...<br/><br/>Executable module set to "~/Downloads/malware".<br/>Architecture set to: x86_64h-apple-macosx-.</code></pre>
<p class="CodeListingCaption"><a id="listing8-5">Listing 8-5</a>: Process attachment, triggered by the <code>--</code><code>waitfor</code> flag</p>
<p>The <code>--waitfor</code> flag is particularly useful when malware spawns other malicious processes that you’d like to debug as well. </p>
<h3 id="h2-501942c08-0002">Controlling Execution</h3>
<p class="BodyFirst">One of the most powerful aspects of a debugger is its ability to precisely control the execution of the process it is debugging. For example, you could instruct a process to execute a single instruction and then halt. <a href="#table8-1" id="tableanchor8-1">Table 8-1</a> describes several LLDB commands related to execution control.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table8-1">Table 8-1</a>: LLDB Commands for Controlling Execution<span epub:type="pagebreak" id="Page_170" title="170"/></p></figcaption>
<table border="1" id="table-501942c08-0001">
<thead>
<tr>
<td><b>LLDB command</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>run </code>(<code>r</code>)</td>
<td>Run the debugged process. Starts the execution, which will continue unabated until a breakpoint is hit, an exception is encountered, or the process terminates.</td>
</tr>
<tr>
<td><code>continue</code> (<code>c</code>)</td>
<td>Continue execution of the debugged process. Similar to the <code>run</code> command, it will continue execution until it reaches a breakpoint, an exception, or process termination.</td>
</tr>
<tr>
<td><code>nexti</code> (<code>n</code>)</td>
<td>Execute the next instruction, as pointed to by the program counter register, and then halt. This command will skip over function calls and repeated instructions. </td>
</tr>
<tr>
<td><code>stepi</code> (<code>s</code>)</td>
<td>Execute the next instruction, as pointed to by the program counter register, and halt. Unlike the <code>nexti</code> command, this command will step into function calls, allowing analysis of the called function.</td>
</tr>
<tr>
<td><code>finish</code> (<code>f</code>)</td>
<td>Execute the rest of the instructions in the current function (called a <em>frame</em>), return, and halt.</td>
</tr>
<tr>
<td><span class="KeyCaps">ctrl-c</span></td>
<td>Pause execution. If the process has been run (<code>r</code>) or continued (<code>c</code>), this will cause the process to halt wherever it is currently executing.</td>
</tr>
</tbody>
</table>
</figure>
<p>Notice that you can shorten the majority of LLDB commands to single or double letters. For example, you can enter <code>s</code> for the <code>stepi</code> command. Also note that LLDB includes several names for its commands in order to maintain backward compatibility with the GNU Project Debugger (GDB), a well-known predecessor to LLDB.<sup class="endnote"><a href="#c08-endnote-3" id="c08-noteref-3">3</a></sup> For example, to perform a single step, LLDB supports both <code>thread step-inst</code> and <code>step</code>, which matches GDB. For the sake of simplicity, this chapter describes the LLDB command names that are compatible with GDB.</p>
<p>While you could step through each of the binary’s executable instructions one at a time, doing so is tedious. On the other hand, instructing the debugger to run the malware uninhibited defeats the purpose of debugging in the first place. The solution is to use breakpoints.</p>
<h3 id="h2-501942c08-0003">Using Breakpoints</h3>
<p class="BodyFirst">A <em>breakpoint</em> is a command that instructs the debugger to halt execution at a specified location. You’ll often set breakpoints at the entry point of the binary, at method or function calls, or on the addresses of instructions of interest. You may have to first triage a binary via static analysis tools such as a disassembler in order to know exactly where to set such breakpoints. Once a breakpoint has been hit and the debugger has halted execution, you’ll be able to inspect the current state of the process, including its memory, the CPU register contents, call stacks, and more.</p>
<p>You can use the <code>breakpoint</code> command (or <code>b</code> for short) to set a breakpoint at a named location, such as a function or method name, or at an address. Behind the scenes, the debugger will transparently modify the process memory space to overwrite the byte at the specified location with <span epub:type="pagebreak" id="Page_171" title="171"/>a breakpoint instruction. On Intel x86_64 systems, this is the interrupt 3 instruction, whose value is <code>0xCC</code>. Once set, whenever the memory address containing the breakpoint is executed, the interrupt 3 will cause the CPU to return control to the debugger, which halts execution. Of course, if execution is continued, the debugger will first execute the original instruction (which was transparently overridden to set the breakpoint), such that normal program functionality is maintained. </p>
<p>Suppose we wanted to debug a malicious sample called <em>malware</em> and halt execution at its <code>main</code> function (<a href="#listing8-6" id="listinganchor8-6">Listing 8-6</a>). If the malware’s symbols were not stripped (that is, compiled with debugging symbols), we could start a debugging session and then enter the following to set a breakpoint by name.</p>
<pre><code>(lldb)<b> b main</b><br/>Breakpoint 1: where = malware`main, <br/>              address = 0x100004bd9</code></pre>
<p class="CodeListingCaption"><a id="listing8-6">Listing 8-6</a>: Setting a breakpoint on a program’s <code>main</code> function</p>
<p>With this breakpoint set, we can use the <code>run</code> command to instruct the debugger to run the debugged process. Execution will commence and then halt when it reaches the instruction at the start of the <code>main</code> function (<a href="#listing8-7" id="listinganchor8-7">Listing 8-7</a>):</p>
<pre><code>(lldb) <b>run</b><br/><br/>(lldb) Process 1953 stopped<br/>stop reason = breakpoint 1.1<br/>-&gt;  0x100004bd9 &lt;+0&gt;: pushq  %rbp</code></pre>
<p class="CodeListingCaption"><a id="listing8-7">Listing 8-7</a>: Breakpoint hit; execution halted</p>
<p>Often, though, the names of functions are not available in a compiled binary, so we must set breakpoints by specifying an address. You might also want to set a breakpoint at some address, say, within a function of interest. To set a breakpoint on an address, specify the hex address preceded by <code>0x</code>.</p>
<p>In the previous example, if the <code>main</code> function (found at <code>0x100004bd9</code>) had not been named, we could still set a breakpoint at its start as follows (<a href="#listing8-8" id="listinganchor8-8">Listing 8-8</a>):</p>
<pre><code>(lldb) <b>b 0x100004bd9</b><br/>Breakpoint 1: where = malware`__lldb_unnamed_symbol1$$malware, <br/>              address = 0x100004bd9</code></pre>
<p class="CodeListingCaption"><a id="listing8-8">Listing 8-8</a>: Setting a breakpoint by address</p>
<p>Luckily, a large percentage of Mac malware is written in Objective-C, meaning that, even in its compiled form, it will contain both class and method names. As such, we can also set breakpoints on these method names, or any Apple API it invokes, by passing the class and full method name to the <code>breakpoint</code> (<code>b</code>) command. </p>
<h4 id="h3-501942c08-0001"><span epub:type="pagebreak" id="Page_172" title="172"/>Setting Breakpoints on Method Names</h4>
<p class="BodyFirst">Recall that in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span> we leveraged the <code>class-dump</code><em/> tool to extract Objective-C class and method names. If you spot methods of interest, you can then set breakpoints upon them to take a closer look. For example, by running <code>class-dump</code> on the installer for malware known as FinFisher, we’ll find a method named <code>installPayload</code> in a class named <code>appAppDelegate</code>. Specifying the class and method name will allow us to set a breakpoint so that we can dynamically analyze how the malware persistently installs itself (<a href="#listing8-9" id="listinganchor8-9">Listing 8-9</a>): </p>
<pre><code>Target 0: (installer) stopped.<br/>(lldb) b -[appAppDelegate installPayload]<br/><br/>Breakpoint 1: where = installer`-[appAppDelegate installPayload], <br/>address = 0x000000010000336c</code></pre>
<p class="CodeListingCaption"><a id="listing8-9">Listing 8-9</a>: Setting a breakpoint on an <code>installPayload</code> method (FinFisher)</p>
<p>Note that setting breakpoints on Apple Objective-C methods can be somewhat nuanced due to various opaque compiler optimizations and abstractions. For example, imagine that, in a disassembler, you notice a malicious sample is invoking the Apple class <code>NSTask</code>’s launch method. You’d like to set a debugger breakpoint on this method so that the malware is halted when it attempts to launch an external command or program. However, at runtime, the launch method call will actually be handled not by the <code>NSTask</code> class but rather its subclass, <code>NSConcreteTask</code>. Thus, you actually have to set the breakpoint in the following manner: </p>
<pre><code>b -[NSConcreteTask launch]</code></pre>
<p>This might raise the following valid question: How do you know what class or subclass will actually handle a method? One approach is to track invocations of the <code>objc_msgSend</code> function (and its variants). As Objective-C calls are routed through this function at runtime, it is possible to uncover all classes and the methods they invoke. Shortly I’ll illustrate exactly how to do this via an LLDB debugger script. For an in-depth discussion of debugging Objective-C code, including more information on setting breakpoints, see Ari Grant’s excellent write-up “Dancing in the Debugger—A Waltz with LLDB.”<sup class="endnote"><a href="#c08-endnote-4" id="c08-noteref-4">4</a></sup></p>
<h4 id="h3-501942c08-0002">Conditionally Triggering a Breakpoint</h4>
<p class="BodyFirst">Often you’ll want a breakpoint to always trigger. Other times, it may be more efficient for them to trigger and halt the process only under certain conditions. Luckily, LLDB supports the notion of applying conditions to breakpoints. These conditions must evaluate to true for the breakpoint to trigger and halt the process. To add a condition to a breakpoint, use the <code>-c</code> flag and then specify the condition. For example, imagine that a malicious sample is sending encrypted data to a remote command and control server. <span epub:type="pagebreak" id="Page_173" title="173"/>In a debugger, we could set a breakpoint on the function responsible for encrypting the data prior to transmission in order to view its plaintext contents. Unfortunately, if the malware also sends small “heartbeat” messages at regular intervals, this will continually trigger our breakpoint. We most likely want to ignore such messages, as they contain no meaningful data and will slow down our analysis. </p>
<p>The solution? Adding a condition to the breakpoint! Specifically, we’ll instruct the breakpoint to only trigger if the size of the data being encrypted and exfiltrated is larger than the heartbeat message. For the sake of the example, let’s assume the message-encryption function takes, as its second argument, the size of the message (which can be found in the <code>$rsi</code> register) and that heartbeat messages are at most 128 bytes. To add this condition to breakpoint number 1, we would execute the commands in <a href="#listing8-10" id="listinganchor8-10">Listing 8-10</a>:</p>
<pre><code>(lldb) <b>br modify -c '$rsi &gt; 128' 1</b><br/>(lldb) <b>br list</b><br/>Current breakpoints:<br/>1: address = 0x100003d28, locations = 1, resolved = 1, hit count = 0<br/>Condition: $rsi  &gt; 128</code></pre>
<p class="CodeListingCaption"><a id="listing8-10">Listing 8-10</a>: Setting a conditional breakpoint</p>
<p>With such a conditional added to the breakpoint, the debugger will only halt when messages with data larger than 128 bytes are passed into the encryption and exfiltration function. Perfect! </p>
<h4 id="h3-501942c08-0003">Adding Commands to Breakpoints</h4>
<p class="BodyFirst">Usually we set a breakpoint and perform a deterministic action once it is hit. In the previous example, we’ll likely always want to print out unencrypted data to see what the malware is about to exfiltrate. While we could perform this action manually each time the breakpoint is hit, it may be more efficient to add what is known as a <em>command</em> to the breakpoint. This command, which consists of one or more debugger commands, will be automatically executed each time the breakpoint is hit. To add one to a breakpoint, use <code>breakpoint command add</code> and specify the breakpoint by number. Following this, specify the commands to be executed, and then enter <code>DONE</code>. Keeping with the previous example, let’s assume the message-encryption function takes as its first argument the plaintext contents of the message (which can be found in the <code>RDI</code> register). To add a breakpoint action to print this out, we’ll use the <code>print object</code> (<code>po</code>) command (discussed later in this chapter). We’ll also tell the debugger to then simply continue (<a href="#listing8-11" id="listinganchor8-11">Listing 8-11</a>): </p>
<pre><code>(lldb) <b>breakpoint command add 1</b><br/>Enter your debugger command(s).  Type 'DONE' to end.<br/>&gt; <b>po $rdi</b><br/>&gt; <b>continue </b><br/>&gt; <b>DONE</b></code></pre>
<p class="CodeListingCaption"><a id="listing8-11">Listing 8-11</a>: Adding breakpoint commands</p>
<p><span epub:type="pagebreak" id="Page_174" title="174"/>Now, whenever this breakpoint is hit, the debugger will print out the plaintext message passed to the function and then merrily continue on its way. We can simply sit back and watch. </p>
<h4 id="h3-501942c08-0004">Managing Breakpoints</h4>
<p class="BodyFirst">The LLDB debugger also supports various commands to manage breakpoints. Breakpoints can be set, modified, deleted, enabled, disabled, or listed using the commands described in <a href="#table8-2" id="tableanchor8-2">Table 8-2</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table8-2">Table 8-2</a>: LLDB Commands for Managing Breakpoints</p></figcaption>
<table border="1" id="table-501942c08-0002">
<thead>
<tr>
<td><b>LLDB command</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>breakpoint </code>(<code>b</code>) <var>&lt;function/method name&gt;</var></td>
<td>Set a breakpoint on a specified function or method name.</td>
</tr>
<tr>
<td><code>breakpoint </code>(<code>b</code>) 0x<var>&lt;address&gt;</var></td>
<td>Set a breakpoint on an instruction at a specified memory address.</td>
</tr>
<tr>
<td><code>breakpoint list</code> (<code>br l</code>)</td>
<td>Display all current breakpoints, including their numbers.</td>
</tr>
<tr>
<td><code>breakpoint enable</code>/<code>disable</code> <var>&lt;number&gt;</var> (<code>br e/dis</code>)</td>
<td>Enable or disable a breakpoint (specified by number).</td>
</tr>
<tr>
<td><code>breakpoint modify </code><var>&lt;modifications&gt;</var> <var>&lt;number&gt;</var><code> (br mod)</code></td>
<td>Modify the options on a breakpoint (specified by number).</td>
</tr>
<tr>
<td><code>breakpoint delete</code> <var>&lt;number&gt; </var>(<code>br del</code>)</td>
<td>Delete a breakpoint (specified by number).</td>
</tr>
</tbody>
</table>
</figure>
<p>Running the <code>help</code> command with the <code>breakpoint</code> parameter provides a comprehensive list of breakpoint-related commands, including those mentioned in <a href="#table8-2">Table 8-2</a>. </p>
<pre><code>(lldb) <b>help breakpoint</b><br/>Syntax: breakpoint <var>&lt;subcommand&gt;</var> [<var>&lt;command-options&gt;</var>]</code></pre>
<p>For more information on the breakpoint commands supported by LLDB, see the tool’s documentation on the topic.<sup class="endnote"><a href="#c08-endnote-5" id="c08-noteref-5">5</a></sup></p>
<h3 id="h2-501942c08-0004">Examining All the Things</h3>
<p class="BodyFirst">Once you’ve halted execution, you can instruct the debugger to display many things, including the values of CPU registers, the contents of the process memory, or other process state information such as the current call stack. This powerful capability allows you to examine runtime information that often isn’t directly available during static analysis. For example, in the case study at the beginning of this chapter, we were able to view the malware’s decrypted in-memory configuration information.</p>
<p>To dump the contents of the CPU registers, use the <code>register read</code> command (or the shortened <code>reg r</code>). To view the value of a specific register, pass in the register name as the final parameter: </p>
<pre><code>(lldb) <b>reg read rax</b><br/>rax = 0x0000000000000000</code></pre>
<p><span epub:type="pagebreak" id="Page_175" title="175"/>Often we’re also interested in what the registers point to. That is to say, we’d like to examine the contents of actual memory addresses. The <code>memory read</code> or GDB-compatible <code>x</code> command can be used to read the contents of memory. Note that these instructions both require register names to be prefixed with <code>$</code>; for example, <code>$rax</code>.</p>
<p>But unless we explicitly specify a format for the data, LLDB will print out the raw hex bytes. <a href="#table8-3" id="tableanchor8-3">Table 8-3</a> lists a variety of format specifiers that instruct LLDB to treat the memory address as a string, instructions, or byte.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table8-3">Table 8-3</a>: LLDB Commands for Displaying Memory Contents</p></figcaption>
<table border="1" id="table-501942c08-0003">
<thead>
<tr>
<td><b>LLDB command</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>x/s</code> <var>&lt;register or memory address&gt;</var></td>
<td>Display the memory as a null-terminated string.</td>
</tr>
<tr>
<td><code>x/i</code> <var>&lt;register or memory address&gt;</var></td>
<td>Display the memory as an assembly instruction.</td>
</tr>
<tr>
<td><code>x/b</code> <var>&lt;register or memory address&gt;</var></td>
<td>Display the memory as a byte.</td>
</tr>
</tbody>
</table>
</figure>
<p>You can also specify the number of items to display by adding a numerical value after the <code>/</code>. For example, to disassemble 10 instructions, starting at the current location of the instruction pointer (<code>RIP</code>), enter <code>x/10i $rip</code>. </p>
<p>The LLDB debugger also supports the <code>print</code> command. When executed with a register or memory address, it will display the contents at the specified location. You can also specify a typecast to instruct the <code>print</code> command to format the data. For example, if the <code>RSI</code> register points to a null-terminated string, you can display this by typing <code>print (char*)$rsi</code>.</p>
<p>The <code>print</code> command can also be executed with the <code>object</code> specifier. This can be used to print out the contents (or <em>description</em>, in Objective-C parlance) of any Objective-C object. For instance, consider the example presented at the start of the chapter. Within the <code>setDefaultConfiguration</code> method, the Mami malware decrypts its configuration information into an Objective-C object referenced by the <code>RAX</code> register. Thus, using the <code>print object</code> command, we can print the verbose description of the object, including all of its key/value pairs (<a href="#listing8-12" id="listinganchor8-12">Listing 8-12</a>):</p>
<pre><code>(lldb) <b>print object $rax</b><br/>{<br/> "dnsChanger" =  {<br/>   "affiliate" = "";<br/>   "blacklist_dns" = ();<br/>   "encrypt" = true;<br/>   "external_id" = 0;<br/>   "product_name" = dnsChanger;<br/>   "publisher_id" = 0;<br/><br/>    ...<br/>   "setup_dns" =         (<br/>      "82.163.143.135",<br/>      "82.163.142.137"<br/>    );<br/>    "shared_storage" = "/Users/%USER_NAME%/Library/Application Support";<br/>    "storage_timeout" = 120;<br/><span epub:type="pagebreak" id="Page_176" title="176"/>   };<br/> "installer_id" = 1359747970602718687;<br/> ...<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing8-12">Listing 8-12</a>: Printing a dictionary object (Mami)</p>
<p>You might be wondering how, given an arbitrary value or address, you can decide which display command to use. That is to say, how do you know if the address is a pointer to an Objective-C object, a string, or a sequence of instructions? If the value to display is a parameter or return value from a documented API, its type will be noted in its documentation. For example, most of Apple’s Objective-C APIs or methods return objects, which should be displayed using the <code>print object</code> command. However, if no context is available, the disassembly of the binary may provide some insight, or trial and error could suffice. For example, if the <code>print object</code> command doesn’t produce meaningful output, perhaps try <code>x/b</code> to dump the contents of the specified data as raw hex bytes.</p>
<p>The <code>backtrace</code> (or <code>bt</code>) debugger command, which prints a sequence of stack frames, is another useful debugging command for examining the process. When a breakpoint is hit, we’re often interested in determining the program flow up to that point. For example, imagine we’ve set a breakpoint on a malware’s string-decryption function, which may have been invoked in multiple places in the malicious code to decrypt embedded strings. When the breakpoint triggers, we’d like to know the location of the caller, that is, the address of the code responsible for invoking the function. This can be accomplished via <code>backtrace</code>. Whenever a function is called, a stack frame will be created on the call stack—this contains the address that the process will return to once the function is done, among other things. As the return address is the address of the instruction immediately following the call, we can check it to accurately determine the address of the caller. Moreover, as the backtrace contains previous stack frames as well, the entire function call hierarchy can be reconstructed. If you’re interested in learning more about backtraces and call stacks, see Apple’s write-up “Examining the Call Stack.”<sup class="endnote"><a href="#c08-endnote-6" id="c08-noteref-6">6</a></sup></p>
<h3 id="h2-501942c08-0005">Modifying Process State</h3>
<p class="BodyFirst">Normally, a debugging session is rather passive once you’ve set your breakpoints to halt execution. However, you can interact with a process by directly modifying its state or even its control flow. This is especially useful when analyzing a malicious specimen that implements anti-debugging logic, a topic discussed in the next chapter. </p>
<p>Once you’ve located anti-analysis logic, one option is to instruct the debugger to simply skip over the code by modifying the instruction pointer. In some cases, you can also overcome such anti-analysis code by simply changing the value of a register. For example, modifying the <code>RAX</code> register can subvert the value returned by a function.</p>
<p>The most common way to modify the state of the binary is to change either CPU register values or the contents of memory. The <code>register write</code> <span epub:type="pagebreak" id="Page_177" title="177"/>command can be used to change values of the former, while the <code>memory write</code> command modifies the latter. </p>
<p>The <code>register write</code> (or <code>reg write</code>) command takes two parameters: the target register and its new value. Let’s see exactly how we can leverage this to wholly bypass the anti-analysis logic found in a widespread adware installer. In <a href="#listing8-13" id="listinganchor8-13">Listing 8-13</a>, we first use the <code>x</code> command with the <code>2i</code> and the program counter register (<code>RIP</code>) to display the next two instructions to be executed. The call instruction at <code>0x100035cbe</code> will trigger anti-debugging logic. (The details of this logic are not pertinent for this example.) </p>
<pre><code>(lldb) <b>x/2i $rip</b> <br/>0x100035cbe: ff d0 callq *%rax<br/>0x100035cc0: 48 83 c4 10 addq $0x10, %rsp<br/><br/>(lldb) <b>register write $rip 0x100035CC0</b> <br/><br/>(lldb) <b>x/i $rip</b> <br/>0x100035cc0: 48 83 c4 10 addq $0x10, %rsp</code></pre>
<p class="CodeListingCaption"><a id="listing8-13">Listing 8-13</a>: Modifying the instruction pointer </p>
<p>In order to bypass the call to the anti-debugging logic, we use LLDB’s <code>register write</code> command to modify the instruction pointer (<code>RIP</code>) to point to the next instruction (at <code>0x100035cc0</code>). Redisplaying the value of the instruction pointer confirms it has been successfully updated. After this modification, the problematic call at address <code>0x100035cbe</code> is never invoked; thus, the malware’s anti-debugger logic is never executed, and our debugging session can continue unimpeded. Moreover, the malware is generally none the wiser.</p>
<p>There are other reasons to modify CPU register values to influence the debugged process. For example, imagine a piece of malware that attempts to connect to a remote command and control server before persistently installing itself. If the server is offline but we want the malware to continue to execute so we can observe how it installs itself, we may have to modify a register that contains the result of this connection check. As the return value from a function call is stored in the <code>RAX</code> register, this may involve setting the value of <code>RAX</code> to <code>1</code> (true), causing the malware to believe the connection check succeeded (<a href="#listing8-14" id="listinganchor8-14">Listing 8-14</a>):</p>
<pre><code>(lldb) <b>reg write $rax 1</b></code></pre>
<p class="CodeListingCaption"><a id="listing8-14">Listing 8-14</a>: Modifying a register</p>
<p>Easy peasy! </p>
<p>We can change the contents of any writable memory with the <code>memory write</code> command. During malware analysis, this command could be useful to change the default values of an encrypted configuration file that are only decrypted in memory. Such a configuration may include a trigger date, which instructs the malware to remain dormant until the date is encountered. To coerce immediate activity so you can observe the malware’s full behavior, you could directly modify the trigger date in memory to the current time. </p>
<p><span epub:type="pagebreak" id="Page_178" title="178"/>As another example, the <code>memory write</code> command could be used to modify the memory that holds the address of a malicious sample’s remote command and control server. This provides a simple and non-destructive way for an analyst to specify an alternate server, such as one under their control. Being able to modify the address of a malware’s command and control server or specify an alternate server has its perks. In a research paper titled “Offensive Malware Analysis: Dissecting OSX/FruitFly.b Via a Custom C&amp;C Server,” I illustrated how malware connecting to an alternate server under an analyst’s control could be tasked to reveal its capabilities.<sup class="endnote"><a href="#c08-endnote-7" id="c08-noteref-7">7</a></sup></p>
<p>The format of the <code>memory write</code> command is described by LLDB’s <code>help</code> command. The simplest way to leverage <code>memory write</code> is with:</p>
<ul>
<li>The memory address to modify</li>
<li>The <code>-s</code> flag and optionally a number (to specify the number of bytes to modify if the default of 1 byte does not suffice) </li>
<li>The value of the bytes to write to memory</li>
</ul>
<p>For example, to change the memory at address <code>0x100100000</code> to <code>0x41414141</code>, you would run the following: </p>
<pre><code>(lldb) <b>memory write 0x100100000 -s 4 0x41414141</b></code></pre>
<p>The modification can then be confirmed with the <code>memory read</code> command:</p>
<pre><code>(lldb) <b>memory read 0x100100000</b><br/>0x100100000: 41 41 41 41 00 00 00 00 00 00 00 00 00 00 00 00  AAAA...</code></pre>
<h2 id="h1-501942c08-0003">LLDB Scripting</h2>
<p class="BodyFirst">One of the more powerful features of LLDB is its support for debugging scripts, which allow you to extend the capabilities of the debugger or simply automate repetitive tasks. Let’s walk through an example of building a simple debugger script to illustrate important concepts and show how such a script can improve your dynamic malware analysis. </p>
<p>Earlier in this chapter, I mentioned how tracking invocations of the <code>objc_msgSend</code> function can reveal the majority of the Objective-C calls made by the process. When analyzing malware, this can provide valuable insight into the functionality of a specimen, as well as drive subsequent analysis. One naive approach to monitoring calls to the <code>objc_msgSend</code> function is simply setting a breakpoint on the function. Yes, this will halt the process and allow you to examine the function’s arguments, which include both class and method names. However, as you’ll quickly see, this approach is very inefficient, and the many, many calls to the <code>objc_msgSend</code> function will become overwhelming. </p>
<p>A more efficient approach is to create a debugger script that will automatically set a breakpoint, attach a command to print out the Objective-C <span epub:type="pagebreak" id="Page_179" title="179"/>class and method names, and then allow the process to continue. Debugger scripts for LLDB are written in Python and loaded via the debugger command <code>command script import </code><var>&lt;path to script&gt;</var>. These scripts should import the LLDB module so that the LLDB API can be accessed by the rest of the Python code. For more information on this API, see the official LLDB documentation: “Python Reference.”<sup class="endnote"><a href="#c08-endnote-8" id="c08-noteref-8">8</a></sup></p>
<p>More often than not, you’ll want your script to automatically perform an action once it’s loaded (such as setting a breakpoint). To facilitate this, LLDB provides the <code>__lldb_init_module</code> convenience function, which if it’s implemented in your debugger script will be automatically invoked whenever the script is loaded. In our debugger script, we’ll use this function to set a breakpoint and breakpoint callback (<a href="#listing8-15" id="listinganchor8-15">Listing 8-15</a>):</p>
<pre><code>import lldb<br/><br/>def __lldb_init_module(debugger, internal_dict):<br/>    target = debugger.GetSelectedTarget()<br/>    breakpoint = target.BreakpointCreateByName("objc_msgSend")<br/>    breakpoint.SetScriptCallbackFunction('objc.msgSendCallback')</code></pre>
<p class="CodeListingCaption"><a id="listing8-15">Listing 8-15</a>: Setting a breakpoint via a debugger script</p>
<p>First, our code gets a reference to the process that is running within the debugger. With this reference, we can then invoke the <code>BreakpointCreateByName</code> function to set a breakpoint on the <code>objc_msgSend</code> function. Finally, we attach our callback function with a call to the <code>SetScriptCallbackFunction</code> function. Note that the parameter to this function is your module or script’s name, followed by a period and the name of the callback (for example, <code>objc.msgSendCallback</code>). </p>
<p>Now, whenever the <code>objc_msgSend</code> function is invoked, our callback, <code>msgSendCallback</code>, will be invoked. In this callback, we simply want to print out the Objective-C class and method name that is being invoked, before allowing the debugged process to continue. Recall that, in previous discussions of the <code>objc_msgSend</code> function, we noted that its first parameter is the Objective-C class name, while the second is the method name. We also know that on Intel x86_64 platforms, the first two parameters will be passed in the <code>RDI</code> and <code>RSI</code> registers, respectively. This means we can implement our callback in the following manner (<a href="#listing8-16" id="listinganchor8-16">Listing 8-16</a>): </p>
<pre><code>def msgSendCallback(frame, bp_loc, dict):<br/>    lldb.debugger.HandleCommand('po [$rdi class]')<br/>    lldb.debugger.HandleCommand('x/s $rsi')<br/><br/>    frame.thread.process.Continue()</code></pre>
<p class="CodeListingCaption"><a id="listing8-16">Listing 8-16</a>: Implementing a breakpoint action via a debugger script</p>
<p>In order to execute built-in debugger commands, we can use the <code>HandleCommand</code> API. First, we print out the name of the Objective-C class that <span epub:type="pagebreak" id="Page_180" title="180"/>can be found within the <code>RDI</code> register. We make use of the <code>po</code> (<code>print object</code>) command, because the class name we want to display is an Objective-C string object. Following this, we print out the method’s name stored in the <code>RSI</code> register. As it is a null-terminated C string, the <code>x/s</code> command suffices for this purpose. Then we instruct the debugger to continue, so the debugged process can resume. </p>
<p>We can save the code in Listings 8-15 and 8-16 (for example, to <em>~/objc.py</em>), load it into a debugger, and then execute a malicious sample we’re interested in further analyzing (<a href="#listing8-17" id="listinganchor8-17">Listing 8-17</a>): </p>
<pre><code>(lldb) <b>command script import ~/objc.py</b><br/><br/>(lldb) <b>NSTask</b><br/>0x1d8dcd07c: "alloc"<br/><br/>(lldb) <b>NSConcreteTask</b><br/>0x1d8dccbdd: "init"<br/><br/>(lldb) <b>NSConcreteTask</b><br/>0x1d8e1b67a: "setLaunchPath:"<br/><br/>(lldb) <b>NSConcreteTask</b><br/>0x1d8e1b771: "launch"</code></pre>
<p class="CodeListingCaption"><a id="listing8-17">Listing 8-17</a>: Our debugger script in action</p>
<p>From the output of our script, we see that the malware is leveraging the <code>NSTask</code> class. Behind the scenes, we see that a <code>NSConcreteTask</code> is initialized, a launch path is set, and then the task is launched. To investigate further, we can now manually set a breakpoint on the <code>NSConcreteTask</code>’s <code>launch</code> method to see exactly what the malware is executing. </p>
<p>LLDB debugger scripts are a powerful way to extend the debugger and provide an invaluable capability, especially when analyzing more sophisticated malware samples. Here we’ve only scratched the surface of what they can do through a trivial, albeit useful, example. To learn more, consult online examples, such as Taha Karim’s script to automatically dump the Bundlore malware’s payload.<sup class="endnote"><a href="#c08-endnote-9" id="c08-noteref-9">9</a></sup> These examples highlight more advanced use cases while also providing valuable insight into LLDB’s scripting API.</p>
<h2 id="h1-501942c08-0004">A Sample Debugging Session: Uncovering Hidden Cryptocurrency Mining Logic in an App Store Application</h2>
<p class="BodyFirst">In early 2018, a popular application called Calendar 2, found in Apple’s official Mac App Store, was discovered to contain logic that surreptitiously mined cryptocurrency on users’ computers (<a href="#figure8-1" id="figureanchor8-1">Figure 8-1</a>). Though it isn’t exactly malware per se, this application provides an illustrative case study of how a debugger can help us understand a binary’s hidden or subversive capabilities. Moreover, due to the rise of malicious crytocurrency miners targeting macOS, this example is particularly relevant.</p>
<span epub:type="pagebreak" id="Page_181" title="181"/><figure>
<img alt="Calendar 2 is on the Mac App Store. It’s by Qbix, Inc., has 2/5 stars and 29 ratings, and is stated as “Free” but “Offers In-App Purchases.”" class="keyline" src="image_fi/501942c08/f08001.png"/>
<figcaption><p><a id="figure8-1">Figure 8-1</a>: A surreptitious cryptocurrency miner in Apple’s official Mac App Store</p></figcaption>
</figure>
<p>During my initial static analysis triage, I uncovered various methods whose names referenced cryptocurrency mining (<a href="#listing8-18" id="listinganchor8-18">Listing 8-18</a>). This was odd, as the application claimed to simply be a calendar application.</p>
<pre><code>/* @class MinerManager */<br/>-(void)runMining {<br/>    rdx = self-&gt;_coreLimit;<br/>    r14 = [self calculateWorkingCores:rdx];<br/>    [Coinstash_XMRSTAK9Coinstash setCPULimit:self-&gt;_cpuLimit];<br/>    r15 = [self getPort];<br/>    r12 = [self algorythm];<br/>    [self getSlotMemoryMode];<br/><br/>    [Coinstash_XMRSTAK9Coinstash startMiningWithPort:r15 <br/>                                 password:self-&gt;_token <br/>                                 coreCount:r14<br/>                                 slowMemory:self-&gt;_slowMemoryMode<br/>                                 currency:r12];<br/>    ...<br/><br/>    return;<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing8-18">Listing 8-18</a>: Cryptocurrency mining logic within an App Store application?</p>
<p>In this listing, we can see a method named <code>runMining</code> that contains code that invokes methods in a framework named <code>Coinstash_XMRSTAK</code>. As the framework is written in Swift, the method names are slightly mangled, though still mostly readable. </p>
<p>One of the goals of the subsequent dynamic analysis was to uncover information about the cryptocurrency account, where any mined coins were to be sent. Based on the method names (such as <code>startMiningWithPort</code>, <code>:password:</code> and so on), I reasoned that, in a debugging session, setting a breakpoint on either of the methods would reveal this information. </p>
<p><span epub:type="pagebreak" id="Page_182" title="182"/>After firing up LLDB and loading the application, we can set a breakpoint on the <code>runMining</code> method by name, as shown in <a href="#listing8-19" id="listinganchor8-19">Listing 8-19</a>:</p>
<pre><code>% <b>lldb CalendarFree.app</b><br/>(lldb) <b>target create "CalendarFree.app"</b><br/>Current executable set to 'CalendarFree.app' (x86_64).<br/><br/>(lldb) <b>b -[MinerManager runMining]</b><br/>Breakpoint 1: where = CalendarFree`-[MinerManager runMining], <br/>              address = 0x0000000100077fc0</code></pre>
<p class="CodeListingCaption"><a id="listing8-19">Listing 8-19</a>: Initializing a debugging session and setting an initial breakpoint</p>
<p>Once the breakpoint is set, we instruct the debugger to run the application. As expected, it halts at the breakpoint we set (<a href="#listing8-20" id="listinganchor8-20">Listing 8-20</a>):</p>
<pre><code>(lldb) <b>r</b><br/>Process 782 launched: 'CalendarFree.app/Contents/MacOS/CalendarFree' (x86_64)<br/><br/>CalendarFree[782:7349] Miner: Stopped<br/>Process 782 stopped<br/> stop reason = breakpoint 1.1<br/> <br/>CalendarFree`-[MinerManager runMining]:<br/>-&gt;  0x100077fc0 &lt;+0&gt;: pushq  %rbp<br/>    0x100077fc1 &lt;+1&gt;: movq   %rsp, %rbp<br/>    0x100077fc4 &lt;+4&gt;: pushq  %r15<br/>    0x100077fc6 &lt;+6&gt;: pushq  %r14</code></pre>
<p class="CodeListingCaption"><a id="listing8-20">Listing 8-20</a>: Breakpoint hit; execution halted</p>
<p>Let’s step through the instructions until we reach the call to the Coinstash <code>startMiningWithPort:... </code>method. As its name suggests, it begins the actual mining. Because we want to step over the other method calls prior to reaching it, we use the <code>nexti</code> (or <code>n</code>) command (<a href="#listing8-21" id="listinganchor8-21">Listing 8-21</a>). This allows the calls to execute but avoids us having to step through them, instruction by instruction. </p>
<pre><code>(lldb) <b>n</b><br/><br/>Process 782 stopped<br/> stop reason = instruction step over<br/><br/>CalendarFree`-[MinerManager runMining] + 35:<br/>-&gt;  0x100077fe3 &lt;+35&gt;: movq 0xaa3d6(%rip), %r13   ;0x00007fff58acba00: objc_msgSend</code></pre>
<p class="CodeListingCaption"><a id="listing8-21">Listing 8-21</a>: Stepping through instructions and over method calls</p>
<p>Eventually we approach the invocation of the method of interest. Recall that, in assembly, Objective-C calls are routed through the <code>objc_msgSend</code> function. In the debugger, we first see this function’s address being moved into the <code>R13</code> register. Though we could just set a breakpoint on the call to the <code>objc_msgSend</code> function (at address <code>0x100078067</code>) that invokes the <code>startMiningWithPort:...</code> <span epub:type="pagebreak" id="Page_183" title="183"/>method, we’ll take a more exhaustive approach and continue stepping, instruction by instruction, until the call has been reached (<a href="#listing8-22" id="listinganchor8-22">Listing 8-22</a>):</p>
<pre><code>(lldb) <b>n</b><br/><br/>Process 782 stopped<br/> stop reason = instruction step over<br/><br/>CalendarFree`-[MinerManager runMining] + 167:<br/>-&gt;  0x100078067 &lt;+167&gt;: callq  *%r13<br/><br/>(lldb) <b>reg read $r13</b><br/>r13 = 0x00007fff58acba00  libobjc.A.dylib`objc_msgSend </code></pre>
<p class="CodeListingCaption"><a id="listing8-22">Listing 8-22</a>: Stepping through instructions until the call of interest is reached</p>
<p>Note that, via the <code>reg read</code> command, we confirmed that the <code>R13</code> register indeed contains the <code>objc_msgSend</code> function.</p>
<p>Recall from <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span> that, at the time of a call to the <code>objc_msgSend</code> function, certain registers hold specific argument values by convention.<b> </b>For example, the function’s first argument (held in the <code>RDI</code> register) is the class or object upon which the method is being invoked. During the static analysis triage, this was identified as a class named <code>Coinstash_XMRSTAK.Coinstash</code>. Using the <code>print object</code> (<code>po</code>) command, we can dynamically see that this is indeed correct:</p>
<pre><code>(lldb) <b>po $rdi</b><br/>Coinstash_XMRSTAK.Coinstash</code></pre>
<p>The second argument (held in the <code>RSI</code> register) will be a null-terminated string that names the method to be invoked. Let’s confirm this is the case, and that its value is the <code>startMiningWithPort:...</code> method. To print out a null-terminated string, we use the <code>x</code> command with the <code>s</code> format specifier:</p>
<pre><code>(lldb) <b>x/s $rsi</b><br/>0x1000f1576: "startMiningWithPort:password:coreCount:slowMemory:currency:"</code></pre>
<p>Following the class and method name are the method’s arguments. From the method’s name, we can gather it takes five arguments that include a port, password, and currency. We couldn’t easily figure out the values of these arguments using static analysis methods, such as a disassembler, because they didn’t readily appear. With the debugger, it’s a breeze. </p>
<p>We know that the next arguments are stored in the <code>RDX</code>, <code>RCX</code>, <code>R8</code>, and <code>R9</code> registers, as specified in the application binary interface. As this method takes more than four arguments, the last argument will be found on the stack (<code>RSP</code>). Let’s have a peek (<a href="#listing8-23" id="listinganchor8-23">Listing 8-23</a>):</p>
<pre><code>(lldb) <b>po $rdx</b><br/>7777<br/><br/>(lldb) <b>po $rcx</b><br/>qbix:greg@qbix.com<br/><br/><span epub:type="pagebreak" id="Page_184" title="184"/>(lldb) <b>reg read $r8</b><br/>r8 = 0x0000000000000001<br/><br/>(lldb) <b>po $r9</b><br/>always<br/><br/>(lldb) <b>x/s $rsp</b><br/>0x7ffeefbfe0d0: "graft"</code></pre>
<p class="CodeListingCaption"><a id="listing8-23">Listing 8-23</a>: Displaying the <code>startMiningWithPort:</code><code>...</code> method’s parameters</p>
<p>Note that for the arguments that are objects, we use the <code>po</code> command to display their contents. For those that aren’t, we use the other appropriate display commands, such as <code>reg read $r8</code><b> </b>to view the contents of a register and <code>x/s</code> to display a NULL-terminated string. </p>
<p>By examining the arguments, we’ve uncovered the port (<code>7777</code>), the account password (<code>qbix:greg@qbix.com</code>), cryptocurrency (<code>graft</code>), and more! Moreover, if we continue our debugging session, we’ll encounter additional data, for example, within a <code>NSURLRequest</code> object (which in this debugging session is found in memory at 0x1018f04e0). In the debugger, in conjunction with the <code>po</code> command, we can invoke the <code>NSURLRequest</code>’s <code>HTTPBody</code> method on the object <span aria-label="annotation1" class="CodeAnnotation">1</span> to display the contents (specifically the body), of this network request. This reveals detailed account information and cryptomining statistics (<a href="#listing8-24" id="listinganchor8-24">Listing 8-24</a>): </p>
<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">1</span> (lldb) <b>po [0x1018f04e0 HTTPBody]</b><br/>{<br/>  "mining": {<br/>    "statistic": {<br/>      "ZeroCounter": 0,<br/>      "AverageHashRate": 0.92911845445632935,<br/>      "CounterTime": 30,<br/>    },<br/>    "params": {<br/>      "Token": "qbix:greg@qbix.com",<br/>      "Algorithm": "graft",<br/>      "CPULimit": 25,<br/>      "EnableMiningMode": true,<br/>      "CPUBatteryLimit": 10,<br/>      "CoreLimit": 25,<br/>      "Ports": {<br/>        "7777": 1000000,<br/>        "5555": 160,<br/>        "3333": 40<br/>      }<br/>    }<br/>  },<br/>  ...<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing8-24">Listing 8-24</a>: Displaying a network object containing cryptocurrency miner account information and statistics </p>
<p>It is also worth noting that, as this information is securely transmitted over the network (encrypted), it would have been rather involved to recover <span epub:type="pagebreak" id="Page_185" title="185"/>it via a simple network monitor. Via the debugger, it was relatively straightforward. If you’re interested in the full analysis of this application, including more details on the use of a debugger to uncover and understand its cryptomining logic, see my write-up “A Surreptitious Cryptocurrency Miner in the Mac App Store?”<sup class="endnote"><a href="#c08-endnote-10" id="c08-noteref-10">10</a></sup></p>
<h2 id="h1-501942c08-0005">Up Next</h2>
<p class="BodyFirst">In this chapter I introduced the debugger, the most thorough tool for analyzing even complex malware threats. Specifically, I showed how to debug a binary via breakpoints, instruction by instruction, while examining or modifying registers and memory contents, skipping functions you don’t want to execute, and much more. Now that you’re armed with this analysis capability, malware doesn’t stand a chance. </p>
<p>Of course, malware authors are less than stoked that their malicious creations can be deconstructed so easily. In the next chapter, we’ll dive into the kinds of anti-analysis logic employed by malware authors to thwart (or at least complicate) both static and dynamic analysis efforts.</p>
<h2 id="h1-501942c08-0006">Endnotes</h2>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c08-noteref-1" id="c08-endnote-1">1</a></sup>	“LLDB Tutorial,” <em>LLDB Debugger</em>, <a class="LinkURL" href="https://lldb.llvm.org/use/tutorial.html">https://lldb.llvm.org/use/tutorial.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c08-noteref-2" id="c08-endnote-2">2</a></sup>	“Disabling and Enabling System Integrity Protection,” <em>Apple Developer Documentation</em>, <a class="LinkURL" href="https://developer.apple.com/documentation/security/disabling_and_enabling_system_integrity_protection/">https://developer.apple.com/documentation/security/disabling_and_enabling_system_integrity_protection/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c08-noteref-3" id="c08-endnote-3">3</a></sup>	“GDB to LLDB command map,” <em>LLDB Debugger</em>, <a class="LinkURL" href="https://lldb.llvm.org/use/map.html">https://lldb.llvm.org/use/map.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c08-noteref-4" id="c08-endnote-4">4</a></sup>	Ari Grant, “Dancing in the Debugger—A Waltz with LLDB,” <em>Objc</em>, <a class="LinkURL" href="https://www.objc.io/issues/19-debugging/lldb-debugging/">https://www.objc.io/issues/19-debugging/lldb-debugging/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c08-noteref-5" id="c08-endnote-5">5</a></sup>	“LLDB Tutorial: Setting Breakpoints,” <em>LLDB Debugger</em>, <a class="LinkURL" href="https://lldb.llvm.org/use/tutorial.html#setting-breakpoints/">https://lldb.llvm.org/use/tutorial.html#setting-breakpoints/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c08-noteref-6" id="c08-endnote-6">6</a></sup>	“Examining the Call Stack,” <em>Apple Developer Documentation Archive</em>, <a class="LinkURL" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/lldb-guide/chapters/C5-Examining-The-Call-Stack.html">https://developer.apple.com/library/archive/documentation/General/Conceptual/lldb-guide/chapters/C5-Examining-The-Call-Stack.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c08-noteref-7" id="c08-endnote-7">7</a></sup>	Patrick Wardle, “Offensive Malware Analysis: Dissecting OSX/FruitFly.b Via A Custom C&amp;C Server,” <em>Virus Bulletin Conference</em>, October 2017, <a class="LinkURL" href="https://www.virusbulletin.com/uploads/pdf/magazine/2017/VB2017-Wardle.pdf">https://www.virusbulletin.com/uploads/pdf/magazine/2017/VB2017-Wardle.pdf</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c08-noteref-8" id="c08-endnote-8">8</a></sup>	“Python Reference,” <em>LLDB Debugger</em>, December 2014, <a class="LinkURL" href="https://lldb.llvm.org/use/python-reference.html">https://lldb.llvm.org/use/python-reference.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c08-noteref-9" id="c08-endnote-9">9</a></sup>	OSX/Bundlore Payload Dumper (bundlore_python_dump2.py), <a class="LinkURL" href="https://gist.github.com/tahaconfiant/36bd7594f094e4d1b2afc14264f923dc/">https://gist.github.com/tahaconfiant/36bd7594f094e4d1b2afc14264f923dc/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c08-noteref-10" id="c08-endnote-10">10</a></sup>	Patrick Wardle, “A Surreptitious Cryptocurrency Miner in the Mac App Store?” <em>Objective-See</em>, March 11, 2018, <a class="LinkURL" href="https://objective-see.com/blog/blog_0x2B.html">https://objective-see.com/blog/blog_0x2B.html</a>.</p></aside>
</section>
</body>
</html>