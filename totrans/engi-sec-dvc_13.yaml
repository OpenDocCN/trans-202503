- en: '**10'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ROBUST DEVICE ARCHITECTURE**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Robustness is *the* key feature for components in industries like automotive,
    aerospace, and industrial automation. Neither dirt and dust nor freezing or broiling
    temperatures should be able to do any harm to those devices. Products in this
    category are built to survive over a long lifetime. They’re designed with the
    requirement of *physical robustness* as a high priority.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, since connectivity and communication are increasing even in those
    rather conservative areas, a new concern has emerged: *digital robustness*. Threats
    like network-based DoS attacks aim for temporary service interruption that can
    be critical for real-time systems depending on timely system reactions. Therefore,
    the protection goal of *availability* rises in importance for such embedded systems.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I highlight the relevance of robust device architectures for
    connected devices facing increasing network stress. I discuss the impact on real-time
    systems and essential functions of embedded devices. Afterward, we’ll look at
    strategies for coping with DoS attacks on embedded systems on the hardware, OS,
    and application level. This chapter’s case study then takes a look at the real-time
    and robustness behavior of a Linux-based embedded system under various conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Devices Under Network Stress**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Almost every device has some kind of network interface, whether it’s Wi-Fi,
    Ethernet, or a domain-specific networking standard like the CAN bus. Threats like
    cut cables and jammers blocking wireless communication channels are well known.
    Because they lead to the physical loss of the communication medium’s availability,
    messages sent over affected channels will be lost and won’t reach the initially
    connected device. While this issue affects overall system communication, the resources
    of the device itself are not impacted, and (even if perfectly designed) the device
    won’t be able to help in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: The threats covered in this chapter are of a slightly different nature. They’re
    initiated over a network connection, but in contrast to targeting the communication
    channels, they have an impact on a device’s operations and resources. This can
    be as simple as a wrong packet on the wrong port, causing a sloppily engineered
    industrial device to drop everything and jump into an undocumented update mode
    while bringing its control function to a halt. Overloading a device with a large
    number of messages, however, is more often the main threat.
  prefs: []
  type: TYPE_NORMAL
- en: Such device weaknesses can be provoked on numerous occasions that happen more
    frequently with rising network complexity, the introduction of security management
    processes by operators, and an increased attack surface. Let’s consider some typical
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: '***Malfunctioning Neighbor Devices***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The more complex and heterogeneous a system, the higher the probability that
    a device goes wild someday and broadcasts tons of messages to all participants
    in the same network. The constant and eventually high-volume traffic is able to
    unintentionally reveal the unreliability of connected devices in this domain.
  prefs: []
  type: TYPE_NORMAL
- en: '***Protocol Fuzzing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Fuzzing* is a security testing technique that repeatedly generates randomly
    mutated, malformed inputs and feeds them to a device with the goal of exhibiting
    unconsidered corner cases. Developers often apply fuzzing to test their own devices.
    Systems integrators, operators, and researchers also use fuzzing to analyze the
    robustness and security of devices, and to uncover undesired behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Network and Vulnerability Scanning***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: IT environments are used to being scanned regularly for open network ports,
    vulnerable client machines, and misconfigured server instances. Environments like
    industrial production sites are much less likely to be subject to such IT security
    methods, but they will be in the future. Components should be able to handle such
    scans and not show unexpected behavior, such as temporary deviations in processing
    speeds or even complete device failure.
  prefs: []
  type: TYPE_NORMAL
- en: '***Flooding Attacks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As soon as an attacker has access to a network, they’re able to send packets
    to connected devices. Certain tools can initiate network-based DoS attacks with
    a one-liner that even script kiddies can easily perform. Truly robust devices
    shouldn’t be affected by such attacks and should continue operating properly.
  prefs: []
  type: TYPE_NORMAL
- en: '***Robust Architectures***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many cases of low robustness against unusual network communication are due to
    bugs that should be discovered during functional and security testing, which is
    a mandatory part of the secure development process described in [Chapter 1](ch01.xhtml#ch01).
    However, some devices’ DoS vulnerabilities arise from the architectural decisions
    you may have made for your device.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re part of an engineering team that’s proud of its ruggedized products,
    take a step forward and also make digital robustness a high-priority feature.
    The following sections provide advice for engineering digital robustness.
  prefs: []
  type: TYPE_NORMAL
- en: '**Essential Device Functions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s easy to say that a flooding attack shouldn’t impact a device’s functionality,
    but the practical implementation of protection measures requires more detailed
    considerations than you might expect. It’s clear that communication capabilities
    might suffer from high message load and might be reduced or even completely lost,
    which influences every device feature that depends on data received from other
    entities and possibly operations that need to transfer data from your device to
    other network participants. These impacts are inevitable from a device’s perspective
    and require corresponding mitigation measures.
  prefs: []
  type: TYPE_NORMAL
- en: Part 4-2 of the industrial standard IEC 62443 covers technical security requirements
    for industrial components, and it includes the specific requirement CR 7.1 that
    deals with DoS protection on embedded systems. Its central demand is that a device
    should maintain its *essential functions* even under a DoS attack and while operating
    in a *degraded mode*. If you want to fulfill this requirement, the obvious question
    you have to pose first is, “What actually are my device’s essential functions?”
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider three generic types of devices and their possible essential functions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Sensors***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Sensors* measure environment parameters. No matter whether it’s tracking temperature,
    distance, pH value, or fill level, the sensor’s task is to capture the current
    situation and communicate it to a control or monitoring system. However, if the
    communication channel and/or corresponding device resources can be overloaded
    and communication capabilities are lost, the sensor should still be able to collect
    its data.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the essential function could be the correct sensing and storage
    of the acquired values. From a product engineering perspective, this could lead
    to a new requirement—namely, a sufficiently large data buffer and recovery procedure
    for when communication is working again.
  prefs: []
  type: TYPE_NORMAL
- en: '***Actuators***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Actuators* like drives, valves, engines, or even lasers influence the physical
    world. They’re usually parameterized by a central controller instance, which communicates
    with the actuator—for example, over an Ethernet network.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume a drive is operating at 1,000 revolutions per minute when suddenly
    a DoS attack on its network interface starts. Should the essential function (turning
    the drive at a certain speed) keep operating? From a security and an availability
    perspective, that could make sense. However, safety experts might argue that the
    system isn’t in a safe state anymore and should react with a shutdown to avoid
    unsafe behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '***Controllers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Control devices* for automotive, industrial automation, or critical infrastructures
    usually follow the simple principles illustrated in [Figure 10-1](ch10.xhtml#ch10fig01):
    receive inputs, process them by a given program, maybe do some communication,
    and then set the new output signals.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-1: The typical execution cycle of a control device*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Afterward, the cycle begins anew. However, in case of network stress, the communication
    slot could consume too much time and resources. Again, you need to define your
    strategy: it might be reasonable to say that cycle execution (except for communication)
    is the essential function that should keep running, even if the device is stressed
    over the network interface. If network communication itself is essential, the
    question would be whether it’s absolutely required for every single cycle or whether
    at least once within 10 cycles would be acceptable, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: If the defined requirements can’t be fulfilled at runtime, the system should
    probably come to a stop. A good example of such devices might be automotive components
    that read pedal sensor values and control the engine accordingly. Architects and
    developers of these control units have to specify the devices’ essential functions
    in order to prepare them for the case that the sensor communication or its corresponding
    task fails—for whatever reason.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Defining a device’s essential functions is a fundamental design decision that
    can have significant influences on the device’s software and hardware architecture.
    Be sure to consider this topic early and seriously.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Real-Time Systems**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Digital robustness is relevant for almost every product, as device failures
    often lead to financial losses for operators. However, it’s especially desirable
    for *real-time embedded systems*. These devices are not only required to maintain
    the availability of their services but also have to make sure that, upon an initial
    event, the results of the device operation are *available before a given deadline*.
  prefs: []
  type: TYPE_NORMAL
- en: Although high-performance processors and super-fast reaction times can be the
    results of such a requirement, those features aren’t mandatory. The only important
    constraint is that a system’s response is provided *before the time limit is over*,
    be it a microsecond or half a minute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Real-time systems have three categories that differ in terms of the impact
    of missed deadlines: soft, firm, and hard real-time systems.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Soft Real-Time Systems***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Soft real-time systems* can tolerate missing deadlines even frequently. However,
    the usefulness and value of delayed results are continuously decreasing. If the
    deadline is missed significantly, the results might turn out to be worthless.
    Application examples include weather stations, live audio transmission, and video
    gaming.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Firm Real-Time Systems***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A missed deadline in a *firm real-time system* leads to a defect or a degraded
    quality of service. However, misses that happen only infrequently might be tolerable.
    An example of such a system could be a pick-and-place robot. If its controller
    misses a deadline, the currently processed component might be broken or placed
    the wrong way, but after handling this single failure, the device is able to continue
    normal operation.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hard Real-Time Systems***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Hard real-time systems* have to satisfy the highest requirements. For these
    systems, any missed deadline is critical. Depending on the application, it might
    even lead to catastrophic consequences. Typical examples are engine control units
    in planes or trains, high-quality manufacturing processes, and medical devices
    like pacemakers.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Impact of DoS Attacks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If your device falls into one of these real-time groups, you have to consider
    the potential corresponding impacts of DoS attacks, or even accidentally occurring
    network stress, during your threat and risk assessment and mitigate the resulting
    weaknesses accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource Exhaustion and Prevention Strategies**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Network-based DoS attacks, like flooding, aim for *temporary resource exhaustion*
    on the target device. In a simple scenario, an attacker can achieve this by utilizing
    most of the available network bandwidth to send packets to a target device. The
    victim device receives all the packets and has to process them. The required processing
    power depends on the type and content of the network packets.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the accumulation of network packets reaches a level that fills all
    internal buffers and the device is not able to process the packets faster than
    they arrive at its network interface, CPU resource exhaustion occurs. The device
    isn’t able to perform its queuing tasks anymore, including its essential functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The cause of resource exhaustion doesn’t have to be a deliberate attack. A
    careless network scan with* nmap *might be enough to temporarily provoke resource
    exhaustion on your device, as shown in this chapter’s case study.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall prevention of resource exhaustion isn’t always possible in practice
    and depends on specific device parameters and attacker capabilities. However,
    a strong separation between essential functions and secondary operations is a
    solid architecture that can keep operating in a degraded mode, even under significant
    network stress. A given set of device resources can be distributed among critical
    and rather less critical operations by using two basic strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fixed resource allocation**    A static allocation of resources to tasks
    has the advantage of providing a transparent and clear segregation of duties.
    However, fixed limits lead to inefficiencies at runtime, when a resource isn’t
    consumed by its allocated task and another task would benefit from using that
    resource but isn’t allowed to.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic resource allocation**    To foster efficient resource use, resources
    can be allocated to specific tasks at runtime, based on task attributes that are
    used to derive a priority metric.'
  prefs: []
  type: TYPE_NORMAL
- en: These approaches should be considered during the design of your device’s hardware
    architecture and the selection of the main processing units. Moreover, the choice
    and configuration of your OS can have significant impacts on your device’s robustness.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardware-Level Implementation Options**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A device’s hardware architecture defines its basic computing resource conditions.
    During its development, ICs for various purposes are selected, including microcontrollers,
    multicore SoCs, and FPGAs, but also dedicated chips like Ethernet PHYs that handle
    network communication on the physical layer.
  prefs: []
  type: TYPE_NORMAL
- en: If robustness against network flooding is one of your main concerns and you
    take that into account at an early stage of your development process, you can
    design your device’s hardware architecture in a way that significantly reduces
    the risk of network-based DoS attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '***Dedicated Preprocessing Unit***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 10-2](ch10.xhtml#ch10fig02) shows the basic concept when introducing
    a dedicated preprocessing unit for network traffic. The main idea behind this
    architecture is the physical separation of the main application’s processor and
    the network processing, or at least parts of it.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-2: An architecture with network traffic preprocessing*'
  prefs: []
  type: TYPE_NORMAL
- en: One specific example of such an architecture is a *communication preprocessor*
    that implements a TCP/IP stack and takes care of processing network packets and
    their payload. The communication of relevant data between the main processor and
    the preprocessing unit is carried out over a preferably simple interface. In case
    of a flooding attack or just very high network load for unknown reasons, the communication
    unit is likely to run into resource exhaustion, but the application processor
    behind it will not be impacted and will be able to perform the device’s essential
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: The use of a *hardware packet filtering unit* is a second example of this approach.
    Here, the network stack remains on the main processing unit, and the preprocessor
    is used only to filter the stream of network packets arriving at the device’s
    network interface. Rules for filtering might, for example, include rate limits
    to guarantee that your application processor receives only the number of packets
    it’s able to handle.
  prefs: []
  type: TYPE_NORMAL
- en: Such an architecture could be implemented by specific networking ICs that provide
    this functionality, but, at the time of writing, these are rather uncommon in
    embedded systems. For devices hosting an FPGA, the MAC controller could be implemented
    in digital logic followed by a custom packet-filtering core before handing network
    data to the main CPU.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Be careful when designing the communication between a main processor and a
    preprocessing unit. If the former shows a heavy dependency on the latter, the
    device might fail despite the solid architecture.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Multicore Architectures***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If digital robustness appears too late on the list of requirements and the hardware
    design is already fixed, you might be lucky if you’ve opted for a multicore SoC
    as the main processing unit in your device. Admittedly, individual cores in multicore
    chips are not completely separated and independent of one another; they share
    resources like buses, cache memories, and the like. However, a well-considered
    distribution of tasks among cores, as shown in [Figure 10-3](ch10.xhtml#ch10fig03),
    can reduce the probability of a DoS event.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-3: Using multicore architectures for robustness*'
  prefs: []
  type: TYPE_NORMAL
- en: An increasing number of SoCs for embedded systems implement *asymmetric multiprocessing
    (AMP)*. They include one or more high-performance cores that are meant to run
    feature-rich OSs, such as Linux, and one or more smaller cores that, for example,
    excel at real-time applications. One approach toward increased robustness could
    be the allocation of essential functions like control tasks to the dedicated real-time
    core, as indicated by [Figure 10-3](ch10.xhtml#ch10fig03)a. Similar structures
    are possible on SoCs that combine hard processors with soft cores that reside
    within an FPGA fabric.
  prefs: []
  type: TYPE_NORMAL
- en: If your device runs on a *symmetric multiprocessing (SMP)* SoC—which means it
    has two, four, eight, or even more cores of the same type—you still have options
    to improve robustness. The architecture in [Figure 10-3](ch10.xhtml#ch10fig03)b
    is meant to separate networking tasks from essential functions by binding their
    processes to dedicated cores. This concept is known as *core pinning*, or *processor
    affinity*, and has to be supported by your OS.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Again, (communication) dependencies between processes on different cores might
    break the intended separation and should be conceptualized with care.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operating System Capabilities**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A central duty of an OS is the management of CPU cores, memory regions, and
    a diverse set of hardware interfaces. The component handling the difficult task
    of allocating processing time during runtime is called the *scheduler*. It’s absolutely
    reasonable to consider capabilities and responsibilities of OSs and schedulers
    when talking about preventing resource exhaustion.
  prefs: []
  type: TYPE_NORMAL
- en: '***Operating System Options***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When it comes to selecting an OS, device engineers have basically four options:
    bare-metal software without an OS, a real-time OS, a fully fledged OS, or a hypervisor-based
    OS combination.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bare-Metal Software Without an OS**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In simple devices and applications, an OS might not even be necessary. Events
    and corresponding resource allocation can be handled by polling loops or interrupt
    service routines.
  prefs: []
  type: TYPE_NORMAL
- en: '**Real-Time OS**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'An RTOS is a rather low-complexity OS that is specifically meant for real-time
    applications that have a high interest in reliability. Its scheduler manages resources
    based on task priorities: tasks with a higher priority can interrupt currently
    running ones that have a lower priority.'
  prefs: []
  type: TYPE_NORMAL
- en: In such a system, it’s important not to configure networking-related tasks as
    the top priority, because doing so could lead to network-induced DoS situations.
    In practice, you can find a variety of RTOSs in the field, including commercial
    ones like QNX or VxWorks, but also open source variants such as FreeRTOS, RIOT,
    or Zephyr.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fully Fledged OS**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Many modern, feature-rich devices rely on open source libraries and tools that
    handle, for example, network communication, presentation of user interfaces, or
    data-processing tasks. Those devices are usually based on a fully fledged OS like
    Linux. However, such complex and not fully deterministic OSs share a disadvantage:
    the lack of proper real-time capabilities. In the next section, I’ll discuss a
    possibility that makes Linux more real-time capable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hypervisor-Based OS Combination**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Some manufacturers want to combine the real-time advantages of RTOSs with the
    many libraries and capabilities of Linux. In these cases, a further abstraction
    layer is introduced below those OSs: a *hypervisor* takes over the task of hardware
    resource allocation and thereby plays an important role in separating essential
    functions (probably running on top of an RTOS) from the supporting functionalities
    implemented within Linux. These setups further increase the complexity of your
    product’s software architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Linux with a Real-Time Patch***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In its typical configuration for desktop and server systems, Linux doesn’t offer
    reliable real-time capabilities. However, for several years, the real-time community
    has maintained a kernel patch known as `PREEMPT_RT`. It includes a variety of
    changes to the Linux kernel that share the common goal of enabling *preemption*
    of kernel threads and in-kernel primitives, which means that nondeterminism in
    task scheduling is reduced and computing resource allocation comes closer to a
    purely priority-based system. In current Linux kernel versions, you can activate
    real-time support with the `CONFIG_PREEMPT_RT` configuration option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread scheduling in Linux happens based on a scheduling policy and a static
    scheduling priority. “Normal” threads are scheduled with policies like `SCHED_OTHER`,
    `SCHED_IDLE`, or `SCHED_BATCH` and a priority of 0\. Threads that have to fulfill
    real-time requirements are scheduled with one of the following policies:'
  prefs: []
  type: TYPE_NORMAL
- en: SCHED_FIFO    This scheduler follows the *first-in first-out (FIFO) principle*,
    which means that a running thread is executed until it is preempted by a thread
    with a higher static priority.
  prefs: []
  type: TYPE_NORMAL
- en: SCHED_RR    The classic *round-robin (RR)* scheduling approach is similar to
    `SCHED_FIFO` except that threads are allowed to run for only a defined maximum
    amount of time. Afterward, the thread is interrupted and added to the end of the
    queue for threads with the same priority. Threads with higher priority may preempt
    those with lower priority.
  prefs: []
  type: TYPE_NORMAL
- en: SCHED_DEADLINE    In contrast to the other schedulers, this one is based on
    *global earliest deadline first (GEDF)*. It doesn’t rely on static priorities
    but assigns them dynamically. Its decisions are based on a thread’s absolute deadline
    and its total computation time.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Although* PREEMPT_RT *makes Linux behave more like a real-time OS, it’s still
    a complex piece of software that’s not suitable for many hard real-time requirements.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application and Protocol Considerations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While this chapter is primarily concerned with the robust device architecture
    on the hardware and OS level, I don’t want to ignore the application and communication
    levels. Many DoS situations in the real world arise from sloppy software and protocol
    design.
  prefs: []
  type: TYPE_NORMAL
- en: Such issues can be introduced in various phases of the development process.
    A protocol specification might already lack a solid definition of correct behavior
    in corner cases—for example, minimum or maximum values of message parameters.
    Further, even simple bugs in software, such as missing bounds checking, can lead
    to undesired side effects like endless loops or deadlocks under certain circumstances.
    Then, if security testing is performed only superficially, devices leave production
    with firmware that gives attackers the opportunity to trigger a DoS event with
    as little effort as a single network packet.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections provide practical suggestions for tackling this complex
    issue. The important possibility you should be looking for is an attacker’s ability
    to *force a state transition* within your device that results in a DoS.
  prefs: []
  type: TYPE_NORMAL
- en: '***Identify Logical Flaws***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Protocol design is a complex task, but many companies take this path and develop
    their own, proprietary message and communication format. If you find yourself
    in such a situation, be sure to do your best to eliminate logical flaws in your
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you can do that on the concept level by asking questions like these:
    What is the range of validity for each value in our messages? Is a network participant
    able to force our device into an undefined state? Are the validity and plausibility
    of message values verified before they’re used? Second, testing your protocol
    implementation with messages that only partially fulfill the specification or
    even try to manipulate your device’s state on purpose can be helpful for discovering
    vulnerabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Implement Input and Sender Validation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In many embedded system scenarios, an adversary is able to communicate directly
    with a device—for example, over the network. Even if official client software
    *should* be used for interacting with your device, attackers might simply craft
    their own manipulated messages, so devices shouldn’t trust any packet arriving
    at their network interface.
  prefs: []
  type: TYPE_NORMAL
- en: Critical commands, such as switching into update mode and halting all operations,
    should be allowed only after the authenticity of the sender has been verified
    successfully. Therefore, a developer’s default attitude should be to *expect*
    malicious input and implement suitable input validation and filtering mechanisms
    accordingly, whether on the firewall level or within the application that processes
    a message’s payload.
  prefs: []
  type: TYPE_NORMAL
- en: '***Analyze Active Protection Measures***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes attackers can misuse active protection measures to force a device
    into a DoS state. For example, your login process might be hardened to prohibit
    brute-force attacks by allowing only 10 login attempts. After reaching that limit,
    the device changes into a locked mode from which it can be reactivated only by
    a recovery procedure. While this might be an absolutely reasonable security measure,
    it also allows attackers to force a DoS situation, even for legitimate users,
    by entering the wrong user credentials 10 times.
  prefs: []
  type: TYPE_NORMAL
- en: Firewall configurations that block IPs based on their amount of traffic have
    similar mechanisms. In that case, attackers might spoof sender IP addresses of
    valid devices and trigger the protection feature by sending a large number of
    packets. As a result, the communication attempts of legitimate devices will be
    blocked afterward.
  prefs: []
  type: TYPE_NORMAL
- en: '***Introduce Chaos Engineering and Fuzzing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The human imagination is limited. It’s unrealistic to assume that developers
    will anticipate all potential issues that might lead to a DoS event on your device.
    Two testing methods push the limits in this regard, however.
  prefs: []
  type: TYPE_NORMAL
- en: '*Chaos engineering* is a kind of reliability and resilience testing for IT
    systems that introduces “chaos” into an IT infrastructure in the form of random
    failures of services or applications. In the area of embedded system testing,
    this “chaos” can be crashed processes or the loss of communication channels in
    order to analyze the device’s behavior under adverse circumstances.'
  prefs: []
  type: TYPE_NORMAL
- en: The discipline of *fuzzing* might be applied to communication protocols, but
    also on input data like the configuration files or certificates that a device
    processes. It can be used to create a large number of test messages or test files
    by cleverly mutating input data many times. In this way, you can discover cases
    that lead to a DoS state that would have been very hard to find by manual, human
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All that said, keep in mind that your product development team’s mindset and
    awareness can be decisive factors in detecting DoS vulnerabilities early in your
    development process.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Case Study: Robustness Options on an STM32MP157F Device**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case study, I’ll analyze the real-time and robustness capabilities of
    an STM32MP157F device. I’ll shed light on corresponding measurement methods and
    tools used to simulate CPU and network stress on a device.
  prefs: []
  type: TYPE_NORMAL
- en: '***Basic System Properties***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Regarding hardware-level options, the STM32MP157F device at hand provides two
    Cortex-A7 cores running at 800 MHz and a dedicated Cortex-M4 core at 209 MHz for
    real-time applications. This basic information allows us to conclude that both
    pinning tasks to one of the A7 cores and moving essential software applications
    to the separated M4 core would be possible. In principle, using the M4 core as
    a preprocessing unit for Ethernet traffic might even be an option, but that’s
    probably not the first solution I would pursue, and it would require further feasibility
    analysis based on the SoC’s architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The MAC unit included in the STM32MP157F’s Ethernet peripheral supports data
    transfer rates of 10, 100, and 1,000Mbps. After looking into ST’s *Reference Manual
    RM0436* for STM32MP157F devices, it becomes clear that this module even comes
    with hardware-assisted packet filtering. Received packets can be filtered based
    on their source and destination MAC addresses, the virtual local area network
    (VLAN) tag in the Ethernet frame of a packet, the source and destination IP address,
    and the source and destination port of TCP and UDP messages. Unfortunately, the
    module doesn’t have any kind of rate-limiting feature, which would be useful for
    DoS protection.
  prefs: []
  type: TYPE_NORMAL
- en: The third part of this initial analysis concerns the Linux OS running on my
    STM32MP157F device. As previously described, Linux can be patched or configured
    to behave similarly to a real-time system. With the command and output shown in
    [Listing 10-1](ch10.xhtml#ch10list01), I checked whether my Linux system, which
    was created by Yocto based on ST’s `st-image-core` image, comes with real-time
    scheduling capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-1: The Linux kernel properties of my system*'
  prefs: []
  type: TYPE_NORMAL
- en: The string `SMP` points out that the Linux system at hand was configured at
    compile time to support symmetric multicore architectures like the A7 dual core
    of the STM32MP157F, while `PREEMPT` indicates that the Linux kernel was compiled
    with the `CONFIG_PREEMPT` option. The system runs a *low-latency kernel*, which
    means that kernel code not executed in a critical section can be interrupted by
    higher-priority tasks. However, this configuration shouldn’t be confused with
    the `PREEMPT_RT` indicator, which represents a fully preemptible Linux kernel
    enabled by `CONFIG_PREEMPT_RT`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Measurements on a Low-Latency Kernel***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can measure a device’s latency behavior in two ways. If you have internal
    access to the device’s Linux system, you can run software that analyzes the scheduling
    behavior of that Linux system. On the other hand, for example, if you analyze
    a third-party component, you might be forced to regard the device under testing
    as a black box. In such a case, you can observe the device’s latency behavior
    only with respect to input and output signals—for example, with an oscilloscope
    or a logic analyzer. While the former approach is more suitable for showing the
    principle capabilities of a device, the latter can yield results that are much
    closer to a specific use case.
  prefs: []
  type: TYPE_NORMAL
- en: In this case study, I use the `cyclictest` tool to analyze the system’s real-time
    capabilities because I have access to the device’s Linux console and I don’t yet
    have a specific application in mind. This tool measures the latency between the
    programmed and the actual execution of a real-time task scheduled with `SCHED_FIFO`.
    [Listing 10-2](ch10.xhtml#ch10list02) shows a sample test and its results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-2: The task latency in idle mode*'
  prefs: []
  type: TYPE_NORMAL
- en: The `--mlockall` parameter is used to reduce overhead and influences from the
    tool itself, while `--smp` is necessary for testing on a multicore system. The
    measuring thread is executed every 200 *µ*s as set by the `--interval` option,
    and there’s no difference between the measuring periods of the various threads,
    as denoted by `--distance=0`. The measuring tasks are executed 40,000 times (`--loops=40000`)
    with a task priority of 80 (`--priority=80`).
  prefs: []
  type: TYPE_NORMAL
- en: The result output shows two lines, one for each CPU core. The letters `P`, `I`,
    and `C` stand for the priority setting, measuring interval, and count of performed
    measurements, respectively. The values on the right show the minimal, actual,
    average, and maximum observed latency. The rightmost number is the most important
    one because it indicates worst-case latencies for scheduled tasks that may or
    may not be tolerable for you.
  prefs: []
  type: TYPE_NORMAL
- en: In the current state, the given Linux system with a `PREEMPT` low-latency kernel
    shows maximum latencies of 158 and 165 *µ*s. However, if I use a second device
    on the same network to apply a SYN flooding attack—for example, by running `hping3
    --syn --flood` device-ip, the maximum latency is affected significantly, as shown
    in [Listing 10-3](ch10.xhtml#ch10list03).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-3: The effect of SYN flooding on task latency*'
  prefs: []
  type: TYPE_NORMAL
- en: In such a situation, even with a low-latency kernel, task latency might rise
    to over 5 ms, a multiple of the actual task interval. Clearly, this could be critical
    if your application has to fulfill real-time requirements. [Listing 10-4](ch10.xhtml#ch10list04)
    shows a sample measurement result while a simple port scan was performed with
    `nmap` device-ip.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-4: The effect of a SYN scan with* nmap *on task latency*'
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, we can see that the low-latency kernel of the standard Linux
    distribution for the STM32MP157F device isn’t able to provide strong real-time
    features. Even short periods of intense network traffic can affect the system’s
    reaction times.
  prefs: []
  type: TYPE_NORMAL
- en: '***Measurements on a Real-Time Kernel***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If robustness is one of your top requirements, you might want to look for a
    Linux distribution that implements a fully preemptible kernel to fulfill real-time
    constraints. Luckily, ST provides the Yocto layer `meta-st-x-linux-rt` for the
    STM32MP157F device. After adding it to my build system, I only have to set `MACHINE=stm32mp15-rt`
    and re-create the build environment before I can use `bitbake` to generate the
    `st-image-core` image and a Linux kernel with `CONFIG_PREEMPT_RT` enabled.
  prefs: []
  type: TYPE_NORMAL
- en: After booting the new image, I double-checked that the kernel actually provides
    real-time capabilities. The output in [Listing 10-5](ch10.xhtml#ch10list05) shows
    the typical `PREEMPT_RT` feature as desired.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-5: The Linux kernel features including real-time capabilities*'
  prefs: []
  type: TYPE_NORMAL
- en: Again, you can test the system’s real-time behavior with `cyclictest` as in
    the previous section. [Listing 10-6](ch10.xhtml#ch10list06) shows the positive
    effects of the real-time kernel.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-6: The task latency of the real-time kernel in idle mode*'
  prefs: []
  type: TYPE_NORMAL
- en: In comparison to the low-latency kernel’s values in [Listing 10-2](ch10.xhtml#ch10list02),
    158 and 165 *µ*s, the maximum latency was significantly reduced to 64 and 72 *µ*s,
    respectively. The results shown in [Listing 10-7](ch10.xhtml#ch10list07) indicate
    even better behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-7: The effect of SYN flooding on the real-time kernel’s latency*'
  prefs: []
  type: TYPE_NORMAL
- en: The maximum latency of the Linux system doesn’t exceed 100 *µ*s, even in the
    face of a SYN flooding attack performed with `hping3`.
  prefs: []
  type: TYPE_NORMAL
- en: You can observe a similar effect in [Listing 10-8](ch10.xhtml#ch10list08), which
    was captured while running network scans on the device under test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-8: The effect of a SYN scan with* nmap *on the real-time kernel’s
    latency*'
  prefs: []
  type: TYPE_NORMAL
- en: While common `nmap` commands provoked worst-case latencies of more than 6 ms
    for the standard image with its low-latency kernel, the real-time kernel analyzed
    in this section can be incited to raise maximum latencies by only less than 15
    *µ*s compared to the idle state.
  prefs: []
  type: TYPE_NORMAL
- en: What all this amounts to is that a low-latency Linux kernel doesn’t guarantee
    any robustness, and even a fully preemptible Linux kernel comes only close to
    real-time behavior. If this is a viable option for you, make sure to understand
    that you trade performance for determinism when switching to the real-time Linux
    kernel. Further, features like the SoC’s dynamic power management and frequency
    scaling might be deactivated to reach real-time behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*All the presented measurements of maximum latency have to be regarded as only
    rough estimations. Your device could run into an even worse condition that leads
    to even higher maximum reaction times.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Real-Time Coprocessor***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re aiming to fulfill hard real-time requirements, Linux is likely not
    your best choice. However, the STM32MP157F provides an additional Cortex-M4 core
    for exactly that purpose. The development and build process of dedicated M4 firmware
    is beyond the scope of this case study, but you can use ST’s STM32CubeIDE or your
    favorite customized makefile for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume you’ve created a firmware file *m4_fw.elf* that contains your real-time
    application. Typically, you would place that file in the */lib/firmware/* directory,
    as it’s firmware for a coprocessor. [Listing 10-9](ch10.xhtml#ch10list09) shows
    the basic initialization of Linux’s `remoteproc` framework to prepare M4 firmware
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-9: Initializing M4 firmware using the* remoteproc *framework*'
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, the firmware path */lib/firmware/* is written to the corresponding
    `sysfs` node. Afterward, the name of the specific firmware file, *m4_fw.elf* in
    this case, is passed to the remote processor instance `remoteproc0`, representing
    the M4 real-time core.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, nothing runs. The output in [Listing 10-10](ch10.xhtml#ch10list010)
    confirms that the M4 is still offline. To start the provided firmware, the `start`
    keyword has to be written to `remoteproc0/state`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-10: Starting M4 firmware using the* remoteproc *framework*'
  prefs: []
  type: TYPE_NORMAL
- en: Subsequently, the core is powered up, and execution of the real-time application
    begins. Now, even if the Linux system suffers from high network load and is running
    out of resources, the real-time firmware will continue operating at its CPU’s
    clock frequency of 209 MHz unperturbed. Also, the state of `remoteproc0` has changed
    to `running`, accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Listing 10-11](ch10.xhtml#ch10list011), the Linux system is able
    to stop the firmware execution by writing `stop` to `remoteproc0/state`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 10-11: Stopping M4 firmware using the* remoteproc *framework*'
  prefs: []
  type: TYPE_NORMAL
- en: If necessary for your application, Linux’s remote processor messaging (RPMsg)
    framework enables the exchange of information between the main CPUs and the coprocessor.
    However, make sure to avoid strong dependencies of the real-time application on
    the Linux system as this might cause your whole device to stumble, again.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many industries regard robustness as a fundamental feature for all their devices.
    However, when it comes to highly interconnected and automated systems, both customers
    and manufacturers typically have difficulty specifying their understanding of
    digital robustness.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter bridged the gap between the real-time world of embedded systems
    and the security protection goal of availability. The most important takeaways
    for device engineers and architects should be that they must consider potential
    digital stress on the network and other interfaces, essential functions of their
    devices that should work properly even under attack, and architecture decisions
    that support true real-time behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Options for achieving a robust device architecture range from the integration
    of dedicated hardware resources to the separation of duties within multicore SoCs
    to the careful selection and configuration of a device’s OS. But, again, as shown
    in this chapter’s case study, nothing replaces the practical evaluation of your
    device’s behavior during idle and potential situations of stress.
  prefs: []
  type: TYPE_NORMAL
