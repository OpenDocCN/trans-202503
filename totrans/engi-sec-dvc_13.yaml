- en: '**10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10  '
- en: ROBUST DEVICE ARCHITECTURE**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 强健的设备架构**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: Robustness is *the* key feature for components in industries like automotive,
    aerospace, and industrial automation. Neither dirt and dust nor freezing or broiling
    temperatures should be able to do any harm to those devices. Products in this
    category are built to survive over a long lifetime. They’re designed with the
    requirement of *physical robustness* as a high priority.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 鲁棒性是像汽车、航空航天和工业自动化等行业中组件的*关键特性*。设备不应受到尘土、寒冷或高温的影响。此类产品被设计成能在较长的生命周期内生存。它们在设计时将*物理鲁棒性*作为高优先级要求。
- en: 'However, since connectivity and communication are increasing even in those
    rather conservative areas, a new concern has emerged: *digital robustness*. Threats
    like network-based DoS attacks aim for temporary service interruption that can
    be critical for real-time systems depending on timely system reactions. Therefore,
    the protection goal of *availability* rises in importance for such embedded systems.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着即便在那些相对保守的领域，连接性和通信的增加，一个新的问题出现了：*数字鲁棒性*。像基于网络的DoS攻击这样的威胁，旨在造成暂时的服务中断，而这对依赖及时系统反应的实时系统来说可能是至关重要的。因此，*可用性*的保护目标对于这些嵌入式系统变得更加重要。
- en: In this chapter, I highlight the relevance of robust device architectures for
    connected devices facing increasing network stress. I discuss the impact on real-time
    systems and essential functions of embedded devices. Afterward, we’ll look at
    strategies for coping with DoS attacks on embedded systems on the hardware, OS,
    and application level. This chapter’s case study then takes a look at the real-time
    and robustness behavior of a Linux-based embedded system under various conditions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讨论了在面对日益增加的网络压力时，连接设备需要具备强大的设备架构。我将讨论实时系统以及嵌入式设备的基本功能受影响的情况。之后，我们将探讨应对嵌入式系统上硬件、操作系统和应用层的DoS攻击的策略。本章的案例研究将分析在不同条件下基于Linux的嵌入式系统的实时性和鲁棒性表现。
- en: '**Devices Under Network Stress**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网络压力下的设备**'
- en: Almost every device has some kind of network interface, whether it’s Wi-Fi,
    Ethernet, or a domain-specific networking standard like the CAN bus. Threats like
    cut cables and jammers blocking wireless communication channels are well known.
    Because they lead to the physical loss of the communication medium’s availability,
    messages sent over affected channels will be lost and won’t reach the initially
    connected device. While this issue affects overall system communication, the resources
    of the device itself are not impacted, and (even if perfectly designed) the device
    won’t be able to help in this situation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个设备都有某种网络接口，无论是Wi-Fi、以太网，还是像CAN总线这样的领域特定网络标准。像切断电缆和干扰器阻塞无线通信频道这样的威胁是广为人知的。因为这些威胁导致通信介质的物理可用性丧失，发送过受影响频道的消息将丢失，无法到达最初连接的设备。虽然这个问题会影响整体系统的通信，但设备本身的资源不会受到影响，并且（即使设计得再完美）设备也无法在这种情况下提供帮助。
- en: The threats covered in this chapter are of a slightly different nature. They’re
    initiated over a network connection, but in contrast to targeting the communication
    channels, they have an impact on a device’s operations and resources. This can
    be as simple as a wrong packet on the wrong port, causing a sloppily engineered
    industrial device to drop everything and jump into an undocumented update mode
    while bringing its control function to a halt. Overloading a device with a large
    number of messages, however, is more often the main threat.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的威胁性质略有不同。它们通过网络连接发起，但与针对通信频道的攻击不同，它们对设备的操作和资源产生影响。这可能是简单的错误数据包发送到错误端口，导致设计不良的工业设备丢失所有功能并进入未记录的更新模式，从而使其控制功能停止。然而，设备被大量信息轰炸的情况，通常才是主要的威胁。
- en: Such device weaknesses can be provoked on numerous occasions that happen more
    frequently with rising network complexity, the introduction of security management
    processes by operators, and an increased attack surface. Let’s consider some typical
    cases.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设备弱点可能在许多情况下被触发，这些情况随着网络复杂性的增加、运营商引入安全管理流程以及攻击面扩大而变得更加频繁。让我们考虑一些典型的案例。
- en: '***Malfunctioning Neighbor Devices***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***故障邻近设备***'
- en: The more complex and heterogeneous a system, the higher the probability that
    a device goes wild someday and broadcasts tons of messages to all participants
    in the same network. The constant and eventually high-volume traffic is able to
    unintentionally reveal the unreliability of connected devices in this domain.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 系统越复杂、越异构，设备某天失控并向同一网络中的所有参与者广播大量消息的可能性就越高。持续不断且最终变得高频的流量有可能无意间暴露出连接设备在该领域中的不可靠性。
- en: '***Protocol Fuzzing***'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***协议模糊测试***'
- en: '*Fuzzing* is a security testing technique that repeatedly generates randomly
    mutated, malformed inputs and feeds them to a device with the goal of exhibiting
    unconsidered corner cases. Developers often apply fuzzing to test their own devices.
    Systems integrators, operators, and researchers also use fuzzing to analyze the
    robustness and security of devices, and to uncover undesired behavior.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*模糊测试*是一种安全测试技术，它通过反复生成随机变异的、不规则的输入并将其输入到设备中，目的是暴露出一些未曾考虑到的边缘情况。开发人员通常使用模糊测试来测试他们自己的设备。系统集成商、运营商和研究人员也使用模糊测试来分析设备的鲁棒性与安全性，发现不希望出现的行为。'
- en: '***Network and Vulnerability Scanning***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***网络与漏洞扫描***'
- en: IT environments are used to being scanned regularly for open network ports,
    vulnerable client machines, and misconfigured server instances. Environments like
    industrial production sites are much less likely to be subject to such IT security
    methods, but they will be in the future. Components should be able to handle such
    scans and not show unexpected behavior, such as temporary deviations in processing
    speeds or even complete device failure.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: IT 环境通常会定期扫描开放的网络端口、存在漏洞的客户端机器以及配置错误的服务器实例。像工业生产现场这样的环境不太可能受到此类 IT 安全方法的影响，但未来它们也将面临这种情况。各个组件应该能够应对此类扫描，并且不会出现意外行为，例如处理速度的临时波动或设备完全故障。
- en: '***Flooding Attacks***'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***洪水攻击***'
- en: As soon as an attacker has access to a network, they’re able to send packets
    to connected devices. Certain tools can initiate network-based DoS attacks with
    a one-liner that even script kiddies can easily perform. Truly robust devices
    shouldn’t be affected by such attacks and should continue operating properly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦攻击者能够访问网络，他们就可以向连接的设备发送数据包。一些工具可以通过一行命令发起基于网络的 DoS 攻击，连脚本小白也能轻松执行。真正强大的设备应该不会受到这些攻击的影响，应该能够继续正常运行。
- en: '***Robust Architectures***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***强大的架构***'
- en: Many cases of low robustness against unusual network communication are due to
    bugs that should be discovered during functional and security testing, which is
    a mandatory part of the secure development process described in [Chapter 1](ch01.xhtml#ch01).
    However, some devices’ DoS vulnerabilities arise from the architectural decisions
    you may have made for your device.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 许多对异常网络通信缺乏鲁棒性的案例都是由于在功能和安全测试中未能发现的错误，这些测试是[第1章](ch01.xhtml#ch01)中描述的安全开发过程的强制性部分。然而，某些设备的
    DoS 漏洞来自于你在设计设备时所做的架构决策。
- en: If you’re part of an engineering team that’s proud of its ruggedized products,
    take a step forward and also make digital robustness a high-priority feature.
    The following sections provide advice for engineering digital robustness.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个自豪于其坚固产品的工程团队的一员，迈出一步， 同时将数字鲁棒性作为一个高优先级特性来考虑。接下来的部分将提供关于如何构建数字鲁棒性的建议。
- en: '**Essential Device Functions**'
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**设备基本功能**'
- en: It’s easy to say that a flooding attack shouldn’t impact a device’s functionality,
    but the practical implementation of protection measures requires more detailed
    considerations than you might expect. It’s clear that communication capabilities
    might suffer from high message load and might be reduced or even completely lost,
    which influences every device feature that depends on data received from other
    entities and possibly operations that need to transfer data from your device to
    other network participants. These impacts are inevitable from a device’s perspective
    and require corresponding mitigation measures.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 说洪水攻击不应影响设备功能很容易，但实际实现保护措施需要比预期更为详细的考虑。显然，通信能力可能会因高负载的消息流而受到影响，可能会减弱甚至完全丧失，这将影响所有依赖于从其他实体接收数据的设备功能，甚至可能会影响需要将数据从设备传输到其他网络参与者的操作。从设备的角度来看，这些影响是不可避免的，并需要相应的缓解措施。
- en: Part 4-2 of the industrial standard IEC 62443 covers technical security requirements
    for industrial components, and it includes the specific requirement CR 7.1 that
    deals with DoS protection on embedded systems. Its central demand is that a device
    should maintain its *essential functions* even under a DoS attack and while operating
    in a *degraded mode*. If you want to fulfill this requirement, the obvious question
    you have to pose first is, “What actually are my device’s essential functions?”
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 工业标准IEC 62443的第4-2部分涵盖了工业组件的技术安全要求，其中包括处理嵌入式系统上的DoS保护的特定要求CR 7.1。它的核心要求是设备即使在DoS攻击下并处于*降级模式*下，也应该保持其**基本功能**。如果你想满足这一要求，首先要提出的显而易见问题是：“我的设备的基本功能到底是什么？”
- en: Let’s consider three generic types of devices and their possible essential functions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑三种通用设备类型及其可能的基本功能。
- en: '***Sensors***'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***传感器***'
- en: '*Sensors* measure environment parameters. No matter whether it’s tracking temperature,
    distance, pH value, or fill level, the sensor’s task is to capture the current
    situation and communicate it to a control or monitoring system. However, if the
    communication channel and/or corresponding device resources can be overloaded
    and communication capabilities are lost, the sensor should still be able to collect
    its data.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*传感器*测量环境参数。不管是追踪温度、距离、pH值还是填充水平，传感器的任务是捕捉当前情况并将其传递给控制或监控系统。然而，如果通信通道和/或相应的设备资源可能会超载并失去通信能力，传感器仍然应该能够收集其数据。'
- en: In this case, the essential function could be the correct sensing and storage
    of the acquired values. From a product engineering perspective, this could lead
    to a new requirement—namely, a sufficiently large data buffer and recovery procedure
    for when communication is working again.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，基本功能可能是正确地感知并存储所获取的值。从产品工程的角度来看，这可能会导致一个新的需求——即，当通信恢复时，需要一个足够大的数据缓冲区和恢复过程。
- en: '***Actuators***'
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***执行器***'
- en: '*Actuators* like drives, valves, engines, or even lasers influence the physical
    world. They’re usually parameterized by a central controller instance, which communicates
    with the actuator—for example, over an Ethernet network.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*执行器*如驱动器、阀门、发动机或甚至激光器会影响物理世界。它们通常由一个中央控制器实例进行参数化，并通过以太网等通信方式与执行器进行通讯。'
- en: Let’s assume a drive is operating at 1,000 revolutions per minute when suddenly
    a DoS attack on its network interface starts. Should the essential function (turning
    the drive at a certain speed) keep operating? From a security and an availability
    perspective, that could make sense. However, safety experts might argue that the
    system isn’t in a safe state anymore and should react with a shutdown to avoid
    unsafe behavior.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个驱动器以每分钟1,000转的速度运转时，突然发生了对其网络接口的DoS攻击。是否应该让其基本功能（以某个速度旋转驱动器）继续运行？从安全性和可用性的角度来看，这可能是合理的。然而，安全专家可能会认为，系统已经不再处于安全状态，应通过停机来避免不安全的行为。
- en: '***Controllers***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***控制器***'
- en: '*Control devices* for automotive, industrial automation, or critical infrastructures
    usually follow the simple principles illustrated in [Figure 10-1](ch10.xhtml#ch10fig01):
    receive inputs, process them by a given program, maybe do some communication,
    and then set the new output signals.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*控制设备*用于汽车、工业自动化或关键基础设施，通常遵循[图10-1](ch10.xhtml#ch10fig01)所示的简单原理：接收输入，按照给定程序进行处理，可能进行一些通信，然后设置新的输出信号。'
- en: '![Image](../images/10fig01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig01.jpg)'
- en: '*Figure 10-1: The typical execution cycle of a control device*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-1：控制设备的典型执行周期*'
- en: 'Afterward, the cycle begins anew. However, in case of network stress, the communication
    slot could consume too much time and resources. Again, you need to define your
    strategy: it might be reasonable to say that cycle execution (except for communication)
    is the essential function that should keep running, even if the device is stressed
    over the network interface. If network communication itself is essential, the
    question would be whether it’s absolutely required for every single cycle or whether
    at least once within 10 cycles would be acceptable, for example.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，周期重新开始。然而，在网络压力的情况下，通信时隙可能会消耗过多的时间和资源。同样，你需要定义自己的策略：可能合理的做法是认为周期执行（除通信外）是应该持续运行的基本功能，即使设备在网络接口上处于压力状态。如果网络通信本身是必需的，问题将是每个周期都绝对需要通信，还是至少每10个周期中一次可以接受，例如。
- en: If the defined requirements can’t be fulfilled at runtime, the system should
    probably come to a stop. A good example of such devices might be automotive components
    that read pedal sensor values and control the engine accordingly. Architects and
    developers of these control units have to specify the devices’ essential functions
    in order to prepare them for the case that the sensor communication or its corresponding
    task fails—for whatever reason.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义的要求在运行时无法满足，系统应该可能停机。此类设备的一个好例子可能是读取踏板传感器值并相应控制发动机的汽车组件。这些控制单元的架构师和开发人员必须明确设备的基本功能，以便为传感器通信或相应任务失败的情况做准备——无论是什么原因导致的。
- en: '**NOTE**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Defining a device’s essential functions is a fundamental design decision that
    can have significant influences on the device’s software and hardware architecture.
    Be sure to consider this topic early and seriously.*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*定义设备的基本功能是一个基础性的设计决策，这个决策可能对设备的软件和硬件架构产生重大影响。务必在早期认真考虑这一主题。*'
- en: '**Real-Time Systems**'
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实时系统**'
- en: Digital robustness is relevant for almost every product, as device failures
    often lead to financial losses for operators. However, it’s especially desirable
    for *real-time embedded systems*. These devices are not only required to maintain
    the availability of their services but also have to make sure that, upon an initial
    event, the results of the device operation are *available before a given deadline*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 数字鲁棒性对于几乎所有产品都很重要，因为设备故障往往会导致运营商的财务损失。然而，对于*实时嵌入式系统*来说，这一点尤其重要。这些设备不仅要求保持服务的可用性，还必须确保在初始事件发生后，设备操作的结果能够*在给定的截止时间之前*提供。
- en: Although high-performance processors and super-fast reaction times can be the
    results of such a requirement, those features aren’t mandatory. The only important
    constraint is that a system’s response is provided *before the time limit is over*,
    be it a microsecond or half a minute.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管高性能处理器和超快反应时间可能是此类需求的结果，但这些特点并非强制要求。唯一重要的约束条件是，系统的响应必须在*时间限制结束之前*提供，无论是微秒还是半分钟。
- en: 'Real-time systems have three categories that differ in terms of the impact
    of missed deadlines: soft, firm, and hard real-time systems.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实时系统有三类，它们在错过截止时间后的影响程度上有所不同：软实时系统、严实时系统和硬实时系统。
- en: '***Soft Real-Time Systems***'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***软实时系统***'
- en: '*Soft real-time systems* can tolerate missing deadlines even frequently. However,
    the usefulness and value of delayed results are continuously decreasing. If the
    deadline is missed significantly, the results might turn out to be worthless.
    Application examples include weather stations, live audio transmission, and video
    gaming.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*软实时系统*即便经常错过截止时间也能容忍。然而，延迟结果的有用性和价值会持续下降。如果错过的截止时间较为严重，结果可能会变得毫无价值。应用实例包括气象站、实时音频传输和视频游戏。'
- en: '***Firm Real-Time Systems***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***严实时系统***'
- en: A missed deadline in a *firm real-time system* leads to a defect or a degraded
    quality of service. However, misses that happen only infrequently might be tolerable.
    An example of such a system could be a pick-and-place robot. If its controller
    misses a deadline, the currently processed component might be broken or placed
    the wrong way, but after handling this single failure, the device is able to continue
    normal operation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在*严实时系统*中，错过的截止时间会导致缺陷或服务质量下降。然而，偶尔错过截止时间可能是可以容忍的。这类系统的一个例子可能是取放机器人。如果它的控制器错过了截止时间，当前处理的部件可能会损坏或放置错误，但在处理完这一单一故障后，设备能够继续正常操作。
- en: '***Hard Real-Time Systems***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***硬实时系统***'
- en: '*Hard real-time systems* have to satisfy the highest requirements. For these
    systems, any missed deadline is critical. Depending on the application, it might
    even lead to catastrophic consequences. Typical examples are engine control units
    in planes or trains, high-quality manufacturing processes, and medical devices
    like pacemakers.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*硬实时系统*必须满足最高的要求。对于这些系统，任何错过的截止时间都是至关重要的。根据应用场景的不同，错过截止时间甚至可能导致灾难性的后果。典型的例子包括飞机或火车上的发动机控制单元、高质量制造过程，以及像起搏器这样的医疗设备。'
- en: '***Impact of DoS Attacks***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***DoS攻击的影响***'
- en: If your device falls into one of these real-time groups, you have to consider
    the potential corresponding impacts of DoS attacks, or even accidentally occurring
    network stress, during your threat and risk assessment and mitigate the resulting
    weaknesses accordingly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的设备属于这些实时类别中的某一类，您必须在威胁和风险评估过程中考虑DoS攻击或偶发的网络压力带来的潜在影响，并相应地缓解由此产生的弱点。
- en: '**Resource Exhaustion and Prevention Strategies**'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**资源耗尽与预防策略**'
- en: Network-based DoS attacks, like flooding, aim for *temporary resource exhaustion*
    on the target device. In a simple scenario, an attacker can achieve this by utilizing
    most of the available network bandwidth to send packets to a target device. The
    victim device receives all the packets and has to process them. The required processing
    power depends on the type and content of the network packets.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 基于网络的 DoS 攻击，如洪水攻击，旨在对目标设备造成*临时资源耗尽*。在一个简单的场景中，攻击者可以通过利用大部分可用的网络带宽向目标设备发送数据包来实现这一点。受害设备接收所有数据包并必须处理它们。所需的处理能力取决于网络数据包的类型和内容。
- en: However, if the accumulation of network packets reaches a level that fills all
    internal buffers and the device is not able to process the packets faster than
    they arrive at its network interface, CPU resource exhaustion occurs. The device
    isn’t able to perform its queuing tasks anymore, including its essential functions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果网络数据包的积累达到填满所有内部缓冲区的程度，并且设备无法比数据包到达更快地处理它们，就会发生 CPU 资源耗尽。此时设备无法再执行队列任务，包括其基本功能。
- en: '**WARNING**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*The cause of resource exhaustion doesn’t have to be a deliberate attack. A
    careless network scan with* nmap *might be enough to temporarily provoke resource
    exhaustion on your device, as shown in this chapter’s case study.*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*资源耗尽的原因不一定是恶意攻击。一次粗心的网络扫描，使用* nmap *可能就足以暂时引发设备的资源耗尽，正如本章案例研究所示。*'
- en: 'Overall prevention of resource exhaustion isn’t always possible in practice
    and depends on specific device parameters and attacker capabilities. However,
    a strong separation between essential functions and secondary operations is a
    solid architecture that can keep operating in a degraded mode, even under significant
    network stress. A given set of device resources can be distributed among critical
    and rather less critical operations by using two basic strategies:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 完全预防资源耗尽在实践中并不总是可能的，它取决于特定设备的参数和攻击者的能力。然而，基本功能和次要操作之间的强大分离是一个稳固的架构，可以在遭受显著网络压力的情况下保持降级模式下运行。通过使用两种基本策略，可以将设备资源分配到关键操作和相对不太关键的操作中：
- en: '**Fixed resource allocation**    A static allocation of resources to tasks
    has the advantage of providing a transparent and clear segregation of duties.
    However, fixed limits lead to inefficiencies at runtime, when a resource isn’t
    consumed by its allocated task and another task would benefit from using that
    resource but isn’t allowed to.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**固定资源分配** 资源静态分配给任务的优点在于提供了透明且清晰的职责划分。然而，固定的资源限制会在运行时导致低效，当资源没有被其分配的任务使用时，另一个任务本可以使用该资源，但由于限制无法使用。'
- en: '**Dynamic resource allocation**    To foster efficient resource use, resources
    can be allocated to specific tasks at runtime, based on task attributes that are
    used to derive a priority metric.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态资源分配** 为了促进资源的高效使用，可以根据任务属性在运行时将资源分配给特定任务，这些任务属性用于推导优先级指标。'
- en: These approaches should be considered during the design of your device’s hardware
    architecture and the selection of the main processing units. Moreover, the choice
    and configuration of your OS can have significant impacts on your device’s robustness.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计设备硬件架构和选择主要处理单元时，应考虑这些方法。此外，操作系统的选择和配置对设备的鲁棒性也有重要影响。
- en: '**Hardware-Level Implementation Options**'
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**硬件级实现选项**'
- en: A device’s hardware architecture defines its basic computing resource conditions.
    During its development, ICs for various purposes are selected, including microcontrollers,
    multicore SoCs, and FPGAs, but also dedicated chips like Ethernet PHYs that handle
    network communication on the physical layer.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 设备的硬件架构定义了其基本的计算资源条件。在开发过程中，选择了各种目的的集成电路（IC），包括微控制器、多核系统级芯片（SoC）和 FPGA，以及专用芯片，如处理物理层网络通信的以太网物理层（Ethernet
    PHY）。
- en: If robustness against network flooding is one of your main concerns and you
    take that into account at an early stage of your development process, you can
    design your device’s hardware architecture in a way that significantly reduces
    the risk of network-based DoS attacks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网络洪水的鲁棒性是你的主要关注点之一，并且你在开发过程的早期就考虑到了这一点，你可以设计设备的硬件架构，从而显著减少基于网络的拒绝服务（DoS）攻击的风险。
- en: '***Dedicated Preprocessing Unit***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***专用预处理单元***'
- en: '[Figure 10-2](ch10.xhtml#ch10fig02) shows the basic concept when introducing
    a dedicated preprocessing unit for network traffic. The main idea behind this
    architecture is the physical separation of the main application’s processor and
    the network processing, or at least parts of it.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-2](ch10.xhtml#ch10fig02)展示了在引入专用预处理单元处理网络流量时的基本概念。该架构的主要思想是物理上将主应用处理器和网络处理分开，或至少将其中一部分分离开来。'
- en: '![Image](../images/10fig02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/10fig02.jpg)'
- en: '*Figure 10-2: An architecture with network traffic preprocessing*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-2：带有网络流量预处理的架构*'
- en: One specific example of such an architecture is a *communication preprocessor*
    that implements a TCP/IP stack and takes care of processing network packets and
    their payload. The communication of relevant data between the main processor and
    the preprocessing unit is carried out over a preferably simple interface. In case
    of a flooding attack or just very high network load for unknown reasons, the communication
    unit is likely to run into resource exhaustion, but the application processor
    behind it will not be impacted and will be able to perform the device’s essential
    functions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构的一个具体例子是*通信预处理器*，它实现了TCP/IP协议栈并负责处理网络包及其负载。主处理器与预处理单元之间的相关数据通信通过一个尽可能简单的接口进行。遇到洪水攻击或由于未知原因造成的非常高的网络负载时，通信单元可能会出现资源耗尽，但其背后的应用处理器不会受到影响，仍然能够执行设备的基本功能。
- en: The use of a *hardware packet filtering unit* is a second example of this approach.
    Here, the network stack remains on the main processing unit, and the preprocessor
    is used only to filter the stream of network packets arriving at the device’s
    network interface. Rules for filtering might, for example, include rate limits
    to guarantee that your application processor receives only the number of packets
    it’s able to handle.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*硬件包过滤单元*是这种方法的第二个例子。在这种情况下，网络栈保留在主处理单元上，预处理器仅用于过滤到达设备网络接口的网络包流。过滤规则可能包括速率限制，确保应用处理器只接收它能够处理的包数量。
- en: Such an architecture could be implemented by specific networking ICs that provide
    this functionality, but, at the time of writing, these are rather uncommon in
    embedded systems. For devices hosting an FPGA, the MAC controller could be implemented
    in digital logic followed by a custom packet-filtering core before handing network
    data to the main CPU.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构可以通过提供此功能的特定网络集成电路（IC）来实现，但在写作时，这些IC在嵌入式系统中还相对较少见。对于托管FPGA的设备，MAC控制器可以通过数字逻辑实现，然后在将网络数据传递给主CPU之前，经过定制的包过滤核心。
- en: '**WARNING**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Be careful when designing the communication between a main processor and a
    preprocessing unit. If the former shows a heavy dependency on the latter, the
    device might fail despite the solid architecture.*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*在设计主处理器与预处理单元之间的通信时要小心。如果前者对后者的依赖过大，即使架构坚固，设备也可能会出现故障。*'
- en: '***Multicore Architectures***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***多核架构***'
- en: If digital robustness appears too late on the list of requirements and the hardware
    design is already fixed, you might be lucky if you’ve opted for a multicore SoC
    as the main processing unit in your device. Admittedly, individual cores in multicore
    chips are not completely separated and independent of one another; they share
    resources like buses, cache memories, and the like. However, a well-considered
    distribution of tasks among cores, as shown in [Figure 10-3](ch10.xhtml#ch10fig03),
    can reduce the probability of a DoS event.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数字鲁棒性要求在需求列表上出现得太晚，而硬件设计已经确定，那么如果你选择了多核SoC作为设备的主要处理单元，你可能会比较幸运。诚然，多核芯片中的单个核心并不是完全分离和独立的，它们共享总线、缓存等资源。然而，正如[图10-3](ch10.xhtml#ch10fig03)所示，合理的任务分配可以降低DoS事件的概率。
- en: '![Image](../images/10fig03.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/10fig03.jpg)'
- en: '*Figure 10-3: Using multicore architectures for robustness*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-3：使用多核架构提升系统鲁棒性*'
- en: An increasing number of SoCs for embedded systems implement *asymmetric multiprocessing
    (AMP)*. They include one or more high-performance cores that are meant to run
    feature-rich OSs, such as Linux, and one or more smaller cores that, for example,
    excel at real-time applications. One approach toward increased robustness could
    be the allocation of essential functions like control tasks to the dedicated real-time
    core, as indicated by [Figure 10-3](ch10.xhtml#ch10fig03)a. Similar structures
    are possible on SoCs that combine hard processors with soft cores that reside
    within an FPGA fabric.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越多的嵌入式系统SoC实现了*异构多处理（AMP）*。它们包括一个或多个高性能核心，用于运行功能丰富的操作系统，如Linux，还有一个或多个较小的核心，通常擅长实时应用。增强鲁棒性的一种方法可能是将控制任务等关键功能分配给专用的实时核心，如[图10-3](ch10.xhtml#ch10fig03)a所示。类似的结构在将硬处理器与位于FPGA架构中的软核心结合的SoC上也可以实现。
- en: If your device runs on a *symmetric multiprocessing (SMP)* SoC—which means it
    has two, four, eight, or even more cores of the same type—you still have options
    to improve robustness. The architecture in [Figure 10-3](ch10.xhtml#ch10fig03)b
    is meant to separate networking tasks from essential functions by binding their
    processes to dedicated cores. This concept is known as *core pinning*, or *processor
    affinity*, and has to be supported by your OS.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的设备运行在*对称多处理（SMP）* SoC上——这意味着它有两个、四个、八个甚至更多相同类型的核心——你仍然可以采取措施提高鲁棒性。[图10-3](ch10.xhtml#ch10fig03)b中的架构旨在通过将网络任务的进程绑定到专用核心来将其与关键功能分离。这种概念称为*核心绑定*或*处理器亲和性*，并且必须得到操作系统的支持。
- en: '**WARNING**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Again, (communication) dependencies between processes on different cores might
    break the intended separation and should be conceptualized with care.*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*再次强调，（通信）在不同核心上的进程之间的依赖关系可能会破坏预期的分离，应该谨慎地进行概念化。*'
- en: '**Operating System Capabilities**'
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**操作系统功能**'
- en: A central duty of an OS is the management of CPU cores, memory regions, and
    a diverse set of hardware interfaces. The component handling the difficult task
    of allocating processing time during runtime is called the *scheduler*. It’s absolutely
    reasonable to consider capabilities and responsibilities of OSs and schedulers
    when talking about preventing resource exhaustion.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统的一个核心任务是管理CPU核心、内存区域以及多种硬件接口。负责在运行时分配处理时间的组件被称为*调度器*。在讨论防止资源耗尽时，考虑操作系统和调度器的功能和职责是完全合理的。
- en: '***Operating System Options***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***操作系统选项***'
- en: 'When it comes to selecting an OS, device engineers have basically four options:
    bare-metal software without an OS, a real-time OS, a fully fledged OS, or a hypervisor-based
    OS combination.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择操作系统时，设备工程师基本上有四种选择：裸机软件（无操作系统）、实时操作系统、完整的操作系统或基于虚拟机的操作系统组合。
- en: '**Bare-Metal Software Without an OS**'
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**裸机软件（无操作系统）**'
- en: In simple devices and applications, an OS might not even be necessary. Events
    and corresponding resource allocation can be handled by polling loops or interrupt
    service routines.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的设备和应用中，操作系统甚至可能不是必需的。事件及其相应的资源分配可以通过轮询循环或中断服务程序来处理。
- en: '**Real-Time OS**'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**实时操作系统**'
- en: 'An RTOS is a rather low-complexity OS that is specifically meant for real-time
    applications that have a high interest in reliability. Its scheduler manages resources
    based on task priorities: tasks with a higher priority can interrupt currently
    running ones that have a lower priority.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实时操作系统（RTOS）是一种低复杂度的操作系统，专门用于对可靠性有高度需求的实时应用。它的调度器根据任务优先级来管理资源：优先级较高的任务可以中断当前运行的优先级较低的任务。
- en: In such a system, it’s important not to configure networking-related tasks as
    the top priority, because doing so could lead to network-induced DoS situations.
    In practice, you can find a variety of RTOSs in the field, including commercial
    ones like QNX or VxWorks, but also open source variants such as FreeRTOS, RIOT,
    or Zephyr.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的系统中，重要的是不要将与网络相关的任务配置为最高优先级，因为这样可能会导致网络引发的DoS情况。实际上，在该领域可以找到各种RTOS，包括商业的QNX或VxWorks，也有开源的变种，如FreeRTOS、RIOT或Zephyr。
- en: '**Fully Fledged OS**'
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**完整操作系统**'
- en: 'Many modern, feature-rich devices rely on open source libraries and tools that
    handle, for example, network communication, presentation of user interfaces, or
    data-processing tasks. Those devices are usually based on a fully fledged OS like
    Linux. However, such complex and not fully deterministic OSs share a disadvantage:
    the lack of proper real-time capabilities. In the next section, I’ll discuss a
    possibility that makes Linux more real-time capable.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代功能丰富的设备依赖于开源库和工具，处理例如网络通信、用户界面展示或数据处理任务。这些设备通常基于像 Linux 这样的完全功能的操作系统。然而，这类复杂且不完全确定性的操作系统有一个缺点：缺乏适当的实时能力。在下一节中，我将讨论一种使
    Linux 更具实时能力的可能性。
- en: '**Hypervisor-Based OS Combination**'
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**基于虚拟机监控器的操作系统组合**'
- en: 'Some manufacturers want to combine the real-time advantages of RTOSs with the
    many libraries and capabilities of Linux. In these cases, a further abstraction
    layer is introduced below those OSs: a *hypervisor* takes over the task of hardware
    resource allocation and thereby plays an important role in separating essential
    functions (probably running on top of an RTOS) from the supporting functionalities
    implemented within Linux. These setups further increase the complexity of your
    product’s software architecture.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一些制造商希望将实时操作系统（RTOS）的实时优势与 Linux 的众多库和功能结合起来。在这些情况下，在这些操作系统下引入了一个额外的抽象层：一个*虚拟机监控器*负责硬件资源分配的任务，从而在将核心功能（可能运行在
    RTOS 上）与在 Linux 中实现的支持功能分离方面发挥着重要作用。这些配置进一步增加了产品软件架构的复杂性。
- en: '***Linux with a Real-Time Patch***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***带实时补丁的 Linux***'
- en: In its typical configuration for desktop and server systems, Linux doesn’t offer
    reliable real-time capabilities. However, for several years, the real-time community
    has maintained a kernel patch known as `PREEMPT_RT`. It includes a variety of
    changes to the Linux kernel that share the common goal of enabling *preemption*
    of kernel threads and in-kernel primitives, which means that nondeterminism in
    task scheduling is reduced and computing resource allocation comes closer to a
    purely priority-based system. In current Linux kernel versions, you can activate
    real-time support with the `CONFIG_PREEMPT_RT` configuration option.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面和服务器系统的典型配置中，Linux 并不提供可靠的实时能力。然而，多年来，实时社区一直维护着一个名为`PREEMPT_RT`的内核补丁。它对 Linux
    内核进行了多项修改，目的是实现对内核线程和内核原语的*抢占*，这意味着任务调度中的非确定性减少，计算资源分配更接近纯粹基于优先级的系统。在当前的 Linux
    内核版本中，您可以通过 `CONFIG_PREEMPT_RT` 配置选项来启用实时支持。
- en: 'Thread scheduling in Linux happens based on a scheduling policy and a static
    scheduling priority. “Normal” threads are scheduled with policies like `SCHED_OTHER`,
    `SCHED_IDLE`, or `SCHED_BATCH` and a priority of 0\. Threads that have to fulfill
    real-time requirements are scheduled with one of the following policies:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 中的线程调度是基于调度策略和静态调度优先级进行的。“正常”线程按照像 `SCHED_OTHER`、`SCHED_IDLE` 或 `SCHED_BATCH`
    这样的策略调度，优先级为 0。必须满足实时要求的线程会根据以下策略之一进行调度：
- en: SCHED_FIFO    This scheduler follows the *first-in first-out (FIFO) principle*,
    which means that a running thread is executed until it is preempted by a thread
    with a higher static priority.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: SCHED_FIFO    该调度程序遵循*先进先出（FIFO）原则*，意味着正在运行的线程会一直执行，直到被一个具有更高静态优先级的线程抢占。
- en: SCHED_RR    The classic *round-robin (RR)* scheduling approach is similar to
    `SCHED_FIFO` except that threads are allowed to run for only a defined maximum
    amount of time. Afterward, the thread is interrupted and added to the end of the
    queue for threads with the same priority. Threads with higher priority may preempt
    those with lower priority.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: SCHED_RR    经典的*轮转调度（RR）*方法类似于 `SCHED_FIFO`，不同之处在于线程只能运行一定的最大时间。之后，线程被中断并添加到具有相同优先级的线程队列的末尾。具有更高优先级的线程可能会抢占较低优先级的线程。
- en: SCHED_DEADLINE    In contrast to the other schedulers, this one is based on
    *global earliest deadline first (GEDF)*. It doesn’t rely on static priorities
    but assigns them dynamically. Its decisions are based on a thread’s absolute deadline
    and its total computation time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: SCHED_DEADLINE    与其他调度程序不同，这个调度程序基于*全局最早截止时间优先（GEDF）*。它不依赖于静态优先级，而是动态分配优先级。其决策基于线程的绝对截止时间和总计算时间。
- en: '**NOTE**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Although* PREEMPT_RT *makes Linux behave more like a real-time OS, it’s still
    a complex piece of software that’s not suitable for many hard real-time requirements.*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管* PREEMPT_RT *使 Linux 更像实时操作系统，但它仍然是一个复杂的软件，不适合许多硬实时需求。*'
- en: '**Application and Protocol Considerations**'
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**应用与协议考虑事项**'
- en: While this chapter is primarily concerned with the robust device architecture
    on the hardware and OS level, I don’t want to ignore the application and communication
    levels. Many DoS situations in the real world arise from sloppy software and protocol
    design.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要关注硬件和操作系统层面上稳健的设备架构，但我并不想忽视应用层和通信层。现实世界中，许多DoS情形源于软件和协议设计的不严谨。
- en: Such issues can be introduced in various phases of the development process.
    A protocol specification might already lack a solid definition of correct behavior
    in corner cases—for example, minimum or maximum values of message parameters.
    Further, even simple bugs in software, such as missing bounds checking, can lead
    to undesired side effects like endless loops or deadlocks under certain circumstances.
    Then, if security testing is performed only superficially, devices leave production
    with firmware that gives attackers the opportunity to trigger a DoS event with
    as little effort as a single network packet.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题可能在开发过程的不同阶段引入。协议规范可能已经缺乏对极端情况正确行为的明确定义——例如，消息参数的最小值或最大值。此外，软件中的简单错误，比如缺少边界检查，也可能在特定情况下导致不希望的副作用，如无限循环或死锁。如果仅进行表面上的安全测试，设备就可能带着固件进入生产，而这些固件给攻击者留下了通过单个网络数据包触发DoS事件的机会。
- en: The following sections provide practical suggestions for tackling this complex
    issue. The important possibility you should be looking for is an attacker’s ability
    to *force a state transition* within your device that results in a DoS.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节提供了解决这一复杂问题的实用建议。你应该关注的一个重要可能性是攻击者能够*强制设备状态转变*，从而导致拒绝服务（DoS）攻击。
- en: '***Identify Logical Flaws***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***识别逻辑缺陷***'
- en: Protocol design is a complex task, but many companies take this path and develop
    their own, proprietary message and communication format. If you find yourself
    in such a situation, be sure to do your best to eliminate logical flaws in your
    protocol.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 协议设计是一项复杂的任务，但许多公司选择这条路，开发自己的专有消息和通信格式。如果你发现自己处于这种情况，一定要尽力消除协议中的逻辑缺陷。
- en: 'First, you can do that on the concept level by asking questions like these:
    What is the range of validity for each value in our messages? Is a network participant
    able to force our device into an undefined state? Are the validity and plausibility
    of message values verified before they’re used? Second, testing your protocol
    implementation with messages that only partially fulfill the specification or
    even try to manipulate your device’s state on purpose can be helpful for discovering
    vulnerabilities.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以从概念层面开始，提出以下问题：我们消息中每个值的有效范围是什么？网络参与者能否强制我们的设备进入未定义的状态？在使用消息之前，是否验证了消息值的有效性和合理性？其次，使用仅部分满足规范或甚至故意尝试操控设备状态的消息来测试你的协议实现，可以帮助发现漏洞。
- en: '***Implement Input and Sender Validation***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实施输入和发送者验证***'
- en: In many embedded system scenarios, an adversary is able to communicate directly
    with a device—for example, over the network. Even if official client software
    *should* be used for interacting with your device, attackers might simply craft
    their own manipulated messages, so devices shouldn’t trust any packet arriving
    at their network interface.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多嵌入式系统场景中，攻击者能够直接与设备通信——例如，通过网络。即使应该使用官方客户端软件与设备进行交互，攻击者也可能会自行构造被篡改的消息，因此设备不应信任任何到达其网络接口的数据包。
- en: Critical commands, such as switching into update mode and halting all operations,
    should be allowed only after the authenticity of the sender has been verified
    successfully. Therefore, a developer’s default attitude should be to *expect*
    malicious input and implement suitable input validation and filtering mechanisms
    accordingly, whether on the firewall level or within the application that processes
    a message’s payload.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 关键命令，如切换到更新模式和停止所有操作，只有在成功验证发送者的身份后才能执行。因此，开发者的默认态度应该是*预期*恶意输入，并相应地实现合适的输入验证和过滤机制，无论是在防火墙层面还是在处理消息有效载荷的应用程序内部。
- en: '***Analyze Active Protection Measures***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分析主动保护措施***'
- en: Sometimes attackers can misuse active protection measures to force a device
    into a DoS state. For example, your login process might be hardened to prohibit
    brute-force attacks by allowing only 10 login attempts. After reaching that limit,
    the device changes into a locked mode from which it can be reactivated only by
    a recovery procedure. While this might be an absolutely reasonable security measure,
    it also allows attackers to force a DoS situation, even for legitimate users,
    by entering the wrong user credentials 10 times.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，攻击者可能会滥用主动保护措施，将设备强制置于拒绝服务（DoS）状态。例如，你的登录过程可能会被加固，以通过仅允许10次登录尝试来防止暴力破解攻击。达到该限制后，设备会进入锁定模式，只有通过恢复程序才能重新激活。虽然这可能是一个完全合理的安全措施，但它也允许攻击者通过输入错误的用户凭证10次来强制产生DoS状态，即便是合法用户也会受到影响。
- en: Firewall configurations that block IPs based on their amount of traffic have
    similar mechanisms. In that case, attackers might spoof sender IP addresses of
    valid devices and trigger the protection feature by sending a large number of
    packets. As a result, the communication attempts of legitimate devices will be
    blocked afterward.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 基于流量数量阻止IP的防火墙配置也有类似的机制。在这种情况下，攻击者可能会伪造有效设备的发送者IP地址，通过发送大量数据包来触发保护功能。结果，合法设备的通信尝试随后会被阻塞。
- en: '***Introduce Chaos Engineering and Fuzzing***'
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***引入混沌工程与模糊测试***'
- en: The human imagination is limited. It’s unrealistic to assume that developers
    will anticipate all potential issues that might lead to a DoS event on your device.
    Two testing methods push the limits in this regard, however.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 人类的想象力是有限的。假设开发人员能预见到所有可能导致设备DoS事件的问题是不现实的。然而，有两种测试方法可以在这方面突破极限。
- en: '*Chaos engineering* is a kind of reliability and resilience testing for IT
    systems that introduces “chaos” into an IT infrastructure in the form of random
    failures of services or applications. In the area of embedded system testing,
    this “chaos” can be crashed processes or the loss of communication channels in
    order to analyze the device’s behavior under adverse circumstances.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*混沌工程*是一种针对IT系统的可靠性和韧性测试，通过在IT基础设施中引入“混沌”——即随机失败的服务或应用程序，来进行测试。在嵌入式系统测试领域，这种“混沌”可以表现为崩溃的进程或失去的通信通道，从而分析设备在不利环境下的行为。'
- en: The discipline of *fuzzing* might be applied to communication protocols, but
    also on input data like the configuration files or certificates that a device
    processes. It can be used to create a large number of test messages or test files
    by cleverly mutating input data many times. In this way, you can discover cases
    that lead to a DoS state that would have been very hard to find by manual, human
    analysis.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*模糊测试*的学科可以应用于通信协议，也可以应用于设备处理的输入数据，如配置文件或证书。它可以通过巧妙地多次变异输入数据，创建大量的测试消息或测试文件。通过这种方式，你可以发现那些通过人工分析非常难以发现的、会导致DoS状态的情况。'
- en: '**NOTE**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All that said, keep in mind that your product development team’s mindset and
    awareness can be decisive factors in detecting DoS vulnerabilities early in your
    development process.*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*话虽如此，请记住，产品开发团队的思维方式和意识，可能是早期发现DoS漏洞的决定性因素。*'
- en: '**Case Study: Robustness Options on an STM32MP157F Device**'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**案例研究：STM32MP157F设备的鲁棒性选项**'
- en: In this case study, I’ll analyze the real-time and robustness capabilities of
    an STM32MP157F device. I’ll shed light on corresponding measurement methods and
    tools used to simulate CPU and network stress on a device.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本案例研究中，我将分析STM32MP157F设备的实时性和鲁棒性能力。我将阐明用于模拟设备CPU和网络压力的相应测量方法和工具。
- en: '***Basic System Properties***'
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基本系统属性***'
- en: Regarding hardware-level options, the STM32MP157F device at hand provides two
    Cortex-A7 cores running at 800 MHz and a dedicated Cortex-M4 core at 209 MHz for
    real-time applications. This basic information allows us to conclude that both
    pinning tasks to one of the A7 cores and moving essential software applications
    to the separated M4 core would be possible. In principle, using the M4 core as
    a preprocessing unit for Ethernet traffic might even be an option, but that’s
    probably not the first solution I would pursue, and it would require further feasibility
    analysis based on the SoC’s architecture.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬件级别选项方面，当前使用的STM32MP157F设备提供了两个运行在800 MHz的Cortex-A7核心和一个运行在209 MHz的专用Cortex-M4核心，用于实时应用。这个基本信息使我们可以得出结论：既可以将任务绑定到A7核心之一，也可以将关键软件应用程序移到分离的M4核心。原则上，使用M4核心作为以太网流量的预处理单元甚至可能是一种选择，但这可能不是我首先会考虑的方案，且需要基于SoC架构进一步进行可行性分析。
- en: The MAC unit included in the STM32MP157F’s Ethernet peripheral supports data
    transfer rates of 10, 100, and 1,000Mbps. After looking into ST’s *Reference Manual
    RM0436* for STM32MP157F devices, it becomes clear that this module even comes
    with hardware-assisted packet filtering. Received packets can be filtered based
    on their source and destination MAC addresses, the virtual local area network
    (VLAN) tag in the Ethernet frame of a packet, the source and destination IP address,
    and the source and destination port of TCP and UDP messages. Unfortunately, the
    module doesn’t have any kind of rate-limiting feature, which would be useful for
    DoS protection.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: STM32MP157F的以太网外设中包含的MAC单元支持10、100和1,000Mbps的数据传输速率。在查阅了ST针对STM32MP157F设备的*参考手册RM0436*之后，我们可以清楚地看到该模块还支持硬件加速的数据包过滤。接收到的数据包可以根据其源和目标MAC地址、以太网帧中的虚拟局域网（VLAN）标签、源和目标IP地址以及TCP和UDP消息的源和目标端口进行过滤。不幸的是，该模块没有任何形式的速率限制功能，这在DoS保护中会非常有用。
- en: The third part of this initial analysis concerns the Linux OS running on my
    STM32MP157F device. As previously described, Linux can be patched or configured
    to behave similarly to a real-time system. With the command and output shown in
    [Listing 10-1](ch10.xhtml#ch10list01), I checked whether my Linux system, which
    was created by Yocto based on ST’s `st-image-core` image, comes with real-time
    scheduling capabilities.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本次初步分析的第三部分涉及我STM32MP157F设备上运行的Linux操作系统。如前所述，Linux可以通过补丁或配置使其行为类似于实时系统。通过[列表10-1](ch10.xhtml#ch10list01)中的命令和输出，我检查了我的Linux系统，它是基于ST的`st-image-core`镜像通过Yocto创建的，是否具备实时调度功能。
- en: '[PRE0]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 10-1: The Linux kernel properties of my system*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-1：我系统的Linux内核属性*'
- en: The string `SMP` points out that the Linux system at hand was configured at
    compile time to support symmetric multicore architectures like the A7 dual core
    of the STM32MP157F, while `PREEMPT` indicates that the Linux kernel was compiled
    with the `CONFIG_PREEMPT` option. The system runs a *low-latency kernel*, which
    means that kernel code not executed in a critical section can be interrupted by
    higher-priority tasks. However, this configuration shouldn’t be confused with
    the `PREEMPT_RT` indicator, which represents a fully preemptible Linux kernel
    enabled by `CONFIG_PREEMPT_RT`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串`SMP`指出，当前的Linux系统在编译时已配置为支持对称多核架构，如STM32MP157F的A7双核，而`PREEMPT`则表示Linux内核是通过`CONFIG_PREEMPT`选项编译的。该系统运行一个*低延迟内核*，这意味着内核代码在非关键区段执行时，可以被更高优先级的任务中断。然而，这种配置不应与`PREEMPT_RT`指示符混淆，后者代表的是通过`CONFIG_PREEMPT_RT`启用的完全可抢占Linux内核。
- en: '***Measurements on a Low-Latency Kernel***'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***低延迟内核的测量***'
- en: You can measure a device’s latency behavior in two ways. If you have internal
    access to the device’s Linux system, you can run software that analyzes the scheduling
    behavior of that Linux system. On the other hand, for example, if you analyze
    a third-party component, you might be forced to regard the device under testing
    as a black box. In such a case, you can observe the device’s latency behavior
    only with respect to input and output signals—for example, with an oscilloscope
    or a logic analyzer. While the former approach is more suitable for showing the
    principle capabilities of a device, the latter can yield results that are much
    closer to a specific use case.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式来测量设备的延迟行为。如果你可以访问设备的 Linux 系统，你可以运行分析该 Linux 系统调度行为的软件。另一方面，例如，如果你分析一个第三方组件，你可能不得不将待测设备视为一个黑箱。在这种情况下，你只能通过输入和输出信号来观察设备的延迟行为——例如，通过示波器或逻辑分析仪。前一种方法更适合展示设备的基本能力，而后一种方法可以得出更接近特定应用场景的结果。
- en: In this case study, I use the `cyclictest` tool to analyze the system’s real-time
    capabilities because I have access to the device’s Linux console and I don’t yet
    have a specific application in mind. This tool measures the latency between the
    programmed and the actual execution of a real-time task scheduled with `SCHED_FIFO`.
    [Listing 10-2](ch10.xhtml#ch10list02) shows a sample test and its results.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例研究中，我使用 `cyclictest` 工具来分析系统的实时能力，因为我可以访问设备的 Linux 控制台，并且我目前没有特定的应用程序。该工具测量使用
    `SCHED_FIFO` 调度的实时任务的编程执行和实际执行之间的延迟。[清单 10-2](ch10.xhtml#ch10list02) 显示了一个测试样本及其结果。
- en: '[PRE1]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 10-2: The task latency in idle mode*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-2：空闲模式下的任务延迟*'
- en: The `--mlockall` parameter is used to reduce overhead and influences from the
    tool itself, while `--smp` is necessary for testing on a multicore system. The
    measuring thread is executed every 200 *µ*s as set by the `--interval` option,
    and there’s no difference between the measuring periods of the various threads,
    as denoted by `--distance=0`. The measuring tasks are executed 40,000 times (`--loops=40000`)
    with a task priority of 80 (`--priority=80`).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`--mlockall` 参数用于减少工具本身的开销和影响，而 `--smp` 则是多核系统测试所必需的。测量线程按照 `--interval` 选项设定的每
    200 *µ*s 执行，并且不同线程的测量周期没有区别，正如 `--distance=0` 所表示的那样。测量任务执行了 40,000 次（`--loops=40000`），任务优先级为
    80（`--priority=80`）。'
- en: The result output shows two lines, one for each CPU core. The letters `P`, `I`,
    and `C` stand for the priority setting, measuring interval, and count of performed
    measurements, respectively. The values on the right show the minimal, actual,
    average, and maximum observed latency. The rightmost number is the most important
    one because it indicates worst-case latencies for scheduled tasks that may or
    may not be tolerable for you.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出显示了两行，每行对应一个 CPU 核心。字母 `P`、`I` 和 `C` 分别表示优先级设置、测量间隔和执行测量的次数。右侧的值显示了最小、实际、平均和最大观察到的延迟。最右边的数字是最重要的，因为它表示对计划任务的最差延迟，这可能对你来说是可以接受的，也可能是不可接受的。
- en: In the current state, the given Linux system with a `PREEMPT` low-latency kernel
    shows maximum latencies of 158 and 165 *µ*s. However, if I use a second device
    on the same network to apply a SYN flooding attack—for example, by running `hping3
    --syn --flood` device-ip, the maximum latency is affected significantly, as shown
    in [Listing 10-3](ch10.xhtml#ch10list03).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前状态下，给定的 Linux 系统使用 `PREEMPT` 低延迟内核显示出最大延迟为 158 和 165 *µ*s。然而，如果我使用同一网络上的第二个设备进行
    SYN 洪水攻击——例如，运行 `hping3 --syn --flood` device-ip，最大延迟会显著受到影响，如[清单 10-3](ch10.xhtml#ch10list03)所示。
- en: '[PRE2]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 10-3: The effect of SYN flooding on task latency*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-3：SYN 洪水对任务延迟的影响*'
- en: In such a situation, even with a low-latency kernel, task latency might rise
    to over 5 ms, a multiple of the actual task interval. Clearly, this could be critical
    if your application has to fulfill real-time requirements. [Listing 10-4](ch10.xhtml#ch10list04)
    shows a sample measurement result while a simple port scan was performed with
    `nmap` device-ip.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，即使使用低延迟内核，任务延迟也可能上升到超过 5 毫秒，这是实际任务间隔的多倍。显然，如果你的应用程序必须满足实时要求，这可能是至关重要的。[清单
    10-4](ch10.xhtml#ch10list04) 显示了在执行简单端口扫描时使用 `nmap` device-ip 得到的测量结果。
- en: '[PRE3]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 10-4: The effect of a SYN scan with* nmap *on task latency*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-4：SYN 扫描对任务延迟的影响* nmap'
- en: In conclusion, we can see that the low-latency kernel of the standard Linux
    distribution for the STM32MP157F device isn’t able to provide strong real-time
    features. Even short periods of intense network traffic can affect the system’s
    reaction times.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们可以看到，针对 STM32MP157F 设备的标准 Linux 发行版的低延迟内核无法提供强大的实时特性。即使是短时间的强烈网络流量也会影响系统的反应时间。
- en: '***Measurements on a Real-Time Kernel***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实时内核的测量***'
- en: If robustness is one of your top requirements, you might want to look for a
    Linux distribution that implements a fully preemptible kernel to fulfill real-time
    constraints. Luckily, ST provides the Yocto layer `meta-st-x-linux-rt` for the
    STM32MP157F device. After adding it to my build system, I only have to set `MACHINE=stm32mp15-rt`
    and re-create the build environment before I can use `bitbake` to generate the
    `st-image-core` image and a Linux kernel with `CONFIG_PREEMPT_RT` enabled.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果稳健性是你的主要需求之一，你可能需要寻找实现了完全可抢占内核的 Linux 发行版，以满足实时约束。幸运的是，ST 为 STM32MP157F 设备提供了
    Yocto 层 `meta-st-x-linux-rt`。将其添加到我的构建系统后，我只需设置 `MACHINE=stm32mp15-rt` 并重新创建构建环境，然后就可以使用
    `bitbake` 生成启用了 `CONFIG_PREEMPT_RT` 的 `st-image-core` 镜像和 Linux 内核。
- en: After booting the new image, I double-checked that the kernel actually provides
    real-time capabilities. The output in [Listing 10-5](ch10.xhtml#ch10list05) shows
    the typical `PREEMPT_RT` feature as desired.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 启动新镜像后，我再次确认内核实际上提供了实时功能。[列表 10-5](ch10.xhtml#ch10list05)中的输出显示了典型的 `PREEMPT_RT`
    特性，如所期望的那样。
- en: '[PRE4]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 10-5: The Linux kernel features including real-time capabilities*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-5：包括实时功能的 Linux 内核特性*'
- en: Again, you can test the system’s real-time behavior with `cyclictest` as in
    the previous section. [Listing 10-6](ch10.xhtml#ch10list06) shows the positive
    effects of the real-time kernel.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你可以像上一节那样使用`cyclictest`测试系统的实时表现。[列表 10-6](ch10.xhtml#ch10list06)显示了实时内核的正面效果。
- en: '[PRE5]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 10-6: The task latency of the real-time kernel in idle mode*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-6：空闲模式下实时内核的任务延迟*'
- en: In comparison to the low-latency kernel’s values in [Listing 10-2](ch10.xhtml#ch10list02),
    158 and 165 *µ*s, the maximum latency was significantly reduced to 64 and 72 *µ*s,
    respectively. The results shown in [Listing 10-7](ch10.xhtml#ch10list07) indicate
    even better behavior.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与[列表 10-2](ch10.xhtml#ch10list02)中低延迟内核的值（158 和 165 *µ*秒）相比，最大延迟显著降低至 64 和 72
    *µ*秒，分别是。 [列表 10-7](ch10.xhtml#ch10list07)中的结果显示了更好的表现。
- en: '[PRE6]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 10-7: The effect of SYN flooding on the real-time kernel’s latency*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-7：SYN 洪泛对实时内核延迟的影响*'
- en: The maximum latency of the Linux system doesn’t exceed 100 *µ*s, even in the
    face of a SYN flooding attack performed with `hping3`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在进行 `hping3` 执行的 SYN 洪泛攻击时，Linux 系统的最大延迟也不会超过 100 *µ*秒。
- en: You can observe a similar effect in [Listing 10-8](ch10.xhtml#ch10list08), which
    was captured while running network scans on the device under test.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[列表 10-8](ch10.xhtml#ch10list08)中观察到类似的效果，该结果是在测试设备上运行网络扫描时捕获的。
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 10-8: The effect of a SYN scan with* nmap *on the real-time kernel’s
    latency*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-8：使用* nmap *进行 SYN 扫描对实时内核延迟的影响*'
- en: While common `nmap` commands provoked worst-case latencies of more than 6 ms
    for the standard image with its low-latency kernel, the real-time kernel analyzed
    in this section can be incited to raise maximum latencies by only less than 15
    *µ*s compared to the idle state.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然常见的 `nmap` 命令会使标准镜像的低延迟内核引发超过 6 毫秒的最坏情况延迟，但本节分析的实时内核只会使最大延迟比空闲状态增加不到 15 *µ*秒。
- en: What all this amounts to is that a low-latency Linux kernel doesn’t guarantee
    any robustness, and even a fully preemptible Linux kernel comes only close to
    real-time behavior. If this is a viable option for you, make sure to understand
    that you trade performance for determinism when switching to the real-time Linux
    kernel. Further, features like the SoC’s dynamic power management and frequency
    scaling might be deactivated to reach real-time behavior.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，低延迟 Linux 内核并不保证任何稳健性，即使是完全可抢占的 Linux 内核也只能接近实时表现。如果这是一个可行的选项，务必理解切换到实时
    Linux 内核时，你是以牺牲性能换取确定性。此外，为了实现实时行为，诸如 SoC 的动态功率管理和频率缩放等特性可能会被禁用。
- en: '**NOTE**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*All the presented measurements of maximum latency have to be regarded as only
    rough estimations. Your device could run into an even worse condition that leads
    to even higher maximum reaction times.*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有展示的最大延迟测量值都应视为粗略估算。你的设备可能会遇到更糟糕的情况，导致更高的最大反应时间。*'
- en: '***Real-Time Coprocessor***'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实时协处理器***'
- en: If you’re aiming to fulfill hard real-time requirements, Linux is likely not
    your best choice. However, the STM32MP157F provides an additional Cortex-M4 core
    for exactly that purpose. The development and build process of dedicated M4 firmware
    is beyond the scope of this case study, but you can use ST’s STM32CubeIDE or your
    favorite customized makefile for that purpose.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想满足硬实时需求，Linux 可能不是最佳选择。然而，STM32MP157F 提供了一个额外的 Cortex-M4 核心，正是为了这个目的。专用
    M4 固件的开发和构建过程超出了本案例研究的范围，但你可以使用 ST 的 STM32CubeIDE 或你最喜欢的定制 Makefile 来实现这一目标。
- en: Let’s assume you’ve created a firmware file *m4_fw.elf* that contains your real-time
    application. Typically, you would place that file in the */lib/firmware/* directory,
    as it’s firmware for a coprocessor. [Listing 10-9](ch10.xhtml#ch10list09) shows
    the basic initialization of Linux’s `remoteproc` framework to prepare M4 firmware
    execution.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经创建了一个包含实时应用程序的固件文件 *m4_fw.elf*。通常，你会将该文件放在 */lib/firmware/* 目录中，因为它是协处理器的固件。[清单
    10-9](ch10.xhtml#ch10list09) 显示了 Linux `remoteproc` 框架的基本初始化，以准备 M4 固件的执行。
- en: '[PRE8]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 10-9: Initializing M4 firmware using the* remoteproc *framework*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-9：使用* remoteproc *框架初始化 M4 固件*'
- en: In the first step, the firmware path */lib/firmware/* is written to the corresponding
    `sysfs` node. Afterward, the name of the specific firmware file, *m4_fw.elf* in
    this case, is passed to the remote processor instance `remoteproc0`, representing
    the M4 real-time core.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，固件路径 */lib/firmware/* 被写入相应的 `sysfs` 节点。随后，特定固件文件的名称（在此案例中为 *m4_fw.elf*）会传递给远程处理器实例
    `remoteproc0`，代表 M4 实时核心。
- en: At this point, nothing runs. The output in [Listing 10-10](ch10.xhtml#ch10list010)
    confirms that the M4 is still offline. To start the provided firmware, the `start`
    keyword has to be written to `remoteproc0/state`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，什么都没有运行。[清单 10-10](ch10.xhtml#ch10list010) 中的输出确认 M4 仍然处于离线状态。要启动提供的固件，必须将
    `start` 关键字写入 `remoteproc0/state`。
- en: '[PRE9]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 10-10: Starting M4 firmware using the* remoteproc *framework*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-10：使用* remoteproc *框架启动 M4 固件*'
- en: Subsequently, the core is powered up, and execution of the real-time application
    begins. Now, even if the Linux system suffers from high network load and is running
    out of resources, the real-time firmware will continue operating at its CPU’s
    clock frequency of 209 MHz unperturbed. Also, the state of `remoteproc0` has changed
    to `running`, accordingly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，核心被启动，实时应用程序的执行开始。即使 Linux 系统遭遇高网络负载并且资源耗尽，实时固件也会继续以其 CPU 时钟频率 209 MHz 不受干扰地运行。同时，`remoteproc0`
    的状态已相应更改为 `running`。
- en: As shown in [Listing 10-11](ch10.xhtml#ch10list011), the Linux system is able
    to stop the firmware execution by writing `stop` to `remoteproc0/state`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [清单 10-11](ch10.xhtml#ch10list011) 所示，Linux 系统可以通过写入 `stop` 到 `remoteproc0/state`
    来停止固件的执行。
- en: '[PRE10]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 10-11: Stopping M4 firmware using the* remoteproc *framework*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-11：使用* remoteproc *框架停止 M4 固件*'
- en: If necessary for your application, Linux’s remote processor messaging (RPMsg)
    framework enables the exchange of information between the main CPUs and the coprocessor.
    However, make sure to avoid strong dependencies of the real-time application on
    the Linux system as this might cause your whole device to stumble, again.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用需要，Linux 的远程处理器消息（RPMsg）框架可以在主 CPU 和协处理器之间交换信息。然而，确保避免实时应用对 Linux 系统的强依赖，因为这可能会导致整个设备再次发生故障。
- en: '**Summary**'
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Many industries regard robustness as a fundamental feature for all their devices.
    However, when it comes to highly interconnected and automated systems, both customers
    and manufacturers typically have difficulty specifying their understanding of
    digital robustness.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 许多行业将鲁棒性视为所有设备的基本特性。然而，当涉及到高度互联和自动化的系统时，客户和制造商通常很难明确规定他们对数字鲁棒性的理解。
- en: This chapter bridged the gap between the real-time world of embedded systems
    and the security protection goal of availability. The most important takeaways
    for device engineers and architects should be that they must consider potential
    digital stress on the network and other interfaces, essential functions of their
    devices that should work properly even under attack, and architecture decisions
    that support true real-time behavior.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本章弥合了嵌入式系统的实时世界与可用性安全保护目标之间的差距。设备工程师和架构师应当从中得到的最重要的启示是，他们必须考虑网络和其他接口上可能的数字压力、即使在遭受攻击时也应正常工作的设备核心功能，以及支持真正实时行为的架构决策。
- en: Options for achieving a robust device architecture range from the integration
    of dedicated hardware resources to the separation of duties within multicore SoCs
    to the careful selection and configuration of a device’s OS. But, again, as shown
    in this chapter’s case study, nothing replaces the practical evaluation of your
    device’s behavior during idle and potential situations of stress.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 实现稳健设备架构的选项从集成专用硬件资源到在多核SoC中分离职责，再到精心选择和配置设备操作系统不等。但正如本章案例研究所示，**没有什么能够替代在空闲状态和潜在压力情况下对设备行为的实际评估**。
