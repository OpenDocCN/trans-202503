- en: '## **15'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **15'
- en: ECLIPSE AND GHIDRADEV**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: ECLIPSE 和 GHIDRADEV**
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/com.jpg)'
- en: The scripts that are distributed with Ghidra and the scripts we created in [Chapter
    14](ch14.xhtml#ch14) are relatively simple. The coding required was minimal, which
    greatly simplified the development and testing phases. The basic script editor
    provided by Ghidra’s Script Manager is fine for quick-and-dirty work, but it lacks
    the sophistication to manage complex projects. For more substantial tasks, Ghidra
    provides a plugin that facilitates development using the Eclipse development environment.
    In this chapter, we look at Eclipse and the role it can play in the development
    of more advanced Ghidra scripts. We also show how Eclipse can be used to create
    new Ghidra modules and revisit this topic in later chapters as we expand Ghidra’s
    inventory of loaders and discuss the inner workings of Ghidra processor modules.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 附带的脚本以及我们在 [第14章](ch14.xhtml#ch14) 中创建的脚本相对简单。所需的编码非常少，这大大简化了开发和测试阶段。Ghidra
    的脚本管理器提供的基本脚本编辑器适合快速且简单的工作，但它缺乏管理复杂项目的能力。对于更复杂的任务，Ghidra 提供了一个插件，方便在 Eclipse 开发环境中进行开发。在本章中，我们将讨论
    Eclipse 以及它在开发更高级 Ghidra 脚本中的作用。我们还将展示如何使用 Eclipse 创建新的 Ghidra 模块，并在后续章节中重新讨论这一主题，随着我们扩展
    Ghidra 的加载器库并讨论 Ghidra 处理器模块的内部工作原理。
- en: '### **Eclipse**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '### **Eclipse**'
- en: '*Eclipse* is an integrated development environment (IDE) that is used by many
    Java developers, which makes it a natural fit for Ghidra development. While it
    is possible to run both Eclipse and Ghidra on the same machine without any interaction
    between them, the integration of the two can greatly simplify Ghidra development.
    Without integration, Eclipse would just be another script editing option outside
    the Ghidra environment. By integrating Eclipse with Ghidra, you suddenly have
    a rich IDE that includes Ghidra-specific functionality, resources, and templates
    to facilitate your Ghidra development process. Integrating Eclipse and Ghidra
    does not require significant effort; you just need to provide each with some information
    about the other so that they can be used together.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*Eclipse* 是一个集成开发环境（IDE），被许多 Java 开发者使用，这使它成为 Ghidra 开发的自然选择。虽然可以在同一台机器上运行
    Eclipse 和 Ghidra，而两者之间没有任何交互，但集成这两者可以大大简化 Ghidra 开发过程。如果没有集成，Eclipse 就只是 Ghidra
    环境外的另一种脚本编辑选项。通过将 Eclipse 与 Ghidra 集成，你会突然拥有一个功能丰富的 IDE，其中包括 Ghidra 特定的功能、资源和模板，来促进你的
    Ghidra 开发过程。集成 Eclipse 和 Ghidra 并不需要太多工作，你只需要为两者提供一些关于彼此的信息，便能实现它们的共同使用。'
- en: '***Eclipse Integration***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Eclipse 集成***'
- en: In order for Ghidra to work with Eclipse, Eclipse needs to have the GhidraDev
    plugin installed. You can integrate the two applications from within either Ghidra
    or Eclipse. Instructions for both integration approaches are included in the *GhidraDev_README.html*
    document found in the *Extensions/Eclipse/GhidraDev* directory of your Ghidra
    installation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Ghidra 与 Eclipse 配合使用，Eclipse 需要安装 GhidraDev 插件。你可以通过 Ghidra 或 Eclipse 内部将两者集成。有关两种集成方式的说明，请参阅位于
    Ghidra 安装目录下的 *Extensions/Eclipse/GhidraDev* 目录中的 *GhidraDev_README.html* 文档。
- en: While the written documentation does walk you through the details of the process,
    the easiest starting point is to select a Ghidra action that requires Eclipse,
    such as Edit Script with Eclipse (refer to [Figure 14-2](ch14.xhtml#fig14_2)).
    If you select this option and have not previously integrated Eclipse and Ghidra,
    you will be prompted for the directory information required to make the connection.
    Depending on your configuration, you may need to provide the path to your Eclipse
    installation directory, your Eclipse workspace directory, your Ghidra installation
    directory, your Eclipse drop-in directory, and possibly the port number used to
    communicate with Eclipse for script editing.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管书面文档会指导你完成整个过程，但最简单的起点是选择一个需要 Eclipse 的 Ghidra 操作，例如使用 Eclipse 编辑脚本（参见 [图
    14-2](ch14.xhtml#fig14_2)）。如果你选择这个选项，并且之前没有集成 Eclipse 和 Ghidra，你将被提示输入所需的目录信息以完成连接。根据你的配置，你可能需要提供
    Eclipse 安装目录、Eclipse 工作区目录、Ghidra 安装目录、Eclipse 插件目录，可能还需要提供用于与 Eclipse 进行脚本编辑通信的端口号。
- en: Ghidra’s documentation will help you overcome any obstacles that you encounter
    during the integration process. The truly adventurous can explore the integration
    plugins in the *Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/eclipse*
    directory in Ghidra’s source repository.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 的文档将帮助你克服集成过程中遇到的任何障碍。真正敢于冒险的人可以探索 Ghidra 源代码库中的 *Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/eclipse*
    目录下的集成插件。
- en: '***Starting Eclipse***'
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启动 Eclipse***'
- en: Once Ghidra and Eclipse are successfully integrated, you can use them for writing
    Ghidra scripts and plugins. The first time you launch Eclipse after it has been
    integrated with Ghidra, you are likely to see the dialog shown in [Figure 15-1](ch15.xhtml#fig15_1),
    requesting to establish a communication path between your Ghidra instance and
    your Eclipse GhidraDev instance.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Ghidra 和 Eclipse 成功集成，你就可以使用它们编写 Ghidra 脚本和插件。在 Ghidra 与 Eclipse 集成后第一次启动
    Eclipse 时，你可能会看到[图 15-1](ch15.xhtml#fig15_1)中显示的对话框，要求在 Ghidra 实例和 Eclipse GhidraDev
    实例之间建立通信路径。
- en: 'Venturing onward, you will see the Eclipse IDE welcome screen, as shown in
    [Figure 15-2](ch15.xhtml#fig15_2). This instance of Eclipse has a new addition
    on the menu bar: GhidraDev. This is the menu we will use to create more complex
    scripts and Ghidra tools.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，你将看到 Eclipse IDE 欢迎界面，如[图 15-2](ch15.xhtml#fig15_2)所示。这个 Eclipse 实例的菜单栏上新增了一个选项：GhidraDev。我们将使用这个菜单来创建更复杂的脚本和
    Ghidra 工具。
- en: The landing page for Ghidra Eclipse, the Welcome to the Eclipse IDE for Java
    Developers workbench, includes links to numerous tutorials, documentation, and
    information about the Eclipse IDE and Java that should provide the necessary background
    support to users new to Eclipse as well as an optional refresher for experienced
    users. To move ahead with Ghidra, we will focus our discussion on how the GhidraDev
    menu can be used to augment Ghidra’s existing capabilities, build new capabilities,
    and customize Ghidra to improve our reverse engineering workflow.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra Eclipse 的登录页面，欢迎来到 Eclipse IDE for Java 开发者工作台，包括多个教程、文档以及有关 Eclipse
    IDE 和 Java 的信息，这些内容应该为新手用户提供必要的背景支持，同时也为有经验的用户提供可选的复习材料。为了继续使用 Ghidra，我们将重点讨论如何使用
    GhidraDev 菜单来增强 Ghidra 的现有功能，构建新功能，并定制 Ghidra，以改善我们的逆向工程工作流程。
- en: '![image](Images/fig15-1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-1.jpg)'
- en: '*Figure 15-1: GhidraDevUser Consent dialog*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-1：GhidraDevUser 同意对话框*'
- en: '![image](Images/fig15-2.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-2.jpg)'
- en: '*Figure 15-2: Eclipse IDE welcome screen*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-2：Eclipse IDE 欢迎界面*'
- en: '***Editing Scripts with Eclipse***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 Eclipse 编辑脚本***'
- en: Once the GhidraDev plugin has been installed in Eclipse, you are ready to create
    new scripts, or edit existing ones using the Eclipse IDE. As we migrate from using
    Ghidra’s Script Manager to create and edit scripts, to using Eclipse, it’s worth
    remembering that while it is possible to launch Eclipse from Script Manager, it
    is possible to do so only to edit an existing script (see [Figure 14-2](ch14.xhtml#fig14_2)).
    If you want to edit a new script using Eclipse, you’ll need to first launch Eclipse
    and then use the GhidraDev menu to create the new script. Whether you launch Eclipse
    yourself, or arrive in Eclipse via Ghidra’s Script Manager, for the remainder
    of this chapter, we use Eclipse rather than the Script Manager’s basic editor
    to create and modify scripts and modules for Ghidra.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 GhidraDev 插件安装在 Eclipse 中，你就可以使用 Eclipse IDE 创建新脚本或编辑现有脚本。随着我们从使用 Ghidra
    的脚本管理器来创建和编辑脚本，转向使用 Eclipse，有一点值得记住，虽然可以通过脚本管理器启动 Eclipse，但这仅限于编辑现有脚本（见[图 14-2](ch14.xhtml#fig14_2)）。如果你想使用
    Eclipse 编辑新脚本，你需要先启动 Eclipse，然后使用 GhidraDev 菜单来创建新脚本。无论是你自己启动 Eclipse，还是通过 Ghidra
    的脚本管理器进入 Eclipse，在本章剩余部分，我们都将使用 Eclipse，而不是脚本管理器的基本编辑器，来创建和修改 Ghidra 的脚本和模块。
- en: 'To edit the first script we created in “[Edit Script Example: Regex Search](ch14.xhtml#ch14lev236)”
    on [page 290](ch14.xhtml#page_290), select **File** ▸ **Open File** from the Eclipse
    menu and navigate to the script *FindStringByRegex.java*. This opens the script
    in the Eclipse IDE, and you can begin using Eclipse’s rich set of editing options.
    [Figure 15-3](ch15.xhtml#fig15_3) shows the first few lines of the script with
    the comments and imports collapsed. Collapsing lines is a default feature of the
    Eclipse IDE that could cause some confusion if you are switching between the basic
    editor provided by Ghidra and Eclipse.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑我们在“[编辑脚本示例：正则搜索](ch14.xhtml#ch14lev236)”中创建的第一个脚本，请从 Eclipse 菜单中选择 **文件**
    ▸ **打开文件**，并导航到脚本 *FindStringByRegex.java*。这将脚本在 Eclipse IDE 中打开，您可以开始使用 Eclipse
    提供的丰富编辑选项。[图 15-3](ch15.xhtml#fig15_3)展示了脚本的前几行，其中注释和导入部分已被折叠。折叠行是 Eclipse IDE
    的默认功能，如果您在 Ghidra 提供的基本编辑器和 Eclipse 之间切换，这可能会引起一些困惑。
- en: '![image](Images/fig15-3.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-3.jpg)'
- en: '*Figure 15-3: Eclipse editor presentation of* FindStringsByRegex'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-3：Eclipse 编辑器展示的* FindStringsByRegex'
- en: Only one line of comments is displayed by default. You can click an icon to
    expand (the + icon at the left of line 2) the content and display all of the comments
    as well as to collapse (the `–` icon at the left of line 34) the content if desired.
    The same is true on line 26 with the `import` statements. Hovering over the icon
    for any section that is collapsed displays the hidden content in a pop-up window.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，只显示一行注释。您可以点击图标展开（点击第 2 行左侧的 + 图标）内容并显示所有注释，或者根据需要折叠（点击第 34 行左侧的 `–` 图标）内容。第
    26 行的 `import` 语句也有类似的情况。将鼠标悬停在任何折叠部分的图标上，会在弹出窗口中显示隐藏的内容。
- en: Before we can start building examples that expand Ghidra’s capabilities, you
    need to understand more about the GhidraDev menu and the Eclipse IDE. Let’s shift
    our focus back to the GhidraDev menu and investigate the various options and how
    they can be used in context.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建扩展 Ghidra 功能的示例之前，您需要更多地了解 GhidraDev 菜单和 Eclipse IDE。让我们将焦点重新放回到 GhidraDev
    菜单，探索各种选项以及它们在实际应用中的使用方式。
- en: '**GhidraDev Menu**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**GhidraDev 菜单**'
- en: The expanded GhidraDev menu is shown in [Figure 15-4](ch15.xhtml#fig15_4) and
    includes five options that you can use to control your development environment
    and work with files. In this chapter, we focus on developing in Java, although
    Python is an option in several of the windows.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 展开的 GhidraDev 菜单如[图 15-4](ch15.xhtml#fig15_4)所示，包含五个选项，您可以利用这些选项来控制开发环境并处理文件。本章我们将重点讨论
    Java 开发，虽然在一些窗口中 Python 也可作为选项。
- en: '![image](Images/fig15-4.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-4.jpg)'
- en: '*Figure 15-4: GhidraDev menu options*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-4：GhidraDev 菜单选项*'
- en: '#### *GhidraDev ▸ New*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '#### *GhidraDev ▸ 新建*'
- en: The GhidraDev ▸ New menu provides you with three submenu options, as shown in
    [Figure 15-5](ch15.xhtml#fig15_5). All three of the options launch wizards that
    guide you through an associated creation process. We start with the simplest option,
    which is to create a new Ghidra script. This is an alternative path to creating
    scripts from that discussed in [Chapter 14](ch14.xhtml#ch14).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: GhidraDev ▸ 新建菜单提供了三个子菜单选项，如[图 15-5](ch15.xhtml#fig15_5)所示。所有三个选项都会启动向导，指导您完成相关的创建过程。我们从最简单的选项开始，即创建一个新的
    Ghidra 脚本。这是创建脚本的一种替代路径，和[第 14 章](ch14.xhtml#ch14)中讨论的路径有所不同。
- en: '![image](Images/fig15-5.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-5.jpg)'
- en: '*Figure 15-5: GhidraDev ▸ New submenu*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-5：GhidraDev ▸ 新建子菜单*'
- en: '**Creating a Script**'
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建脚本**'
- en: Creating a new script using GhidraDev ▸ New ▸ Ghidra Script results in a dialog
    that allows you to enter information about your new script. An example of the
    dialog populated with content is shown in [Figure 15-6](ch15.xhtml#fig15_6). In
    addition to the directory and file information, the dialog collects the same metadata
    that we manually entered into our script files in the Script Manager’s basic editor.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GhidraDev ▸ 新建 ▸ Ghidra 脚本创建新脚本时，会弹出一个对话框，允许您输入有关新脚本的信息。一个已填充内容的对话框示例如[图
    15-6](ch15.xhtml#fig15_6)所示。除了目录和文件信息外，该对话框还会收集我们手动输入到脚本管理器基本编辑器中的相同元数据。
- en: '![image](Images/fig15-6.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-6.jpg)'
- en: '*Figure 15-6: Create Ghidra Script dialog*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-6：创建 Ghidra 脚本对话框*'
- en: The Finish button at the bottom of the dialog produces the script template shown
    in [Figure 15-7](ch15.xhtml#fig15_7). The metadata entered in [Figure 15-6](ch15.xhtml#fig15_6)
    is included in the comment section at the top of the script. This content is in
    the same format as the metadata we saw in [Chapter 14](ch14.xhtml#ch14) (see the
    top of [Figure 14-4](ch14.xhtml#fig14_4)). When you edit this script in Eclipse,
    the task tag (clipboard icon, seen on the left side of line 14 in [Figure 15-7](ch15.xhtml#fig15_7))
    associated with each `TODO` item in the script identifies locations where there
    is work to be done. You can delete and insert task tags at will.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框底部的完成按钮生成了[图 15-7](ch15.xhtml#fig15_7)中所示的脚本模板。在[图 15-6](ch15.xhtml#fig15_6)中输入的元数据被包含在脚本顶部的注释部分。此内容与我们在[第
    14 章](ch14.xhtml#ch14)中看到的元数据格式相同（见[图 14-4](ch14.xhtml#fig14_4)的顶部）。当您在 Eclipse
    中编辑此脚本时，与脚本中每个`TODO`项相关的任务标签（如[图 15-7](ch15.xhtml#fig15_7)第 14 行左侧的剪贴板图标）标识出需要处理的位置。您可以随意删除和插入任务标签。
- en: '![image](Images/fig15-7.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-7.jpg)'
- en: '*Figure 15-7: GhidraDev ▸ NewScript script shell*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-7：GhidraDev ▸ 新建脚本脚本外壳*'
- en: Eclipse does not preload your script with the list of `import` statements like
    the Ghidra basic editor does (refer to [Figure 14-4](ch14.xhtml#fig14_4)). Not
    to worry. Eclipse helps you to manage your `import` statements by letting you
    know when you use something that requires an associated `import` statement. For
    example, if we replace the `TODO` comment in [Figure 15-7](ch15.xhtml#fig15_7)
    with the declaration of a Java `ArrayList`, Eclipse adds an error tag to the line
    and underlines `ArrayList` in red. Hovering over the error tag or `ArrayList`
    displays a pop-up window suggesting quick fixes to solve the issue, as shown in
    [Figure 15-8](ch15.xhtml#fig15_8).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse 并不会像 Ghidra 基本编辑器那样预加载您的脚本与 `import` 语句列表（参见[图 14-4](ch14.xhtml#fig14_4)）。不用担心，Eclipse
    通过在您使用需要相关 `import` 语句的内容时提醒您来帮助管理 `import` 语句。例如，如果我们将[图 15-7](ch15.xhtml#fig15_7)中的
    `TODO` 注释替换为 Java `ArrayList` 的声明，Eclipse 会在该行添加一个错误标签并将 `ArrayList` 用红色下划线标出。将鼠标悬停在错误标签或
    `ArrayList` 上时，会弹出一个窗口，建议快速修复此问题，如[图 15-8](ch15.xhtml#fig15_8)所示。
- en: '![image](Images/fig15-8.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-8.jpg)'
- en: '*Figure 15-8: Eclipse Quick Fix options*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-8：Eclipse 快速修复选项*'
- en: Choosing the first option in the suggestion list instructs Eclipse to add the
    selected `import` statement to the script, as shown in [Figure 15-9](ch15.xhtml#fig15_9).
    While it was helpful to have the list of potential `import` statements loaded
    when creating a new script in the CodeBrowser Script Manager, it is not as essential
    in Eclipse.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 选择建议列表中的第一个选项会指示 Eclipse 将选定的 `import` 语句添加到脚本中，如[图 15-9](ch15.xhtml#fig15_9)所示。虽然在
    CodeBrowser 脚本管理器中创建新脚本时，加载潜在的 `import` 语句列表是很有帮助的，但在 Eclipse 中它并不是那么重要。
- en: '![image](Images/fig15-9.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-9.jpg)'
- en: '*Figure 15-9: Eclipse after Quick Fix import is applied*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-9：应用快速修复导入后的 Eclipse*'
- en: '**Creating a Script Project**'
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建脚本项目**'
- en: The second option in the GhidraDev ▸ New menu creates a new script project,
    as shown in [Figure 15-10](ch15.xhtml#fig15_10). We name our first script project
    *CH15_ProjectExample_linked* and place it in the default directory that we have
    set up for Eclipse. The Create run configuration checkbox allows you to create
    a *run configuration*, which provides Eclipse with the necessary information (command
    line arguments, directory paths, and so on) to launch Ghidra and allows us to
    use Eclipse to run and debug the script in Ghidra. Leave this checkbox in its
    default state, selected. Click **Finish** to complete creation of the script using
    the default format, which links the script project to your home directory.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: GhidraDev ▸ 新建菜单中的第二个选项创建一个新的脚本项目，如[图 15-10](ch15.xhtml#fig15_10)所示。我们将第一个脚本项目命名为*CH15_ProjectExample_linked*，并将其放在我们为
    Eclipse 设置的默认目录中。创建运行配置复选框允许您创建一个*运行配置*，该配置为 Eclipse 提供启动 Ghidra 所需的信息（命令行参数、目录路径等），并使我们能够使用
    Eclipse 在 Ghidra 中运行和调试脚本。保持此复选框的默认状态，即选中状态。点击**完成**以使用默认格式完成脚本的创建，该格式将脚本项目与您的主目录链接。
- en: '![image](Images/fig15-10.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-10.jpg)'
- en: '*Figure 15-10: Eclipse Ghidra Script Project dialog*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-10：Eclipse Ghidra 脚本项目对话框*'
- en: We will create a second script project *CH15_ProjectExample* and this time will
    choose the Next button. Choosing Next yields the dialog with two Link options
    that are set by default (hence the *_linked* extension on our first project name).
    The first option creates a link to your home script directory. The second lets
    you link to the Ghidra installation script directories. *Link*, in this case,
    is a way of saying that folders representing your home script directory and/or
    Ghidra’s own script directories will be added to your new project, making any
    script in those directories easily accessible to you while working on your project.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建第二个脚本项目*CH15_ProjectExample*，这次会选择“下一步”按钮。点击“下一步”会出现一个对话框，里面有两个默认勾选的链接选项（因此我们第一个项目名称带有*linked*扩展名）。第一个选项创建一个指向你的主脚本目录的链接。第二个选项让你链接到
    Ghidra 安装脚本目录。在此，“链接”意味着表示你的主脚本目录和/或 Ghidra 脚本目录的文件夹将被添加到新项目中，这样你在项目开发时可以方便地访问这些目录中的任何脚本。
- en: The results of selecting or deselecting these options and then clicking the
    Finish button will become clear later in the chapter when we discuss the Eclipse
    Package Explorer. For this second script project, de-select the first link checkbox
    as shown in [Figure 15-11](ch15.xhtml#fig15_11).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 选择或取消选择这些选项后点击“完成”按钮的结果将在本章后面讨论 Eclipse 包资源管理器时变得更加清晰。对于第二个脚本项目，如[图 15-11](ch15.xhtml#fig15_11)所示，取消勾选第一个链接复选框。
- en: '![image](Images/fig15-11.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-11.jpg)'
- en: '*Figure 15-11: Eclipse configuration options for script projects*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-11：Eclipse 脚本项目配置选项*'
- en: '**Creating a Module Project**'
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建模块项目**'
- en: The final option in the GhidraDev ▸ New menu creates a Ghidra module project.^([1](footnotes.xhtml#ch15fn1))
    Not to be confused with a Ghidra module (for example, analyzer, loader, and so
    on), a *Ghidra module project* aggregates code for a new Ghidra module with associated
    help files, documentation, and other resources, such as icons. Further, it allows
    you some control over how your new module interacts with the other modules within
    Ghidra. We demonstrate Ghidra modules in context in this and future chapters.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: GhidraDev ▸ 新建菜单中的最后一个选项会创建一个 Ghidra 模块项目。^([1](footnotes.xhtml#ch15fn1)) 这与
    Ghidra 模块（例如分析器、加载器等）不同，*Ghidra 模块项目*将为新的 Ghidra 模块聚合代码、相关的帮助文件、文档和其他资源，例如图标。此外，它还允许你控制新模块与
    Ghidra 中其他模块的交互方式。我们将在本章及未来的章节中演示 Ghidra 模块的具体应用。
- en: Choosing New ▸ Ghidra Module Project displays the dialog shown in [Figure 15-12](ch15.xhtml#fig15_12),
    which should be familiar because it is exactly the same as the Script Project
    dialog. We name our new project *CH15_ModuleExample* to make it easy to identify
    in the Package Explorer.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“新建 ▸ Ghidra 模块项目”会显示如[图 15-12](ch15.xhtml#fig15_12)所示的对话框，这个对话框应该很熟悉，因为它与脚本项目对话框完全相同。我们将新项目命名为*CH15_ModuleExample*，以便在包资源管理器中轻松识别。
- en: '![image](Images/fig15-12.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-12.jpg)'
- en: '*Figure 15-12: Eclipse Module Project dialog*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-12：Eclipse 模块项目对话框*'
- en: Clicking Next at this point allows you to base your module on existing Ghidra
    templates, as shown in [Figure 15-13](ch15.xhtml#fig15_13). By default, all of
    the options are selected. You can change this to include none, some, or all of
    the templates, depending on your development goals. Any of the options you choose
    will be grouped together in a project within the Package Explorer. In our case,
    we have deselected all of the options.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在此步骤点击“下一步”可以让你基于现有的 Ghidra 模板来创建模块，如[图 15-13](ch15.xhtml#fig15_13)所示。默认情况下，所有选项都已被选择。你可以根据开发目标选择包括所有、部分或没有任何模板。你选择的任何选项将会在包资源管理器中作为项目分组。如果是我们的话，我们已经取消了所有选项。
- en: While most of the selections will produce an associated source code template
    with task tags, there are two exceptions. First, if you do not select any of the
    module templates, you will not have a template file. In addition, the processor
    module does not produce a template file but does generate other supporting content.
    (Processor modules are discussed in [Chapter 18](ch18.xhtml#ch18).)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数选择会生成带有任务标签的相关源代码模板，但有两个例外。首先，如果你没有选择任何模块模板，将不会有模板文件。其次，处理器模块不会生成模板文件，但会生成其他支持内容。（处理器模块将在[第
    18 章](ch18.xhtml#ch18)中讨论。）
- en: '![image](Images/fig15-13.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-13.jpg)'
- en: '*Figure 15-13: Template options for Ghidra module projects*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-13：Ghidra 模块项目的模板选项*'
- en: Now that you know how to create Ghidra scripts, script projects, and module
    projects, let’s shift our focus to the Eclipse Package Explorer to better understand
    how we can work with our new creations.^([2](footnotes.xhtml#ch15fn2))
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何创建Ghidra脚本、脚本项目和模块项目，让我们将焦点转向Eclipse包资源管理器，以更好地理解如何使用我们新创建的内容。^([2](footnotes.xhtml#ch15fn2))
- en: '***Navigating the Package Explorer***'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***导航包资源管理器***'
- en: Eclipse’s Package Explorer is the gateway to the Ghidra files you need to complete
    your Ghidra extension. Here, we present the hierarchical organization and then
    drill down into examples of Ghidra projects and modules created through the GhidraDev
    menu. [Figure 15-14](ch15.xhtml#fig15_14) displays a sample Eclipse Package Explorer
    window containing the items we created earlier in this chapter as well as a few
    others we created to demonstrate the effect of various options on the resulting
    Package Explorer contents.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse的包资源管理器是您完成Ghidra扩展所需的Ghidra文件的入口。在这里，我们展示了层级组织结构，并深入了解通过GhidraDev菜单创建的Ghidra项目和模块的示例。[图15-14](ch15.xhtml#fig15_14)显示了一个示例的Eclipse包资源管理器窗口，包含了我们在本章早些时候创建的项目以及一些我们创建的其他项目，用于演示不同选项对最终包资源管理器内容的影响。
- en: '![image](Images/fig15-14.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-14.jpg)'
- en: '*Figure 15-14: Package Explorer populated with example modules and project*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-14：包资源管理器，包含示例模块和项目*'
- en: We start by looking at the two script projects. *CH15_ProjectExample_linked*
    is the script project we created with both link options checked (refer to [Figure
    15-11](ch15.xhtml#fig15_11)). Immediately below it, we see a similar project,
    *CH15_ProjectExample*, but in this case, neither link option was checked. A partially
    expanded Package Explorer entry for *CH15_ProjectExample* is shown in [Figure
    15-15](ch15.xhtml#fig15_15).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看这两个脚本项目。*CH15_ProjectExample_linked*是我们通过勾选两个链接选项创建的脚本项目（请参见[图15-11](ch15.xhtml#fig15_11)）。紧接着，我们看到一个类似的项目，*CH15_ProjectExample*，但在这种情况下，没有勾选任何链接选项。[图15-15](ch15.xhtml#fig15_15)显示了*CH15_ProjectExample*的部分扩展包资源管理器条目。
- en: 'The following four components are included in this script project:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下四个组件包含在此脚本项目中：
- en: '**JUnit4** This is an open source unit-testing framework for Java. More information
    is available at *[https://junit.org/junit4/index.html](https://junit.org/junit4/index.html)*.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**JUnit4** 这是一个开源的Java单元测试框架。更多信息，请访问*[https://junit.org/junit4/index.html](https://junit.org/junit4/index.html)*。'
- en: '**JRE System Library** This is the Java Runtime Environment System Library.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**JRE系统库** 这是Java运行时环境系统库。'
- en: '**Referenced Libraries** These are referenced libraries that are not part of
    the JRE System Library, but are part of our Ghidra installation.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**引用的库** 这些是引用的库，它们不是JRE系统库的一部分，但属于我们的Ghidra安装的一部分。'
- en: '**Ghidra** This is the directory for your current Ghidra installation. We have
    expanded this directory so that you can see the familiar file structure introduced
    in [Chapter 3](ch03.xhtml#ch03) (see [Figure 3-1](ch03.xhtml#fig3_1)) and used
    throughout this book.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ghidra** 这是您当前Ghidra安装的目录。我们已经扩展了此目录，以便您可以看到在[第3章](ch03.xhtml#ch03)（见[图3-1](ch03.xhtml#fig3_1)）中介绍并在本书中使用的熟悉的文件结构。'
- en: '![image](Images/fig15-15.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-15.jpg)'
- en: '*Figure 15-15: Package Explorer script project entries* without *links*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-15：包资源管理器脚本项目条目* 没有*链接*'
- en: Compare the contents of [Figure 15-15](ch15.xhtml#fig15_15) with the expanded
    contents from *CH15_ProjectExample_linked* shown in [Figure 15-16](ch15.xhtml#fig15_16).
    For this script project, we selected both link options. Linking the user home
    script directory results in the *Home scripts* entry in the project hierarchy
    and provides us easy access to the scripts we have previously written to use as
    examples or to modify.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 比较[图15-15](ch15.xhtml#fig15_15)中的内容与[图15-16](ch15.xhtml#fig15_16)中显示的*CH15_ProjectExample_linked*的扩展内容。在这个脚本项目中，我们选择了两个链接选项。将用户主脚本目录链接后，会在项目层次结构中显示*Home
    scripts*条目，并为我们提供便捷访问我们之前编写的脚本，以供示例使用或修改。
- en: '![image](Images/fig15-16.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-16.jpg)'
- en: '*Figure 15-16: Package Explorer script project entries* with *links*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-16：包资源管理器脚本项目条目* 含*链接*'
- en: Linking Ghidra installation script directories results in all of the folders
    in [Figure 15-16](ch15.xhtml#fig15_16) that start with *Ghidra* and end with *scripts*.
    Each one of these corresponds to a script directory within in the *Ghidra/Features*
    directory in your Ghidra installation.^([3](footnotes.xhtml#ch15fn3)) Expanding
    any of these folders provides access to the source code for each of the scripts
    included in your Ghidra installation. Like the home scripts, these can serve as
    examples to modify or use as a base for creating new scripts. While you are not
    permitted to overwrite these scripts from within the Ghidra Script Manager basic
    editor, you can edit them in Eclipse and other editors outside of the Ghidra Project
    environment. When you have finished creating or editing a new script, you can
    save it in the appropriate script directory within your script project, and it
    will be available to use the next time you open the Ghidra Script Manager.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 链接Ghidra安装脚本目录会导致[图15-16](ch15.xhtml#fig15_16)中所有以*Ghidra*开头并以*scripts*结尾的文件夹。每一个文件夹都对应于Ghidra安装中的*Ghidra/Features*目录中的一个脚本目录。^([3](footnotes.xhtml#ch15fn3))
    展开这些文件夹中的任何一个，可以访问到你Ghidra安装中包含的每个脚本的源代码。像主页脚本一样，这些脚本可以作为修改或创建新脚本的基础示例。虽然你不能在Ghidra脚本管理器的基本编辑器中覆盖这些脚本，但你可以在Eclipse和Ghidra项目环境外的其他编辑器中编辑它们。当你完成创建或编辑新脚本时，你可以将其保存在脚本项目中的相应脚本目录中，并且下次打开Ghidra脚本管理器时可以使用它。
- en: Now that we have looked at scripts within the Eclipse Package Explorer, let’s
    see how the Ghidra module project we built is represented. The partially expanded
    content of our project in the Package Explorer is shown in [Figure 15-17](ch15.xhtml#fig15_17).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了Eclipse包资源管理器中的脚本，让我们看看我们构建的Ghidra模块项目是如何表示的。在包资源管理器中，我们项目的部分展开内容如[图15-17](ch15.xhtml#fig15_17)所示。
- en: '![image](Images/fig15-17.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-17.jpg)'
- en: '*Figure 15-17: Package Explorer hierarchy for* CH15_ModuleExampleModule'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-17：* CH15_ModuleExampleModule的包资源管理器层次结构'
- en: '**ARE WE BUILDING THAT SCRIPT AGAIN?**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们是否再次构建那个脚本？**'
- en: 'In [Chapter 14](ch14.xhtml#ch14), we presented a toy example within the Ghidra
    Script Manager environment where we modified the existing script *CountAndSaveStrings*
    and used it to build a new script called *FindStringsByRegex*. The following steps
    do the same task within the Eclipse IDE:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第14章](ch14.xhtml#ch14)中，我们展示了一个在Ghidra脚本管理器环境中的玩具示例，我们修改了现有的脚本*CountAndSaveStrings*并用它构建了一个名为*FindStringsByRegex*的新脚本。以下步骤将在Eclipse
    IDE中执行相同的任务：
- en: Search for *CountAndSaveStrings.java* in Eclipse (CTRL-SHIFT-R).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Eclipse中搜索*CountAndSaveStrings.java*（CTRL-SHIFT-R）。
- en: Double-click to open the file in the Eclipse editor.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击以在Eclipse编辑器中打开文件。
- en: Replace the existing class and comments with the new class and comments.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用新类和注释替换现有的类和注释。
- en: Save the file (*EclipseFindStringByRegex.java*) in the recommended *ghidra_scripts*
    directory.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件(*EclipseFindStringByRegex.java*)保存到推荐的*ghidra_scripts*目录中。
- en: Run the new script from the Script Manager window in Ghidra.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Ghidra的脚本管理器窗口中运行新脚本。
- en: You can launch Ghidra manually to get access to the Script Manager window. Alternatively,
    you can select the Run As option in the Eclipse IDE, which will show the dialog
    in [Figure 15-18](ch15.xhtml#fig15_18). The first option launches Ghidra for you.
    The second option launches a non-GUI version of Ghidra, which is the topic of
    [Chapter 16](ch16.xhtml#ch16).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以手动启动Ghidra来访问脚本管理器窗口。或者，你可以在Eclipse IDE中选择“以此方式运行”选项，这将显示[图15-18](ch15.xhtml#fig15_18)中的对话框。第一个选项会为你启动Ghidra，第二个选项会启动一个无GUI版本的Ghidra，这是[第16章](ch16.xhtml#ch16)的主题。
- en: '![image](Images/fig15-18.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-18.jpg)'
- en: '*Figure 15-18: Eclipse Run As options*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15-18：Eclipse“以此方式运行”选项*'
- en: Once Ghidra has been launched, you can run your script from the Script Manager
    and edit it using Eclipse.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Ghidra启动，你可以从脚本管理器运行脚本并使用Eclipse进行编辑。
- en: 'Module projects include the following new elements:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 模块项目包括以下新元素：
- en: '***src/main/java*** This is the location for the source code. If you created
    a module type that has a template available, the associated *.java* files are
    placed in this directory.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '***src/main/java*** 这是源代码的位置。如果你创建了一个有模板的模块类型，相关的*.java*文件会放在这个目录下。'
- en: '***src/main/help*** When you create or extend content, you have the opportunity
    to add useful information to Ghidra Help by using the files and information in
    this directory.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '***src/main/help*** 当你创建或扩展内容时，你有机会通过使用此目录中的文件和信息将有用的信息添加到Ghidra帮助中。'
- en: '***src/main/resources*** As with many of the other entries in the *src/main*
    directory, expanding this content will lead you to a *README.txt* file that provides
    additional information about the purpose of the directory and how it should be
    used. For example, the *src/main/resources/images/ README.txt* file lets you know
    that it is the location in which any image or icon files associated with the module
    should be stored.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '***src/main/resources*** 与 *src/main* 目录中的许多其他条目一样，展开此内容将带您进入一个 *README.txt*
    文件，提供有关目录目的和使用方法的更多信息。例如，*src/main/resources/images/README.txt* 文件告知您，它是存储与模块相关的任何图像或图标文件的位置。'
- en: '***ghidra_scripts*** This is where Ghidra scripts that are specific to this
    module are stored.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '***ghidra_scripts*** 这是存储特定于此模块的 Ghidra 脚本的位置。'
- en: '***data*** This folder holds any independent data files that are used with
    this module. (While not prohibited from use with other module types, this folder
    is primarily used with processor modules and is discussed in [Chapter 18](ch18.xhtml#ch18).)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '***data*** 此文件夹包含与此模块一起使用的任何独立数据文件。（虽然不禁止与其他模块类型一起使用，但此文件夹主要用于处理器模块，并在[第18章](ch18.xhtml#ch18)中进行了讨论。）'
- en: '***lib*** Any *.jar* files required by the module should be stored in this
    folder.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '***lib*** 模块所需的任何*.jar*文件应存储在此文件夹中。'
- en: '***os*** There are subdirectories within this folder for linux64, oxs64, and
    win64 to hold any native binaries that the module may depend upon.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '***os*** 此文件夹内有子目录，用于存储 linux64、oxs64 和 win64 的任何本地二进制文件，模块可能依赖于这些文件。'
- en: '***src*** This directory is used to hold unit test cases.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '***src*** 此目录用于存储单元测试用例。'
- en: '***build.gradle*** Gradle is an open source build system. This file is used
    to build your Ghidra extension.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '***build.gradle*** Gradle 是一个开源构建系统。此文件用于构建您的 Ghidra 扩展。'
- en: '***extension.properties*** This file stores metadata about the extension.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '***extension.properties*** 此文件存储有关扩展的元数据。'
- en: '***Module.manifest*** You can enter information about the module such as configuration
    information in this file.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '***Module.manifest*** 您可以在此文件中输入有关模块的配置信息等。'
- en: You may have noticed in [Figure 15-14](ch15.xhtml#fig15_14) that we created
    additional *Test* modules (*AnalyzerTest*, *AllTypeTest*, and *LoaderTest*). Each
    was created using a different combination of Module Template options (see [Figure
    15-13](ch15.xhtml#fig15_13)), which results in a different set of files being
    instantiated for each project. When using these templates as a starting point
    for your projects, it’s useful to know just how much work Eclipse and Ghidra have
    done for you—and how much work is left for you to complete.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在[图15-14](ch15.xhtml#fig15_14)中，我们创建了额外的 *Test* 模块（*AnalyzerTest*、*AllTypeTest*
    和 *LoaderTest*）。每个模块都使用不同的模块模板选项组合创建（见[图15-13](ch15.xhtml#fig15_13)），这会为每个项目实例化不同的文件集。使用这些模板作为您项目的起点时，了解
    Eclipse 和 Ghidra 已为您完成了多少工作——以及还有多少工作需要您完成，是非常有用的。
- en: Let’s begin by looking in the *AnalyzerTest* directory that we created to demonstrate
    an analyzer template. Expand the *src/main/java* directory to find a file called
    *AnalyzerTestAnalyzer.java*. The name is a concatenation of the module name (*AnalyzerTest*)
    with the template type (*Analyzer*). Double-click this file to open it in the
    editor and see the code shown in [Figure 15-19](ch15.xhtml#fig15_19). Like the
    script templates earlier in the chapter, the Eclipse IDE provides task tags with
    associated comments to guide us through building our analyzer as well as the options
    to expand and collapse content. The *LoaderTest* module contains the template
    for building a loader, which is discussed further in [Chapter 17](ch17.xhtml#ch17).
    The remaining module, *AllTypeTest*, is the default module that results when you
    bypass the module template options. This populates the *src/main/java* directory
    with all of the templates, as shown in [Figure 15-20](ch15.xhtml#fig15_20).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们创建的 *AnalyzerTest* 目录开始，演示分析器模板。展开 *src/main/java* 目录，找到一个名为 *AnalyzerTestAnalyzer.java*
    的文件。这个名字是模块名（*AnalyzerTest*）和模板类型（*Analyzer*）的拼接。双击此文件以在编辑器中打开它，并查看[图15-19](ch15.xhtml#fig15_19)中显示的代码。像本章前面的脚本模板一样，Eclipse
    IDE 提供了带有相关注释的任务标签，帮助我们构建分析器，并提供扩展和折叠内容的选项。*LoaderTest* 模块包含构建加载器的模板，后者在[第17章](ch17.xhtml#ch17)中进一步讨论。剩下的模块
    *AllTypeTest* 是跳过模块模板选项时的默认模块。它将所有模板填充到 *src/main/java* 目录中，如[图15-20](ch15.xhtml#fig15_20)所示。
- en: Now that we have seen how helpful Ghidra and Eclipse can be when we create new
    modules, let's use this information to build a new analyzer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 Ghidra 和 Eclipse 在创建新模块时的帮助作用，现在让我们利用这些信息构建一个新的分析器。
- en: '![image](Images/fig15-19.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-19.jpg)'
- en: '*Figure 15-19: Default analyzer template for a module (comments, imports, and
    functions collapsed)*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-19：模块的默认分析器模板（已折叠的注释、导入和函数）*'
- en: '![image](Images/fig15-20.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-20.jpg)'
- en: '*Figure 15-20: Sample default module source code content*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-20：示例默认模块源代码内容*'
- en: '**Example: Ghidra Analyzer Module Project**'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**示例：Ghidra 分析器模块项目**'
- en: 'With the Eclipse integration basics behind us, let’s walk through building
    a simple Ghidra analyzer to identify potential ROP gadgets in our listing. We
    will use a simplified software development process, as this is just a simple demonstration
    project. Our process includes the following steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了 Eclipse 集成基础知识后，让我们逐步构建一个简单的 Ghidra 分析器，以识别我们列表中的潜在 ROP gadgets。我们将采用简化的软件开发流程，因为这只是一个简单的演示项目。我们的流程包括以下步骤：
- en: Define the problem.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义问题。
- en: Create the Eclipse module.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Eclipse 模块。
- en: Build the analyzer.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建分析器。
- en: Add the analyzer to our Ghidra installation.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将分析器添加到我们的 Ghidra 安装中。
- en: Test the analyzer from our Ghidra installation.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试我们 Ghidra 安装中的分析器。
- en: '**WHAT’S A ROP GADGET AND WHY DO WE CARE?**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是 ROP gadget，为什么我们关心它？**'
- en: For those unfamiliar with exploit development, ROP stands for *return-oriented
    programming*. One software security mitigation that aims to defeat raw shellcode
    injection is to ensure that no memory region that is writable is, at the same
    time, also executable. Such mitigations are often referred to as *Non-eXecutable
    (NX)* or *Data Execution Prevention (DEP)*) because it becomes impossible to inject
    shellcode into memory (must be writable) and then transfer control to that shellcode
    (must be executable).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不熟悉利用开发的人，ROP 代表*面向返回的编程*。一种旨在阻止原始 shellcode 注入的软件安全缓解措施是确保没有可写的内存区域同时也是可执行的。这类缓解措施通常被称为*不可执行（NX）*或*数据执行保护（DEP）*，因为这样就无法将
    shellcode 注入到内存中（必须是可写的），然后将控制权转移到该 shellcode 上（必须是可执行的）。
- en: ROP techniques aim to hijack a program’s stack (often through a stack-based
    buffer overflow) to place a carefully crafted sequence of return addresses and
    data into the stack. At some point after the overflow, the program begins using
    the attacker-supplied return addresses rather than return addresses placed on
    the stack by normal program execution. The return addresses the attacker places
    on the stack point to program memory locations that already contain code as a
    result of normal program and library loading operations. Because the original
    author of the exploited program did not design the program to do the attacker’s
    work for them, the attacker often needs to pick and choose small portions of this
    existing code to sequence together.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ROP 技术旨在劫持程序的栈（通常通过基于栈的缓冲区溢出），将精心构造的一系列返回地址和数据放入栈中。在溢出发生后的某个时刻，程序开始使用攻击者提供的返回地址，而不是由正常程序执行放置在栈上的返回地址。攻击者放置在栈上的返回地址指向程序内存位置，这些位置已经包含了代码，这些代码通常是由于正常的程序和库加载操作而存在的。因为被利用程序的原始作者并未设计程序来为攻击者执行任务，所以攻击者通常需要挑选和组合这些现有代码的小片段。
- en: 'A *ROP gadget* is a single one of these code fragments, and the sequencing
    mechanism often relies on the gadget terminating in a return (hence return-oriented)
    instruction, which retrieves an address from the now attacker-controlled stack
    to transfer control to the next gadget. A gadget often performs a very simple
    task such as loading a register from the stack. The following simple gadget could
    be used to initialize RAX on an x86-64 system:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*ROP gadget*是这些代码片段中的单个部分，而序列化机制通常依赖于该 gadget 以一个返回（因此是面向返回的）指令结束，这个指令从现在由攻击者控制的栈中检索一个地址，将控制权转移到下一个
    gadget。一个 gadget 通常执行一个非常简单的任务，例如从栈中加载寄存器。以下简单的 gadget 可用于初始化 x86-64 系统上的 RAX：
- en: '[PRE0]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Because every exploitable program is different, attackers can’t depend on a
    specific set of gadgets being present in any given binary. Automated gadget finders
    are tools that search a binary for instruction sequences that may be used as gadgets
    and present these gadgets to the attacker, who must decide which ones are useful
    in crafting their attack. The most sophisticated gadget finders infer the semantics
    of a gadget and automatically sequence gadgets to perform a specified action,
    saving the attacker the trouble of doing it themselves.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个可利用的程序都不同，攻击者不能依赖于任何给定二进制文件中存在特定的 gadget 集。自动化的 gadget 查找器是用于搜索二进制文件中可能用作
    gadget 的指令序列的工具，并将这些 gadget 提供给攻击者，攻击者必须决定哪些 gadget 在构造攻击时有用。最先进的 gadget 查找器可以推断
    gadget 的语义，并自动地将多个 gadget 排列成执行特定操作的序列，省去了攻击者自己处理的麻烦。
- en: '***Step 1: Define the Problem***'
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 1：定义问题***'
- en: Our task is to design and develop an instruction analyzer that will identify
    simple ROP gadgets within a binary. The analyzer needs to be added to Ghidra and
    be available as a selectable analyzer in the Ghidra Analyzer menu.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是设计并开发一个指令分析器，用于识别二进制文件中的简单 ROP gadget。该分析器需要添加到 Ghidra 中，并在 Ghidra 分析器菜单中作为可选分析器提供。
- en: '#### ***Step 2: Create the Eclipse Module***'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***步骤 2：创建 Eclipse 模块***'
- en: We use GhidraDev ▸ New ▸ Ghidra Module Project to create a module called *SimpleROP*
    using the analyzer module template. This creates a file called *SimpleROPAnalyzer.java*
    in the *src/main/java* folder within the *SimpleROP* module. The resulting Package
    Explorer view is shown in [Figure 15-21](ch15.xhtml#fig15_21).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 GhidraDev ▸ New ▸ Ghidra Module Project 创建一个名为 *SimpleROP* 的模块，采用分析器模块模板。这将在
    *SimpleROP* 模块的 *src/main/java* 文件夹中创建一个名为 *SimpleROPAnalyzer.java* 的文件。结果的包资源管理器视图如
    [图 15-21](ch15.xhtml#fig15_21) 所示。
- en: '![image](Images/fig15-21.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-21.jpg)'
- en: '*Figure 15-21: Package Explorer* src/main *entries for* SimpleROP'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-21：包资源管理器* src/main *SimpleROP 的条目*'
- en: '***Step 3: Build the Analyzer***'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***步骤 3：构建分析器***'
- en: A portion of the generated *SimpleROPAnalyzer.java* code is shown in [Figure
    15-22](ch15.xhtml#fig15_22). The functions have been collapsed so that we can
    see all of the analyzer methods that are provided. Eclipse will recommend imports
    if we need them as we develop our code so we can jump right into coding the tasks
    we need to perform and add the recommended `import` statements when Eclipse detects
    that we need them.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的部分 *SimpleROPAnalyzer.java* 代码如 [图 15-22](ch15.xhtml#fig15_22) 所示。各个函数已经被折叠，我们可以看到提供的所有分析方法。Eclipse
    在我们开发代码时，如果需要导入，会推荐相应的导入语句，这样我们可以直接跳入编写所需任务的代码，并在 Eclipse 检测到我们需要时，自动添加推荐的 `import`
    语句。
- en: '![image](Images/fig15-22.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig15-22.jpg)'
- en: '*Figure 15-22:* SimpleROPAnalyzer *template*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-22：* SimpleROPAnalyzer *模板*'
- en: The six task tags (to the left of the line numbers) in [Figure 15-22](ch15.xhtml#fig15_22)
    indicate where we should start our development. We will expand the associated
    sections as we address each task and include the before and after content associated
    with each task. (Note that some content will be wrapped or reformatted for readability
    and comments minimized to conserve space.)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15-22](ch15.xhtml#fig15_22) 中的六个任务标签（位于行号的左侧）标示了我们应该开始开发的位置。我们将在处理每个任务时扩展相关部分，并包含每个任务的前后内容。（请注意，为了可读性，一些内容将被换行或重新格式化，并且注释将尽量简化以节省空间。）'
- en: 'For functionality, we will rely on the following class-level declarations:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于功能性，我们将依赖以下类级声明：
- en: '[PRE1]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Comments associated with each declaration describe the purpose of each variable.
    The various `List` variables contain the instructions from which our gadgets will
    be composed and classify those instructions based on the number and type of operands
    they require, and whether the instruction is a legal start instruction for one
    of our gadgets. Because our gadget construction algorithm works its way backward
    in memory, *start* here actually means a starting point for our algorithm. At
    runtime, these same start instructions would actually be the last instructions
    executed in a given gadget.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每个声明旁边的注释描述了每个变量的用途。各种 `List` 变量包含了我们的 gadget 所需的指令，并根据它们所需的操作数数量和类型，以及该指令是否是我们
    gadget 合法起始指令来分类这些指令。由于我们的 gadget 构建算法是从内存中倒着进行的，*start* 这里实际上指的是我们算法的起点。在运行时，这些起始指令实际上将是给定
    gadget 中最后执行的指令。
- en: '**Step 3-1: Document the Class**'
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 3-1：记录类文档**'
- en: 'When we expand the first task tag, we see the following task description:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们展开第一个任务标签时，我们会看到以下任务描述：
- en: '[PRE2]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Replace the existing `TODO` comments with comments that describe what the analyzer
    does:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将现有的`TODO`注释替换为描述分析器功能的注释：
- en: '[PRE3]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '##### **Step 3-2: Name and Describe Our Analyzer**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '##### **步骤 3-2：命名并描述我们的分析器**'
- en: 'Expanding the next task tag provides us with a `TODO` comment and the line
    of code that we need to edit. Within the Eclipse IDE, the code to be modified
    appears in purple font and has a name indicative of the associated task. The second
    task contains the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 展开下一个任务标签会显示一个`TODO`注释和我们需要编辑的代码行。在Eclipse IDE中，需要修改的代码以紫色字体显示，并且代码的名称表明了相关任务的内容。第二项任务包含以下内容：
- en: '[PRE4]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The two strings need to be replaced with meaningful content. In addition, the
    analyzer type needs to be specified. To facilitate dependency resolution across
    analyzers, Ghidra groups analyzers into the following categories: byte, data,
    function, function modifiers, function signatures, and instruction. In this case,
    we are building an instruction analyzer. The resulting code is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个字符串需要替换为有意义的内容。此外，还需要指定分析器类型。为了促进分析器之间的依赖解决，Ghidra将分析器分为以下几类：字节、数据、函数、函数修饰符、函数签名和指令。在这种情况下，我们正在构建一个指令分析器。最终的代码如下：
- en: '[PRE5]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Step 3-3: Determine If Our Analyzer Should Be a Default Analyzer**'
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 3-3：确定我们的分析器是否应该是默认分析器**'
- en: 'The third task asks us to return `true` if the analyzer should be enabled by
    default:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第三项任务要求我们返回`true`，如果分析器应该默认启用的话：
- en: '[PRE6]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We do not want this analyzer enabled by default; therefore, no code modifications
    are required.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望此分析器默认启用，因此无需修改代码。
- en: '**Step 3-4: Determine If the Input Is Appropriate for This Analyzer**'
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 3-4：确定输入是否适合此分析器**'
- en: 'The fourth task requires us to determine whether our analyzer is compatible
    with the program content:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第四项任务要求我们确定我们的分析器是否与程序内容兼容：
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since this analyzer is only for demonstration purposes, we assume that the
    input file is compatible with our analysis and simply return `true`. In reality,
    we would add code to verify compatibility of the analysis file prior to using
    our analyzer. For example, we might return `true` only after we have determined
    that file is an x86 binary. Worked examples of this verification can be found
    in most analyzers included in your Ghidra installation (*Ghidra/Features/Base/lib/Base-src/Ghidra/app/analyzers*),
    accessible through your module directory within Eclipse:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此分析器仅用于演示目的，我们假设输入文件与我们的分析兼容，并直接返回`true`。实际上，我们会在使用分析器之前添加代码来验证分析文件的兼容性。例如，我们可能仅在确定文件是x86二进制文件后才返回`true`。有关此验证的工作示例，可以在您的Ghidra安装中找到大多数分析器（*Ghidra/Features/Base/lib/Base-src/Ghidra/app/analyzers*），可以通过Eclipse中的模块目录访问：
- en: '[PRE8]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Step 3-5: Register Analyzer Options**'
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 3-5：注册分析器选项**'
- en: 'The fifth task offers us the opportunity to specify any special options we
    wish to present to users of our analyzer:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第五项任务为我们提供了指定任何特殊选项的机会，这些选项将呈现给我们的分析器用户：
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since this analyzer is only for demonstration purposes, we will not add any
    options. Options might include user-controlled choices (for example, choose output
    file, optionally annotate the listing, and so on). Options for each analyzer are
    displayed in the Analyzer window when an individual analyzer is selected:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此分析器仅用于演示目的，我们将不会添加任何选项。选项可能包括用户控制的选择（例如，选择输出文件、可选地注释列表等）。每个分析器的选项会在选择单个分析器时显示在分析器窗口中：
- en: '[PRE10]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Step 3-6: Perform the Analysis**'
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**步骤 3-6：执行分析**'
- en: 'The sixth task highlights the function that gets called when our analyzer gets
    invoked:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第六项任务强调了在分析器被调用时触发的函数：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is the part of the module that does the work. Four methods are used by
    this module, each of which is detailed next:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是模块中执行工作的部分。该模块使用了四个方法，每个方法接下来将详细说明：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Ghidra invokes an analyzer’s `added` method ➊ to initiate analysis. Our algorithm
    tests every instruction ➋ in the binary to determine whether the instruction is
    a valid “start” point ➌ for our gadget builder. Each time a valid start instruction
    is found, our gadget creation function, `buildGadget`, is invoked ➍. Gadget creation
    is a recursive ➏ walk backward ➐ through the instruction list that continues as
    long as an instruction is considered useful ➎ to us. Finally, each gadget is printed,
    by iterating over its instructions ➑, as it is completed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 4: Test the Analyzer Within Eclipse***'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: During the development process, it is common to test and modify code frequently.
    As you are building your analyzer, you can test its functionality within Eclipse
    by using the Run As option and choosing Ghidra. This opens Ghidra with the current
    version of the module temporarily installed. If the results are not what you expect
    when you test the module, you can edit the file within Eclipse and retest. When
    you are satisfied with your result, you should move on to step 5\. Using this
    method to test your code within Eclipse can be a great time-saver during the development
    process.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 5: Add the Analyzer to Our Ghidra Installation***'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To add this analyzer to our Ghidra installation, we need to export our module
    from Eclipse and then install the extension in Ghidra. Exporting is accomplished
    by selecting **GhidraDev** ▸ **Export** ▸ **Ghidra Module Extension**, choosing
    your module, and clicking **Next**. In the next window, select the **Gradle Wrapper**
    option shown in [Figure 15-23](ch15.xhtml#fig15_23) if you do not have a local
    Gradle installation (note that an internet connection is required in order for
    the wrapper to reach out to *gradle.org*). Click **Finish** to complete the export
    process. If this is your first time exporting the module, a *dist* directory will
    be added to your module within Eclipse and a *.zip* file of the exported content
    will be saved to the folder.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig15-23.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-23: Configure Gradle dialog*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: In the Ghidra Project window, add the new analyzer by selecting **File** ▸ **Install
    Extensions**. A window similar to that shown in [Figure 15-24](ch15.xhtml#fig15_24)
    will be displayed showing all of the existing extensions that have not been installed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig15-24.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-24: Install Extensions window*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Add the new analyzer *SimpleROP* by selecting the + icon at the top right and
    navigating to our newly created *.zip* file in the associated *dist* directory.
    Once our analyzer appears in the list, we can select it and click OK (not shown).
    Restart Ghidra to use the new functionality from the Analysis menu.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '***Step 6: Test the Analyzer Within Ghidra***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As with our limited development plan, we used a limited scope test plan just
    to demonstrate functionality. *SimpleROP* passed acceptance testing as the analyzer
    met the following criteria:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: (Pass) *SimpleROP* appears in the Analysis Options in the CodeBrowser ▸ Analysis
    menu.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Pass) The description of *SimpleROP* appears in the Analysis Options description
    window when selected.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test cases 1 and 2 passed, as shown in [Figure 15-25](ch15.xhtml#fig15_25).
    (Had we chosen to register and program associated options in step 3-5, they would
    have been displayed in the Options panel on the right side of the window).
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/fig15-25.jpg)'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 15-25: Analysis Options window*'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (Pass) *SimpleROP* executes when selected.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this case, we ran *SimpleROP* on an analyzed file, and as part of auto analysis.
    Running *SimpleROP* on an unanalyzed file would not yield any results, as `INSTRUCTION_ANALYZER`
    extensions require instructions to have been previously identified (a default
    part of auto analysis). When *SimpleROP* is run as part of the auto analysis,
    it is prioritized appropriately because of the analyzer type we assigned in step
    3-2\. [Figure 15-26](ch15.xhtml#fig15_26) shows the Ghidra Log confirmation that
    the *SimpleROP* analyzer ran.
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/fig15-26.jpg)'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 15-26: Ghidra User Log window showing analysis confirmation*'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: (Pass) *SimpleROP* writes each gadget to a file called *fileZZZ_gadgets.txt*
    when analyzing *fileZZZ*.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following excerpt from the file *call_tree_x64_static_gadgets.txt* shows
    that many of the gadgets are taken from the portion of the *call_tree_x64_static*
    listing shown in [Figure 15-27](ch15.xhtml#fig15_27):'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![image](Images/fig15-27.jpg)'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 15-27: CodeBrowser listing of* call_tree_x64_static'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 14](ch14.xhtml#ch14), we introduced scripting as a means of extending
    Ghidra’s capabilities. In this chapter, we introduced Ghidra extension modules
    along with Ghidra’s Eclipse integration capabilities. While Eclipse is not your
    only option for editing Ghidra extensions, the integration of Ghidra and the Eclipse
    IDE provides an incredibly powerful environment for developers extending Ghidra’s
    capabilities. The development wizards and templates lower the bar for authoring
    extensions as they present coders with a guided approach to modifying existing
    content and building new extensions. In [Chapter 16](ch16.xhtml#ch16), we take
    a look at headless Ghidra, an option that appeared in [Figure 15-18](ch15.xhtml#fig15_18).
    Subsequent chapters build on the integration of Ghidra and the Eclipse IDE to
    further extend Ghidra’s capabilities and provide a solid foundation for making
    Ghidra into the optimal tool for your reverse engineering workflow.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
