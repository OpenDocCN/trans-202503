<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_41"/><strong>4 LPC1343 Call Stack</strong></h2>&#13;
<p class="noindent">The LPC800, LPC1100, LPC1200, LPC1300, LPC1500, LPC-1700, and LPC1800 series of ARM microcontrollers from NXP are vulnerable to bootloader memory corruption. This was first described in Herrewegen et al. (2020) for the LPC1343, a Cortex M3 with 32kB of flash and 8kB of RAM. In this chapter, we’ll explore the bootloader’s protocol and the vulnerability, then walk through the steps of writing our own exploit.</p>&#13;
<p class="indent">LPC microcontrollers have five Code Read Protection (CRP) levels, each of which provides further restrictions on the ISP (bootloader) and SWD (debugger) access. Level 0 (NOCRP) is unprotected, allowing memory to be freely read and written through the bootloader or an SWD debugger. CRP 1 disables SWD debugging entirely, while ISP reads are prevented and ISP writes are restricted, in order to allow in-the-field updates of some memory while protecting the rest. In CRP 2, most commands are disabled. CRP 3 is the most secure, disabling all functionality. A fifth mode, NOISP, disables the ISP interface while leaving SWD enabled, so that memory is still exposed.</p>&#13;
<p class="indent">The bootloader presents itself as both a UART serial port and a USB mass storage disk, in which a single file of the disk represents the chip’s firmware. Herrewegen’s attack is specific to the UART interface in CRP Level 1, but the authors note that the mass storage interface is likely a good target for further bug hunting. See <a href="ch15.xhtml#ch15">Chapter 15</a> for a glitching attack that works reliably against these chips in higher protection modes.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_42"/><img id="ch4fig1" src="../images/f0042-01.jpg" alt="Image" width="777" height="931"/></div>&#13;
<p class="figcap">Figure 4.1: LPC1343</p>&#13;
<h3 class="h3" id="ch00lev1sec11"><span epub:type="pagebreak" id="page_43"/><strong>Getting Started</strong></h3>&#13;
<p class="noindent">The mask ROM bootloader is 16kB at <span class="literal">0x1fff0000</span>. 32kB of flash memory begin at address <span class="literal">0x00000000</span>, and 8kB of SRAM are mapped at <span class="literal">0x10000000</span>.</p>&#13;
<p class="indent">The bootloader does not allow ROM to be read directly, so I first dumped the ROM using an SWD debugger and OpenOCD. I also wanted a copy of SRAM, in order to have global variable and stack values while debugging, so I first zeroed SRAM with the debugger and then booted into the bootloader. Reading a RAM dump through the bootloader gave me the state from within the Read RAM function of the bootloader, with all uninitialized bytes left as <span class="literal">0x00</span>.</p>&#13;
<p class="indent">The protection level is configured by a 32-bit word written to <span class="literal">0x02fc</span> in flash memory. CRP 1 is <span class="literal">0x12345678</span>, CRP 2 is <span class="literal">0x87654321</span>, and CRP 3 is <span class="literal">0x43218765</span>. All other values leave the chip unprotected, which makes it a good target for the glitching attack in <a href="ch15.xhtml#ch15">Chapter 15</a>.</p>&#13;
<p class="indent">RAM begins at <span class="literal">0x10000000</span> with a protected region for the bootloader to use as working memory. The bootloader will deny writes to this region. According to the documentation, the first 768 bytes up to <span class="literal">0x10000300</span> ought to be protected, but in practice, only the first 512 bytes up to <span class="literal">0x10000200</span> are protected. A few global variables exist in the range that is not (but ought to be) protected, but none of these globals are known to be exploitable. <a href="ch04.xhtml#ch4fig3">Figure 4.3</a> shows this layout.</p>&#13;
<p class="indent">The designers seem to have protected their <span class="literal">.data</span> section, while forgetting that the call stack is an even juicier target for attackers. The bootloader’s call stack grows downward from <span class="literal">0x10001fdc</span>, entirely outside of the write-protected region! Herrewegen’s exploit works by repeatedly altering this stack with the Write RAM function to trigger a return into the otherwise unreachable Read <span epub:type="pagebreak" id="page_44"/>Memory function, dumping some bytes of flash before repeating the process all over again.</p>&#13;
<h3 class="h3" id="ch00lev1sec12"><strong>UART Protocol in Brief</strong></h3>&#13;
<p class="noindent">The UART protocol is documented in <a href="ch21.xhtml#ch21">Chapter 21</a> of NXP (2012). It’s an ASCII protocol that automatically syncs to your baud rate, and you can slowly type most of the protocol by hand in a terminal emulator if that’s your fancy.</p>&#13;
<p class="indent">The bootloader is enabled by pulling the <span class="literal">BLD_E</span> pin high, and the UART mode is selected on models with USB by pulling <span class="literal">P0_3</span> low. After starting the bootloader, you transmit a question mark at 57,600 baud. The chip sends you the word <span class="literal">Synchronized</span>, and you send it back to confirm that things are working.</p>&#13;
<p class="indent">Each command is sent as a line of text, which is echoed back. Parameters that are numeric are <em>always</em> in base 10; there’s no support for parsing hexadecimal. Reads and writes are armored in lines of the <span class="literal">uuencode</span> format, with a checksum every twenty lines. (With 45 decoded bytes per line, that’s every 900 bytes.)</p>&#13;
<p class="indent">As I couldn’t find an open source bootloader client to patch, I wrote a new bootloader client in Golang with the <span class="literal">go-serial</span> library.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_45"/><img id="ch4fig2" src="../images/f0045-01.jpg" alt="Image" width="680" height="611"/></div>&#13;
<p class="figcap">Figure 4.2: LPC1343 Memory Map</p>&#13;
<div class="image"><img id="ch4fig3" src="../images/f0045-02.jpg" alt="Image" width="725" height="245"/></div>&#13;
<p class="figcap">Figure 4.3: LPC1343 Bootloader SRAM</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_46"/><img id="ch4fig4" src="../images/f0046-01.jpg" alt="Image" width="730" height="544"/></div>&#13;
<p class="figcap">Figure 4.4: LPC1343 Bootloader Commands</p>&#13;
<div class="image"><img id="ch4fig5" src="../images/f0046-02.jpg" alt="Image" width="659" height="196"/></div>&#13;
<p class="figcap">Figure 4.5: Code Protection Literals</p>&#13;
<h3 class="h3" id="ch00lev1sec13"><span epub:type="pagebreak" id="page_47"/><strong>Reverse Engineering the Bootloader</strong></h3>&#13;
<p class="noindent">The next step is to reverse engineer the bootloader. I did this in Ghidra, loading the ROM dump at <span class="literal">0x1fff0000</span> and an SRAM dump at <span class="literal">0x10000000</span>.</p>&#13;
<p class="indent">On my first try, I loaded an SRAM dump from a chip that hadn’t been zeroed. SRAM loses its state when not powered, so this filled the mostly unused memory with gobbledygook that frustrated reverse engineering. Zeroing SRAM before running the bootloader, then dumping it through the bootloader gave me an image with all global variables initialized and with a live call stack to help me get my bearings.</p>&#13;
<p class="indent">These dumps were taken from an unlocked chip, of course. Except when unlocked chips are unavailable, such as for smart cards that are only available under an NDA, it’s best to develop exploits first against unlocked chips and only later to use them against a locked target.</p>&#13;
<p class="indent">After loading both the firmware and the SRAM dump, I spent an afternoon looking for functions and naming them. Good clues to a function’s purpose can come from the I/O addresses that it accesses and whether it reads or writes them.</p>&#13;
<p class="indent">The first nybble of an address tells me what type it is, just by checking the memory map in <a href="ch04.xhtml#ch4fig2">Figure 4.2</a>. Those that begin with a <span class="literal">1</span> are SRAM on this chip, while those that begin with <span class="literal">0</span> are flash memory and effectively constant. If it begins with a <span class="literal">4</span>, it’s an I/O peripheral and I can look up the peripheral’s name in the chip’s datasheet or header files.</p>&#13;
<p class="indent">Large <span class="literal">switch</span> statements are also handy, such as the loop that interprets the commands in <a href="ch04.xhtml#ch4fig4">Figure 4.4</a>. Note that two of those commands, <span class="literal">T</span> and <span class="literal">U</span>, are absent from NXP’s documentation.</p>&#13;
<p class="indent">I skipped over the mass storage implementation, as I already knew which bug I would be exploiting from reading the details in <span epub:type="pagebreak" id="page_48"/>Herrewegen et al. (2020). When hunting an original bug, rather than re-implementing prior art, it’s a good idea to explore all of the code that is reachable while the chip is locked. Pay special attention to parser code, and consider fuzz testing the firmware in emulation if you don’t find an exploitable bug manually.</p>&#13;
<h3 class="h3" id="ch00lev1sec14"><strong>Controlling the Program Counter</strong></h3>&#13;
<p class="noindent">After implementing the basic bootloader commands, we can read and write the SRAM of a locked chip above <span class="literal">0x10000200</span>, so controlling the program counter is as simple as finding a return pointer on the stack above that address. If we overwrite that address and then return, the chip will branch to our new address rather than the legitimate caller function.</p>&#13;
<p class="indent">In my Ghidra project, I looked at the interrupt table of the bootloader at <span class="literal">0x1fff0000</span>. The very first word, <span class="literal">0x10000ffc</span>, is the initial top of the stack, and the return pointer that I want to clobber should come somewhere below that in memory.</p>&#13;
<p class="indent">My second clue to a good injection location was that when I halted the bootloader to zero it, the program counter was <span class="literal">0x10001f88</span>. Depth will vary by the function being called, but this shows that I’m in the right region.</p>&#13;
<p class="indent">A third clue came again from Ghidra, where I could explore this region for valid code pointers. The offset will vary a bit, because I’m viewing the stack of the Read command and my exploit will be corrupting the stack of the Write command, but the alignments are often similar.</p>&#13;
<p class="indent">Eventually I came up with <span class="literal">0x10001f94</span> as a working return pointer that is restored to the program counter after the Read command sends its acknowledgment. It’s here that I write the address of my shellcode to trigger its execution.</p>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_49"/><img src="../images/f0049-01.jpg" alt="Image" width="821" height="368"/></div>&#13;
<h3 class="h3" id="ch00lev1sec15"><strong>Shellcode for Privilege Escalation</strong></h3>&#13;
<p class="noindent">Herrewegen’s exploit rewrote more than just the return pointer. Instead, he patched the stack to turn a Write into a Read, dumping text back to his client. I’m lazy, so I took the more direct route of running C shellcode from RAM rather than repurposing existing code from ROM.</p>&#13;
<p class="indent">Getting the shellcode as bytes that would run from SRAM required only a minimal linker script, and for simplicity’s sake I used the <span class="literal">ENTRY(main)</span> directive to make my <span class="literal">main()</span> method the entrypoint, and I placed <span class="literal">.text</span> and <span class="literal">.data</span> next to each other in RAM. The first byte is the entry point, and any global variables are loaded directly with the image rather than copied from code memory.</p>&#13;
<p class="indent">From the Herrewegen paper, I knew that there is a global variable in SRAM that caches the CRP lock word. The permanent location in flash is at <span class="literal">0x000002fc</span>, and a little bit of searching in Ghidra revealed that the cached version is at <span class="literal">0x10000184</span>. So the first thing my shellcode must do is overwrite this with a higher <span epub:type="pagebreak" id="page_50"/>privilege value, such as zero.</p>&#13;
<p class="indent">I also needed to make sure that the stack had been restored, so that the interpreter loop of the bootloader wouldn’t crash. This could be done by luck, or by crafting the right bytes on the stack, but because I wanted my shellcode to work on the very first try, I took a simpler solution: it simply calls the main loop of the command interpreter, which expects to be called by the bootloader after privileges have been cached. It’s an infinite <span class="literal">while()</span> loop that never returns, and there’s plenty of stack depth to spare. This gives a clean continuation without any hard work.<sup><a id="ch4fn_1" href="footnotes.xhtml#ch4fn1">1</a></sup></p>&#13;
<p class="indent">This is my symbol file. It defines only the global variable that contains the protection level and the bootloader’s command interpreter loop.</p>&#13;
<div class="imagel"><img src="../images/f0050-01.jpg" alt="Image" width="811" height="66"/></div>&#13;
<p class="indent">This is my shellcode, written in C rather than assembly. It simply disables the protections and jumps right back into the command loop.</p>&#13;
<div class="imagel"><img src="../images/f0050-02.jpg" alt="Image" width="821" height="321"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_51"/>Tying all of that together, this is the Go method that unlocks the chip, before cleanly continuing into any of the standard boot-loader commands without the pesky readout protection getting in the way.</p>&#13;
<div class="imagel"><img src="../images/f0051-01.jpg" alt="Image" width="821" height="368"/><span epub:type="pagebreak" id="page_52"/></div>&#13;
</div>
</div>
</body></html>