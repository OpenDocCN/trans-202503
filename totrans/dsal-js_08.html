<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch6">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_91" aria-label="91"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch6">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">6</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">SORTING</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">In previous chapters we discussed concepts related to programming and designing algorithms. Now we’ll start considering their actual application. The problem we’ll explore is how to sort a set of records into order, where each record consists of a key (alphabetical, numerical, or several fields) and data.</p>&#13;
<p class="TX">The algorithm’s output should include the exact same set of records, but shuffled so that the keys are in order. You usually want the keys in ascending order, but descending order requires only a minor change in sorting algorithms—namely, reversing comparisons—so you won’t see it here. (See question 6.1 at the end of the chapter.)</p>&#13;
<p class="TX">We’ll first consider general aspects of the sorting problem and then moves on to look at several algorithms based on comparisons of keys (the most common algorithms), followed by a few algorithms based on other principles. We’ll consider the performance of all algorithms and even toss in some humorous algorithms for comparison.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_92" aria-label="92"/>&#13;
<h3 class="H1" id="sec1"><span id="h1-25"/><span class="SANS_Futura_Std_Bold_B_11">The Sorting Problem</span></h3>&#13;
<p class="TNI1">A <i>sorting algorithm</i> is basically an algorithm that, given a list of records containing a key and some data, reorders the list so that the keys are in nondecreasing order (no key is smaller than its preceding key), and the output list is a permutation of the input list, retaining all original records. Forgetting the second condition is easy, but ignoring it would mean that the following would be a valid sorting function:</p>&#13;
<pre id="pre-80"><code>const wrongWayToSort = (inputData) =&gt; [];</code></pre>&#13;
<p class="TX">Sorting is important in and of itself, but it also affects the efficiency of other algorithms. For instance, in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span> we’ll see how working with sorted data allows for more efficient search procedures.</p>&#13;
<p class="TX">For our examples, we’ll usually assume single-field keys that you can directly compare using the <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">&gt;</span> operators. For more generic cases, you could modify the algorithms to use the <span class="SANS_TheSansMonoCd_W5Regular_11">compare(a,b)</span> comparison function, as JavaScript’s sorting algorithm does (see the section “<span class="Xref">JavaScript’s Own Sort Method</span>” on page <span class="Xref">95</span>). In the code examples in this book, you’ll always write tests as <span class="SANS_TheSansMonoCd_W5Regular_11">a&gt;b</span>, so modifying the code for generic sorting requires only changing that comparison to <span class="SANS_TheSansMonoCd_W5Regular_11">compare(a,b)&gt;0</span>. (See question 6.2 for a variation.) In <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span>, you’ll actually use this kind of solution by applying a <span class="SANS_TheSansMonoCd_W5Regular_11">goesHigher(a,b)</span> function to decide which of <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> should be higher in a heap.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-42"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Internal vs. External Sorting</span></h4>&#13;
<p class="TNI1">An important consideration when sorting data is whether it can all be stored in memory at the same time, or whether it’s so large that it must reside in a storage device. The first case is called <i>internal sorting</i>, and the second is called <i>external sorting</i>. All the algorithms in this chapter fall into the first category, but what if you need to sort more data than can fit in memory?</p>&#13;
<p class="TX">External sorting breaks up all the input into runs that are as large as possible to fit in memory, then uses internal sorting to sort the runs, saves them to external storage, and merges the sorted runs into the final output. That said, it’s highly likely that for large sorting tasks like this, you’ll be better off using a standard system sort utility, which also might be optimized to use parallel threads, multiple central processing units (CPUs), and so on. In any case, should you decide to roll out your own external sort procedure, the algorithms in this section cover the needed internal sorting, and using a heap (as in <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span>) would help with writing efficient merge code.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-43"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Adaptive Sorting</span></h4>&#13;
<p class="TNI1">A sorting algorithm is called <i>adaptive</i> if it somehow takes advantage of whatever existing order already exists in its input. Shell sort, which you’ll learn about in the section “<span class="Xref">Making Bigger Jumps with Comb and Shell Sort</span>” on page <span class="Xref">103</span>, is such a case: the algorithm performs better when data is partially sorted. On the other hand, quicksort, which you’ll learn about in the section “<span class="Xref">Going for Speed with Quicksort</span>” on page <span class="Xref">105</span>, could be considered <span role="doc-pagebreak" epub:type="pagebreak" id="pg_93" aria-label="93"/>anti-adaptive. Its worst performance happens when data is already in order (though there are ways around this).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-44"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">In-Place and</span> <span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Out-of-Place Sorting</span></h4>&#13;
<p class="TNI1">Another consideration for sorting algorithms is whether they require extra data structures (and thus extra space). This requirement is often relaxed to allow for constant, less than <i>O</i>(<i>n</i>) extra memory—the key rule is whether extra space proportional to the input size is needed. We don’t take into account the <i>O</i>(<i>n</i>) space needed to store the <i>n</i> elements to be sorted. Algorithms that don’t require such extra space are called <i>in-place</i>, and those that do require more memory are known as <i>out-of-place</i> or <i>not-in-place</i> algorithms. This doesn’t mean that out-of-place algorithms return a new list; they may perfectly well reorder the input list in place, but they require <i>O</i>(<i>n</i>), or more, extra space to do so.</p>&#13;
<p class="TX">Consider carefully how much memory an algorithm uses: some recursive algorithms like quicksort require internally using a stack that is <i>O</i>(<i>log n</i>) but that is also allowed to count as in-place. Merge sort usually requires extra space to merge sequences, so it has <i>O</i>(<i>n</i>) needs and thus falls into the out-of-place category.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-45"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Online and Offline Sorting</span></h4>&#13;
<p class="TNI1">Another distinction to make when considering algorithms is whether they can process the input data in a serial stream-like fashion or whether all the data needs to be available from the beginning. Algorithms in the first category are called <i>online algorithms</i>, and those in the second are <i>offline algorithms</i>. This distinction applies not only to sorting but to other problems as well; for example, you’ll see it again when discussing sampling in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>.</p>&#13;
<p class="TX">In terms of sorting, an online algorithm will always have a sorted list, adding new elements to it as they come in, while an offline algorithm will have to wait until all elements are available. Offline algorithms usually have better performance, though. Online algorithms don’t know the whole input, so they have to make decisions that may turn out later to be suboptimal, which is the same kind of situation as with greedy algorithms (see <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>).</p>&#13;
<p class="TX">As an example of this distinction, consider how you could sort a set of playing cards. If you keep the cards you’ve sorted so far in your hand and then every time you get a new card you insert it into place among the previous ones, you are implementing an online algorithm—in fact, it’s an <i>insertion sort</i>, which we’ll study in the section “<span class="Xref">Sorting Strategies for Playing Cards</span>” on page <span class="Xref">100</span>. If you wait until you have all the cards and then sort them somehow, that’s an offline sort.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-46"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Sorting Stability</span></h4>&#13;
<p class="TNI1">Sorting data with possibly equal keys raises a question: In what relative order do the elements with equal keys end up? A <i>stable sorting</i> algorithm maintains the same order as the input, so if one element preceded another <span role="doc-pagebreak" epub:type="pagebreak" id="pg_94" aria-label="94"/>and both had the same key, in the ordered output, the first one will precede the second.</p>&#13;
<p class="TX">Why does stability matter? Imagine you want to have a drop-down element in an HTML page that shows your contacts but with this rule: starred contacts (favorites) should appear first, in alphabetical order, followed by nonstarred contacts, also in alphabetical order.</p>&#13;
<p class="TX">To achieve the required ordering, you could first order the whole list by name and then reorder it so starred contacts are first. <a href="chapter6.xhtml#fig6-1">Figure 6-1</a> illustrates this method.</p>&#13;
<figure class="IMG"><img class="img5" id="fig6-1" src="../images/Figure6-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 6-1: Sorting by two fields with a stable sorting algorithm</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The first sort reorders the list by name, alphabetically, and the second sort places starred names before the ones without stars. If the second sort is stable, this ordering won’t affect the previous alphabetical sorting. With an unstable sort, that might not be true. Stability is the reason Joliet precedes Romeo in the final list. Joliet preceded Romeo when sorting by name, and when sorting by star, they keep the same relative order.</p>&#13;
<p class="TX">You can modify any sorting algorithm to force it to be stable. No matter what the key for ordering is, consider a new extended key formed by the original key followed by the item’s position in the list. Ordering this array by the new extended key, items that shared the same (original) key value will be sorted together, but because of the added position, they will keep the same original relative order, as shown in <a href="chapter6.xhtml#fig6-2">Figure 6-2</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig6-2" src="../images/Figure6-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 6-2: Sorting made stable by using an extended key</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The first step adds the item’s position as an extra key; the second step sorts by name and position. Elements that had the same original key (Alpha and Echo in the example) are kept in their original relative positions to each other. You would finish by dropping the added field.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_95" aria-label="95"/>&#13;
<h4 class="H2" id="sec7"><span id="h2-47"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">JavaScript’s Own Sort Method</span></h4>&#13;
<p class="TNI1">When sorting data in JavaScript, don’t forget that the language already provides a <span class="SANS_TheSansMonoCd_W5Regular_11">.sort(...)</span> method, and despite considering more (and possibly better) sorting algorithms later in this chapter, in many cases using JavaScript’s own sort might be most effective. Let’s quickly review how this sort works (see <i><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort</a></i> for more information).</p>&#13;
<p class="TX">Given an array, the <span class="SANS_TheSansMonoCd_W5Regular_11">.sort(comparisonFunction)</span> method reorders the array in place using an optional comparison function. (The newer <span class="SANS_TheSansMonoCd_W5Regular_11">.toSorted()</span> method doesn’t sort in place, but rather produces a new, sorted version of the array.) If that function is omitted, JavaScript converts elements to strings and then sorts lexicographically, which may not be what you wanted:</p>&#13;
<pre id="pre-81"><code>const a = [22, 9, 60, 12, 4, 56];&#13;
a.sort();&#13;
console.log(a); // 12 22 4 56 60 9</code></pre>&#13;
<p class="TX">To accommodate other ways of sorting, you need to provide a function that will receive two elements, <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">b</span>, and return a negative value if <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> should precede <span class="SANS_TheSansMonoCd_W5Regular_11">b</span>, a positive value if <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> should follow <span class="SANS_TheSansMonoCd_W5Regular_11">b</span>, and zero if both keys are equal and if <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> could be in any order. You can fix the previous example quite easily:</p>&#13;
<pre id="pre-82"><code>const a = [22, 9, 60, 12, 4, 56];&#13;
a.sort(<b>(a, b) =&gt; a - b</b>);&#13;
console.log(a); // 4 9 12 22 56 60</code></pre>&#13;
<p class="TX">You can also implement more complex comparisons; the following example shows how you would sort objects by date and name:</p>&#13;
<pre id="pre-83"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const people = [&#13;
  {d: 22, m: 9, y: 60, n: "alpha"},&#13;
  {d: 12, m: 4, y: 56, n: "bravo"},&#13;
  {d: 22, m: 3, y: 56, n: "hotel"},&#13;
  {d: 9,  m: 1, y: 60, n: "foxtrot"},&#13;
  {d: 22, m: 4, y: 56, n: "echo"},&#13;
  {d: 22, m: 3, y: 56, n: "delta"},&#13;
  {d: 22, m: 3, y: 56, n: "india"},&#13;
  {d: 14, m: 1, y: 34, n: "charlie"},&#13;
  {d: 9,  m:12, y: 40, n: "golf"}&#13;
];&#13;
&#13;
const dateNameCompare = (a, b) =&gt; {&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation2">❷</span> if (a.y !== b.y) {&#13;
    return a.y - b.y;&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation3">❸</span>} else if (a.m !== b.m) {&#13;
    return a.m - b.m;&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation4">❹</span>} else if (a.d !== b.d) {&#13;
    return a.d - b.d;&#13;
<span class="Code_CodeAnnotation1" aria-label="annotation5">❺</span>} else if (a.n &lt; b.n) {&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_96" aria-label="96"/>    return -1;&#13;
  } else if (a.n &gt; b.n) {&#13;
    return 1;&#13;
  } else {&#13;
 <span class="Code_CodeAnnotation1" aria-label="annotation6">❻</span> return 0;&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX">The data to sort <span class="CodeAnnotation" aria-label="annotation1">❶</span> has dates as three separate fields (<span class="SANS_TheSansMonoCd_W5Regular_11">d</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">m</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>, for day, month, and year) and name (<span class="SANS_TheSansMonoCd_W5Regular_11">n</span>). If two persons are from different years <span class="CodeAnnotation" aria-label="annotation2">❷</span>, you return the correct negative or positive value by subtracting years. If the years are equal, you can compare months with the same kind of logic <span class="CodeAnnotation" aria-label="annotation3">❸</span>, and if the months are also equal <span class="CodeAnnotation" aria-label="annotation4">❹</span>, you do the same once more for days. If the dates are equal, you resort to comparing names <span class="CodeAnnotation" aria-label="annotation5">❺</span>, and since you cannot use math and just subtract dates, you need to make actual comparisons, date part by date part. The final <span class="SANS_TheSansMonoCd_W5Regular_11">return 0</span> is done <span class="CodeAnnotation" aria-label="annotation6">❻</span> only if all fields were compared and found to match.</p>&#13;
<p class="TX">If you sort the <span class="SANS_TheSansMonoCd_W5Regular_11">people</span> array with the <span class="SANS_TheSansMonoCd_W5Regular_11">dateNameCompare(...)</span> function you just wrote, you get the expected result:</p>&#13;
<pre id="pre-84"><code>console.log(people.sort(dateNameCompare));&#13;
&#13;
[&#13;
  {d: 14, m: 1, y: 34, n: 'charlie'},&#13;
  {d: 9,  m:12, y: 40, n: 'golf'},&#13;
  {d: 22, m: 3, y: 56, n: 'delta'},&#13;
  {d: 22, m: 3, y: 56, n: 'hotel'},&#13;
  {d: 22, m: 3, y: 56, n: 'india'},&#13;
  {d: 12, m: 4, y: 56, n: 'bravo'},&#13;
  {d: 22, m: 4, y: 56, n: 'echo'},&#13;
  {d:  9, m: 1, y: 60, n: 'foxtrot'},&#13;
  {d: 22, m: 9, y: 60, n: 'alpha'}&#13;
]</code></pre>&#13;
<p class="TX">Finally, consider stability. Originally, the specification for the <span class="SANS_TheSansMonoCd_W5Regular_11">.sort(...)</span> method didn’t require it, but ECMAScript 2019 added the requirement. Be aware, however, that if using an earlier JavaScript engine, you cannot assume stability, so you might have to resort to the solution described in “<span class="Xref">Sorting Stability</span>” on <span class="Xref"><a href="chapter6.xhtml#pg_93">page 93</a></span>. Also, keep in mind that any given engine may just not correctly implement the standard.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-48"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Sort Performance</span></h4>&#13;
<p class="TNI1">If you have to sort <i>n</i> values, your logic has to be able to deal with all possible <i>n</i>! permutations of those values. How many comparisons will be needed for that? Think of the game of 20 questions. In that game, you have to guess a selected object by asking, at most, 20 yes or no questions. If you plan your questions carefully, you should be able to pick any element out of more than a million (2<sup>20</sup> = 1,048,576, actually) possible options. You can apply that logic to sorting <i>n</i> elements.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_97" aria-label="97"/>If you are comparing elements to sort an array, it’s indirectly implied that you’re deciding which was the original permutation. Well-placed questions divide the range of options in half, so you need to know how many questions are needed for <i>n</i>! possibilities. This is equivalent to asking how many times you should divide <i>n</i>! by 2 until you get down to 1. The answer is log <i>n!</i>, in base 2. (Alternatively, you can see it as asking what value of <i>k</i> is such that 2<i><sup>k</sup></i> &gt; <i>n</i>!) This section won’t go into its derivation, but Stirling’s approximation says that <i>n</i>! grows as <i>n</i><i><sup>n</sup></i>, so the logarithm of <i>n</i>! is <i>O</i>(<i>n</i> log <i>n</i>).</p>&#13;
<p class="TX">This automatically implies that any algorithm based on comparing elements will be <i>O</i>(<i>n</i> log <i>n</i>) at the very least. No better results are achievable, but worse results are obviously possible. With that in mind, in the next section we’ll consider several algorithms, from worst to best performance.</p>&#13;
<p class="TX">Note, however, the observation about these algorithms being “based on comparing elements.” If you manage to sort a list without making actual comparisons, all bets are off. You’ll see that some methods allow sorting in <i>O</i>(<i>n</i>) time, without ever comparing keys to each other.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span id="h1-26"/><span class="SANS_Futura_Std_Bold_B_11">Sorting with Comparisons</span></h3>&#13;
<p class="TNI1">As mentioned previously, we’ll consider the major sorting algorithms, all of which depend on comparing values to each other. The first algorithms we’ll consider are <i>O</i>(<i>n</i><sup>2</sup>), so they’re not optimum, but we’ll move on to better ones until we reach several that achieve the best <i>O</i>(<i>n</i> log <i>n</i>) performance.</p>&#13;
<p class="TX">In all cases you’ll write functions that receive an array of values (as stated earlier, you don’t have to worry about key + data pairs, as that can easily be accommodated), and you’ll also pass parameters to specify which part of the array (<span class="SANS_TheSansMonoCd_W5Regular_11">from</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">to</span>) should be sorted. As usual, you’ll want to sort the whole array. Those parameters will have default values, so the whole array will be sorted if they’re not present.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-49"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Bubbling Up and Down</span></h4>&#13;
<p class="TNI1">We’ll start our review of sorting algorithms with <i>bubble sort</i>, which probably has the catchiest name, possibly to compensate for its subpar performance. This algorithm is easy to implement, but you’d use it only for smaller sets of data. It also has generated several variations (you’ll look at comb sort in the next section, which actually leads to a better-performing algorithm).</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h5 class="H3" id="sec11"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Bubble Sort</span></h5>&#13;
<p class="TNI1">The bubble sort algorithm derives its name from the simple idea that larger numbers represent bubbles that bubble up to the top of the list. It starts at the beginning of the array and goes in order through all elements in the array, and if an element is greater than the following element, it swaps them (see <a href="chapter6.xhtml#fig6-3">Figure 6-3</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_98" aria-label="98"/>&#13;
<figure class="IMG"><img class="img5" id="fig6-3" src="../images/Figure6-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 6-3: With bubble sort, each pass moves another element to its place.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The first pass at the top of <a href="chapter6.xhtml#fig6-3">Figure 6-3</a> goes from left to right, comparing adjacent values and swapping if needed so that the higher value is always to the right. After the first pass, 60 goes to the top of the array. You proceed in the same way with the rest of the array, and after the second pass, 56 goes to the next-to-last position, so you have at least two elements in the right place. After the third pass, three elements will be in place, and so on. The last two rows required no swapping, because previous passes had already moved the elements to the correct places, which frequently happens.</p>&#13;
<p class="TX">Here’s the logic for this algorithm:</p>&#13;
<pre id="pre-85"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const bubbleSort = (arr, from = 0, to = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> for (let j = to; j &gt; from; j--) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> for (let i = from; i &lt; j; i++) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if (arr[i] &gt; arr[i + 1]) {&#13;
        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];&#13;
      }&#13;
    }&#13;
  }&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="TX">All sorting functions share the same signature: an array to sort (<span class="SANS_TheSansMonoCd_W5Regular_11">arr</span>) and the limits for sorting (<span class="SANS_TheSansMonoCd_W5Regular_11">from</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">to</span>) that, by default, will be the array’s extremes <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The outer loop <span class="CodeAnnotation" aria-label="annotation2">❷</span> goes from the right to the left; after each pass, the element in position <span class="SANS_TheSansMonoCd_W5Regular_11">j</span> of the array will be in the right place. The inner loop <span class="CodeAnnotation" aria-label="annotation3">❸</span> goes from the left extreme to the right up to (but not reaching) the outer loop <span class="SANS_TheSansMonoCd_W5Regular_11">j</span>; you compare each element with the next <span class="CodeAnnotation" aria-label="annotation4">❹</span>, and if the second is smaller, you swap them.</p>&#13;
<p class="TX">You can improve performance in most sorted arrays (a not uncommon case) by checking whether any swaps occurred on each pass through the array. If none were detected, it means the array is in order (see question 6.7).</p>&#13;
<p class="TX">The performance of this algorithm is <i>O</i>(<i>n</i><sup>2</sup>), which is easy to calculate. First count comparisons: the first pass does (<i>n</i> – 1) comparisons, the second pass does (<i>n</i> – 2), the third (<i>n</i> – 3), and so on. The total number of comparisons is then the sum of all numbers from (<i>n</i> – 1) down to 1, which is <i>n</i>(<i>n</i> – 1) / 2, so <i>O</i>(<i>n</i><sup>2</sup>).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_99" aria-label="99"/>&#13;
<h5 class="H3" id="sec12"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Sinking Sort and Shuttle Sort</span></h5>&#13;
<p class="TNI1">Bubble sort quickly moves the greatest values to the end of an array, but the smallest values may take a while to reach their final positions. Similarly, <i>sinking sort</i> (see question 6.6) makes the lowest values quickly sink to the beginning of the array, but correspondingly, it takes longer for the greatest values to go to their places. You can alternate a pass of bubbling with a pass of sinking to get an enhanced algorithm, called <i>shuttle sort</i> (also known as <i>cocktail shaker sort</i> or <i>bidirectional</i> bubble sort). In comparison with bubble sort, the first passes of the shuttle sort proceed as shown in <a href="chapter6.xhtml#fig6-4">Figure 6-4</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig6-4" src="../images/Figure6-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 6-4: Shuttle sort alternates left-to-right and right-to-left passes.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Starting with the same elements, the first pass is the same as bubble sort’s, moving 60, which is the greatest value in the array, to the rightmost position. The second pass goes right to left and moves 04, the smallest value in the array, to the leftmost position. The third pass again goes left to right and moves 56 to its place; after that, it goes right to left, then left to right, and so on, alternating direction every time.</p>&#13;
<p class="TX">Here’s the corresponding code:</p>&#13;
<pre id="pre-86"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const shuttleSort = (arr, from = 0, to = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> let f = from;&#13;
  let t = to;&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> while (f &lt; t) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> for (let i = f; i &lt;= t - 1; i++) {&#13;
      if (arr[i] &gt; arr[i + 1]) {&#13;
        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];&#13;
      }&#13;
    }&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> t--;&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> for (let i = t - 1; i &gt;= f; i--) {&#13;
      if (arr[i] &gt; arr[i + 1]) {&#13;
        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];&#13;
      }&#13;
    }&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_100" aria-label="100"/>  <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> f++;&#13;
  }&#13;
&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="TX">As mentioned earlier, the signature for this sort function is always the same: an array to sort and the portion to put in order <span class="CodeAnnotation" aria-label="annotation1">❶</span>. You have two variables <span class="CodeAnnotation" aria-label="annotation2">❷</span> that mark how far to the left and right the array is already sorted: <span class="SANS_TheSansMonoCd_W5Regular_11">f</span> (as in <i>from</i>) starts at the left and grows by 1 after each right-to-left pass, and <span class="SANS_TheSansMonoCd_W5Regular_11">t</span> (as in <i>to</i>) starts at the right and decreases by 1 after each left-to-right pass. When these variables meet <span class="CodeAnnotation" aria-label="annotation3">❸</span>, the sort is done. You perform a left-to-right pass as shown earlier <span class="CodeAnnotation" aria-label="annotation4">❹</span>, and then you decrement <span class="SANS_TheSansMonoCd_W5Regular_11">t</span> <span class="CodeAnnotation" aria-label="annotation5">❺</span>, since you’ve placed a new value in the right place. After this pass, you do the same <span class="CodeAnnotation" aria-label="annotation6">❻</span>, but right to left, and you increment <span class="SANS_TheSansMonoCd_W5Regular_11">f</span> <span class="CodeAnnotation" aria-label="annotation7">❼</span> to finish.</p>&#13;
<p class="TX">The algorithm is still <i>O</i>(<i>n</i><sup>2</sup>), but the actual implementation typically is double the speed or even better if you include testing for swaps (see question 6.7). In any case, it’s easy to show that it can’t do any worse, for in each pass, it places one number at its final position, so after having placed (<i>n</i> – 1) numbers at their place, it will be done, the same as bubble sort.</p>&#13;
<p class="TX">Nevertheless, despite the catchy name, this sort algorithm is not good enough in comparison with those that we’ll explore later in the chapter.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h2-50"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Sorting Strategies for Playing Cards</span></h4>&#13;
<p class="TNI1">Thinking about how you do simple tasks can provide tips for developing an algorithm. For example, suppose you have a few playing cards in your hand and want to order them from lowest to highest. You could apply a couple of different strategies, which we’ll look at next: selection sort or insertion sort.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h5 class="H3" id="sec14"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Selection Sort</span></h5>&#13;
<p class="TNI1">A simple solution is to look for the lowest card and place it farthest to the left in your hand. Then look for the next lowest card and place it after the first, and keep doing that, always selecting the lowest remaining card and placing it next to the already sorted cards. This process is the basis for the <i>selection sort</i> algorithm, which adds a small detail: when placing a card to the left, you do a swap with the other card (see <a href="chapter6.xhtml#fig6-5">Figure 6-5</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig6-5" src="../images/Figure6-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 6-5: Selection sort looks for the smallest element and swaps it to get it into place.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_101" aria-label="101"/>In the first pass at the top, you find that the minimum number is 04, and you do a swap to move it to the first place in the array. The second pass finds 09 and swaps it with 12, so you now have two numbers in order. The process continues the same way; an exception is in the next-to-last line, in which no swap is needed because 56 was already in the correct place.</p>&#13;
<p class="TX">Here’s an implementation:</p>&#13;
<pre id="pre-87"><code>const selectionSort = (arr, from = 0, to = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> for (let i = from; i &lt; to; i++) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> let m = i;&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> for (let j = i + 1; j &lt;= to; j++) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> if (arr[m] &gt; arr[j]) {&#13;
        m = j;&#13;
      }&#13;
    }&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> if (m !== i) {&#13;
      [arr[i], arr[m]] = [arr[m], arr[i]];&#13;
    }&#13;
  }&#13;
&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="TX">Go in order <span class="CodeAnnotation" aria-label="annotation1">❶</span> from the first place in the array to the last. The <span class="SANS_TheSansMonoCd_W5Regular_11">m</span> variable <span class="CodeAnnotation" aria-label="annotation2">❷</span> keeps track of the position of the minimum value already found. As you loop through the yet unsorted numbers <span class="CodeAnnotation" aria-label="annotation3">❸</span>, if you find a new minimum candidate <span class="CodeAnnotation" aria-label="annotation4">❹</span>, you update <span class="SANS_TheSansMonoCd_W5Regular_11">m</span>. After finishing this loop, if the minimum isn’t already in place <span class="CodeAnnotation" aria-label="annotation5">❺</span>, do a swap.</p>&#13;
<p class="TX">The order of this algorithm is, again, <i>O</i>(<i>n</i><sup>2</sup>). You have to look at <i>n</i> elements to find what should go in the first place; then look at <i>n</i> – 1 for the second place, <i>n</i> – 2 for the third, and so on. You already know this sum is <i>O</i>(<i>n</i><sup>2</sup>). The algorithm in the next section is also based on how you’d sort playing cards, but it has slightly better performance.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h5 class="H3" id="sec15"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Insertion Sort</span></h5>&#13;
<p class="TNI1">With selection sort, we thought about sorting playing cards, but you could have considered another method. Take the first card; that’s clearly already in order by itself. Now look at the second card, and either place it before the first (if it’s lower) or leave it where it is (if it’s higher). You now have two cards in order. Look at the third card, decide where it should go among the previous two, and place it there. As you go through all the cards in your hand, you’ll end up putting them in order, and this is called an <i>insertion sort</i>, because of the way you insert new cards among the previously sorted ones (see <a href="chapter6.xhtml#fig6-6">Figure 6-6</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_102" aria-label="102"/>&#13;
<figure class="IMG"><img class="img5" id="fig6-6" src="../images/Figure6-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 6-6: Sorting by insertion works the way one sorts playing cards.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Start with a single card in order, in this case, number 34. Then consider the next value, 12, and place it to the left of 34, so the two numbers are in order. Then consider 22, which goes between 12 and 34, and now three values are ordered. Continue working this way, always inserting the next number where it belongs among the previously sorted ones, until you reach the last line. After placing 14 among the already sorted numbers, the whole array becomes ordered.</p>&#13;
<p class="TX">The following code implements this method:</p>&#13;
<pre id="pre-88"><code>const insertionSort = (arr, from = 0, to = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> for (let i = from + 1; i &lt;= to; i++) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> for (let j = i; j &gt; from &amp;&amp; arr[j - 1] &gt; arr[j]; j--) {&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> [arr[j - 1], arr[j]] = [arr[j], arr[j – 1]];&#13;
    }&#13;
  }&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="TX">Set up a loop that starts at the second place in the array and goes to the end <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and loop back as long as the list isn’t in order <span class="CodeAnnotation" aria-label="annotation2">❷</span>, swapping to get new numbers in place <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Looking at this carefully, you’ll notice it’s doing too many swaps to get the new element to its place.</p>&#13;
<p class="TX">You can quickly optimize the code to avoid that and do just one swap per loop:</p>&#13;
<pre id="pre-89"><code>const insertionSort = (arr, from = 0, to = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> for (let i = from + 1; i &lt;= to; i++) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const temp = arr[i];&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> let j;&#13;
    for (j = i; j &gt; from &amp;&amp; arr[j - 1] &gt; temp; j--) {&#13;
      arr[j] = arr[j - 1];&#13;
    }&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> arr[j] = temp;&#13;
  }&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_103" aria-label="103"/>The first loop <span class="CodeAnnotation" aria-label="annotation1">❶</span> is exactly the same as earlier, but the difference lies within. You set the number to be inserted among the previously sorted aside <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and you loop to find where it should go <span class="CodeAnnotation" aria-label="annotation3">❸</span>, pushing values that are greater to the right. At the end <span class="CodeAnnotation" aria-label="annotation4">❹</span>, you place the new value in its final position.</p>&#13;
<p class="TX">Insertion sort is a simple algorithm, which makes it a good choice for smaller arrays. Later in the chapter we’ll look at how it’s sometimes used in hybrid sorting algorithms as a replacement for theoretically more convenient, but practically slower, alternative methods.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h2-51"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Making Bigger Jumps with Comb and Shell Sort</span></h4>&#13;
<p class="TNI1">Bubble sort and its variants are not the best-performing sorting algorithms. However, the idea of swapping elements to make them bubble up or sink down isn’t bad, and applying the idea of making larger jumps (for example, swapping elements that are farther apart) eventually leads to a better algorithm, <i>Shell sort</i>. You’ll explore this idea with a bubble sort variant called <i>comb sort</i> first.</p>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h5 class="H3" id="sec17"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Comb Sort</span></h5>&#13;
<p class="TNI1">Let’s go back to bubble sort and consider how keys move in an array like rabbits and turtles. Rabbits represent the large values near the beginning of the list, which quickly move to their places at the end of the array, swap after swap. On the other hand, turtles represent the small values near the end of the list, which slowly move to their places in a single swap per pass. You want both turtles and rabbits to move quickly to their respective sides of the array.</p>&#13;
<p class="TX">The idea is to perform some passes with swaps, but instead of comparing one element with the next one, you’ll consider larger gaps. Thus, rabbits will jump further distances toward the right, but turtles will correspondingly jump further distances toward the left. You’ll do passes with successively smaller gaps, and when the gap becomes 1, you’ll apply the common bubble sort to finish.</p>&#13;
<p class="TX">The logic is as follows:</p>&#13;
<pre id="pre-90"><code>const combSort = (arr, from = 0, to = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const SHRINK_FACTOR = 1.3;&#13;
&#13;
  let gap = to - from + 1;&#13;
  for (;;) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> gap = Math.floor(gap / SHRINK_FACTOR);&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (gap === 1) {&#13;
      return bubbleSort(arr, from, to);&#13;
    }&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> for (let i = from; i &lt;= to - gap; i++) {&#13;
      if (arr[i] &gt; arr[i + gap]) {&#13;
        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];&#13;
      }&#13;
    }&#13;
  }&#13;
};</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_104" aria-label="104"/>It has been determined empirically that the first gap should equal the array’s length divided by 1.3, the “shrink factor” <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and successive gaps will always be 1.3 times smaller <span class="CodeAnnotation" aria-label="annotation2">❷</span>. When the gap becomes 1 <span class="CodeAnnotation" aria-label="annotation3">❸</span>, just apply bubble sort, and you’re done. While the gap is greater than 1 <span class="CodeAnnotation" aria-label="annotation4">❹</span>, you do what’s essentially the central logic of bubble sort, but instead of comparing elements one place apart, you compare elements <span class="SANS_TheSansMonoCd_W5Regular_11">gap</span> places apart.</p>&#13;
<p class="TX">Comb sort usually performs better than bubble sort, but it’s still <i>O</i>(<i>n</i><sup>2</sup>) in the worst case and becomes <i>O</i>(<i>n</i> log <i>n</i>) in the best case. However, that’s not why we’re considering this idea; rather, the concept of sorting elements that are far apart provides real benefits, and you’ll see that Shell sort that does exactly that in a way similar to comb sort.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h5 class="H3" id="sec18"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Shell Sort</span></h5>&#13;
<p class="TNI1">To understand how Shell sort works, assume you want to order the array shown in <a href="chapter6.xhtml#fig6-7">Figure 6-7</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig6-7" src="../images/Figure6-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 6-7: Shell sort works similarly to insertion sort, but with larger gaps.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In the first pass, do an insertion sort, but for elements set four places apart, which leads to an array consisting of four short-ordered sequences. Then lower the gap size to 2 and repeat the sort. The array now consists of two ordered sequences. Eventually, you reach a gap size of 1, and in that case, you’re just doing an insertion sort, but because of the previous partial sorts, it doesn’t do as many comparisons or swaps as with the normal algorithm, which is the advantage of Shell sort.</p>&#13;
<p class="TX">Here’s the Shell sort implementation:</p>&#13;
<pre id="pre-91"><code>const shellSort = (arr, from = 0, to = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const gaps = [1]; // Knuth, 1973&#13;
  while (gaps[0] &lt; (to - from) / 3) {&#13;
    gaps.unshift(gaps[0] * 3 + 1);&#13;
  }&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> gaps.forEach((gap) =&gt; {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> for (let i = from + gap; i &lt;= to; i++) {&#13;
      const temp = arr[i];&#13;
      let j;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_105" aria-label="105"/>    <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> for (j = i; j &gt;= from + gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap) {&#13;
        arr[j] = arr[j - gap];&#13;
      }&#13;
      arr[j] = temp;&#13;
    }&#13;
  });&#13;
&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="TX">First select what gaps to use <span class="CodeAnnotation" aria-label="annotation1">❶</span>, keeping in mind that the last one to be applied must be 1. You’ll find many suggestions online as to which sequence to use, but this example will use Knuth’s proposal (1, 4, 13, 40, 121, . . . , with each term being triple the previous one, plus 1), which leads to an <i>O</i>(<i>n</i><sup>1.5</sup>) algorithm. Then, you take gaps in decreasing order <span class="CodeAnnotation" aria-label="annotation2">❷</span> and essentially do an insertion sort <span class="CodeAnnotation" aria-label="annotation3">❸</span> but for elements <span class="SANS_TheSansMonoCd_W5Regular_11">gap</span> spaces apart <span class="CodeAnnotation" aria-label="annotation4">❹</span>. With larger gaps, you’re ordering sequences of fewer elements, but as you decrease the gap size, you deal with longer sequences that tend to be almost in order, so insertion sort behaves well.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h4 class="H2" id="sec19"><span id="h2-52"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Going for Speed with Quicksort</span></h4>&#13;
<p class="TNI1">Let’s move on to the quicker algorithms that achieve the <i>O</i>(<i>n</i> log <i>n</i>) theoretical speed limit—albeit with a problematic worst-case quadratic performance! <i>Quicksort</i> (also known as <i>partition-exchange sort</i>) was created by Tony Hoare in the 1960s and is a divide-and-conquer algorithm with high speed. We’ll consider the standard version first and then discuss some possible enhancements.</p>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h5 class="H3" id="sec20"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Standard Version</span></h5>&#13;
<p class="TNI1">How does quicksort work? The idea is first to select a “pivot” element from the array to be sorted and redistribute all the other elements in two subarrays, according to whether they are smaller or larger than the pivot. The array ends with lower values first, then the pivot, and then higher values. Then, each subarray is sorted recursively, and when that’s done, the whole array is sorted (see <a href="chapter6.xhtml#fig6-8">Figure 6-8</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig6-8" src="../images/Figure6-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 6-8: Quicksort works by partitioning arrays and recursively sorting the parts.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_106" aria-label="106"/>Let’s say we always choose the rightmost element of the array as the pivot. (It won’t prove to be a very wise option, as you’ll see.) In this case, the first choice is 14, and you rearrange the array so all values less than 14 come first, then 14 itself, and finally all values greater than 14. The same procedure (select the pivot, rearrange, and sort recursively) is applied to each subarray until the whole array is sorted.</p>&#13;
<p class="TX">Here’s a direct implementation of the procedure:</p>&#13;
<pre id="pre-92"><code>const quickSort = (arr, left = 0, right = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (left &lt; right) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const pivot = arr[right];&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> let p = left;&#13;
    for (let j = left; j &lt; right; j++) {&#13;
      if (pivot &gt; arr[j]) {&#13;
        [arr[p], arr[j]] = [arr[j], arr[p]];&#13;
        p++;&#13;
      }&#13;
    }&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> [arr[p], arr[right]] = [arr[right], arr[p]];&#13;
&#13;
    // Recursively sort the two partitions&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> quickSort(arr, left, p – 1);&#13;
    quickSort(arr, p + 1, right);&#13;
  }&#13;
&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="TX">First, check whether there’s actually anything to sort; if the <span class="SANS_TheSansMonoCd_W5Regular_11">left</span> pointer is equal to or greater than the <span class="SANS_TheSansMonoCd_W5Regular_11">right</span> one, you’re done <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The rightmost element will be the pivot <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Next, go through the array from left to right <span class="CodeAnnotation" aria-label="annotation3">❸</span> in a fashion reminiscent of the insertion sort, exchanging elements if needed so smaller elements move to the left, greater ones to the right, and the pivot ends at position <span class="SANS_TheSansMonoCd_W5Regular_11">p</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span>. It would be a good idea to simulate a run of the pivoting code by hand. Despite its short length, it’s a bit tricky to get right. (What happens if the pivot value appears several times in the array? See question 6.10.) Finally, apply recursion to sort the two partitions <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">Analysis shows that <i>on average</i>, quicksort works in <i>O</i>(<i>n</i> log <i>n</i>) time. However, the worst case is easy to find. Consider sorting an already sorted (in ascending or descending order) array. Examining the code shows that partitioning will always end with just one subarray, and you’ll have the equivalent of a selection sort or bubble sort, which means performance goes down to <i>O</i>(<i>n</i><sup>2</sup>). But you can fix that.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h5 class="H3" id="sec21"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Pivot Selection Techniques</span></h5>&#13;
<p class="TNI1">How you choose the pivot can have a serious impact on quicksort’s performance. In particular, if you always choose the largest (or smallest) element in the array, you’ll get a negative hit in speed, so consider some alternative pivot-selecting techniques.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_107" aria-label="107"/>The first solution to avoid problems with sorted arrays is to choose the pivot randomly. Select a random position between left and right inclusive and, if needed, swap the selected element to move it to the rightmost position, so you can go on with the rest of the algorithm without any further changes:</p>&#13;
<pre id="pre-93"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> const iPivot = Math.floor(left + (right + 1 - left) * Math.random());&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if (iPivot !== right) {&#13;
  [arr[iPivot], arr[right]] = [arr[right], arr[iPivot]];&#13;
}</code></pre>&#13;
<p class="TX">We’ll look at random selection in more detail in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>, but the way you calculate <span class="SANS_TheSansMonoCd_W5Regular_11">iPivot</span> (the position of the pivot) <span class="CodeAnnotation" aria-label="annotation1">❶</span> selects a value from <span class="SANS_TheSansMonoCd_W5Regular_11">left</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">right</span> inclusive with equal odds. The rest of the sorting algorithm assumes that the chosen pivot was at the right of the array, so if the chosen pivot is elsewhere <span class="CodeAnnotation" aria-label="annotation2">❷</span>, just do a swap.</p>&#13;
<p class="TX">This random selection solves the worst-case behavior for almost-sorted arrays, but there’s still the (assuredly low) probability that you’ll always just happen to pick the highest or lowest value in the array to be sorted, and in that case, performance will suffer.</p>&#13;
<p class="TX">What’s the ideal pivot? Choosing the array’s median (the value that splits the array in two) would be optimum. A rule that comes close is called the <i>median of three</i>: choose the median of the left, middle, and right elements of the array:</p>&#13;
<pre id="pre-94"><code>const middle = Math.floor((left + right) / 2);&#13;
if (arr[left] &gt; arr[middle]) {&#13;
  [arr[left], arr[middle]] = [arr[middle], arr[left]];&#13;
}&#13;
if (arr[left] &gt; arr[right]) {&#13;
  [arr[left], arr[right]] = [arr[right], arr[left]];&#13;
}&#13;
if (arr[right] &gt; arr[middle]) {&#13;
  [arr[right], arr[middle]] = [arr[middle], arr[right]];&#13;
}</code></pre>&#13;
<p class="TX">Testing this code with all possible permutations of three values shows that <span class="SANS_TheSansMonoCd_W5Regular_11">arr[right]</span> always ends with the middle value. Even better, you might pick the “ninther,” defined as a “median of medians”: divide the array in three parts, apply the median of three to each third, and then take the median of those three values.</p>&#13;
<p class="TX">You can help quicksort become faster by selecting pivots carefully, but you can enhance it even further.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h5 class="H3" id="sec22"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Hybrid Version</span></h5>&#13;
<p class="TNI1">Quicksort is fast, but all the pivots and recursion have an impact on running times, so for small arrays, a combination of simpler algorithms may actually perform faster. You can apply a <i>hybrid algorithm</i> that uses two distinct methods together. For instance, you may find that for arrays under a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_108" aria-label="108"/>certain cutoff limit, an insertion sort performs better, so whenever you want to sort an array smaller than the limit, switch to that algorithm:</p>&#13;
<pre id="pre-95"><code><b>const CUTOFF = 7;</b>&#13;
&#13;
const quickSort = (arr, left = 0, right = arr.length - 1) =&gt; {&#13;
  if (left &lt; right) {&#13;
<b>    if (right - left &lt; CUTOFF) {</b>&#13;
<b>      insertionSort(arr, left, right);</b>&#13;
    } else {&#13;
      //&#13;
      // quicksort as before&#13;
      //&#13;
    }&#13;
  }&#13;
&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="Continued">The lines in bold are all you need to change. Define the cutoff limit, and when sorting, if the array is small enough, apply the alternative sort.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h5 class="H3" id="sec23"><span class="SANS_Futura_Std_Bold_Condensed_B_11">Dual-Pivot Version</span></h5>&#13;
<p class="TNI1">You can extend the idea of splitting an array to be sorted in two parts, separated by a pivot, to splitting the array in three parts, separated by two pivots. This dual-pivot version is usually faster. (Java uses it as its default sorting algorithm for primitive types.) Choose the leftmost and rightmost elements as pivots, as shown in <a href="chapter6.xhtml#fig6-9">Figure 6-9</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig6-9" src="../images/Figure6-9.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 6-9: Dual-pivot sort is like quicksort, but it splits the array in three parts instead of two.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Start by choosing 34 and 14 as pivots, and rearrange the array so that all values less than 14 (12, 9, 4) come first, then 14 itself, then values between 14 and 34 (just 22), then 34, and finally values greater than 34 (60, 56). Each subarray is then sorted again with the same method.</p>&#13;
<p class="TX">The algorithm is similar to a basic quicksort; the main differences are in the selection of pivots and partitioning. For performance reasons, you’ll use the hybrid approach and turn to an insertion sort if the array to be sorted is small enough; for example:</p>&#13;
<pre id="pre-96"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_109" aria-label="109"/>const dualPivot = (arr, left = 0, right = arr.length - 1) =&gt; {&#13;
  if (left &lt; right) {&#13;
    if (right - left &lt; CUTOFF) {&#13;
      insertionSort(arr, left, right);&#13;
    } else {&#13;
      // Choose outermost elements as pivots.&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (arr[left] &gt; arr[right]) {&#13;
        [arr[left], arr[right]] = [arr[right], arr[left]];&#13;
      }&#13;
      const pivotLeft = arr[left];&#13;
      const pivotRight = arr[right];&#13;
&#13;
      let ll = left + 1;&#13;
      let rr = right - 1;&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> for (let mm = ll; mm &lt;= rr; mm++) {&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> if (pivotLeft &gt; arr[mm]) {&#13;
          [arr[mm], arr[ll]] = [arr[ll], arr[mm]];&#13;
          ll++;&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span>} else if (arr[mm] &gt; pivotRight) {&#13;
          while (arr[rr] &gt; pivotRight &amp;&amp; mm &lt; rr) {&#13;
            rr--;&#13;
          }&#13;
          [arr[mm], arr[rr]] = [arr[rr], arr[mm]];&#13;
          rr--;&#13;
&#13;
          if (pivotLeft &gt; arr[mm]) {&#13;
            [arr[mm], arr[ll]] = [arr[ll], arr[mm]];&#13;
            ll++;&#13;
          }&#13;
        }&#13;
      }&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> ll--;&#13;
      rr++;&#13;
      [arr[left], arr[ll]] = [arr[ll], arr[left]];&#13;
      [arr[right], arr[rr]] = [arr[rr], arr[right]];&#13;
&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> dualPivot(arr, left, ll - 1);&#13;
      dualPivot(arr, ll + 1, rr - 1);&#13;
      dualPivot(arr, rr + 1, right);&#13;
    }&#13;
  }&#13;
&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="TX">You’re choosing the leftmost and rightmost elements as pivots, but, of course, you could take any two values and swap them so they end up in the extremes of the array, with the smaller on the left <span class="CodeAnnotation" aria-label="annotation1">❶</span>. (Actually, when dealing with arrays nearly in order, choosing two middle elements is better.) Next, you start swapping elements, maintaining these invariants:</p>&#13;
<ul class="ul">&#13;
<li class="ListBullet"><span class="SANS_TheSansMonoCd_W5Regular_11">pivotLeft</span> is at the left of the array.</li>&#13;
<li class="ListBullet">From positions <span class="SANS_TheSansMonoCd_W5Regular_11">left</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">ll - 1</span>, all values are less than <span class="SANS_TheSansMonoCd_W5Regular_11">pivotLeft</span>.</li>&#13;
<li class="ListBullet"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_110" aria-label="110"/>From positions <span class="SANS_TheSansMonoCd_W5Regular_11">ll</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">mm - 1</span>, all values are strictly between <span class="SANS_TheSansMonoCd_W5Regular_11">pivotLeft</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">pivotRight</span>.</li>&#13;
<li class="ListBullet">From positions <span class="SANS_TheSansMonoCd_W5Regular_11">mm</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">rr</span>, the status of values is yet unknown.</li>&#13;
<li class="ListBullet">From positions <span class="SANS_TheSansMonoCd_W5Regular_11">rr</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">right - 1</span>, the values are greater than <span class="SANS_TheSansMonoCd_W5Regular_11">pivotRight</span>.</li>&#13;
<li class="ListBullet"><span class="SANS_TheSansMonoCd_W5Regular_11">pivotRight</span> is at the right of the array.</li>&#13;
</ul>&#13;
<p class="TX">You can establish this invariant from the beginning by setting <span class="SANS_TheSansMonoCd_W5Regular_11">mm</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">left</span> <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> and making it go up until it reaches the end of the array <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If the element at <span class="SANS_TheSansMonoCd_W5Regular_11">mm</span> is less than <span class="SANS_TheSansMonoCd_W5Regular_11">pivotLeft</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>, a mere swap maintains the invariant. If the element at <span class="SANS_TheSansMonoCd_W5Regular_11">mm</span> is greater than <span class="SANS_TheSansMonoCd_W5Regular_11">pivotRight</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span>, you have to do a bit more work to maintain the invariant, moving <span class="SANS_TheSansMonoCd_W5Regular_11">rr</span> to the left. (Remember, the idea is to keep the invariants; this loop ensures the next-to-last one.) After the loop is done <span class="CodeAnnotation" aria-label="annotation5">❺</span>, swap the pivots to their final places and apply recursion to sort the three partitions <span class="CodeAnnotation" aria-label="annotation6">❻</span>.</p>&#13;
<p class="TX">Quicksort is a great algorithm with several variants, but it always comes with the possibility (albeit remote) of bad performance.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h4 class="H2" id="sec24"><span id="h2-53"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Merging for</span> <span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Performance with Merge Sort</span></h4>&#13;
<p class="TNI1">We’ll wrap up our study of comparison-based sorts with the <i>merge sort</i> algorithm that guarantees a constant performance, but with the cost of a higher need for memory. Merge sort basically does all sorting by merging. If you have two ordered sequences of values, <i>n</i> in total, merging them into a single-order sequence can be done in an <i>O</i>(<i>n</i>) process. The key idea of a merge sort is to apply recursion. First, split the array to be sorted into two halves, then recursively sort each half, and finally merge both ordered halves into a single sequence (see <a href="chapter6.xhtml#fig6-10">Figure 6-10</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig6-10" src="../images/Figure6-10.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 6-10: Merge sort splits the array into two parts, sorts them, and ends by merging them.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Each array to be sorted is split into two parts, which are sorted and then joined back together. To sort an 8-element array, you need to sort two 4-element arrays, which means you have to sort four 2-element arrays, and that requires sorting eight 1-element arrays. Sorting the latter is trivial (nothing to do), and doing the merge reconstructs the original array.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_111" aria-label="111"/>Here’s a recursive implementation:</p>&#13;
<pre id="pre-97"><code>const mergesort = (arr, left = 0, right = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> if (right &gt; left) {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const split = Math.floor((left + right) / 2);&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const arrL = mergesort(arr.slice(left, split + 1));&#13;
    const arrR = mergesort(arr.slice(split + 1, right + 1));&#13;
&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> let ll = 0;&#13;
    let rr = 0;&#13;
    for (let i = left; i &lt;= right; i++) {&#13;
      if (&#13;
        ll !== arrL.length &amp;&amp;&#13;
        (rr === arrR.length || !arrR[ll] &gt; arrL[rr])&#13;
      ) {&#13;
        arr[i] = arrL[ll];&#13;
        ll++;&#13;
      } else {&#13;
        arr[i] = arrR[rr];&#13;
        rr++;&#13;
      }&#13;
    }&#13;
  }&#13;
&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="TX">First, check whether you even need to sort <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which could include a hybrid approach, and if the array is small enough, you’d apply some other method, not merge sort. Then split the array in half <span class="CodeAnnotation" aria-label="annotation2">❷</span> and recursively sort each half <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Next, merge both sorted arrays <span class="CodeAnnotation" aria-label="annotation4">❹</span>: <span class="SANS_TheSansMonoCd_W5Regular_11">ll</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">rr</span> will traverse each array, and the output will go into the original array. Finally, return the sorted array.</p>&#13;
<p class="TX">Merge sort has very good performance (despite the extra space needed to perform the merge), and it’s actually the basis of <i>Tim sort</i>, a stable adaptive method that’s widely used. Java utilizes it, JavaScript also applies it in the V8 engine, and other languages use it as well. We won’t delve into the actual implementation, as the algorithm is quite longer than the ones we’ve been considering (a couple of implementations in GitHub run to almost 1,000 lines each). Tim sort takes advantage of runs of elements that are already in order, merging shorter runs to create longer ones, and applying an insertion sort to make sure runs are long enough. You’ve already studied all the pieces that make up the complete Tim sort algorithm.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>There’s more to learn about comparison-based sorting methods, but we’ll postpone considering more algorithms until we’ve seen some data structures. In <a href="chapter14.xhtml">Chapter 14</a> we’ll explore priority queues and heaps. Likewise, in <a href="chapter12.xhtml">Chapter 12</a> we’ll study binary trees and, in particular, binary search trees. By adding all elements to be sorted into such a structure, you can traverse it in order later, thus producing another sort, although the performance and relative complexity of that solution don’t make it very attractive. Binary search trees are more oriented toward searching; sorting is just a</i> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_112" aria-label="112"/><i>by-product. In the same way, other structures such as skip lists (which we’ll analyze in <a href="chapter11.xhtml">Chapter 11</a>) could also provide a sorting method, but as with binary search trees, sorting isn’t the intended goal.</i></p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h3 class="H1" id="sec25"><span id="h1-27"/><span class="SANS_Futura_Std_Bold_B_11">Sorting Without Comparisons</span></h3>&#13;
<p class="TNI1">In the previous section, all of the sorting algorithms depended on comparing keys and using that information to move, swap, or partition values. But there are other ways to sort. As an example, imagine you’re in charge of customer assistance and receive email for many different reasons. How can you simplify the classification task? You could use a different email address for each category so that messages are automatically sorted into the correct bins for processing.</p>&#13;
<p class="TX">This simple solution provides a glimmer of what we’re going to do. Basically, you won’t compare keys; instead, you’ll use their values to figure out where they should go in the final, ordered list. It’s not always possible, but if you can apply the methods here, performance becomes <i>O</i>(<i>n</i>), which is impossible to beat. After all, no algorithm can sort <i>n</i> values without at least looking at them once, and that’s already an <i>O</i>(<i>n</i>) process. In this section, we’ll consider a couple of methods, <i>bitmap sort</i> and <i>counting sort</i>, and we’ll also look at a very old sorting method, <i>radix sort</i>, whose origins are on par with tabulating machines that used punched cards to do census work.</p>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h4 class="H2" id="sec26"><span id="h2-54"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Bitmap Sort</span></h4>&#13;
<p class="TNI1">Let’s start with a sorting method that has excellent performance but some limitations, if you can live with them. We have to make three suppositions. First, you’re going to sort only numbers on their own (no key + data). Second, you know the possible range of numbers, and it’s not very big. (For instance, if all you knew was that they were 64-bit numbers, the range from lowest to highest numbers would make you forget about attempting this algorithm.) And, third, the numbers are never going to be duplicated; all numbers to sort will be different.</p>&#13;
<p class="TX">With these (too many) restrictions in mind, you can easily use a bitmap. Assume you are starting with all bits turned off, and whenever you read a number, set that bit to on. After you’re done, go through the bits in order, and whenever a bit is set, output the corresponding number, and you’re done (see <a href="chapter6.xhtml#fig6-11">Figure 6-11</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig6-11" src="../images/Figure6-11.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 6-11: Bitmap sort takes advantage of knowing the range of values to be sorted.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_113" aria-label="113"/>You must go through all the numbers to find the minimum and maximum values to define the size of the bitmap. After that, go through the numbers again, setting bits whenever a number appears. In <a href="chapter6.xhtml#fig6-11">Figure 6-11</a>, bits corresponding to numbers 22, 24, 25, 27, 28, and 31 are set. (JavaScript mandates that all arrays start at position 0, so you have to remember that position 0 actually corresponds to key 22, position 1 to key 23, and so on.) Finally, go through the bitmap, outputting the numbers whose bits are set; it’s simple.</p>&#13;
<p class="TX">This algorithm is limited, but it’s the basis for a different, enhanced algorithm. For simplicity, this example will use an array of booleans instead of a bitmap and write the following code:</p>&#13;
<pre id="pre-98"><code>const bitmapSort = (arr, from = 0, to = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const copy = arr.slice(from, to + 1);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const minKey = Math.min(...copy);&#13;
  const maxKey = Math.max(...copy);&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> const bitmap = new Array(maxKey - minKey + 1).fill(false);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> copy.forEach((v) =&gt; {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> if (bitmap[v - minKey]) {&#13;
      throw new Error("Cannot sort... duplicate values");&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span>} else {&#13;
      bitmap[v - minKey] = true;&#13;
    }&#13;
  });&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> let k = from;&#13;
  bitmap.forEach((v, i) =&gt; {&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation8">❽</span> if (v) {&#13;
      arr[k] = i + minKey;&#13;
      k++;&#13;
    }&#13;
  });&#13;
&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="TX">First make a copy of the input array <span class="CodeAnnotation" aria-label="annotation1">❶</span> to simplify the next step, which is determining the minimum and maximum keys <span class="CodeAnnotation" aria-label="annotation2">❷</span>. (This could be done in a single loop a tad more efficiently.) Then create a bitmap array of the right length <span class="CodeAnnotation" aria-label="annotation3">❸</span>, but in reality you’ll be using common booleans, not bits. You need to be careful with indices, because JavaScript’s arrays always start at zero; a bit of index math will be needed to relate keys to array positions. Then go through the input array <span class="CodeAnnotation" aria-label="annotation4">❹</span> and check whether the key already appeared. If so <span class="CodeAnnotation" aria-label="annotation5">❺</span>, there’s a problem. If not <span class="CodeAnnotation" aria-label="annotation6">❻</span>, just mark that the number did appear. Finally, go through the bitmap <span class="CodeAnnotation" aria-label="annotation7">❼</span>, and whenever you find a set flag <span class="CodeAnnotation" aria-label="annotation8">❽</span>, output the corresponding number.</p>&#13;
<p class="TX">Not being able to allow for duplicate keys is a serious limitation, and dealing with numbers only is another; you need to be able to sort elements consisting of a key + data, as in all the other algorithms you’ve explored so far.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_114" aria-label="114"/>&#13;
<h4 class="H2" id="sec27"><span id="h2-55"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Counting Sort</span></h4>&#13;
<p class="TNI1">The previous sort is quite effective but applies in only limited cases. You can make improvements by calculating where each sorted element should go. To do that, you need to count how many times each key appears and then use that information to decide where to place sorted elements in the output array (see <a href="chapter6.xhtml#fig6-12">Figure 6-12</a>).</p>&#13;
<figure class="IMG"><img class="img5" id="fig6-12" src="../images/Figure6-12.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 6-12: Count sort is somewhat similar to bitmap sort, but it can deal with repeated keys.</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In the same way as with bitmap sort, you need to find the minimum and maximum values in the array to be sorted and set up an appropriate array with counters, all initialized to zero. (Again, remember that position 0 corresponds to the minimum key, which is 47 in this case; position 1 corresponds to 48, and so on.) Then go through the array again, incrementing the corresponding counters. After you have all the counts, you can follow an easy procedure to determine where each key goes. For instance, elements with the minimum key (47) start at position 0 of the output array; elements with the next key (48) follow two places later (because there were two 47s) at place 2. Each new key is placed to the right of the previous key, leaving as many empty spaces as needed to place all the previous elements.</p>&#13;
<p class="TX">The implementation for this algorithm follows:</p>&#13;
<pre id="pre-99"><code>const countingSort = (arr, from = 0, to = arr.length - 1) =&gt; {&#13;
<span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> const copy = arr.slice(from, to + 1);&#13;
  const minKey = Math.min(...copy);&#13;
  const maxKey = Math.max(...copy);&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> const count = new Array(maxKey - minKey + 1).fill(0);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> copy.forEach((v) =&gt; count[v – minKey]++);&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> const place = new Array(maxKey - minKey + 1).fill(0);&#13;
<span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> place.forEach((v, i) =&gt; {&#13;
    place[i] = i === 0 ? from : place[i - 1] + count[i - 1];&#13;
  });&#13;
&#13;
<span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> copy.forEach((v) =&gt; {&#13;
    arr[place[v - minKey]] = v;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_115" aria-label="115"/>  <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> place[v – minKey]++;&#13;
  });&#13;
&#13;
  return arr;&#13;
};</code></pre>&#13;
<p class="TX">The first three lines of this algorithm are the same as the bitmap sort <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and you create a copy of the input array and determine the minimum and maximum keys. You then create an array with the counts for all keys (initialized to zero and needing the same kind of index math as in bitmap sort <span class="CodeAnnotation" aria-label="annotation2">❷</span>). Then go through the input data <span class="CodeAnnotation" aria-label="annotation3">❸</span> and increment counts for each key value. Now generate a new array <span class="CodeAnnotation" aria-label="annotation4">❹</span> to calculate the starting place for elements with each key. The minimum key starts at position 0, and each key is a few spaces away from the previous one, according to the count of the previous key <span class="CodeAnnotation" aria-label="annotation5">❺</span>. (For example, if the previous count was 5, you’ll have the new key 5 places away from the first occurrence of the previous key.) Finally, use the <span class="SANS_TheSansMonoCd_W5Regular_11">place</span> array to start positioning sorted elements in their right places <span class="CodeAnnotation" aria-label="annotation6">❻</span>; each time an element goes into the output array, the corresponding place is incremented by 1 <span class="CodeAnnotation" aria-label="annotation7">❼</span> for the next element with the same key.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h4 class="H2" id="sec28"><span id="h2-56"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Radix Sort</span></h4>&#13;
<p class="TNI1">The last sorting algorithm in this chapter is probably the oldest. It was used with Hollerith punch cards (see <a href="chapter6.xhtml#fig6-13">Figure 6-13</a>) when tabulating census data, back in the days when IBM was founded.</p>&#13;
<figure class="IMG"><img class="img1" id="fig6-13" src="../images/Figure6-13.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 6-13: An original Hollerith card (public domain)</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Suppose you have a disordered set of punch cards, numbered in columns 1 to 6, and you want to sort them. Using a <i>classifier</i>, a machine that <span role="doc-pagebreak" epub:type="pagebreak" id="pg_116" aria-label="116"/>processes cards and separates them into bins according to the value on a specific column, you would follow these steps:</p>&#13;
<p class="ListNumberF">	1.	Separate cards into bins according to column 6 and choose cards with a 0, then cards with a 1, and so on, finishing with cards with a 9. You have sorted the cards by the sixth column, but you have to keep working.</p>&#13;
<p class="ListNumber">	2.	Redo the same process, but use column 5. When you pick the cards up, you’ll find that they are sorted by two columns (refer back to the “<span class="listnumber_Xref">Sorting Stability</span>” section on page <span class="Xref">93</span> to understand why).</p>&#13;
<p class="ListNumberL">	3.	Do the process again for columns 4, 3, 2, and 1, in that order, and you’ll end up with a totally sorted deck of cards.</p>&#13;
<p class="TX">You’ll explore this algorithm in more detail in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span> when looking at lists, which will be the way you’ll emulate the bins.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h3 class="H1" id="sec29"><span id="h1-28"/><span class="SANS_Futura_Std_Bold_B_11">Inefficient Sorting Algorithms</span></h3>&#13;
<p class="TNI1">We’ll finish on a not-too-serious note by considering some algorithms that are really inefficient, going from bad to worse. These algorithms are not intended for actual use!</p>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
&#13;
<h4 class="H2" id="sec30"><span id="h2-57"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Stooge Sort</span></h4>&#13;
<p class="TNI1">The name of this algorithm comes from the Three Stooges comedy group, and if you’re familiar with them, its inefficiency will remind you of their antics. The process to sort a list starts by comparing its first and last elements and swapping them (if needed) to ensure the greater one is at the end. Next, it recursively applies Stooge sort to the initial two-thirds of the list, then it sorts the last two-thirds of the list (which ensures that the last third will have the greatest values, in order), and finally, it sorts the first two-thirds of the list again. The number of comparisons needed for <i>n</i> elements satisfies <i>C</i>(<i>n</i>) = 3<i>C</i>(2<i>n</i> / 3) + 1, so the algorithm has a complexity of <i>O</i>(<i>n</i><sup>2.71</sup>), which makes it perform worse than bubble sort, but there’s even worse.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
&#13;
<h4 class="H2" id="sec31"><span id="h2-58"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Slow Sort</span></h4>&#13;
<p class="TNI1">This algorithm was designed as a joke. Rather than divide and conquer, it’s based on “multiply and surrender.” The authors were proud to have found an algorithm worse than any that were previously created. To sort an array with two or more elements, the algorithm first splits it in half, and then it uses recursion to sort each half. Finally, it compares the last element of each half and places it (swapping if needed) at the end of the original array. After doing that, the algorithm proceeds to sort the list with the maximum extracted. The number of comparisons for this algorithm satisfies <i>C</i>(<i>n</i>) = 2<i>C</i>(<i>n</i> / 2) + <i>C</i>(<i>n</i> – 1) + 1, and its time is <i>O</i>(<i>n</i> <sup>log</sup> <i><sup>n</sup></i>). It’s not even polynomial!</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_117" aria-label="117"/>&#13;
<h4 class="H2" id="sec32"><span id="h2-59"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Permutation Sort</span></h4>&#13;
<p class="TNI1">In <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>, you saw how to go forward from one permutation of values to the following one, which suggests an even worse algorithm for sorting a sequence: repeatedly attempting to produce the next permutation of the elements until the algorithm fails because the last permutation was reached and then reversing the sequence. For a random order, this algorithm requires testing on average <i>n</i>! / 2 permutations, which means its time is at least factorial. For almost any size, the algorithm becomes impossible to run because of its running time.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
&#13;
<h4 class="H2" id="sec33"><span id="h2-60"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Bogosort</span></h4>&#13;
<p class="TNI1">The last algorithm derives its name from a portmanteau of the words <i>bogus</i> and <i>sort</i>, and it’s a probabilistic algorithm that sorts its input with probability 1, but without any certainty as to its running time. The idea also has to do with permutations: if the list to be sorted isn’t in order, it shuffles its elements randomly (we’ll look at such algorithms in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>) and tests again. If you were to apply this method to sorting a deck of cards, the logic would be as follows: if the cards are not in order, throw them into the air, pick them up, and check again—the odds of getting it right are 1/52!, so roughly around one in a hundred million million million million million million million million million million million. Not good!</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
&#13;
<h4 class="H2" id="sec34"><span id="h2-61"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">Sleep Sort</span></h4>&#13;
<p class="TNI1">The last sort is specifically meant for JavaScript, and its running time depends on the maximum key to be sorted. It works with numeric keys, and the idea is that if an input key is <i>K</i>, wait <i>K</i> seconds and output its value. After enough time has passed, all values will be output in order:</p>&#13;
<pre id="pre-100"><code>const sleepSort = (arr) =&gt;&#13;
  arr.forEach((v) =&gt; setTimeout(() =&gt; console.log(v), v * 1000));</code></pre>&#13;
<p class="TX">Even if this algorithm seems to work, with a sufficiently large dataset, it may crash (too many timeouts waiting) or fail. The algorithm goes through the list and starts to output numbers—think of processing a list such as 1, 2, 2, 2, . . . , 2, 2, 0, and with enough 2s, the initial 1 may be output before the last 0 is processed.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec35">&#13;
&#13;
<h3 class="H1" id="sec35"><span id="h1-29"/><span class="SANS_Futura_Std_Bold_B_11">Summary</span></h3>&#13;
<p class="TNI1">In this chapter we’ve explored several sorting algorithms with different performance levels. In the next chapter, we’ll touch on a similar subject, the selection problem, which is akin to sorting only part of an array, because instead of getting all elements in order in their proper place, you care only about placing a single element in its final place, not necessarily sorting the whole list.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec36">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_118" aria-label="118"/>&#13;
<h3 class="H1" id="sec36"><span id="h1-30"/><span class="SANS_Futura_Std_Bold_B_11">Questions</span></h3>&#13;
<p class="ListHead"><b>6.1  Forced Reversal</b></p>&#13;
<p class="ListPlainFirst">Suppose you want to order a set of numbers in descending order, but you have a sorting function that sorts only in ascending order with no options whatsoever to change how it works. How can you manage to sort your data as you wish?</p>&#13;
<p class="ListHead"><b>6.2  Only Lower</b></p>&#13;
<p class="ListPlainFirst">Suppose you had a boolean function <span class="SANS_TheSansMonoCd_W5Regular_11">lower(a,b)</span> that returns true if <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> is lower in sorting order than <span class="SANS_TheSansMonoCd_W5Regular_11">b</span> and false otherwise. How can you use it to decide whether <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> is higher in sorting order than <span class="SANS_TheSansMonoCd_W5Regular_11">b</span>? And how can you use it to see whether both keys are equal in order?</p>&#13;
<p class="ListHead"><b>6.3  Testing a Sort Algorithm</b></p>&#13;
<p class="ListPlainFirst">Imagine you’re trying out a new sorting algorithm of your own. How would you test that it actually sorted correctly?</p>&#13;
<p class="ListHead"><b>6.4  Missing ID</b></p>&#13;
<p class="ListPlainFirst">Imagine you got a set of six-digit IDs, but the count is under 1,000,000, so at least one ID is missing. How can you find one?</p>&#13;
<p class="ListHead"><b>6.5  Unmatched One</b></p>&#13;
<p class="ListPlainFirst">Say you have an array with transaction numbers, and each number should appear twice somewhere in the array, but you know there was a mistake, and there’s a single transaction that appears only once. How do you detect it?</p>&#13;
<p class="ListHead"><b>6.6  Sinking Sort</b></p>&#13;
<p class="ListPlainFirst">This is a variant of bubble sort. Instead of starting at the bottom of the array and making higher values bubble to the top, sinking sort starts at the top of the array and makes smaller values sink to the bottom. In terms of performance, it’s the same as bubble sort, but it may be used if you want to find only the <i>k</i> lowest elements of the array, as you’ll see in <span class="listplain_Xref"><a href="chapter7.xhtml">Chapter 7</a></span>. Can you implement sinking sort?</p>&#13;
<p class="ListHead"><b>6.7  Bubble Swap Checking</b></p>&#13;
<p class="ListPlainFirst">Add a test to bubble sort after each pass through the array to exit earlier if no swaps were detected. This test will speed things up if you deal with arrays that were practically in order and just a few swap passes get everything in its place.</p>&#13;
<p class="ListHead"><b>6.8  Inserting Recursively</b></p>&#13;
<p class="ListPlainFirst">Can you implement insertion sort in a recursive way?</p>&#13;
<p class="ListHead"><b>6.9  Stable Shell?</b></p>&#13;
<p class="ListPlainFirst">Is Shell sort stable?</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_119" aria-label="119"/><b>6.10  A Dutch Enhancement</b></p>&#13;
<p class="ListPlainFirst">The Dutch National Flag Problem requires you to arrange an array with elements that are either red, white, or blue, so all red elements come first, followed by all white ones, and finishing with all blue ones, as in the Dutch national flag. Show how you may similarly enhance quicksort’s performance with repeated elements by rearranging the array to be sorted into three parts: all elements less than the pivot, all elements equal to the pivot, and all elements greater than the pivot. The middle part won’t need any further sorting.</p>&#13;
<p class="ListHead"><b>6.11  Simpler Merging?</b></p>&#13;
<p class="ListPlainFirst">When merging halves in merge sort, you wrote the following (look specifically at the text in bold):</p>&#13;
<pre class="pre" id="pre-101"><code>for (let i = left; i &lt;= right; i++) {&#13;
  if (ll !== arrL.length &amp;&amp; (rr === arrR.length || <b>!arrR[ll] &gt; arrL[rr]</b>)) {&#13;
    ...&#13;
  } else {&#13;
    ...&#13;
  }&#13;
}</code></pre>&#13;
<p class="ListContinued">Why is it written that way? You always want to compare using the greater- than operator to be able to easily substitute a function for more complex comparisons, but why not write <span class="SANS_TheSansMonoCd_W5Regular_11">arr[rr]&gt;arr[ll]</span> instead?</p>&#13;
<p class="ListHead"><b>6.12  Try Not to Be Negative</b></p>&#13;
<p class="ListPlainFirst">What happens with radix sort if some numbers are negative? Also, what happens if you have noninteger values? Can you do something about this?</p>&#13;
<p class="ListHead"><b>6.13  Fill It Up!</b></p>&#13;
<p class="ListPlainFirst">In radix sort, imagine you wanted to initialize the buckets array with 10 empty arrays, and you did it as follows:</p>&#13;
<pre class="pre" id="pre-102"><code>const buckets = Array(10).fill(0).map(() =&gt; []);</code></pre>&#13;
<p class="ListContinued">Why wouldn’t the following alternative work?</p>&#13;
<pre class="pre" id="pre-103"><code>const buckets = Array(10).fill([])</code></pre>&#13;
<p class="ListContinued">And what about this other possibility?</p>&#13;
<pre class="pre" id="pre-104"><code>const buckets = Array(10).map(() =&gt; [])</code></pre>&#13;
<p class="ListHead"><b>6.14  What About Letters?</b></p>&#13;
<p class="ListPlainFirst">How would you modify radix sort to work with alphabetical strings?</p>&#13;
</section>&#13;
</section>&#13;
</body></html>