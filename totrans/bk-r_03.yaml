- en: '**2**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2**'
- en: '**NUMERICS, ARITHMETIC, ASSIGNMENT, AND VECTORS**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**数值、算术、赋值和向量**'
- en: '![image](../images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common-01.jpg)'
- en: In its simplest role, R can function as a mere desktop calculator. In this chapter,
    I’ll discuss how to use the software for arithmetic. I’ll also show how to store
    results so you can use them later in other calculations. Then, you’ll learn about
    vectors, which let you handle multiple values at once. Vectors are an essential
    tool in R, and much of R’s functionality was designed with vector operations in
    mind. You’ll examine some common and useful ways to manipulate vectors and take
    advantage of vector-oriented behavior.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，R 可以作为一个普通的桌面计算器。在本章中，我将讨论如何使用软件进行算术运算。我还会展示如何存储结果，以便你可以在其他计算中稍后使用它们。接下来，你将学习向量，它可以让你一次处理多个值。向量是
    R 中的一个重要工具，R 的许多功能设计时都考虑到了向量操作。你将研究一些常见且有用的方式来操作向量，并利用面向向量的行为。
- en: '**2.1 R for Basic Math**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**2.1 R 基础数学**'
- en: All common arithmetic operations and mathematical functionality are ready to
    use at the console prompt. You can perform addition, subtraction, multiplication,
    and division with the symbols `+`, `-`, `*`, and `/`, respectively. You can create
    exponents (also referred to as *powers* or *indices*) using `^`, and you control
    the order of the calculations in a single command using parentheses, `()`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所有常见的算术操作和数学功能都可以在控制台提示符下使用。你可以分别使用符号 `+`、`-`、`*` 和 `/` 执行加法、减法、乘法和除法。你可以使用
    `^` 创建指数（也称为*幂*或*指数*），并通过括号 `()` 控制单个命令中的运算顺序。
- en: '***2.1.1 Arithmetic***'
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***2.1.1 算术运算***'
- en: 'In R, standard mathematical rules apply throughout and follow the usual left-to-right
    order of operations: parentheses, exponents, multiplication, division, addition,
    subtraction (PEMDAS). Here’s an example in the console:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中，标准的数学规则始终适用，并遵循通常的从左到右的运算顺序：括号、指数、乘法、除法、加法、减法（PEMDAS）。这是一个在控制台中的示例：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can find the square root of any non-negative number with the `sqrt` function.
    You simply provide the desired number to `x` as shown here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `sqrt` 函数来计算任何非负数的平方根。只需将期望的数字提供给 `x`，如下所示：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When using R, you’ll often find that you need to translate a complicated arithmetic
    formula into code for evaluation (for example, when replicating a calculation
    from a textbook or research paper). The next examples provide a mathematically
    expressed calculation, followed by its execution in R:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 R 时，你会发现需要将复杂的算术公式转化为代码进行计算（例如，当复制教科书或研究论文中的计算时）。以下示例提供了一个数学表达式的计算，然后是其在
    R 中的执行：
- en: '![image](../images/f0018-01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0018-01.jpg)'
- en: Note that some R expressions require extra parentheses that aren’t present in
    the mathematical expressions. Missing or misplaced parentheses are common causes
    of arithmetic errors in R, especially when dealing with exponents. If the exponent
    is itself an arithmetic calculation, it must always appear in parentheses. For
    example, in the third expression, you need parentheses around `2.25-1/4`. You
    also need to use parentheses if the number being raised to some power is a calculation,
    such as the expression 2^(2+1) in the third example. Note that R considers a negative
    number a calculation because it interprets, for example, `-2` as `-1*2`. This
    is why you also need the parentheses around `-2` in that same expression. It’s
    important to highlight these issues early because they can easily be overlooked
    in large chunks of code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有些 R 表达式需要额外的括号，而这些括号在数学表达式中并不存在。缺少或位置不当的括号是 R 中算术错误的常见原因，尤其是在处理指数时。如果指数本身是一个算术计算，它必须始终放在括号中。例如，在第三个表达式中，你需要在
    `2.25-1/4` 周围加上括号。如果要对某个数进行幂运算，而这个数本身是一个计算结果，像第三个例子中的表达式 `2^(2+1)`，你也需要使用括号。请注意，R
    将负数视为一个计算，因为它会将 `-2` 解释为 `-1*2`。这就是为什么在这个表达式中你也需要将 `-2` 放入括号的原因。强调这些问题很重要，因为它们在大量代码中很容易被忽视。
- en: '***2.1.2 Logarithms and Exponentials***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***2.1.2 对数与指数***'
- en: 'You’ll often see or read about researchers performing a *log transformation*
    on certain data. This refers to rescaling numbers according to the *logarithm*.
    When supplied a given number *x* and a value referred to as a *base*, the logarithm
    calculates the power to which you must raise the base to get to *x*. For example,
    the logarithm of *x* = 243 to base 3 (written mathematically as log[3] 243) is
    5, because 3⁵ = 243\. In R, the log transformation is achieved with the `log`
    function. You supply `log` with the number to transform, assigned to the value
    `x`, and the base, assigned to `base`, as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你会经常看到或阅读到研究人员对某些数据进行*对数变换*。这意味着根据*对数*重新缩放数字。当给定一个数字*x*和一个被称为*底数*的值时，对数计算出必须将底数提升到哪个幂才能得到*x*。例如，*x*
    = 243以3为底的对数（数学上写作log[3] 243）为5，因为3⁵ = 243。在R中，对数变换通过`log`函数实现。你提供`log`函数需要变换的数字，赋值给`x`，以及底数，赋值给`base`，如下所示：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here are some things to consider:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要考虑的事项：
- en: • Both *x* and the base must be positive.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: • *x*和底数都必须是正数。
- en: • The log of any number *x* when the base is equal to *x* is 1.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: • 当底数为*x*时，任意数*x*的对数结果为1。
- en: • The log of *x* = 1 is always 0, regardless of the base.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: • 对于*x* = 1的对数结果永远是0，不论底数是什么。
- en: There’s a particular kind of log transformation often used in mathematics called
    the *natural log*, which fixes the base at a special mathematical number—*Euler’s
    number*. This is conventionally written as *e* and is approximately equal to 2.718.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中有一种特别的对数变换，称为*自然对数*，它将底数固定为一个特殊的数学常数——*欧拉数*。这个数通常表示为*e*，约等于2.718。
- en: 'Euler’s number gives rise to the *exponential function*, defined as *e* raised
    to the power of *x*, where *x* can be any number (negative, zero, or positive).
    The exponential function, *f*(*x*) = *e*^x, is often written as exp(*x*) and represents
    the *inverse* of the natural log such that exp(log[*e*] *x*) = log[*e*] exp(*x*)
    = *x*. The R command for the exponential function is `exp`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉数引出了*指数函数*，其定义为*e*的*x*次方，其中*x*可以是任何数（负数、零或正数）。指数函数*f*(*x*) = *e*^x，通常写作exp(*x*)，表示自然对数的*逆*，使得exp(log[*e*]
    *x*) = log[*e*] exp(*x*) = *x*。指数函数的R命令是`exp`：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The default behavior of `log` is to assume the natural log:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`log`的默认行为是默认使用自然对数：'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You must provide the value of `base` yourself if you want to use a value other
    than *e*. The logarithm and exponential functions are mentioned here because they
    become important later on in the book—many statistical methods use them because
    of their various helpful mathematical properties.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用除了*e*以外的其他底数，必须自己提供`base`的值。这里提到对数和指数函数，因为它们在本书后面非常重要——许多统计方法使用它们，因为它们具有多种有用的数学性质。
- en: '***2.1.3 E-Notation***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***2.1.3 E-表示法***'
- en: 'When R prints large or small numbers beyond a certain threshold of significant
    figures, set at 7 by default, the numbers are displayed using the classic scientific
    e-notation. The e-notation is typical to most programming languages—and even many
    desktop calculators—to allow easier interpretation of extreme values. In e-notation,
    any number *x* can be expressed as *x*e*y*, which represents exactly *x* × 10^(*y*).
    Consider the number 2,342,151,012,900\. It could, for example, be represented
    as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当R打印出超出某个有效数字阈值（默认设置为7）的非常大或非常小的数字时，这些数字将以经典的科学计数法表示。E表示法是大多数编程语言——甚至许多桌面计算器——所使用的，用以便于理解极端值。在E表示法中，任何数字*x*都可以表示为*x*e*y*，它等于*x*
    × 10^(*y*)。考虑数字2,342,151,012,900。例如，它可以表示为：
- en: • 2.3421510129e12, which is equivalent to writing 2.3421510129 × 10^(12)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: • 2.3421510129e12，相当于写作2.3421510129 × 10^(12)
- en: • 234.21510129e10, which is equivalent to writing 234.21510129 × 10^(10)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: • 234.21510129e10，相当于写作234.21510129 × 10^(10)
- en: 'You could use any value for the power of *y*, but standard e-notation uses
    the power that places a decimal just after the first significant digit. Put simply,
    for a *positive* power +*y*, the e-notation can be interpreted as “move the decimal
    point *y* positions to the *right*.” For a *negative* power −*y*, the interpretation
    is “move the decimal point *y* positions to the *left*.” This is exactly how R
    presents e-notation:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为*y*的幂使用任何值，但标准的E表示法使用将小数点放在第一个有效数字后面的幂。简单来说，对于*正*的幂+*y*，E表示法可以解释为“将小数点向*右*移动*y*位”。对于*负*的幂−*y*，解释为“将小数点向*左*移动*y*位”。这正是R如何呈现E表示法的方式：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the first example, R shows only the first seven significant digits and hides
    the rest. Note that no information is lost in any calculations even if R hides
    digits; the e-notation is purely for ease of readability by the user, and the
    extra digits are still stored by R, even though they aren’t shown.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，R 只显示前七位有效数字，并隐藏其余部分。请注意，即使 R 隐藏了数字，计算过程中并不会丢失任何信息；e-表示法仅仅是为了方便用户阅读，额外的数字仍然被
    R 存储，即使它们没有显示出来。
- en: Finally, note that R must impose constraints on how extreme a number can be
    before it is treated as either infinity (for large numbers) or zero (for small
    numbers). These constraints depend on your individual system, and I’ll discuss
    the technical details a bit more in [Section 6.1.1](ch06.xhtml#ch06lev2sec55).
    However, any modern desktop system can be trusted to be precise enough by default
    for most computational and statistical endeavors in R.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意 R 必须对数字的极限值施加约束，才能将其视为无穷大（对于大数字）或零（对于小数字）。这些约束取决于你的具体系统，我将在[第 6.1.1 节](ch06.xhtml#ch06lev2sec55)中详细讨论技术细节。然而，任何现代桌面系统默认情况下都可以被认为足够精确，能够满足大多数
    R 中的计算和统计需求。
- en: '**Exercise 2.1**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 2.1**'
- en: Using R, verify that
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 R，验证以下内容
- en: '![image](../images/f0021-01.jpg)'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0021-01.jpg)'
- en: when *a* = 2.3.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当 *a* = 2.3 时。
- en: Which of the following squares negative 4 and adds 2 to the result?
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个选项是将负 4 平方并加 2 到结果？
- en: '`(-4)^2+2`'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`(-4)^2+2`'
- en: '`-4^2+2`'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-4^2+2`'
- en: '`(-4)^(2+2)`'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`(-4)^(2+2)`'
- en: '`-4^(2+2)`'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-4^(2+2)`'
- en: Using R, how would you calculate the square root of half of the average of the
    numbers 25.2, 15, 16.44, 15.3, and 18.6?
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 R，你如何计算数字 25.2、15、16.44、15.3 和 18.6 的平均值的一半的平方根？
- en: Find log[*e*] 0.3.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 log[*e*] 0.3。
- en: Compute the exponential transform of your answer to (d).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算你在 (d) 中的答案的指数变换。
- en: Identify R’s representation of −0.00000000423546322 when printing this number
    to the console.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中打印时，识别 R 如何表示 −0.00000000423546322 这个数字。
- en: '**2.2 Assigning Objects**'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**2.2 赋值对象**'
- en: So far, R has simply displayed the results of the example calculations by printing
    them to the console. If you want to save the results and perform further operations,
    you need to be able to *assign* the results of a given computation to an *object*
    in the current workspace. Put simply, this amounts to storing some item or result
    under a given name so it can be accessed later, without having to write out that
    calculation again. In this book, I will use the terms *assign* and *store* interchangeably.
    Note that some programming books refer to a stored object as a *variable* because
    of the ability to easily overwrite that object and change it to something different,
    meaning that what it represents can vary throughout a session. However, I’ll use
    the term *object* throughout this book because we’ll discuss variables in [Part
    III](part03.xhtml#part03) as a distinctly different statistical concept.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，R 仅通过将计算结果打印到控制台来展示示例计算结果。如果你想保存结果并进行进一步操作，你需要能够将给定计算的结果*赋值*给当前工作空间中的一个*对象*。简单来说，这意味着将某个项或结果存储在给定的名称下，以便稍后访问，而不必重新计算这个结果。在本书中，我将交替使用*赋值*和*存储*这两个术语。请注意，有些编程书籍将存储的对象称为*变量*，因为可以轻松地覆盖该对象并将其更改为其他内容，这意味着它所代表的内容可能在整个会话中发生变化。然而，我将在本书中使用*对象*这个术语，因为我们将在[第三部分](part03.xhtml#part03)讨论变量作为一个截然不同的统计学概念。
- en: 'You can specify an assignment in R in two ways: using arrow notation (`<-`)
    and using a single equal sign (`=`). Both methods are shown here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式在 R 中指定赋值：使用箭头符号（`<-`）和使用单个等号符号（`=`）。这两种方法在这里都展示了：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see from these examples, R will display the value assigned to an
    object when you enter the name of the object into the console. When you use the
    object in subsequent operations, R will substitute the value you assigned to it.
    Finally, if you use the `ls` command (which you saw in [Section 1.3.1](ch01.xhtml#ch01lev2sec12))
    to examine the contents of the current workspace, it will reveal the names of
    the objects in alphabetical order (along with any other previously created items).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从这些示例中看到的，当你将对象的名称输入到控制台时，R 会显示分配给该对象的值。当你在后续操作中使用该对象时，R 会替代你分配给它的值。最后，如果你使用
    `ls` 命令（你在[第 1.3.1 节](ch01.xhtml#ch01lev2sec12)中看到过）检查当前工作空间的内容，它将按字母顺序显示对象的名称（以及其他任何先前创建的项目）。
- en: Although `=` and `<-` do the same thing, it is wise (for the neatness of code
    if nothing else) to be consistent. Many users choose to stick with the `<-`, however,
    because of the potential for confusion in using the `=` (for example, I clearly
    didn’t mean that *x* is *mathematically* equal to *x* + 1 earlier). In this book,
    I’ll do the same and reserve `=` for setting function arguments, which begins
    in [Section 2.3.2](ch02.xhtml#ch02lev2sec21). So far you’ve used only numeric
    values, but note that the procedure for assignment is universal for all types
    and classes of objects, which you’ll examine in the coming chapters.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`=`和`<-`执行相同的操作，但为了代码的整洁（至少在这方面），保持一致性是明智的。许多用户选择坚持使用`<-`，因为使用`=`可能会引起混淆（例如，之前我显然不是想说*x*在*数学上*等于*x*
    + 1）。在本书中，我也会这样做，并将`=`保留用于设置函数参数，这将在[第2.3.2节](ch02.xhtml#ch02lev2sec21)中开始讲解。到目前为止，你只使用了数字值，但请注意，赋值的过程对于所有类型和类的对象都是通用的，接下来的章节中你将进一步探讨这些内容。
- en: Objects can be named almost anything as long as the name begins with a letter
    (in other words, not a number), avoids symbols (though underscores and periods
    are fine), and avoids the handful of “reserved” words such as those used for defining
    special values (see [Section 6.1](ch06.xhtml#ch06lev1sec21)) or for controlling
    code flow (see [Chapter 10](ch10.xhtml#ch10)). You can find a useful summary of
    these naming rules in [Section 9.1.2](ch09.xhtml#ch09lev2sec80).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的命名几乎没有限制，只要名称以字母开头（换句话说，不能以数字开头），避免使用符号（不过下划线和句点是可以的），并避免使用一些“保留”词汇，例如用于定义特殊值的词汇（见[第6.1节](ch06.xhtml#ch06lev1sec21)）或用于控制代码流的词汇（见[第10章](ch10.xhtml#ch10)）。你可以在[第9.1.2节](ch09.xhtml#ch09lev2sec80)找到这些命名规则的有用总结。
- en: '**Exercise 2.2**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 2.2**'
- en: Create an object that stores the value 3² × 4^(1/8).
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个存储值为3² × 4^(1/8)的对象。
- en: Overwrite your object in (a) by itself divided by 2.33\. Print the result to
    the console.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用(a)中的对象除以2.33来覆盖该对象。将结果打印到控制台。
- en: Create a new object with the value −8.2 × 10^(−13).
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个值为−8.2 × 10^(−13)的新对象。
- en: Print directly to the console the result of multiplying (b) by (c).
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接在控制台打印将(b)乘以(c)的结果。
- en: '**2.3 Vectors**'
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**2.3 向量**'
- en: Often you’ll want to perform the same calculations or comparisons upon multiple
    entities, for example if you’re rescaling measurements in a data set. You could
    do this type of operation one entry at a time, though this is clearly not ideal,
    especially if you have a large number of items. R provides a far more efficient
    solution to this problem with *vectors*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你会希望对多个实体执行相同的计算或比较，例如当你需要重新缩放数据集中的测量值时。你可以逐个条目进行操作，尽管这样显然不理想，尤其是当你有大量条目时。R提供了一个更高效的解决方案——*向量*。
- en: For the moment, to keep things simple, you’ll continue to work with numeric
    entries only, though many of the utility functions discussed here may also be
    applied to structures containing non-numeric values. You’ll start looking at these
    other kinds of data in [Chapter 4](ch04.xhtml#ch04).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为了简化问题，你将继续只处理数字条目，尽管这里讨论的许多实用函数也可以应用于包含非数字值的结构。你将在[第4章](ch04.xhtml#ch04)开始查看这些其他类型的数据。
- en: '***2.3.1 Creating a Vector***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***2.3.1 创建一个向量***'
- en: The vector is the essential building block for handling multiple items in R.
    In a numeric sense, you can think of a vector as a collection of observations
    or measurements concerning a single variable, for example, the heights of 50 people
    or the number of coffees you drink daily. More complicated data structures may
    consist of several vectors. The function for creating a vector is the single letter
    `c`, with the desired entries in parentheses separated by commas.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是R中处理多个项目的基本构件。从数字的角度来看，你可以把向量看作是关于单一变量的观察值或测量值的集合，例如50个人的身高或你每天喝的咖啡数量。更复杂的数据结构可能由多个向量组成。创建向量的函数是单个字母`c`，所需条目放在括号内，条目之间用逗号分隔。
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Vector entries can be calculations or previously stored items (including vectors
    themselves).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 向量条目可以是计算结果或先前存储的项目（包括向量本身）。
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code created a new vector assigned to the object `myvec2`. Some of the
    entries are defined as arithmetic expressions, and it’s the result of the expression
    that’s stored in the vector. The last element, `foo`, is an existing numeric object
    defined as `32.1`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个新向量并赋值给对象`myvec2`。其中一些条目被定义为算术表达式，存储在向量中的则是表达式的结果。最后一个元素`foo`是一个已定义的数字对象，其值为`32.1`。
- en: Let’s look at another example.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一个新的例子。
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code creates and stores yet another vector, `myvec3`, which contains the
    entries of `myvec` and `myvec2` appended together in that order.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建并存储了另一个向量`myvec3`，它包含了`myvec`和`myvec2`的条目，按顺序连接在一起。
- en: '***2.3.2 Sequences, Repetition, Sorting, and Lengths***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***2.3.2 序列、重复、排序和长度***'
- en: 'Here I’ll discuss some common and useful functions associated with R vectors:
    `seq`, `rep`, `sort`, and `length`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将讨论一些与R向量相关的常见和有用的函数：`seq`、`rep`、`sort`和`length`。
- en: Let’s create an equally spaced sequence of increasing or decreasing numeric
    values. This is something you’ll need often, for example when programming loops
    (see [Chapter 10](ch10.xhtml#ch10)) or when plotting data points (see [Chapter
    7](ch07.xhtml#ch07)). The easiest way to create such a sequence, with numeric
    values separated by intervals of 1, is to use the colon operator.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个均匀间隔的递增或递减数值序列。这是您在编程循环时（见[第10章](ch10.xhtml#ch10)）或绘制数据点时（见[第7章](ch07.xhtml#ch07)）常常需要的功能。创建此类序列最简单的方法是使用冒号操作符，将数值按间隔1分隔。
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The example `3:27` should be read as “from 3 to 27 (by 1).” The result is a
    numeric vector just as if you had listed each number manually in parentheses with
    `c`. As always, you can also provide either a previously stored value or a (strictly
    parenthesized) calculation when using the colon operator:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 示例`3:27`应理解为“从3到27（步长为1）”。结果是一个数字向量，就像您手动列出每个数字并用`c`括起来一样。像往常一样，您也可以在使用冒号操作符时提供先前存储的值或（严格的）括号计算：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Sequences with seq**'
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用seq生成序列**'
- en: You can also use the `seq` command, which allows for more flexible creations
    of sequences. This ready-to-use function takes in a `from` value, a `to` value,
    and a `by` value, and it returns the corresponding sequence as a numeric vector.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`seq`命令，它允许您更灵活地创建序列。这个现成的函数接收一个`from`值，一个`to`值，以及一个`by`值，然后返回相应的序列，作为一个数字向量。
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This gives you a sequence with intervals of 3 rather than 1\. Note that these
    kinds of sequences will always start at the `from` number but will not always
    include the `to` number, depending on what you are asking R to increase (or decrease)
    them `by`. For example, if you are increasing (or decreasing) by even numbers
    and your sequence ends in an odd number, the final number won’t be included. Instead
    of providing a `by` value, however, you can specify a `length.out` value to produce
    a vector with that many numbers, evenly spaced between the `from` and `to` values.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您提供一个间隔为3而不是1的序列。请注意，这类序列将始终从`from`数字开始，但是否包含`to`数字取决于您要求R按什么方式增加（或减少）它们。例如，如果您按偶数增加（或减少），且序列以奇数结尾，则最后一个数字将不会被包含。然而，您可以通过指定`length.out`值来生成一个具有该数量数字的向量，这些数字在`from`和`to`值之间均匀分布。
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By setting `length.out` to `40`, you make the program print exactly 40 evenly
    spaced numbers from 3 to 27.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`length.out`设置为`40`，您可以让程序从3到27打印出恰好40个均匀间隔的数字。
- en: 'For decreasing sequences, the use of `by` must be negative. Here’s an example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于递减序列，`by`的值必须为负。这里是一个例子：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code uses the previously stored object `foo` as the value for `from` and
    uses the parenthesized calculation `(-47+1.5)` as the `to` value. Given those
    values (that is, with `foo` being greater than `(-47+1.5)`), the sequence can
    progress only in negative steps; directly above, we set `by` to be `-2.4`. The
    use of `length.out` to create decreasing sequences, however, remains the same
    (it would make no sense to specify a “negative length”). For the same `from` and
    `to` values, you can create a decreasing sequence of length 5 easily, as shown
    here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用先前存储的对象`foo`作为`from`的值，并使用括号中的计算`(-47+1.5)`作为`to`的值。给定这些值（即`foo`大于`(-47+1.5)`），序列只能按负数步长递进；在上面，我们将`by`设置为`-2.4`。然而，使用`length.out`来创建递减序列的方式保持不变（指定“负长度”是没有意义的）。对于相同的`from`和`to`值，您可以轻松创建一个长度为5的递减序列，如下所示：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There are shorthand ways of calling these functions, which you’ll learn about
    in [Chapter 9](ch09.xhtml#ch09), but in these early stages I’ll stick with the
    explicit usage.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些简化的调用方式，您将在[第9章](ch09.xhtml#ch09)中学到这些，但在这些早期阶段，我将坚持使用显式的用法。
- en: '**Repetition with rep**'
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用rep进行重复**'
- en: Sequences are extremely useful, but sometimes you may want simply to repeat
    a certain value. You do this using `rep`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 序列非常有用，但有时您可能只想重复某个特定值。您可以使用`rep`来做到这一点。
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `rep` function is given a single value or a vector of values as its argument
    `x`, as well as a value for the arguments `times` and `each`. The value for `times`
    provides the number of times to repeat `x`, and `each` provides the number of
    times to repeat each element of `x`. In the first line directly above, you simply
    repeat a single value four times. The other examples first use `rep` and `times`
    on a vector to repeat the entire vector, then use `each` to repeat each member
    of the vector, and finally use both `times` and `each` to do both at once.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`rep`函数接受一个单一值或一个值的向量作为参数`x`，并且需要提供`times`和`each`的值。`times`的值指定重复`x`的次数，而`each`指定重复`x`中每个元素的次数。在上面的第一行，你仅仅是将一个值重复四次。其他例子首先使用`rep`和`times`对一个向量进行重复整个向量的操作，然后使用`each`重复向量中每个元素，最后同时使用`times`和`each`一次性完成两者操作。'
- en: If neither `times` nor `each` is specified, R’s default is to treat the values
    of `times` and `each` as `1` so that a call of `rep(x=c(3,62,8.3))` will just
    return the originally supplied `x` with no changes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定`times`或`each`，R的默认行为是将`times`和`each`的值视为`1`，因此调用`rep(x=c(3,62,8.3))`时，返回的将是原始的`x`，没有任何变化。
- en: 'As with `seq`, you can include the result of `rep` in a vector of the same
    data type, as shown in the following example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与`seq`一样，你可以将`rep`的结果包含在相同数据类型的向量中，如下例所示：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, I’ve constructed a vector where the third to sixth entries (inclusive)
    are governed by the evaluation of a `rep` command—the single value `32 rep`eated
    `foo` times (where `foo` is stored as `4`). The last five entries are the result
    of an evaluation of `seq`, namely a sequence from −2 to 1 of length `foo+1` (5).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我构建了一个向量，其中第三到第六个条目（包含在内）由`rep`命令的计算结果决定——单一值`32`被重复`foo`次（其中`foo`的值为4）。最后五个条目是`seq`的计算结果，即从−2到1的序列，长度为`foo+1`（5）。
- en: '**Sorting with sort**'
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用sort进行排序**'
- en: Sorting a vector in increasing or decreasing order of its elements is another
    simple operation that crops up in everyday tasks. The conveniently named `sort`
    function does just that.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对一个向量进行升序或降序排序是日常任务中的另一个简单操作。便捷的`sort`函数正是用来做这件事的。
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `sort` function is pretty straightforward. You supply a vector to the function
    as the argument `x`, and a second argument, `decreasing`, indicates the order
    in which you want to sort. This argument takes a type of value you have not yet
    met: one of the all-important *logical* values. A logical value can be only one
    of two specific, case-sensitive values: `TRUE` or `FALSE`. Generally speaking,
    logicals are used to indicate the satisfaction or failure of a certain *condition*,
    and they form an integral part of all programming languages. You’ll investigate
    logical values in R in greater detail in [Section 4.1](ch04.xhtml#ch04lev1sec16).
    For now, in regards to `sort`, you set `decreasing=FALSE` to sort from smallest
    to largest, and `decreasing=TRUE` sorts from largest to smallest.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`函数非常简单。你将一个向量作为参数`x`传入该函数，第二个参数`decreasing`表示你希望排序的顺序。这个参数使用了一种你之前没有遇到过的类型：即重要的*逻辑*值。逻辑值只能是两个特定的、区分大小写的值之一：`TRUE`或`FALSE`。一般来说，逻辑值用于指示某个*条件*是否满足，并且是所有编程语言的重要组成部分。你将在[R
    语言第四章第1节](ch04.xhtml#ch04lev1sec16)中详细学习逻辑值。现在，关于`sort`，你可以将`decreasing=FALSE`设为从小到大排序，而`decreasing=TRUE`则是从大到小排序。'
- en: '**Finding a Vector Length with length**'
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用length查找向量长度**'
- en: I’ll round off this section with the `length` function, which determines how
    many entries exist in a vector given as the argument `x`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过`length`函数来总结这一部分，`length`函数用于确定作为参数`x`传入的向量中存在多少条目。
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that if you include entries that depend on the evaluation of other functions
    (in this case, calls to `rep` and `seq`), `length` tells you the number of entries
    *after* those inner functions have been executed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你包含依赖于其他函数计算结果的条目（在此案例中，调用了`rep`和`seq`），`length`会告诉你在这些内置函数执行**后**的条目数。
- en: '**Exercise 2.3**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习2.3**'
- en: Create and store a sequence of values from 5 to −11 that progresses in steps
    of 0.3.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并存储一个从5到−11的数值序列，步长为0.3。
- en: Overwrite the object from (a) using the same sequence with the order reversed.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相反顺序的相同序列覆盖（a）中的对象。
- en: Repeat the vector `c(-1,3,-5,7,-9)` twice, with each element repeated 10 times,
    and store the result. Display the result sorted from largest to smallest.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将向量`c(-1,3,-5,7,-9)`重复两次，每个元素重复10次，并存储结果。然后将结果按从大到小排序并显示。
- en: 'Create and store a vector that contains, in any configuration, the following:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并存储一个包含以下内容的向量，无论其配置如何：
- en: A sequence of integers from 6 to 12 (inclusive)
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从6到12（包含12）的整数序列
- en: A threefold repetition of the value 5.3
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值5.3的三重重复
- en: The number −3
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数字−3
- en: A sequence of nine values starting at 102 and ending at the number that is the
    total length of the vector created in (c)
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从102开始，到在（c）中创建的向量的总长度为止，共九个值的序列
- en: Confirm that the length of the vector created in (d) is 20.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认在（d）中创建的向量的长度为20。
- en: '***2.3.3 Subsetting and Element Extraction***'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***2.3.3 子集和元素提取***'
- en: In all the results you have seen printed to the console screen so far, you may
    have noticed a curious feature. Immediately to the left of the output there is
    a square-bracketed `[1]`. When the output is a long vector that spans the width
    of the console and wraps onto the following line, another square-bracketed number
    appears to the left of the new line. These numbers represent the *index* of the
    entry directly to the right. Quite simply, the index corresponds to the *position*
    of a value within a vector, and that’s precisely why the first value always has
    a `[1]` next to it (even if it’s the only value and not part of a larger vector).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在你到目前为止在控制台屏幕上看到的所有结果中，你可能注意到一个奇怪的特征。在输出的左侧紧挨着有一个方括号中的`[1]`。当输出是一个较长的向量，跨越了控制台的宽度并换行时，新的方括号中的数字会出现在新的一行左侧。这些数字表示直接右侧条目的*索引*。简单来说，索引对应于一个值在向量中的*位置*，这就是为什么第一个值旁边总是有一个`[1]`（即使它是唯一的值，不是更大向量的一部分）。
- en: 'These indexes allow you to retrieve specific elements from a vector, which
    is known as *subsetting*. Suppose you have a vector called `myvec` in your workspace.
    Then there will be exactly `length(x=myvec)` entries in `myvec`, with each entry
    having a specific position: `1` or `2` or `3`, all the way up to `length(x=myvec)`.
    You can access individual elements by asking R to return the values of `myvec`
    at specific locations, done by entering the name of the vector followed by the
    position in square brackets.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些索引允许你从一个向量中提取特定的元素，这被称为*子集提取*。假设你在工作区有一个名为`myvec`的向量。那么`myvec`中将会有`length(x=myvec)`个条目，每个条目有一个特定的位置：`1`、`2`、`3`，一直到`length(x=myvec)`。你可以通过让R返回`myvec`在特定位置的值来访问单个元素，这通过输入向量的名称并在后面跟上方括号中的位置来完成。
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Because `length(x=myvec)` results in the final index of the vector (in this
    case, `10`), entering this phrase in the square brackets extracts the final element,
    `-8`. Similarly, you could extract the second-to-last element by subtracting 1
    from the length; let’s try that, and also assign the result to a new object:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`length(x=myvec)`给出了向量的最终索引（在这个例子中是`10`），在方括号中输入这个短语会提取最后一个元素`-8`。同样，你可以通过从长度中减去1来提取倒数第二个元素；我们来尝试一下，并将结果赋值给一个新对象：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As these examples show, the index may be an arithmetic function of other numbers
    or previously stored values. You can assign the result to a new object in your
    workspace in the usual way with the `<-` notation. Using your knowledge of sequences,
    you can use the colon notation with the length of the specific vector to obtain
    all possible indexes for extracting a particular element in the vector:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这些例子所示，索引可能是其他数字或之前存储值的算术函数。你可以像平常一样使用`<-`符号将结果赋值给工作区中的新对象。利用你对序列的了解，你可以使用冒号符号和特定向量的长度来获得所有可能的索引，以提取向量中的特定元素：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can also delete individual elements by using *negative* versions of the
    indexes supplied in the square brackets. Continuing with the objects `myvec`,
    `foo`, `bar`, and `myvec.len` as defined earlier, consider the following operations:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用方括号中提供的索引的*负数*版本来删除单个元素。继续使用前面定义的对象`myvec`、`foo`、`bar`和`myvec.len`，请考虑以下操作：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This line produces the contents of `myvec` without the first element. Similarly,
    the following code assigns to the object `baz` the contents of `myvec` without
    its second element:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行生成了不包含第一个元素的`myvec`内容。同样，以下代码将`myvec`中不包含第二个元素的内容赋值给对象`baz`：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Again, the index in the square brackets can be the result of an appropriate
    calculation, like so:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，方括号中的索引也可以是一个适当计算的结果，如下所示：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using the square-bracket operator to extract or delete values from a vector
    does not change the original vector you are subsetting *unless* you explicitly
    overwrite the vector with the subsetted version. For instance, in this example,
    `qux` is a new vector defined as `myvec` without its second-to-last entry, but
    in your workspace, `myvec` itself *remains unchanged*. In other words, subsetting
    vectors in this way simply returns the requested elements, which can be assigned
    to a new object if you want, but doesn’t alter the original object in the workspace.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方括号操作符来提取或删除向量中的值，并不会改变你正在子集化的原始向量，*除非*你显式地用子集化后的版本覆盖该向量。例如，在这个例子中，`qux`是一个新向量，定义为`myvec`去掉倒数第二个条目，但在你的工作空间中，`myvec`本身*保持不变*。换句话说，以这种方式对子集化向量仅仅返回请求的元素，如果你想的话可以将它们分配给一个新对象，但不会改变工作空间中的原始对象。
- en: 'Now, suppose you want to piece `myvec` back together from `qux` and `bar`.
    You can call something like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想通过`qux`和`bar`将`myvec`重新拼接在一起。你可以调用类似这样的代码：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, this line uses `c` to reconstruct the vector in three parts:
    `qux[-length(x=qux)]`, the object `bar` defined earlier, and `qux[length(x=qux)]`.
    For clarity, let’s examine each part in turn.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这行代码使用`c`将向量分成三部分来重构：`qux[-length(x=qux)]`，之前定义的`bar`对象，以及`qux[length(x=qux)]`。为了清晰起见，我们依次查看每一部分。
- en: • `qux[-length(x=qux)]`
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: • `qux[-length(x=qux)]`
- en: This piece of code returns the values of `qux` except for its last element.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码返回了`qux`的值，除了它的最后一个元素。
- en: R> length(x=qux)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: R> length(x=qux)
- en: '[1] 9'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 9'
- en: R> qux[-length(x=qux)]
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: R> qux[-length(x=qux)]
- en: '[1]  5.0 -2.3  4.0  4.0  4.0  6.0  8.0 10.0'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[1]  5.0 -2.3  4.0  4.0  4.0  6.0  8.0 10.0'
- en: Now you have a vector that’s the same as the first eight entries of `myvec`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个与`myvec`的前八个条目相同的向量。
- en: • `bar`
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: • `bar`
- en: 'Earlier, you had stored `bar` as the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你已经将`bar`存储为以下内容：
- en: R> bar <- myvec[myvec.len-1]
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: R> bar <- myvec[myvec.len-1]
- en: R> bar
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: R> bar
- en: '[1] 40221'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] 40221'
- en: This is precisely the second-to-last element of `myvec` that `qux` is missing.
    So, you’ll slot this value in after `qux[-length(x=qux)]`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是`myvec`中`qux`缺少的倒数第二个元素。因此，你将把这个值插入到`qux[-length(x=qux)]`之后。
- en: • `qux[length(x=qux)]`
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: • `qux[length(x=qux)]`
- en: Finally, you just need the last element of `qux` that matches the last element
    of `myvec`. This is extracted from `qux` (not deleted as earlier) using `length`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你只需要`qux`的最后一个元素，它与`myvec`的最后一个元素匹配。这是通过`length`从`qux`中提取的（不像之前那样删除）。
- en: R> qux[length(x=qux)]
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: R> qux[length(x=qux)]
- en: '[1] -8'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] -8'
- en: Now it should be clear how calling these three parts of code together, in this
    order, is one way to reconstruct `myvec`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该清楚了，如何通过按此顺序调用这三部分代码来重构`myvec`。
- en: 'As with most operations in R, you are not restricted to doing things one by
    one. You can also subset objects using *vectors of indexes*, rather than individual
    indexes. Using `myvec` again from earlier, you get the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与R中的大多数操作一样，你不必逐一进行操作。你还可以使用*索引向量*来子集化对象，而不是单个索引。再次使用之前的`myvec`，你可以得到以下结果：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This returns the first, third, and fifth elements of `myvec` in one go. Another
    common and convenient subsetting tool is the colon operator (discussed in [Section
    2.3.2](ch02.xhtml#ch02lev2sec21)), which creates a sequence of indexes. Here’s
    an example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次返回了`myvec`的第一个、第三个和第五个元素。另一个常见且方便的子集化工具是冒号操作符（在[第2.3.2节](ch02.xhtml#ch02lev2sec21)中讨论），它用于创建索引序列。这里是一个例子：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This provides the first four elements of `myvec` (recall that the colon operator
    returns a numeric vector, so there is no need to explicitly wrap this using `c`).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了`myvec`的前四个元素（记住，冒号操作符返回一个数字向量，所以不需要显式使用`c`来包裹它）。
- en: 'The order of the returned elements depends entirely upon the index vector supplied
    in the square brackets. For example, using `foo` again, consider the order of
    the indexes and the resulting extractions, shown here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的元素的顺序完全取决于方括号中提供的索引向量。例如，再次使用`foo`，考虑索引的顺序和由此得到的提取结果，如下所示：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here you extracted elements starting at the end of the vector, working backward.
    You can also use `rep` to repeat an index, as shown here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你从向量的末尾提取了元素，向后工作。你还可以使用`rep`来重复一个索引，如下所示：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is now something a little more general than strictly “subsetting”—by using
    an index vector, you can create an entirely new vector of any length consisting
    of some or all of the elements in the original vector. As shown earlier, this
    index vector can contain the desired element positions in any order and can repeat
    indexes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在已经是一个比严格的“子集”更通用的东西——通过使用索引向量，你可以创建一个全新的向量，长度可以为任意值，并包含原始向量中的一些或所有元素。如前所示，这个索引向量可以包含按任意顺序排列的目标元素位置，并且可以重复索引。
- en: 'You can also return the elements of a vector after deleting more than one element.
    For example, to create a vector after removing the first and third elements of
    `foo`, you can execute the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在删除多个元素后返回向量的元素。例如，要创建一个删除了`foo`中的第一个和第三个元素后的向量，可以执行以下操作：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that it is not possible to mix positive and negative indexes in a single
    index vector.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，无法在单个索引向量中混合使用正负索引。
- en: 'Sometimes you’ll need to overwrite certain elements in an existing vector with
    new values. In this situation, you first specify the elements you want to overwrite
    using square brackets and then use the assignment operator to assign the new values.
    Here’s an example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要用新值覆盖现有向量中的某些元素。在这种情况下，你首先使用方括号指定要覆盖的元素，然后使用赋值运算符给这些元素赋上新值。以下是一个例子：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This overwrites the first element of `bar`, which was originally `3`, with a
    new value, `6`. When selecting multiple elements, you can specify a single value
    to replace them all or enter a vector of values that’s equal in length to the
    number of elements selected to replace them one for one. Let’s try this with the
    same `bar` vector from earlier.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将`bar`的第一个元素（原为`3`）覆盖为新值`6`。当选择多个元素时，你可以指定一个单一的值来替换它们，或者输入一个与所选替换元素数量相同的向量，从而一一替换它们。我们来尝试一下之前提到的同一个`bar`向量。
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here you overwrite the second, fourth, and sixth elements with `-2`, `-0.5`,
    and `-1`, respectively; all else remains the same. By contrast, the following
    code overwrites elements `7` to `10` (inclusive), replacing them all with `100`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将第2、第4和第6个元素分别覆盖为`-2`、`-0.5`和`-1`，其余部分保持不变。相比之下，以下代码将元素`7`到`10`（包括第10个）覆盖为`100`：
- en: '[PRE34]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finally, it’s important to mention that this section has focused on just one
    of the two main methods, or “flavors,” of vector element extraction in R. You’ll
    look at the alternative method, using logical flags, in [Section 4.1.5](ch04.xhtml#ch04lev2sec41).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要提到的是，本节仅讨论了R中两种主要方法之一，或者说是两种“风格”的向量元素提取方法。你将在[第4.1.5节](ch04.xhtml#ch04lev2sec41)中查看另一种方法，使用逻辑标志。
- en: '**Exercise 2.4**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习2.4**'
- en: 'Create and store a vector that contains the following, in this order:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并存储一个包含以下元素的向量，顺序如下：
- en: – A sequence of length 5 from 3 to 6 (inclusive)
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 一个从3到6（包括6）的长度为5的序列
- en: – A twofold repetition of the vector `c(2,-5.1,-33)`
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 向量`c(2,-5.1,-33)`的两倍重复
- en: – The value ![image](../images/f0032-01.jpg)
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: – 值![image](../images/f0032-01.jpg)
- en: Extract the first and last elements of your vector from (a), storing them as
    a new object.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从向量(a)中提取第一个和最后一个元素，并将它们存储为一个新对象。
- en: Store as a third object the values returned by omitting the first and last values
    of your vector from (a).
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将通过省略向量(a)的第一个和最后一个值返回的值存储为第三个对象。
- en: Use only (b) and (c) to reconstruct (a).
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只使用(b)和(c)来重建(a)。
- en: Overwrite (a) with the same values sorted from smallest to largest.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用从最小到最大排序后的相同值覆盖(a)。
- en: Use the colon operator as an index vector to reverse the order of (e), and confirm
    this is identical to using `sort` on (e) with `decreasing=TRUE`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用冒号运算符作为索引向量来反转(e)的顺序，并确认这与对(e)使用`sort`函数并设置`decreasing=TRUE`是等价的。
- en: Create a vector from (c) that repeats the third element of (c) three times,
    the sixth element four times, and the last element once.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从(c)中创建一个向量，其中包含(c)的第三个元素重复三次、第六个元素重复四次以及最后一个元素重复一次。
- en: Create a new vector as a copy of (e) by assigning (e) as is to a newly named
    object. Using this new copy of (e), overwrite the first, the fifth to the seventh
    (inclusive), and the last element with the values 99 to 95 (inclusive), respectively.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新向量，作为(e)的副本，将(e)原样赋值给一个新命名的对象。使用这个新副本的(e)，依次将第一个元素、第5到第7个元素（包括第7个）以及最后一个元素覆盖为99到95（包括95）的值。
- en: '***2.3.4 Vector-Oriented Behavior***'
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***2.3.4 向量导向行为***'
- en: Vectors are so useful because they allow R to carry out operations on multiple
    elements simultaneously with speed and efficiency. This *vector-oriented*, *vectorized*,
    or *element-wise* behavior is a key feature of the language, one that you will
    briefly examine here through some examples of rescaling measurements.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 向量之所以如此有用，是因为它们允许 R 以高速和高效的方式对多个元素同时进行操作。这个*面向向量*、*向量化*或*按元素*的行为是该语言的一个关键特性，你将在这里通过一些重新缩放测量的示例简要地了解它。
- en: 'Let’s start with this simple example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个简单的例子开始：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This code creates a sequence of six values between 5.5 and 0.5, in increments
    of 1\. From this vector, you subtract another vector containing 2, 4, 6, 8, 10,
    and 12\. What does this do? Well, quite simply, R matches up the elements according
    to their respective positions and performs the operation on each corresponding
    pair of elements. The resulting vector is obtained by subtracting the first element
    of `c(2,4,6,8,10,12)` from the first element of `foo` (5.5 − 2 = 3.5), then by
    subtracting the second element of `c(2,4,6,8,10,12)` from the second element of
    `foo` (4.5 − 4 = 0.5), and so on. Thus, rather than inelegantly cycling through
    each element in turn (as you could do by hand or by explicitly using a loop),
    R permits a fast and efficient alternative using vector-oriented behavior. [Figure
    2-1](ch02.xhtml#ch2fig1) illustrates how you can understand this type of calculation
    and highlights the fact that the positions of the elements are crucial in terms
    of the final result; elements in differing positions have no effect on one another.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个从 5.5 到 0.5 的六个值的序列，增量为 1。然后，从这个向量中减去另一个包含 2、4、6、8、10 和 12 的向量。这会怎么做呢？简单来说，R
    会根据元素的位置匹配每个元素，并对每一对相应的元素进行操作。结果向量是通过从 `c(2,4,6,8,10,12)` 的第一个元素减去 `foo` 的第一个元素（5.5
    − 2 = 3.5），然后从 `c(2,4,6,8,10,12)` 的第二个元素减去 `foo` 的第二个元素（4.5 − 4 = 0.5），依此类推。因此，与手动或显式使用循环逐个处理每个元素相比，R
    允许使用面向向量的行为进行快速而高效的替代。[图 2-1](ch02.xhtml#ch2fig1) 展示了如何理解这种类型的计算，并突出了元素位置在最终结果中的重要性；不同位置的元素互不影响。
- en: 'The situation is made more complicated when using vectors of different lengths,
    which can happen in two distinct ways. The first is when the length of the longer
    vector can be evenly divided by the length of the shorter vector. The second is
    when the length of the longer vector *cannot* be divided by the length of the
    shorter vector—this is usually unintentional on the user’s part. In both of these
    situations, R essentially attempts to replicate, or *recycle*, the shorter vector
    by as many times as needed to match the length of the longer vector, before completing
    the specified operation. As an example, suppose you wanted to alternate the entries
    of `foo` shown earlier as negative and positive. You could explicitly multiply
    `foo` by `c(1,-1,1,-1,1,-1)`, but you don’t need to write out the full latter
    vector. Instead, you can write the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用不同长度的向量时，情况会变得更加复杂，这种情况可以通过两种不同的方式发生。第一种是较长的向量的长度可以被较短向量的长度整除。第二种是较长的向量的长度*不能*被较短向量的长度整除——这通常是用户无意的行为。在这两种情况下，R
    本质上会尝试重复，或*回收*，较短的向量，直到它的长度与较长的向量匹配，然后完成指定的操作。举个例子，假设你想将之前显示的 `foo` 的条目交替设为负数和正数。你可以显式地将
    `foo` 乘以 `c(1,-1,1,-1,1,-1)`，但你不需要写出完整的后者向量。相反，你可以写以下内容：
- en: '![image](../images/f02-01.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f02-01.jpg)'
- en: '*Figure 2-1: A conceptual diagram of the element-wise behavior of a comparison
    or operation carried out on two vectors of equal length in R. Note that the operation
    is performed by matching up the element positions.*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：在 R 中对两个相同长度的向量进行比较或操作时，按元素行为的概念图。请注意，操作是通过将元素位置一一匹配来进行的。*'
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here `bar` has been applied repeatedly throughout the length of `foo` until
    completion. The left plot of [Figure 2-2](ch02.xhtml#ch2fig2) illustrates this
    particular example. Now let’s see what happens when the vector lengths are not
    evenly divisible.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `bar` 已在 `foo` 的整个长度上重复应用，直到完成。[图 2-2](ch02.xhtml#ch2fig2) 的左侧图展示了这个特定示例。现在让我们看看当向量长度不能整除时会发生什么。
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here you see that R has matched the first four elements of `foo` with the entirety
    of `baz`, but it’s not able to fully repeat the vector again. The repetition has
    been attempted, with the first two elements of `baz` being matched with the last
    two of the longer `foo`, though not without a protest from R, which notifies the
    user of the unevenly divisible lengths (you’ll look at warnings in more detail
    in [Section 12.1](ch12.xhtml#ch12lev1sec39)). The plot on the right in [Figure
    2-2](ch02.xhtml#ch2fig2) illustrates this example.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 R 已将 `foo` 的前四个元素与整个 `baz` 匹配，但它无法再次完全重复该向量。虽然 R 尝试重复该向量，将 `baz` 的前两个元素与较长的
    `foo` 的后两个元素匹配，但这并不没有完全成功，因为 R 发出警告，提示长度无法均匀除尽（你将在[第 12.1 节](ch12.xhtml#ch12lev1sec39)中更详细地查看警告）。右图中的[图
    2-2](ch02.xhtml#ch2fig2)展示了这一示例。
- en: '![image](../images/f02-02.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f02-02.jpg)'
- en: '*Figure 2-2: An element-wise operation on two vectors of differing lengths.
    Left:* `foo` *multiplied by* `bar`*; lengths are evenly divisible. Right:* `foo`
    *multiplied by* `baz`*; lengths are not evenly divisible, and a warning is issued.*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-2：对两个不同长度的向量执行逐元素操作。左：* `foo` *与* `bar` *相乘；长度可以均匀除尽。右：* `foo` *与* `baz`
    *相乘；长度不能均匀除尽，并发出警告。*'
- en: 'As I noted in [Section 2.3.3](ch02.xhtml#ch02lev2sec22), you can consider single
    values to be vectors of length 1, so you can use a single value to repeat an operation
    on all the values of a vector of any length. Here’s an example, using the same
    vector `foo`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第 2.3.3 节](ch02.xhtml#ch02lev2sec22)中提到的，你可以将单个值视为长度为 1 的向量，因此你可以使用单个值对任何长度的向量执行操作。以下是一个例子，使用相同的向量
    `foo`：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is far easier than executing `foo+c(3,3,3,3,3,3)` or the more general `foo+rep(x=3,times=length(x=foo))`.
    Operating on vectors using a single value in this fashion is quite common, such
    as if you want to rescale or translate a set of measurements by some constant
    amount.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这远比执行 `foo+c(3,3,3,3,3,3)` 或更一般的 `foo+rep(x=3,times=length(x=foo))` 要容易。以这种方式操作向量，使用单个值是非常常见的，例如，如果你想通过某个常数对一组测量值进行重新缩放或平移。
- en: Another benefit of vector-oriented behavior is that you can use vectorized functions
    to complete potentially laborious tasks. For example, if you want to sum or multiply
    all the entries in a numeric vector, you can just use a built-in function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 面向向量的行为的另一个好处是，你可以使用矢量化函数完成潜在的繁重任务。例如，如果你想对一个数字向量中的所有元素求和或相乘，你只需要使用一个内置函数。
- en: 'Recall `foo`, shown earlier:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下之前展示的 `foo`：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can find the sum of these six elements with
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式求得这六个元素的和：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: and their product with
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以及它们的乘积：
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Far from being just convenient, vectorized functions are faster and more efficient
    than an explicitly coded iterative approach like a loop. The main takeaway from
    these examples is that much of R’s functionality is designed specifically for
    certain data structures, ensuring neatness of code as well as optimization of
    performance.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量化函数不仅方便，而且比显式编写的迭代方法（例如循环）更快、更高效。这些示例的主要启示是，R 的许多功能是专门为某些数据结构设计的，确保了代码的简洁性和性能的优化。
- en: 'Lastly, as mentioned earlier, this vector-oriented behavior applies in the
    same way to overwriting multiple elements. Again using `foo`, examine the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如前所述，这种面向向量的行为同样适用于覆盖多个元素。再次使用 `foo`，请查看以下内容：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You see four specific elements being overwritten by a vector of length 2, which
    is recycled in the same fashion you’re familiar with. Again, the length of the
    vector of replacements must evenly divide the number of elements being overwritten,
    or else a warning similar to the one shown earlier will be issued when R cannot
    complete a full-length recycle.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到四个特定元素被长度为 2 的向量覆盖，这些向量以你熟悉的方式重复。同样，替换向量的长度必须能均匀除尽要被覆盖的元素数量，否则当 R 无法完成一个完整长度的重复时，将发出类似之前的警告。
- en: '**Exercise 2.5**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 2.5**'
- en: Convert the vector `c(2,0.5,1,2,0.5,1,2,0.5,1)` to a vector of only `1`s, using
    a vector of length 3.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将向量 `c(2,0.5,1,2,0.5,1,2,0.5,1)` 转换为仅包含 `1` 的向量，使用长度为 3 的向量。
- en: 'The conversion from a temperature measurement in degrees Fahrenheit *F* to
    Celsius *C* is performed using the following equation:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 华氏度 *F* 到摄氏度 *C* 的转换是通过以下公式进行的：
- en: '![image](../images/f0036-01.jpg)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](../images/f0036-01.jpg)'
- en: Use vector-oriented behavior in R to convert the temperatures 45, 77, 20, 19,
    101, 120, and 212 in degrees Fahrenheit to degrees Celsius.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用面向向量的行为，在 R 中将温度值 45、77、20、19、101、120 和 212 华氏度转换为摄氏度。
- en: Use the vector `c(2,4,6)` and the vector `c(1,2)` in conjunction with `rep`
    and `*` to produce the vector `c(2,4,6,4,8,12)`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overwrite the middle four elements of the resulting vector from (c) with the
    two recycled values `-0.1` and `-100`, in that order.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Important Code in This Chapter**'
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| **Function/operator** | **Brief description** | **First occurrence** |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
- en: '| `+`, `*`, `-`, `/`, `^` | Arithmetic | [Section 2.1](ch02.xhtml#ch02lev1sec09),
    [p. 17](ch02.xhtml#page_17) |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: '| `sqrt` | Square root | [Section 2.1.1](ch02.xhtml#ch02lev2sec17), [p. 18](ch02.xhtml#page_18)
    |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '| `log` | Logarithm | [Section 2.1.2](ch02.xhtml#ch02lev2sec18), [p. 19](ch02.xhtml#page_19)
    |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: '| `exp` | Exponential | [Section 2.1.2](ch02.xhtml#ch02lev2sec18), [p. 19](ch02.xhtml#page_19)
    |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: '| `<-`, `=` | Object assignment | [Section 2.2](ch02.xhtml#ch02lev1sec10),
    [p. 21](ch02.xhtml#page_21) |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
- en: '| `c` | Vector creation | [Section 2.3.1](ch02.xhtml#ch02lev2sec20), [p. 23](ch02.xhtml#page_23)
    |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
- en: '| `:`, `seq` | Sequence creation | [Section 2.3.2](ch02.xhtml#ch02lev2sec21),
    [p. 24](ch02.xhtml#page_24) |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: '| `rep` | Value/vector repetition | [Section 2.3.2](ch02.xhtml#ch02lev2sec21),
    [p. 25](ch02.xhtml#page_25) |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: '| `sort` | Vector sorting | [Section 2.3.2](ch02.xhtml#ch02lev2sec21), [p.
    26](ch02.xhtml#page_26) |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
- en: '| `length` | Determine vector length | [Section 2.3.2](ch02.xhtml#ch02lev2sec21),
    [p. 27](ch02.xhtml#page_27) |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
- en: '| `[ ]` | Vector subsetting/extraction | [Section 2.3.3](ch02.xhtml#ch02lev2sec22),
    [p. 28](ch02.xhtml#page_28) |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
- en: '| `sum` | Sum all vector elements | [Section 2.3.4](ch02.xhtml#ch02lev2sec23),
    [p. 36](ch02.xhtml#page_36) |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
- en: '| `prod` | Multiply all vector elements | [Section 2.3.4](ch02.xhtml#ch02lev2sec23),
    [p. 36](ch02.xhtml#page_36) |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
