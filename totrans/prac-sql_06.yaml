- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic Math and Stats with SQL
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: If your data includes any of the number data types we explored in Chapter 4—integers,
    decimals, or floating points—sooner or later your analysis will include some calculations.
    You might want to know the average of all the dollar values in a column or add
    values in two columns to produce a total for each row. SQL can handle those calculations
    and more, from basic math through advanced statistics.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I’ll start with the basics and progress to math functions and
    beginning statistics. I’ll also discuss calculations related to percentages and
    percent change. For several of the exercises, we’ll use the 2019 US Census population
    estimates data you imported in Chapter 5.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Math Operators and Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with the basic math you learned in grade school (all’s forgiven
    if you’ve forgotten some of it). [Table 6-1](#table6-1) shows nine math operators
    you’ll use most often in your calculations. The first four (addition, subtraction,
    multiplication, and division) are part of the ANSI SQL standard and are implemented
    in all database systems. The others are PostgreSQL-specific operators, although
    most other database managers likely have functions or operators to perform those
    operations too. For example, the modulo operator (`%`) works in Microsoft SQL
    Server and MySQL as well as with PostgreSQL. If you’re using another database
    system, check its documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-1: Basic Math Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | Addition |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | Subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Multiplication |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | Division (returns the quotient only, no remainder) |'
  prefs: []
  type: TYPE_TB
- en: '| `%` | Modulo (returns just the remainder) |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Exponentiation |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;/` | Square root |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;&#124;/` | Cube root |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | Factorial |'
  prefs: []
  type: TYPE_TB
- en: We’ll step through each of these operators by executing simple SQL queries on
    plain numbers rather than operating on a table or another database object. You
    can either enter the statements separately into the pgAdmin query tool and execute
    them one at a time, or if you copied the code for this chapter from the resources
    at [https://www.nostarch.com/practical-sql-2nd-edition/](https://www.nostarch.com/practical-sql-2nd-edition/),
    you can highlight each line and execute it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Math and Data Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you work through the examples, note the data type of each result, which
    is listed beneath each column name in the pgAdmin results grid. The type returned
    for a calculation will vary depending on the operation and the data type of the
    input numbers. When using an operator between two numbers—addition, subtraction,
    multiplication, or division—the data type returned follows this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Two integers return an `integer`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `numeric` on either side or both sides of the operator returns a `numeric`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything with a floating-point number returns a floating-point number of type
    `double precision`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the exponentiation, root, and factorial functions are different. Each
    takes just one number, either before or after the operator, and returns numeric
    and floating-point types, even when the input is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the result’s data type will suit your needs; other times, you may
    need to use `CAST` to change the data type, as mentioned in “Transforming Values
    from One Type to Another with CAST” in Chapter 4, such as if you need to feed
    the result into a function that takes a certain type. I’ll note those times as
    we work through the book.
  prefs: []
  type: TYPE_NORMAL
- en: Adding, Subtracting, and Multiplying
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start with simple integer addition, subtraction, and multiplication.
    [Listing 6-1](#listing6-1) shows three examples, each with the `SELECT` keyword
    followed by the math formula. Since Chapter 3, we’ve used `SELECT` for its main
    purpose: to retrieve data from a table. But with PostgreSQL, Microsoft’s SQL Server,
    MySQL, and some other database management systems, you can omit the table name
    and perform simple math and string operations, as we do here. For readability’s
    sake, I recommend you use a single space before and after the math operator; although
    using spaces isn’t strictly necessary for your code to work, it is good practice.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-1: Basic addition, subtraction, and multiplication with SQL'
  prefs: []
  type: TYPE_NORMAL
- en: 'None of these statements is rocket science, so you shouldn’t be surprised that
    running `SELECT 2 + 2;` 1 in the Query Tool shows a result of `4`. Similarly,
    the examples for subtraction 2 and multiplication 3 yield what you’d expect: `8`
    and `12`. The output displays in a column, as with any query result. But because
    we’re not querying a table and specifying a column, the results appear beneath
    a `?column?` name, signifying an unknown column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That’s okay. We’re not affecting any data in a table, just displaying a result.
    If you want to display a column name, you can provide an alias, as in `SELECT
    3 * 4 AS result;`.
  prefs: []
  type: TYPE_NORMAL
- en: Performing Division and Modulo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Division with SQL gets a little trickier because of the difference between math
    with integers and math with decimals. Add in *modulo*, an operator that returns
    just the *remainder* in a division operation, and the results can be confusing.
    So, to make it clear, [Listing 6-2](#listing6-2) shows four examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-2: Integer and decimal division with SQL'
  prefs: []
  type: TYPE_NORMAL
- en: The `/` operator 1 divides the integer `11` by another integer, `6`. If you
    do that math in your head, you know the answer is `1` with a remainder of `5`.
    However, running this query yields `1`, which is how SQL handles division of one
    integer by another—by reporting only the integer *quotient* without any remainder.
    If you want to retrieve the *remainder* as an integer, you must perform the same
    calculation using the modulo operator `%`, as in 2. That statement returns just
    the remainder, in this case `5`. No single operation today will provide you with
    both the quotient and the remainder as integers, though an enterprising developer
    could add that functionality in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modulo is useful for more than just fetching a remainder: you can also use
    it as a test condition. For example, to check whether a number is even, you can
    test it using the `% 2` operation. If the result is `0` with no remainder, the
    number is even.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to divide two numbers and have the result return as a `numeric`
    type. First, if one or both of the numbers is a `numeric`, the result will by
    default be expressed as a `numeric`. That’s what happens when I divide `11.0`
    by `6` 3. Execute that query, and the result is `1.83333`. The number of decimal
    digits displayed may vary according to your PostgreSQL and system settings.
  prefs: []
  type: TYPE_NORMAL
- en: Second, if you’re working with data stored only as integers and need to force
    decimal division, you can use `CAST` to convert one of the integers to a `numeric`
    type 4. Executing this also returns `1.83333`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Exponents, Roots, and Factorials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Beyond the basics, PostgreSQL-flavored SQL also provides operators and functions
    to square, cube, or otherwise raise a base number to an exponent, as well as find
    roots or the factorial of a number. [Listing 6-3](#listing6-3) shows these operations
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-3: Exponents, roots, and factorials with SQL'
  prefs: []
  type: TYPE_NORMAL
- en: The exponentiation operator (`^`) allows you to raise a given base number to
    an exponent, as in 1, where `3 ^ 4` (colloquially, we’d call that three to the
    fourth power) returns `81`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the square root of a number in two ways: using the `|/` operator
    2 or the `sqrt(``n``)` function. For a cube root, use the `||/` operator 3. Both
    are *prefix operators*, named because they come before a single value.'
  prefs: []
  type: TYPE_NORMAL
- en: To find the *factorial* of a number, you can use the `factorial(``n``)` function
    or the `!` operator. The `!`, available only in PostgreSQL versions 13 and earlier,
    is a *suffix operator*, coming after a single value. You’ll use factorials in
    many places in math, but perhaps the most common is to determine how many ways
    a number of items can be ordered. Say you have four photographs. How many ways
    could you order them on a wall? To find the answer, you’d calculate the factorial
    by starting with the number of items and multiplying it by all the smaller positive
    integers. So, at 4, the function `factorial(4)` is equivalent to 4 × 3 × 2 × 1\.
    That’s 24 ways to order four photos. No wonder decorating takes so long sometimes!
  prefs: []
  type: TYPE_NORMAL
- en: Again, these operators are specific to PostgreSQL; they’re not part of the SQL
    standard. If you’re using another database application, check its documentation
    for how it implements these operations.
  prefs: []
  type: TYPE_NORMAL
- en: Minding the Order of Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may recall from early math lessons what the order of operations, or *operator
    precedence*, is on a mathematical expression. Which calculations does SQL execute
    first? Not surprisingly, SQL follows the established math standard. For the PostgreSQL
    operators discussed so far, the order is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Exponents and roots
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiplication, division, modulo
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Addition and subtraction
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Given these rules, you’ll need to encase an operation in parentheses if you
    want to calculate it in a different order. For example, the following two expressions
    yield different results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first expression returns `79` because the multiplication operation receives
    precedence and is processed before the addition. The second returns `135` because
    the parentheses force the addition operation to occur first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a second example using exponents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Exponent operations take precedence over subtraction, so without parentheses
    the entire expression is evaluated left to right and the operation to find 3 to
    the power of 3 happens first. Then 1 is subtracted, returning `26`. In the second
    example, the parentheses force the subtraction to happen first, so the operation
    results in `9`, which is 3 to the power of 2.
  prefs: []
  type: TYPE_NORMAL
- en: Keep operator precedence in mind to avoid having to correct your analysis later!
  prefs: []
  type: TYPE_NORMAL
- en: Doing Math Across Census Table Columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s try to use the most frequently used SQL math operators on real data by
    digging into the 2019 US Census population estimates table, `us_counties_pop_est_2019`,
    that you imported in Chapter 5. Instead of using numbers in queries, we’ll use
    the names of the columns that contain the numbers. When we execute the query,
    the calculation will occur on each row of the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'To refresh your memory about the data, run the script in [Listing 6-4](#listing6-4).
    It should return 3,142 rows showing the name and state of each county in the United
    States plus the 2019 components of population change: births, deaths, and international
    and domestic migration.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-4: Selecting census population estimate columns with aliases'
  prefs: []
  type: TYPE_NORMAL
- en: This query doesn’t return all columns in the table, just the ones with data
    related to the population estimates. In addition, I employ the `AS` keyword 1
    to give each column a shorter *alias* in the result set. Because all the data
    in this query is from 2019, I’m eliminating the year from the names of the results
    columns to reduce scrolling in the pgAdmin output. It’s an arbitrary decision
    that you can adjust.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and Subtracting Columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let’s try a simple calculation using two of the columns. [Listing 6-5](#listing6-5)
    subtracts the number of deaths from the number of births in each county, a measure
    the census refers to as natural increase. Let’s see what this shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-5: Subtracting two columns in *us_counties_pop_est_2019*'
  prefs: []
  type: TYPE_NORMAL
- en: Providing `births_2019 - deaths_2019` 1 as one of the columns in the `SELECT`
    statement handles the calculation. Again, I use the `AS` keyword to provide a
    readable alias for the column. If you don’t provide an alias, PostgreSQL uses
    the label `?column?`, which is far less than helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the query to see the results. The first few rows should resemble this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A quick check with a calculator or pencil and paper confirms that the `natural_increase`
    column equals the difference between the two columns you subtracted. Excellent!
    Notice as you scroll through the output that some counties have more births than
    deaths, while others have the opposite. Typically, counties with a younger mix
    of residents see births outpace deaths; those with an older set of people—think
    rural areas and retirement hotspots—tend to see a greater number of deaths than
    births.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s build on this to test our data and validate that we imported columns
    correctly. The population estimate for 2019 should equal the sum of the 2018 estimate
    and the columns about births, deaths, migration, and residual factor. The code
    in [Listing 6-6](#listing6-6) should show that it does.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-6: Checking census data totals'
  prefs: []
  type: TYPE_NORMAL
- en: This query includes the 2019 population estimate 1, followed by a calculation
    adding the components to the 2018 population estimate as `component_total` 2.
    The 2018 estimate plus the components should equal the 2019 estimate. Rather than
    manually check, we also add a column that subtracts the components total from
    the 2019 estimate 3. That column, named `difference`, should contain a zero in
    each row if all the data is in the right place. To avoid having to scan all 3,142
    rows, we add an `ORDER BY` clause 4 on the named column. Any rows showing a difference
    should appear at the top or bottom of the query result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the query; the first few rows should provide this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With the `difference` column showing zeros, we can be confident that our import
    was clean. Whenever I encounter or import a new dataset, I like to perform little
    tests like this. They help me better understand the data and head off any potential
    issues before I dig into analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Percentages of the Whole
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One way to spot differences in the items in a dataset is to calculate the percentage
    of the whole that a particular data point represents. Then, you can glean meaningful
    insights—and sometimes surprises—by comparing that percentage across all the items
    in your dataset.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out the percentage of the whole, divide the number in question by
    the total. For example, if you had a basket of 12 apples and used 9 in a pie,
    that would be 9 / 12 or 0.75—commonly expressed as 75 percent.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll try this on the census population estimates using the two columns that
    represent the size of each county’s geographical features. The columns `area_land`
    and `area_water` show a county’s land and water measurement in square meters.
    Using the code in [Listing 6-7](#listing6-7), we can calculate for each county
    the percentage of its area that is made up of water.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-7: Calculating the percent of a county’s area that is water'
  prefs: []
  type: TYPE_NORMAL
- en: The key piece of this query divides `area_water` by the sum of `area_land` and
    `area_water`, which together represent the total area of the county 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the data as their original integer types, we won’t get the fractional
    result we need: every row will display a result of 0, the quotient. Instead, we
    force decimal division by casting one of the integers to the numeric type. Here,
    for brevity, we use the PostgreSQL-specific double-colon notation after the first
    reference to `area_water`, but you can also use the ANSI SQL standard `CAST` function
    covered in Chapter 4. Finally, we multiply the result by 100 to present the result
    as a fraction of 100—the way most people understand percentages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By sorting from highest to lowest percentage, the top of the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check the Wikipedia entry for Keweenaw County, you’ll discover the reason
    why its total area is more than 90 percent water: its land area includes an island
    in Lake Superior, and the lake’s waters are included in the total reported by
    the census. Add that to your trivia collection!'
  prefs: []
  type: TYPE_NORMAL
- en: Tracking Percent Change
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another key indicator in data analysis is percent change: how much bigger,
    or smaller, is one number than another? Percent change calculations are often
    employed when analyzing change over time, and they’re particularly useful for
    comparing change among similar items.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The year-over-year change in the number of vehicles sold by each automobile
    maker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The monthly change in subscriptions to each email list owned by a marketing
    firm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The annual increase or decrease in enrollment at schools across a nation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The formula to calculate percent change can be expressed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: (*new number* – *old number*) / *old number*
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you own a lemonade stand and sold 73 glasses of lemonade today and 59
    glasses yesterday, you’d figure the day-to-day percent change like this:'
  prefs: []
  type: TYPE_NORMAL
- en: (73 – 59) / 59 = .237 = 23.7%
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try this with a small collection of test data related to spending in departments
    of a hypothetical local government. [Listing 6-8](#listing6-8) calculates which
    departments had the greatest percentage increase and decrease.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-8: Calculating percent change'
  prefs: []
  type: TYPE_NORMAL
- en: We create a small table called `percent_change` 1 and insert six rows 2 with
    data on department spending for the years 2019 and 2022\. The percent change formula
    3 subtracts `spend_2019` from `spend_2022` and then divides by `spend_2019`. We
    multiply by 100 to express the result as a portion of 100.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify the output, this time I’ve added the `round()` function to remove
    all but one decimal place. The function takes two arguments: the column or expression
    to be rounded and the number of decimal places to display. Because both numbers
    are type `numeric`, the result will also be a `numeric`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The script creates this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, it’s just a matter of finding out why the Clerk department’s spending has
    outpaced others in the town.
  prefs: []
  type: TYPE_NORMAL
- en: Using Aggregate Functions for Averages and Sums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve performed math operations across columns in each row of a table.
    SQL also lets you calculate a result from values within the same column using
    *aggregate functions*. You can see a full list of PostgreSQL aggregates, which
    calculate a single result from multiple inputs, at [https://www.postgresql.org/docs/current/functions-aggregate.html](https://www.postgresql.org/docs/current/functions-aggregate.html).
    Two of the most-used aggregate functions in data analysis are `avg()` and `sum()`.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to the `us_counties_pop_est_2019` census table, it’s reasonable to
    want to calculate the total population of all counties plus the average population
    of all counties. Using `avg()` and `sum()` on column `pop_est_2019` (the population
    estimate for 2019) makes it easy, as shown in [Listing 6-9](#listing6-9). Again,
    we use the `round()` function to remove numbers after the decimal point in the
    average calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-9: Using the `sum()` and `avg()` aggregate functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'This calculation produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The estimated population for all counties in the United States in 2019 added
    up to approximately 328.2 million, and the average of the county population estimates
    was 104,468.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Median
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *median* value in a set of numbers is as important an indicator, if not
    more so, than the average. Here’s the difference between median and average:'
  prefs: []
  type: TYPE_NORMAL
- en: Average The sum of all the values divided by the number of values
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Median The “middle” value in an ordered set of values
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Median is important in data analysis because it reduces the effect of outliers.
    Consider this example: let’s say six kids, ages 10, 11, 10, 9, 13, and 12, go
    on a field trip. It’s easy to add the ages and divide by six to get the group’s
    average age:'
  prefs: []
  type: TYPE_NORMAL
- en: (10 + 11 + 10 + 9 + 13 + 12) / 6 = 10.8
  prefs: []
  type: TYPE_NORMAL
- en: Because the ages fall within a narrow range, the 10.8 average is a good representation
    of the group. But averages are less helpful when the values are bunched, or skewed,
    toward one end of the distribution, or if the group includes outliers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say an older chaperone joins the field trip. With ages of 10,
    11, 10, 9, 13, 12, and 46, the average age increases considerably:'
  prefs: []
  type: TYPE_NORMAL
- en: (10 + 11 + 10 + 9 + 13 + 12 + 46) / 7 = 15.9
  prefs: []
  type: TYPE_NORMAL
- en: Now the average doesn’t represent the group well because the outlier skews it,
    making it an unreliable indicator.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s better in this case to find the median, the midpoint in an ordered list
    of values—the point at which half the values are more and half are less. Using
    the field trip, we order the attendees’ ages from lowest to highest:'
  prefs: []
  type: TYPE_NORMAL
- en: 9, 10, 10, 11, 12, 13, 46
  prefs: []
  type: TYPE_NORMAL
- en: The middle (median) value is 11\. Given this group, the median of 11 is a better
    picture of the typical age than the average of 15.9.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the set of values is an even number, you take the average of the two middle
    numbers to find the median. Let’s add another student (age 12) to the field trip:'
  prefs: []
  type: TYPE_NORMAL
- en: 9, 10, 10, 11, 12, 12, 13, 46
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the two middle values are 11 and 12\. To find the median, we average them:
    11.5.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Medians are reported frequently in financial news. Reports on housing prices
    often use medians because a few sales of McMansions in a ZIP code that is otherwise
    modest can make averages useless. The same goes for sports player salaries: one
    or two superstars can skew a team’s average.'
  prefs: []
  type: TYPE_NORMAL
- en: A good test is to calculate the average and the median for a group of values.
    If they’re close, the group is probably normally distributed (the familiar bell
    curve), and the average is useful. If they’re far apart, the values are not normally
    distributed, and the median is the better representation.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Median with Percentile Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PostgreSQL (as with most relational databases) does not have a built-in `median()`
    function like you’d find in Excel or other spreadsheet programs. It’s also not
    included in the ANSI SQL standard. Instead we can use a SQL *percentile* function
    to find the median and use *quantiles* or *cut points* to divide a group of numbers
    into equal sizes. Percentile functions are part of standard ANSI SQL.
  prefs: []
  type: TYPE_NORMAL
- en: In statistics, percentiles indicate the point in an ordered set of data below
    which a certain percentage of the data is found. For example, a doctor might tell
    you that your height places you in the 60th percentile for an adult in your age
    group. That means 60 percent of people are shorter than you.
  prefs: []
  type: TYPE_NORMAL
- en: The median is equivalent to the 50th percentile—again, half the values are below
    and half above. There are two versions of the percentile function—`percentile_cont(``n``)`
    and `percentile_disc(``n``)`. Both functions are part of the ANSI SQL standard
    and are present in PostgreSQL, Microsoft SQL Server, and other databases.
  prefs: []
  type: TYPE_NORMAL
- en: The `percentile_cont(``n``)` function calculates percentiles as *continuous*
    values. That is, the result does not have to be one of the numbers in the dataset
    but can be a decimal value in between two of the numbers. This follows the methodology
    for calculating medians on an even number of values, where the median is the average
    of the two middle numbers. The `percentile_disc(``n``)` function returns only
    *discrete* values, meaning the result will be rounded to one of the numbers in
    the set.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 6-10](#listing6-10) we make a test table with six numbers and find
    the percentiles.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-10: Testing SQL percentile functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'In both the continuous 1 and discrete 2 percentile functions, we enter `.5`
    to represent the 50th percentile, equivalent to the median. Running the code returns
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `percentile_cont()` function returned what we’d expect the median to be:
    `3.5`. But because `percentile_disc()` calculates discrete values, it reports
    `3`, the last value in the first 50 percent of the numbers. Because the accepted
    method of calculating medians is to average the two middle values in an even-numbered
    set, use `percentile_cont(.5)` to find a median.'
  prefs: []
  type: TYPE_NORMAL
- en: Finding Median and Percentiles with Census Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our census data can show how a median tells a different story than an average.
    [Listing 6-11](#listing6-11) adds `percentile_cont()` alongside the `sum()` and
    `avg()` aggregates we’ve used so far to find the sum, average, and median population
    of all counties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-11: Using `sum()`, `avg()`, and `percentile_cont()` aggregate functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your result should equal the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The median and average are far apart, which shows that averages can mislead.
    As of 2019 estimates, half the counties in America had fewer than 25,726 people,
    whereas half had more. If you gave a presentation on US demographics and told
    the audience that the “average county in America has 104,468 people,” they’d walk
    away with a skewed picture of reality. More than 40 counties were estimated to
    have a million or more people in 2019, and Los Angeles County had more than 10
    million. That pushed the average higher.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Other Quantiles with Percentile Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also slice data into smaller equal groups for analysis. Most common
    are *quartiles* (four equal groups), *quintiles* (five groups), and *deciles*
    (10 groups). To find any individual value, you can just plug it into a percentile
    function. To find the value marking the first quartile or the lowest 25 percent
    of data, you’d use a value of `.25`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: However, entering values one at a time is laborious if you want to generate
    multiple cut points. Instead, you can pass values into `percentile_cont()` using
    an *array*, a list of items.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-12](#listing6-12) shows how to calculate all four quartiles at once.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-12: Passing an array of values to `percentile_cont()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we create our cut points by enclosing values in an *array
    constructor* 1 called `ARRAY[]`. An array constructor is an expression that builds
    an array from the elements included between the square brackets. Inside the brackets,
    we provide comma-separated values representing the three points at which to cut
    to create four quartiles. Run the query, and you should see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we passed in an array, PostgreSQL returns an array, denoted in the
    results by curly brackets. Each quartile is separated by commas. The first quartile
    is 10,902.5, which means 25 percent of counties have a population that is equal
    to or lower than this value. The second quartile is the same as the median: 25,726\.
    The third quartile is 68,072.75, meaning the largest 25 percent of counties have
    at least this large of a population. (When reporting these, we’d of course round
    up or down, as we don’t deal in fractions when talking about people.)'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are defined in the ANSI SQL standard, and our use here is just one of
    several ways you work with arrays in PostgreSQL. You can, for example, define
    a table column as an array of a particular data type. That’s useful if you want
    store multiple values in a single database column, such as a collection of tags
    for a blog post, instead of storing them in a separate table. See the PostgreSQL
    documentation at [https://www.postgresql.org/docs/current/arrays.html](https://www.postgresql.org/docs/current/arrays.html)
    for examples of declaring, searching, and modifying arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays also come with a host of functions (noted for PostgreSQL at [https://www.postgresql.org/docs/current/functions-array.html](https://www.postgresql.org/docs/current/functions-array.html))
    that allow you to perform tasks such as adding or removing values or counting
    the elements. A handy function for working with the result returned in [Listing
    6-12](#listing6-12) is `unnest()`, which makes the array easier to read by turning
    it into rows. [Listing 6-13](#listing6-13) shows the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-13: Using `unnest()` to turn an array into rows'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the output should be in rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If we were computing deciles, pulling them from the resulting array and displaying
    them in rows would be especially helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can find the *mode*, the value that appears most often, using the PostgreSQL
    `mode()` function. The function is not part of standard SQL and has a syntax similar
    to the percentile functions. [Listing 6-14](#listing6-14) shows a `mode()` calculation
    on `births_2019`, the column showing the number of babies born.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-14: Finding the most frequent value with `mode()`'
  prefs: []
  type: TYPE_NORMAL
- en: The result is `86`, a number of births shared by 16 counties.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with numbers is a key step in acquiring meaning from your data, and
    with the math skills covered in this chapter, you’re ready to handle the foundations
    of numerical analysis with SQL. Later in the book, you’ll learn about deeper statistical
    concepts including regression and correlation, but at this point you’ve mastered
    the basics of sums, averages, and percentiles. You’ve also learned how a median
    can be a fairer assessment of a group of values than an average. That alone can
    help you avoid inaccurate conclusions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I’ll introduce you to the power of joining data in two
    or more tables to increase your options for data analysis. We’ll use the 2019
    US Census data you’ve already loaded into the `analysis` database and explore
    additional datasets.
  prefs: []
  type: TYPE_NORMAL
