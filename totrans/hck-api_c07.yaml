- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Endpoint Analysis
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 端点分析
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Now that you’ve discovered a few APIs, it’s time to begin using and testing
    the endpoints you’ve found. This chapter will cover interacting with endpoints,
    testing them for vulnerabilities, and maybe even scoring some early wins.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经发现了一些 API，是时候开始使用并测试你找到的端点了。本章将介绍如何与端点交互，测试它们的漏洞，甚至可能在早期就获得一些小小的胜利。
- en: By “early wins,” I mean critical vulnerabilities or data leaks sometimes present
    during this stage of testing. APIs are a special sort of target because you may
    not need advanced skills to bypass firewalls and endpoint security; instead, you
    may just need to know how to use an endpoint as it was designed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所谓的“早期胜利”，是指在测试的这个阶段可能会发现的关键漏洞或数据泄露。API 是一种特殊的目标，因为你可能不需要高级技能就能绕过防火墙和端点安全；相反，你可能只需要知道如何按其设计使用一个端点。
- en: We’ll begin by learning how to discover the format of an API’s numerous requests
    from its documentation, its specification, and reverse engineering, and we’ll
    use these sources to build Postman collections so we can perform analysis across
    each request. Then we’ll walk through a simple process you can use to begin your
    API testing and discuss how you might find your first vulnerabilities, such as
    information disclosures, security misconfigurations, excessive data exposures,
    and business logic flaws.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习如何从 API 文档、规范和反向工程中发现 API 多种请求的格式，并利用这些资源构建 Postman 集合，以便在每个请求中进行分析。然后，我们将通过一个简单的过程开始你的
    API 测试，并讨论如何发现你的第一个漏洞，比如信息泄露、安全配置错误、过度的数据暴露和业务逻辑缺陷。
- en: Finding Request Information
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找请求信息
- en: If you’re used to attacking web applications, your hunt for API vulnerabilities
    should be somewhat familiar. The primary difference is that you no longer have
    obvious GUI cues such as search bars, login fields, and buttons for uploading
    files. API hacking relies on the backend operations of those items that are found
    in the GUI—namely, GET requests with query parameters and most POST/PUT/UPDATE/DELETE
    requests.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于攻击 Web 应用程序，那么你对 API 漏洞的追踪应该会有些熟悉。主要的区别是你不再有明显的 GUI 提示，如搜索栏、登录框和上传文件的按钮。API
    黑客攻击依赖于那些出现在 GUI 中的项的后端操作——也就是带有查询参数的 GET 请求，以及大多数的 POST/PUT/UPDATE/DELETE 请求。
- en: Before you craft requests to an API, you’ll need an understanding of its endpoints,
    request parameters, necessary headers, authentication requirements, and administrative
    functionality. Documentation will often point us to those elements. Therefore,
    to succeed as an API hacker, you’ll need to know how to read and use API documentation,
    as well as how to find it. Even better, if you can find a specification for an
    API, you can import it directly into Postman to automatically craft requests.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建请求之前，你需要了解其端点、请求参数、必要的头部、身份验证要求和管理功能。文档通常会指引我们找到这些元素。因此，作为一名 API 黑客，你需要学会如何阅读和使用
    API 文档，并且知道如何找到它。如果你能找到 API 的规范，更好的是，你可以将其直接导入 Postman，以自动创建请求。
- en: When you’re performing a black box API test and the documentation is truly unavailable,
    you’ll be left to reverse engineer the API requests on your own. You will need
    to thoroughly fuzz your way through the API to discover endpoints, parameters,
    and header requirements in order to map out the API and its functionality.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行黑盒 API 测试且文档完全不可用时，你将不得不自己反向工程 API 请求。你需要彻底进行模糊测试，探索 API 的端点、参数和头部要求，以便绘制出
    API 的结构及其功能。
- en: Finding Information in Documentation
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在文档中查找信息
- en: 'As you know by now, an API’s documentation is a set of instructions published
    by the API provider for the API consumer. Because public and partner APIs are
    designed with self-service in mind, a public user or a partner should be able
    to find the documentation, understand how to use the API, and do so without assistance
    from the provider. It is quite common for the documentation to be located under
    directories like the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在所知道的，API 的文档是由 API 提供者发布的供 API 使用者参考的一套说明。由于公共和合作伙伴 API 的设计目的是为了自助服务，公共用户或合作伙伴应该能够找到文档，理解如何使用
    API，并且无需提供者的帮助即可完成。文档通常会位于如下目录下：
- en: '*https://example.com/docs*'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*https://example.com/docs*'
- en: '*https://example.com/api/docs*'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*https://example.com/api/docs*'
- en: '*https://docs.example.com*'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*https://docs.example.com*'
- en: '*https://dev.example.com/docs*'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*https://dev.example.com/docs*'
- en: '*https://developer.example.com/docs*'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*https://developer.example.com/docs*'
- en: '*https://api.example.com/docs*'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*https://api.example.com/docs*'
- en: '*https://example.com/developers/documentation*'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*https://example.com/developers/documentation*'
- en: When the documentation is not publicly available, try creating an account and
    searching for the documentation while authenticated. If you still cannot find
    the docs, I have provided a couple API wordlists on GitHub that can help you discover
    API documentation through the use of a fuzzing technique called *directory brute
    force* ([https://github.com/hAPI-hacker/Hacking-APIs](https://github.com/hAPI-hacker/Hacking-APIs)).
    You can use the `subdomains_list` and the `dir_list` to brute-force web application
    subdomains and domains and potentially find API docs hosted on the site. There
    is a good chance you’ll be able to discover documentation during reconnaissance
    and web application scanning.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当文档不可公开获取时，尝试创建一个帐户并在验证身份后搜索文档。如果仍然找不到文档，我在 GitHub 上提供了一些 API 单词列表，帮助你通过一种叫做*目录暴力破解*的模糊技术发现
    API 文档（[https://github.com/hAPI-hacker/Hacking-APIs](https://github.com/hAPI-hacker/Hacking-APIs)）。你可以使用`subdomains_list`和`dir_list`来暴力破解
    Web 应用的子域名和域名，并有可能找到托管在网站上的 API 文档。在侦察和 Web 应用扫描过程中，很有可能会发现文档。
- en: If an organization’s documentation really is locked down, you still have a few
    options. First, try using your Google hacking skills to find it on search engines
    and in other recon tools. Second, use the Wayback Machine ([https://web.archive.org/](https://web.archive.org/)).
    If your target once posted their API documentation publicly and later retracted
    it, there may be an archive of their docs available. Archived documentation will
    likely be outdated, but it should give you an idea of the authentication requirements,
    naming schemes, and endpoint locations. Third, when permitted, try social engineering
    techniques to trick an organization into sharing its documentation. These techniques
    are beyond the scope of this book, but you can get creative with smishing, vishing,
    and phishing developers, sales departments, and organization partners for access
    to the API documentation. Act like a new customer trying to work with the target
    API.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个组织的文档确实被严格限制，你仍然有一些选择。首先，尝试使用你的 Google 黑客技能在搜索引擎和其他侦察工具中查找它。其次，使用 Wayback
    Machine（[https://web.archive.org/](https://web.archive.org/)）。如果目标曾公开发布过其 API
    文档并随后撤回，可能会有该文档的存档。虽然存档文档很可能已经过时，但它应该能给你一些关于身份验证要求、命名方案和端点位置的线索。第三，当允许时，尝试社交工程技术来诱使组织分享其文档。这些技巧超出了本书的范围，但你可以通过短信钓鱼、语音钓鱼和网络钓鱼等手段，创造性地欺骗开发人员、销售部门以及合作伙伴来获取
    API 文档的访问权限。假装是一个新客户，试图与目标 API 合作。
- en: Although API documentation is straightforward, there are a few elements to look
    out for. The*overview*istypically the first section of API documentation. Normally
    found at the beginning of the doc, the overview will provide a high-level introduction
    of how to connect and use the API. In addition, it could contain information about
    authentication and rate limiting.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 API 文档比较直白，但仍有一些要注意的元素。*概述*通常是 API 文档的第一部分。通常位于文档的开头，概述部分会提供如何连接和使用 API 的高层次介绍。此外，它还可能包含有关身份验证和速率限制的信息。
- en: Review the documentation for *functionality*, or the actions that you can take
    using the given API. These will be represented by a combination of an HTTP method
    (GET, PUT, POST, DELETE) and an endpoint. Every organization’s APIs will be different,
    but you can expect to find functionality related to user account management, options
    to upload and download data, different ways to request information, and so on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 审查文档的*功能*，或者你可以使用给定 API 执行的操作。这些操作通常由 HTTP 方法（GET、PUT、POST、DELETE）和端点的组合来表示。每个组织的
    API 都会有所不同，但你可以预期会找到与用户帐户管理、上传和下载数据的选项、不同的请求信息方式等相关的功能。
- en: When making a request to an endpoint, make sure you note the request *requirements*.
    Requirements could include some form of authentication, parameters, path variables,
    headers, and information included in the body of the request. The API documentation
    should tell you what it requires of you and mention in which part of the request
    that information belongs. If the documentation provides examples, use them to
    help you. Typically, you can replace the sample values with the ones you’re looking
    for. [Table 7-1](#table7-1) describes some of the conventions often used in these
    examples.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在向端点发出请求时，请确保注意请求的*要求*。要求可能包括某种身份验证、参数、路径变量、头部和请求体中的信息。API文档应告诉你它需要什么，并说明这些信息属于请求的哪一部分。如果文档提供了示例，请利用它们帮助你。通常，你可以将示例值替换为你正在寻找的值。[表7-1](#table7-1)描述了这些示例中常用的一些约定。
- en: 'Table 7-1: API Documentation Conventions'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-1：API文档约定
- en: '| **Convention** | **Example** | **Meaning** |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **约定** | **示例** | **含义** |'
- en: '| --- | --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `:` or `{}` | */user/:id* */user/{id}*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '| `:` 或 `{}` | */user/:id* */user/{id}*'
- en: '*/user/2727*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*/user/2727*'
- en: '*/account/:username*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*/account/:username*'
- en: '*/account/{username}*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*/account/{username}*'
- en: '*/account/scuttleph1sh* | The colon or curly brackets are used by some APIs
    to indicate a path variable. In other words, “:id” represents the variable for
    an ID number and “{username}” represents the account username you are trying to
    access. |'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*/account/scuttleph1sh* | 冒号或花括号被一些API用来表示路径变量。换句话说，“:id”代表一个ID号的变量，而“{username}”代表你试图访问的账户用户名。
    |'
- en: '| `[]` | */api/v1/user**?**find**=[name]* | Square brackets indicate that the
    input is optional. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `[]` | */api/v1/user**?**find**=[name]* | 方括号表示输入是可选的。 |'
- en: '| `&#124;&#124;` | “blue” &#124;&#124; “green” &#124;&#124; “red” | Double
    bars represent different possible values that can be used. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;` | “蓝色”&#124;&#124; “绿色”&#124;&#124; “红色” | 双竖线表示可以使用的不同可能值。
    |'
- en: '| `< >` | <find-function> | Angle brackets represent a DomString, which is
    a 16-bit string. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `< >` | <find-function> | 尖括号表示DomString，它是一个16位字符串。 |'
- en: 'For example, the following is a GET request from the vulnerable Pixi API documentation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是来自脆弱Pixi API文档的GET请求：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can see that the method is GET ❶, the endpoint is */api/picture/{picture_id}/likes*
    ❷, and the only requirements are the `x-access-token` header and the `picture_id`
    variable to be updated in the path ❸. Now you know that, in order to test this
    endpoint, you’ll need to figure out how to obtain a JSON Web Token (JWT) and what
    form the `picture_id` should be in.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，方法是GET ❶，端点是*/api/picture/{picture_id}/likes* ❷，唯一的要求是`x-access-token`头部和`picture_id`变量需要在路径中更新
    ❸。现在你知道了，为了测试这个端点，你需要弄清楚如何获得JSON Web Token（JWT）以及`picture_id`应该是什么格式。
- en: You can then take these instructions and insert the information into an API
    browser such as Postman (see [Figure 7-1](#figure7-1)). As you’ll see, all of
    the headers besides `x-access-token` will be automatically generated by Postman.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以将这些指令插入到API浏览器中，例如Postman（见[图7-1](#figure7-1)）。如你所见，除了`x-access-token`之外的所有头部都会被Postman自动生成。
- en: 'Here, I authenticated to the web page and found the `picture_id` listed under
    the pictures. I used the documentation to find the API registration process, which
    generated a JWT. I then took the JWT and saved it as the variable `hapi_token`;
    we will be using variables throughout this chapter. Once the token is saved as
    a variable, you can call it by using the variable name surrounded by curly brackets:
    `{{hapi_token}}`. (Note that if you are working with several collections, you’ll
    want to use environmental variables instead.) Put together, it forms a successful
    API request. You can see that the provider responded with a “200 OK,” along with
    the requested information.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我通过身份验证登录到网页，并在图片下找到了`picture_id`。我利用文档查找了API注册流程，生成了JWT。然后，我将JWT保存为变量`hapi_token`；在本章中，我们将使用变量。保存了token作为变量后，你可以通过将变量名包围在花括号中来调用它：`{{hapi_token}}`。（请注意，如果你正在处理多个集合，你可能会希望使用环境变量。）将它们组合起来，形成了一个成功的API请求。你可以看到，提供者回应了“200
    OK”，以及请求的信息。
- en: '![Screenshot of Postman with a list of headers checked and an automatically
    generated request containing those fields](image_fi/502444c07/F07001.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Postman截图，显示已勾选的头部列表，并包含这些字段的自动生成请求](image_fi/502444c07/F07001.png)'
- en: 'Figure 7-1: The fully crafted request to the Pixi endpoint */api/{picture_id}/likes*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-1：完全构造的请求，指向Pixi端点*/api/{picture_id}/likes*
- en: 'In situations where your request is improperly formed, the provider will usually
    let you know what you’ve done wrong. For instance, if you make a request to the
    same endpoint without the `x-access-token`, Pixi will respond with the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求格式不正确的情况下，提供方通常会告知您哪里出了问题。例如，如果您在没有 `x-access-token` 的情况下请求相同的端点，Pixi 会返回以下信息：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You should be able to understand the response and make any necessary adjustments.
    If you had attempted to copy and paste the endpoint without replacing the `{picture_id}`
    variable, the provider would respond with a status code of 200 OK and a body with
    square brackets (`[]`). If you are stumped by a response, return to the documentation
    and compare your request with the requirements.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够理解响应并进行必要的调整。如果您尝试复制粘贴端点，但没有替换 `{picture_id}` 变量，提供方会返回状态码 200 OK，并且响应体是一个带方括号（`[]`）的空内容。如果响应令您困惑，请返回文档并将您的请求与要求进行比较。
- en: Importing API Specifications
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入 API 规范
- en: If your target has a specification, in a format like OpenAPI (Swagger), RAML,
    or API Blueprint or in a Postman collection, finding this will be even more useful
    than finding the documentation. When provided with a specification, you can simply
    import it into Postman and review the requests that make up the collection, as
    well as their endpoints, headers, parameters, and some required variables.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的目标有规范，格式如 OpenAPI（Swagger）、RAML 或 API Blueprint，或者是 Postman 集合，找到它会比找到文档更有用。提供了规范后，您可以简单地将其导入
    Postman，并查看构成集合的请求，以及它们的端点、头信息、参数和一些必需的变量。
- en: Specifications should be as easy or as hard to find as their API documentation
    counterparts. They’ll often look like the page in [Figure 7-2](#figure7-2). The
    specification will contain plaintext and typically be in JSON format, but it could
    also be in YAML, RAML, or XML format. If the URL path doesn’t give away the type
    of specification, scan the beginning of the file for a descriptor, such as `"swagger":"2.0"`,
    to find the specification and version.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 规范的查找应当和它们的 API 文档一样容易或困难。它们通常看起来像[图 7-2](#figure7-2)中的页面。规范通常是纯文本格式，通常是 JSON
    格式，但也可能是 YAML、RAML 或 XML 格式。如果 URL 路径没有明确标明规范类型，可以扫描文件的开头，查找描述符，例如 `"swagger":"2.0"`，以确定规范及其版本。
- en: '![Screenshot of a Pixi web page containing a large amount of unformatted JSON
    data](image_fi/502444c07/F07002.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![包含大量未格式化的 JSON 数据的 Pixi 网页截图](image_fi/502444c07/F07002.png)'
- en: 'Figure 7-2: The Pixi swagger definition page'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2：Pixi Swagger 定义页面
- en: To import the specification, begin by launching Postman. Under the Workspace
    Collection section, click **Import**, select **Link**, and then add the location
    of the specification (see [Figure 7-3](#figure7-3)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入规范，首先启动 Postman。在工作区集合部分，点击**导入**，选择**链接**，然后添加规范的位置（见[图 7-3](#figure7-3)）。
- en: '![Screenshot of a Postman menu item with an “enter a URL” field and a Continue
    button](image_fi/502444c07/F07003.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 菜单项截图，包含一个“输入 URL”字段和一个继续按钮](image_fi/502444c07/F07003.png)'
- en: 'Figure 7-3: The Import Link functionality within Postman'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-3：Postman 中的导入链接功能
- en: Click **Continue**, and on the final window, select **Import**. Postman will
    detect the specification and import the file as a collection. Once the collection
    has been imported into Postman, you can review the functionality here (see [Figure
    7-4](#figure7-4)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**继续**，在最后的窗口中，选择**导入**。Postman 会检测规范并将文件导入为一个集合。集合导入到 Postman 后，您可以在此处查看其功能（见[图
    7-4](#figure7-4)）。
- en: '![Screenshot of the Postman Collections tab showing a directory structure for
    the Pixi App API. Includes subfolders and a list of POST and GET requests.](image_fi/502444c07/F07004.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Postman Collections 标签页截图，显示 Pixi App API 的目录结构，包括子文件夹和 POST、GET 请求列表。](image_fi/502444c07/F07004.png)'
- en: 'Figure 7-4: The imported Pixi App collection'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-4：导入的 Pixi 应用集合
- en: After you’ve imported a new collection, make sure to check the collection variables.
    You can display the collection editor by selecting the three horizontal circles
    at the top level of a collection and choosing **Edit**. Here, you can select the
    Variables tab within the collection editor to see the variables. You can adjust
    the variables to fit your needs and add any new variables you would like to this
    collection. In [Figure 7-5](#figure7-5), you can see where I have added the `hapi_token`
    JWT variable to my Pixi App collection.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入新集合后，确保检查集合变量。你可以通过选择集合顶部的三个水平圆圈并选择**编辑**来显示集合编辑器。在这里，你可以选择集合编辑器中的变量选项卡来查看变量。你可以根据需要调整变量，并向该集合添加任何新变量。在[图
    7-5](#figure7-5)中，你可以看到我已经将 `hapi_token` JWT 变量添加到我的 Pixi App 集合中。
- en: '![Screenshot of the Postman Variables tab with two variables, baseUrl and hapi_token,
    checked](image_fi/502444c07/F07005.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 变量选项卡的截图，显示两个变量，baseUrl 和 hapi_token，已选中](image_fi/502444c07/F07005.png)'
- en: 'Figure 7-5: The Postman collection variables editor'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-5：Postman 集合变量编辑器
- en: Once you’ve finished making updates, save your changes using the **Save** button
    at the top-right corner. Importing API specifications to Postman like this could
    save you hours of manually adding all endpoints, request methods, headers, and
    requirements.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成更新，使用右上角的**保存**按钮保存你的更改。像这样将 API 规范导入到 Postman 可以节省你手动添加所有端点、请求方法、头信息和要求的几个小时。
- en: Reverse Engineering APIs
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反向工程 API
- en: In the instance where there is no documentation and no specification, you will
    have to reverse engineer the API based on your interactions with it. We will touch
    on this process in more detail in Chapter 7. Mapping an API with several endpoints
    and a few methods can quickly grow into quite a beast to attack. To manage this
    process, build the requests under a collection in order to thoroughly hack the
    API. Postman can help you keep track of all these requests.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有文档和规范的情况下，你需要根据与 API 的交互进行反向工程。我们将在第七章中更详细地讲解这个过程。映射一个具有多个端点和一些方法的 API，可能会迅速变成一个需要攻克的庞大项目。为了管理这个过程，可以在一个集合下构建请求，从而彻底测试
    API。Postman 可以帮助你跟踪所有这些请求。
- en: There are two ways to reverse engineer an API with Postman. One way is by manually
    constructing each request. While this can be a bit cumbersome, it allows you to
    capture the precise requests you care about. The other way is to proxy web traffic
    through Postman and then use it to capture a stream of requests. This process
    makes it much easier to construct requests within Postman, but you’ll have to
    remove or ignore unrelated requests. Finally, if you obtain a valid authentication
    header, such as a token, API key, or other authentication value, add that to Kiterunner
    to help map out API endpoints.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Postman 反向工程 API 有两种方法。一种方法是手动构建每个请求。虽然这可能有点繁琐，但它可以让你捕获你关心的精确请求。另一种方法是通过
    Postman 代理 Web 流量，然后使用它捕获一系列请求。这一过程使得在 Postman 中构建请求变得更加容易，但你需要删除或忽略无关的请求。最后，如果你获得了有效的认证头，例如令牌、API
    密钥或其他认证值，可以将其添加到 Kiterunner 中，以帮助映射 API 端点。
- en: Manually Building a Postman Collection
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 手动构建 Postman 集合
- en: To manually build your own collection in Postman, select **New** under My Workspace,
    as seen at the top right of [Figure 7-6](#figure7-6).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Postman 中手动构建自己的集合，请在我的工作区下选择**新建**，如[图 7-6](#figure7-6)右上角所示。
- en: '![The Postman “My Workspace” tab, with New and Import buttons in the upper
    right](image_fi/502444c07/F07006.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Postman “我的工作区”选项卡，右上角有新建和导入按钮](image_fi/502444c07/F07006.png)'
- en: 'Figure 7-6: The workspace section of Postman'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-6：Postman 的工作区部分
- en: In the Create New window, create a new collection and then set up a `baseURL`
    variable containing your target’s URL. Creating a `baseURL` variable (or using
    one that is already present) will help you quickly make alterations to the URL
    across an entire collection. APIs can be quite large, and making small changes
    to many requests can be time-consuming. For example, suppose you want to test
    out different API path versions (such as *v1/v2/v3*) across an API with hundreds
    of unique requests. Replacing the URL with a variable means you would only need
    to update the variable in order to change the path for all requests using the
    variable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Create New”窗口中，创建一个新集合，然后设置一个 `baseURL` 变量，包含目标的 URL。创建 `baseURL` 变量（或使用已存在的变量）将帮助你快速在整个集合中修改
    URL。API 可能非常庞大，修改许多请求中的小细节可能会很耗时。例如，假设你想测试一个有数百个独立请求的 API 的不同路径版本（如 *v1/v2/v3*）。使用变量替换
    URL 意味着你只需要更新该变量，就能改变所有使用该变量的请求路径。
- en: Now, any time you discover an API request, you can add it to the collection
    (see [Figure 7-7](#figure7-7)).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次你发现一个 API 请求时，都可以将其添加到集合中（见 [图 7-7](#figure7-7)）。
- en: '![Screenshot of Postman showing the menu item “Reqres Testing” right-clicked
    and “Add Request” selected in a pop-up menu](image_fi/502444c07/F07007.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 界面截图，显示右键点击菜单项“Reqres Testing”，并在弹出菜单中选择“Add Request”](image_fi/502444c07/F07007.png)'
- en: 'Figure 7-7: The Add Request option within a new Postman collection'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-7：新建 Postman 集合中的 Add Request 选项
- en: Select the collection options button (the three horizontal circles) and select
    **Add Request**. If you want to further organize the requests, you can create
    folders to group the requests together. Once you have built a collection, you
    can use it as though it were documentation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 选择集合选项按钮（三个水平圆圈），然后选择 **Add Request**。如果你想进一步组织请求，可以创建文件夹将请求归类。当你构建完集合后，可以像使用文档一样使用它。
- en: Building a Postman Collection by Proxy
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过代理构建 Postman 集合
- en: The second way to reverse engineer an API is to proxy web browser traffic through
    Postman and clean up the requests so that only the API-related ones remain. Let’s
    reverse engineer the crAPI API by proxying our browser traffic to Postman.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 逆向工程 API 的第二种方法是通过 Postman 代理网页浏览器流量，并清理请求，确保仅保留与 API 相关的请求。让我们通过将浏览器流量代理到 Postman
    来逆向工程 crAPI API。
- en: First, open Postman and create a collection for crAPI. At the top right of Postman
    is a signal button that you can select to open the Capture requests and cookies
    window (see [Figure 7-8](#figure7-8)).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开 Postman 并为 crAPI 创建一个集合。在 Postman 界面右上角有一个信号按钮，你可以选择它来打开“Capture requests
    and cookies”窗口（见 [图 7-8](#figure7-8)）。
- en: '![The Postman “Capture Requests and Cookies” window with “Capture requests”
    set to On, the port set to 5555, and the requests saved to the crAPI collection](image_fi/502444c07/F07008.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Postman “Capture Requests and Cookies” 窗口，显示“Capture requests”已设置为开启，端口设置为
    5555，请求被保存到 crAPI 集合](image_fi/502444c07/F07008.png)'
- en: 'Figure 7-8: The Postman Capture requests and cookies window'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-8：Postman 捕获请求和 Cookies 窗口
- en: Make sure the port number matches the one you’ve configured in FoxyProxy. Back
    in Chapter 4, we set this to port 5555\. Save requests to your crAPI collection.
    Finally, set Capture Requests to **On**. Now navigate to the crAPI web application
    and set FoxyProxy to forward traffic to Postman.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 确保端口号与在 FoxyProxy 中配置的端口一致。在第 4 章中，我们将其设置为端口 5555。将请求保存到你的 crAPI 集合中。最后，将“Capture
    Requests”设置为 **On**。现在，导航到 crAPI 网页应用并设置 FoxyProxy 将流量转发到 Postman。
- en: As you start using the web application, every request will be sent through Postman
    and added to the selected collection. Use every feature of the web application,
    including registering a new account, authenticating, performing a password reset,
    clicking every link, updating your profile, using the community forum, and navigating
    to the shop. Once you’ve finished thoroughly using the web application, stop your
    proxy and review the crAPI collection made within Postman.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始使用该网页应用时，每个请求都会通过 Postman 发送并添加到选定的集合中。使用网页应用的每个功能，包括注册新账号、身份验证、执行密码重置、点击每个链接、更新个人资料、使用社区论坛和访问商店。彻底使用完网页应用后，停止代理并查看在
    Postman 中创建的 crAPI 集合。
- en: One downside of building a collection this way is that you’ll have captured
    several requests that aren’t API related. You will need to delete these requests
    and organize the collection. Postman allows you to create folders to group similar
    requests, and you can rename as many requests as you’d like. In [Figure 7-9](#figure7-9),
    you can see that I grouped requests by the different endpoints.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式构建集合的一个缺点是，你将捕获到一些与 API 无关的请求。你需要删除这些请求并整理集合。Postman 允许你创建文件夹来分组相似的请求，并且你可以根据需要重命名任何请求。在
    [图 7-9](#figure7-9) 中，你可以看到我按不同的端点对请求进行了分组。
- en: '![Screenshot of crAPI requests in Postman, grouped into Community, Identity,
    and Workshop folders](image_fi/502444c07/F07009.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 中的 crAPI 请求截图，按社区、身份和工作坊文件夹进行分组](image_fi/502444c07/F07009.png)'
- en: 'Figure 7-9: An organized crAPI collection'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-9：一个组织良好的 crAPI 集合
- en: Adding API Authentication Requirements to Postman
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 API 认证要求添加到 Postman 中
- en: Once you’ve compiled the basic request information in Postman, look for the
    API’s authentication requirements. Most APIs with authentication requirements
    will have a process for obtaining access, typically by sending credentials over
    a POST request or OAuth or else by using a method separate from the API, such
    as email, to obtain a token. Decent documentation should make the authentication
    process clear. In the next chapter, we will dedicate time to testing the API authentication
    processes. For now, we will use the API authentication requirements to start using
    the API as it was intended.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在 Postman 中编译了基本的请求信息，接下来查找 API 的认证要求。大多数有认证要求的 API 都会提供获取访问权限的流程，通常是通过 POST
    请求发送凭据，或者通过 OAuth，或者使用与 API 分开的方式，比如电子邮件，来获取令牌。良好的文档应该能清楚地说明认证过程。在下一章中，我们将专门花时间测试
    API 认证流程。目前，我们将利用 API 认证要求来按预期使用 API。
- en: As an example of a somewhat typical authentication process, let’s register and
    authenticate to the Pixi API. Pixi’s Swagger documentation tells us that we need
    to make a request with both `user` and `pass` parameters to the */api/register*
    endpoint to receive a JWT. If you’ve imported the collection, you should be able
    to find and select the “Create Authentication Token” request in Postman (see [Figure
    7-10](#figure7-10)).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个典型的认证过程示例，让我们注册并认证到 Pixi API。Pixi 的 Swagger 文档告诉我们，我们需要向 */api/register*
    端点发送一个包含 `user` 和 `pass` 参数的请求，以获得 JWT。如果你已经导入了集合，你应该能够在 Postman 中找到并选择“创建认证令牌”请求（见
    [图 7-10](#figure7-10)）。
- en: '![Screenshot of a POST request in Postman, with a long, highlighted string
    value for the “token” header value](image_fi/502444c07/F07010.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 中的 POST 请求截图，其中“token”头的值为长的高亮字符串](image_fi/502444c07/F07010.png)'
- en: 'Figure 7-10: A successful registration request to the Pixi API'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-10：成功的 Pixi API 注册请求
- en: The preconfigured request contains parameters you may not be aware of and are
    not required for authentication. Instead of using the preconfigured information,
    I crafted the response by selecting the `x-www-form-urlencoded` option with the
    only parameters necessary (`user` and `pass`). I then added the keys `user` and
    `pass` and filled in the values shown in [Figure 7-10](#figure7-10). This process
    resulted in successful registration, as indicated by the 200 OK status code and
    the response of a token.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 预配置的请求包含一些你可能不知道的参数，而这些参数并不是认证所必需的。与其使用预配置的信息，我选择了 `x-www-form-urlencoded` 选项，并仅使用必要的参数（`user`
    和 `pass`）。然后我添加了 `user` 和 `pass` 这两个键，并填写了 [图 7-10](#figure7-10) 中显示的值。这个过程导致了成功的注册，状态码为
    200 OK，并返回了一个令牌。
- en: It’s a good idea to save successful authentication requests so you can repeat
    them when needed, as tokens could be set to expire quickly. Additionally, API
    security controls could detect malicious activity and revoke your token. As long
    as your account isn’t blocked, you should be able to generate another token and
    continue your testing. Also, be sure to save your token as a collection or environmental
    variable. That way, you’ll be able to quickly reference it in subsequent requests
    instead of having to continuously copy in the giant string.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 保存成功的认证请求是个好主意，这样你就能在需要时重复使用它们，因为令牌可能会快速过期。此外，API 安全控制可能会检测到恶意活动并撤销你的令牌。只要你的帐户没有被封锁，你应该能够生成另一个令牌并继续测试。此外，确保将令牌保存为集合或环境变量。这样，你就可以在后续请求中快速引用它，而不必每次都复制那个巨大的字符串。
- en: The next thing you should do when you get an authentication token or API key
    is to add it to Kiterunner. We used Kiterunner in Chapter 6 to map out a target’s
    attack surface as an unauthenticated user, but adding an authentication header
    to the tool will greatly improve your results. Not only will Kiterunner provide
    you with a list of valid endpoints, but it will also hand you interesting HTTP
    methods and parameters.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你获取到认证令牌或 API 密钥后，接下来应该做的事是将它添加到 Kiterunner 中。在第六章中，我们作为未认证用户使用 Kiterunner
    绘制目标的攻击面，但向工具中添加认证头将大大提升你的结果。不仅如此，Kiterunner 会为你提供有效端点的列表，还会显示有趣的 HTTP 方法和参数。
- en: 'In the following example, we use the `x-access-token` provided to us during
    the Pixi registration process. Take the full authorization header and add it to
    your Kiterunner scan with the `-H` option:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用在 Pixi 注册过程中提供的 `x-access-token`。将完整的授权头添加到你的 Kiterunner 扫描中，使用 `-H`
    选项：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Adding authorization headers to your Kiterunner requests should improve your
    scan results, as it will allow the scanner to access endpoints it otherwise wouldn’t
    have access to.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 向 Kiterunner 请求添加授权头应该能提高你的扫描结果，因为它将允许扫描器访问原本无法访问的端点。
- en: Analyzing Functionality
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能分析
- en: Once you have the API’s information loaded into Postman, you should begin to
    look for issues. This section covers a method for initially testing the functionality
    of API endpoints. You’ll begin by using the API as it was intended. In the process,
    you’ll pay attention to the responses and their status codes and error messages.
    In particular, you’ll seek out functionality that interests you as an attacker,
    especially if there are indications of information disclosure, excessive data
    exposure, and other low-hanging vulnerabilities. Look for endpoints that could
    provide you with sensitive information, requests that allow you to interact with
    resources, areas of the API that allow you to inject a payload, and administrative
    actions. Beyond that, look for any endpoint that allows you to upload your own
    payload and interact with resources.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将 API 的信息加载到 Postman 中，你应该开始寻找问题。本节将介绍一种初步测试 API 端点功能的方法。你将从按预期使用 API 开始。在这个过程中，你需要关注响应、它们的状态码和错误信息。特别是，你要寻找作为攻击者可能感兴趣的功能，尤其是如果有信息泄露、数据暴露过度和其他容易利用的漏洞的迹象。寻找那些可能提供敏感信息的端点、允许你与资源交互的请求、允许你注入有效载荷的
    API 区域，以及管理操作。除此之外，寻找任何允许你上传自己的有效载荷并与资源交互的端点。
- en: 'To streamline this process, I recommend proxying Kiterunner’s results through
    Burp Suite so you can replay interesting requests. In past chapters, I showed
    you the replay feature of Kiterunner, which lets you review individual API requests
    and responses. To proxy a replay through another tool, you will need to specify
    the address of the proxy receiver:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这个过程，我建议通过 Burp Suite 代理 Kiterunner 的结果，这样你就可以重放感兴趣的请求。在之前的章节中，我向你展示了 Kiterunner
    的重放功能，它让你能够查看单独的 API 请求和响应。要通过其他工具代理重放，你需要指定代理接收器的地址：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This request uses Kiterunner’s replay option, as specified by `kb replay`. The
    `-w` option specifies the wordlist used, and `proxy` specifies the Burp Suite
    proxy. The remainder of the command is the original Kiterunner output. In [Figure
    7-11](#figure7-11), you can see that the Kiterunner replay was successfully captured
    in Burp Suite.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求使用了 Kiterunner 的重放选项，正如 `kb replay` 所指定的那样。`-w` 选项指定了使用的字典，而 `proxy` 指定了
    Burp Suite 代理。命令的其余部分是原始的 Kiterunner 输出。在 [图 7-11](#figure7-11) 中，你可以看到 Kiterunner
    的重放请求成功被 Burp Suite 捕获。
- en: '![Screenshot of a GET request in Burp Suite](image_fi/502444c07/F07011.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Burp Suite 中 GET 请求的截图](image_fi/502444c07/F07011.png)'
- en: 'Figure 7-11: A Kiterunner request intercepted with Burp Suite'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-11：通过 Burp Suite 截获的 Kiterunner 请求
- en: Now you can analyze the requests and use Burp Suite to repeat all interesting
    results captured in Kiterunner.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以分析这些请求，并使用 Burp Suite 重复所有在 Kiterunner 中捕获到的有趣结果。
- en: Testing Intended Use
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试预期用途
- en: Start by using the API endpoints as intended. You could begin this process with
    a web browser, but web browsers were not meant to interact with APIs, so you might
    want to switch to Postman. Use the API documentation to see how you should structure
    your requests, what headers to include, what parameters to add, and what to supply
    for authentication. Then send the requests. Adjust your requests until you receive
    successful responses from the provider.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先按照预期使用 API 端点。你可以从浏览器开始这个过程，但浏览器并不是为了与 API 交互而设计的，所以你可能想切换到 Postman。使用 API
    文档查看如何构建请求，应该包含哪些头信息，添加哪些参数，以及如何进行身份验证。然后发送请求。调整你的请求，直到从服务提供商处收到成功的响应。
- en: 'As you proceed, ask yourself these questions:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续进行时，问问自己以下问题：
- en: What sorts of actions can I take?
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可以采取什么操作？
- en: Can I interact with other user accounts?
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可以与其他用户账户进行交互吗？
- en: What kinds of resources are available?
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有哪些资源可用？
- en: When I create a new resource, how is that resource identified?
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我创建一个新资源时，如何识别该资源？
- en: Can I upload a file? Can I edit a file?
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可以上传文件吗？我可以编辑文件吗？
- en: There is no need to make every possible request if you are manually working
    with the API, but make a few. Of course, if you have built a collection in Postman,
    you can easily make every possible request and see what response you get from
    the provider.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你手动与 API 交互，则不需要进行每一个可能的请求，但可以进行一些请求。当然，如果你在 Postman 中构建了一个集合，你可以轻松地进行所有可能的请求，并查看你从服务提供商那里收到的响应。
- en: For example, send a request to Pixi’s */api/user/info* endpoint to see what
    sort of response you receive from the application (see [Figure 7-12](#figure7-12)).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，向 Pixi 的 */api/user/info* 端点发送请求，看看你从应用程序收到什么响应（见 [图 7-12](#figure7-12)）。
- en: In order to make a request to this endpoint, you must use the GET method. Add
    the *{{baseUrl}}/api/user/info* endpoint to the URL field. Then add the `x-access-token`
    to the request header. As you can see, I have set the JWT as the variable `{{hapi_token}}`.
    If you are successful, you should receive a 200 OK status code, seen just above
    the response.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向此端点发出请求，你必须使用 GET 方法。将 *{{baseUrl}}/api/user/info* 端点添加到 URL 字段。然后将 `x-access-token`
    添加到请求头中。如你所见，我已将 JWT 设置为变量 `{{hapi_token}}`。如果成功，你应该会收到 200 OK 状态码，显示在响应上方。
- en: '![Screenshot of a request in Postman with the x-access-token variable selected](image_fi/502444c07/F07012.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Postman 中请求的截图，选择了 x-access-token 变量](image_fi/502444c07/F07012.png)'
- en: 'Figure 7-12: Setting the `x-access-token` as the variable for the JWT'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-12：将 `x-access-token` 设置为 JWT 的变量
- en: Performing Privileged Actions
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行特权操作
- en: If you’ve gained access to an API’s documentation, any sort of administrative
    actions listed there should grab your attention. Privileged actions will often
    lead to additional functionality, information, and control. For example, admin
    requests could give you the ability to create and delete users, search for sensitive
    user information, enable and disable accounts, add users to groups, manage tokens,
    access logs, and more. Luckily for us, admin API documentation information is
    often available for all to see due to the self-service nature of APIs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经获得了 API 文档的访问权限，文档中列出的任何管理操作都应该引起你的注意。特权操作通常会带来额外的功能、信息和控制。例如，管理员请求可能让你有能力创建和删除用户，搜索敏感用户信息，启用和禁用账户，将用户添加到组中，管理令牌，访问日志等。幸运的是，由于
    API 的自助性质，管理员 API 文档信息通常对所有人开放。
- en: 'If security controls are in place, administrative actions should have authorization
    requirements, but never assume that they actually do. My recommendation is to
    test these actions in several phases: first as an unauthenticated user, then as
    a low-privileged user, and finally as an administrative user. When you make the
    administrative requests as documented but without any authorization requirements,
    you should receive some sort of unauthorized response if any security controls
    are in place.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安全控制到位，管理操作应该有授权要求，但永远不要假设它们真的有。我建议将这些操作分几个阶段进行测试：首先作为未认证用户，其次作为低权限用户，最后作为管理员用户。当你按照文档进行管理员请求，但没有任何授权要求时，如果有安全控制，应该会收到某种未经授权的响应。
- en: You’ll likely have to find a way to gain access to the administrative requirements.
    In the case of the Pixi, the documentation in [Figure 7-13](#figure7-13) clearly
    shows us that we need an `x-access-token` to perform the GET request to the */api/admin/users/search*
    endpoint. When you test this administrative endpoint, you’ll see that Pixi has
    basic security controls in place to prevent unauthorized users from using administrative
    endpoints.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要找到一种方法来获取管理员权限。在 Pixi 的案例中，[图 7-13](#figure7-13)中的文档明确告诉我们，我们需要一个 `x-access-token`
    才能对 */api/admin/users/search* 端点执行 GET 请求。当你测试这个管理员端点时，你会发现 Pixi 已经采取了基本的安全控制措施，防止未授权用户使用管理员端点。
- en: '![Screenshot of the Pixi documentation for the admins endpoint](image_fi/502444c07/F07013.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Pixi 管理员端点文档截图](image_fi/502444c07/F07013.png)'
- en: 'Figure 7-13: The requirements for a Pixi administrative endpoint'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-13：Pixi 管理员端点的要求
- en: Making sure that the most basic security controls are in place is a useful practice.
    More importantly, protected administrative endpoints establish a goal for us for
    the next steps in our testing; we now know that in order to use this functionality,
    we need to obtain an admin JWT.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 确保最基本的安全控制到位是一个有用的做法。更重要的是，受保护的管理员端点为我们接下来的测试步骤设立了目标；我们现在知道，为了使用此功能，我们需要获得一个管理员
    JWT。
- en: Analyzing API Responses
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析 API 响应
- en: As most APIs are meant to be self-service, developers will often leave some
    hint in the API responses when things don’t go as planned. One of the most basic
    skills you’ll need as an API hacker is the ability to analyze the responses you
    receive. This is initially done by issuing a request and reviewing the response
    status code, headers, and content included in the body.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数 API 是为了自助服务而设计的，开发者通常会在 API 响应中留下某些提示，以便在事情进展不顺利时帮助我们。作为 API 黑客，你需要掌握的最基本技能之一就是分析你收到的响应。这通常是通过发起请求并查看响应状态码、头部信息以及响应体中的内容来完成的。
- en: First check that you are receiving the responses you expect. API documentation
    can sometimes provide examples of what you could receive as a response. However,
    once you begin using the API in unintended ways, you will no longer know what
    you’ll get as a response, which is why it helps to first use the API as it was
    intended before moving into attack mode. Developing a sense of regular and irregular
    behavior will make vulnerabilities obvious.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查你是否收到了预期的响应。API 文档有时会提供你可能收到的响应示例。然而，一旦你开始以非预期的方式使用 API，你将无法知道自己会得到什么响应，这就是为什么在进入攻击模式之前，先按照
    API 设计的方式使用它会更有帮助。培养对正常行为和异常行为的敏感度会使漏洞变得更加明显。
- en: 'At this point, your search for vulnerabilities begins. Now that you’re interacting
    with the API, you should be able to find information disclosures, security misconfigurations,
    excessive data exposures, and business logic flaws, all without too much technical
    finesse. It’s time to introduce the most important ingredient of hacking: the
    adversarial mindset. In the following sections, I will show you what to look for.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你的漏洞搜索正式开始了。既然你已经在与 API 进行交互，你应该能够找到信息泄露、安全配置错误、过度的数据暴露以及业务逻辑漏洞，而且这一切不需要太高的技术技巧。现在是时候引入黑客攻击中最重要的要素：对抗性思维。接下来的部分，我将告诉你应该寻找什么。
- en: Finding Information Disclosures
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找信息泄露
- en: Information disclosure will often be the fuel for our testing. Anything that
    helps our exploitation of an API can be considered an information disclosure,
    whether it’s interesting status codes, headers, or user data. When making requests,
    you should review responses for software information, usernames, email addresses,
    phone numbers, password requirements, account numbers, partner company names,
    and any information that your target claims is useful.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 信息泄露通常是我们测试的燃料。任何帮助我们利用 API 的信息都可以视为信息泄露，无论是有趣的状态码、头部信息还是用户数据。在发起请求时，你应该检查响应中的软件信息、用户名、电子邮件地址、电话号码、密码要求、账户号码、合作公司名称，以及目标声明为有用的任何信息。
- en: Headers can inadvertently reveal more information about the application than
    necessary. Some, like `X-powered-by`, do not serve much of a purpose and often
    disclose information about the backend. Of course, this alone won’t lead to exploitation,
    but it can help us know what sort of payload to craft and reveal potential application
    weaknesses.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 头部信息可能会无意中泄露应用程序不必要的更多信息。有些头部信息，例如 `X-powered-by`，基本没有作用，而且常常暴露后台信息。当然，仅凭这些信息不能直接导致利用，但它可以帮助我们知道应该制作什么样的有效负载，并揭示潜在的应用弱点。
- en: Status codes can also disclose useful information. If you were to brute-force
    the paths of different endpoints and receive responses with the status codes 404
    Not Found and 401 Unauthorized, you could map out the API’s endpoints as an unauthorized
    user. This simple information disclosure can get much worse if these status codes
    were returned for requests with different query parameters. Say you were able
    to use a query parameter for a customer’s phone number, account number, and email
    address. Then you could brute-force these items, treating the 404s as nonexistent
    values and the 401s as existing ones. Now, it probably shouldn’t take too much
    imagination to see how this sort of information could assist you. You could perform
    password spraying; test password resend mechanisms, or conduct phishing, vishing,
    and smishing. There is also a chance you could pair query parameters together
    and extract personally identifiable information from the unique status codes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 状态码也可以泄露有用的信息。如果你通过暴力破解不同端点的路径并收到状态码为404 Not Found和401 Unauthorized的响应，你就可以将API的端点映射出来，作为一个未授权用户。这种简单的信息泄露如果出现在带有不同查询参数的请求中，情况会变得更加糟糕。假设你能够使用查询参数，比如客户的电话号码、账户号码和电子邮件地址。然后，你可以暴力破解这些项目，将404视为不存在的值，将401视为存在的值。现在，可能不需要太多的想象力就能看出，这种信息如何对你有所帮助。你可以进行密码喷洒；测试密码重发机制，或者进行钓鱼、语音钓鱼和短信钓鱼。你也有可能将查询参数配对，利用独特的状态码提取个人身份信息。
- en: API documentation can itself be an information disclosure risk. For instance,
    it is often an excellent source of information about business logic vulnerabilities,
    as discussed in Chapter 3. Moreover, administrative API documentation will often
    tell you the admin endpoints, the parameters required, and the method to obtain
    the specified parameters. This information can be used to aid you in authorization
    attacks (such as BOLA and BFLA), which are covered in later chapters.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: API文档本身可能也是一种信息泄露风险。例如，它通常是业务逻辑漏洞的一个极好信息来源，正如第三章所讨论的那样。此外，管理API文档通常会告诉你管理员端点、所需的参数，以及获取指定参数的方法。这些信息可以用来帮助你进行授权攻击（例如BOLA和BFLA），这些内容将在后续章节中讨论。
- en: When you start exploiting API vulnerabilities, be sure to track which headers,
    unique status codes, documentation, or other hints were handed to you by the API
    provider.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始利用API漏洞时，务必记录下API提供者给你提供的哪些头信息、独特的状态码、文档或其他线索。
- en: Finding Security Misconfigurations
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找安全配置错误
- en: Security misconfigurations represent a large variety of items. At this stage
    of your testing, look for verbose error messaging, poor transit encryption, and
    other problematic configurations. Each of these issues can be useful later for
    exploiting the API.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 安全配置错误包括多种不同的项。在你测试的这个阶段，寻找冗长的错误信息、较差的传输加密和其他有问题的配置。这些问题中的每一个都可以在以后利用API时派上用场。
- en: Verbose Errors
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 冗长的错误信息
- en: Error messages exist to help the developers on both the provider and consumer
    sides understand what has gone wrong. For example, if the API requires you to
    POST a username and password in order to obtain an API token, check how the provider
    responds to both existing and nonexistent usernames. A common way to respond to
    nonexistent usernames is with the error “User does not exist, please provide a
    valid username.” When a user does exist but you’ve used the wrong password, you
    may get the error “Invalid password.” This small difference in error response
    is an information disclosure that you can use to brute-force usernames, which
    can then be leveraged in later attacks.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息旨在帮助提供方和消费方的开发人员理解发生了什么错误。例如，如果API要求你POST用户名和密码以获取API令牌，检查提供方如何回应已存在和不存在的用户名。对于不存在的用户名，常见的回应方式是错误信息“用户不存在，请提供有效的用户名。”当用户名存在但密码错误时，你可能会收到错误信息“密码无效。”这种小小的错误响应差异是一种信息泄露，你可以利用它暴力破解用户名，进而在后续攻击中使用。
- en: Poor Transit Encryption
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 较差的传输加密
- en: Finding an API in the wild without transit encryption is rare. I’ve only come
    across this in instances when the provider believes its API contains only nonsensitive
    public information. In situations like this, the challenge is to see whether you
    can discover any sensitive information by using the API. In all other situations,
    make sure to check that the API has valid transit encryption. If the API is transmitting
    any sensitive information, HTTPS should be in use.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在野外发现没有传输加密的API是罕见的。我仅在提供商认为其API只包含不敏感的公共信息时遇到过这种情况。在这种情况下，挑战在于你是否能够通过使用API发现任何敏感信息。在所有其他情况下，请务必检查API是否具有有效的传输加密。如果API传输任何敏感信息，应该使用HTTPS。
- en: In order to attack an API with transit insecurities, you would need to perform
    a *man-in-the-middle (MITM)* attack in which you somehow intercept the traffic
    between a provider and a consumer. Because HTTP sends unencrypted traffic, you’ll
    be able to read the intercept requests and responses. Even if HTTPS is in use
    on the provider’s end, check whether a consumer can initiate HTTP requests and
    share their tokens in the clear.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了攻击具有传输安全漏洞的API，你需要执行*中间人（MITM）*攻击，拦截提供商和消费者之间的流量。因为HTTP发送的是未加密的流量，你将能够读取拦截到的请求和响应。即使在提供商端使用了HTTPS，也要检查消费者是否能发起HTTP请求并将其令牌以明文形式共享。
- en: Use a tool like Wireshark to capture network traffic and spot plaintext API
    requests passing across the network you’re connected to. In [Figure 7-14](#figure7-14),
    a consumer has made an HTTP request to the HTTPS-protected *reqres.in*. As you
    can see, the API token within the path is clear as day.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像Wireshark这样的工具来捕获网络流量，查找通过你所连接的网络传输的明文API请求。在[图7-14](#figure7-14)中，消费者已向HTTPS保护的*reqres.in*发出了HTTP请求。如你所见，路径中的API令牌是明文的。
- en: '![Screenshot of Wireshark showing a GET request with a user token included
    in the URL](image_fi/502444c07/F07014.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![Wireshark截图，显示一个GET请求，其中URL中包含用户令牌](image_fi/502444c07/F07014.png)'
- en: 'Figure 7-14: A Wireshark capture of a user’s token in an HTTP request'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-14：Wireshark捕获的HTTP请求中的用户令牌
- en: Problematic Configurations
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置问题
- en: Debugging pages are a form of security misconfiguration that can expose plenty
    of useful information. I have come across many APIs that had debugging enabled.
    You have a better chance of finding this sort of misconfiguration in newly developed
    APIs and in testing environments. For example, in [Figure 7-15](#figure7-15),
    not only can you see the default landing page for 404 errors and all of this provider’s
    endpoints, but you can also see that the application is powered by Django.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 调试页面是一种安全配置错误，可能暴露大量有用信息。我遇到过许多启用了调试功能的API。在新开发的API和测试环境中，发现这种配置错误的机会更大。例如，在[图7-15](#figure7-15)中，你不仅可以看到404错误的默认着陆页和该提供商的所有端点，还可以看到应用程序是由Django驱动的。
- en: '![Screenshot of webpage displaying a 404 error, a list of API endpoints, and
    a message that reads “You are seeing this error because you have DEBUG = True
    in your Django settings file.”](image_fi/502444c07/F07015.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![显示404错误的网页截图，列出API端点，并显示一条消息：“你看到这个错误是因为在Django设置文件中将DEBUG = True。”](image_fi/502444c07/F07015.png)'
- en: 'Figure 7-15: The debug page of Tiredful API'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-15：Tiredful API的调试页面
- en: This finding could trigger you to research what sorts of malicious things can
    be done when the Django debug mode is enabled.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个发现可能会促使你研究在启用Django调试模式时可能会发生的恶意操作。
- en: Finding Excessive Data Exposures
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现过度数据暴露
- en: As discussed in Chapter 3, excessive data exposure is a vulnerability that takes
    place when the API provider sends more information than the API consumer requests.
    This happens because the developers designed the API to depend on the consumer
    to filter results.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如第3章所述，过度的数据暴露是一种漏洞，发生在API提供商发送比API消费者请求更多的信息时。这是因为开发者设计API时依赖于消费者过滤结果。
- en: When testing for excessive data exposure on a large scale, it’s best to use
    a tool like Postman’s Collection Runner, which helps you make many requests quickly
    and provides you with an easy way to review the results. If the provider responds
    with more information than you needed, you could have found a vulnerability.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在大规模测试数据暴露过多时，最好使用像Postman的Collection Runner这样的工具，它可以帮助你快速发出许多请求，并提供一种便捷的方式来查看结果。如果提供商回应的内容超过了你所需的信息，那么你可能发现了一个漏洞。
- en: 'Of course, not every excess byte of data should be considered a vulnerability;
    watch for excess information that can be useful in an attack. True excessive data
    exposure vulnerabilities are often fairly obvious because of the sheer quantity
    of data provided. Imagine an endpoint with the ability to search for usernames.
    If you queried for a username and received the username plus a timestamp of the
    user’s last login, this is excess data, but it’s hardly useful. Now, if you queried
    for the username and were provided with a username plus the user’s full name,
    email, and birthday, you have a finding. For example, say a GET request to *https://secure.example.com/api/users/hapi_hacker*
    was supposed to give you information about our hapi_hacker account, but it responded
    with the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并不是每一个多余的数据字节都应视为漏洞；你应该关注那些在攻击中可能有用的多余信息。真正的过度数据暴露漏洞通常是显而易见的，因为提供的数据量极大。想象一个端点能够搜索用户名。如果你查询一个用户名并收到了该用户名加上用户最后登录的时间戳，这是多余的数据，但几乎没有用处。现在，如果你查询用户名并且得到了该用户名、用户的全名、电子邮件和生日，你就找到了一个漏洞。例如，假设对*https://secure.example.com/api/users/hapi_hacker*发出的GET请求本应返回有关hapi_hacker账户的信息，但响应如下：
- en: '[PRE4]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, a request was made for the hapi_hacker account, but the administrator’s
    account and security settings were included in the response. Not only does the
    response provide you with an administrator’s email address and username, but it
    also lets you know whether they are an administrator without multifactor authentication
    enabled. This vulnerability is fairly common and can be extremely useful for obtaining
    private information. Also, if there is an excessive data exposure vulnerability
    on one endpoint and method, you can bet there are others.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，曾请求过hapi_hacker账户，但响应中却包含了管理员账户和安全设置。响应不仅提供了管理员的电子邮件地址和用户名，还告诉你该管理员是否启用了多因素认证。这种漏洞相当常见，并且对于获取私人信息非常有用。此外，如果一个端点和方法存在过多的数据暴露漏洞，你可以肯定，其他地方也会有类似的问题。
- en: Finding Business Logic Flaws
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现业务逻辑缺陷
- en: 'OWASP provides the following advice about testing for business logic flaws
    ([https://owasp.org/www-community/vulnerabilities/Business_logic_vulnerability](https://owasp.org/www-community/vulnerabilities/Business_logic_vulnerability)):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: OWASP提供了关于测试业务逻辑漏洞的建议（[https://owasp.org/www-community/vulnerabilities/Business_logic_vulnerability](https://owasp.org/www-community/vulnerabilities/Business_logic_vulnerability)）：
- en: You’ll need to evaluate the threat agents who could possibly exploit the problem
    and whether it would be detected. Again, this will take a strong understanding
    of the business. The vulnerabilities themselves are often quite easy to discover
    and exploit without any special tools or techniques, as they are a supported part
    of the application.
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你需要评估可能利用该问题的威胁代理，以及是否能够被检测到。同样，这需要对业务有深刻的理解。这些漏洞本身通常非常容易被发现和利用，无需任何特殊工具或技术，因为它们是应用程序的支持部分。
- en: In other words, because business logic flaws are unique to each business and
    its logic, it is difficult to anticipate the specifics of the flaws you will find.
    Finding and exploiting these flaws is usually a matter of turning the features
    of an API against the API provider.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，由于业务逻辑漏洞是每个业务及其逻辑特有的，因此很难预见你将发现哪些具体的漏洞。发现并利用这些漏洞通常只是将API的功能反过来用于攻击API提供者。
- en: 'Business logic flaws could be discovered as early as when you review the API
    documentation and find directions for how not to use the application. (Chapter
    3 lists the kinds of descriptions that should instantly make your vulnerability
    sensors go off.) When you find these, your next step should be obvious: do the
    opposite of what the documentation recommends! Consider the following examples:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑缺陷可能会在你查看API文档时就被发现，例如发现文档中指出了如何不使用该应用程序。（第三章列出了那些应该立刻引起你漏洞警觉的描述类型。）当你发现这些时，你的下一步应该显而易见：做文档中不推荐的事情！考虑以下示例：
- en: '*If the documentation tells you not to perform action X*, perform action X.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如果文档告诉你不要执行X操作*，那就执行X操作。'
- en: '*If the documentation tells you that data sent in a certain format isn’t validated*,
    upload a reverse shell payload and try to find ways to execute it. Test the size
    of file that can be uploaded. If rate limiting is lacking and file size is not
    validated, you’ve discovered a serious business logic flaw that will lead to a
    denial of service.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*If the documentation tells you that all file formats are accepted*, upload
    files and test all file extensions. You can find a list of file extensions for
    this purpose called *file-ext* ([https://github.com/hAPI-hacker/Hacking-APIs/tree/main/Wordlists](https://github.com/hAPI-hacker/Hacking-APIs/tree/main/Wordlists)).
    If you can upload these sorts of files, the next step would be to see if you can
    execute them.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to relying on clues in the documentation, consider the features
    of a given endpoint to determine how a nefarious person could use them to their
    advantage. The challenging part about business logic flaws is that they are unique
    to each business. Identifying features as vulnerabilities will require putting
    on your evil genius cap and using your imagination.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to find information about API requests so you
    can load it into Postman and begin your testing. Then you learned to use an API
    as it was intended and analyze responses for common vulnerabilities. You can use
    the described techniques to begin testing APIs for vulnerabilities. Sometimes
    all it takes is using the API with an adversarial mindset to make critical findings.
    In the next chapter, we will attack the API’s authentication mechanisms.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Lab #4: Building a crAPI Collection and Discovering Excessive Data Exposure'
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Chapter 6, we discovered the existence of the crAPI API. Now we will use
    what we’ve learned from this chapter to begin analyzing crAPI endpoints. In this
    lab, we will register an account, authenticate to crAPI, and analyze various features
    of the application. In Chapter 8, we’ll attack the API’s authentication process.
    For now, I will guide you through the natural progression from browsing a web
    application to analyzing API endpoints. We’ll start by building a request collection
    from scratch and then work our way toward finding an excessive data exposure vulnerability
    with serious implications.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: In the web browser of your Kali machine, navigate to the crAPI web application.
    In my case, the vulnerable app is located at 192.168.195.130, but yours might
    be different. Register an account with the crAPI web application. The crAPI registration
    page requires all fields to be filled out with password complexity requirements
    (see [Figure 7-16](#figure7-16)).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the crAPI Signup page](image_fi/502444c07/F07016.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-16: The crAPI account registration page'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Since we know nothing about the APIs used in this application, we’ll want to
    proxy the requests through Burp Suite to see what’s going on below the GUI. Set
    up your proxy and click **Signup** to initiate the request. You should see that
    the application submits a POST request to the */identity/api/auth/signup* endpoint
    (see [Figure 7-17](#figure7-17)).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the request includes a JSON payload with all of the answers you
    provided in the registration form.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a POST request in Burp Suite](image_fi/502444c07/F07017.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-17: An intercepted crAPI authentication request'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve discovered our first crAPI API request, we’ll start building
    a Postman collection. Click the **Options** button under the collection and then
    add a new request. Make sure that the request you build in Postman matches the
    request you intercepted: a POST request to the */identity/api/auth/signup* endpoint
    with a JSON object as the body (see [Figure 7-18](#figure7-18)).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of a POST request body in Postman](image_fi/502444c07/F07018.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-18: The crAPI registration request in Postman'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Test the request to make sure you’ve crafted it correctly, as there is actually
    a lot that you could get wrong at this point. For example, your endpoint or body
    could contain a typo, you could forget to change the request method from GET to
    POST, or maybe you didn’t match the headers of the original request. The only
    way to find out if you copied it correctly is to send a request, see how the provider
    responds, and troubleshoot if needed. Here are a couple hints for troubleshooting
    this first request:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: If you receive the status code 415 Unsupported Media Type, you need to update
    the `Content-Type` header so that the value is *application/json*.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The crAPI application won’t allow you to create two accounts using the same
    number or email, so you may need to alter those values in the body of your request
    if you already registered in the GUI.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll know your request is ready when you receive a status 200 OK as a response.
    Once you receive a successful response, make sure to save your request!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve saved the registration request to our crAPI collection, log in
    to the web app to see what other API artifacts there are to discover. Proxy the
    login request using the email and password you registered. When you submit a successful
    login request, you should receive a Bearer token from the application (see [Figure
    7-19](#figure7-19)). You’ll need to include this Bearer token in all of your authenticated
    requests moving forward.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of an HTTP response in Burp Suite with the Authorization field
    of the body highlighted](image_fi/502444c07/F07019.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-19: An intercepted request after a successful login to crAPI'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Add this Bearer token to your collection, either as an authorization method
    or a variable. I saved mine as an authorization method with the Type set to Bearer
    Token, as seen in [Figure 7-20](#figure7-20).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Postman “Edit Collection” tab with a Bearer Token saved
    in the Authorization menu item](image_fi/502444c07/F07020.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![Postman “编辑集合”标签页的截图，其中在授权菜单项中保存了一个 Bearer Token](image_fi/502444c07/F07020.png)'
- en: 'Figure 7-20: The Postman collection editor'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-20：Postman 集合编辑器
- en: Continue using the application in the browser, proxying its traffic, and saving
    the requests you discover to your collection. Try using different parts of the
    application, such as the dashboard, shop, and community, to name a few. Be sure
    to look for the kind of interesting functionality we discussed in this chapter.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 继续在浏览器中使用该应用程序，代理其流量，并将你发现的请求保存到集合中。尝试使用应用程序的不同部分，例如仪表盘、商店和社区等。务必寻找我们在本章讨论过的有趣功能。
- en: 'One endpoint in particular should catch your attention simply based on the
    fact that it involves other crAPI users: the forum. Use the crAPI forum as it
    was intended in your browser and intercept the request. Submitting a comment to
    the forum will generate a POST request. Save the POST request to the collection.
    Now send the request used to populate the community forum to the */community/api/v2/community/posts/recent*
    endpoint. Notice anything significant in the JSON response body in [Listing 7-1](#listing7-1)?'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特别的端点应该引起你的注意，仅仅因为它涉及到其他 crAPI 用户：论坛。在浏览器中按预期使用 crAPI 论坛并拦截请求。向论坛提交评论将生成一个
    POST 请求。将该 POST 请求保存到集合中。现在，将用于填充社区论坛的请求发送到 */community/api/v2/community/posts/recent*
    端点。在[列表7-1](#listing7-1)中的 JSON 响应正文中注意到什么重要信息了吗？
- en: '[PRE5]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 7-1: A sample of the JSON response received from the */community/api/v2/community/posts/recent*
    endpoint'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-1：从 */community/api/v2/community/posts/recent* 端点接收到的 JSON 响应示例
- en: Not only do you receive the JSON object for your post, you also receive the
    information about every post on the forum. Those objects contain much more information
    than is necessary, including sensitive information such as user IDs, email addresses,
    and vehicle IDs. If you’ve made it this far, congratulations; this means you’ve
    discovered an excessive data exposure vulnerability. Great job! There are many
    more vulnerabilities affecting crAPI, and we’ll definitely use our findings here
    to help locate even more severe vulnerabilities in the upcoming chapters.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅收到了你帖子对应的 JSON 对象，还收到了论坛中每个帖子的相关信息。这些对象包含了比所需更多的信息，包括敏感信息，如用户 ID、电子邮件地址和车辆
    ID。如果你已经做到这一点，恭喜你；这意味着你发现了一个过度数据暴露的漏洞。做得好！crAPI 还存在许多其他漏洞，接下来的章节中我们将利用这些发现帮助定位更多严重的漏洞。
