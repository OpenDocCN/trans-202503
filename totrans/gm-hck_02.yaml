- en: '**1**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SCANNING MEMORY USING CHEAT ENGINE**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The best game hackers in the world spend years personalizing expansive arsenals
    with custom-built tools. Such potent toolkits enable these hackers to seamlessly
    analyze games, effortlessly prototype hacks, and effectively develop bots. At
    the core, however, each unique kit is built from the same four-piece powerhouse:
    a memory scanner, an assembler-level debugger, a process monitor, and a hex editor.'
  prefs: []
  type: TYPE_NORMAL
- en: Memory scanning is the gateway to game hacking, and this chapter will teach
    you about Cheat Engine, a powerful memory scanner that searches a game’s operating
    memory (which lives in RAM) for values like the player’s level, health, or in-game
    money. First, I’ll focus on basic memory scanning, memory modification, and pointer
    scanning. Following that, we’ll dive into Cheat Engine’s powerful embedded Lua
    scripting engine.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can grab Cheat Engine from* [http://www.cheatengine.org/](http://www.cheatengine.org/)*.
    Pay attention when running the installer because it will try to install some toolbars
    and other bloatware. You can disable those options if you wish.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why Memory Scanners Are Important**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Knowing a game’s state is paramount to interacting with the game intelligently,
    but unlike humans, software can’t determine the state of a game simply by looking
    at what’s on the screen. Fortunately, underneath all of the stimuli produced by
    a game, a computer’s memory contains a purely numeric representation of that game’s
    state—and programs can understand numbers easily. Hackers use memory scanners
    to find those values in memory, and then in their programs, they read the memory
    in these locations to understand the game’s state.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a program that heals players when they fall below 500 health needs
    to know how to do two things: track a player’s current health and cast a healing
    spell. The former requires access to the game’s state, while the latter might
    only require a button to be pressed. Given the location where a player’s health
    is stored and the way to read a game’s memory, the program would look something
    like this pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A memory scanner allows you to find `HEALTH_LOCATION` so that your software
    can query it for you later.
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Memory Scanning**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The memory scanner is the most basic, yet most important, tool for the aspiring
    game hacker. As in any program, all data in the memory of a game resides at an
    absolute location called a *memory address*. If you think of the memory as a very
    large byte array, a memory address is an index pointing to a value in that array.
    When a memory scanner is told to find some value *x* (called a *scan value*, because
    it’s the value you’re scanning for) in a game’s memory, the scanner loops through
    the byte array looking for any value equal to *x*. Every time it finds a matching
    value, it adds the index of the match to a result list.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the sheer size of a game’s memory, however, the value of *x* can appear
    in hundreds of locations. Imagine that *x* is the player’s health, which is currently
    500\. Our *x* uniquely holds `500`, but `500` is not uniquely held by *x*, so
    a scan for *x* returns all variables with a value of `500`. Any addresses not
    related to *x* are ultimately clutter; they share a value of `500` with *x* only
    by chance. To filter out these unwanted values, the memory scanner allows you
    to rescan the result list, removing addresses that no longer hold the same value
    as *x*, whether *x* is still `500` or has changed.
  prefs: []
  type: TYPE_NORMAL
- en: For these rescans to be effective, the overall state of the game must have significant
    *entropy*—a measure of disorder. You increase entropy by changing the in-game
    environment, often by moving around, killing creatures, or switching characters.
    As entropy increases, unrelated addresses are less likely to continue to arbitrarily
    hold the same value, and given enough entropy, a few rescans should filter out
    all false positives and leave you with the true address of *x*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cheat Engine’s Memory Scanner**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section gives you a tour of Cheat Engine’s memory-scanning options, which
    will help you track down the addresses of game state values in memory. I’ll give
    you a chance to try the scanner out in “[Basic Memory Editing](ch01.xhtml#ch01sb01)”
    on [page 11](ch01.xhtml#page_11); for now, open Cheat Engine and have a look around.
    The memory scanner is tightly encapsulated in its main window, as shown in [Figure
    1-1](ch01.xhtml#ch1fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f01-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-1: Cheat Engine main screen*'
  prefs: []
  type: TYPE_NORMAL
- en: To begin scanning a game’s memory, click the Attach icon ➊ to attach to a process
    and then enter the scan value (referred to as *x* in our conceptual scanner) you
    want to locate ➌. By attaching to a process, we’re telling Cheat Engine to prepare
    to operate on it; in this case, that operation is a scan. It helps to also tell
    Cheat Engine what kind of scan to run, as I’ll discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: '***Scan Types***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Cheat Engine allows you to select two different scan directives, called Scan
    Type and Value Type ➍. Scan Type tells the scanner how to compare your scan value
    with the memory being scanned using one of the following scan types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exact Value** Returns addresses pointing to values equal to the scan value.
    Choose this option if the value you are looking for won’t change during the scan;
    health, mana, and level typically fall into this category.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bigger Than** Returns addresses pointing to values greater than the scan
    value. This option is useful when the value you’re searching for is steadily increasing,
    which often happens with timers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Smaller Than** Returns addresses pointing to values smaller than the scan
    value. Like Bigger Than, this option is useful for finding timers (in this case,
    ones that count down rather than up).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Value Between** Returns addresses pointing to values within a scan value
    range. This option combines Bigger Than and Smaller Than, displaying a secondary
    scan value box that allows you to input a much smaller range of values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unknown Initial Value** Returns all addresses in a program’s memory, allowing
    rescans to examine the entire address range relative to their initial values.
    This option is useful for finding item or creature types, since you won’t always
    know the internal values the game developers used to represent these objects.'
  prefs: []
  type: TYPE_NORMAL
- en: The Value Type directive tells the Cheat Engine scanner what type of variable
    it’s searching for.
  prefs: []
  type: TYPE_NORMAL
- en: '***Running Your First Scan***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once the two scan directives are set, click **First Scan** ➋ to run an initial
    scan for values, and the scanner will populate the results list ➎. Any green addresses
    in this list are *static*, meaning that they should remain persistent across program
    restarts. Addresses listed in black reside in *dynamically allocated memory*,
    memory that is allocated at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: When the results list is first populated, it shows the address and real-time
    value of each result. Each rescan will also show the value of each result during
    the previous scan. (Any real-time values displayed are updated at an interval
    that you can set in Edit ▸ Settings ▸General Settings ▸Update interval.)
  prefs: []
  type: TYPE_NORMAL
- en: '***Next Scans***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once the results list is populated, the scanner enables the Next Scan ➋ button,
    which offers six new scan types. These additional scan types allow you to compare
    the addresses in the results list to their values in the previous scan, which
    will help you narrow down which address holds the game state value you’re scanning
    for. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased Value** Returns addresses pointing to values that have increased.
    This complements the Bigger Than scan type by keeping the same minimum value and
    removing any address whose value has decreased.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased Value By** Returns addresses pointing to values that have increased
    by a defined amount. This scan type usually returns far fewer false positives,
    but you can use it only when you know exactly how much a value has increased.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decreased Value** This option is the opposite of Increased Value.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decreased Value By** This option is the opposite of Increased Value By.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Changed Value** Returns addresses pointing to values that have changed. This
    type is useful when you know a value will mutate, but you’re unsure how.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unchanged Value** Returns addresses pointing to values that haven’t changed.
    This can help you eliminate false positives, since you can easily create a large
    amount of entropy while ensuring the desired value stays the same.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll usually need to use multiple scan types in order to narrow down a large
    result list and find the correct address. Eliminating false positives is often
    a matter of properly creating entropy (as described in “[Basic Memory Scanning](ch01.xhtml#ch00lev1sec8)”
    on [page 4](ch01.xhtml#page_4)), tactically changing your scan directives, bravely
    pressing Next Scan, and then repeating the process until you have a single remaining
    address.
  prefs: []
  type: TYPE_NORMAL
- en: '***When You Can’t Get a Single Result***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes it is impossible to pinpoint a single result in Cheat Engine, in which
    case you must determine the correct address through experimentation. For example,
    if you’re looking for your character’s health and can’t narrow it down to fewer
    than five addresses, you could try modifying the value of each address (as discussed
    in “[Manual Modification with Cheat Engine](ch01.xhtml#ch00lev1sec16)” on [page
    8](ch01.xhtml#page_8)) until you see the health display change or the other values
    automatically change to the one you set.
  prefs: []
  type: TYPE_NORMAL
- en: '***Cheat Tables***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once you’ve found the correct address, you can double-click it to add it to
    the *cheat table pane* ➏; addresses in the cheat table pane can be modified, watched,
    and saved to cheat table files for future use.
  prefs: []
  type: TYPE_NORMAL
- en: For each address in the cheat table pane, you can add a description by double-clicking
    the Description column, and you can add a color by right-clicking and selecting
    Change Color. You can also display the values of each address in hexadecimal or
    decimal format by right-clicking and selecting Show as hexadecimal or Show as
    decimal, respectively. Lastly, you can change the data type of each value by double-clicking
    the Type column, or you can change the value itself by double-clicking the Value
    column.
  prefs: []
  type: TYPE_NORMAL
- en: Since the main purpose of the cheat table pane is to allow a game hacker to
    neatly track addresses, it can be dynamically saved and loaded. Go to **File**
    ▸ **Save** or **File** ▸**Save As** to save the current cheat table pane to a
    *.ct* document file containing each address with its value type, description,
    display color, and display format. To load the saved *.ct* documents, go to **File**
    ▸**Load**. (You’ll find many ready-made cheat tables for popular games at *[http://cheatengine.org/tables.php](http://cheatengine.org/tables.php)*.)
  prefs: []
  type: TYPE_NORMAL
- en: Now that I’ve described how to scan for a game state value, I’ll discuss how
    you can change that value when you know where it lives in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory Modification in Games**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bots cheat a game system by modifying memory values in the game’s state in order
    to give you lots of in-game money, modify your character’s health, change your
    character’s position, and so on. In most online games, a character’s vitals (such
    as health, mana, skills, and position) are held in memory but are controlled by
    the game server and relayed to your local game client over the Internet, so modifying
    such values during online play is merely cosmetic and doesn’t affect the actual
    values. (Any useful memory modification to an online game requires a much more
    advanced hack that’s beyond Cheat Engine’s capabilities.) In local games with
    no remote server, however, you can manipulate all of these values at will.
  prefs: []
  type: TYPE_NORMAL
- en: '***Manual Modification with Cheat Engine***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll use Cheat Engine to understand how the memory modification magic works.
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify memory manually, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Attach Cheat Engine to a game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Either scan for the address you wish to modify or load a cheat table that contains
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the Value column for the address to open an input prompt where
    you can enter a new value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to make sure the new value can’t be overwritten, select the box
    under the Active column to *freeze* the address, which will make Cheat Engine
    keep writing the same value back to it every time it changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This method works wonders for quick-and-dirty hacks, but constantly changing
    values by hand is cumbersome; an automated solution would be much more appealing.
  prefs: []
  type: TYPE_NORMAL
- en: '***Trainer Generator***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Cheat Engine’s trainer generator allows you to automate the whole memory modification
    process without writing any code.
  prefs: []
  type: TYPE_NORMAL
- en: To create a *trainer* (a simple bot that binds memory modification actions to
    keyboard hotkeys), go to **File** ▸ **Create generic trainer Lua script from table**.
    This opens a Trainer generator dialog similar to the one shown in [Figure 1-2](ch01.xhtml#ch1fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f01-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-2: Cheat Engine Trainer generator dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of fields to modify here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Processname** The name of the executable the trainer should attach to. This
    is the name shown in the process list when you attach with Cheat Engine, and it
    should be autofilled with the name of the process Cheat Engine is attached to.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Popup trainer on keypress** Optionally enables a hotkey—which you set by
    entering a key combination in the box below the checkbox—to display the trainer’s
    main window.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Title** The name of your trainer, which will be displayed on its interface.
    This is optional.'
  prefs: []
  type: TYPE_NORMAL
- en: '**About text** The description of your trainer, to be displayed on the interface;
    this is also optional.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Freeze interval (in milliseconds)** The interval during which a freeze operation
    overwrites the value. You should generally leave this at 250, as lower intervals
    can sap resources and higher values may be too slow.'
  prefs: []
  type: TYPE_NORMAL
- en: Once these values are configured, click **Add Hotkey** to set up a key sequence
    to activate your trainer. You will be prompted to select a value from your cheat
    table. Enter a value, and you will be taken to a Set/Change hotkey screen similar
    to [Figure 1-3](ch01.xhtml#ch1fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f01-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-3: Cheat Engine Set/Change hotkey screen*'
  prefs: []
  type: TYPE_NORMAL
- en: 'On this screen, place your cursor in the box labeled Type the keys you want
    to set the hotkey to ➊ and enter the desired key combination. Next, choose the
    desired action from the drop-down menu ➋; your options should appear in the following
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Toggle freeze** Toggles the freeze state of the address.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Toggle freeze and allow increase** Toggles the freeze state of the address
    but allows the value to increase. Any time the value decreases, the trainer overwrites
    it with its previous value. Increased values will not be overwritten.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Toggle freeze and allow decrease** Does the opposite of Toggle freeze and
    allow increase.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Freeze** Sets the address to frozen if it’s not frozen already.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unfreeze** Unfreezes the address if it’s frozen.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Set value to** Sets the value to whatever you specify in the value box ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decrease value with** Decreases the value by the amount you specify in the
    value box ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increase value with** Does the opposite of Decrease value with.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can set a description for the action ➍. Click **Apply**, then **OK**,
    and your action will appear in the list on the Trainer generator screen. At this
    point, Cheat Engine runs the trainer in the background, and you can simply press
    the hotkeys you configured to execute the memory actions.
  prefs: []
  type: TYPE_NORMAL
- en: To save your trainer to a portable executable, click **Generate trainer**. Running
    this executable after the game is launched will attach your trainer to the game
    so you can use it without starting Cheat Engine.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know your way around Cheat Engine’s memory scanner and trainer
    generator, try modifying some memory yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '**BASIC MEMORY EDITING**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the files for this book from *[https://www.nostarch.com/gamehacking/](https://www.nostarch.com/gamehacking/)*,
    and run the file *BasicMemory.exe*. Next, start up Cheat Engine and attach to
    the binary. Then, using only Cheat Engine, find the addresses for the x- and y-coordinates
    of the gray ball. (Hint: Use the 4 Bytes value type.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve found the values, modify them to place the ball on top of the black
    square. The game will let you know once you’ve succeeded by displaying the text
    “Good job!” (Hint: Each time the ball is moved, its position—stored as a 4-byte
    integer—in that plane is changed by 1\. Also, try to look only for static [green]
    results.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pointer Scanning**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I’ve mentioned, online games often store values in dynamically allocated
    memory. While addresses that reference dynamic memory are useless to us in and
    of themselves, some static address will always point to another address, which
    in turn points to another, and so on, until the tail of the chain points to the
    dynamic memory we’re interested in. Cheat Engine can locate these chains using
    a method called *pointer scanning*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll introduce you to pointer chains and then describe how
    pointer scanning works in Cheat Engine. When you have a good grasp of the user
    interface, you can get some hands-on experience in “[Pointer Scanning](ch01.xhtml#ch00lev1sec18)”
    on [page 18](ch01.xhtml#page_18).
  prefs: []
  type: TYPE_NORMAL
- en: '***Pointer Chains***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The chain of offsets I’ve just described is called a *pointer chain* and looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first value in this pointer chain (`start`) is called a *memory pointer*.
    It’s an address that starts the chain. The remaining values (`offset1`, `offset2`,
    and so on) make up the route to the desired value, called a *pointer path*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pseudocode shows how a pointer chain might be read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates the function `readPointerPath()`, which takes a pointer chain
    called `chain` as a parameter. The function `readPointerPath()` treats the pointer
    path in `chain` as a list of memory offsets from the address `ret`, which is initially
    set to the memory pointer at ➊. It then loops through these offsets, updating
    the value of `ret` to the result of `read(ret + offset)` on each iteration and
    returning `ret` once it’s finished. This pseudocode shows what `readPointerPath()`
    looks like when the loop is unrolled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The function ultimately calls `read` four times, on four different addresses—one
    for each element in `chain`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Many game hackers prefer to code their chain reads in place, instead of encapsulating
    them in functions like* `readPointerPath()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Pointer Scanning Basics***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pointer chains exist because every chunk of dynamically allocated memory must
    have a corresponding static address that the game’s code can use to reference
    it. Game hackers can access these chunks by locating the pointer chains that reference
    them. Because of their multitier structure, however, pointer chains cannot be
    located through the linear approach that memory scanners use, so game hackers
    have devised new ways to find them.
  prefs: []
  type: TYPE_NORMAL
- en: From a reverse engineering perspective, you could locate and analyze the assembly
    code in order to deduce what pointer path it used to access the value, but doing
    so is very time-consuming and requires advanced tools. *Pointer scanners* solve
    this problem by using brute-force to recursively iterate over every possible pointer
    chain until they find one that resolves to the target memory address.
  prefs: []
  type: TYPE_NORMAL
- en: The [Listing 1-1](ch01.xhtml#ch1exe1) pseudocode should give you a general idea
    of how a pointer scanner works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-1: Pseudocode for a pointer scanner*'
  prefs: []
  type: TYPE_NORMAL
- en: This code creates the functions `pointerScan()` and `rScan()`.
  prefs: []
  type: TYPE_NORMAL
- en: '**pointerScan()**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `pointerScan()` function is the entry point to the scan. It takes the parameters
    `target` (the dynamic memory address to find), `maxAdd` (the maximum value of
    any offset), and `maxDepth` (the maximum length of the pointer path). It then
    loops through every 4-byte aligned address ➊ in the game, calling `rScan()` with
    the parameters `address` (the address in the current iteration), `target`, `maxAdd`,
    `maxDepth`, and `curDepth` (the depth of the path, which is always 1 in this case).
  prefs: []
  type: TYPE_NORMAL
- en: '**rScan()**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `rScan()` function reads memory from every 4-byte aligned offset between
    `0` and `maxAdd` ➋, and returns if a result is equal to `target` ➌. If `rScan()`
    doesn’t return in the first loop and the recursion is not too deep ➍, it increments
    `curDepth` and again loops over each offset ➎, calling itself for each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: If a self call returns a partial pointer path ➏, `rScan()` will prepend the
    current offset to the path and return up the recursion chain ➐ until it reaches
    `pointerScan()`. When a call to `rScan()` from `pointerScan()` returns a pointer
    path, `pointerScan()` pushes the current address to the front of the path and
    returns it as a complete chain.
  prefs: []
  type: TYPE_NORMAL
- en: '***Pointer Scanning with Cheat Engine***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The previous example showed the basic process of pointer scanning, but the implementation
    I’ve shown is primitive. Aside from being insanely slow to execute, it would generate
    countless false positives. Cheat Engine’s pointer scanner uses a number of advanced
    interpolations to speed up the scan and make it more accurate, and in this section,
    I’ll introduce you to the smorgasbord of available scanning options.
  prefs: []
  type: TYPE_NORMAL
- en: To initiate a pointer scan in Cheat Engine, right-click on a dynamic memory
    address in your cheat table and click **Pointer scan for this address**. When
    you initiate a pointer scan, Cheat Engine will ask you where to store the scan
    results as a *.ptr* file. Once you enter a location, a Pointerscanner scanoptions
    dialog similar to the one shown in [Figure 1-4](ch01.xhtml#ch1fig4) will appear.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f01-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-4: Cheat Engine Pointerscanner scanoptions dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: The Address to find input field at the top displays your dynamic memory address.
    Now carefully select from among Cheat Engine’s many scan options.
  prefs: []
  type: TYPE_NORMAL
- en: '**Key Options**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Several of Cheat Engine’s scan options typically retain their default values.
    Those options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Addresses must be 32-bits aligned** Tells Cheat Engine to scan only addresses
    that are multiples of 4, which greatly increases the scan speed. As you’ll learn
    in [Chapter 4](ch04.xhtml#ch04), compilers align data so that most addresses will
    be multiples of 4 anyway by default. You’ll rarely need to disable this option.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Only find paths with a static address** Speeds up the scan by preventing
    Cheat Engine from searching paths with a dynamic start pointer. This option should
    *always* be enabled because scanning for a path starting at another dynamic address
    can be counterproductive.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Don’t include pointers with read-only nodes** Should also always be enabled.
    Dynamically allocated memory that stores volatile data should never be read-only.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stop traversing a path when a static has been found** Terminates the scan
    when it finds a pointer path with a static start address. This should be enabled
    to reduce false positives and speed up the scan.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pointer path may only be inside this region** Can typically be left as is.
    The other options available to you compensate for this large range by intelligently
    narrowing the scope of the scan.'
  prefs: []
  type: TYPE_NORMAL
- en: '**First element of pointerstruct must point to module** Tells Cheat Engine
    not to search heap chunks in which virtual function tables are not found, under
    the assumption that the game was coded using object orientation. While this setting
    can immensely speed up scans, it’s highly unreliable and you should almost always
    leave it disabled.'
  prefs: []
  type: TYPE_NORMAL
- en: '**No looping pointers** Invalidates any paths that point to themselves, weeding
    out inefficient paths but slightly slowing down the scan. This should usually
    be enabled.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Max level** Determines the maximum length of the pointer path. (Remember
    the `maxDepth` variable in the example code in [Listing 1-1](ch01.xhtml#ch1exe1)?)
    This should be kept around 6 or 7.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there will be times when you’ll need to change these options from
    the settings described. For example, failing to obtain reliable results with the
    No looping pointers or Max level settings typically means that the value you’re
    looking for exists in a dynamic data structure, like a linked list, binary tree,
    or vector. Another example is the Stop traversing a path when a static has been
    found option, which in rare cases can prevent you from getting reliable results.
  prefs: []
  type: TYPE_NORMAL
- en: '**Situational Options**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Unlike the previous options, your settings for the remaining ones will depend
    on your situation. Here’s how to determine the best configuration for each:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Improve pointerscan with gathered heap data** Allows Cheat Engine to use
    the heap allocation record to determine offset limits, effectively speeding up
    the scan by weeding out many false positives. If you run into a game using a custom
    memory allocator (which is becoming increasingly common), this option can actually
    do the exact opposite of what it’s meant to do. You can leave this setting enabled
    in initial scans, but it should be the first to go when you’re unable to find
    reliable paths.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Only allow static and heap addresses in the path** Invalidates all paths
    that can’t be optimized with heap data, making this approach even more aggressive.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Max different offsets per node** Limits the number of same-value pointers
    the scanner checks. That is, if *n* different addresses point to `0x0BADF00D`,
    this option tells Cheat Engine to consider only the first *m* addresses. This
    can be extremely helpful when you’re unable to narrow down your result set. In
    other cases, you may want to disable it, as it will miss many valid paths.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Allow stack addresses of the first thread(s) to be handled as static** Scans
    the call stacks of oldest *m* threads in the game, considering the first *n* bytes
    in each one. This allows Cheat Engine to scan the parameters and local variables
    of functions in the game’s call chain (the goal being to find variables used by
    the game’s main loop). The paths found with this option can be both highly volatile
    and extremely useful; I use it only when I fail to find heap addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack addresses as only static address** Takes the previous option even further
    by allowing only stack addresses in pointer paths.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pointers must end with specific offsets** Can be useful if you know the offset(s)
    at the end of a valid path. This option will allow you to specify those offsets
    (starting with the last offset at the top), greatly reducing the scope of the
    scan.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nr of threads scanning** Determines how many threads the scanner will use.
    A number equal to the number of cores in your processor often works best. A drop-down
    menu with options allows you to specify the priority for each thread. Idle is
    best if you want your scan to go very slowly, Normal is what you should use for
    most scans, and Time critical is useful for lengthy scans but will render your
    computer useless for the scan duration.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maximum offset value** Determines the maximum value of each offset in the
    path. (Remember the `maxAdd` variable in [Listing 1-1](ch01.xhtml#ch1exe1)?) I
    typically start with a low value, increasing it only if my scan fails; `128` is
    a good starting value. Keep in mind that this value is mostly ignored if you’re
    using the heap optimization options.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*What if both Only allow static and heap addresses in the path and Stack addresses
    as only static address are enabled? Will the scan come up empty? Seems like a
    fun, albeit useless, experiment.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have defined your scan options, click **OK** to start a pointer scan.
    When the scan completes, a results window will appear with the list of pointer
    chains found. This list often has thousands of results, containing both real chains
    and false positives.
  prefs: []
  type: TYPE_NORMAL
- en: '***Pointer Rescanning***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The pointer scanner has a rescan feature that can help you eliminate false positives.
    To begin, press CTRL-R from the results window to open the Rescan pointerlist
    dialog, as shown in [Figure 1-5](ch01.xhtml#ch1fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f01-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-5: Cheat Engine Rescan pointerlist dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main options to consider when you tell Cheat Engine to rescan:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Only filter out invalid pointers** If you check this box ➊, the rescan will
    discard only pointer chains that point to invalid memory, which helps if your
    initial result set is very large. Disable this to filter out paths that don’t
    resolve to a specific address or value (as shown in the figure).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Repeat rescan until stopped** If you check this box ➋, the rescan will execute
    in a continuous loop. Ideally, you should enable this setting and let rescan run
    while you create a large amount of memory entropy.'
  prefs: []
  type: TYPE_NORMAL
- en: For the initial rescan, enable both **Only filter out invalid pointers** and
    **Repeat rescan until stopped**, and then press **OK** to initiate the rescan.
    The rescan window will go away, and a Stop rescan loop button will appear in the
    results window. The result list will be constantly rescanned until you click Stop
    rescan loop, but spend a few minutes creating memory entropy before doing so.
  prefs: []
  type: TYPE_NORMAL
- en: In rare cases, rescanning using a rescan loop may still leave you with a large
    list of possible paths. When this happens, you may need to restart the game, find
    the address that holds your value (it may have changed!), and use the rescan feature
    on this address to further narrow results. In this scan, leave **Only filter out
    invalid pointers** unchecked and enter the *new* address in the **Address to find**
    field.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you had to close the results window, you can reopen it and load the result
    list by going to the main Cheat Engine window and pressing the Memory View button
    below the results pane. This should bring up a memory dump window. When the window
    appears, press CTRL-P to open the pointer scan results list. Then press CTRL-O
    to open the* .ptr *file where you saved the pointer scan.*'
  prefs: []
  type: TYPE_NORMAL
- en: If your results still aren’t narrow enough, try running the same scan across
    system restarts or even on different systems. If this still yields a large result
    set, each result can safely be considered static because more than one pointer
    chain can resolve to the same address.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve narrowed down your result set, double-click on a usable pointer
    chain to add it to your cheat table. If you have a handful of seemingly usable
    chains, grab the one with the fewest offsets. If you find multiple chains with
    identical offsets that start with the same pointer but diverge after a certain
    point, your data may be stored in a dynamic data structure.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all there is to pointer scanning in Cheat Engine. Try it yourself!
  prefs: []
  type: TYPE_NORMAL
- en: '**POINTER SCANNING**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to *[https://www.nostarch.com/gamehacking/](https://www.nostarch.com/gamehacking/)*
    and download *MemoryPointers.exe*. Unlike the last task, which required you to
    win only once, this one requires that you win 50 times in 10 seconds. Upon each
    win, the memory addresses for the x- and y-coordinates will change, meaning you
    will be able to freeze the value only if you have found a proper pointer path.
    Start this exercise the same way as the previous one, but once you’ve found the
    addresses, use the Pointer scan feature to locate pointer paths to them. Then,
    place the ball on top of the black square, freeze the value in place, and press
    TAB to begin the test. Just as before, the game will let you know once you’ve
    won. (Hint: Try setting the maximum level to `5` and the maximum offset value
    to `512`. Also, play with the options to allow stack addresses, terminate the
    scan when a static is found, and improve the pointer scan with heap data. See
    which combination of options gives the best results.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lua Scripting Environment**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Historically, bot developers rarely used Cheat Engine to update their addresses
    when a game released a patch because it was much easier to do so in OllyDbg. This
    made Cheat Engine useless to game hackers other than for initial research and
    development—that is, until a powerful Lua-based embedded scripting engine was
    implemented around Cheat Engine’s robust scanning environment. While this engine
    was created to enable the development of simple bots within Cheat Engine, professional
    game hackers found they could also use it to easily write complex scripts to automatically
    locate addresses across different versions of a game’s binary—a task that might
    otherwise take hours.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You’ll find more detail about the Cheat Engine Lua scripting engine on the
    wiki at* [http://wiki.cheatengine.org/](http://wiki.cheatengine.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: To start using the Lua engine, press CTRL-ALT-L from the main Cheat Engine window.
    Once the window opens, write your script in the text area and click **Execute
    script** to run it. Save a script with CTRL-S and open a saved script with CTRL-O.
  prefs: []
  type: TYPE_NORMAL
- en: The scripting engine has hundreds of functions and infinite use cases, so I’ll
    give you just a glimpse of its abilities by breaking down two scripts. Every game
    is different and every game hacker writes scripts to accomplish unique goals,
    so these scripts are only useful for demonstrating concepts.
  prefs: []
  type: TYPE_NORMAL
- en: '***Searching for Assembly Patterns***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This first script locates functions that compose outgoing packets and sends
    them to the game server. It works by searching a game’s assembly code for functions
    that contain a certain code sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The code begins by getting the base address of the module that Cheat Engine
    is attached to ➊. Once it has the base address, the function `LocatePacketCreation()`
    is defined ➋. This function loops through the first `0x2FFFFFF` bytes of memory
    in the game ➌, searching for a sequence that represents this x86 assembler code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The function checks that the type is equal to `packetType`, but it doesn’t care
    what the function offset is ➍. Once this sequence is found, the function returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `LocateFunctionHead()` function is defined ➎. The function backtracks
    up to 0x1FFF bytes from a given address ➏, and at each address, it checks for
    a stub of assembler code ➐ that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This stub will be present at the beginning of every function, because it’s part
    of the function prologue that sets up the function’s stack frame. Once it finds
    the code, the function will return the address of the stub plus 1 ➑ (the first
    byte, `0xCC`, is padding).
  prefs: []
  type: TYPE_NORMAL
- en: 'To tie these steps together, the `LocatePacketCreation()` function is called
    with the `packetType` that I’m looking for (arbitrarily `0x64`) and the resulting
    address is passed into the `LocateFunctionHead()` function ➒. This effectively
    locates the first function that pushes `packetType` into a function call and stores
    its address in `funcAddress`. This stub shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This 35-line script can automatically locate 15 different functions in under
    a minute.
  prefs: []
  type: TYPE_NORMAL
- en: '***Searching for Strings***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This next Lua script scans a game’s memory for text strings. It works much as
    the Cheat Engine’s memory scanner does when you use the string value type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After getting the base address, the `findString()` function is defined ➊, which
    takes a string, `str`, as a parameter. This function loops through the game’s
    memory ➍ in 4,096-byte-long chunks ➋. The chunks are scanned sequentially, each
    one starting `len` (the length of `str`) bytes before the end of the previous
    one ➌ to prevent missing a string that begins on one chunk and ends on another.
  prefs: []
  type: TYPE_NORMAL
- en: As `findString()` reads each chunk, it iterates over every byte until the overlap
    point in the chunk ➎, passing each subchunk into the `checkForString()` function
    ➏. If `checkForString()` matches the subchunk to `str`, it prints the address
    of that subchunk to the console ➐.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, to find all addresses that reference the strings `"hello"` and `"world"`,
    the functions `findString("hello")` ➑ and `findString("world")` ➒ are called.
    By using this code to search for embedded debug strings and pairing it with the
    previous code to locate function headers, I’m able to find a large number of internal
    functions within a game in mere seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '**OPTIMIZING MEMORY CODE**'
  prefs: []
  type: TYPE_NORMAL
- en: Due to the high overhead of memory reading, optimization is extremely important
    when you’re writing code that performs memory reads. In the previous code snippet,
    notice that the function `findString()` does not use the Lua engine’s builtin
    `readString()` function. Instead, it reads big chunks of memory and searches them
    for the desired string. Let’s break down the numbers.
  prefs: []
  type: TYPE_NORMAL
- en: A scan using `readString()` would try to read a string of `len` bytes at every
    possible memory address. This means it would read, at most, `(0x2FFFFFF * len
    + len)` bytes. However, `findString()` reads chunks of 4,096 bytes and scans them
    locally for matching strings. This means it would read, at most, `(0x2FFFFFF +
    4096 + (0x2FFFFFF / (4096 - 10)) * len)` bytes. When searching for a string with
    a length of 10, the number of bytes that each method would read is 503,316,480
    and 50,458,923, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Not only does `findString()` read an order of magnitude less data, it also invokes
    far fewer memory reads. Reading in chunks of 4,096 bytes would require a total
    of `(0x2FFFFFF / (4096 - len))` reads. Compare that to a scan using `readString()`,
    which would need `0x2FFFFFF` reads. The scan that uses `findString()` is a huge
    improvement because invoking a read is much more expensive than increasing the
    size of data being read. (Note that I chose 4,096 arbitrarily. I keep the chunk
    relatively small because reading memory can be time-consuming, and it might be
    wasteful to read four pages at a time just to find the string in the first.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By this point, you should have a basic understanding of Cheat Engine and how
    it works. Cheat Engine is a very important tool in your kit, and I encourage you
    to get some hands-on experience with it by following “[Basic Memory Editing](ch01.xhtml#ch01sb01)”
    on [page 11](ch01.xhtml#page_11) and “[Pointer Scanning](ch01.xhtml#ch00lev1sec18)”
    on [page 18](ch01.xhtml#page_18) and playing around with it on your own.
  prefs: []
  type: TYPE_NORMAL
