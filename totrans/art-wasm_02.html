<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="19" id="Page_19"/>2</span><br/>
<span class="ChapterTitle">WebAssembly Text Basics</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="190" height="190"/>
</figure>
<p class="ChapterIntro">In this chapter, we’ll dive into the basics of WAT code. We’ll write most of the code in this book in WAT, the lowest level of programming you can write for deployment to WebAssembly (although for experienced assembly coders, it might seem rather high level).</p>
<p>This chapter covers a lot of ground. We’ll begin by showing you the two comment styles in WebAssembly. Next, we’ll write the traditional hello world application. We don’t start with hello world because working with strings from within WAT is more challenging than you might expect. </p>
<p>Then we’ll discuss how to import data from JavaScript into our WebAssembly module using an import object. We’ll look at named and unnamed global and local variables, as well as the data types that WebAssembly supports. We’ll discuss the S-Expression syntax and how the <code>wat2wasm</code> compiler unpacks those S-Expressions when it compiles your code. You’ll delve into conditional logic, including <code>if</code>/<code>else</code> statements and branch tables, and you’ll learn how to use loops and blocks in conjunction with conditional logic. </p>
<p><span epub:type="pagebreak" title="20" id="Page_20"/>By the end of this chapter, you should be able to write simple WebAssembly apps that you can execute from the command line using Node.js.</p>
<h2 id="h1-501737c02-0001">Writing the Simplest Module</h2>
<p class="BodyFirst">Every WAT application must be a module, so we’ll first look at the module syntax. We declare a module in a block, like the one in <a href="#listing2-1" id="listinganchor2-1">Listing 2-1</a>.</p>
<pre><code>(module
  <span class="LiteralGray">;; This is where the module code goes.</span>
)</code></pre>
<p class="CodeListingCaption"><a id="listing2-1">Listing 2-1</a>: Single line WAT comment</p>
<p>We declare a module with the <code>module</code> keyword, and anything inside the surrounding parentheses is part of the module. To add a comment, we use two semicolons <code>;;</code> , and everything on the line that follows is a comment. WAT also has block comment syntax; you open the block comment with <code>(;</code> and close it with <code>;)</code> , as shown in <a href="#listing2-2" id="listinganchor2-2">Listing 2-2</a>.</p>
<pre><code>(module
<span class="LiteralGray">  (;</span>
<span class="LiteralGray">  This is a module with a block comment.</span>
<span class="LiteralGray">  Like the /* and */ comments in JavaScript</span>
<span class="LiteralGray">  you can have as many lines as you like inside</span>
<span class="LiteralGray">  between the opening and closing parenthesis</span>
<span class="LiteralGray">  ;)</span>
)</code></pre>
<p class="CodeListingCaption"><a id="listing2-2">Listing 2-2</a>: Multi-line WAT comment</p>
<p>Because this module doesn’t do anything, we won’t bother to compile it. Instead, we’ll move on to writing our hello world application.</p>
<h2 id="h1-501737c02-0002">Hello World in WebAssembly</h2>
<p class="BodyFirst">WAT doesn’t have any native string support, so working with strings requires you to work directly with memory as an array of character data. That memory data then must be converted into a string in JavaScript code, because manipulating strings from within JavaScript is much simpler.</p>
<p>When working with strings in WAT, you need to declare an array of character data that is stored within WebAssembly linear memory. Linear memory is a topic we’ll discuss in detail in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>, but for now know that linear memory is similar to a memory heap in native applications, or a giant typed array in JavaScript. </p>
<p>You’ll also need to call an imported JavaScript function from WebAssembly to handle I/O operations. Unlike in a native application where the operating system usually handles I/O, in a WebAssembly module, I/O <span epub:type="pagebreak" title="21" id="Page_21"/>must be handled by the embedding environment, whether that environment is a web browser, an operating system, or runtime.</p>
<h3 id="h2-501737c02-0001">Creating Our WAT Module</h3>
<p class="BodyFirst">In this section, we’ll create a simple WebAssembly module that creates a <code>hello world!</code> string in linear memory and calls JavaScript to write that string to the console. Create a new WAT file and name it <em>helloworld.wat</em>. Open that file and add the WAT code in <a href="#listing2-3" id="listinganchor2-3">Listing 2-3</a>.</p>
<p class="CodeLabel"><b>helloworld.wat</b></p>
<pre><code>(module
  (import "env" "print_string" (func $print_string( param i32 )))
)</code></pre>
<p class="CodeListingCaption"><a id="listing2-3">Listing 2-3</a>: Importing a function </p>
<p>This code tells WebAssembly to expect the import object <code>env</code> from our embedding environment, and that within that object we’re expecting the function <code>print_string</code>. When we write our JavaScript code later, we’ll create this <code>env</code> object with the <code>print_string</code> function, which will be passed to our WebAssembly module when we instantiate it.</p>
<p>We also set up the signature as requiring a single <code>i32</code> parameter representing the length of our string. We name this function <code>$print_string</code> so we can access it from our WAT code.</p>
<p>Next, we’ll add an import for our memory buffer. Add the line in bold in <a href="#listing2-4" id="listinganchor2-4">Listing 2-4</a>.</p>
<p class="CodeLabel"><b>helloworld.wat</b></p>
<pre><code>(module
  (import "env" "print_string" (func $print_string( param i32 )))
  <b>(import "env" "buffer" (memory 1))</b>
)</code></pre>
<p class="CodeListingCaption"><a id="listing2-4">Listing 2-4</a>: Importing a function and memory buffer </p>
<p>This new <code>import</code> tells our WebAssembly module that we’ll be importing a memory buffer from the object <code>env</code> and the buffer will be called <code>buffer</code>. The <code>(memory</code><code> 1)</code> statement indicates that the buffer will be a single page of linear memory: a <em>page</em> is the smallest chunk of memory you can allocate at one time to linear memory. In WebAssembly, a page is 64KB, which is more than we need for this module, so we need just one page. Next, in <a href="#listing2-5" id="listinganchor2-5">Listing 2-5</a>, we add a few global variables to <em>helloworld.wat</em>.</p>
<p class="CodeLabel"><b>helloworld.wat</b></p>
<pre><code>(module
  (import "env" "print_string" (func $print_string( param i32 )))
  (import "env" "buffer" (memory 1))
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (global $start_string (import "env" "start_string") i32) 
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (global $string_len i32 (i32.const<b> 12))</b>
)</code></pre>
<p class="CodeListingCaption"><a id="listing2-5">Listing 2-5</a>: Adding global variables </p>
<p>The first <code>global</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> variable is a number imported from our JavaScript import object; it maps to a variable with the name <code>env</code> in JavaScript (which <span epub:type="pagebreak" title="22" id="Page_22"/>we’ve yet to create). That value will be the starting memory location of our string and can be any location in our linear memory page up to the maximum 65,535. Of course, you wouldn’t want to choose a value close to the end of linear memory because it would limit the length of the string you could store. If the value passed in is <code>0</code>, you can use the entire 64KB for your string. If you passed in the value <code>65,532</code>, you would only be able to use the last four bytes to store character data. If you try to write to a memory location that is greater than what was allocated, you’ll get a memory error in your JavaScript console. The second global variable, <code>$string_len</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, is a constant that represents the length of the string we’ll define, and we set it to <code>12</code>.</p>
<p>In <a href="#listing2-6" id="listinganchor2-6">Listing 2-6</a>, we define our string in linear memory using a data expression.</p>
<p class="CodeLabel"><b>helloworld.wat</b></p>
<pre><code>(module
  (import "env" "print_string" (func $print_string( param i32 )))
  (import "env" "buffer" (memory 1))
  (global $start_string (import "env" "start_string") i32)
  (global $string_len i32 (i32.const 12))
  <b>(data (global.get $start_string) "hello world!")</b>
)</code></pre>
<p class="CodeListingCaption"><a id="listing2-6">Listing 2-6</a>: Adding a data string </p>
<p>We first pass the location in memory where the module will write data. The data is stored in the <code>$start_string</code> global variable that the module will import from JavaScript. The second parameter is the data string, which we define as the string <code>"hello world!"</code>.</p>
<p>Now we can define our <code>"helloworld"</code> function and add it to the module, as shown in <a href="#listing2-7" id="listinganchor2-7">Listing 2-7</a>.</p>
<p class="CodeLabel"><b>helloworld.wat</b></p>
<pre><code>(module
  (import "env" "print_string" (func $print_string (param i32)))
  (import "env" "buffer" (memory 1))
  (global $start_string (import "env" "start_string") i32)
  (global $string_len i32 (i32.const 12))
  (data (global.get $start_string) "hello world!")	
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (func (export "helloworld")
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> (call $print_string (global.get $string_len))
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing2-7">Listing 2-7</a>: Adding a <code>"</code><code>helloworld</code><code>"</code> function to the WebAssembly module</p>
<p>We define and export our function as <code>"helloworld"</code> for use in JavaScript <span class="CodeAnnotation" aria-label="annotation1">1</span>. The only thing this function does is call the imported <code>$print_string</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> function, passing it the length of the string we defined as a global. We can now compile our WebAssembly module, like so:</p>
<pre><code>wat2wasm helloworld.wat</code></pre>
<p><span epub:type="pagebreak" title="23" id="Page_23"/>Running <code>wat2wasm</code> generates a <em>helloworld.wasm</em> module. To execute the WebAssembly module, we’ll need to create a JavaScript file that executes it.</p>
<h3 id="h2-501737c02-0002">Creating the JavaScript File</h3>
<p class="BodyFirst">Now we’ll create <em>helloworld.js </em>to run our WebAssembly module. Create and open the JavaScript file in your text editor, and add the Node.js file constants as well as three variables, as shown in <a href="#listing2-8" id="listinganchor2-8">Listing 2-8</a>.</p>
<p class="CodeLabel"><b>helloworld.js</b></p>
<pre><code>const fs = require('fs');
const bytes = fs.readFileSync(__dirname + '/helloworld.wasm');

<span class="CodeAnnotationHang" aria-label="annotation1">1</span> let hello_world = null; <span class="LiteralGray">// function will be set later</span>
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> let start_string_index = 100; <span class="LiteralGray">// linear memory location of string</span>
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> let memory = new WebAssembly.Memory ({ initial: 1 }); <span class="LiteralGray">// linear memory</span>
...</code></pre>
<p class="CodeListingCaption"><a id="listing2-8">Listing 2-8</a>: Declaring the JavaScript variables</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Notice the <code>...</code> in the last line of code in <a href="#listing2-8">Listing 2-8</a>. In this book, we’ll use <code>...</code>to indicate that there is more code to be added to this file in the next few sections. If the <code>...</code> appears at the beginning of a block of code, it indicates that this is a continuation from code in a previous section that ended with the <code>...</code>syntax.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>The <code>hello_world</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> variable will eventually point to the <code>helloworld </code>function exported by our WebAssembly module, so we set it to <code>null</code> for the time being. The <code>start_string_index</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> variable is the starting location of our string in the linear memory array. We set it to <code>100</code> here, so as not to be close to the 64KB limit. We chose the address 100 arbitrarily. You can choose any address as long as none of the memory you’re using extends past the 64KB limit.</p>
<p>The last variable holds the <code>WebAssembly.Memory</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> object. The number passed represents the number of pages you want to allocate. We initialize it with a size of one page by passing in <code>{initial: 1}</code> as the only parameter. You can allocate up to two gigabytes this way, but setting this value too high can result in an error if the browser is unable to find enough contiguous memory to fulfill the request.</p>
<p><a href="#listing2-9" id="listinganchor2-9">Listing 2-9</a> shows the next variable we need to declare, <code>importObject</code>, which will be passed into our WebAssembly module when we instantiate it.</p>
<p class="CodeLabel"><b>helloworld.js</b></p>
<pre><code>...
let importObject = {
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> env: {
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> buffer: memory,
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> start_string: start_string_index,
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> print_string: function (str_len) {
      const bytes = new Uint8Array (memory.buffer,
        start_string_index, str_len);
      const log_string = new TextDecoder('utf8').decode(bytes);
      console.log (log_string);
    }
<span epub:type="pagebreak" title="24" id="Page_24"/>  }
};
...</code></pre>
<p class="CodeListingCaption"><a id="listing2-9">Listing 2-9</a>: Declaring the <code>importObject</code> in JavaScript</p>
<p>Inside our <code>importObject</code>, we add an object named <code>env</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, an abbreviation of <em>environment</em>, although you can call this object anything you like as long as it matches the name inside the WebAssembly import declaration. These are the values that will be passed into the WebAssembly module when it’s instantiated. If there is any function or value from the embedding environment you want to make available to the WebAssembly module, pass them in here. The <code>env </code>object contains the memory buffer <span class="CodeAnnotation" aria-label="annotation2">2</span> and the starting location <span class="CodeAnnotation" aria-label="annotation3">3</span> of our string within <code>buffer</code>. The third property in <code>env</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> contains our JavaScript function,<code> print_string</code>, which our WebAssembly module will call as we instructed in <a href="#listing2-9">Listing 2-9</a>. This function retrieves the length of the string in our memory buffer and uses it in combination with our starting string index to create a string object. The app then displays the string object on the command line.</p>
<p>Additionally, we add the IIFE that asynchronously loads our WebAssembly module and then calls the <code>helloworld</code> function, as shown in <a href="#listing2-10" id="listinganchor2-10">Listing 2-10</a>.</p>
<p class="CodeLabel"><b>helloworld.js</b></p>
<pre><code>...
( async () =&gt; {   
  let obj = await
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> WebAssembly.instantiate(new Uint8Array (bytes), importObject);
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> ({helloworld: hello_world} = obj.instance.exports);
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> hello_world();
})();</code></pre>
<p class="CodeListingCaption"><a id="listing2-10">Listing 2-10</a>: Instantiating the WebAssembly module in an asynchronous IIFE</p>
<p>The first line of the <code>async</code> module awaits the <code>WebAssembly.instantiate</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> function call, but unlike the simple addition example from Listing 1-1, we’re passing that function the <code>importObject</code> we declared earlier. We then pull the <code>helloworld</code> function out of <code>obj.instance.exports</code> using the destructuring syntax to set the <code>hello_world</code> variable to the <code>obj.instance.exports</code> function <span class="CodeAnnotation" aria-label="annotation2">2</span>.</p>
<p>The last line of our IIFE calls the <code>hello_world</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> function. We enclose our arrow function in parentheses, and then add the function call parentheses to the end of our function declaration, which causes this function to execute immediately.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	We declare asynchronous code using the IIFE <code>async</code>/<code>await</code> syntax in an <code>async</code><code/> function; alternatively, you can create a named <code>async</code> function that you call immediately after the function’s declaration.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" title="25" id="Page_25"/>Once you have the JavaScript and WebAssembly files, run the following call to <code>node</code> from the command line:</p>
<pre><code>node helloworld.js</code></pre>
<p>You should see the following output on the command line:</p>
<pre><code>hello world!</code></pre>
<p>We’ve built the ubiquitous hello world application! Now that you have the hello world application under your belt, we’ll explore variables and how they work in WAT.</p>
<h2 id="h1-501737c02-0003">WAT Variables</h2>
<p class="BodyFirst">WAT treats variables a little differently than other programming languages, so it’s worth providing you with some details here. However, the browser manages local or global WAT variables in the same way it manages JavaScript variables.</p>
<p>WAT has four global and local variable types: i32 (32-bit integer), i64 (64-bit integer), f32 (32-bit floating-point), and f64 (64-bit floating-point). Strings and other more sophisticated data structures need to be managed directly in linear memory. We’ll cover linear memory and the use of more complicated data structures in WAT in Chapter 6. For now, let’s look at each variable type.</p>
<h3 id="h2-501737c02-0003">Global Variables and Type Conversion</h3>
<p class="BodyFirst">As you might expect, you can access globals in WAT from any function, and we generally use globals as constants. <em>Mutable globals</em> can be modified after they’re set and are usually frowned upon because they can introduce side effects in functions that use them. You can import global variables from JavaScript, allowing the JavaScript portion of your application to set constant values inside your module. </p>
<p>When importing global variables, keep in mind that, at the time of this writing, standard JavaScript number variables don’t support 64-bit integer values. Numbers in JavaScript are 64-bit floating-point variables. A 64-bit floating-point variable can represent every value in a 32-bit integer, so JavaScript has no trouble making this conversion. However, you cannot represent all possible 64-bit integer values with a 64-bit floating-point value. Unfortunately, this means that you can work with 64-bit integers in WebAssembly, but if you want to send 64-bit values to JavaScript, it requires additional effort, which is beyond the scope of this book. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The BigInt WebAssembly proposal will make support for JavaScript BigInt types available in WebAssembly. That will make it easier for JavaScript to exchange 64-bit integers with a WebAssembly module. At the writing of this book the BigInt proposal is in the final stages of development by the WebAssembly Working Group.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" title="26" id="Page_26"/>Another detail you must know about data types in WebAssembly and JavaScript is that JavaScript treats all numbers as 64-bit floating-point numbers. When you call a JavaScript function from WebAssembly, the JavaScript engine will perform an implicit conversion to a 64-bit float, no matter what data type you pass. However, WebAssembly will define the imported function as having a specific data type requirement. Even if you pass the same function into the WebAssembly module three times, you’ll need to specify a type that the parameter passed from WebAssembly. </p>
<p>Let’s create a module named <em>globals.wat</em> that imports three numbers from JavaScript. The WAT file in <a href="#listing2-11" id="listinganchor2-11">Listing 2-11</a> declares global variables for a 32-bit integer, a 32-bit floating-point, and a 64-bit floating-point numeric value.</p>
<p class="CodeLabel"><b>globals.wat</b></p>
<pre><code>(module
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (global $import_integer_32  (import "env" "import_i32") i32)
  (global $import_float_32    (import "env" "import_f32") f32)
  (global $import_float_64    (import "env" "import_f64") f64)

<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (import "js" "log_i32" (func $log_i32 (param i32)))
  (import "js" "log_f32" (func $log_f32 (param f32)))
  (import "js" "log_f64" (func $log_f64 (param f64)))

  (func (export "globaltest")
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> (call $log_i32 (global.get $import_integer_32))
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> (call $log_f32 (global.get $import_float_32))
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> (call $log_f64 (global.get $import_float_64))
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing2-11">Listing 2-11</a>: Importing alternative versions of the JavaScript function</p>
<p>We first declare the globals, including their types and import location <span class="CodeAnnotation" aria-label="annotation1">1</span>. We’re also importing a <code>log</code> function from JavaScript. WebAssembly requires us to specify data types, so we import three functions, each with different types for the parameter: a 32-bit integer, a 32-bit float, and a 64-bit float <span class="CodeAnnotation" aria-label="annotation2">2</span>.</p>
<p>The variable passed into <code>$log_f64</code> is <code>(global.get</code><code> $import_float_64)</code>, which tells WebAssembly that the variable we’re pushing onto the stack is global. If you wanted to push a local variable called <code>$x</code> onto the stack, you would need to execute the expression <code>(local.get</code><code> $x)</code>. We’ll cover local variables later in this chapter. </p>
<p>In JavaScript, all of these functions take a dynamic variable. The JavaScript functions will be almost identical. In the function <code>globaltest</code>, we call the 32-bit integer version of the <code>log</code> function (<code>$log_i32</code>) <span class="CodeAnnotation" aria-label="annotation3">3</span>, followed by the 32-bit float (<code>$log_f32</code>) <span class="CodeAnnotation" aria-label="annotation4">4</span> and the 64-bit float (<code>log_f64)</code> <span class="CodeAnnotation" aria-label="annotation5">5</span>. These functions will log three different messages to demonstrate the perils of moving between the native 64-bit floating-point values in JavaScript and the data types supported by WebAssembly. Before we look at the output, we need to create a JavaScript file to run our WebAssembly module. We’ll start by declaring a <code>global_test</code> variable followed by a <code>log_message</code> function that will be called for each of our data types, as shown in <a href="#listing2-12" id="listinganchor2-12">Listing 2-12</a>.</p>
<span epub:type="pagebreak" title="27" id="Page_27"/>
<p class="CodeLabel"><b>globals.js</b></p>
<pre><code>const fs = require('fs');
const bytes = fs.readFileSync('./globals.wasm');
let global_test = null;

let importObject = {
  js: {
    log_i32: (value) =&gt; { console.log ("i32: ", value) },
    log_f32: (value) =&gt; { console.log ("f32: ", value) },
    log_f64: (value) =&gt; { console.log ("f64: ", value) },
  },
  env: {
    import_i32: 5_000_000_000, // _ is ignored in numbers in JS and WAT
    import_f32: 123.0123456789,
    import_f64: 123.0123456789,
  }
};
...</code></pre>
<p class="CodeListingCaption"><a id="listing2-12">Listing 2-12</a>: Setting <code>importObject</code> functions and values</p>
<p>In <a href="#listing2-12">Listing 2-12</a>, there are three different JavaScript functions passed to the WebAssembly module using <code>importObject</code>: <code>log_i32</code>, <code>log_f32</code>, and <code>log_f64</code>. Each of these functions is a wrapper around the <code>console.log</code> function. The functions pass a string as a prefix to the value from the WebAssembly module. These functions take in only a single parameter called <code>value</code>. JavaScript doesn’t assign a type to the parameter in the same way WebAssembly does, so the same function could have been used three times. The only reason we didn’t use the same function three times is because we wanted to change the string that prefixed the values to keep the output clear. </p>
<p>We chose the values in <a href="#listing2-12">Listing 2-12</a> to demonstrate the limitations of each data type. We set the global variable <code>import_int32</code> to a value of <code>5,000,000,000</code>, which we pass into WebAssembly as a 32-bit integer. That value is larger than can be held by a 32-bit integer. We set the global variable <code>import_f32</code> to <code>123.0123456789</code>, which has a higher level of precision than is supported by the 32-bit floating-point variable set in our WebAssembly module. The final global variable set in the <code>importObject</code> is <code>import_f64</code>, which, unlike the previous two variables, is large enough to hold the value passed into it. </p>
<p>The code in <a href="#listing2-13" id="listinganchor2-13">Listing 2-13</a> instantiates our WebAssembly module and executes the <code>globaltest</code> function.</p>
<p class="CodeLabel"><b>globals.js</b></p>
<pre><code>...
( async () =&gt; {
  let obj = await WebAssembly.instantiate(new Uint8Array (bytes),
                                          importObject);
  ({globaltest: global_test} = obj.instance.exports);

  global_test();
})();</code></pre>
<p class="CodeListingCaption"><a id="listing2-13">Listing 2-13</a>: Instantiating the WebAssembly module in the asynchronous IIFE</p>
<p><span epub:type="pagebreak" title="28" id="Page_28"/>Now that we have all our code in the JavaScript and WAT files, we can compile the WAT file into <em>globals.wasm</em> using the following <code>wat2wasm</code> call:</p>
<pre><code>wat2wasm globals.wat</code></pre>
<p>After compiling <em>globals.wasm</em>, we run our application using the following <code>node</code> command:</p>
<pre><code>node globals.js</code></pre>
<p>When you run this JavaScript file using <code>node</code>, you should see the output in <a href="#listing2-14" id="listinganchor2-14">Listing 2-14</a> logged to the console.</p>
<pre><code>i32: 705032704
f32: 123.01234436035156
f64: 123.0123456789</code></pre>
<p class="CodeListingCaption"><a id="listing2-14">Listing 2-14</a>: Output logged to the console from <em>globals.js</em></p>
<p>We passed in a value of <code>5,000,000,000</code> using our <code>importObject</code>, but our output shows a value of <code>705,032,704</code>. The reason is that a 32-bit unsigned integer has a maximum value of 4,294,967,295. If you add <code>1</code> to that number, the 32-bit integer wraps back around to a value of <code>0</code>. So if you take the 5,000,000,000 number we passed in and subtract 4,294,967,296, the result is 705,032,704. The lesson is, if you’re dealing with numbers larger than a few billion, you might not be able to work with 32-bit integers. Unfortunately, as mentioned earlier, you can’t pass 64-bit integers to JavaScript from WebAssembly. If you want to pass 64-bit integers to JavaScript from WebAssembly, you’ll need to convert them to 64-bit floats or pass them as two 32-bit integers.</p>
<p>We passed a value of <code>123.0123456789</code> to our WebAssembly module, but because the 32-bit floating-point number has such limited precision, the best it can do is approximate that number, and it doesn’t do a great job of it. A 32-bit floating-point number in JavaScript and WebAssembly uses 23 bits to represent the number and multiplies it by two raised to an 8-bit exponent value. All floating-point numbers are approximations, but 64-bit floating-point numbers do a much better job of those approximations. The performance differences you’ll see using 32-bit versus 64-bit floating-point numbers vary with your hardware. If you want to use 32-bit floating-point numbers to improve the performance of your application, it’s a good idea to know the target hardware. Some mobile devices might see a larger performance boost using 32-bit floating-point numbers.</p>
<p>The final message shows the 64-bit floating-point value returned to JavaScript as <code>f64: 123.0123456789</code>.</p>
<p>As you can see, this is the first number that remains unmodified from what we passed into the WebAssembly module. That by no means indicates that you should always use 64-bit floating-point numbers. Addition, subtraction, and multiplication typically perform three to five times faster with integers. Dividing by powers of two is also several times faster. However, division by anything but a power of two can be faster with floating-point numbers.</p>
<p><span epub:type="pagebreak" title="29" id="Page_29"/>We’ll explore these data types in more detail in Chapter 4. Now that you have a better understanding of globals and types, let’s examine local variables.</p>
<h3 id="h2-501737c02-0004">Local Variables</h3>
<p class="BodyFirst">In WebAssembly, the values stored in local variables and parameters are pushed onto the stack with the <code>local.get</code> expression. In Chapter 1, we wrote a small function that performed the addition of two parameters passed into the function that looked like <a href="#listing2-15" id="listinganchor2-15">Listing 2-15</a>.</p>
<p class="CodeLabel"><b>AddInt.wat</b></p>
<pre><code>(module
    (func (export "AddInt")
    (param $value_1 i32) (param $value_2 i32)
    (result i32)
        local.get $value_1
        local.get $value_2
        i32.add
    )
)</code></pre>
<p class="CodeListingCaption"><a id="listing2-15">Listing 2-15</a>: WebAssembly module with a 32-bit integer add</p>
<p>Let’s make a few modifications to the code. To demonstrate how we can use local variables, we’ll square the value of the sum that <code>AddInt</code> returned. Create a new file named <em>SumSquared.wat</em> and add the code in <a href="#listing2-16" id="listinganchor2-16">Listing 2-16</a>. The changes are called out with numbers.</p>
<p class="CodeLabel"><b>SumSquared.wat</b></p>
<pre><code>(module
  (func (export <span class="CodeAnnotationCode" aria-label="annotation1">1</span>"SumSquared")
    (param $value_1 i32) (param $value_2 i32)
    (result i32)
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> (local $sum i32)
      
 <span class="CodeAnnotationCode" aria-label="annotation3">3</span> (i32.add (local.get $value_1) (local.get $value_2))
 <span class="CodeAnnotationCode" aria-label="annotation4">4</span> local.set $sum

  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> <b>(</b>i32.mul (<span class="CodeAnnotationCode" aria-label="annotation6">6</span>local.get $sum) (local.get $sum))
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing2-16">Listing 2-16</a>: Bit integer parameter and local variable definition</p>
<p>First, we change the name in the export to <code>SumSquared</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. We add a local variable called <code>$sum</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> that we’ll use to store the result of the call to <code>i32.add</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>. We change <code>i32.add</code> to use the S-Expression syntax. Immediately after that, we call <code>local.set</code><code> $sum</code> to pop the value off the stack and set the new local variable <code>$sum</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>. Then we call <code>i32.mul</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> using the S-Expression syntax, passing in the value of <code>$sum</code> for both parameters. This is done through a call to <code>local.get</code> <span class="CodeAnnotation" aria-label="annotation6">6</span>.</p>
<p>To test this function, create a new JavaScript file named <em>SumSquared.js</em> and add the code in <a href="#listing2-17" id="listinganchor2-17">Listing 2-17</a>.</p>
<span epub:type="pagebreak" title="30" id="Page_30"/>
<pre><code>const fs = require('fs');
const bytes = fs.readFileSync(__dirname + '/SumSquared.wasm');
const val1 = parseInt(process.argv[2]);
const val2 = parseInt(process.argv[3]);

(async () =&gt; {
  const obj =
    await WebAssembly.instantiate(new Uint8Array (bytes));
  let sum_sq =
      obj.instance.exports.SumSquared(val1, val2);
      console.log (
        `(${val1} + ${val2}) * (${val1} + ${val2}) = ${sum_sq}`
      );
})();</code></pre>
<p class="CodeListingCaption"><a id="listing2-17">Listing 2-17</a>: JavaScript that executes the <em>SumSquared.js</em> WebAssembly module</p>
<p>Once you’ve created your <em>SumSquared.js</em> function, you can run it the same way you ran the <em>AddInt.js</em> file earlier, making sure to pass in two extra parameters that represent the values you want to sum and then square. The following command will add 2 and 3, and then square the result:</p>
<pre><code>node SumSquared.js 2 3</code></pre>
<p>The output of that run looks like this:</p>
<pre><code>(2 + 3) * (2 + 3) = 25</code></pre>
<p>You should now understand how to set a local variable from a value on the stack and how to add a value to the stack from a global variable. Next, let’s explore how to unpack the S-Expression syntax.</p>
<h3 id="h2-501737c02-0005">Unpacking S-Expressions</h3>
<p class="BodyFirst">So far we’ve been mixing the use of S-Expressions with the linear WAT syntax. However, the browser debugger doesn’t keep your S-Expressions intact when you’re debugging; instead, it unpacks them. Because you’ll want to use your knowledge of WAT to decompile and debug WebAssembly, you’ll need to understand the unpacking process. We’ll walk through the process the <code>wat2wasm</code> compiler uses to unpack a short piece of WAT code. The unpacking process evaluates the expressions inside out first and then in order. It initially dives into each S-Expression looking for subexpressions. If subexpressions exist, it evaluates the subexpressions first. If two expressions are at the same depth, it evaluates them in order. Let’s look at <a href="#listing2-18" id="listinganchor2-18">Listing 2-18</a>.</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span><span class="LiteralGray"> </span>(i32.mul   <span class="LiteralGray">       ;; executes 7th (last)</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> (i32.add        <span class="LiteralGray">;; executes 3rd</span>
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> (i32.const 3) <span class="LiteralGray">;; executes 1st</span>
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> (i32.const 2) <span class="LiteralGray">;; executes 2nd</span>
  )
<span epub:type="pagebreak" title="31" id="Page_31"/><span class="CodeAnnotationCode" aria-label="annotation5">5</span> (i32.sub        <span class="LiteralGray">;; executes 6th</span>
  <span class="CodeAnnotationCode" aria-label="annotation6">6</span> (i32.const 9) <span class="LiteralGray">;; executes 4th</span>
  <span class="CodeAnnotationCode" aria-label="annotation7">7</span> (i32.const 7) <span class="LiteralGray">;; executes 5th</span>
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing2-18">Listing 2-18</a>: Using the S-Expression syntax</p>
<p>First, we need to go inside our <code>i32.mul</code> expression <span class="CodeAnnotation" aria-label="annotation1">1</span> to see if any subexpressions exist. We find two subexpressions, an <code>i32.add</code> expression <span class="CodeAnnotation" aria-label="annotation2">2</span> and an <code>i32.sub</code> expression <span class="CodeAnnotation" aria-label="annotation5">5</span>. We look at the first of these two expressions and go inside <code>i32.add</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, evaluating <code>(i32.const</code><code> 3)</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, which pushes a 32-bit integer <code>3</code> onto our stack. Because nothing is left to evaluate inside that statement, we move on to evaluate <code>(i32.const</code><code> 2)</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>, which pushes a 32-bit integer <code>2</code> onto the stack. Then the S-Expression executes <code>i32.add</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>. The first three lines executed in the S-Expression are shown in <a href="#listing2-19" id="listinganchor2-19">Listing 2-19</a>.</p>
<pre><code>i32.const 3
i32.const 2
i32.add</code></pre>
<p class="CodeListingCaption"><a id="listing2-19">Listing 2-19</a>: Code from <code>i32.add</code> after it’s unpacked</p>
<p>Now that <code>i32.add</code> is executed, the next piece to get unpacked is <code>i32.sub</code>. Similarly, the code first goes inside the S-Expression and executes the <code>(i32.const</code><code> 9)</code> expression <span class="CodeAnnotation" aria-label="annotation6">6</span> followed by the <code>(i32.const</code><code> 7)</code> expression <span class="CodeAnnotation" aria-label="annotation7">7</span>. Once those two constants are pushed onto the stack, the code executes <code>i32.sub</code>. The unpacked subexpression looks like <a href="#listing2-20" id="listinganchor2-20">Listing 2-20</a>.</p>
<pre><code>i32.const 9
i32.const 7
i32.sub</code></pre>
<p class="CodeListingCaption"><a id="listing2-20">Listing 2-20</a>: Code from <code>i32.sub</code> after the S-Expression is unpacked</p>
<p>After the <code>i32.add</code> and <code>i32.sub</code> S-Expressions have been executed, the unpacked version executes the <code>i32.mul</code> command. </p>
<p>The fully unpacked version of the S-Expression is shown in <a href="#listing2-21" id="listinganchor2-21">Listing 2-21</a>.</p>
<pre><code>i32.const 3  <span class="LiteralGray">;; Stack = [3]</span>
i32.const 2  <span class="LiteralGray">;; Stack = [2, 3]</span>
i32.add      <span class="LiteralGray">;; 2 &amp; 3 popped from stack, added sum of 5 pushed onto stack [5]</span>

i32.const 9  <span class="LiteralGray">;; Stack = [9,5]</span>
i32.const 7  <span class="LiteralGray">;; Stack = [7,9,5]</span>
i32.sub      <span class="LiteralGray">;; 7 &amp; 9 popped off stack . 9-7=2 pushed on stack [2,5]</span>

i32.mul      <span class="LiteralGray">;; 2,5 popped off stack, 2x5=10 is pushed on the stack [10]</span></code></pre>
<p class="CodeListingCaption"><a id="listing2-21">Listing 2-21</a>: Example of using the WAT stack</p>
<p><span epub:type="pagebreak" title="32" id="Page_32"/>How the stack machine works might seem a little daunting at first, but it will feel more natural once you get accustomed to it. We recommend using S-Expressions until you’re comfortable with the stack machine. The S-Expression syntax is an excellent way to ease your way into WAT if you’re only familiar with higher-level languages.</p>
<h3 id="h2-501737c02-0006">Indexed Variables</h3>
<p class="BodyFirst">WAT doesn’t require you to name your variables and functions. Instead, you can use index numbers to reference functions and variables that you haven’t yet named. From time to time, you might see WAT code that uses these indexed variables and functions. Sometimes this code comes from disassembly, although we’ve also seen people write code that looks like this occasionally. </p>
<p>Code that calls <code>local.get</code> followed by a number is retrieving a local variable based on the order it appears in the WebAssembly code. For example, we could have written our <em>AddInt.wat</em> file in <a href="#listing2-21">Listing 2-21</a> like the code in <a href="#listing2-22" id="listinganchor2-22">Listing 2-22</a>.</p>
<pre><code>(module
    (func (export "AddInt")
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> (param i32 i32)
    (result i32)
      <span class="CodeAnnotationCode" aria-label="annotation2">2</span> local.get 0
      <span class="CodeAnnotationCode" aria-label="annotation3">3</span> local.get 1
        i32.add
    )
)</code></pre>
<p class="CodeListingCaption"><a id="listing2-22">Listing 2-22</a>: Using variables</p>
<p>As you can see, we don’t name the parameters in the <code>param</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> expression. A convenient part of this code style is that you can declare multiple parameters in a single expression by adding more types. When we call <code>local.get</code>, we need to pass in a zero indexed number to retrieve the proper parameter. The first call to <code>local.get</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> retrieves the first parameter by passing in <code>0</code>. The second call to <code>local.get</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> retrieves the second parameter by passing in <code>1</code>. You can also use this syntax for functions and global variables. I find this syntax difficult to read, so I won’t use it in this book. However, I felt it was necessary to introduce because some debuggers use it.</p>
<h3 id="h2-501737c02-0007">Converting Between Types</h3>
<p class="BodyFirst">JavaScript developers don’t need to deal with converting between different numeric types. All numbers in JavaScript are 64-bit floating-point numbers. That simplifies coding for developers but comes at a performance cost. When you’re working with WebAssembly, you need to be more familiar with your numeric data. If you need to perform numeric operations between two variables with different data types, you’ll need to do some conversion. <a href="#table2-1" id="tableanchor2-1">Table 2-1</a> <span epub:type="pagebreak" title="33" id="Page_33"/>provides the conversion functions you can use in WAT to convert between the different numeric data types.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-1">Table 2-1</a>: Numeric Type Conversion Functions</p></figcaption>
<table id="table-501737c02-0001" border="1">
<thead>
<tr>
<td><b>Function</b></td>
<td><b>Action</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>i32.trunc_s/f64<br/>
i32.trunc_u/f64</td>
<td>Convert a 64-bit float to a 32-bit integer<br/>
</td>
</tr>
<tr>
<td>i32.trunc_s/f32<br/>
i32.trunc_u/f32<br/>
i32.reinterpret/f32</td>
<td>Convert a 32-bit float to a 32-bit integer<br/>
<br/>
</td>
</tr>
<tr>
<td>i32.wrap/i64</td>
<td>Convert a 64-bit integer to a 32-bit integer</td>
</tr>
<tr>
<td>i64.trunc_s/f64<br/>
i64.trunc_u/f64<br/>
i64.reinterpret/f64</td>
<td>Convert a 64-bit float to a 64-bit integer<br/>
<br/>
</td>
</tr>
<tr>
<td>i64.extend_s/i32<br/>
i64.extend_u/i32</td>
<td>Convert a 32-bit integer to a 64-bit integer<br/>
</td>
</tr>
<tr>
<td>i64.trunc_s/f32<br/>
i64.trunc_u/f32</td>
<td>Convert a 32-bit float to a 64-bit integer<br/>
</td>
</tr>
<tr>
<td>f32.demote/f64</td>
<td>Convert a 64-bit float to a 32-bit float</td>
</tr>
<tr>
<td>f32.convert_s/i32<br/>
f32.convert_u/i32<br/>
f32.reinterpret/i32</td>
<td>Convert a 32-bit integer to a 32-bit float<br/>
<br/>
</td>
</tr>
<tr>
<td>f32.convert_s/i64<br/>
f32.convert_u/i64</td>
<td>Convert a 64-bit integer to a 32-bit float<br/>
</td>
</tr>
<tr>
<td>f64.promote/f32</td>
<td>Convert a 32-bit float to a 64-bit float</td>
</tr>
<tr>
<td>f64.convert_s/i32<br/>
f64.convert_u/i32</td>
<td>Convert a 32-bit integer to a 64-bit float<br/>
</td>
</tr>
<tr>
<td>f64.convert_s/i64<br/>
f64.convert_u/i64<br/>
f64.reinterpret/i64</td>
<td>Convert a 64-bit integer to a 64-bit float<br/>
<br/>
</td>
</tr>
</tbody>
</table>
</figure>
<p>I omitted quite a bit of information from this table to stay focused. The <code>_u </code>and <code>_s</code> suffixes on expressions, such as <code>convert</code>, <code>trunc</code>, and <code>extend</code>, let WebAssembly know whether the integers you’re working with are unsigned (cannot be negative) or signed (can be negative), respectively. A <code>trunc</code> expression truncates the fractional portion of a floating-point number when it converts it to an integer. Floating-point numbers can be promoted from an <code>f32</code> to an <code>f64</code> or demoted from an <code>f64</code> to an <code>f32</code>. Integers are simply converted to floating-point numbers. The <code>wrap </code>command puts the lower 32 bits of a 64-bit integer into an <code>i32</code>. The <code>reinterpret </code>command keeps the bits of an integer or floating-point value the same when it reinterprets them as a different data type. </p>
<h2 id="h1-501737c02-0004"><span epub:type="pagebreak" title="34" id="Page_34"/>if/else Conditional Logic</h2>
<p class="BodyFirst">One way that WAT differs from an assembly language is that it contains some higher-level control flow statements, such as <code>if</code> and <code>else</code>. WebAssembly doesn’t have a boolean type; instead, it uses <code>i32</code> values to represent booleans. An <code>if</code> statement requires an <code>i32</code> to be on the top of the stack to evaluate control flow. The <code>if</code> statement evaluates any non-zero value as true and zero as false. The syntax for an <code>if</code>/<code>else</code> statement using S-Expressions looks like <a href="#listing2-23" id="listinganchor2-23">Listing 2-23</a>.</p>
<pre><code><span class="LiteralGray">;; This code is for demonstration and not part of a larger app</span>
(if (local.get $bool_i32)
  (then
    <span class="LiteralGray">;; do something if $bool_i32 is not 0</span>
<span class="LiteralGray">    ;; nop is a "no operation" opcode.  </span>
    nop <span class="LiteralGray">;; I use it to stand in for code that would actually do something.</span>
  )
  (else
    <span class="LiteralGray">;; do something if $bool_i32 is 0</span>
    nop
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing2-23">Listing 2-23</a>: The <code>if</code>/<code>else</code> syntax using S-Expressions</p>
<p>Let’s also look at what the unpacked version of the <code>if</code>/<code>else</code> statements look like. Unpacking an <code>if</code>/<code>else</code> statement might look a little different than you would expect. There is no <code>(then</code><code>)</code> expression in the unpacked version. <a href="#listing2-24" id="listinganchor2-24">Listing 2-24</a> shows how the code in <a href="#listing2-23">Listing 2-23</a> would look after it’s unpacked.</p>
<pre><code><span class="LiteralGray">;; This code is for demonstration and not part of a larger app</span>
local.get $bool_i32

if
 <span class="LiteralGray"> ;; do something if $bool_i32 is not 0</span>
  nop
else
<span class="LiteralGray">  ;; do something if $bool_i32 is 0</span>
  nop
end</code></pre>
<p class="CodeListingCaption"><a id="listing2-24">Listing 2-24</a>: The <code>if</code>/<code>else</code> statement using the linear syntax</p>
<p>The <code>then</code> S-Expression is pure syntactic sugar and doesn’t exist in the unpacked version of our code. The unpacked version requires an <code>end</code> statement that doesn’t exist in the S-Expression syntax. </p>
<p>When you’re writing high-level programs, you use boolean logic with your <code>if</code>/<code>else</code> statements. In JavaScript, you might have an <code>if</code> statement that looks something like this:</p>
<pre><code>if( x &gt; y &amp;&amp; y &lt; 6 )</code></pre>
<p><span epub:type="pagebreak" title="35" id="Page_35"/>To replicate this in WebAssembly, you would need to use expressions that conditionally return 32-bit integer values. <a href="#listing2-25" id="listinganchor2-25">Listing 2-25</a> shows how we would do the logic from the JavaScript <code>if</code> example with <code>x</code> and <code>y</code> as 32-bit integers.</p>
<pre><code><span class="LiteralGray">;; This code is for demonstration and not part of a larger app</span>
(if
  (i32.and
    (i32.gt_s (local.get $x) (local.get $y) ) <span class="LiteralGray">;; signed greater than</span>
    (i32.lt_s  (local.get $y) (i32.const 6) ) <span class="LiteralGray">;; signed less than</span>
  )
  (then
    <span class="LiteralGray">;; x is greater than y and y is less than 6</span>
    nop
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing2-25">Listing 2-25</a>: An <code>if</code> expression with an <code>i32.and</code> using S-Expression syntax</p>
<p>It looks a bit complicated in comparison. The <code>i32.and</code> expression performs a bitwise AND operation on 32-bit integers. It ends up working out because <code>i32.gt_s</code> and <code>i32.lt_s</code> both return <code>1</code> if true and <code>0</code> if false. In WebAssembly, you must keep in mind that you’re using bitwise AND/OR operations; if you use an <code>i32.and</code> on a value of <code>2</code> and a value of <code>1</code>, it will result in <code>0</code> because of the way the binary AND works. You might want a logical AND instead of a binary AND, but <code>i32.and</code> is a binary AND. If you’re unfamiliar with binary AND/OR operations, we discuss them in more detail in Chapter 4. In some ways, complicated <code>if</code> expressions look better when they’re unpacked. <a href="#listing2-26" id="listinganchor2-26">Listing 2-26</a> shows the code in <a href="#listing2-25">Listing 2-25</a> without the sugar.</p>
<pre><code><span class="LiteralGray">;; This code is for demonstration and not part of a larger app</span>
local.get $x
local.get $y
i32.gt_s      <span class="LiteralGray">;; pushes 1 on the stack if $x &gt; $y</span>

local.get $y
i32.const 6
i32.lt_s      <span class="LiteralGray">;; pushes 1 on the stack if $y &lt; 6</span>

i32.and       <span class="LiteralGray">;; do a bitwise and on the last two values on the stack</span>

if
  <span class="LiteralGray">;; x is greater than y and y is less than 6</span>
  nop
end</code></pre>
<p class="CodeListingCaption"><a id="listing2-26">Listing 2-26</a>: An <code>if</code> statement with <code>i32.and</code> using stack syntax</p>
<p><a href="#listing2-27" id="listinganchor2-27">Listing 2-27</a> shows there are similar expressions you can use if <code>$x</code> and <code>$y</code> are 64-bit or 32-bit floating-point numbers.</p>
<pre><code><span class="LiteralGray">;; This code is for demonstration and not part of a larger app</span>
(if
<span epub:type="pagebreak" title="36" id="Page_36"/>  (i32.and
 <span class="CodeAnnotationCode" aria-label="annotation1">1</span> (f32.gt (local.get $x) (local.get $y) )
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> (f32.lt  (local.get $y) (f32.const 6) )
  )
  (then
   <span class="LiteralGray"> ;; x is greater than y and y is less than 6</span>
    nop
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing2-27">Listing 2-27</a>: Using <code>f32</code> comparisons but <code>i32.and</code> results</p>
<p>Notice that we changed <code>i32.gt_s</code> and <code>i32.lt_s</code> to <code>f32.gt</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and <code>f32.lt</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, respectively. Many integer operations must specify whether they support negative numbers using the <code>_s</code> suffix. You don’t have to do that for floating-point numbers, because all floating-point numbers are signed and have a dedicated sign bit. </p>
<p>There are a total of 40 comparison expressions in WebAssembly. <a href="#table2-2" id="tableanchor2-2">Table 2-2</a> shows expressions that are useful in conjunction with the <code>if</code>/<code>else</code> expressions. Unless otherwise stated, these functions pop two values off the stack, compare them, and push <code>1</code> on the stack if true and <code>0</code> on the stack if false.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table2-2">Table 2-2</a>: Functions to Use with <code>if/else</code></p></figcaption>
<table id="table-501737c02-0002" border="1">
<thead>
<tr>
<td><b>Function</b></td>
<td><b>Action</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>i32.eq<br/>
i64.eq<br/>
f32.eq<br/>
f64.eq</td>
<td>Test for equality<br/>
<br/>
<br/>
</td>
</tr>
<tr>
<td>i32.ne<br/>
i64.ne<br/>
f32.ne<br/>
f64.ne</td>
<td>Not equal<br/>
<br/>
<br/>
</td>
</tr>
<tr>
<td>i32.lt_s<br/>
i32.lt_u<br/>
i64.lt_s<br/>
i64.lt_u<br/>
f32.lt<br/>
f64.lt</td>
<td>Less than test. The <code>_s</code> suffix indicates signed comparison; <code>_u</code> indicates unsigned.<br/>
<br/>
<br/>
<br/>
</td>
</tr>
<tr>
<td>i32.le_s<br/>
i32.le_u<br/>
i64.le_s<br/>
i64.le_u<br/>
f32.le<br/>
f64.le</td>
<td>Less than or equal test. The <code>_s</code> suffix indicates signed comparison; <code>_u</code> indicates unsigned.<br/>
<br/>
<br/>
<br/>
<br/>
</td>
</tr>
<tr>
<td><span epub:type="pagebreak" title="37" id="Page_37"/>i32.gt_s<br/>
i32.gt_u<br/>
f32.gt<br/>
f64.gt<br/>
i64.gt_s<br/>
i64.gt_u</td>
<td>Greater than test. The <code>_s</code> suffix indicates signed comparison; <code>_u</code> indicates unsigned.<br/>
<br/>
<br/>
<br/>
<br/>
</td>
</tr>
<tr>
<td>i32.ge_s<br/>
i32.ge_u<br/>
i64.ge_s<br/>
i64.ge_u<br/>
f32.ge<br/>
f64.ge</td>
<td>Greater than or equal test. The <code>_s</code> suffix indicates signed comparison; <code>_u</code> indicates unsigned.<br/>
<br/>
<br/>
<br/>
<br/>
</td>
</tr>
<tr>
<td>i32.and<br/>
i64.and</td>
<td>Bitwise AND<br/>
</td>
</tr>
<tr>
<td>i32.or<br/>
i64.or</td>
<td>Bitwise OR<br/>
</td>
</tr>
<tr>
<td>i32.xor<br/>
i64.xor</td>
<td>Bitwise exclusive OR<br/>
</td>
</tr>
<tr>
<td>i32.eqz<br/>
i64.eqz</td>
<td>Test a floating-point number to see if it has a zero value<br/>
</td>
</tr>
</tbody>
</table>
</figure>
<h2 id="h1-501737c02-0005">Loops and Blocks</h2>
<p class="BodyFirst">The branching expressions in WAT are different than branching statements you might find in an assembly language. The differences prevent the spaghetti code that comes about as the result of jumps to arbitrary locations. If you want your code to jump backward, you must put your code inside a loop. If you want your code to jump forward, you must put it inside a block. For the kind of functionality you would see in a high-level programming language, you must use the loop and block statements together. Let’s explore these structures with some throwaway code examples that won’t be a part of a larger app.</p>
<h3 id="h2-501737c02-0008">The block Statement</h3>
<p class="BodyFirst">First, we’ll look at the <code>block</code> expression. The block and loop statements in WAT work a bit like <code>goto</code> statements in assembly or some low-level programming languages. However, the code can only jump to the end of a <code>block</code> if it’s inside that <code>block</code>. That prevents the code from arbitrarily branching to a <code>block</code> label from anywhere within your program. If the code jumps to the end of a <code>block</code>, the code that performs that jump must exist inside that <code>block</code>. <a href="#listing2-28" id="listinganchor2-28">Listing 2-28</a> shows an example.</p>
<span epub:type="pagebreak" title="38" id="Page_38"/>
<pre><code><span class="LiteralGray">;; This code is for demonstration and not part of a larger app</span>
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> (block $jump_to_end
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> br $jump_to_end

<span class="LiteralGray">   ;; code below the branch does not execute. br jumps to the end of the block</span>
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> nop
)

<span class="LiteralGray">;; This is where the br statement jumps to</span>
<span class="CodeAnnotationHang" aria-label="annotation4">4</span><span class="LiteralGray"> </span>nop</code></pre>
<p class="CodeListingCaption"><a id="listing2-28">Listing 2-28</a>: Declaring a <code>block</code> in WAT</p>
<p>The <code>br</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> statement is a branch statement that instructs the program to jump to a different location in the code. You might expect <code>br</code> to jump back to the beginning of the block where the label is defined <span class="CodeAnnotation" aria-label="annotation1">1</span>. But that isn’t what happens. If you use a <code>br</code> statement within a block to jump to the block’s label, it exits that block and begins to execute the code immediately outside the block <span class="CodeAnnotation" aria-label="annotation4">4</span>. That means that the code directly below the <code>br</code> statement <span class="CodeAnnotation" aria-label="annotation3">3</span> never executes. As mentioned earlier, this code isn’t meant to be used, we only wanted to demonstrate how the <code>block</code> and <code>br</code> statements work.</p>
<p>The way we use the <code>br</code> statement here isn’t useful. Because the <code>br</code> statement always branches to the end of the labeled block, you want it to branch conditionally. </p>
<p>The <code>br_if</code> conditional branch in <a href="#listing2-29" id="listinganchor2-29">Listing 2-29</a> is used to branch given a condition, unlike the code in <a href="#listing2-28">Listing 2-28</a>.</p>
<pre><code><span class="LiteralGray">;; This code is for demonstration and not part of a larger app</span>
(block $jump_to_end
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> local.get $should_I_branch
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> br_if $jump_to_end
	
<span class="LiteralGray">  ;; code below the branch will execute if $should_I_branch is 0</span>
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> nop
)

<span class="CodeAnnotationHang" aria-label="annotation4">4</span><span class="LiteralGray"> </span>nop</code></pre>
<p class="CodeListingCaption"><a id="listing2-29">Listing 2-29</a>: Branching to the end of the block with <code>br_if</code></p>
<p>The new version of the code pushes a 32-bit integer value <code>$should_I_branch</code> onto the stack <span class="CodeAnnotation" aria-label="annotation1">1</span>. The <code>br_if</code> statement pops the top value off the stack <span class="CodeAnnotation" aria-label="annotation2">2</span>, and if that value isn’t <code>0</code>, branches to the end of the <code>$jump_to_end</code> block <span class="CodeAnnotation" aria-label="annotation4">4</span>. If <code>$should_I_branch</code> is <code>0</code>, the code in the block below the <code>br_if</code> statement <span class="CodeAnnotation" aria-label="annotation3">3</span> executes.</p>
<h2 id="h1-501737c02-0006">The loop Expression</h2>
<p class="BodyFirst">The <code>block</code> expression always jumps to the end of the <code>block</code> on a branch. If you need to jump to the beginning of a block of code, use the <code>loop</code> <span epub:type="pagebreak" title="39" id="Page_39"/>statement. <a href="#listing2-30" id="listinganchor2-30">Listing 2-30</a> shows how a WAT <code>loop</code> statement works. You would be mistaken if you think this code executes in an infinite loop.</p>
<pre><code><span class="LiteralGray">;; This code is for demonstration and not part of a larger app</span>
(loop $not_gonna_loop
<span class="LiteralGray">  ;; this code will only execute once</span>
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> nop
)

<span class="LiteralGray">;; because there is no branch in our loop, it exits the loop block at the end</span>
<span class="CodeAnnotationHang" aria-label="annotation2">2</span><span class="LiteralGray"> </span>nop</code></pre>
<p class="CodeListingCaption"><a id="listing2-30">Listing 2-30</a>: A <code>loop</code> expression that doesn’t loop</p>
<p>In fact, a <code>loop</code> expression in WAT doesn’t loop on its own; it needs a branch statement located inside the loop to branch back to the beginning of the <code>loop</code> expression. A <code>loop</code> block will execute the code inside it <span class="CodeAnnotation" aria-label="annotation1">1</span> just like a <code>block</code> expression and, without a branch, exits at the end of the block <span class="CodeAnnotation" aria-label="annotation2">2</span>. </p>
<p>If for any reason you want to create an infinite loop, you need to execute a <code>br</code> statement at the end of your <code>loop</code>, as shown in <a href="#listing2-31" id="listinganchor2-31">Listing 2-31</a>.</p>
<pre><code><span class="LiteralGray">;; This code is for demonstration and not part of a larger app</span>
  (loop $infinite_loop
   <span class="LiteralGray"> ;; this code will execute in an infinite loop</span>
    nop

  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> br $infinite_loop
  )

<span class="LiteralGray">  ;; this code will never execute because the loop above is infinite</span>
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> nop</code></pre>
<p class="CodeListingCaption"><a id="listing2-31">Listing 2-31</a>: Branching in an infinite loop</p>
<p>The <code>br</code> statement <span class="CodeAnnotation" aria-label="annotation1">1</span> always branches back to the top of the <code>$infinite_loop</code> block with every iteration. The code below the <code>loop</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> never executes. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	When you write WAT to execute in the browser, you never want to use an infinite loop because WebAssembly doesn’t do your browser rendering; so you need to relinquish control back to the browser, or the browser hangs.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-501737c02-0009">Using block and loop Together</h3>
<p class="BodyFirst">To make your loop able to break and continue, you need to use the <code>loop</code> and the <code>block</code> expressions together. Let’s put together a little WebAssembly module and JavaScript app that finds factorials. The program will run a loop until we have the factorial value of the number passed into the function. That will allow us to test the <code>continue</code> and <code>break</code> functionality of our <code>loop</code> expression. Our simple loop will calculate the factorial value for each number up to some parameter value <code>$n</code> that we’ll pass in from JavaScript. Then the value of <code>$n</code> factorial will be returned to JavaScript.</p>
<p><span epub:type="pagebreak" title="40" id="Page_40"/>Create a new file named <em>loop.wat </em>and add the code in <a href="#listing2-32" id="listinganchor2-32">Listing 2-32</a>.</p>
<p class="CodeLabel"><b>loop.wat</b></p>
<pre><code>(module
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> (import "env" "log" (func $log (param i32 i32)))

  (func $loop_test (export "loop_test") (param $n i32)
    (result i32)

    (local $i         i32)
    (local $factorial i32)
    
    (local.set $factorial (i32.const 1))

  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> (loop $continue (block $break	<span class="LiteralGray">;; $continue loop and $break block</span>
    <span class="CodeAnnotationCode" aria-label="annotation3">3</span> (local.set $i            	<span class="LiteralGray">;; $i++	</span>
        (i32.add (local.get $i) (i32.const 1))
      )

<span class="LiteralGray">    </span><span class="CodeAnnotationCode" aria-label="annotation4">4</span><span class="LiteralGray"> ;; value of $i factorial</span>
      (local.set $factorial <span class="LiteralGray">;; $factorial = $i * $factorial	</span>
        (i32.mul (local.get $i) (local.get $factorial))
      )
	
 <span class="LiteralGray">     ;; call $log passing parameters $i, $factorial</span>
    <span class="CodeAnnotationCode" aria-label="annotation5">5</span> (call $log (local.get $i) (local.get $factorial))
      
    <span class="CodeAnnotationCode" aria-label="annotation6">6</span> (br_if $break
       (i32.eq (local.get $i) (local.get $n)))<span class="LiteralGray">;;if $i==$n break from loop</span>
    <span class="CodeAnnotationCode" aria-label="annotation7">7</span> br $continue      <span class="LiteralGray">  ;; branch to top of loop</span>
    ))

  <span class="CodeAnnotationCode" aria-label="annotation8">8</span> local.get $factorial<span class="LiteralGray">  ;; return $factorial to calling JavaScript</span>
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing2-32">Listing 2-32</a>: Branching forward and backward with a <code>loop</code> and a <code>block</code></p>
<p>The first expression in this module is an import of the <code>$log</code> function <span class="CodeAnnotation" aria-label="annotation1">1</span>. In a moment, we’ll write this function in JavaScript and call it on every pass through our loop to log the value of <code>$i</code> factorial for each pass. We labeled the loop <code>$continue</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> and the block <code>$break</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> because branching to <code>$continue</code> will continue to execute the loop and branching to <code>$break</code> will break out of the loop. We could have done this without using the <code>$break</code> block, but we want to demonstrate how the loop can work in conjunction with a block. This allows your code to work like a <code>break</code> and a <code>continue</code> statement in a high-level programming language.</p>
<p>The <code>loop</code> increments <code>$i</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> and then calculates a new <code>$factorial</code> value by multiplying <code>$i</code> by the old <code>$factorial</code> value <span class="CodeAnnotation" aria-label="annotation4">4</span>. It then makes a call to log with <code>$i</code> and <code>$factorial</code> <span class="CodeAnnotation" aria-label="annotation5">5</span>. We use a <code>br_if</code> to break out of the <code>loop</code> if <code>$i</code> == <code>$n</code> <span class="CodeAnnotation" aria-label="annotation6">6</span>. If we don’t break out of <code>loop</code>, we branch back to the top of <code>loop</code> <span class="CodeAnnotation" aria-label="annotation7">7</span>. When the <code>loop</code> exits, we push the value of <code>$factorial</code> onto the stack <span class="CodeAnnotation" aria-label="annotation8">8</span> so we can return that value to the calling JavaScript.</p>
<p><span epub:type="pagebreak" title="41" id="Page_41"/>Once you have your WAT file, compile it into a WebAssembly file using the following command:</p>
<pre><code>wat2wasm loop.wat</code></pre>
<p>Now we’ll create a JavaScript file to execute the WebAssembly. Create a <em>loop.js</em> file and enter the code in <a href="#listing2-33" id="listinganchor2-33">Listing 2-33</a>.</p>
<p class="CodeLabel"><b>loop.js</b></p>
<pre><code>const fs = require('fs');
const bytes = fs.readFileSync(__dirname + '/loop.wasm');
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> const n = parseInt(process.argv[2] || "1"); <span class="LiteralGray">// we will loop n times</span>
let loop_test = null;

let importObject = {
  env: {
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> log: function(n, factorial) { <span class="LiteralGray">// log n factorial to output tag</span>
      console.log(`${n}! = ${factorial}`);
    }
  }
};


( async() =&gt; {
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> let obj = await WebAssembly.instantiate( new Uint8Array(bytes),
                                           importObject );

<span class="CodeAnnotationCode" aria-label="annotation4">4</span> loop_test = obj.instance.exports.loop_test;

<span class="CodeAnnotationCode" aria-label="annotation5">5</span> const factorial = loop_test(n);<span class="LiteralGray"> // call our loop test</span>
<span class="CodeAnnotationCode" aria-label="annotation6">6</span> console.log(`result ${n}! = ${factorial}`);
<span class="CodeAnnotationCode" aria-label="annotation7">7</span> if (n &gt; 12) {
    console.log(`
    ===============================================================
    Factorials greater than 12 are too large for a 32-bit integer.
    ===============================================================
    `)
  }
})();</code></pre>
<p class="CodeListingCaption"><a id="listing2-33">Listing 2-33</a>: Calling the <code>loop_test</code> from JavaScript</p>
<p>The <code>log</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> function, which our WAT code will call, logs a string to the console with the values of <code>n </code><span class="CodeAnnotation" aria-label="annotation1">1</span> and <code>n</code> factorial passed from the WAT <code>loop</code>. When we instantiate the module <span class="CodeAnnotation" aria-label="annotation3">3</span>, we pass a value of <code>n</code> to the <code>loop_test</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> function. The <code>loop_test</code> function finds the factorial as a result <span class="CodeAnnotation" aria-label="annotation5">5</span>. We then use a <code>console.log</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> call to display the value of <code>n</code> and <code>n</code> factorial. We have a check at the end to make sure the number we enter isn’t greater than a value of <code>12</code> <span class="CodeAnnotation" aria-label="annotation7">7</span>, because signed 32-bit integers only support numbers up to about 2 billion. Run<em> loop.js</em> using <code>node</code> by executing the following on the command line:</p>
<pre><code>node loop.js 10</code></pre>
<p><span epub:type="pagebreak" title="42" id="Page_42"/><a href="#listing2-34" id="listinganchor2-34">Listing 2-34</a> shows the output you should see on the command line.</p>
<pre><code>1! = 1
2! = 2
3! = 6
4! = 24
5! = 120
6! = 720
7! = 5040
8! = 40320
9! = 362880
10! = 3628800
result 10! = 3628800</code></pre>
<p class="CodeListingCaption"><a id="listing2-34">Listing 2-34</a>: Output from <em>loop.js</em></p>
<p>Now that you know how loops work in WAT, let’s look at branch tables.</p>
<h3 id="h2-501737c02-0010">Branching with br_table</h3>
<p class="BodyFirst">Another way to use the <code>block</code> expression in WAT is in conjunction with a <var>br_table</var><em> expression, </em>which allows you to implement a kind of <code>switch</code> statement. It’s meant to provide the kind of jump table performance you get with a <code>switch</code> statement when there are a large number of branches. The <code>br_table</code> expression takes a list of blocks and an index into that list of blocks. It then breaks out of whichever block your index points to. The awkward thing about using a branch table is that the code can only break out of a block it’s inside. That means you must declare all of your blocks ahead of time. <a href="#listing2-35" id="listinganchor2-35">Listing 2-35</a> shows what the WAT code looks like to build a <code>br_table</code>.</p>
<pre><code><span class="LiteralGray">;; This code is for demonstration and not part of a larger app</span>
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> (block $block_0
(block $block_1
(block $block_2
(block $block_3
(block $block_4
(block $block_5
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> (br_table $block_0 $block_1 $block_2 $block_3 $block_4 $block_5
  (local.get $val)
)
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> ) <span class="LiteralGray">;; block 5</span>
i32.const 55
return

)   <span class="LiteralGray">;; block 4</span>
i32.const 44
return

)   <span class="LiteralGray"> ;; block 3</span>
i32.const 33
return

)    <span class="LiteralGray">;; block 2</span>
i32.const 22
<span epub:type="pagebreak" title="43" id="Page_43"/>return

)  <span class="LiteralGray">  ;; block 1</span>
i32.const 11
return

)   <span class="LiteralGray">;; block 0</span>
i32.const 0
return</code></pre>
<p class="CodeListingCaption"><a id="listing2-35">Listing 2-35</a>: Using the <code>br_table</code> syntax from within WAT</p>
<p>We define all the <code>block</code> expressions before the <code>br_table</code> expression <span class="CodeAnnotation" aria-label="annotation1">1</span>. So when the <code>br_table</code> expression is called <span class="CodeAnnotation" aria-label="annotation2">2</span>, it’s not always completely clear where in the code it will jump. This is why we added the comments <span class="CodeAnnotation" aria-label="annotation3">3</span> in the code indicating which <code>block</code> was ending. </p>
<p>The <code>br_table</code> provides some performance improvement over the use of <code>if</code> expressions when you have a large number of branches. In our testing, using the <code>br_table</code> expression wasn’t worthwhile until there were about a dozen branches. Of course this will depend on the embedding environment and hardware it runs on. Even at this number of branches, the <code>br_table</code> was still slower on Chrome than <code>if</code> statements. Firefox with about a dozen branches was noticeably faster with the <code>br_table</code> expression.</p>
<h2 id="h1-501737c02-0007">Summary</h2>
<p class="BodyFirst">In this chapter, we covered many of the WAT programming basics. After learning to create and execute a WebAssembly module in Chapter 1, you moved on to creating the traditional hello world application in this chapter. Creating a hello world application is a bit more advanced in WAT than in most programming languages. </p>
<p>After completing a few initial programs, we began looking at some of the basic features of WAT and how they differ from a traditionally high-level language like JavaScript. We explored variables and constants and how they can be pushed onto the stack using WAT commands. We discussed the S-Expression syntax and how to unpack it. We also briefly mentioned indexed local variables and functions, and introduced you to that syntax. You learned the basic branching and looping structures, and how to use them within the WAT syntax. In the next chapter, we’ll explore functions and function tables in WAT, and how they interact with JavaScript and other WAT modules.</p>
</section>
</div></body></html>